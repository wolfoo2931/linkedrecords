/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../structured-text-editor/assets/latex_cheatsheet.js":
/*!************************************************************!*\
  !*** ../structured-text-editor/assets/latex_cheatsheet.js ***!
  \************************************************************/
/***/ ((module) => {

module.exports = `
<div class="latex-eq-tooltip">
Some Examples what you can insert here. You can scroll the list to see more.
<table>
<tr>
<td>
  <div class="markup">e=mc^2</div>
</td>
<td>
  <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>=</mo><mi>m</mi><msup><mi>c</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">e=mc^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.864108em; vertical-align: 0em;"></span><span class="mord mathdefault">m</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.864108em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>
</td>
</tr>
<tr>
<td>
  <div class="markup">y = \\frac{2x^2}{8x}</div>
</td>
<td>
  <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mfrac><mrow><mn>2</mn><msup><mi>x</mi><mn>2</mn></msup></mrow><mrow><mn>8</mn><mi>x</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">y = \\frac{2x^2}{8x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 2.17711em; vertical-align: -0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.49111em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">8</span><span class="mord mathdefault">x</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">2</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.686em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>
</td>
</tr>
<tr>
<td>
  <div class="markup">\\int^{a+1}_{a-1}</div>
</td>
<td>
  <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∫</mo><mrow><mi>a</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>a</mi><mo>+</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding="application/x-tex">\\int^{a+1}_{a-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 2.53429em; vertical-align: -0.970281em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right: 0.44445em; position: relative; top: -0.001125em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.56401em;"><span class="" style="top: -1.78805em; margin-left: -0.44445em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span class="" style="top: -3.8129em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.970281em;"><span class=""></span></span></span></span></span></span></span></span></span></span>
</td>
</tr>
<tr>
<td>
  <div class="markup">\\sum_{i=1}^n a_i</div>
</td>
<td>
  <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\\sum_{i=1}^n a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 2.92907em; vertical-align: -1.27767em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.6514em;"><span class="" style="top: -1.87233em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span class="" style="top: -3.05001em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span><span class="" style="top: -4.30001em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.27767em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>
</td>
</tr>
<tr>
<td>
  <div class="markup">\\big[x\\big]</div>
</td>
<td>
  <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="false">[</mo><mi>x</mi><mo fence="false">]</mo></mrow><annotation encoding="application/x-tex">\\big[x\\big]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.20001em; vertical-align: -0.35001em;"></span><span class="mord"><span class="delimsizing size1">[</span></span><span class="mord mathdefault">x</span><span class="mord"><span class="delimsizing size1">]</span></span></span></span></span></span>
</td>
</tr>
<tr>
<td>
  <div class="markup">\\Big[x\\Big]</div>
</td>
<td>
  <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="false">[</mo><mi>x</mi><mo fence="false">]</mo></mrow><annotation encoding="application/x-tex">\\Big[x\\Big]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.80002em; vertical-align: -0.65002em;"></span><span class="mord"><span class="delimsizing size2">[</span></span><span class="mord mathdefault">x</span><span class="mord"><span class="delimsizing size2">]</span></span></span></span></span></span>
</td>
</tr>
<tr>
<td>
  <div class="markup">\\lim_{h\\to0} \\frac{1}{n}</div>
</td>
<td>
  <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munder><mo><mi>lim</mi><mo>⁡</mo></mo><mrow><mi>h</mi><mo>→</mo><mn>0</mn></mrow></munder><mfrac><mn>1</mn><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">\\lim_{h\\to0} \\frac{1}{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 2.07355em; vertical-align: -0.752108em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.69444em;"><span class="" style="top: -2.34789em; margin-left: 0em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mrel mtight">→</span><span class="mord mtight">0</span></span></span></span><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class=""><span class="mop">lim</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.752108em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.32144em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.686em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>
</td>
</tr>
<tr>
<td>
  <div class="markup">\\sqrt{9} = \\sqrt[2]{9} </div>
</td>
<td>
  <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mn>9</mn></msqrt><mo>=</mo><mroot><mn>9</mn><mn>2</mn></mroot></mrow><annotation encoding="application/x-tex">\\sqrt{9} = \\sqrt[2]{9} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.04em; vertical-align: -0.083905em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.956095em;"><span class="svg-align" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord" style="padding-left: 0.833em;"><span class="mord">9</span></span></span><span class="" style="top: -2.91609em;"><span class="pstrut" style="height: 3em;"></span><span class="hide-tail" style="min-width: 0.853em; height: 1.08em;"><svg width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702
    c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
    c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
    c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
    s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
    c69,-144,104.5,-217.7,106.5,-221
    l0 -0
    c5.3,-9.3,12,-14,20,-14
    H400000v40H845.2724
    s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
    c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
    M834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.083905em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.04em; vertical-align: -0.083905em;"></span><span class="mord sqrt"><span class="root"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.845534em;"><span class="" style="top: -3.02331em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size6 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.956095em;"><span class="svg-align" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord" style="padding-left: 0.833em;"><span class="mord">9</span></span></span><span class="" style="top: -2.91609em;"><span class="pstrut" style="height: 3em;"></span><span class="hide-tail" style="min-width: 0.853em; height: 1.08em;"><svg width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702
    c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
    c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
    c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
    s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
    c69,-144,104.5,-217.7,106.5,-221
    l0 -0
    c5.3,-9.3,12,-14,20,-14
    H400000v40H845.2724
    s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
    c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
    M834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.083905em;"><span class=""></span></span></span></span></span></span></span></span></span>
</td>
</tr>
<tr>
<td>
  <div class="markup">
    \\begin{pmatrix}<br/>
    &nbsp;&nbsp;a && b \\\\<br/>
    &nbsp;&nbsp;c && d<br/>
    \\end{pmatrix}<br/>
  </div>
</td>
<td>
  <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>a</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>b</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>c</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>d</mi></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\\begin{pmatrix}
    a &amp;&amp; b \\\\
    c &amp;&amp; d
  \\end{pmatrix}
  </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 2.40003em; vertical-align: -0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.45em;"><span class="" style="top: -3.61em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span class="" style="top: -2.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.95em;"><span class=""></span></span></span></span></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.45em;"><span class="" style="top: -3.45em;"><span class="pstrut" style="height: 2.84em;"></span><span class="mord"></span></span><span class="" style="top: -2.25em;"><span class="pstrut" style="height: 2.84em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.95em;"><span class=""></span></span></span></span></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.45em;"><span class="" style="top: -3.61em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">b</span></span></span><span class="" style="top: -2.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.95em;"><span class=""></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top: 0em;"><span class="delimsizing size3">)</span></span></span></span></span></span></span>
</td>

<tr>
  <td>
    <div class="markup">
      f=\\begin{cases}<br/>
      0   & c1\\\\<br/>
      1   & c2\\\\<br/>
      2   & c2<br/>
      \\end{cases}<br/>
    </div>
  </td>
  <td>
    <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>c</mi><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>c</mi><mn>2</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>c</mi><mn>2</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">f =
      \\begin{cases}
      0   &amp; c1\\\\
      1   &amp; c2\\\\
      2   &amp; c2
      \\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 4.32em; vertical-align: -1.91em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 2.35002em;"><span class="" style="top: -2.19999em;"><span class="pstrut" style="height: 3.15em;"></span><span class="delimsizinginner delim-size4"><span class="">⎩</span></span></span><span class="" style="top: -2.19499em;"><span class="pstrut" style="height: 3.15em;"></span><span class="delimsizinginner delim-size4"><span class="">⎪</span></span></span><span class="" style="top: -2.20499em;"><span class="pstrut" style="height: 3.15em;"></span><span class="delimsizinginner delim-size4"><span class="">⎪</span></span></span><span class="" style="top: -3.15001em;"><span class="pstrut" style="height: 3.15em;"></span><span class="delimsizinginner delim-size4"><span class="">⎨</span></span></span><span class="" style="top: -4.29501em;"><span class="pstrut" style="height: 3.15em;"></span><span class="delimsizinginner delim-size4"><span class="">⎪</span></span></span><span class="" style="top: -4.30501em;"><span class="pstrut" style="height: 3.15em;"></span><span class="delimsizinginner delim-size4"><span class="">⎪</span></span></span><span class="" style="top: -4.60002em;"><span class="pstrut" style="height: 3.15em;"></span><span class="delimsizinginner delim-size4"><span class="">⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.85002em;"><span class=""></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 2.41em;"><span class="" style="top: -4.41em;"><span class="pstrut" style="height: 3.008em;"></span><span class="mord"><span class="mord">0</span></span></span><span class="" style="top: -2.97em;"><span class="pstrut" style="height: 3.008em;"></span><span class="mord"><span class="mord">1</span></span></span><span class="" style="top: -1.53em;"><span class="pstrut" style="height: 3.008em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.91em;"><span class=""></span></span></span></span></span><span class="arraycolsep" style="width: 1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 2.41em;"><span class="" style="top: -4.41em;"><span class="pstrut" style="height: 3.008em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="mord">1</span></span></span><span class="" style="top: -2.97em;"><span class="pstrut" style="height: 3.008em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="mord">2</span></span></span><span class="" style="top: -1.53em;"><span class="pstrut" style="height: 3.008em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.91em;"><span class=""></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>
  </td>
</tr>
</tr>
</table>
<div>`

/***/ }),

/***/ "../structured-text-editor/lib/declarativ_forms/src/declarativ_form.js":
/*!*****************************************************************************!*\
  !*** ../structured-text-editor/lib/declarativ_forms/src/declarativ_form.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var dl = __webpack_require__(/*! ./dl_select */ "../structured-text-editor/lib/declarativ_forms/src/dl_select.js");
var tippy = (__webpack_require__(/*! tippy.js */ "../structured-text-editor/node_modules/tippy.js/dist/tippy.esm.js")["default"]);
var tippyInstances = new Map();
var modalDialogs = [];

document.addEventListener("keydown", e => {
    if(modalDialogs.length === 0) {
        return;
    }

    lastDialog = modalDialogs[modalDialogs.length - 1];

    if(e.key === 'Escape') {
        lastDialog.escHandler(e)
    } else if(e.key === 'Enter') {
        if(Object.keys(lastDialog.buttons).length === 1) {
            lastDialog.enterHandler(e)
        }
    }
});

function DeclarativForm(attrs, onChangeCallback, onCancelCallback, confirmButtonCaption) {
    var self = this;
    this.fields = attrs.fields
    this.dom = document.createElement('div')
    this.dom.classList.add('dl-form')
    this.formElement = document.createElement('form')
    this.dom.appendChild(this.formElement)
    this.onChangeCallback = onChangeCallback
    this.onCancelCallback = onCancelCallback
    this.buttons = attrs.buttons || { [confirmButtonCaption || 'OK']: { action: onChangeCallback, id: 'confirmBtn-' + Math.round(Math.random()*1000000) }  }
    this.initPromises = {}
    this.allPromises = []

    if(Object.keys(this.buttons).length === 1) {
        this.onChangeCallback = Object.values(this.buttons)[0].action || Object.values(this.buttons)[0]
    }

    if(attrs.classNames) {
        attrs.classNames.forEach(function(name) {
            self.formElement.classList.add(name)
        })
    }

    this.formElement.onsubmit = function(e) {
        e.preventDefault();
        return false;
    }

    this.escHandler = function(e) {
        self.cancelModalIfCancelable()
    }

    this.enterHandler = function(e) {
        var field = self.fields.find(function(f) { return f.name === e.target.name})
        var confirmBtnElID =  Object.values(self.buttons).map(b => b.id).find(id => !!id)
        var confirmBtnEl = document.getElementById(confirmBtnElID)

        if(!field || !field.largetext) {
            if(!confirmBtnEl || !confirmBtnEl.classList.contains('disabled')) {
                self.closeModalIfOpen()
            }

            e.preventDefault()
            e.stopPropagation()
        } else if(!field.allowNewlines) {
            e.preventDefault()
            e.stopPropagation()
        }
    }

    this.fields.forEach((field, fieldIndex) => {
        var fieldWrapper = document.createElement('div'),
            fieldElement, label, allowedValues,
            message, tooltip

        allowedValues = (field.allowedValues instanceof Function) ?
            field.allowedValues() :
            field.allowedValues

        message = (field.message instanceof Function) ?
            field.message() :
            field.message

        fieldWrapper.id = 'dl-form-field-wrapper-for-' + field.name
        fieldWrapper.classList.add('dl-form-field-wrapper')

        if(field.tab) {
            fieldWrapper.classList.add(field.tab.replace(/\s/g, ''))
        }

        if(allowedValues) {
            fieldElement = document.createElement('dl-select')
            fieldWrapper.classList.add('dl-select-wrapper')
            fieldElement.setLoadingStatus()
            self.initPromises[field.name] = Promise.resolve(allowedValues).then(values => {
                values.forEach((val) => {
                    let optEl = document.createElement('dl-option')
                    if(Array.isArray(val)) {
                        optEl.setAttribute('value', val[0])
                        optEl.innerHTML = val[1]
                        if(val[2]) {
                            optEl.setAttribute('displayWhenSelected', val[2])
                        }
                    } else {
                        optEl.innerHTML = val
                    }

                    fieldElement.onchange = () => {
                        self.updateForm(fieldElement)
                    }

                    fieldElement.addOption(optEl)
                })

                fieldElement.unsetLoadingStatus()
            }).catch(_ => {
                fieldElement.unsetLoadingStatus()
            })

            this.allPromises.push(self.initPromises[field.name])
        } else if (field.message) {
            fieldElement = document.createElement('p')
            fieldElement.classList.add('message')
            fieldElement.innerHTML = field.message
        } else if (field.arrayOf) {
            fieldElement = document.createElement('div')
            fieldElement.classList.add('array-of')
            fieldElement.setValue = (value) => {
                fieldElement.value = value
                self.updateForm(fieldElement)
            }

            field.render = (dom, formData) => {
                dom.innerHTML = ''

                let renderEntry = field.renderEntry || (obj => Object.values(obj).filter(val => (typeof val === 'string') && val.trim() !== '').join(', '))

                if(field.suggested) {
                    let suggestedContainer = document.createElement('div')
                    suggestedContainer.classList.add('dl-form-array-suggested-container')
                    let suggestedEntries = typeof field.suggested === 'function' ?
                        field.suggested(formData, modalDialogs.map(d => d.getValues())) :
                        field.suggested;

                    (suggestedEntries || []).forEach((suggestedEntry, fieldIndex) => {
                        checkboxEl = document.createElement('span')

                        let cb = document.createElement('input')
                        cb.id = 'field-' + fieldIndex
                        cb.setAttribute('type', 'checkbox')
                        cb.oninput = cb.onchange = () => {
                            field.domElement.acceptedSuggestions = field.domElement.acceptedSuggestions || [];

                            checkboxEl.setAttribute('value', cb.checked)

                            if(cb.checked) {
                                field.domElement.acceptedSuggestions.push([suggestedEntry, fieldIndex])
                            } else {
                                field.domElement.acceptedSuggestions = field.domElement.acceptedSuggestions.filter(x => x[1] !== fieldIndex)
                            }
                        }

                        let labelEl = document.createElement('label')
                        labelEl.setAttribute('for', 'field-' + fieldIndex)
                        labelEl.innerHTML = renderEntry(suggestedEntry)

                        checkboxEl.classList.add('check')
                        checkboxEl.classList.add('dl-form-array-of-suggestion')
                        checkboxEl.appendChild(cb)
                        checkboxEl.appendChild(labelEl)
                        checkboxEl.setAttribute('value', false)
                        checkboxEl.jsonValue = suggestedEntry

                        suggestedContainer.appendChild(checkboxEl)

                        return checkboxEl
                    })

                    dom.appendChild(suggestedContainer)
                }

                const getConfirmButton = action => ({
                    'OK': {
                        action,
                        id: 'addIntegration',
                        isActive: formData => field.isValidRecord ? field.isValidRecord(formData, self) : true,
                    }
                })

                dom.value && dom.value.forEach && dom.value.forEach((entryObj, elIndex) => {
                    let entryEl = document.createElement('div')
                    let deleteElBtn = document.createElement('button')
                    let editElBtn = document.createElement('button')
                    deleteElBtn.innerHTML = 'Remove'
                    editElBtn.innerHTML = 'Edit'
                    entryEl.innerHTML = '<span>' + renderEntry(entryObj) + '</span>'
                    entryEl.dataset.ElIndex = elIndex
                    entryEl.classList.add('dl-form-array-of-entry')

                    entryEl.appendChild(editElBtn)
                    entryEl.appendChild(deleteElBtn)

                    deleteElBtn.classList.add('delete-array-of-btn')

                    editElBtn.classList.add('edit-array-of-btn')
                    editElBtn.dataset.ElIndex = elIndex
                    editElBtn.onclick = e => {
                        e.preventDefault()

                        let editFieds = field.arrayOf.map(field => {
                            return {
                                ...field,
                                defaultValue: dom.value[deleteElBtn.dataset.ElIndex][field.name] || ''
                            };
                        })

                        new DeclarativForm({ classNames: [`form-for-array-of-${field.name}`], fields: editFieds, buttons: getConfirmButton(formData => {
                            dom.value = dom.value || []
                            dom.value[deleteElBtn.dataset.ElIndex] = formData
                            dom.setValue(dom.value)
                            if(field.onChange) {
                                Promise.allSettled(this.allPromises).then(() => field.onChange(this.getValues()))
                            }
                        }) }, () => {}, () => {}).openInModal()
                    }

                    deleteElBtn.dataset.ElIndex = elIndex
                    deleteElBtn.onclick = e => {
                        dom.value.splice(deleteElBtn.dataset.ElIndex, 1)
                        dom.setValue(dom.value)
                        e.preventDefault()
                        if(field.onChange) {
                            Promise.allSettled(this.allPromises).then(() => field.onChange(this.getValues()))
                        }
                    }

                    dom.appendChild(entryEl)
                })

                let addButton = document.createElement('button')
                addButton.classList.add('dl-form-array-of-add-entry')
                addButton.innerHTML = field.newButtonLabel || 'Add'

                addButton.onclick = e => {
                    new DeclarativForm({ classNames: [`form-for-array-of-${field.name}`], fields: field.arrayOf, buttons: getConfirmButton(formData => {
                        dom.value = dom.value || []
                        dom.value.push(formData)
                        dom.setValue(dom.value)
                        if(field.onChange) {
                            Promise.all(this.allPromises).then(() => field.onChange(this.getValues()))
                        }
                    })}, () => {}, () => {}).openInModal()

                    e.preventDefault()
                }

                dom.appendChild(addButton)
            }

            field.render(fieldElement, self.formData, self)
        } else if (field.render) {
            fieldElement = document.createElement('p')
            fieldElement.classList.add('render')

            fieldElement.onChange = function (forceFormUpdate) {
                self.updateForm(fieldElement, forceFormUpdate);
            }

            field.render(fieldElement, self.formData, self)
        } else if (field.largetext) {
            fieldElement = document.createElement('textarea')
            fieldElement.oninput = fieldElement.onchange = function() {
                self.updateForm(fieldElement);
            }
        } else if (field.check) {
            fieldElement = document.createElement('span')

            let cb = document.createElement('input')
            cb.id = 'field-' + fieldIndex
            cb.setAttribute('type', 'checkbox')
            cb.oninput = cb.onchange = function() {
                fieldElement.setAttribute('value', cb.checked)
                self.updateForm(cb);
            }

            let labelEl = document.createElement('label')
            labelEl.setAttribute('for', 'field-' + fieldIndex)
            labelEl.innerHTML = field.check

            fieldElement.classList.add('check')
            fieldElement.appendChild(cb)
            fieldElement.appendChild(labelEl)
            fieldElement.setAttribute('value', typeof field.defaultValue === 'function' ? field.defaultValue(self.formData) : field.defaultValue)
            fieldElement.setValue = function(val) {
                cb.checked = !!val
            }
        } else if (field.detailedOptions) {
            fieldElement = document.createElement('div')
            fieldElement.classList.add('detailed-options')

            field.detailedOptions.forEach(function(option) {
                var optionEl = document.createElement('div');
                optionEl.classList.add('detailed-option');

                optionEl.innerHTML = option.html;
                optionEl.setAttribute('data-value', option.value);

                optionEl.addEventListener("click", function() {
                    fieldElement.value = option.value;
                    fieldElement.querySelectorAll('.detailed-option').forEach(function(option) {
                        option.classList.remove('active');
                    });

                    optionEl.classList.add('active');
                    self.updateForm(optionEl);
                });

                fieldElement.appendChild(optionEl)
                fieldElement.setValue = function(val) {
                    var el = fieldElement.querySelector(`div[data-value="${val}"]`);

                    if(!el) {
                        return;
                    }

                    fieldElement.value = val;
                    fieldElement.querySelectorAll('.detailed-option').forEach(function(option) {
                        option.classList.remove('active');
                    });

                    el.classList.add('active');
                }
            });
        } else if (field.calculate) {
            fieldElement = document.createElement('input')
            fieldElement.type = 'hidden'
        } else {
            fieldElement = document.createElement('input')
            fieldElement.setValue = function(val) {
                fieldElement.value = val;
            }

            if(field.inputType) {
                fieldElement.setAttribute('type', field.inputType);
            }

            if(field.autocomplete) {
                fieldElement.setAttribute('autocomplete', field.autocomplete);
            }

            if(field.placeholder) {
                fieldElement.placeholder = field.placeholder;
            }

            fieldElement.oninput = fieldElement.onchange = function() {
                self.updateForm(fieldElement);
            }
        }

        field.domElement = fieldElement
        fieldElement.name = field.name
        fieldElement.setAttribute('name', field.name)

        if(field.displayName) {
            label = document.createElement('label')
            label.innerHTML = field.displayName
            label.setAttribute('for', field.name)
            fieldWrapper.appendChild(label)
        } else {
            fieldWrapper.classList.add('withoutLabel')
        }

        if(field.tooltip) {
            tooltip = document.createElement('span')
            tooltip.dataset['tippyContent'] = field.tooltip.text || field.tooltip
            tooltip.dataset['initialTippyContent'] = field.tooltip.text || field.tooltip
            tooltip.classList.add('dl-tooltip')
            tooltip.innerHTML = '?'

            if(label && !field.tooltip.inInput) {
                label.appendChild(tooltip)
            } else {
                tooltip.classList.add('dl-tooltip-in-input')
                fieldElement.classList.add('dl-tooltip-inside')
                fieldWrapper.appendChild(tooltip)
            }
        }

        if(fieldElement.type === 'hidden') {
            fieldWrapper.classList.add('dl-form-hidden-field')
        }

        fieldWrapper.appendChild(fieldElement)
        self.dom.children[0].appendChild(fieldWrapper)

        if(field.defaultValue) {
            this.allPromises.push(Promise.resolve(self.initPromises[field.name]).then(_ => {
                let tmpDefaultValue = typeof field.defaultValue === 'function' ? field.defaultValue(self.formData) : field.defaultValue

                if(fieldElement.setValue) {
                    fieldElement.setValue(tmpDefaultValue)
                } else if (fieldElement.tagName === 'INPUT' || fieldElement.tagName === 'TEXTAREA') {
                    fieldElement.value = tmpDefaultValue
                } else {
                    fieldElement.setAttribute('value', tmpDefaultValue)
                }
            }))
        }
    })

    Promise.allSettled(this.allPromises).then(_ => self.updateForm())
}

DeclarativForm.prototype = {

    updateForm: function(triggerElement, forceFormUpdate) {
        var formData = this.getValues();
        var self = this
        var triggerFieldName = triggerElement && triggerElement.name

        if(this._lastFromUpdatSate === JSON.stringify(formData) && !forceFormUpdate) {
            return;
        }

        this._lastFromUpdatSate = JSON.stringify(formData)

        this.fields.forEach(field => {
            var shouldReload = (!triggerFieldName || (field.reloadOnChangeOf && field.reloadOnChangeOf.includes(triggerFieldName)))

            if(!field.domElement) {
                return;
            }

            if(field.isActive) {
                let tmpIsActive = field.isActive(formData, modalDialogs.map(d => d.getValues()))
                if(tmpIsActive) {
                    field.domElement.parentElement.classList.remove('inactive')
                } else {
                    field.domElement.parentElement.classList.add('inactive')
                }
            }

            if(field.onFormChange) {
                field.onFormChange(formData, self, triggerElement)
            }

            if(field.render) {
                field.render(field.domElement, formData, self)
            }

            if(field.allowedValues instanceof Function && shouldReload) {
                const allowedValues = field.allowedValues(formData)
                field.domElement.setLoadingStatus()
                this.allPromises.push(allowedValues)

                Promise.resolve(allowedValues).then(values => {
                    this.resetTooltip(field.name)
                    field.domElement.removeAllOptions()

                    values && values.forEach((val) => {
                        let optEl = document.createElement('dl-option')
                        if(Array.isArray(val)) {
                            optEl.setAttribute('value', val[0])
                            optEl.innerHTML = val[1]
                            if(val[2]) {
                                optEl.setAttribute('displayWhenSelected', val[2])
                            }
                        } else {
                            optEl.innerHTML = val
                        }

                        field.domElement.onchange = function() {
                            self.updateForm(field.domElement)
                        }

                        field.domElement.addOption(optEl)
                    })

                    field.domElement.unsetLoadingStatus()
                    field.domElement.setValue(field.domElement.getValue())
                }).catch(err => {
                    field.domElement.unsetLoadingStatus()
                    if(field.onValuesCalculationFailedMessage) {
                        const message = field.onValuesCalculationFailedMessage(formData, err);
                        if(message.level === 'info') {
                            this.setTooltipWarning(field.name, message.text)
                        } else if(message.level === 'warning') {
                            this.setTooltipWarning(field.name, message.text)
                        } else if(message.level === 'error') {
                            this.setTooltipError(field.name, message.text)
                        }
                    }
                })
            }
        });

        Promise.allSettled(this.allPromises).then(() => {
            formData = this.getValues();

            Object.values(this.buttons)
                .filter(btn => (btn.isActive && btn.id))
                .forEach(btn => {
                    let buttonEl = document.getElementById(btn.id)
                    if(!buttonEl) return;

                    buttonEl.classList.add('disabled')

                    let isActiveCheckPrmise = btn.isActive(formData)
                    this.allPromises.push(isActiveCheckPrmise)

                    Promise.resolve(isActiveCheckPrmise)
                        .then(BtnIsActive => {
                            if(BtnIsActive) {
                                buttonEl.classList.remove('disabled')
                            } else {
                                buttonEl.classList.add('disabled')
                            }
                        })
                });
        })
    },

    updateCalculatedFields(triggerFieldName, formData) {
        return Promise.allSettled(this.fields.map(field => new Promise(done => {
            var shouldReload = (!triggerFieldName || (field.reloadOnChangeOf && field.reloadOnChangeOf.includes(triggerFieldName)))

            if(field.calculate && shouldReload) {
                return Promise.allSettled(this.allPromises).then(() => {
                    const thisUpdatePromise = field.calculate(formData || this.getValues())
                    this.allPromises.push(thisUpdatePromise)
                    return Promise.resolve(thisUpdatePromise).then(v => {
                        field.domElement._value = v
                        done()
                    })
                })
            } else {
                done()
            }
        })))
    },

    getHTML: function() {
        return this.dom.outerHTML;
    },

    openInModal: function(attr) {
        modalDialogs.push(this);

        this.modalEl = this.modalEl || this.createModalElement(attr)

        var modalContent = this.modalEl.querySelector('.modal-content')
        var modalWindow = this.modalEl.querySelector('.modal')

        this.updateTabs()
        modalContent.appendChild(this.dom)
        this.modalEl.style.display = 'block'

        if(attr && attr.classNames) {
            attr.classNames.forEach(function(name) {
                modalWindow.classList.add(name)
            })
        }

        this.updateTooltips();

        if(modalDialogs.length >= 2) {
            modalDialogs[modalDialogs.length-2].hide()
        }
    },

    appendInElement: function(el, attr) {
        var self = this
        this.modalEl = this.modalEl || this.createModalElement(attr, true)
        this.modalEl.style.display = 'block'

        var modalContent = this.modalEl.querySelector('.modal-content')

        this.modalEl.classList.add('noModalDialog')

        if(attr && attr.classNames) {
            attr.classNames.forEach(function(name) {
                self.modalEl.classList.add(name)
            })
        }

        modalContent.appendChild(this.dom)
        el.appendChild(this.modalEl)
        this.updateTabs()

        this.updateTooltips()
    },

    hide: function() {
        this.modalEl && this.modalEl.classList.add('dl-modal-hidden')
    },

    show: function() {
        this.modalEl && this.modalEl.classList.remove('dl-modal-hidden')
    },

    updateTooltips: function(sel) {
        sel = sel || '[data-tippy-content]';

        var domElements = document.querySelectorAll(sel);

        domElements.forEach(el => {
            if(tippyInstances.get(el)) {
                tippyInstances.get(el).forEach(el => el.destroy());
                tippyInstances.delete(el);
            }
        })

        var tippies = tippy(sel, {
            placement: 'right',
            allowHTML: true,
            interactive: true
        })

        tippies.forEach(tippy => {
            if(tippyInstances.get(tippy.reference)) {
                tippyInstances.get(tippy.reference).push(tippy)
            } else {
                tippyInstances.set(tippy.reference, [tippy]);
            }
        });
    },

    setTooltip: function(fieldName, text, iconContent, className) {
        className = className || '';
        var tooltipSelector = `#dl-form-field-wrapper-for-${fieldName} .dl-tooltip`;
        var tooltipEl = document.querySelector(tooltipSelector);

        if(tooltipEl.classList.value.includes('dl-tooltip-in-input')) {
            tooltipEl.classList.value = `dl-tooltip dl-tooltip-in-input ${className}`;
        } else {
            tooltipEl.classList.value = `dl-tooltip ${className}`;
        }

        tooltipEl.dataset['tippyContent'] = text;
        tooltipEl.innerHTML = iconContent;

        this.updateTooltips(tooltipSelector);
    },

    setTooltipSuccess: function(fieldName, text) {
        this.setTooltip(fieldName, text, '&#10003;', 'tooltip-success')
    },

    setTooltipWarning: function(fieldName, text) {
        this.setTooltip(fieldName, text, '!', 'tooltip-warning');
    },

    setTooltipError: function(fieldName, text) {
        this.setTooltip(fieldName, text, '!', 'tooltip-error');
    },

    resetTooltip: function(fieldName) {
        var tooltipEl = document.querySelector(`#dl-form-field-wrapper-for-${fieldName} .dl-tooltip`);

        if(tooltipEl) {
            this.setTooltip(fieldName, tooltipEl.dataset['initialTippyContent'], '?', '');
        }
    },

    resetTooltips: function(fieldNames) {
        fieldNames.forEach(fieldName => this.resetTooltip(fieldName))
    },

    updateTabs: function() {
        var tabsWrapper = this.modalEl.querySelector('.tabWrapper'),
            tabs = this.fields.filter(f => f.tab).map(f => f.tab).filter((value, index, self) => self.indexOf(value) === index),
            self = this, tmpTabEl

        tabsWrapper.innerHTML = ''

        tabs.forEach((tab) => {
            tmpTabEl = document.createElement('div')
            tmpTabEl.classList.add('dl-tab-btn')
            tmpTabEl.classList.add(tab.replace(/\s/g, ''))
            tmpTabEl.innerHTML = tab
            tmpTabEl.onclick = function() {
                self.setActiveTab(tab)
            }
            tabsWrapper.appendChild(tmpTabEl)
        })

        if(tabs[0]) {
            this.setActiveTab(tabs[0])
        }
    },

    setActiveTab: function(tab) {
        if(!tab) {
            tab = this.activeTab
        }

        var tabClassName = tab.replace(/\s/g, ''),
            currentActiveTabBtn = document.querySelector('.dl-tab-btn.active'),
            tabBtn = document.querySelector('.dl-tab-btn.' + tabClassName)

        if(currentActiveTabBtn) {
            currentActiveTabBtn.classList.remove('active')
        }

        tabBtn.classList.add('active')

        this.activeTab = tab;
        this.fields.forEach(field => {
            if(!field.domElement) { return }
            if(field.tab === tab) {
                field.domElement.parentElement.classList.remove('notInTab')
            } else {
                field.domElement.parentElement.classList.add('notInTab')
            }
        })
    },

    deleteFromStack: function() {
        modalDialogs = modalDialogs.filter(dia => dia !== this)
    },

    cancelModalIfCancelable: function() {
        if(this.onCancelCallback) {
            if(this.modalEl) {
                this.modalEl.remove()
                this.modalEl = null
            }

            this.onCancelCallback()
            this.deleteFromStack()

            if(modalDialogs.length) {
                modalDialogs[modalDialogs.length-1].show()
                modalDialogs[modalDialogs.length-1].setActiveTab()
            }
        }
    },

    closeModalIfOpen: function(callaback) {
        callaback = callaback || this.onChangeCallback

        if(this.modalEl) {
            this.modalEl.remove()
            this.modalEl = null
        }

        if(callaback) {
            callaback(this.getValues())
        }

        this.deleteFromStack()

        if(modalDialogs.length) {
            modalDialogs[modalDialogs.length-1].show()
            modalDialogs[modalDialogs.length-1].setActiveTab()
        }
    },

    getValues: function() {
        var result  = {}

        //TODO: filter calculated fields
        this.fields.filter(function(field) {
            return field.domElement && !field.domElement.parentElement.classList.contains('inactive')
        }).forEach(function(field) {
            if(!field.domElement) { return }
            result[field.name] = field.domElement.getAttribute('value') || field.domElement._value || field.domElement.value

            if(field.domElement.acceptedSuggestions) {
                result[field.name] = result[field.name] || [];
                field.domElement.acceptedSuggestions
                    .map(el => el[0])
                    .forEach(candidate => {
                        if(!result[field.name].find(processed => JSON.stringify(candidate) === JSON.stringify(processed))) {
                            result[field.name].push(candidate)
                        }
                    })
            }

            if(!result[field.name]) {
                result[field.name] = ''
            }

            if(field.check) {
                result[field.name] = result[field.name] === 'true'
            }
        })

        result.activeTab = this.activeTab;
        return result
    },

    createModalElement: function(attr, doNotMount) {

        attr = attr || {}
        attr.classNames = attr.classNames || []

        var modalWrapper = document.createElement('div'),
            modal = document.createElement('div'),
            modalContent = document.createElement('div'),
            lowBar = document.createElement('div'),
            upBar  = document.createElement('div'),
            cancelBtn = document.createElement('div'),
            tabWrapper = document.createElement('div'),
            tmpBtn

        modalWrapper.classList.add('dl-modal')
        modalWrapper.style.display = 'none'
        modal.classList.add('modal')
        modalContent.classList.add('modal-content')
        tabWrapper.classList.add('tabWrapper')
        lowBar.classList.add('low-bar')

        Object.keys(this.buttons).forEach((btn => {
            let callback = typeof this.buttons[btn] === 'function' ? this.buttons[btn] : this.buttons[btn].action
            tmpBtn = document.createElement('div')
            tmpBtn.classList.add('btn')
            tmpBtn.innerHTML = btn

            if(this.buttons[btn].id) {
                tmpBtn.id = this.buttons[btn].id
            }

            tmpBtn.onclick = (event) => {
                const classes = event.target.classList

                if(classes.contains('loading-btn') || classes.contains('disabled')) {
                    return
                }

                Promise.allSettled(this.allPromises).then(() => {
                    if(!classes.contains('disabled')) {
                        this.updateCalculatedFields().then(() => {
                            this.closeModalIfOpen(callback)
                            classes.remove('loading-btn')
                        })
                    }
                })
            }

            lowBar.appendChild(tmpBtn)
        }))

        if(this.onCancelCallback) {
            upBar.classList.add('up-bar')
            cancelBtn.classList.add('cancelBtn')
            cancelBtn.onclick = () => { this.cancelModalIfCancelable() }
            upBar.appendChild(cancelBtn)
        }

        modalWrapper.appendChild(modal)
        modal.appendChild(upBar)
        modal.appendChild(tabWrapper)
        modal.appendChild(modalContent)
        modal.appendChild(lowBar)

        if(!doNotMount) {
            document.body.appendChild(modalWrapper)
        }

        return modalWrapper
    }
}

module.exports = DeclarativForm


/***/ }),

/***/ "../structured-text-editor/lib/declarativ_forms/src/dl_select.js":
/*!***********************************************************************!*\
  !*** ../structured-text-editor/lib/declarativ_forms/src/dl_select.js ***!
  \***********************************************************************/
/***/ (() => {

var style = document.createElement('style'),
    xmlns = 'http://www.w3.org/2000/svg'

style.textContent = `
    @keyframes placeHolderShimmer{
        0%{
            background-position: -468px 0
        }
        100%{
            background-position: 468px 0
        }
    }

    dl-select {
        position: relative;
        font-weight: 300;
        font-family: 'Rubik', sans-serif;
    }

    dl-select .input-wrapper {
        display: inline-block;
        border: 2px solid #ddd;
        border-radius: 4px;
    }

    dl-select.dl-focused .input-wrapper {
        border: 2px solid #bbb;
    }

    dl-select.dl-focused .input-wrapper svg {
        border-left: 1px solid #bbb;
        fill: #bbb;
    }

    dl-select .options-wrapper {
        position: absolute;
        left: 0px;
        top: 20px;
        font-size: 0.9em;
        background-color: #fff;
        width: 100%;
        max-height: 230px;
        overflow: scroll;
        box-shadow: 0px 0px 10px -2px rgba(0,0,0,0.4);
        z-index: 100;
    }

    dl-select .options-wrapper dl-option {
        border-left: 1px solid #bbb;
        border-right: 1px solid #bbb;
        cursor: pointer;
    }

    dl-select .options-wrapper .noMatchesHint {
        border-left: 1px solid #bbb;
        border-right: 1px solid #bbb;
        padding: 5px;
        font-style: italic;
    }

    dl-select .options-wrapper {
        border-top: 1px solid #bbb;
        border-bottom: 1px solid #bbb;
        border-radius: 4px;
    }

    dl-select .input-wrapper input {
        width: 371px;
        outline-width: 0;
        margin-top: 2px;
        padding: 6px;
        font-size: 0.9em;
        font-family: 'Rubik', sans-serif;
        font-weight: 300;
        border: 0px;
        border-radius: 4px;
        float: left;
        cursor: pointer;
        box-sizing: content-box;
    }

    dl-select .input-wrapper svg {
        width: 20px;
        height: 20px;
        margin-top: 5px;
        margin-right: 4px;
        padding-left: 4px;
        fill: #ddd;
        float: right;
        border-left: 1px solid #ddd;
        cursor: pointer;
    }

    dl-select .options-wrapper dl-option {
        display: block;
        padding: 5px;
        color: #545454;
    }

    dl-select .options-wrapper dl-option:hover {
        background-color: rgba(224, 240, 227, 0.4);
    }

    dl-select .options-wrapper dl-option.dl-focused {
        background-color: rgba(224, 240, 227, 0.4);
    }

    dl-select .dl-option-tag {
        float: right;
        border: 1px solid #888;
        font-size: 0.8em;
        padding: 2px;
        font-family: 'Source Code Pro', monospace;
        border-radius: 2px;
        margin-top: -1px;
    }

    dl-select .dl-option-tag:last-child {
       margin-right: 10px;
    }

    .dl-select-loading {

    }

    .dl-select-no-options-available svg path {
        display: none;
    }

    .dl-select-no-options-available svg {
        border-left: none !important;
    }

    .dl-select-loading svg, .dl-select-no-options-available svg {
        pointer-events: none;
    }

    .dl-select-loading input, .dl-select-no-options-available input {
        pointer-events: none;
    }

    body.dark-theme dl-select {
        --dl-select-loading-col1: #282727;
        --dl-select-loading-col2: #505656;
    }

    dl-select {
        --dl-select-loading-col1: #eeeeee;
        --dl-select-loading-col2: #dddddd;
    }

    .dl-select-loading .input-wrapper {
        animation-duration: 1.25s;
        animation-fill-mode: forwards;
        animation-iteration-count: infinite;
        animation-name: placeHolderShimmer;
        animation-timing-function: linear;
        background: darkgray;
        background: linear-gradient(to right, var(--dl-select-loading-col1) 10%, var(--dl-select-loading-col2) 18%, var(--dl-select-loading-col1) 33%);
        background-size: 800px 104px;
        position: relative;
        width: 412px;
        height: 31px;
    }
    .dl-select-loading input {
        display: none;
    }
`

window.addEventListener('load', () => {
    document.body.appendChild(style)
})

class DlSelect extends HTMLElement {
    constructor() {
        super()
        this.loadingScreenTimeouts = []
        this.loadingStartedAt = undefined
        this.optionsWrapper = document.createElement('div')
        this.inputWrapper = document.createElement('span')
        this.noMatchesHint = document.createElement('span')
        this.inputField = document.createElement('input')
        this.arrow = document.createElementNS(xmlns, 'svg')
    }

    connectedCallback() {
        var self = this

        if(this.isInitialized) { return }

        this.inputWrapper.classList.add('input-wrapper')
        this.optionsWrapper.classList.add('options-wrapper')
        this.optionsWrapper.style.display = 'none'
        this.inputField.placeholder = 'Select ...'
        this.noMatchesHint.classList.add('noMatchesHint')
        this.noMatchesHint.innerHTML = 'No Matches'
        this.noMatchesHint.style.display = 'none'
        this.inputField.onfocus = () => { self.focus() }
        this.inputField.onblur = (e) => { self.unfocus() }
        this.inputField.oninput = () => { self.filterOptions(this.inputField.value) }
        this.arrow.onclick = () => { self.inputField.focus() }
        this.arrow.innerHTML = '<path d="M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"></path>'

        this.optionsWrapper.appendChild(this.noMatchesHint)

        this.classList.add('dl-select-no-options-available')

        if (document.readyState !== 'loading') {
            this.loadOptions()
        } else {
            window.addEventListener('load', () => {self.loadOptions()})
        }

        this.addEventListener("keydown", (e) => {
            var option = self.focusedOption()
            if(e.key === 'ArrowDown') {
                self.focusOption(self.nextVisibleOptionAfter(option))
                e.preventDefault()
                e.stopPropagation()
            } else if(e.key === 'ArrowUp') {
                self.focusOption(self.previousVisibleOptionAfter(option))
                e.preventDefault()
                e.stopPropagation()
            } else if(e.key === 'Enter') {
                self.setOption(option)
                self.unfocus()
                e.preventDefault()
                e.stopPropagation()
            }
        })

        this.isInitialized = true;
    }

    setLoadingStatus() {
        this.loadingScreenTimeouts.push(setTimeout(() => {
            this.classList.add('dl-select-loading')
            this.optionsWrapper.remove()
            this.loadingStartedAt = Date.now()
        }, 100))
    }

    unsetLoadingStatus() {
        this.loadingScreenTimeouts.forEach(clearTimeout)
        this.loadingScreenTimeouts = []

        const minLoadTimeInSeconds = 1.5
        const delay = this.loadingStartedAt ?
            (minLoadTimeInSeconds * 1000) - (Date.now() - this.loadingStartedAt)
            : 0

        setTimeout(() => {
            this.appendChild(this.optionsWrapper)
            this.classList.remove('dl-select-loading')
        }, delay)
    }

    loadOptions() {
        var self = this
        while(self.firstElementChild) {
            self.firstElementChild.onmousedown = function() { self.setOption(this) }
            self.firstElementChild.onmouseover = function() { self.clearFocusedOption() }
            self.optionsWrapper.appendChild(self.firstElementChild)
        }

        self.inputWrapper.appendChild(self.inputField)
        self.inputWrapper.appendChild(self.arrow)
        self.appendChild(self.inputWrapper)
        self.appendChild(self.optionsWrapper)
        self.setValue(self.getValue())
        this.updatePlaceholderText()
    }

    removeAllOptions() {
        this.classList.add('dl-select-no-options-available')
        this.querySelectorAll('dl-option').forEach(opt => opt.remove())
        this.updatePlaceholderText()
    }

    addOption(optionEl) {
        var self = this

        optionEl.onmousedown = function() { self.setOption(this) }
        optionEl.onmouseover = function() { self.clearFocusedOption() }
        self.optionsWrapper.appendChild(optionEl)

        this.classList.remove('dl-select-no-options-available')
        this.updatePlaceholderText()
    }

    clearFocusedOption() {
        this._focusedOption = null
        Array.prototype.forEach.call(this.optionsWrapper.children, (opt) => {
            opt.classList.remove('dl-focused')
        })
    }

    focusedOption() {
        return this._focusedOption
    }

    focusOption(option) {
        option = option || this.nextVisibleOptionAfter(option)

        this.clearFocusedOption()

        this._focusedOption = option
        if(option) {
            option.classList.add('dl-focused')
        }
    }

    nextVisibleOptionAfter(option) {
        option = option || this.optionsWrapper.children[0]
        while(option) {
            if(option.nextSibling && option.nextSibling.style.display !== 'none') {
                return option.nextSibling
            }

            option = option.nextSibling
        }
    }

    previousVisibleOptionAfter(option) {
        option = option || this.optionsWrapper.children[0]
        while(option) {
            if(option.previousSibling && option.previousSibling.style.display !== 'none') {
                return option.previousSibling
            }

            option = option.previousSibling
        }
    }

    filterOptions(str) {
        var hasMatched = false;
        str = str.toLowerCase()

        Array.prototype.forEach.call(this.optionsWrapper.children, (opt) => {
            if(str === '' || str.split(' ').every(term => opt.innerText.toLowerCase().includes(term))) {
                opt.style.display = 'block'
                hasMatched = true
            } else {
                opt.style.display = 'none'
            }
        })

        this.noMatchesHint.style.display = hasMatched ? 'none' : 'block'
    }

    setValue(val) {
        if(!val) {
            return
        }

        var option = this.querySelector('dl-option[value="'+val+'"]') ||
                     Array.prototype.find.call(this.querySelectorAll('dl-option'), function(el) {return el.innerText == val})

        this.setAttribute('tmp-value', val)
        this.setOption(option)
    }

    setOption(optionEl) {
        if(!optionEl) { return false }

        this.selectedOptionEl = optionEl
        this.inputField.value = this.getDisplayedText()
        this.setAttribute('value', optionEl.getAttribute('value') || optionEl.innerText)

        var evt = document.createEvent("HTMLEvents")
        evt.initEvent("change", false, true)
        this.dispatchEvent(evt)
    }

    getDisplayedText() {
        if(this.selectedOptionEl) {
            return this.selectedOptionEl.getAttribute('displayWhenSelected') || this.selectedOptionEl.innerText
        } else {
            return ''
        }
    }

    getPlaceholderText() {
        if (this.optionsWrapper.querySelectorAll('dl-option').length === 0) {
            return 'No Options Available'
        } else if(this.selectedOptionEl) {
            return this.selectedOptionEl.innerText
        } else {
            return 'Select ...'
        }
    }

    updatePlaceholderText() {
        this.inputField.placeholder = this.getPlaceholderText()
    }

    getValue() {
        if(this.getAttribute('value')) {
            return this.getAttribute('value')
        }

        var tmpValue = this.getAttribute('tmp-value')
        var option = this.querySelector('dl-option[value="'+this.getAttribute('tmp-value')+'"]')

        if(option && tmpValue) {
            return tmpValue
        }
    }

    focus() {
        this.classList.add('dl-focused')
        this.updatePlaceholderText()
        this.inputField.value = ''
        this.optionsWrapper.style.display = 'inline-block'
        this.filterOptions(this.inputField.value)
    }

    unfocus() {
        this.classList.remove('dl-focused')
        this.optionsWrapper.style.display = 'none'
        this.inputField.value = this.getDisplayedText()
        this.inputField.blur()
    }
}

customElements.define('dl-select', DlSelect)


/***/ }),

/***/ "../structured-text-editor/lib/documentupdater/documentupdater.js":
/*!************************************************************************!*\
  !*** ../structured-text-editor/lib/documentupdater/documentupdater.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ModificationLogEntry = __webpack_require__(/*! ./modification_log */ "../structured-text-editor/lib/documentupdater/modification_log.js"),
    utils = __webpack_require__(/*! ../pixelschubser/utils */ "../structured-text-editor/lib/pixelschubser/utils.js"),
    diffMatchPatch = __webpack_require__(/*! diff_match_patch */ "../structured-text-editor/node_modules/diff_match_patch/lib/diff_match_patch.js"),
    diffEngine = new diffMatchPatch.diff_match_patch,
    withLookahead = __webpack_require__(/*! ../generatorlookahead */ "../structured-text-editor/lib/generatorlookahead/index.js");

// This creates a vitual DOM for the passed `contentElement`
// Using the updateHTML function of this object provides the following advantages:
// - Passed HTML is sanitized based on the content rules of the `htmlRazor`.
// - It returns a modificationLogEntry which includes the changes made.
// - Only updates the dom fractions that must be changed (optimized
//   for long and quite flat documents)
function Documentupdater(contentElement, htmlRazor) {
    this.contentElement = contentElement;
    this.htmlRazor = htmlRazor;
}

Documentupdater.prototype = {
    updateHTML: function(content, focusedSection, args) {
        args = args || {};

        if(this.contentElement.children.length === 0) {
            this.contentElement.innerHTML = '<p></p>';
        }

        if(args.actor) {
            this.contentElement
                .querySelectorAll('.focused-by-api-actor' + args.actor.id + '-fbaaend')
                .forEach(el => el.classList.remove('focused-by-api-actor'+ args.actor.id + '-fbaaend'))
        }

        this.modificationLogEntry = args.modificationLogEntry || new ModificationLogEntry();
        this.modificationLogEntry.insertedBeforeSelectionRangeStart = 0;
        this.modificationLogEntry.insertedBeforeSelectionRangeEnd = 0;

        var firstSectionToUpdate = args.section || args.startSection || this.contentElement.children[0],
            lastSectionToUpdate =  args.section || args.endSection || this.contentElement.children[this.contentElement.children.length-1],
            newSectionStream,
            pairStream,
            lastUpdatedSection,
            pair;

        if(args.startSection &&
           args.endSection &&
        //    this.contentElement.children[0] !== args.startSection &&
        //    this.contentElement.children[this.contentElement.children.length-1] !== args.endSection &&
           content !== undefined &&
           content !== null &&
           content.trim() === '') {
            pairStream = this._deleteOldSectionsPairStream(firstSectionToUpdate, lastSectionToUpdate);
        } else {
            newSectionStream = this.htmlRazor.cleanupHTMLAndAttachEventHandlers(content, this.modificationLogEntry);
            pairStream = this._oldAndNewSectionPairStream(newSectionStream, firstSectionToUpdate, lastSectionToUpdate);
        }

        this.focusedSection = focusedSection;
        this.modificationLogEntry.retainAllSectionsBefore(firstSectionToUpdate);

        while(pair = pairStream.next().value) {
            if(pair.old && pair.new) {
                lastUpdatedSection = this._replaceSections(pair.old, pair.new, args);
            } else if(pair.new) {
                if(lastUpdatedSection) {
                    lastUpdatedSection = this._insertSectionAfter(lastUpdatedSection, pair.new, args);
                } else if(firstSectionToUpdate) {
                    lastUpdatedSection = this._insertSectionBefore(firstSectionToUpdate, pair.new, args);
                } else {
                    lastUpdatedSection = this._insertSectionAtBeginning(pair.new, args);
                }

            } else if(pair.old) {
                this._removeSection(pair.old);
            }

            if(lastUpdatedSection) {
                if(!lastUpdatedSection.wordCount) {
                    lastUpdatedSection.wordCount = lastUpdatedSection
                        .innerText
                        .split(/[\s\.:\?\!']/)
                        .filter(w => w.trim().length > 0)
                        .length;
                }
            }
        }

        this.modificationLogEntry.retainAllSectionsAfter(lastUpdatedSection);

        return this.modificationLogEntry;
    },

    _deleteOldSectionsPairStream: function*(firstSectionToUpdate, lastSectionToUpdate) {
        var nextOldSection = firstSectionToUpdate,
            nextNextOldSection;

        if(firstSectionToUpdate === lastSectionToUpdate) {
            yield { old: firstSectionToUpdate, new: null };
        } else {
            while(nextOldSection) {
                nextNextOldSection = nextOldSection.nextSibling;

                yield { old: nextOldSection, new: null };
                nextOldSection = nextNextOldSection;

                if(nextOldSection === lastSectionToUpdate) {
                    yield { old: nextOldSection, new: null };
                    break;
                }
            }
        }
    },

    _oldAndNewSectionPairStream: function*(newSectionStream, firstSectionToUpdate, lastSectionToUpdate) {
        newSectionStream = withLookahead(newSectionStream)

        var nextOldSection = firstSectionToUpdate,
            nextNextOldSection, nextSectionToBeInserted,
            newSection, nextNewSection;

        while(nextOldSection) {
            nextNextOldSection = nextOldSection.nextSibling;
            newSection = newSectionStream.next().value;
            nextNewSection = newSectionStream.lookahead().value;

            if(!this._areEqualSections(nextOldSection, newSection) &&
               !this._areEqualSections(nextNextOldSection, nextOldSection) &&
               this._areEqualSections(nextOldSection, nextNewSection)
            ) {
                yield { old: undefined, new: newSection };
            } else {
                yield { old: nextOldSection, new: newSection };
                if(nextOldSection === lastSectionToUpdate) { break }
                nextOldSection = nextNextOldSection;
            }
        }

        while(nextSectionToBeInserted = newSectionStream.next().value) {
            yield { old: null, new: nextSectionToBeInserted };
        }
    },

    _removeSection: function(section) {
        if(!section) return false;

        if(section === this.focusedSection) {
            this.modificationLogEntry.focusedSectionHasBeenModified = true;
        }

        this.modificationLogEntry.deleteSection(section);
        return this.contentElement.removeChild(section);
    },

    _insertSectionAtBeginning: function(sectionToInsert, args) {
        if(!sectionToInsert) { return false }

        sectionToInsert.setAttribute('contenteditable', true);

        if(sectionToInsert.onMarkupCleaningFinshed) {
            sectionToInsert.onMarkupCleaningFinshed(sectionToInsert);
        }

        if(args.actor) {
            sectionToInsert.classList.add('focused-by-api-actor' + args.actor.id + '-fbaaend');
        }

        this.modificationLogEntry.insertSection(sectionToInsert);

        if(this.contentElement.children[0]) {
            return this.contentElement.insertBefore(sectionToInsert, this.contentElement.children[0]);
        } else {
            return this.contentElement.appendChild(sectionToInsert);
        }
    },

    _insertSectionAfter: function(predecessorSection, sectionToInsert, args) {
        if(!predecessorSection || !sectionToInsert) { return false }
        sectionToInsert.setAttribute('contenteditable', true);

        if(sectionToInsert.onMarkupCleaningFinshed) {
            sectionToInsert.onMarkupCleaningFinshed(sectionToInsert);
        }

        if(args.actor) {
            sectionToInsert.classList.add('focused-by-api-actor'+ args.actor.id + '-fbaaend');
        }

        this.modificationLogEntry.insertSection(sectionToInsert);
        return this.contentElement.insertBefore(sectionToInsert, predecessorSection.nextSibling);   // if predecessorSection.nextSibling is null, the newNode is inserted at the end of the list of child nodes.
    },

    _insertSectionBefore: function(predecessorSection, sectionToInsert, args) {
        if(!predecessorSection || !sectionToInsert) { return false }
        sectionToInsert.setAttribute('contenteditable', true);

        if(sectionToInsert.onMarkupCleaningFinshed) {
            sectionToInsert.onMarkupCleaningFinshed(sectionToInsert);
        }

        if(args.actor) {
            sectionToInsert.classList.add('focused-by-api-actor'+ args.actor.id + '-fbaaend');
        }

        this.modificationLogEntry.insertSection(sectionToInsert);
        return this.contentElement.insertBefore(sectionToInsert, predecessorSection);   // if predecessorSection.nextSibling is null, the newNode is inserted at the end of the list of child nodes.
    },

    _isSameSectionType: function(section1, section2) {
        if(!section1 || !section2) {
            return false;
        }

        var sameClasses = section1.classList.toString().replace(/focused-by-api-actor.*-fbaaend/g, '').replace(/focused/g, '').replace(/\s/g, '') === section2.classList.toString().replace(/focused-by-api-actor.*-fbaaend/g, '').replace(/focused/g, '').replace(/\s/g, ''),
          sameTags = section1.tagName === section2.tagName;

        return sameTags && sameClasses;
    },

    _getSectionAttributeSigniture: function(section) {
        return JSON.stringify(Object.values(section.attributes)
            .filter(attr => attr.name !== 'class' && attr.name !== 'contenteditable')
            .map(attr => ({ [attr.name]: attr.value })))
    },

    _areEqualSections: function(section1, section2) {
        return this._isSameSectionType(section1, section2) &&
            section1.innerHTML.length === section2.innerHTML.length &&
            this._getSectionAttributeSigniture(section1) === this._getSectionAttributeSigniture(section2) &&
            section1.innerHTML === section2.innerHTML
    },

    _replaceSections: function(oldSection, newSection, args) {
        newSection.setAttribute('contenteditable', true);

        oldSection.summarizedContentLength = undefined;
        newSection.summarizedContentLength = undefined;

        if(this._isSameSectionType(oldSection, newSection)) {
            utils.copyEventListenersRecursively(oldSection, newSection);
        }

        if(newSection.onMarkupCleaningFinshed) {
            newSection.onMarkupCleaningFinshed(newSection);
        }

        if(!this._areEqualSections(newSection, oldSection) || (newSection && newSection.childNodes.length === 0)) {
            this.modificationLogEntry.replaceSection(oldSection, newSection);

            if(args.actor) {
                newSection.classList.add('focused-by-api-actor'+ args.actor.id + '-fbaaend');

                const contentLengthTillSectionStart = args.caret.getContentLengthTillSection(oldSection);
                const diff = diffEngine
                    .diff_main(args.caret._getContentLengthIncrementMaskedText(oldSection), args.caret._getContentLengthIncrementMaskedText(newSection))
                    .flatMap(a => a[1].split('').map(ia => a[0]));

                if(args.caret.rangeStart) {
                    const selectionStartOffsetWithinSection = args.caret.rangeStart - contentLengthTillSectionStart;
                    this.modificationLogEntry.insertedBeforeSelectionRangeStart += diff
                        .slice(0, selectionStartOffsetWithinSection)
                        .reduce((acc, val) => acc + val, 0);
                }

                if(args.caret.rangeEnd && args.caret.rangeEnd !== args.caret.rangeStart) {
                    const selectionStartOffsetWithinSection = args.caret.rangeEnd - contentLengthTillSectionStart;
                    this.modificationLogEntry.insertedBeforeSelectionRangeEnd += diff
                        .slice(0, selectionStartOffsetWithinSection)
                        .reduce((acc, val) => acc + val, 0);
                } else if(args.caret.rangeEnd === args.caret.rangeStart) {
                    this.modificationLogEntry.insertedBeforeSelectionRangeEnd = this.modificationLogEntry.insertedBeforeSelectionRangeStart;
                }
            }

            this.contentElement.replaceChild(newSection, oldSection);

            if(oldSection === this.focusedSection) {
                this.modificationLogEntry.focusedSectionHasBeenModified = true;
                this.modificationLogEntry.focusedSectionReplacement = newSection;
            }

            return newSection;
        } else if(oldSection.originalHTML !== newSection.originalHTML) {
            // we end up in this branch when we simply type text into a section.
            // in this case the actual DOM is already on the actual state, only
            // the originalHTML attribute must be updated.
            this.modificationLogEntry.replaceSection(oldSection, newSection);

            oldSection.originalHTML = newSection.originalHTML;

            Object.keys(this.modificationLogEntry.modLogFlags).forEach(function(flag) {
                oldSection['originalHTMLContains' + flag] = newSection['originalHTMLContains' + flag];
            });

            if(oldSection === this.focusedSection) {
                this.modificationLogEntry.focusedSectionHasBeenModified = true;
                this.modificationLogEntry.focusedSectionDOMWasNotModified = true;
                this.modificationLogEntry.focusedSectionReplacement = newSection;
            }

            oldSection.wordCount = undefined;
            return oldSection;
        }

        this.modificationLogEntry.retainSection(oldSection);
        return oldSection;
    }
}

module.exports = Documentupdater;


/***/ }),

/***/ "../structured-text-editor/lib/documentupdater/modification_log.js":
/*!*************************************************************************!*\
  !*** ../structured-text-editor/lib/documentupdater/modification_log.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var diffMatchPatch = __webpack_require__(/*! diff_match_patch */ "../structured-text-editor/node_modules/diff_match_patch/lib/diff_match_patch.js"),
    diffEngine = new diffMatchPatch.diff_match_patch;

var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;

function ModificationLogEntry() {
    this.log = [];
}

ModificationLogEntry.prototype = {

    setFlagsFor: function(section) {
        var self = this,
            modLogFlags = this.modLogFlags;

        if(!modLogFlags) { return; }

        Object.keys(modLogFlags).forEach(function(flag) {
            if(self['mightInclude' + flag + 'Updates']) {
                return;
            }

            if(section['originalHTMLContains' + flag]) {
                self['mightInclude' + flag + 'Updates'] = true;
                return;
            }

            self['mightInclude' + flag + 'Updates'] = modLogFlags[flag].some(function(selector) {
                return section.matches(selector) || section.querySelector(selector)
            });
        });
    },

    toChangeset: function(Changeset) {
        var cs = Changeset.create();
        var wasLastOpTypeRetain = false, lastOptTypeLength = 0;

        this.log.forEach(function(entry) {
            if(entry.type === 'retain') {
                wasLastOpTypeRetain = true;
                lastOptTypeLength += entry.sectionHTML.length;
            } else if (wasLastOpTypeRetain) {
                cs.retain(lastOptTypeLength);
                wasLastOpTypeRetain = false;
                lastOptTypeLength = 0;
            }

            if (entry.type === 'delete') {
                cs.delete(entry.sectionHTML);
            } else if (entry.type === 'insert') {
                cs.insert(entry.sectionHTML);
            } else if (entry.type === 'replace') {
                var diff = diffEngine.diff_main(entry.oldSectionHTML, entry.newSectionHTML);

                diff.forEach(function(d) {
                    if (DIFF_DELETE == d[0]) {
                        cs.delete(d[1])
                    }

                    if (DIFF_INSERT == d[0]) {
                        cs.insert(d[1]);
                    }

                    if(DIFF_EQUAL == d[0]) {
                      cs.retain(d[1].length);
                    }
                });
            }
        });

        if (wasLastOpTypeRetain) {
            cs.retain(lastOptTypeLength);
        }

        return cs.end();
    },

    afterState: function() {
        var result = '';
        this.log.forEach(function(log) {
            if(log.type === 'retain' || log.type === 'insert') {
                result += log.sectionHTML;
            } else if(log.type === 'replace') {
                result += log.newSectionHTML;
            }
        });

        return result;
    },

    beforeState: function() {
        var result = '';
        this.log.forEach(function(log) {
            if(log.type === 'retain' || log.type === 'delete') {
                result += log.sectionHTML;
            } else if(log.type === 'replace') {
                result += log.oldSectionHTML;
            }
        });

        return result;
    },

    retainSection: function(section) {
        this.log.push({type: 'retain', sectionHTML: section.originalHTML});
    },

    deleteSection: function(section) {
        this.log.push({type: 'delete', sectionHTML: section.originalHTML});
        this.setFlagsFor(section);
    },

    replaceSection: function(oldSec, newSec) {
        this.log.push({type: 'replace', oldSectionHTML: oldSec.originalHTML, newSectionHTML: newSec.originalHTML});
        this.setFlagsFor(newSec);
        this.setFlagsFor(oldSec);
    },

    insertSection: function(section) {
        this.log.push({type: 'insert', sectionHTML: section.originalHTML})
        this.setFlagsFor(section);
    },

    deleteSectionAt: function(index, section) {
        var oldLog;

        if(this.log[index] && this.log[index].type !== 'insert') {
            oldLog = this.log[index];
            this.log[index] = { type: 'delete', sectionHTML: this.log[index].oldSectionHTML || this.log[index].sectionHTML };
        } else if(this.log[index] && this.log[index].type === 'insert') {
            oldLog = this.log.splice(index, 1)[0]; //remove array element with index "index"
        }

        this.setFlagsFor(section);

        return oldLog;
    },

    retainAllSectionsBefore: function(section) {
        if(!section) return;
        var tmpSec = section.parentElement.children[0];
        while(tmpSec !== section) {
            this.retainSection(tmpSec);
            tmpSec = tmpSec.nextSibling;
        }
    },

    retainAllSectionsAfter: function(section) {
        if(!section) return;
        var tmpSec = section.nextSibling;
        while(tmpSec) {
            this.retainSection(tmpSec);
            tmpSec = tmpSec.nextSibling;
        }
    },

    includesHeadingUpdate: function() {
        return !!this.includesHeadingUpdates;
    }
};

module.exports = ModificationLogEntry;


/***/ }),

/***/ "../structured-text-editor/lib/generatorlookahead/index.js":
/*!*****************************************************************!*\
  !*** ../structured-text-editor/lib/generatorlookahead/index.js ***!
  \*****************************************************************/
/***/ ((module) => {

module.exports = function (stream) {
    var nextValue = stream.next();

    return {
        next: function() {
            const thisRound = nextValue;
            nextValue = stream.next();
            return thisRound;
        },
        lookahead: function() {
            return nextValue
        }
    };
}

/***/ }),

/***/ "../structured-text-editor/lib/html_razor/html_razor.js":
/*!**************************************************************!*\
  !*** ../structured-text-editor/lib/html_razor/html_razor.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var StateMachine = __webpack_require__(/*! ./state_machine.js */ "../structured-text-editor/lib/html_razor/state_machine.js");
var utils = __webpack_require__(/*! ../pixelschubser/utils */ "../structured-text-editor/lib/pixelschubser/utils.js");
var namedEncodings = {quot: 34, amp: 38, lt: 60, gt: 62, nbsp: 160, copy: 169, reg: 174, deg: 176, frasl: 47, trade: 8482, euro: 8364, Agrave: 192, Aacute: 193, Acirc: 194, Atilde: 195, Auml: 196, Aring: 197, AElig: 198, Ccedil: 199, Egrave: 200, Eacute: 201, Ecirc: 202, Euml: 203, Igrave: 204, Iacute: 205, Icirc: 206, Iuml: 207, ETH: 208, Ntilde: 209, Ograve: 210, Oacute: 211, Ocirc: 212, Otilde: 213, Ouml: 214, times: 215, Oslash: 216, Ugrave: 217, Uacute: 218, Ucirc: 219, Uuml: 220, Yacute: 221, THORN: 222, szlig: 223, agrave: 224, aacute: 225, acirc: 226, atilde: 227, auml: 228, aring: 229, aelig: 230, ccedil: 231, egrave: 232, eacute: 233, ecirc: 234, euml: 235, igrave: 236, iacute: 237, icirc: 238, iuml: 239, eth: 240, ntilde: 241, ograve: 242, oacute: 243, ocirc: 244, otilde: 245, ouml: 246, divide: 247, oslash: 248, ugrave: 249, uacute: 250, ucirc: 251, uuml: 252, yacute: 253, thorn: 254, yuml: 255, lsquo: 8216, rsquo: 8217, sbquo: 8218, ldquo: 8220, rdquo: 8221, bdquo: 8222, dagger: 8224, Dagger: 8225, permil: 8240, lsaquo: 8249, rsaquo: 8250, spades: 9824, clubs: 9827, hearts: 9829, diams: 9830, oline: 8254, larr: 8592, uarr: 8593, rarr: 8594, darr: 8595, hellip: 133, ndash: 150, mdash: 151, iexcl: 161, cent: 162, pound: 163, curren: 164, yen: 165, brvbar: 166, brkbar: 166, sect: 167, uml: 168, die: 168, ordf: 170, laquo: 171, not: 172, shy: 173, macr: 175, hibar: 175, plusmn: 177, sup2: 178, sup3: 179, acute: 180, micro: 181, para: 182, middot: 183, cedil: 184, sup1: 185, ordm: 186, raquo: 187, frac14: 188, frac12: 189, frac34: 190, iquest: 191, Alpha: 913, alpha: 945, Beta: 914, beta: 946, Gamma: 915, gamma: 947, Delta: 916, delta: 948, Epsilon: 917, epsilon: 949, Zeta: 918, zeta: 950, Eta: 919, eta: 951, Theta: 920, theta: 952, Iota: 921, iota: 953, Kappa: 922, kappa: 954, Lambda: 923, lambda: 955, Mu: 924, mu: 956, Nu: 925, nu: 957, Xi: 926, xi: 958, Omicron: 927, omicron: 959, Pi: 928, pi: 960, Rho: 929, rho: 961, Sigma: 931, sigma: 963, Tau: 932, tau: 964, Upsilon: 933, upsilon: 965, Phi: 934, phi: 966, Chi: 935, chi: 967, Psi: 936, psi: 968, Omega: 937, omega: 969};

function HTMLRazor(tagTransformations, rules) {
    this.tagTransformations = tagTransformations  || {};
    this.rules = rules;
    this.ruleNameByElementCache = {};
    this.ruleNameByTokenCache = {};
    this.tagTransformationByNodeCache = {};
    this.stateMachine = new StateMachine();
    this.temproaryPruneProtectedWhitespace = '\u2588';
}

HTMLRazor.prototype = {

    getRuleNamesByTag: function(tagName) {
        this.ruleEntries = this.ruleEntries || Object.entries(this.rules);

        return this.ruleEntries.filter(function(rule) {
            return rule[1].tagName === tagName.toLowerCase();
        }).map(function(rule) {
            return rule[0];
        });
    },

    doesElementMatchRule: function(element, rule) {
        if(!element || !rule) return false;
        if(rule.tagName !== element.nodeName.toLowerCase()) return false;
        if(rule.className && !element.classList.contains(rule.className)) return false;

        return true;
    },

    doesElementMatchOneRule: function(element, ruleNames) {
        for(let i=0; i<ruleNames.length; i++) {
            if(this.doesElementMatchRule(element, this.rules[ruleNames[i]])) {
                return true;
            }
        }
        return false;
    },

    lookupRuleNameCacheFor: function(t) {
        if(t.nodeName && this.ruleNameByElementCache[t.nodeName] && this.ruleNameByElementCache[t.nodeName][t.className]) {
            return this.ruleNameByElementCache[t.nodeName][t.className];
        } else if(this.ruleNameByTokenCache[t.value] && this.ruleNameByTokenCache[t.value]){
            return this.ruleNameByTokenCache[t.value][t.classNames];
        }
    },

    cacheRuleNameFor: function(t, result) {

        if(!result) {
          result = -1;
        }

        if(t.nodeName) {
            if(!this.ruleNameByElementCache[t.nodeName]) {
                this.ruleNameByElementCache[t.nodeName] = {}
            }

            this.ruleNameByElementCache[t.nodeName][t.className] = result;
        } else {
            if(!this.ruleNameByTokenCache[t.value]) {
                this.ruleNameByTokenCache[t.value] = {}
            }

            this.ruleNameByTokenCache[t.value][t.classNames] = result;
        }
    },

    getRuleNameByElement: function(t) {
        var rules = this.rules,
            result, tokenClassNames, resultCandidates, tmpResult;

        if(!t) return;
        if(t.nodeType === Node.TEXT_NODE) return '#text';

        result = this.lookupRuleNameCacheFor(t);
        if(result === -1) return;
        if(result) return result;

        tokenClassNames = (t && t.attributes && t.attributes['classNames']) || t.classList || [];
        resultCandidates = this.getRuleNamesByTag(t.value || t.nodeName);

        if(tokenClassNames.length !== 0) {
            tmpResult = resultCandidates.find(function(rc) {
                if(!rules[rc].className) return false;

                for(var i=0; i<tokenClassNames.length; i++) {
                    if(rules[rc].className === tokenClassNames[i]) return true;
                }
            });
        }

        result = tmpResult || resultCandidates.find(function(rc) {
            return !rules[rc].className;
        });

        this.cacheRuleNameFor(t, result);

        return result;
    },

    getRuleByElement: function(element) {
        return this.rules[this.getRuleNameByElement(element)];
    },

    isTokenAllowedToBeRootElement: function(t) {
        var rule = this.rules && this.rules[this.getRuleNameByElement(t)];
        return rule && rule.allowedToBeRoot;
    },

    isTokenAllowedToContainItself: function(t) {
      var ruleName = this.getRuleNameByElement(t),
          rule = this.rules && this.rules[ruleName];

        if(!rule.allowedChildren) return false;
        return rule.allowedChildren.indexOf(ruleName) !== -1;
    },

    rootElementsShouldNotBreakOutFrom: function(parentNode) {
        var rule = this.getRuleByElement(parentNode);
        if(!rule) { return false }

        return !!rule.doNotBreakOutRootElements;
    },

    cacheTagTransformationFor: function(tokenPathInParsedTree, result) {
        result = result || -1;
        this.tagTransformationByNodeCache[tokenPathInParsedTree] = result;
        return result == -1 ? undefined : result;
    },

    loockupTagTransformationCacheFor: function(tokenPathInParsedTree, classList) {
        if(classList && classList.length !== 0) {
            return;
        }

        if(this.tagTransformationByNodeCache[tokenPathInParsedTree] === -1) {
            return -1;
        }

        if(this.tagTransformationByNodeCache[tokenPathInParsedTree]) {
            return this.tagTransformationByNodeCache[tokenPathInParsedTree];
        }
    },

    tagTransformationByNode: function(node) {
        var self = this,
            classList = node.classList,
            oriNode = node,
            tokenPathInParsedTree = '',
            matchesByPath = [],
            keys = Object.keys(this.tagTransformations),
            result,
            tk, split;

        if(!oriNode.classList) { oriNode.classList = [] }

        while(node) {
            if(node.tagName) {
                tokenPathInParsedTree = '/' + node.tagName.toLowerCase() + tokenPathInParsedTree;
            } else if(node.nodeType === Node.TEXT_NODE){
                tokenPathInParsedTree = '/#text' + tokenPathInParsedTree;
            }

            node = node.parentNode;
        }

        result = this.loockupTagTransformationCacheFor(tokenPathInParsedTree, classList)

        if(result === -1) {return}
        if(result) {return result}

        for(var i=0; i<keys.length; i++) {
            tk = keys[i];
            split = tk.split('.');

            if(split[0] === tokenPathInParsedTree) {
                if(!split[1]) {
                    matchesByPath.push(tk)
                } else if(oriNode.classList.contains(split[1])) {
                    return this.tagTransformations[tk];
                }
            }
        }

        return self.cacheTagTransformationFor(
                    tokenPathInParsedTree,
                    matchesByPath[0] ? this.tagTransformations[matchesByPath[0]] : -1);
    },

    isNodeAllowedToBeRootElement: function(node) {
        var rule = this.rules[this.getRuleNameByElement(node)];
        return rule && rule.allowedToBeRoot;
    },

    isNodeForbiddenByAllowedChildrenDefinition: function(rootElement, childNodeRuleName, parentElementRule) {
        parentElementRule = parentElementRule || this.getRuleByElement(rootElement);
        if(!childNodeRuleName) return false;
        if(!parentElementRule.allowedChildren) return false;

        return parentElementRule.allowedChildren.indexOf(childNodeRuleName) === -1
    },

    isNodeForbiddenByCardinalityDefinition: function(cardinalities, childNodeRuleName, parentElementRule) {
        var maxAllowed;

        cardinalities[childNodeRuleName] = cardinalities[childNodeRuleName] || 0;

        maxAllowed = parentElementRule &&
                     parentElementRule.childrenCardinality &&
                     parentElementRule.childrenCardinality[childNodeRuleName] &&
                     parentElementRule.childrenCardinality[childNodeRuleName].max;

        if(!maxAllowed) return false;

        return maxAllowed <= cardinalities[childNodeRuleName];
    },

    getRootNodeOf: function(node)  {
        var root = node;

        while(root && root.parentNode) {
            root = root.parentNode;
        }

        return root;
    },

    createDOMElementFromToken: function(token) {
        var self = this, element = document.createElement(token.value);
        Object.keys(token.attributes).forEach(function(key) {
            if(key === 'classNames') {
                element.setAttribute('class', token.attributes[key].join(' '));
            } else {
                element.setAttribute(key, self.strip(token.attributes[key]));
            }
        });

        return element;
    },

    cloneDOMElementAndChangeTagName: function(node, tagName) {
        var result = document.createElement(tagName);

        result.attributes = node.attributes;

        for(var i=0; i<node.attributes.length; i++) {
            result.setAttribute(node.attributes[i].name, node.attributes[i].value)
        }

        result.innerHTML = node.innerHTML;

        return result;
    },

    strip: function(html) {
        if(!html.replace) { return html }

        return html.replace(/&#?(\w+);/g, function(match, dec) {
            if(isNaN(dec) && namedEncodings[dec]) {
                dec = namedEncodings[dec];
            }

            return String.fromCharCode(dec);
        });
    },

    tokenizeHTML: function*(html) {
        var token = null;
        this.stateMachine.resetStateMachine();
        for(let i=0; i<=html.length; i++) {
            token = this.stateMachine.process(html[i] || 'EOF');
            if(token) { yield token; token = null };
        }
    },

    buildTrees: function*(html) {
        var self = this,
            tokenStream = this.tokenizeHTML(html),
            token = null,
            newChild = null,
            currentNodeInTree = null,
            tmpHandlerResult = null;

        var tokenHandler =  {
            OPEN_TAG: function(token) {
                var result;

                if(['br', 'img', 'input'].indexOf(token.value.toLowerCase()) !== -1) {
                    return tokenHandler['EMPTY_TAG'](token);
                }

                newChild = self.createDOMElementFromToken(token);

                if(currentNodeInTree &&
                   self.isTokenAllowedToBeRootElement(token) &&
                   !self.isTokenAllowedToContainItself(token) &&
                   !self.rootElementsShouldNotBreakOutFrom(currentNodeInTree)) {
                    result = self.getRootNodeOf(currentNodeInTree);
                    currentNodeInTree = newChild;
                    return result;
                } else if(currentNodeInTree) {
                    currentNodeInTree.appendChild(newChild);
                    currentNodeInTree = newChild;
                } else {
                    currentNodeInTree = newChild;
                }
            },

            CLOSE_TAG: function(token) {
                if(!currentNodeInTree) return;

                var tmpCurrentNodeInTree;

                if(currentNodeInTree.parentNode) {
                    currentNodeInTree = currentNodeInTree.parentNode;
                } else {
                    tmpCurrentNodeInTree = currentNodeInTree;
                    currentNodeInTree = null;

                    if(tmpCurrentNodeInTree.tagName.toLowerCase() !== token.value && token.value !== '') {
                        tmpCurrentNodeInTree = self.cloneDOMElementAndChangeTagName(tmpCurrentNodeInTree, token.value);
                    }

                    return tmpCurrentNodeInTree;
                }
            },

            EMPTY_TAG: function(token) {
                newChild = self.createDOMElementFromToken(token);

                if(currentNodeInTree) {
                    currentNodeInTree.appendChild(newChild);
                } else {
                    return newChild;
                }
            },

            TEXT: function(token) {
                newChild = document.createTextNode(self.strip(token.value));

                if(!currentNodeInTree) {
                    if(token.value.trim().length === 0) return;
                    currentNodeInTree = document.createElement('p');
                }
                currentNodeInTree.appendChild(newChild);
            }
        }

        while(token = tokenStream.next().value) {
            try {
                tmpHandlerResult = tokenHandler[token.type](token);
            } catch(ex) {
                token = tokenStream.next().value;
                tmpHandlerResult = tokenHandler[token.type](token);
            }

            if(tmpHandlerResult) yield tmpHandlerResult;
        }

        if(currentNodeInTree) {
            yield self.getRootNodeOf(currentNodeInTree);
        }
    },

    transformTreeWithReruns: function(rootElement, transRule, className, modLog) {
        var self = this,
            res = this.transformTree(rootElement, transRule, className, modLog);

        if(Array.isArray(res)) {
            res = res.map(function(r) {
                return self.transformTreeWithReruns(r, undefined, undefined, modLog);
            });

            res = res.reduce((acc, val) => acc.concat(val), []);
        }

        return res;
    },

    // returns an array of DOM elements which should replace the passed element
    transformTree: function(rootElement, transRule, className, modLog) {
        var self = this,
            transRuleWithClass = this.tagTransformationByNode(rootElement),
            transRuleAr, toRuleCondidates, newContent,
            normalizedInnerText, praefixToBeReplaced, praefixMatch, directiveParams,
            toTransformation, tmpDirectiveParams;

        modLog = modLog || {};
        modLog.deletedCharsByMarkupTransformations = modLog.deletedCharsByMarkupTransformations || 0;

        if(!Array.isArray(transRuleWithClass)) {
            transRuleAr = transRuleWithClass ? transRuleWithClass.split('.') : [];
            transRule = transRule || transRuleAr[0];
            className = className || transRuleAr[1];
        } else {
            transRule = transRule || transRuleWithClass;
        }

        if (transRule === '#content') {
            return Array.from(rootElement.childNodes)
        } else if (transRule === '#no-content') {
            rootElement.innerHTML = '';
            return rootElement;
        } else if (transRule === '#text-content') {
            rootElement.innerHTML = rootElement.innerText.replace(/</g, '&lt;').replace(/>/g, '&gt;');
            return rootElement;
        } else if (transRule && rootElement.nodeType === Node.TEXT_NODE) {
            //text node in the left part of the rule is not supported
        } else if(Array.isArray(transRule)) {
            for(let i=0; i<transRule.length; i++) {
                normalizedInnerText = rootElement.innerText.replace(new RegExp(String.fromCharCode(160),"g"), ' ');
                normalizedInnerText = normalizedInnerText.replace(this.temproaryPruneProtectedWhitespace, ' ');
                praefixMatch = normalizedInnerText.match(new RegExp('^' + transRule[i].praefix + '(\\((.*?)\\))?\\s'));

                if(praefixMatch) {
                    praefixToBeReplaced = praefixMatch[0];
                    if(praefixMatch[2]) {
                        directiveParams = praefixMatch[2].split(',').map(function(e) { return e.trim() });
                    } else {
                        directiveParams = [];
                    }

                    toTransformation = transRule[i].to.split(/\(|\)/)[0];
                    tmpDirectiveParams = transRule[i].to.split(/\(|\)/)[1];

                    if(tmpDirectiveParams) {
                        tmpDirectiveParams = tmpDirectiveParams.split(',').map(function(e) { return e.trim() });
                        directiveParams = directiveParams.concat(tmpDirectiveParams);
                    }

                    toRuleCondidates = this.getRuleNamesByTag(toTransformation)
                                           .map(function(ruleName) { return self.rules[ruleName] })
                                           .filter(function(rule) { return rule.allowedToBeRoot && rule.buildEmptyElement });

                    newContent = rootElement.innerHTML.replace('&nbsp;', ' ').replace(this.temproaryPruneProtectedWhitespace, ' ').replace(praefixToBeReplaced, '');
                    modLog.deletedCharsByMarkupTransformations += praefixToBeReplaced.length;
                    modLog.changeSectionType = true;

                    if(toRuleCondidates.length === 1) {
                        rootElement = toRuleCondidates[0].buildEmptyElement(newContent, directiveParams, toRuleCondidates[0]);
                    } else {
                        rootElement = this.cloneDOMElementAndChangeTagName(rootElement, toTransformation);
                        rootElement.innerHTML = newContent;
                    }
                }
            }
        } else if(transRule) {
            rootElement = this.cloneDOMElementAndChangeTagName(rootElement, transRule);
            if(className) rootElement.classList.add(className)
        }

        if(rootElement.childNodes) {
            for(let i=0; i<rootElement.childNodes.length; i++) {

                transRuleWithClass = this.tagTransformationByNode(rootElement.childNodes[i]);
                transRuleAr = transRuleWithClass ? transRuleWithClass.split('.') : [];
                transRule = transRuleAr[0];
                className = transRuleAr[1];

                if(transRule === '-') {
                    let res = [rootElement, rootElement.removeChild(rootElement.childNodes[i])]

                    if(rootElement.childNodes[i]) {
                        let newEl = document.createElement(rootElement.tagName);
                        while(rootElement.childNodes[i]) {
                            newEl.appendChild(rootElement.removeChild(rootElement.childNodes[i]))
                        }

                        res.push(newEl);
                    }

                    if(rootElement.childNodes.length === 0) {
                        res.shift();
                    }

                    return res;
                } else if(transRule && transRule[0] === '=')  {
                    let res = [rootElement, rootElement.removeChild(rootElement.childNodes[i])];
                    let newElementTagName = transRule.substring(1, transRule.length);

                    let newEl = document.createElement(newElementTagName === '' ? rootElement.tagName : newElementTagName);
                    utils.copyNodeAttributes(rootElement, newEl, ['class']);

                    while(rootElement.childNodes[i]) {
                        newEl.appendChild(rootElement.removeChild(rootElement.childNodes[i]))
                    }

                    res.push(newEl);
                    return res;
                } else {
                    let res = this.transformTree(rootElement.childNodes[i], transRule, className, modLog);
                    if(res instanceof Array) {
                        rootElement.childNodes[i].replaceWith(...res);
                        i--;
                    } else if(res) {
                        rootElement.childNodes[i].replaceWith(res);
                    }
                }
            }
        }

        return rootElement;
    },

    cleanupClassAttribte: function(node) {
        var rule = this.getRuleByElement(node),
            classNamesToRemove = [];

        if(rule && rule.allowedClassNames) {
            for(let i=0; i<node.classList.length; i++) {
                if(rule.allowedClassNames.indexOf(node.classList[i]) === -1) {
                    classNamesToRemove.push(node.classList[i]);
                }
            }
            classNamesToRemove.forEach(function(cn) {node.classList.remove(cn);})
        } else if (rule && node.attributes && node.attributes.class) {
            node.removeAttribute('class');
        }
    },

    cleanupNodeAttributes: function(node) {
        // first check whether the cleaning process will remove the class attribute
        var rule = this.getRuleByElement(node),
            attributesToRemove = [];

        if(!rule) return;

        if(node.attributes) {
            for(let i=0; i<node.attributes.length; i++) {
                if(!rule.allowedAttributes ||
                   rule.allowedAttributes.indexOf(node.attributes[i].name) === -1 ||
                  node.attributes[i].value === ''
                  ) {
                    attributesToRemove.push(node.attributes[i].name);
                }
            }
        }

        attributesToRemove.forEach(function(attr) {
            node.removeAttribute(attr);
        });
    },

    buildEmptyElementByRuleName: function(ruleName) {
        var el, rule = this.rules[ruleName];

        if(rule.buildEmptyElement) {
            return rule.buildEmptyElement(null, null, rule);
        }

        el = document.createElement(rule.tagName);
        if(rule.className) {
            el.classList.add(rule.className);
        }
        return el;
    },

    cleanupTree: function(rootElement, modificationLogEntry, previousDOMTree, nextDOMTree) {
        this.cleanupClassAttribte(rootElement);
        this.cleanupNodeAttributes(rootElement);

        var self = this,
            ruleName = this.getRuleNameByElement(rootElement),
            rule = this.rules[ruleName],
            childNodeRuleName,
            cardinalityMap = {},
            result = {},
            deletedCharsByMarkupTransformationsCalulationHelper,
            cTResult;

        if(!ruleName || (rule && rule.deleteIfEmpty && rootElement.innerText.length === 0)) {
            return { removeThisNode: true };
        }

        if(rule && rule.buildAttributes) {
            rule.buildAttributes.forEach(function(ba) {
                if(!rootElement.hasAttribute(ba.name)) {
                    rootElement.setAttribute(ba.name, ba.build())
                }
            })
        }

        for(let i=0; i<rootElement.childNodes.length; i++) {
            childNodeRuleName = this.getRuleNameByElement(rootElement.childNodes[i]);

            if(this.isNodeForbiddenByAllowedChildrenDefinition(rootElement, childNodeRuleName, rule) ||
               this.isNodeForbiddenByCardinalityDefinition(cardinalityMap, childNodeRuleName, rule)) {
                rootElement.removeChild(rootElement.childNodes[i--]);
            } else {
                cardinalityMap[childNodeRuleName]++;

                if(rule.pruneSpaces && rootElement.childNodes[i].nodeType == Node.TEXT_NODE) {
                    deletedCharsByMarkupTransformationsCalulationHelper = rootElement.childNodes[i].nodeValue.length;
                    rootElement.childNodes[i].nodeValue = rootElement.childNodes[i].nodeValue.replace(/(\s|\u00A0)+/g, ' ').replace(/\s$/, '\u00A0');
                    modificationLogEntry.deletedCharsByMarkupTransformations += (deletedCharsByMarkupTransformationsCalulationHelper - rootElement.childNodes[i].nodeValue.length);
                }

                if(rootElement.childNodes[i].nodeType == Node.TEXT_NODE) {
                    rootElement.childNodes[i].nodeValue = rootElement.childNodes[i].nodeValue.replace(this.temproaryPruneProtectedWhitespace, '\u00A0');
                }

                cTResult = this.cleanupTree(rootElement.childNodes[i], modificationLogEntry);

                if(cTResult.removeThisNode) {
                    rootElement.removeChild(rootElement.childNodes[i--]);
                }

                if(cTResult.insertNodeAfter) {
                    rootElement.insertBefore(cTResult.insertNodeAfter, rootElement.childNodes[i].nextSibling);
                }

                if(cTResult.insertNodeBefore) {
                    rootElement.insertBefore(cTResult.insertNodeBefore, rootElement.childNodes[i++]);
                }
            }
        }

        if(rule && rule.allowedSuccessors && rule.allowedSuccessors.length !== 0 && !this.doesElementMatchOneRule(nextDOMTree || rootElement.nextSibling, rule.allowedSuccessors)) {
            result.insertNodeAfter = this.buildEmptyElementByRuleName(rule.allowedSuccessors[0]);
        }

        if(rule && rule.allowedPredecessors && rule.allowedPredecessors.length !== 0 && !this.doesElementMatchOneRule(previousDOMTree || rootElement.previousSibling, rule.allowedPredecessors)) {
            result.insertNodeBefore = this.buildEmptyElementByRuleName(rule.allowedPredecessors[0]);
        }

        return result;
    },

    HTMLToTransformedTreeStream: function*(html, modificationLogEntry) {
        var DOMTreeStream = this.buildTrees(html),
            DOMTree = DOMTreeStream.next().value;

        while(DOMTree) {
            DOMTree = this.transformTreeWithReruns(DOMTree, undefined, undefined, modificationLogEntry);

            if(Array.isArray(DOMTree)) {
                for(let i=0; i<DOMTree.length; i++) {
                    yield DOMTree[i];
                }
            } else {
                yield DOMTree;
            }

            DOMTree = DOMTreeStream.next().value;
        }
    },

    cleanupHTML: function*(html, modificationLogEntry)  {
        if(!html || html === '') { html = '<p></p>' }

        modificationLogEntry = modificationLogEntry || {}
        modificationLogEntry.deletedCharsByMarkupTransformations = 0;

        var DOMTreeStream = this.HTMLToTransformedTreeStream(html, modificationLogEntry),
            cTResult,
            previousDOMTree,
            DOMTree = DOMTreeStream.next().value,
            nextDOMTree = DOMTreeStream.next().value;

        while(DOMTree) {
            if(this.isNodeAllowedToBeRootElement(DOMTree)) {
                cTResult = this.cleanupTree(DOMTree, modificationLogEntry, previousDOMTree, nextDOMTree);
                if(cTResult.insertNodeBefore) {
                    yield this.memorizedNode(cTResult.insertNodeBefore, modificationLogEntry.modLogFlags);
                }

                if(!cTResult.removeThisNode) {
                    yield this.memorizedNode(DOMTree, modificationLogEntry.modLogFlags);
                }

                if(cTResult.insertNodeAfter) {
                    yield this.memorizedNode(cTResult.insertNodeAfter, modificationLogEntry.modLogFlags);
                }
            }

            previousDOMTree = DOMTree;
            DOMTree = nextDOMTree;
            nextDOMTree = DOMTreeStream.next().value;
        }
    },

    memorizedNode: function(node, modLogFlags) {

        modLogFlags = modLogFlags || {};
        node.originalHTML = node.outerHTML;

        Object.keys(modLogFlags).forEach(function(flag) {
            node['originalHTMLContains' + flag] = modLogFlags[flag].some(function(selector) {
                return node.matches(selector) || node.querySelector(selector)
            });
        });

        return node;
    },

    cleanupHTMLAndAttachEventHandlers: function*(html, modificationLogEntry) {
          var DOMTreeStream = this.cleanupHTML(html, modificationLogEntry),
            DOMTree = DOMTreeStream.next().value,
            dummyElement, rule;

        while(DOMTree) {
            rule = this.getRuleByElement(DOMTree);
            if(rule.buildEmptyElement) {
                dummyElement = rule.buildEmptyElement(null, null, rule);
                utils.copyEventListenersRecursively(dummyElement, DOMTree);
            }

            yield DOMTree;
            DOMTree = DOMTreeStream.next().value;
        }
    }
}

module.exports = HTMLRazor;


/***/ }),

/***/ "../structured-text-editor/lib/html_razor/state_machine.js":
/*!*****************************************************************!*\
  !*** ../structured-text-editor/lib/html_razor/state_machine.js ***!
  \*****************************************************************/
/***/ ((module) => {

var i=0,
    WAIT_FOR_NEXT_TOKEN_TO_START = i++,
    READING_TAG_NAME = i++,
    DETERMINING_TAG_TYPE = i++,
    READING_ATTRIBUTE_NAME = i++,
    EXPECTING_QUOTE_TO_START_ATTRIBUTE_VALUE = i++,
    READING_ATTRIBUTE_VALUE = i++,
    WAIT_FOR_NEXT_ATTRIBUTE_TO_START = i++,
    READING_TEXT = i++,
    WAITING_FOR_EMPTY_TAG_TO_BE_CLOSED = i++;

function addCharRangeToTransition(transition, CharRangeStart, CharRangeEnd, TransitionAction) {
    for(let asciCode=CharRangeStart.charCodeAt(0); asciCode<=CharRangeEnd.charCodeAt(0); asciCode++) {
        transition[String.fromCharCode(asciCode)] = TransitionAction;
    }
}

function globCharRangesInTranstion(transition) {
    Object.keys(transition).filter(function(tk) {
        return tk.match(/^\[(.|\s)*\]$/);
    }).forEach(function(tk) {
        var tf = transition[tk];

        if(tk.indexOf('A-Z') !== -1) {addCharRangeToTransition(transition, 'A', 'Z', tf);}
        if(tk.indexOf('a-z') !== -1) {addCharRangeToTransition(transition, 'a', 'z', tf);}
        if(tk.indexOf('0-9') !== -1) {addCharRangeToTransition(transition, '0', '9', tf);}

        if(tk.indexOf(' \n') !== -1) {
           transition[' '] = tf;
           transition['\n'] = tf;
        }

        //tk.replace(/\[|\]|A\-Z|a\-z|0\-9/g, '') -> "[A-Za-z-']" is replaced to "-'", and then "-" and "'" are added to the transition
        tk.replace(/\[|\]|A\-Z|a\-z|0\-9/g, '').split('').forEach(function(c) {
            transition[c] = tf;
        });
    });
}


function StateMachine() {
    var self = this;

    this.transistions = [];
    this.tokens = [];
    this.state = WAIT_FOR_NEXT_TOKEN_TO_START;

    this.resetState();

    this.transistions[WAIT_FOR_NEXT_TOKEN_TO_START] = {
        '<':                 function()     { self.state = DETERMINING_TAG_TYPE; },
        'else':              function(char) { self.state = READING_TEXT; self.currentToken.type = 'TEXT'; self.currentToken.value += char; }
    };

    this.transistions[DETERMINING_TAG_TYPE] = {
        '[a-zA-Z]':          function(char)  { self.state = READING_TAG_NAME; self.currentToken.type = 'OPEN_TAG'; self.currentToken.value += char; },
        '/':                 function()      { self.state = READING_TAG_NAME; self.currentToken.type = 'CLOSE_TAG'; },
    };

    this.transistions[READING_TAG_NAME] = {
        '[a-zA-Z0-9]':       function(char) { self.currentToken.value += char },
        '[ \n]':             function()     { self.currentToken.type === 'CLOSE_TAG' ? self.transistions[READING_TAG_NAME]['>']() : self.state = WAIT_FOR_NEXT_ATTRIBUTE_TO_START },
        '>':                 function()     { self.state = WAIT_FOR_NEXT_TOKEN_TO_START, self.finishToken() },
        '/':                 function()     { self.state = WAITING_FOR_EMPTY_TAG_TO_BE_CLOSED, self.currentToken.type = 'EMPTY_TAG'; }
    };

    this.transistions[READING_ATTRIBUTE_NAME] = {
        '[a-zA-Z-]':         function(char) { self.currentAttribute.name += char },
        ' ':                 function()     { self.state = WAIT_FOR_NEXT_ATTRIBUTE_TO_START; self.finishAttribute() },
        '\n':                function()     {},
        '=':                 function()     { self.state = EXPECTING_QUOTE_TO_START_ATTRIBUTE_VALUE },
        '>':                 function()     { self.state = WAIT_FOR_NEXT_TOKEN_TO_START; self.finishAttribute(); self.finishToken()  },
        '<':                 function()     { self.state = DETERMINING_TAG_TYPE; self.handleBrokenOpenTag(READING_ATTRIBUTE_NAME); },
        '/':                 function()     { self.state = WAITING_FOR_EMPTY_TAG_TO_BE_CLOSED, self.currentToken.type = 'EMPTY_TAG'; self.finishAttribute() }
    };

    this.transistions[EXPECTING_QUOTE_TO_START_ATTRIBUTE_VALUE] = {
        '["\']':             function()     { self.state = READING_ATTRIBUTE_VALUE }
    };

    this.transistions[READING_ATTRIBUTE_VALUE] = {
        '["\']':             function()     { self.state = WAIT_FOR_NEXT_ATTRIBUTE_TO_START; self.finishAttribute() },
        '<':                 function()     { self.state = DETERMINING_TAG_TYPE; self.handleBrokenOpenTag(READING_ATTRIBUTE_VALUE); },
        'else':              function(char) { self.currentAttribute.value += char }
    };

    this.transistions[WAIT_FOR_NEXT_ATTRIBUTE_TO_START] = {
        '[ \n]':             function()     { },
        '[a-zA-Z]':          function(char) { self.state = READING_ATTRIBUTE_NAME; self.currentAttribute.name += char },
        '>':                 function()     { self.state = WAIT_FOR_NEXT_TOKEN_TO_START, self.finishToken() },
        '/':                 function()     { self.state = WAITING_FOR_EMPTY_TAG_TO_BE_CLOSED, self.currentToken.type = 'EMPTY_TAG'; }
    };

    this.transistions[WAITING_FOR_EMPTY_TAG_TO_BE_CLOSED] = {
        '\n':                function()     {},
        '>':                 function()     { self.state = WAIT_FOR_NEXT_TOKEN_TO_START, self.finishToken() },
    };

    this.transistions[READING_TEXT] = {
        '<':                 function()     { self.state = DETERMINING_TAG_TYPE; self.finishToken(); },
        'else':              function(char) { self.currentToken.value += char; },
        'EOF':               function()     { self.finishToken(); }
    };

    this.transistions.forEach(function(t) {
        globCharRangesInTranstion(t);
    })
};

StateMachine.prototype.finishAttribute = function() {

    if(this.currentAttribute.name === 'class') {
        this.currentAttribute.name = 'classNames';
        this.currentAttribute.value = this.currentAttribute.value.split(' ');
        this.currentAttribute.value = this.currentAttribute.value.map(function(c) { return c.trim() });
    }

    this.currentToken.attributes[this.currentAttribute.name] = this.currentAttribute.value || true;
    this.currentAttribute = {name: '', value: ''};
};

StateMachine.prototype.finishToken = function() {
    this.tokens.push(this.currentToken);
    this.resetState();
};

StateMachine.prototype.resetState = function() {
    this.currentToken = {value: '', type: 'UNKNOWN', attributes: {}};
    this.currentAttribute = {name: '', value: ''};
};

StateMachine.prototype.resetStateMachine = function() {
    this.resetState();
    this.tokens = [];
    this.state = WAIT_FOR_NEXT_TOKEN_TO_START;
}

// State Param: the StateMachine state in which the broken open tag has been detected
StateMachine.prototype.handleBrokenOpenTag = function(state) {
    if(state === READING_ATTRIBUTE_NAME || state === READING_ATTRIBUTE_VALUE) {
        this.finishToken();
        this.currentToken = {value: '', type: 'TEXT', attributes: {}};
        this.finishToken();
    }
}

StateMachine.prototype.process = function(char) {

    if(this.transistions[this.state][char]) {
        this.transistions[this.state][char](char);
    } else if (this.transistions[this.state]['else'])  {
        this.transistions[this.state]['else'](char)
    } else {
        // console.log('error parsing content');
    }

    return this.tokens.pop();
};


module.exports = StateMachine


/***/ }),

/***/ "../structured-text-editor/lib/html_razor/tag_transformation.js":
/*!**********************************************************************!*\
  !*** ../structured-text-editor/lib/html_razor/tag_transformation.js ***!
  \**********************************************************************/
/***/ ((module) => {

var TagTransformations = function() {
    Object.call(this);
}

TagTransformations.prototype = Object.create(Object.prototype);

TagTransformations.prototype.allowOnlyTextIn = function(path, args) {
    var t = this,
        p = path,
        c = '#content';

    args = args || {};

    t[p+'/span'] =
    t[p+'/ul'] =
    t[p+'/li'] =
    t[p+'/ul/li'] =
    t[p+'/ol'] =
    t[p+'/ol/li'] =
    t[p+'/strong'] =
    t[p+'/em'] =
    t[p+'/a/span'] =
    t[p+'/b/b'] =
    t[p+'/u/u'] =
    t[p+'/i/i'] =
    t[p+'/font'] = c;

    if(!args.allowBoldItalicUnderline) {
        t[p+'/b'] =
        t[p+'/u'] =
        t[p+'/i'] =
        t[p+'/code'] = c;
    } else {
        t[p+'/inlinecode/b'] =
        t[p+'/inlinecode/i'] =
        t[p+'/inlinecode/u'] =
        t[p+'/inlinecode/a'] = c;
        t[p+'/code'] = 'inlinecode';
        t[p+'/inlinecode/inlinecode'] = '#content';
        t[p+'/b/inlinecode'] = '-';
        t[p+'/u/inlinecode'] = '-';
        t[p+'/i/inlinecode'] = '-';
        t[p+'/a/code'] = 'inlinecode';
    }

    if(!args.allowLinks) {
      t[p+'/a'] = c;
      t[p+'/code'] = c;
      t[p+'/inlinecode'] = c;
    }

    if(!args.allowRootElements) {
        t[p+'/h1'] =
        t[p+'/h2'] =
        t[p+'/h3'] =
        t[p+'/h4'] =
        t[p+'/h5'] =
        t[p+'/h6'] =
        t[p+'/h7'] =
        t[p+'/div'] =
        t[p+'/p'] = c;
    }

    if(args.allowEquations) {
        t.allowInlineequationsIn(p)
    }

    if(args.allowRefs) {
        t.allowRefsIn(p);

        if(args.allowBoldItalicUnderline) {
            t.allowRefsIn(p + '/b');
            t.allowRefsIn(p + '/u');
            t.allowRefsIn(p + '/i');
        }

        if(args.allowLinks) {
            t.allowRefsIn(p + '/a');
        }
    }
};

TagTransformations.prototype.allowInlineequationsIn = function(path) {
    var t = this,
        p = path;

    t[p+'/inlineequation'] = '#no-content';
    t[p+'/b/inlineequation'] =
    t[p+'/u/inlineequation'] =
    t[p+'/i/inlineequation'] =
    t[p+'/a/inlineequation'] =
    t[p+'/b/i/inlineequation'] =
    t[p+'/i/b/inlineequation'] =
    t[p+'/b/u/inlineequation'] =
    t[p+'/u/b/inlineequation'] =
    t[p+'/i/u/inlineequation'] =
    t[p+'/u/i/inlineequation'] =
    t[p+'/a/i/inlineequation'] =
    t[p+'/i/a/inlineequation'] =
    t[p+'/a/u/inlineequation'] =
    t[p+'/u/a/inlineequation'] =
    t[p+'/a/b/inlineequation'] =
    t[p+'/b/a/inlineequation'] = '-'
};



TagTransformations.prototype.allowRefsIn = function(path) {
    this[path+'/span'] = '#content';
    this[path+'/span.footnote'] = 'span.footnote';
    this[path+'/span.reference'] = 'span.reference';
};


module.exports = TagTransformations


/***/ }),

/***/ "../structured-text-editor/lib/lookup_refs/errors.js":
/*!***********************************************************!*\
  !*** ../structured-text-editor/lib/lookup_refs/errors.js ***!
  \***********************************************************/
/***/ ((module) => {

class NotFound extends Error {
    constructor(lookupID) {
        super(`No record found for ${lookupID}`)
    }
}

class InvalidID extends Error {
    constructor(lookupID) {
        super(`ID is invalid: ${lookupID}`)
    }
}

class EmptyID extends Error {
    constructor() {
        super('ID argument should not be null for fetching reference data. Needs to be a DOI/ISBN')
    }
}

module.exports = {
    NotFound,
    InvalidID,
    EmptyID
};

/***/ }),

/***/ "../structured-text-editor/lib/lookup_refs/index.js":
/*!**********************************************************!*\
  !*** ../structured-text-editor/lib/lookup_refs/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var lookupByDOI = __webpack_require__(/*! ./lookup_by_doi */ "../structured-text-editor/lib/lookup_refs/lookup_by_doi.js");
var lookupByISBN = __webpack_require__(/*! ./lookup_by_isbn */ "../structured-text-editor/lib/lookup_refs/lookup_by_isbn.js");
var lookupByURL = __webpack_require__(/*! ./lookup_by_url */ "../structured-text-editor/lib/lookup_refs/lookup_by_url.js");
var lookupByArxiv = __webpack_require__(/*! ./lookup_by_arxiv */ "../structured-text-editor/lib/lookup_refs/lookup_by_arxiv.js");
var errors = __webpack_require__(/*! ./errors */ "../structured-text-editor/lib/lookup_refs/errors.js");

module.exports = {
    fetchJSON: function(id) {
        if(!id) {
            return new Promise((_, rej) => rej(new errors.EmptyID()));
        }

        id = id.trim();

        if(lookupByDOI.isValidID(id)) {
            return lookupByDOI.fetchJSON(id);
        }

        if(lookupByISBN.isValidID(id)) {
            return lookupByISBN.fetchJSON(id);
        }

        if(lookupByURL.isValidID(id)) {
            return lookupByURL.fetchJSON(id);
        }

        if(lookupByArxiv.isValidID(id)) {
            return lookupByArxiv.fetchJSON(id);
        }

        return new Promise((_, rej) => rej(new errors.InvalidID(id)));
    },

    lookupByDOI: lookupByDOI.fetchJSON,
    lookupByISBN: lookupByISBN.fetchJSON,
    lookupByURL: lookupByURL.fetchJSON,
    errors: errors,
}

/***/ }),

/***/ "../structured-text-editor/lib/lookup_refs/lookup_by_arxiv.js":
/*!********************************************************************!*\
  !*** ../structured-text-editor/lib/lookup_refs/lookup_by_arxiv.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// fetch('http://export.arxiv.org/api/query?id_list=1906.01738').then(r => r.text()).then(text => )

var errors = __webpack_require__(/*! ./errors */ "../structured-text-editor/lib/lookup_refs/errors.js");
var months = ['Jan.', 'Feb.', 'Mar.', 'Apr.', 'May.', 'Jun.', 'Jul.', 'Aug.', 'Sep.', 'Oct.', 'Nov.', 'Dec'];
var lookupCache = {}

function getPublishedMonth(entry) {
    try {
        var date = new Date(entry.querySelector('published').innerHTML)

        if(!date || date == 'Invalid Date') {
            throw 'invalid publication date';
        }

        return months[date.getMonth()]
    } catch (ex) {
        console.log('error parsing publication date', ex)
        return ''
    }
}

function getPublishedYear(entry) {
    try {
        var date = new Date(entry.querySelector('published').innerHTML)

        if(!date || date == 'Invalid Date') {
            throw 'invalid publication date'
        }

        return date.getFullYear()
    } catch (ex) {
        console.log('error parsing publication date', ex)
        return ''
    }
}

function resultFromRespnose(xmlDoc) {
    var entry = xmlDoc.querySelector('entry')
    var titleEl = entry.querySelector('title')
    var authors = entry.querySelectorAll('author').map(author => {
        author = author && author.querySelector('name')
        if(author && author.innerHTML) {
            return author.innerHTML
        }
    }).join(' and ')

    return {
        type: 'Article',
        title: (titleEl && titleEl.innerHTML) || '',
        author: authors,
        year: getPublishedYear(entry),
        month: getPublishedMonth(entry)
    }
}

module.exports = {

    isValidID: function(id) {
        return id && id.trim().match(/^(arXiv:)?[0-9]{4}\.[0-9]+(v.)?$/)
    },

    fetchJSON: async function(id) {

        if(!this.isValidID(id)) {
            throw new errors.InvalidID(id);
        }

        if(id.trim().match(/^arXiv:/)) {
            id = id.trim().replace(/^arXiv:/, '')
        }

        if(lookupCache[id]) {
            return lookupCache[id]
        }

        var res = await fetch(`http://export.arxiv.org/api/query?id_list=${id}`)

        if(!res.ok) {
            throw errors.NotFound
        }

        lookupCache[id] = resultFromRespnose(
            new window.DOMParser().parseFromString(await res.text(), "text/xml")
        )

        return lookupCache[id]
    }
}

/***/ }),

/***/ "../structured-text-editor/lib/lookup_refs/lookup_by_doi.js":
/*!******************************************************************!*\
  !*** ../structured-text-editor/lib/lookup_refs/lookup_by_doi.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var errors = __webpack_require__(/*! ./errors */ "../structured-text-editor/lib/lookup_refs/errors.js");
var doiLookupCache = {}

var months = ['Jan.', 'Feb.', 'Mar.', 'Apr.', 'May.', 'Jun.', 'Jul.', 'Aug.', 'Sep.', 'Oct.', 'Nov.', 'Dec'];

var doiType2bibTeXType = {
    'journal-article': 'Article',
    'proceedings-article': 'Conference/Inproceedings',
    'dissertation': 'Phdthesis',

    'book': 'Book',
    'book-series': 'Book',
    'book-set': 'Book',
    'book-track': 'Book',
    'monograph': 'Book',
    'reference-book': 'Book',

    'book-chapter': 'Inbook',
    'book-part': 'Inbook',
    'book-section': 'Inbook',
    'reference-entry': 'Inbook',

    'dataset': 'Techreport',
    'posted-content': 'Techreport',
    'report': 'Techreport',
    'report-series': 'Techreport',
    'standard': 'Techreport',
};

var selectedFields = [
    'type',
    'container-title', // -> journal, booktitle, eventtitle
    'volume',
    'issue',
    'publisher',
    'issued', // -> year, month
    'title',
    'subtitle',
    'author',
    'editor',
];

function transformDoiAuthors(doiData, field) {
    return (doiData[(field)] || [])
        .map(a => `${a.family}, ${a.given}`)
        .join(' and ')
}

function transformDoiMonth(doiData) {
    if(doiData && doiData.issued && doiData.issued['date-parts'] && doiData.issued['date-parts'][0] && doiData.issued['date-parts'][0][1]) {
        return months[doiData.issued['date-parts'][0][1]-1];
    }

    return '';
}

function transformDoiYear(doiData) {
    if(doiData && doiData.issued && doiData.issued['date-parts'] && doiData.issued['date-parts'][0] && doiData.issued['date-parts'][0][0]) {
        return doiData.issued['date-parts'][0][0];
    }

    return '';
}

function transformDoiPublisher(doiData) {
    if(['book-chapter',
      'book-part',
      'book-section',
      'reference-entry',
      'proceedings-article',
      'book',
      'book-series',
      'book-set',
      'book-track',
      'monograph',
      'reference-book'].includes(doiData.type)) {
        return doiData.publisher || '';
    }
    return '';
}

function transformDoiOrganization(doiData) {
    if(['proceedings-article'].includes(doiData.type)) {
        return doiData.publisher || '';
    }

    return '';
}

function transformDoiSchool(doiData) {
    if(['dissertation'].includes(doiData.type)) {
        return doiData.publisher || '';
    }
    return '';
}

function decode(str) {
    return str.replace('&amp;', '&')
}

module.exports = {

    isValidID: function(doi) {
        return doi.match(/^10.\d{4,9}\/.+$/i);
    },

    fetchJSON: function(doi) {
        return module.exports.queryCrossref(doi).then(resultData => {
            return {
                type: resultData.type ? doiType2bibTeXType[resultData.type] : 'Article',
                author: transformDoiAuthors(resultData, 'author'),
                editor: transformDoiAuthors(resultData, 'editor'),
                title: decode(resultData.title ? resultData.title.join(' - ') : ''),
                subtitle: decode(resultData.subtitle ? resultData.subtitle.join(' - ') : ''),
                journal: decode(resultData['container-title'] ? resultData['container-title'].join(' - ') : ''),
                number: resultData.issue || '',
                volume: resultData.volume || '',
                publisher: decode(transformDoiPublisher(resultData)),
                organization: decode(transformDoiOrganization(resultData)),
                year: transformDoiYear(resultData),
                month: transformDoiMonth(resultData),
                school: transformDoiSchool(resultData)
            }
        });
    },

    queryCrossref: function(doi) {
        if(!doi || !this.isValidID(doi)) {
            return new Promise((res, rej) => rej('invalid DOI'));
        }

        if(doiLookupCache[doi]) {
            return doiLookupCache[doi]
        }

        doiLookupCache[doi] = fetch(`https://api.crossref.org/works/?filter=doi:${encodeURIComponent(doi)}&select=${encodeURIComponent(selectedFields.join(','))}`)
            .then(response => response.json())
            .then(data => {
                if(data && data.message && data.message.items, data.message.items.length) {
                    return data.message.items[0];
                }

                return new Promise((_, rej) => rej(new errors.NotFound(doi)));
            });

        return doiLookupCache[doi];
    }
}

/***/ }),

/***/ "../structured-text-editor/lib/lookup_refs/lookup_by_isbn.js":
/*!*******************************************************************!*\
  !*** ../structured-text-editor/lib/lookup_refs/lookup_by_isbn.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var errors = __webpack_require__(/*! ./errors */ "../structured-text-editor/lib/lookup_refs/errors.js");
var fetchCache = {}
var months = ['Jan.', 'Feb.', 'Mar.', 'Apr.', 'May.', 'Jun.', 'Jul.', 'Aug.', 'Sep.', 'Oct.', 'Nov.', 'Dec'];

module.exports = {
    isValidID: function(isbn) {
        return isbn.match(/^(?=(?:\D*\d){10}(?:(?:\D*\d){3})?$)[\d-]+$/);
    },

    fetchJSON: async function(isbn) {
        if(!this.isValidID(isbn)) {
            throw new errors.InvalidID(isbn);
        }

        if(fetchCache[isbn]) {
            return fetchCache[isbn];
        }

        var rawData = await fetch(`https://openlibrary.org/isbn/${isbn}.json`);

        if(rawData.status === 404) {
            await new Promise(res => window.setTimeout(res, 1000));
            rawData = await fetch(`https://openlibrary.org/isbn/${isbn}.json`);
        }

        if(rawData.status === 404) {
            throw new errors.NotFound(isbn);
        }

        rawData = await rawData.json();

        var result = {};
        result.author = (await this.getAuthors(rawData)).join(' and ');
        result.type = 'Book';

        if(rawData.title) {
            result.title = rawData.title;
        }

        if(rawData.subtitle) {
            result.subtitle = rawData.subtitle;
        }

        if(rawData.publishers && rawData.publishers.length) {
            result.publisher = rawData.publishers[0];
        }

        if(rawData.publish_date) {
            var publishDate = new Date(rawData.publish_date);
            if(publishDate instanceof Date && !isNaN(publishDate)) {
                result.year = publishDate.getFullYear();
                result.month = months[publishDate.getMonth()];
            }
        }

        if(rawData.isbn_13 && rawData.isbn_13.length) {
            result.isbn = rawData.isbn_13[0];
        }

        fetchCache[isbn] = result;
        return result;
    },

    getAuthors: async function(payload) {
        var authors = [];

        if(payload.authors && payload.authors.length) {
            for(var i=0; i<payload.authors.length; i++) {
                var authorData = await fetch(`https://openlibrary.org${payload.authors[i].key}.json`);

                if(!authorData.ok) {
                    throw errors.NotFound
                }

                authorData = await authorData.json();
                if(authorData && authorData.name) {
                    authors.push(authorData.name);
                }
            }
        }

        if(payload.contributors && payload.contributors.length) {
            for(var i=0; i<payload.contributors.length; i++) {
                if(payload.contributors[i].role === 'Author') {
                    authors.push(payload.contributors[i].name);
                }
            }
        }

        return authors.map(this.authorNameToBibTeXFormat);
    },

    authorNameToBibTeXFormat: function(name) {
        var names = name.split(' ');
        var lastName = names.pop();

        if(!names.length) {
            return lastName;
        }

        return `${lastName}, ${names.join(' ')}`;
    },
}

/***/ }),

/***/ "../structured-text-editor/lib/lookup_refs/lookup_by_url.js":
/*!******************************************************************!*\
  !*** ../structured-text-editor/lib/lookup_refs/lookup_by_url.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var errors = __webpack_require__(/*! ./errors */ "../structured-text-editor/lib/lookup_refs/errors.js");
var lookupCache = {}
var months = ['Jan.', 'Feb.', 'Mar.', 'Apr.', 'May.', 'Jun.', 'Jul.', 'Aug.', 'Sep.', 'Oct.', 'Nov.', 'Dec'];
var apiEndpoint = 'https://djapi.eu-gb.mybluemix.net'
// var apiEndpoint = 'http://localhost:8080'

function getPublishedMonth(urlMeta) {
    try {
        var date = new Date(urlMeta['article:published_time'])

        if(!date || date == 'Invalid Date') {
            throw 'invalid publication date';
        }

        return months[date.getMonth()]
    } catch (ex) {
        console.log('error parsing publication date', ex)
        return ''
    }
}

function getPublishedYear(urlMeta) {
    try {
        var date = new Date(urlMeta['article:published_time'])

        if(!date || date == 'Invalid Date') {
            throw 'invalid publication date'
        }

        return date.getFullYear()
    } catch (ex) {
        console.log('error parsing publication date', ex)
        return ''
    }
}

function resultFromRespnose(urlMeta, url) {
    return {
        type: 'Website',
        title: (urlMeta.title && urlMeta.title.trim() !== '' ? urlMeta.title : urlMeta.description) || '',
        author: urlMeta.author || '',
        url: url || urlMeta.url || '',
        year: getPublishedYear(urlMeta),
        month: getPublishedMonth(urlMeta)
    }
}

module.exports = {

    isValidID: function(url) {
        return url && url.trim().match(/^https?:\/\//)
    },

    fetchJSON: async function(url) {

        if(!this.isValidID(url)) {
            throw new errors.InvalidID(url);
        }

        if(lookupCache[url]) {
            return lookupCache[url]
        }

        var urlMeta = await fetch(`${apiEndpoint}/api/v2/syncjobs/geturlmetadata?url=${encodeURIComponent(url)}`)

        if(!urlMeta.ok) {
            throw errors.NotFound
        }

        lookupCache[url] = resultFromRespnose(await urlMeta.json(), url)

        return lookupCache[url]
    }
}

/***/ }),

/***/ "../structured-text-editor/lib/pixelschubser/utils.js":
/*!************************************************************!*\
  !*** ../structured-text-editor/lib/pixelschubser/utils.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";


module.exports = {
    getElementPosition: function(el) {
        var xPos = 0,
            yPos = 0;

        while (el) {
            xPos += el.offsetLeft + el.clientLeft;
            yPos += el.offsetTop  + el.clientTop;

            el = el.offsetParent;
        }

        return {
            x: xPos,
            y: yPos
        };
    },

    getDistanceToRightWindowBorder: function(el) {
        var rect = el.getBoundingClientRect();
        if(!rect) return;
        return window.innerWidth - rect.x - rect.width;
    },

    copyNodeAttributes: function(srcNode, targetNode, skipAttributes) {
        skipAttributes = skipAttributes || [];

        for(var i=0; i<srcNode.attributes.length; i++) {
            if(skipAttributes.indexOf(srcNode.attributes[i].name) === -1) {
                targetNode.setAttribute(srcNode.attributes[i].name, srcNode.attributes[i].value);
            }
        }
    },

    getFirstParentWithTagName: function(el, tagName) {
        while(el && !el.tagName === tagName) {
            el = el.parentElement
        }

        return el
    },

    getAllTextNodesOfElement: function(el) {
      var n, a=[], walk = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null, false);

      while(n = walk.nextNode()) { a.push(n); }
      return a;
    },

    getLastVisibleChildOfElement: function(el) {
        var walk = document.createTreeWalker(el, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT, null, false);
        return walk.lastChild();
    },

    getFirstVisibleChildOfElement: function(el) {
        var walk = document.createTreeWalker(el, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT, null, false);
        return walk.nextNode();
    },

    copyEventListenersRecursively: function(srcNode, targetNode) {
        if(srcNode && targetNode) {
            this.copyEventListeners(srcNode, targetNode);
            for(let i=0; i<srcNode.childNodes.length; i++) {
                this.copyEventListenersRecursively(srcNode.childNodes[i], targetNode.childNodes[i]);
            }
        }
    },

    copyEventListeners: function(srcNode, targetNode) {
        targetNode.onclick = targetNode.onclick || srcNode.onclick;
        targetNode.ondragover = targetNode.ondragover || srcNode.ondragover;
        targetNode.ondragleave = targetNode.ondragleave || srcNode.ondragleave;
        targetNode.ondrop = targetNode.ondrop || srcNode.ondrop;
        targetNode.onchange = targetNode.onchange || srcNode.onchange;
        targetNode.onKeyUp = targetNode.onKeyUp || srcNode.onKeyUp;
        targetNode.onKeyDown = targetNode.onKeyDown || srcNode.onKeyDown;
        targetNode.onKeyEnter = targetNode.onKeyEnter || srcNode.onKeyEnter;
        targetNode.onKeyTab = targetNode.onKeyTab || srcNode.onKeyTab;
        targetNode.onKeyBackspace = targetNode.onKeyBackspace || srcNode.onKeyBackspace;
        targetNode.onKeyCombination = targetNode.onKeyCombination || srcNode.onKeyCombination;
        targetNode.onMarkupCleaningFinshed = targetNode.onMarkupCleaningFinshed || srcNode.onMarkupCleaningFinshed;
        targetNode.setContenteditable = targetNode.setContenteditable || srcNode.setContenteditable;
        targetNode.onSelectionChange = targetNode.onSelectionChange || srcNode.onSelectionChange;
        targetNode.onUnfocus = targetNode.onUnfocus || srcNode.onUnfocus;
        targetNode.onWindowResize = targetNode.onWindowResize || srcNode.onWindowResize;

        targetNode.sectionType = targetNode.sectionType || srcNode.sectionType;
    },

    getNodeIteratorPointingTo: function(node) {
        if(!node) { return; }
        var nodeIterator = document.createTreeWalker(
              document.body,
              NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT,
              function(node) {
                  return (node.length === 0 || node.innerHTML === '') ?
                        NodeFilter.FILTER_REJECT :
                        NodeFilter.FILTER_ACCEPT;
              }
        );

        nodeIterator.currentNode = node;

        return nodeIterator;
    },

    rescueLaTeXCharsFromEscape: function(str) {
        var mapping = {
            '\\': 'latexslash',
            '{': 'latexcmdstart',
            '}': 'latexcmdend',
            '$': 'latexcdollar',
        };

        return str.replace(/[\\{}$]/g, function(match) {
            return  mapping[match] ? ('--'+mapping[match]+'--') : '';
        });
    },

    restoreRescuedLaTeXChars: function(str) {
        var mapping = {
            'latexslash': '\\',
            'latexcmdstart': '{',
            'latexcmdend': '}',
            'latexcdollar': '$'
        };

        return str.replace(/--(latex.{5,8}?)--/g, function(match, codename) {
            console.log(codename, mapping[codename])
            return  mapping[codename] ? mapping[codename] : '';
        });
    },

    stringToAttributeSaveString: function(str) {
        var mapping = {
            '<': 'lt',
            '>': 'gt',
            '\'': 'apos',
            '"': 'quot'
        };

        return str.replace(/[<>'"]/g, function(match) {
            return  mapping[match] ? ('--'+mapping[match]+'--') : '';
        });
    },

    attributeSaveStringToString: function(str) {
        var mapping = {
            'lt': '<',
            'gt': '>',
            'apos': '\'',
            'quot': '"'
        };

        return str.replace(/--(.{2,4}?)--/g, function(match, code) {
            return mapping[code] || '';
        });
    },

    attributeSaveStringToHTMLEncoded: function(str) {
        return str.replace(/--(.{2,4}?)--/g, function(match, code) {
            return  '&' + code + ';';
        });
    },

    getSubtreeByChildNode: function(container, child) {
        while(child) {
            if(child && child.parentElement === container && child.nodeType !== Node.TEXT_NODE) {
                return child;
            }
            child = child.parentNode;
        }
    }
};


/***/ }),

/***/ "../structured-text-editor/lib/throttle/throttle.js":
/*!**********************************************************!*\
  !*** ../structured-text-editor/lib/throttle/throttle.js ***!
  \**********************************************************/
/***/ ((module) => {

//see: https://codeburst.io/throttling-and-debouncing-in-javascript-b01cad5c8edf
module.exports = function(limit, func) {
  let lastFunc;
  let lastRan;
  let lastReject;

  return function() {
      const context = this;
      const args = arguments;

      return new Promise((resolve, reject) => {
          if (!lastRan) {
              resolve(func.apply(context, args));
              lastRan = Date.now();
          } else {
              clearTimeout(lastFunc);

              if(lastReject) {
                  lastReject('canceled by throttle')
              }

              lastReject = reject

              lastFunc = setTimeout(function() {
                    if (Date.now() - lastRan >= limit) {
                        resolve(func.apply(context, args));
                        lastRan = Date.now();
                    }
              }, limit - (Date.now() - lastRan));
          }
      }).catch((err) => {
          console.log(err)

          if(err !== 'canceled by throttle') {
              return new Promise((_, reject) => reject(err))
          }
      });
  };
};


/***/ }),

/***/ "../structured-text-editor/lib/toc_builder/toc_builder.js":
/*!****************************************************************!*\
  !*** ../structured-text-editor/lib/toc_builder/toc_builder.js ***!
  \****************************************************************/
/***/ ((module) => {

function getNumberPreafixHTML(numbering) {
    if(!numbering || numbering.length === 0) { return '' }

    return '<span class="index-preafix">' + numbering + '. </span>'
}

function TOCEntryFromElement(h, args) {
    var link, result = document.createElement('li')

    if(h.el.hasAttribute('id') && args.withLinks) {
        link = document.createElement('a')
        link.setAttribute('href', '#' + h.el.getAttribute('id'))
        link.innerHTML = h.content
        result.appendChild(link)
    } else {
        result.innerHTML = h.content
    }

    if(h.numbering) {
        result.innerHTML = getNumberPreafixHTML(h.numbering) + result.innerHTML
    }

    if(h.el.classList.contains('missingLevelHint')) {
        result.classList = h.el.classList
    }
    return result
}

function missingLevelWaring(level) {
  var result = document.createElement('H' + level)
  result.classList.add('missingLevelHint')
  result.classList.add('level-' + level)

  return {
      level: level,
      content: '',
      el: result
  }
}

function annotateHeadingNumbering(DOMElement, args) {
    var c1 = c2 = c3 = c4 = c5 = c6 = 0;

    if(!Number.isInteger(args.startNumberingAtLevel) ||
       args.startNumberingAtLevel < 1 ||
       args.startNumberingAtLevel > 6) {
        return DOMElement;
    }

    DOMElement.querySelectorAll('h1, h2, h3, h4, h5, h6').forEach(function(heading) {
        var numbering

        if(heading.getAttribute('unnumbered-heading') === 'Yes') {
            heading.numbering = undefined;
            return;
        }

        if(heading.tagName === 'H1') {
            c2 = c3 = c4 = c5 = c6 = 0
            c1++
            heading.numbering = c1
            numbering = [c1]
        } else if(heading.tagName === 'H2') {
            c3 = c4 = c5 = c6 = 0
            c2++
            heading.numbering = c2
            numbering = [c1, c2]
        } else if(heading.tagName === 'H3') {
            c4 = c5 = c6 = 0
            c3++
            numbering = [c1, c2, c3]
        } else if(heading.tagName === 'H4') {
            c5 = c6 = 0
            c4++
            numbering = [c1, c2, c3, c4]
        } else if(heading.tagName === 'H5') {
            c6 = 0
            c5++
            numbering = [c1, c2, c3, c4, c5]
        } else if(heading.tagName === 'H6') {
            c6++
            numbering = [c1, c2, c3, c4, c5, c6]
        }

        if(numbering) {
            numbering.splice(0, args.startNumberingAtLevel-1)
            heading.numbering = numbering.join('.')
        }
    })

    return DOMElement
}

function extractHeadings(DOMElement) {
    var tmpMatch, headings = [];

    DOMElement.querySelectorAll('h1, h2, h3, h4, h5, h6').forEach(function(heading) {
        if((tmpMatch = heading.tagName.match(/^H(\d+)$/)) && !heading.classList.contains('no-toc-listing')) {
            headings.push({
                level: parseInt(tmpMatch[1]),
                content: heading.innerText,
                el: heading,
                numbering: heading.numbering
            })
        }
    });

    return headings;
}

function repairHierarchy(headings) {
    var result = [],
        currentLevel = 1

    headings.forEach((heading) => {
        let missingLevels = (heading.level - currentLevel)

        for(let i=0; missingLevels>1; missingLevels--) {
            result.push(missingLevelWaring(++currentLevel))
        }

        result.push(heading)

        if(missingLevels > 0) {
            currentLevel++
        } else if(missingLevels < 0) {
            currentLevel--
        }
    })

    return result
}

function TOCFromDOMElement(DOMElement, args) {
    args = args || {}
    var headings = repairHierarchy(extractHeadings(annotateHeadingNumbering(DOMElement, args))),
        result = document.createElement('ol'),
        currentList = result,
        currentLevel = 1

    headings.forEach((heading) => {
        if(currentLevel < heading.level) {
            let tmpList = document.createElement('ol')
            currentList.appendChild(tmpList)
            currentList = tmpList
            currentLevel = currentLevel+1
        }

        while(currentLevel > heading.level) {
            currentList = currentList.parentNode
            currentLevel = currentLevel-1
        }

        currentList.appendChild(TOCEntryFromElement(heading, args))
    })

    return result
}

module.exports = TOCFromDOMElement


/***/ }),

/***/ "../structured-text-editor/lib/zotero-client/index.js":
/*!************************************************************!*\
  !*** ../structured-text-editor/lib/zotero-client/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
    ZoteroOnline: __webpack_require__(/*! ./online */ "../structured-text-editor/lib/zotero-client/online.js")
}

/***/ }),

/***/ "../structured-text-editor/lib/zotero-client/online.js":
/*!*************************************************************!*\
  !*** ../structured-text-editor/lib/zotero-client/online.js ***!
  \*************************************************************/
/***/ ((module) => {

var months = ['Jan.', 'Feb.', 'Mar.', 'Apr.', 'May.', 'Jun.', 'Jul.', 'Aug.', 'Sep.', 'Oct.', 'Nov.', 'Dec']

function getNextLink(result) {
    const linkHeader = result.headers.get('Link')
    const nextMatch = linkHeader.split(',').map(x => x.match(/<(.+?)>; rel="(.+?)"/)).find(x => x[0] && x[1] && x[2] === 'next')

    if(nextMatch && nextMatch[1]) {
        return nextMatch[1]
    }
}

class ZoteroOnline {

    static transformResponseItem(item, lastModVersion) {
        const typeMap = {
            'book': 'Book',
            'webpage': 'Website',
            'encyclopediaArticle': 'Website',
            'blogPost': 'Website',
            'thesis': 'Mastersthesis',
            'conferencePaper': 'Conference',
            'journalArticle': 'Article',
            'bookSection': 'Inbook'
        }

        const getCreatorsByTypet = type => {
            if(!item || !item.data || !item.data.creators || !item.data.creators.filter) {
                return ''
            }

            return item.data.creators
                .filter(c => c)
                .filter(c => c.creatorType === type)
                .filter(c => c.lastName && c.firstName)
                .map(c => `${c.lastName}, ${c.firstName}`)
                .join(' and ')
        }

        const tryToParseYear = date => {
            if(!date) {
                return ''
            }

            try {
                return (new Date(date)).getFullYear().toString()
            } catch(ex) {
                return ''
            }
        }

        const tryToParseMonth = date => {
            if(!date) {
                return ''
            }

            try {
                return months[(new Date(date)).getMonth()]
            } catch(ex) {
                return ''
            }
        }

        const tryToParseDate = date => {
            if(!date) {
                return ''
            }

            try {
                return date.split('T')[0]
            } catch(ex) {
                return ''
            }
        }

        if(item.data) {
            return {
                lookupId: item.data.ISBN || item.data.DOI,
                id: item.key,
                type: typeMap[item.data.itemType] || 'Article',
                referenceSource: `zotero-online-${item.library.type}-${item.library.id}`,
                title: item.data.title,
                author: getCreatorsByTypet('author'),
                pages: item.data.numPages,
                volume: item.data.valume,
                url: item.data.url,
                series: item.data.series,
                publisher: item.data.publisher,
                edition: item.data.edition,
                date: tryToParseDate(item.data.accessDate),
                series: item.data.seriesNumber,
                booktitle: item.data.bookTitle,
                year: tryToParseYear(item.data.date),
                month: tryToParseMonth(item.data.date),
                editor: getCreatorsByTypet('editor'),
                zoteroLastModVersion: lastModVersion
            }
        }
    }

    constructor(apiKey, store) {
        this.apiKey = apiKey
        this.store = store || new Map()
        this.authHeaderOptions = {
            headers: {
                Authorization: `Bearer ${this.apiKey}`
            }
        }
    }

    async getLastModifiedVersion(scope, scopeID) {
        scope = scope === 'users' ? 'user' : 'group'

        return Object.values(this.store.all(true))
            .filter(item => item.id.startsWith(`zotero-online-item-${scopeID}`))
            .map(item => item.zoteroLastModVersion || 0)
            .reduce((a, b) => Math.max(a, b), 0)
    }

    async saveItem(item, scopeID) {
        await Promise.resolve(this.store.set(`zotero-online-item-${scopeID}-${item.id}`, item))
        return item
    }

    saveAllItem(items, lastModVersion, scopeID) {
        return Promise.all(items.map(item => {
            return this.saveItem(ZoteroOnline.transformResponseItem(item, lastModVersion), scopeID)
        }))
    }

    async loadUserInfo() {
        const result = await fetch(`https://api.zotero.org/keys/${this.apiKey}`)
        const body = await result.json()
        this.userID = body.userID
        this.userName = body.username
        return this
    }

    async groups() {
        const result = await fetch(`https://api.zotero.org/users/${this.userID}/groups`, this.authHeaderOptions)
        const body = await result.json()
        this._groups = body.map(r => r.data)
        return this._groups
    }

    async items() {
        await this.requestItems('users', this.userID)

        return Object.values(this.store.all(true))
            .filter(item => item.id.startsWith(`zotero-online-item-${this.userID}`))
    }

    async itemsByGroupID(groupID) {
        await this.requestItems('groups', groupID)

        return Object.values(this.store.all(true))
            .filter(item => item.id.startsWith(`zotero-online-item-${groupID}`))
    }

    async requestItems(scope, scopeID) {
        var [ body, nextLink, lastModVersion] = await this.requestJson(`https://api.zotero.org/${scope}/${scopeID}/items?since=${await this.getLastModifiedVersion(scope, scopeID)}`)
        var nextLink;

        var storedValues = await this.saveAllItem(body, lastModVersion, scopeID)

        while(nextLink) {
            [ body, nextLink ] = await this.requestJson(nextLink)
            storedValues.push(...(await this.saveAllItem(body, lastModVersion, scopeID)))
        }

        return Object.values(storedValues)
    }

    async requestJson(url) {
        const result = await fetch(url, this.authHeaderOptions)

        if(result.status !== 200) {
            throw 'Error while connecting to Zotero API'
        }

        return [
            await result.json(),
            getNextLink(result),
            result.headers.get('Last-Modified-Version')
        ]
    }
}

module.exports = ZoteroOnline

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/contains.js":
/*!***************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/contains.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ contains)
/* harmony export */ });
function contains(parent, child) {
  // $FlowFixMe: hasOwnProperty doesn't seem to work in tests
  var isShadow = Boolean(child.getRootNode && child.getRootNode().host); // First, attempt with faster native method

  if (parent.contains(child)) {
    return true;
  } // then fallback to custom implementation with Shadow DOM support
  else if (isShadow) {
      var next = child;

      do {
        if (next && parent.isSameNode(next)) {
          return true;
        } // $FlowFixMe: need a better way to handle this...


        next = next.parentNode || next.host;
      } while (next);
    } // Give up, the result is false


  return false;
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getBorders.js":
/*!*****************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getBorders.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getBorders)
/* harmony export */ });
/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getComputedStyle.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");



function toNumber(cssValue) {
  return parseFloat(cssValue) || 0;
}

function getBorders(element) {
  var computedStyle = (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) ? (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element) : {};
  return {
    top: toNumber(computedStyle.borderTopWidth),
    right: toNumber(computedStyle.borderRightWidth),
    bottom: toNumber(computedStyle.borderBottomWidth),
    left: toNumber(computedStyle.borderLeftWidth)
  };
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js":
/*!****************************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getBoundingClientRect)
/* harmony export */ });
function getBoundingClientRect(element) {
  var rect = element.getBoundingClientRect();
  return {
    width: rect.width,
    height: rect.height,
    top: rect.top,
    right: rect.right,
    bottom: rect.bottom,
    left: rect.left,
    x: rect.left,
    y: rect.top
  };
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js":
/*!**********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getClippingRect)
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _getViewportRect_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getViewportRect.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js");
/* harmony import */ var _getDocumentRect_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getDocumentRect.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js");
/* harmony import */ var _listScrollParents_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./listScrollParents.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js");
/* harmony import */ var _getOffsetParent_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./getOffsetParent.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./getDocumentElement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./getComputedStyle.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./instanceOf.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
/* harmony import */ var _getDecorations_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./getDecorations.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getDecorations.js");
/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./contains.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/contains.js");
/* harmony import */ var _utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/rectToClientRect.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/rectToClientRect.js");













function getClientRectFromMixedType(element, clippingParent) {
  return clippingParent === _enums_js__WEBPACK_IMPORTED_MODULE_0__.viewport ? (0,_utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_1__["default"])((0,_getViewportRect_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element)) : (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__.isHTMLElement)(clippingParent) ? (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_4__["default"])(clippingParent) : (0,_utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_1__["default"])((0,_getDocumentRect_js__WEBPACK_IMPORTED_MODULE_5__["default"])((0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_6__["default"])(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`


function getClippingParents(element) {
  var clippingParents = (0,_listScrollParents_js__WEBPACK_IMPORTED_MODULE_7__["default"])(element);
  var canEscapeClipping = ['absolute', 'fixed'].indexOf((0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_8__["default"])(element).position) >= 0;
  var clipperElement = canEscapeClipping && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__.isHTMLElement)(element) ? (0,_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_9__["default"])(element) : element;

  if (!(0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__.isElement)(clipperElement)) {
    return [];
  } // $FlowFixMe: https://github.com/facebook/flow/issues/1414


  return clippingParents.filter(function (clippingParent) {
    return (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__.isElement)(clippingParent) && (0,_contains_js__WEBPACK_IMPORTED_MODULE_10__["default"])(clippingParent, clipperElement);
  });
} // Gets the maximum area that the element is visible in due to any number of
// clipping parents


function getClippingRect(element, boundary, rootBoundary) {
  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents[0];
  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent);
    var decorations = (0,_getDecorations_js__WEBPACK_IMPORTED_MODULE_11__["default"])((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__.isHTMLElement)(clippingParent) ? clippingParent : (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_6__["default"])(element));
    accRect.top = Math.max(rect.top + decorations.top, accRect.top);
    accRect.right = Math.min(rect.right - decorations.right, accRect.right);
    accRect.bottom = Math.min(rect.bottom - decorations.bottom, accRect.bottom);
    accRect.left = Math.max(rect.left + decorations.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js":
/*!***********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getCompositeRect)
/* harmony export */ });
/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
/* harmony import */ var _getNodeScroll_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getNodeScroll.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getNodeName.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./instanceOf.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getDocumentElement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isScrollParent.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js");






 // Returns the composite rect of an element relative to its offsetParent.
// Composite means it takes into account transforms as well as layout.

function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }

  var documentElement = (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(offsetParent);
  var rect = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_1__["default"])(elementOrVirtualElement);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };

  if (!isFixed) {
    if ((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_2__["default"])(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
    (0,_isScrollParent_js__WEBPACK_IMPORTED_MODULE_3__["default"])(documentElement)) {
      scroll = (0,_getNodeScroll_js__WEBPACK_IMPORTED_MODULE_4__["default"])(offsetParent);
    }

    if ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_5__.isHTMLElement)(offsetParent)) {
      offsets = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_1__["default"])(offsetParent);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = (0,_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_6__["default"])(documentElement);
    }
  }

  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js":
/*!***********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getComputedStyle)
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindow.js");

function getComputedStyle(element) {
  return (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element).getComputedStyle(element);
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getDecorations.js":
/*!*********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getDecorations.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getDecorations)
/* harmony export */ });
/* harmony import */ var _getBorders_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getBorders.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getBorders.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getNodeName.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js");



 // Borders + scrollbars

function getDecorations(element) {
  var win = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);
  var borders = (0,_getBorders_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element);
  var isHTML = (0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element) === 'html';
  var winScrollBarX = (0,_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_3__["default"])(element);
  var x = element.clientWidth + borders.right;
  var y = element.clientHeight + borders.bottom; // HACK:
  // document.documentElement.clientHeight on iOS reports the height of the
  // viewport including the bottom bar, even if the bottom bar isn't visible.
  // If the difference between window innerHeight and html clientHeight is more
  // than 50, we assume it's a mobile bottom bar and ignore scrollbars.
  // * A 50px thick scrollbar is likely non-existent (macOS is 15px and Windows
  //   is about 17px)
  // * The mobile bar is 114px tall

  if (isHTML && win.innerHeight - element.clientHeight > 50) {
    y = win.innerHeight - borders.bottom;
  }

  return {
    top: isHTML ? 0 : element.clientTop,
    right: // RTL scrollbar (scrolling containers only)
    element.clientLeft > borders.left ? borders.right : // LTR scrollbar
    isHTML ? win.innerWidth - x - winScrollBarX : element.offsetWidth - x,
    bottom: isHTML ? win.innerHeight - y : element.offsetHeight - y,
    left: isHTML ? winScrollBarX : element.clientLeft
  };
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js":
/*!*************************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getDocumentElement)
/* harmony export */ });
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");

function getDocumentElement(element) {
  // $FlowFixMe: assume body is always available
  return ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isElement)(element) ? element.ownerDocument : element.document).documentElement;
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js":
/*!**********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getDocumentRect)
/* harmony export */ });
/* harmony import */ var _getCompositeRect_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getCompositeRect.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js");
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getDocumentElement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getWindowScroll.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js");




function getDocumentRect(element) {
  var win = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);
  var winScroll = (0,_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element);
  var documentRect = (0,_getCompositeRect_js__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(element), win);
  documentRect.height = Math.max(documentRect.height, win.innerHeight);
  documentRect.width = Math.max(documentRect.width, win.innerWidth);
  documentRect.x = -winScroll.scrollLeft;
  documentRect.y = -winScroll.scrollTop;
  return documentRect;
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js":
/*!***************************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getHTMLElementScroll)
/* harmony export */ });
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js":
/*!********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getLayoutRect)
/* harmony export */ });
// Returns the layout rect of an element relative to its offsetParent. Layout
// means it doesn't take into account transforms.
function getLayoutRect(element) {
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: element.offsetWidth,
    height: element.offsetHeight
  };
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getNodeName.js":
/*!******************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getNodeName.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getNodeName)
/* harmony export */ });
function getNodeName(element) {
  return element ? (element.nodeName || '').toLowerCase() : null;
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js":
/*!********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getNodeScroll)
/* harmony export */ });
/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindowScroll.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js");
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instanceOf.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _getHTMLElementScroll_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getHTMLElementScroll.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js");




function getNodeScroll(node) {
  if (node === (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node) || !(0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(node)) {
    return (0,_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__["default"])(node);
  } else {
    return (0,_getHTMLElementScroll_js__WEBPACK_IMPORTED_MODULE_3__["default"])(node);
  }
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js":
/*!**********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getOffsetParent)
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindow.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getNodeName.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getComputedStyle.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _isTableElement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isTableElement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/isTableElement.js");






function getTrueOffsetParent(element) {
  if (!(0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) || // https://github.com/popperjs/popper-core/issues/837
  (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element).position === 'fixed') {
    return null;
  }

  return element.offsetParent;
}

function getOffsetParent(element) {
  var window = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element);
  var offsetParent = getTrueOffsetParent(element); // Find the nearest non-table offsetParent

  while (offsetParent && (0,_isTableElement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent);
  }

  if (offsetParent && (0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_4__["default"])(offsetParent) === 'body' && (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(offsetParent).position === 'static') {
    return window;
  }

  return offsetParent || window;
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getParentNode.js":
/*!********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getParentNode.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getParentNode)
/* harmony export */ });
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getNodeName.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getDocumentElement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");


function getParentNode(element) {
  if ((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element) === 'html') {
    return element;
  }

  return (// $FlowFixMe: this is a quicker (but less type safe) way to save quite some bytes from the bundle
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    // $FlowFixMe: need a better way to handle this...
    element.host || // ShadowRoot detected
    // $FlowFixMe: HTMLElement is a Node
    (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element) // fallback

  );
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js":
/*!**********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getScrollParent)
/* harmony export */ });
/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getParentNode.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");
/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isScrollParent.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getNodeName.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instanceOf.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");




function getScrollParent(node) {
  if (['html', 'body', '#document'].indexOf((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node)) >= 0) {
    // $FlowFixMe: assume body is always available
    return node.ownerDocument.body;
  }

  if ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(node) && (0,_isScrollParent_js__WEBPACK_IMPORTED_MODULE_2__["default"])(node)) {
    return node;
  }

  return getScrollParent((0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_3__["default"])(node));
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js":
/*!**********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getViewportRect)
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindow.js");

function getViewportRect(element) {
  var win = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);
  var visualViewport = win.visualViewport;
  var width = win.innerWidth;
  var height = win.innerHeight; // We don't know which browsers have buggy or odd implementations of this, so
  // for now we're only applying it to iOS to fix the keyboard issue.
  // Investigation required

  if (visualViewport && /iPhone|iPod|iPad/.test(navigator.platform)) {
    width = visualViewport.width;
    height = visualViewport.height;
  }

  return {
    width: width,
    height: height,
    x: 0,
    y: 0
  };
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindow.js":
/*!****************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindow.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getWindow)
/* harmony export */ });
/*:: import type { Window } from '../types'; */

/*:: declare function getWindow(node: Node | Window): Window; */
function getWindow(node) {
  if (node.toString() !== '[object Window]') {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView : window;
  }

  return node;
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js":
/*!**********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getWindowScroll)
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindow.js");

function getWindowScroll(node) {
  var win = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft: scrollLeft,
    scrollTop: scrollTop
  };
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js":
/*!**************************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getWindowScrollBarX)
/* harmony export */ });
/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getDocumentElement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindowScroll.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js");



function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  // Popper 1 is broken in this case and never had a bug report so let's assume
  // it's not an issue. I don't think anyone ever specifies width on <html>
  // anyway.
  // Browsers where the left scrollbar doesn't cause an issue report `0` for
  // this (e.g. Edge 2019, IE11, Safari)
  return (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element)).left + (0,_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element).scrollLeft;
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/instanceOf.js":
/*!*****************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/instanceOf.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isElement": () => (/* binding */ isElement),
/* harmony export */   "isHTMLElement": () => (/* binding */ isHTMLElement)
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindow.js");

/*:: declare function isElement(node: mixed): boolean %checks(node instanceof
  Element); */

function isElement(node) {
  var OwnElement = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
/*:: declare function isHTMLElement(node: mixed): boolean %checks(node instanceof
  HTMLElement); */


function isHTMLElement(node) {
  var OwnElement = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}



/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js":
/*!*********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isScrollParent)
/* harmony export */ });
/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getComputedStyle.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");

function isScrollParent(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  var _getComputedStyle = (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element),
      overflow = _getComputedStyle.overflow,
      overflowX = _getComputedStyle.overflowX,
      overflowY = _getComputedStyle.overflowY;

  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/isTableElement.js":
/*!*********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/isTableElement.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isTableElement)
/* harmony export */ });
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getNodeName.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");

function isTableElement(element) {
  return ['table', 'td', 'th'].indexOf((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element)) >= 0;
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js":
/*!************************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ listScrollParents)
/* harmony export */ });
/* harmony import */ var _getScrollParent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getScrollParent.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js");
/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getParentNode.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getNodeName.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindow.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isScrollParent.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js");





function listScrollParents(element, list) {
  if (list === void 0) {
    list = [];
  }

  var scrollParent = (0,_getScrollParent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);
  var isBody = (0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scrollParent) === 'body';
  var win = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_2__["default"])(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], (0,_isScrollParent_js__WEBPACK_IMPORTED_MODULE_3__["default"])(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : // $FlowFixMe: isBody tells us target will be an HTMLElement here
  updatedList.concat(listScrollParents((0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_4__["default"])(target)));
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/enums.js":
/*!**************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/enums.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "afterMain": () => (/* binding */ afterMain),
/* harmony export */   "afterRead": () => (/* binding */ afterRead),
/* harmony export */   "afterWrite": () => (/* binding */ afterWrite),
/* harmony export */   "auto": () => (/* binding */ auto),
/* harmony export */   "basePlacements": () => (/* binding */ basePlacements),
/* harmony export */   "beforeMain": () => (/* binding */ beforeMain),
/* harmony export */   "beforeRead": () => (/* binding */ beforeRead),
/* harmony export */   "beforeWrite": () => (/* binding */ beforeWrite),
/* harmony export */   "bottom": () => (/* binding */ bottom),
/* harmony export */   "clippingParents": () => (/* binding */ clippingParents),
/* harmony export */   "end": () => (/* binding */ end),
/* harmony export */   "left": () => (/* binding */ left),
/* harmony export */   "main": () => (/* binding */ main),
/* harmony export */   "modifierPhases": () => (/* binding */ modifierPhases),
/* harmony export */   "placements": () => (/* binding */ placements),
/* harmony export */   "popper": () => (/* binding */ popper),
/* harmony export */   "read": () => (/* binding */ read),
/* harmony export */   "reference": () => (/* binding */ reference),
/* harmony export */   "right": () => (/* binding */ right),
/* harmony export */   "start": () => (/* binding */ start),
/* harmony export */   "top": () => (/* binding */ top),
/* harmony export */   "variationPlacements": () => (/* binding */ variationPlacements),
/* harmony export */   "viewport": () => (/* binding */ viewport),
/* harmony export */   "write": () => (/* binding */ write)
/* harmony export */ });
var top = 'top';
var bottom = 'bottom';
var right = 'right';
var left = 'left';
var auto = 'auto';
var basePlacements = [top, bottom, right, left];
var start = 'start';
var end = 'end';
var clippingParents = 'clippingParents';
var viewport = 'viewport';
var popper = 'popper';
var reference = 'reference';
var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []); // modifiers that need to read the DOM

var beforeRead = 'beforeRead';
var read = 'read';
var afterRead = 'afterRead'; // pure-logic modifiers

var beforeMain = 'beforeMain';
var main = 'main';
var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

var beforeWrite = 'beforeWrite';
var write = 'write';
var afterWrite = 'afterWrite';
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/index.js":
/*!**************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "afterMain": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.afterMain),
/* harmony export */   "afterRead": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.afterRead),
/* harmony export */   "afterWrite": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.afterWrite),
/* harmony export */   "auto": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.auto),
/* harmony export */   "basePlacements": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.basePlacements),
/* harmony export */   "beforeMain": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.beforeMain),
/* harmony export */   "beforeRead": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.beforeRead),
/* harmony export */   "beforeWrite": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.beforeWrite),
/* harmony export */   "bottom": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom),
/* harmony export */   "clippingParents": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.clippingParents),
/* harmony export */   "createPopper": () => (/* binding */ createPopper),
/* harmony export */   "end": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.end),
/* harmony export */   "left": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.left),
/* harmony export */   "main": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.main),
/* harmony export */   "modifierPhases": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.modifierPhases),
/* harmony export */   "placements": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.placements),
/* harmony export */   "popper": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper),
/* harmony export */   "popperGenerator": () => (/* binding */ popperGenerator),
/* harmony export */   "read": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.read),
/* harmony export */   "reference": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.reference),
/* harmony export */   "right": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.right),
/* harmony export */   "start": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.start),
/* harmony export */   "top": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.top),
/* harmony export */   "variationPlacements": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.variationPlacements),
/* harmony export */   "viewport": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.viewport),
/* harmony export */   "write": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.write)
/* harmony export */ });
/* harmony import */ var _dom_utils_getCompositeRect_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./dom-utils/getCompositeRect.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js");
/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./dom-utils/getLayoutRect.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js");
/* harmony import */ var _dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dom-utils/listScrollParents.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js");
/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./dom-utils/getOffsetParent.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./dom-utils/getComputedStyle.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _utils_orderModifiers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/orderModifiers.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/orderModifiers.js");
/* harmony import */ var _utils_debounce_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./utils/debounce.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/debounce.js");
/* harmony import */ var _utils_validateModifiers_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/validateModifiers.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/validateModifiers.js");
/* harmony import */ var _utils_uniqueBy_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/uniqueBy.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/uniqueBy.js");
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/getBasePlacement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _utils_mergeByName_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/mergeByName.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/mergeByName.js");
/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom-utils/instanceOf.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enums.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/enums.js");














var INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';
var INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';
var DEFAULT_OPTIONS = {
  placement: 'bottom',
  modifiers: [],
  strategy: 'absolute'
};

function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return !args.some(function (element) {
    return !(element && typeof element.getBoundingClientRect === 'function');
  });
}

function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }

  var _generatorOptions = generatorOptions,
      _generatorOptions$def = _generatorOptions.defaultModifiers,
      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
      _generatorOptions$def2 = _generatorOptions.defaultOptions,
      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions;
    }

    var state = {
      placement: 'bottom',
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, {}, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference,
        popper: popper
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state,
      setOptions: function setOptions(options) {
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, {}, state.options, {}, options);
        state.scrollParents = {
          reference: (0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isElement)(reference) ? (0,_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_2__["default"])(reference) : reference.contextElement ? (0,_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_2__["default"])(reference.contextElement) : [],
          popper: (0,_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_2__["default"])(popper)
        }; // Orders the modifiers based on their dependencies and `phase`
        // properties

        var orderedModifiers = (0,_utils_orderModifiers_js__WEBPACK_IMPORTED_MODULE_3__["default"])((0,_utils_mergeByName_js__WEBPACK_IMPORTED_MODULE_4__["default"])([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

        state.orderedModifiers = orderedModifiers.filter(function (m) {
          return m.enabled;
        }); // Validate the provided modifiers so that the consumer will get warned
        // if one of the modifiers is invalid for any reason

        if (true) {
          var modifiers = (0,_utils_uniqueBy_js__WEBPACK_IMPORTED_MODULE_5__["default"])([].concat(orderedModifiers, state.options.modifiers), function (_ref) {
            var name = _ref.name;
            return name;
          });
          (0,_utils_validateModifiers_js__WEBPACK_IMPORTED_MODULE_6__["default"])(modifiers);

          if ((0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_7__["default"])(state.options.placement) === _enums_js__WEBPACK_IMPORTED_MODULE_0__.auto) {
            var flipModifier = state.orderedModifiers.find(function (_ref2) {
              var name = _ref2.name;
              return name === 'flip';
            });

            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', 'present and enabled to work.'].join(' '));
            }
          }

          var _getComputedStyle = (0,_dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_8__["default"])(popper),
              marginTop = _getComputedStyle.marginTop,
              marginRight = _getComputedStyle.marginRight,
              marginBottom = _getComputedStyle.marginBottom,
              marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can
          // cause bugs with positioning, so we'll warn the consumer


          if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));
          }
        }

        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }

        var _state$elements = state.elements,
            reference = _state$elements.reference,
            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
        // anymore

        if (!areValidElements(reference, popper)) {
          if (true) {
            console.error(INVALID_ELEMENT_ERROR);
          }

          return;
        } // Store the reference and popper rects to be read by modifiers


        state.rects = {
          reference: (0,_dom_utils_getCompositeRect_js__WEBPACK_IMPORTED_MODULE_9__["default"])(reference, (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_10__["default"])(popper), state.options.strategy === 'fixed'),
          popper: (0,_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_11__["default"])(popper)
        }; // Modifiers have the ability to reset the current update cycle. The
        // most common use case for this is the `flip` modifier changing the
        // placement, which then needs to re-run all the modifiers, because the
        // logic was previously ran for the previous placement and is therefore
        // stale/incorrect

        state.reset = false;
        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
        // is filled with the initial data specified by the modifier. This means
        // it doesn't persist and is fresh on each update.
        // To ensure persistent data, use `${name}#persistent`

        state.orderedModifiers.forEach(function (modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;

        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (true) {
            __debug_loops__ += 1;

            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }

          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }

          var _state$orderedModifie = state.orderedModifiers[index],
              fn = _state$orderedModifie.fn,
              _state$orderedModifie2 = _state$orderedModifie.options,
              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
              name = _state$orderedModifie.name;

          if (typeof fn === 'function') {
            state = fn({
              state: state,
              options: _options,
              name: name,
              instance: instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: (0,_utils_debounce_js__WEBPACK_IMPORTED_MODULE_12__["default"])(function () {
        return new Promise(function (resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };

    if (!areValidElements(reference, popper)) {
      if (true) {
        console.error(INVALID_ELEMENT_ERROR);
      }

      return instance;
    }

    instance.setOptions(options).then(function (state) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state);
      }
    }); // Modifiers have the ability to execute arbitrary code before the first
    // update cycle runs. They will be executed in the same order as the update
    // cycle. This is useful when a modifier adds some persistent data that
    // other modifiers need to use, but the modifier is run after the dependent
    // one.

    function runModifierEffects() {
      state.orderedModifiers.forEach(function (_ref3) {
        var name = _ref3.name,
            _ref3$options = _ref3.options,
            options = _ref3$options === void 0 ? {} : _ref3$options,
            effect = _ref3.effect;

        if (typeof effect === 'function') {
          var cleanupFn = effect({
            state: state,
            name: name,
            instance: instance,
            options: options
          });

          var noopFn = function noopFn() {};

          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }

    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function (fn) {
        return fn();
      });
      effectCleanupFns = [];
    }

    return instance;
  };
}
var createPopper = /*#__PURE__*/popperGenerator();

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/applyStyles.js":
/*!******************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/applyStyles.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom-utils/getNodeName.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom-utils/instanceOf.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");

 // This modifier takes the styles prepared by the `computeStyles` modifier
// and applies them to the HTMLElements such as popper and arrow

function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function (name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name]; // arrow is optional + virtual elements

    if (!(0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) || !(0,_dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element)) {
      return;
    } // Flow doesn't support to extend this property, but it's the most
    // effective way to apply styles to an HTMLElement
    // $FlowFixMe


    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function (name) {
      var value = attributes[name];

      if (value === false) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? '' : value);
      }
    });
  });
}

function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: '0',
      top: '0',
      margin: '0'
    },
    arrow: {
      position: 'absolute'
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);

  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }

  return function () {
    Object.keys(state.elements).forEach(function (name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

      var style = styleProperties.reduce(function (style, property) {
        style[property] = '';
        return style;
      }, {}); // arrow is optional + virtual elements

      if (!(0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) || !(0,_dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element)) {
        return;
      } // Flow doesn't support to extend this property, but it's the most
      // effective way to apply styles to an HTMLElement
      // $FlowFixMe


      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'applyStyles',
  enabled: true,
  phase: 'write',
  fn: applyStyles,
  effect: effect,
  requires: ['computeStyles']
});

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/arrow.js":
/*!************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/arrow.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom-utils/getLayoutRect.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js");
/* harmony import */ var _dom_utils_contains_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../dom-utils/contains.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/contains.js");
/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/getMainAxisFromPlacement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js");
/* harmony import */ var _utils_within_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/within.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/within.js");
/* harmony import */ var _utils_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/mergePaddingObject.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/mergePaddingObject.js");
/* harmony import */ var _utils_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils/expandToHashMap.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/expandToHashMap.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom-utils/instanceOf.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");









 // eslint-disable-next-line import/no-unused-modules

function arrow(_ref) {
  var _state$modifiersData$;

  var state = _ref.state,
      name = _ref.name;
  var arrowElement = state.elements.arrow;
  var popperOffsets = state.modifiersData.popperOffsets;
  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(state.placement);
  var axis = (0,_utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(basePlacement);
  var isVertical = [_enums_js__WEBPACK_IMPORTED_MODULE_2__.left, _enums_js__WEBPACK_IMPORTED_MODULE_2__.right].indexOf(basePlacement) >= 0;
  var len = isVertical ? 'height' : 'width';

  if (!arrowElement || !popperOffsets) {
    return;
  }

  var paddingObject = state.modifiersData[name + "#persistent"].padding;
  var arrowRect = (0,_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_3__["default"])(arrowElement);
  var minProp = axis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_2__.top : _enums_js__WEBPACK_IMPORTED_MODULE_2__.left;
  var maxProp = axis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_2__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_2__.right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
  var startDiff = popperOffsets[axis] - state.rects.reference[axis];
  var arrowOffsetParent = (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(arrowElement);
  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
  // outside of the popper bounds

  var min = paddingObject[minProp];
  var max = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset = (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_5__["default"])(min, center, max); // Prevents breaking syntax highlighting...

  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}

function effect(_ref2) {
  var state = _ref2.state,
      options = _ref2.options,
      name = _ref2.name;
  var _options$element = options.element,
      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element,
      _options$padding = options.padding,
      padding = _options$padding === void 0 ? 0 : _options$padding;

  if (arrowElement == null) {
    return;
  } // CSS selector


  if (typeof arrowElement === 'string') {
    arrowElement = state.elements.popper.querySelector(arrowElement);

    if (!arrowElement) {
      return;
    }
  }

  if (true) {
    if (!(0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_6__.isHTMLElement)(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', 'To use an SVG arrow, wrap it in an HTMLElement that will be used as', 'the arrow.'].join(' '));
    }
  }

  if (!(0,_dom_utils_contains_js__WEBPACK_IMPORTED_MODULE_7__["default"])(state.elements.popper, arrowElement)) {
    if (true) {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', 'element.'].join(' '));
    }

    return;
  }

  state.elements.arrow = arrowElement;
  state.modifiersData[name + "#persistent"] = {
    padding: (0,_utils_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_8__["default"])(typeof padding !== 'number' ? padding : (0,_utils_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_9__["default"])(padding, _enums_js__WEBPACK_IMPORTED_MODULE_2__.basePlacements))
  };
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'arrow',
  enabled: true,
  phase: 'main',
  fn: arrow,
  effect: effect,
  requires: ['popperOffsets'],
  requiresIfExists: ['preventOverflow']
});

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/computeStyles.js":
/*!********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/computeStyles.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "mapToStyles": () => (/* binding */ mapToStyles)
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom-utils/getWindow.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom-utils/getDocumentElement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dom-utils/getComputedStyle.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getBasePlacement.js");





 // eslint-disable-next-line import/no-unused-modules

var unsetSides = {
  top: 'auto',
  right: 'auto',
  bottom: 'auto',
  left: 'auto'
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.

function roundOffsets(_ref) {
  var x = _ref.x,
      y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: Math.round(x * dpr) / dpr || 0,
    y: Math.round(y * dpr) / dpr || 0
  };
}

function mapToStyles(_ref2) {
  var _Object$assign2;

  var popper = _ref2.popper,
      popperRect = _ref2.popperRect,
      placement = _ref2.placement,
      offsets = _ref2.offsets,
      position = _ref2.position,
      gpuAcceleration = _ref2.gpuAcceleration,
      adaptive = _ref2.adaptive;

  var _roundOffsets = roundOffsets(offsets),
      x = _roundOffsets.x,
      y = _roundOffsets.y;

  var hasX = offsets.hasOwnProperty('x');
  var hasY = offsets.hasOwnProperty('y');
  var sideX = _enums_js__WEBPACK_IMPORTED_MODULE_0__.left;
  var sideY = _enums_js__WEBPACK_IMPORTED_MODULE_0__.top;
  var win = window;

  if (adaptive) {
    var offsetParent = (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_1__["default"])(popper);

    if (offsetParent === (0,_dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_2__["default"])(popper)) {
      offsetParent = (0,_dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(popper);
    } // $FlowFixMe: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it

    /*:: offsetParent = (offsetParent: Element); */


    if (placement === _enums_js__WEBPACK_IMPORTED_MODULE_0__.top) {
      sideY = _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom;
      y -= offsetParent.clientHeight - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }

    if (placement === _enums_js__WEBPACK_IMPORTED_MODULE_0__.left) {
      sideX = _enums_js__WEBPACK_IMPORTED_MODULE_0__.right;
      x -= offsetParent.clientWidth - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }

  var commonStyles = Object.assign({
    position: position
  }, adaptive && unsetSides);

  if (gpuAcceleration) {
    var _Object$assign;

    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) < 2 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }

  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
}

function computeStyles(_ref3) {
  var state = _ref3.state,
      options = _ref3.options;
  var _options$gpuAccelerat = options.gpuAcceleration,
      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
      _options$adaptive = options.adaptive,
      adaptive = _options$adaptive === void 0 ? true : _options$adaptive;

  if (true) {
    var transitionProperty = (0,_dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_4__["default"])(state.elements.popper).transitionProperty || '';

    if (adaptive && ['transform', 'top', 'right', 'bottom', 'left'].some(function (property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
      console.warn(['Popper: Detected CSS transitions on at least one of the following', 'CSS properties: "transform", "top", "right", "bottom", "left".', '\n\n', 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', 'for smooth transitions, or remove these properties from the CSS', 'transition declaration on the popper element if only transitioning', 'opacity or background-color for example.', '\n\n', 'We recommend using the popper element as a wrapper around an inner', 'element that can have any CSS property transitioned for animations.'].join(' '));
    }
  }

  var commonStyles = {
    placement: (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_5__["default"])(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration: gpuAcceleration
  };

  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, {}, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive: adaptive
    })));
  }

  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, {}, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: 'absolute',
      adaptive: false
    })));
  }

  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-placement': state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'computeStyles',
  enabled: true,
  phase: 'beforeWrite',
  fn: computeStyles,
  data: {}
});

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/eventListeners.js":
/*!*********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/eventListeners.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom-utils/getWindow.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
 // eslint-disable-next-line import/no-unused-modules

var passive = {
  passive: true
};

function effect(_ref) {
  var state = _ref.state,
      instance = _ref.instance,
      options = _ref.options;
  var _options$scroll = options.scroll,
      scroll = _options$scroll === void 0 ? true : _options$scroll,
      _options$resize = options.resize,
      resize = _options$resize === void 0 ? true : _options$resize;
  var window = (0,_dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

  if (scroll) {
    scrollParents.forEach(function (scrollParent) {
      scrollParent.addEventListener('scroll', instance.update, passive);
    });
  }

  if (resize) {
    window.addEventListener('resize', instance.update, passive);
  }

  return function () {
    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.removeEventListener('scroll', instance.update, passive);
      });
    }

    if (resize) {
      window.removeEventListener('resize', instance.update, passive);
    }
  };
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'eventListeners',
  enabled: true,
  phase: 'write',
  fn: function fn() {},
  effect: effect,
  data: {}
});

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/flip.js":
/*!***********************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/flip.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/getOppositePlacement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getOppositePlacement.js");
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/getOppositeVariationPlacement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js");
/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/detectOverflow.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _utils_computeAutoPlacement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/computeAutoPlacement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _utils_getVariation_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/getVariation.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getVariation.js");






 // eslint-disable-next-line import/no-unused-modules

function getExpandedFallbackPlacements(placement) {
  if ((0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_1__.auto) {
    return [];
  }

  var oppositePlacement = (0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(placement);
  return [(0,_utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(placement), oppositePlacement, (0,_utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(oppositePlacement)];
}

function flip(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;

  if (state.modifiersData[name]._skip) {
    return;
  }

  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
      specifiedFallbackPlacements = options.fallbackPlacements,
      padding = options.padding,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      _options$flipVariatio = options.flipVariations,
      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
      allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [(0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
    return acc.concat((0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_1__.auto ? (0,_utils_computeAutoPlacement_js__WEBPACK_IMPORTED_MODULE_4__["default"])(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      flipVariations: flipVariations,
      allowedAutoPlacements: allowedAutoPlacements
    }) : placement);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements[0];

  for (var i = 0; i < placements.length; i++) {
    var placement = placements[i];

    var _basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement);

    var isStartVariation = (0,_utils_getVariation_js__WEBPACK_IMPORTED_MODULE_5__["default"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_1__.start;
    var isVertical = [_enums_js__WEBPACK_IMPORTED_MODULE_1__.top, _enums_js__WEBPACK_IMPORTED_MODULE_1__.bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? 'width' : 'height';
    var overflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_6__["default"])(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      altBoundary: altBoundary,
      padding: padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? _enums_js__WEBPACK_IMPORTED_MODULE_1__.right : _enums_js__WEBPACK_IMPORTED_MODULE_1__.left : isStartVariation ? _enums_js__WEBPACK_IMPORTED_MODULE_1__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_1__.top;

    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = (0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(mainVariationSide);
    }

    var altVariationSide = (0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(mainVariationSide);
    var checks = [];

    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }

    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }

    if (checks.every(function (check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }

    checksMap.set(placement, checks);
  }

  if (makeFallbackChecks) {
    // `2` may be desired in some cases – research later
    var numberOfChecks = flipVariations ? 3 : 1;

    var _loop = function _loop(_i) {
      var fittingPlacement = placements.find(function (placement) {
        var checks = checksMap.get(placement);

        if (checks) {
          return checks.slice(0, _i).every(function (check) {
            return check;
          });
        }
      });

      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };

    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);

      if (_ret === "break") break;
    }
  }

  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'flip',
  enabled: true,
  phase: 'main',
  fn: flip,
  requiresIfExists: ['offset'],
  data: {
    _skip: false
  }
});

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/hide.js":
/*!***********************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/hide.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/detectOverflow.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/detectOverflow.js");



function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }

  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}

function isAnySideFullyClipped(overflow) {
  return [_enums_js__WEBPACK_IMPORTED_MODULE_0__.top, _enums_js__WEBPACK_IMPORTED_MODULE_0__.right, _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom, _enums_js__WEBPACK_IMPORTED_MODULE_0__.left].some(function (side) {
    return overflow[side] >= 0;
  });
}

function hide(_ref) {
  var state = _ref.state,
      name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state, {
    elementContext: 'reference'
  });
  var popperAltOverflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets: referenceClippingOffsets,
    popperEscapeOffsets: popperEscapeOffsets,
    isReferenceHidden: isReferenceHidden,
    hasPopperEscaped: hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-reference-hidden': isReferenceHidden,
    'data-popper-escaped': hasPopperEscaped
  });
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'hide',
  enabled: true,
  phase: 'main',
  requiresIfExists: ['preventOverflow'],
  fn: hide
});

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/offset.js":
/*!*************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/offset.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "distanceAndSkiddingToXY": () => (/* binding */ distanceAndSkiddingToXY)
/* harmony export */ });
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/enums.js");


function distanceAndSkiddingToXY(placement, rects, offset) {
  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement);
  var invertDistance = [_enums_js__WEBPACK_IMPORTED_MODULE_1__.left, _enums_js__WEBPACK_IMPORTED_MODULE_1__.top].indexOf(basePlacement) >= 0 ? -1 : 1;

  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
    placement: placement
  })) : offset,
      skidding = _ref[0],
      distance = _ref[1];

  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [_enums_js__WEBPACK_IMPORTED_MODULE_1__.left, _enums_js__WEBPACK_IMPORTED_MODULE_1__.right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}

function offset(_ref2) {
  var state = _ref2.state,
      options = _ref2.options,
      name = _ref2.name;
  var _options$offset = options.offset,
      offset = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = _enums_js__WEBPACK_IMPORTED_MODULE_1__.placements.reduce(function (acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement],
      x = _data$state$placement.x,
      y = _data$state$placement.y;

  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'offset',
  enabled: true,
  phase: 'main',
  requires: ['popperOffsets'],
  fn: offset
});

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/popperOffsets.js":
/*!********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/popperOffsets.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_computeOffsets_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/computeOffsets.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/computeOffsets.js");


function popperOffsets(_ref) {
  var state = _ref.state,
      name = _ref.name;
  // Offsets are the actual position the popper needs to have to be
  // properly positioned near its reference element
  // This is the most basic placement, and will be adjusted by
  // the modifiers in the next step
  state.modifiersData[name] = (0,_utils_computeOffsets_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: 'absolute',
    placement: state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'popperOffsets',
  enabled: true,
  phase: 'read',
  fn: popperOffsets,
  data: {}
});

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/preventOverflow.js":
/*!**********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/preventOverflow.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../enums.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/getMainAxisFromPlacement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js");
/* harmony import */ var _utils_getAltAxis_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/getAltAxis.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getAltAxis.js");
/* harmony import */ var _utils_within_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/within.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/within.js");
/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom-utils/getLayoutRect.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js");
/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/detectOverflow.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _utils_getVariation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/getVariation.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getVariation.js");
/* harmony import */ var _utils_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/getFreshSideObject.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getFreshSideObject.js");











function preventOverflow(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;
  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      padding = options.padding,
      _options$tether = options.tether,
      tether = _options$tether === void 0 ? true : _options$tether,
      _options$tetherOffset = options.tetherOffset,
      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(state, {
    boundary: boundary,
    rootBoundary: rootBoundary,
    padding: padding,
    altBoundary: altBoundary
  });
  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state.placement);
  var variation = (0,_utils_getVariation_js__WEBPACK_IMPORTED_MODULE_2__["default"])(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = (0,_utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(basePlacement);
  var altAxis = (0,_utils_getAltAxis_js__WEBPACK_IMPORTED_MODULE_4__["default"])(mainAxis);
  var popperOffsets = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var data = {
    x: 0,
    y: 0
  };

  if (!popperOffsets) {
    return;
  }

  if (checkMainAxis) {
    var mainSide = mainAxis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.top : _enums_js__WEBPACK_IMPORTED_MODULE_5__.left;
    var altSide = mainAxis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_5__.right;
    var len = mainAxis === 'y' ? 'height' : 'width';
    var offset = popperOffsets[mainAxis];
    var min = popperOffsets[mainAxis] + overflow[mainSide];
    var max = popperOffsets[mainAxis] - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === _enums_js__WEBPACK_IMPORTED_MODULE_5__.start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === _enums_js__WEBPACK_IMPORTED_MODULE_5__.start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
    // outside the reference bounds

    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? (0,_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_6__["default"])(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : (0,_utils_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_7__["default"])();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
    // to include its full size in the calculation. If the reference is small
    // and near the edge of a boundary, the popper can overflow even if the
    // reference is not overflowing as well (e.g. virtual elements with no
    // width or height)

    var arrowLen = (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_8__["default"])(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;
    var arrowOffsetParent = state.elements.arrow && (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_9__["default"])(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;
    var tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;
    var preventedOffset = (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_8__["default"])(tether ? Math.min(min, tetherMin) : min, offset, tether ? Math.max(max, tetherMax) : max);
    popperOffsets[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset;
  }

  if (checkAltAxis) {
    var _mainSide = mainAxis === 'x' ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.top : _enums_js__WEBPACK_IMPORTED_MODULE_5__.left;

    var _altSide = mainAxis === 'x' ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_5__.right;

    var _offset = popperOffsets[altAxis];

    var _min = _offset + overflow[_mainSide];

    var _max = _offset - overflow[_altSide];

    var _preventedOffset = (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_8__["default"])(_min, _offset, _max);

    popperOffsets[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'preventOverflow',
  enabled: true,
  phase: 'main',
  fn: preventOverflow,
  requiresIfExists: ['offset']
});

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/popper.js":
/*!***************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/popper.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createPopper": () => (/* binding */ createPopper),
/* harmony export */   "defaultModifiers": () => (/* binding */ defaultModifiers),
/* harmony export */   "detectOverflow": () => (/* reexport safe */ _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   "popperGenerator": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_9__.popperGenerator)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./index.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/index.js");
/* harmony import */ var _modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modifiers/eventListeners.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/eventListeners.js");
/* harmony import */ var _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modifiers/popperOffsets.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/popperOffsets.js");
/* harmony import */ var _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modifiers/computeStyles.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/computeStyles.js");
/* harmony import */ var _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modifiers/applyStyles.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/applyStyles.js");
/* harmony import */ var _modifiers_offset_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modifiers/offset.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/offset.js");
/* harmony import */ var _modifiers_flip_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modifiers/flip.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/flip.js");
/* harmony import */ var _modifiers_preventOverflow_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modifiers/preventOverflow.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/preventOverflow.js");
/* harmony import */ var _modifiers_arrow_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modifiers/arrow.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/arrow.js");
/* harmony import */ var _modifiers_hide_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./modifiers/hide.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/hide.js");
/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils/detectOverflow.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/detectOverflow.js");











var defaultModifiers = [_modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_0__["default"], _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_1__["default"], _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_2__["default"], _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_3__["default"], _modifiers_offset_js__WEBPACK_IMPORTED_MODULE_4__["default"], _modifiers_flip_js__WEBPACK_IMPORTED_MODULE_5__["default"], _modifiers_preventOverflow_js__WEBPACK_IMPORTED_MODULE_6__["default"], _modifiers_arrow_js__WEBPACK_IMPORTED_MODULE_7__["default"], _modifiers_hide_js__WEBPACK_IMPORTED_MODULE_8__["default"]];
var createPopper = /*#__PURE__*/(0,_index_js__WEBPACK_IMPORTED_MODULE_9__.popperGenerator)({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules



/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js":
/*!***********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ computeAutoPlacement)
/* harmony export */ });
/* harmony import */ var _getVariation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getVariation.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getVariation.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _detectOverflow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./detectOverflow.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getBasePlacement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getBasePlacement.js");





/*:: type OverflowsMap = { [ComputedPlacement]: number }; */

/*;; type OverflowsMap = { [key in ComputedPlacement]: number }; */
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      placement = _options.placement,
      boundary = _options.boundary,
      rootBoundary = _options.rootBoundary,
      padding = _options.padding,
      flipVariations = _options.flipVariations,
      _options$allowedAutoP = _options.allowedAutoPlacements,
      allowedAutoPlacements = _options$allowedAutoP === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.placements : _options$allowedAutoP;
  var variation = (0,_getVariation_js__WEBPACK_IMPORTED_MODULE_1__["default"])(placement);
  var placements = (variation ? flipVariations ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.variationPlacements : _enums_js__WEBPACK_IMPORTED_MODULE_0__.variationPlacements.filter(function (placement) {
    return (0,_getVariation_js__WEBPACK_IMPORTED_MODULE_1__["default"])(placement) === variation;
  }) : _enums_js__WEBPACK_IMPORTED_MODULE_0__.basePlacements).filter(function (placement) {
    return allowedAutoPlacements.indexOf(placement) >= 0;
  }); // $FlowFixMe: Flow seems to have problems with two array unions...

  var overflows = placements.reduce(function (acc, placement) {
    acc[placement] = (0,_detectOverflow_js__WEBPACK_IMPORTED_MODULE_2__["default"])(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding
    })[(0,_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(placement)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function (a, b) {
    return overflows[a] - overflows[b];
  });
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/computeOffsets.js":
/*!*****************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/utils/computeOffsets.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ computeOffsets)
/* harmony export */ });
/* harmony import */ var _getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBasePlacement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _getVariation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getVariation.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getVariation.js");
/* harmony import */ var _getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getMainAxisFromPlacement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/enums.js");




function computeOffsets(_ref) {
  var reference = _ref.reference,
      element = _ref.element,
      placement = _ref.placement;
  var basePlacement = placement ? (0,_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement) : null;
  var variation = placement ? (0,_getVariation_js__WEBPACK_IMPORTED_MODULE_1__["default"])(placement) : null;
  var commonX = reference.x + reference.width / 2 - element.width / 2;
  var commonY = reference.y + reference.height / 2 - element.height / 2;
  var offsets;

  switch (basePlacement) {
    case _enums_js__WEBPACK_IMPORTED_MODULE_2__.top:
      offsets = {
        x: commonX,
        y: reference.y - element.height
      };
      break;

    case _enums_js__WEBPACK_IMPORTED_MODULE_2__.bottom:
      offsets = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;

    case _enums_js__WEBPACK_IMPORTED_MODULE_2__.right:
      offsets = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;

    case _enums_js__WEBPACK_IMPORTED_MODULE_2__.left:
      offsets = {
        x: reference.x - element.width,
        y: commonY
      };
      break;

    default:
      offsets = {
        x: reference.x,
        y: reference.y
      };
  }

  var mainAxis = basePlacement ? (0,_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(basePlacement) : null;

  if (mainAxis != null) {
    var len = mainAxis === 'y' ? 'height' : 'width';

    switch (variation) {
      case _enums_js__WEBPACK_IMPORTED_MODULE_2__.start:
        offsets[mainAxis] = Math.floor(offsets[mainAxis]) - Math.floor(reference[len] / 2 - element[len] / 2);
        break;

      case _enums_js__WEBPACK_IMPORTED_MODULE_2__.end:
        offsets[mainAxis] = Math.floor(offsets[mainAxis]) + Math.ceil(reference[len] / 2 - element[len] / 2);
        break;

      default:
    }
  }

  return offsets;
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/debounce.js":
/*!***********************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/utils/debounce.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ debounce)
/* harmony export */ });
function debounce(fn) {
  var pending;
  return function () {
    if (!pending) {
      pending = new Promise(function (resolve) {
        Promise.resolve().then(function () {
          pending = undefined;
          resolve(fn());
        });
      });
    }

    return pending;
  };
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/detectOverflow.js":
/*!*****************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/utils/detectOverflow.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ detectOverflow)
/* harmony export */ });
/* harmony import */ var _dom_utils_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom-utils/getBoundingClientRect.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
/* harmony import */ var _dom_utils_getClippingRect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom-utils/getClippingRect.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js");
/* harmony import */ var _dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dom-utils/getDocumentElement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _computeOffsets_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./computeOffsets.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/computeOffsets.js");
/* harmony import */ var _rectToClientRect_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./rectToClientRect.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/rectToClientRect.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dom-utils/instanceOf.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mergePaddingObject.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/mergePaddingObject.js");
/* harmony import */ var _expandToHashMap_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./expandToHashMap.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/expandToHashMap.js");








 // eslint-disable-next-line import/no-unused-modules

function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$placement = _options.placement,
      placement = _options$placement === void 0 ? state.placement : _options$placement,
      _options$boundary = _options.boundary,
      boundary = _options$boundary === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.clippingParents : _options$boundary,
      _options$rootBoundary = _options.rootBoundary,
      rootBoundary = _options$rootBoundary === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.viewport : _options$rootBoundary,
      _options$elementConte = _options.elementContext,
      elementContext = _options$elementConte === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper : _options$elementConte,
      _options$altBoundary = _options.altBoundary,
      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
      _options$padding = _options.padding,
      padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = (0,_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_1__["default"])(typeof padding !== 'number' ? padding : (0,_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_2__["default"])(padding, _enums_js__WEBPACK_IMPORTED_MODULE_0__.basePlacements));
  var altContext = elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.reference : _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper;
  var referenceElement = state.elements.reference;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = (0,_dom_utils_getClippingRect_js__WEBPACK_IMPORTED_MODULE_3__["default"])((0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isElement)(element) ? element : element.contextElement || (0,_dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_5__["default"])(state.elements.popper), boundary, rootBoundary);
  var referenceClientRect = (0,_dom_utils_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_6__["default"])(referenceElement);
  var popperOffsets = (0,_computeOffsets_js__WEBPACK_IMPORTED_MODULE_7__["default"])({
    reference: referenceClientRect,
    element: popperRect,
    strategy: 'absolute',
    placement: placement
  });
  var popperClientRect = (0,_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_8__["default"])(Object.assign({}, popperRect, {}, popperOffsets));
  var elementClientRect = elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
  // 0 or negative = within the clipping rect

  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

  if (elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper && offsetData) {
    var offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function (key) {
      var multiply = [_enums_js__WEBPACK_IMPORTED_MODULE_0__.right, _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [_enums_js__WEBPACK_IMPORTED_MODULE_0__.top, _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom].indexOf(key) >= 0 ? 'y' : 'x';
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }

  return overflowOffsets;
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/expandToHashMap.js":
/*!******************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/utils/expandToHashMap.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ expandToHashMap)
/* harmony export */ });
function expandToHashMap(value, keys) {
  return keys.reduce(function (hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/format.js":
/*!*********************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/utils/format.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ format)
/* harmony export */ });
function format(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return [].concat(args).reduce(function (p, c) {
    return p.replace(/%s/, c);
  }, str);
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getAltAxis.js":
/*!*************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/utils/getAltAxis.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getAltAxis)
/* harmony export */ });
function getAltAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getBasePlacement.js":
/*!*******************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/utils/getBasePlacement.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getBasePlacement)
/* harmony export */ });

function getBasePlacement(placement) {
  return placement.split('-')[0];
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getFreshSideObject.js":
/*!*********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/utils/getFreshSideObject.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getFreshSideObject)
/* harmony export */ });
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js":
/*!***************************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getMainAxisFromPlacement)
/* harmony export */ });
function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getOppositePlacement.js":
/*!***********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/utils/getOppositePlacement.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getOppositePlacement)
/* harmony export */ });
var hash = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js":
/*!********************************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getOppositeVariationPlacement)
/* harmony export */ });
var hash = {
  start: 'end',
  end: 'start'
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function (matched) {
    return hash[matched];
  });
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getVariation.js":
/*!***************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/utils/getVariation.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getVariation)
/* harmony export */ });
function getVariation(placement) {
  return placement.split('-')[1];
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/mergeByName.js":
/*!**************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/utils/mergeByName.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mergeByName)
/* harmony export */ });
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function (merged, current) {
    var existing = merged[current.name];
    merged[current.name] = existing ? Object.assign({}, existing, {}, current, {
      options: Object.assign({}, existing.options, {}, current.options),
      data: Object.assign({}, existing.data, {}, current.data)
    }) : current;
    return merged;
  }, {}); // IE11 does not support Object.values

  return Object.keys(merged).map(function (key) {
    return merged[key];
  });
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/mergePaddingObject.js":
/*!*********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/utils/mergePaddingObject.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mergePaddingObject)
/* harmony export */ });
/* harmony import */ var _getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getFreshSideObject.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getFreshSideObject.js");

function mergePaddingObject(paddingObject) {
  return Object.assign({}, (0,_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(), {}, paddingObject);
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/orderModifiers.js":
/*!*****************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/utils/orderModifiers.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ orderModifiers)
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/enums.js");
 // source: https://stackoverflow.com/questions/49875255

function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function (modifier) {
    map.set(modifier.name, modifier);
  }); // On visiting object, check for its dependencies and visit them recursively

  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function (dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);

        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }

  modifiers.forEach(function (modifier) {
    if (!visited.has(modifier.name)) {
      // check for visited object
      sort(modifier);
    }
  });
  return result;
}

function orderModifiers(modifiers) {
  // order based on dependencies
  var orderedModifiers = order(modifiers); // order based on phase

  return _enums_js__WEBPACK_IMPORTED_MODULE_0__.modifierPhases.reduce(function (acc, phase) {
    return acc.concat(orderedModifiers.filter(function (modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/rectToClientRect.js":
/*!*******************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/utils/rectToClientRect.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ rectToClientRect)
/* harmony export */ });
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/uniqueBy.js":
/*!***********************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/utils/uniqueBy.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ uniqueBy)
/* harmony export */ });
function uniqueBy(arr, fn) {
  var identifiers = new Set();
  return arr.filter(function (item) {
    var identifier = fn(item);

    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/validateModifiers.js":
/*!********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/utils/validateModifiers.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ validateModifiers)
/* harmony export */ });
/* harmony import */ var _format_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./format.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/format.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/enums.js");


var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ['name', 'enabled', 'phase', 'fn', 'effect', 'requires', 'options'];
function validateModifiers(modifiers) {
  modifiers.forEach(function (modifier) {
    Object.keys(modifier).forEach(function (key) {
      switch (key) {
        case 'name':
          if (typeof modifier.name !== 'string') {
            console.error((0,_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', "\"" + String(modifier.name) + "\""));
          }

          break;

        case 'enabled':
          if (typeof modifier.enabled !== 'boolean') {
            console.error((0,_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', "\"" + String(modifier.enabled) + "\""));
          }

        case 'phase':
          if (_enums_js__WEBPACK_IMPORTED_MODULE_1__.modifierPhases.indexOf(modifier.phase) < 0) {
            console.error((0,_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + _enums_js__WEBPACK_IMPORTED_MODULE_1__.modifierPhases.join(', '), "\"" + String(modifier.phase) + "\""));
          }

          break;

        case 'fn':
          if (typeof modifier.fn !== 'function') {
            console.error((0,_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', "\"" + String(modifier.fn) + "\""));
          }

          break;

        case 'effect':
          if (typeof modifier.effect !== 'function') {
            console.error((0,_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', "\"" + String(modifier.fn) + "\""));
          }

          break;

        case 'requires':
          if (!Array.isArray(modifier.requires)) {
            console.error((0,_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', "\"" + String(modifier.requires) + "\""));
          }

          break;

        case 'requiresIfExists':
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error((0,_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', "\"" + String(modifier.requiresIfExists) + "\""));
          }

          break;

        case 'options':
        case 'data':
          break;

        default:
          console.error("PopperJS: an invalid property has been provided to the \"" + modifier.name + "\" modifier, valid properties are " + VALID_PROPERTIES.map(function (s) {
            return "\"" + s + "\"";
          }).join(', ') + "; but \"" + key + "\" was provided.");
      }

      modifier.requires && modifier.requires.forEach(function (requirement) {
        if (modifiers.find(function (mod) {
          return mod.name === requirement;
        }) == null) {
          console.error((0,_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/within.js":
/*!*********************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/utils/within.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ within)
/* harmony export */ });
function within(min, value, max) {
  return Math.max(min, Math.min(value, max));
}

/***/ }),

/***/ "../structured-text-editor/node_modules/changesets/lib/Builder.js":
/*!************************************************************************!*\
  !*** ../structured-text-editor/node_modules/changesets/lib/Builder.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Changeset = __webpack_require__(/*! ./Changeset */ "../structured-text-editor/node_modules/changesets/lib/Changeset.js")
  , Retain = __webpack_require__(/*! ./operations/Retain */ "../structured-text-editor/node_modules/changesets/lib/operations/Retain.js")
  , Skip = __webpack_require__(/*! ./operations/Skip */ "../structured-text-editor/node_modules/changesets/lib/operations/Skip.js")
  , Insert = __webpack_require__(/*! ./operations/Insert */ "../structured-text-editor/node_modules/changesets/lib/operations/Insert.js")

function Builder() {
  this.ops = []
  this.addendum = ''
  this.removendum = ''
}

module.exports = Builder

Builder.prototype.keep =
Builder.prototype.retain = function(len) {
  this.ops.push(new Retain(len))
  return this
}

Builder.prototype.delete =
Builder.prototype.skip = function(str) {
  this.removendum += str
  this.ops.push(new Skip(str.length))
  return this
}

Builder.prototype.add =
Builder.prototype.insert = function(str) {
  this.addendum += str
  this.ops.push(new Insert(str.length))
  return this
}

Builder.prototype.end = function() {
  var cs = new Changeset(this.ops)
  cs.addendum = this.addendum
  cs.removendum = this.removendum
  return cs
}


/***/ }),

/***/ "../structured-text-editor/node_modules/changesets/lib/Changeset.js":
/*!**************************************************************************!*\
  !*** ../structured-text-editor/node_modules/changesets/lib/Changeset.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * changesets
 * A Changeset library incorporating operational transformation (OT)
 * Copyright 2012 by Marcel Klehr <mklehr@gmx.net>
 *
 * (MIT LICENSE)
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * A sequence of consecutive operations
 *
 * @param ops.. <Operation> all passed operations will be added to the changeset
 */
function Changeset(ops/*or ops..*/) {
  this.addendum = ""
  this.removendum = ""
  this.inputLength = 0
  this.outputLength = 0

  if(!Array.isArray(ops)) ops = arguments
  for(var i=0; i<ops.length; i++) {
    this.push(ops[i])
    this.inputLength += ops[i].input
    this.outputLength += ops[i].output
  }
}

// True inheritance
Changeset.prototype = Object.create(Array.prototype, {
  constructor: {
    value: Changeset,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
module.exports = Changeset

var TextTransform = __webpack_require__(/*! ./TextTransform */ "../structured-text-editor/node_modules/changesets/lib/TextTransform.js")
  , ChangesetTransform = __webpack_require__(/*! ./ChangesetTransform */ "../structured-text-editor/node_modules/changesets/lib/ChangesetTransform.js")

var Retain = __webpack_require__(/*! ./operations/Retain */ "../structured-text-editor/node_modules/changesets/lib/operations/Retain.js")
  , Skip = __webpack_require__(/*! ./operations/Skip */ "../structured-text-editor/node_modules/changesets/lib/operations/Skip.js")
  , Insert = __webpack_require__(/*! ./operations/Insert */ "../structured-text-editor/node_modules/changesets/lib/operations/Insert.js")

var Builder = __webpack_require__(/*! ./Builder */ "../structured-text-editor/node_modules/changesets/lib/Builder.js")

/**
 * Returns an array containing the ops that are within the passed range
 * (only op.input is counted; thus not counting inserts to the range length, yet they are part of the range)
 */
Changeset.prototype.subrange = function(start, len) {
  var range = []
    , op, oplen
    , l=0
  for(var i=0, pos=0; i<this.length && l < len; i++) {
    op = this[i]
    if(op.input+pos >= start) {
      if(op.input) {
        if(op.length != Infinity) oplen = op.length -Math.max(0, start-pos) -Math.max(0, (op.length+pos)-(start+len))
        else oplen = len
        if (oplen !== 0) range.push( op.derive(oplen) ) // (Don't copy over more than len param allows)
      }
      else {
        range.push( op.derive(op.length) )
        oplen = 0
      }
      l += oplen
    }
    pos += op.input
  }
  return range
}

/**
 * Merge two changesets (that are based on the same state!) so that the resulting changseset
 * has the same effect as both orignal ones applied one after the other
 *
 * @param otherCs <Changeset>
 * @param left <boolean> Which op to choose if there's an insert tie (If you use this function in a distributed, synchronous environment, be sure to invert this param on the other site, otherwise it can be omitted safely))
 * @returns <Changeset>
 */
Changeset.prototype.merge = function(otherCs, left) {
  if(!(otherCs instanceof Changeset)) {
    throw new Error('Argument must be a #<Changeset>, but received '+otherCs.__proto__.constructor.name)
  }

  if(otherCs.inputLength !== this.outputLength) {
    throw new Error("Changeset lengths for merging don't match! Input length of younger cs: "+otherCs.inputLength+', output length of older cs:'+this.outputLength)
  }

  var newops = []
    , addPtr1 = 0
    , remPtr1 = 0
    , addPtr2 = 0
    , remPtr2 = 0
    , newaddendum = ''
    , newremovendum = ''

  zip(this, otherCs, function(op1, op2) {
    // console.log(newops)
    // console.log(op1, op2)

    // I'm deleting something -- the other cs can't know that, so just overtake my op
    if(op1 && !op1.output) {
      newops.push(op1.merge().clone())
      newremovendum += this.removendum.substr(remPtr1, op1.length) // overtake added chars
      remPtr1 += op1.length
      op1.length = 0 // don't gimme that one again.
      return
    }

    // op2 is an insert
    if(op2 && !op2.input) {
      newops.push(op2.merge().clone())
      newaddendum += otherCs.addendum.substr(addPtr2, op2.length) // overtake added chars
      addPtr2 += op2.length
      op2.length = 0 // don't gimme that one again.
      return
    }

    // op2 is either a retain or a skip
    if(op2 && op2.input && op1) {
      // op2 retains whatever we do here (retain or insert), so just clone my op
      if(op2.output) {
        newops.push(op1.merge(op2).clone())
        if(!op1.input) { // overtake addendum
          newaddendum += this.addendum.substr(addPtr1, op1.length)
          addPtr1 += op1.length
        }
        op1.length = 0 // don't gimme these again
        op2.length = 0
      }else

      // op2 deletes my retain here, so just clone the delete
      // (op1 can only be a retain and no skip here, cause we've handled skips above already)
      if(!op2.output && op1.input) {
        newops.push(op2.merge(op1).clone())
        newremovendum += otherCs.removendum.substr(remPtr2, op2.length) // overtake added chars
        remPtr2 += op2.length
        op1.length = 0 // don't gimme these again
        op2.length = 0
      }else

      //otherCs deletes something I added (-1) +1 = 0
      {
        addPtr1 += op1.length
        op1.length = 0 // don't gimme these again
        op2.length = 0
      }
      return
    }

    console.log('oops', arguments)
    throw new Error('oops. This case hasn\'t been considered by the developer (error code: PBCAC)')
  }.bind(this))

  var newCs = new Changeset(newops)
  newCs.addendum = newaddendum
  newCs.removendum = newremovendum

  return newCs
}

/**
 * A private and quite handy function that slices ops into equally long pieces and applies them on a mapping function
 * that can determine the iteration steps by setting op.length to 0 on an op (equals using .next() in a usual iterator)
 */
function zip(cs1, cs2, func) {
  var opstack1 = cs1.map(function(op) {return op.clone()}) // copy ops
    , opstack2 = cs2.map(function(op) {return op.clone()})

  var op2, op1
  while(opstack1.length || opstack2.length) {// iterate through all outstanding ops of this cs
    op1 = opstack1[0]? opstack1[0].clone() : null
    op2 = opstack2[0]? opstack2[0].clone() : null

    if(op1) {
      if(op2) op1 = op1.derive(Math.min(op1.length, op2.length)) // slice 'em into equally long pieces
      if(opstack1[0].length > op1.length) opstack1[0] = opstack1[0].derive(opstack1[0].length-op1.length)
      else opstack1.shift()
    }

    if(op2) {
      if(op1) op2 = op2.derive(Math.min(op1.length, op2.length)) // slice 'em into equally long pieces
      if(opstack2[0].length > op2.length) opstack2[0] = opstack2[0].derive(opstack2[0].length-op2.length)
      else opstack2.shift()
    }

    func(op1, op2)

    if(op1 && op1.length) opstack1.unshift(op1)
    if(op2 && op2.length) opstack2.unshift(op2)
  }
}

/**
 * Inclusion Transformation (IT) or Forward Transformation
 *
 * transforms the operations of the current changeset against the
 * all operations in another changeset in such a way that the
 * effects of the latter are effectively included.
 * This is basically like a applying the other cs on this one.
 *
 * @param otherCs <Changeset>
 * @param left <boolean> Which op to choose if there's an insert tie (If you use this function in a distributed, synchronous environment, be sure to invert this param on the other site, otherwise it can be omitted safely)
 *
 * @returns <Changeset>
 */
Changeset.prototype.transformAgainst = function(otherCs, left) {
  if(!(otherCs instanceof Changeset)) {
    throw new Error('Argument to Changeset#transformAgainst must be a #<Changeset>, but received '+otherCs.__proto__.constructor.name)
  }

  if(this.inputLength != otherCs.inputLength) {
    throw new Error('Can\'t transform changesets with differing inputLength: '+this.inputLength+' and '+otherCs.inputLength)
  }

  var transformation = new ChangesetTransform(this, [new Retain(Infinity)])
  otherCs.forEach(function(op) {
    var nextOp = this.subrange(transformation.pos, Infinity)[0] // next op of this cs
    if(nextOp && !nextOp.input && !op.input) { // two inserts tied; left breaks it
      if (left) transformation.writeOutput(transformation.readInput(nextOp.length))
    }
    op.apply(transformation)
  }.bind(this))

  return transformation.result()
}

/**
 * Exclusion Transformation (ET) or Backwards Transformation
 *
 * transforms all operations in the current changeset against the operations
 * in another changeset in such a way that the impact of the latter are effectively excluded
 *
 * @param changeset <Changeset> the changeset to substract from this one
 * @param left <boolean> Which op to choose if there's an insert tie (If you use this function in a distributed, synchronous environment, be sure to invert this param on the other site, otherwise it can be omitted safely)
 * @returns <Changeset>
 */
Changeset.prototype.substract = function(changeset, left) {
  // The current operations assume that the changes in
  // `changeset` happened before, so for each of those ops
  // we create an operation that undoes its effect and
  // transform all our operations on top of the inverse changes
  return this.transformAgainst(changeset.invert(), left)
}

/**
 * Returns the inverse Changeset of the current one
 *
 * Changeset.invert().apply(Changeset.apply(document)) == document
 */
Changeset.prototype.invert = function() {
  // invert all ops
  var newCs = new Changeset(this.map(function(op) {
    return op.invert()
  }))

  // removendum becomes addendum and vice versa
  newCs.addendum = this.removendum
  newCs.removendum = this.addendum

  return newCs
}

/**
 * Applies this changeset on a text
 */
Changeset.prototype.apply = function(input) {
  // pre-requisites
  if(input.length != this.inputLength) throw new Error('Input length doesn\'t match expected length. expected: '+this.inputLength+'; actual: '+input.length)

  var operation = new TextTransform(input, this.addendum, this.removendum)

  this.forEach(function(op) {
    // each Operation has access to all pointers as well as the input, addendum and removendum (the latter are immutable)
    op.apply(operation)
  }.bind(this))

  return operation.result()
}

/**
 * Returns an array of strings describing this changeset's operations
 */
Changeset.prototype.inspect = function() {
  var j = 0
  return this.map(function(op) {
    var string = ''

    if(!op.input) { // if Insert
      string = this.addendum.substr(j,op.length)
      j += op.length
      return string
    }

    for(var i=0; i<op.length; i++) string += op.symbol
    return string
  }.bind(this)).join('')
}

/**
 * Serializes the given changeset in order to return a (hopefully) more compact representation
 * than json that can be sent through a network or stored in a database
 *
 * Numbers are converted to the base 36, unsafe chars in the text are urlencoded
 *
 * @param cs <Changeset> The changeset to be serialized
 * @returns <String> The serialized changeset
 */
Changeset.prototype.pack = function() {
  var packed = this.map(function(op) {
    return op.pack()
  }).join('')

  var addendum = this.addendum.replace(/%/g, '%25').replace(/\|/g, '%7C')
    , removendum = this.removendum.replace(/%/g, '%25').replace(/\|/g, '%7C')
  return packed+'|'+addendum+'|'+removendum
}
Changeset.prototype.toString = function() {
  return this.pack()
}

/**
 * Unserializes the output of cs.text.Changeset#toString()
 *
 * @param packed <String> The serialized changeset
 * @param <cs.Changeset>
 */
Changeset.unpack = function(packed) {
  if(packed == '') throw new Error('Cannot unpack from empty string')
  var components = packed.split('|')
    , opstring = components[0]
    , addendum = components[1].replace(/%7c/gi, '|').replace(/%25/g, '%')
    , removendum = components[2].replace(/%7c/gi, '|').replace(/%25/g, '%')

  var matches = opstring.match(/[=+-]([^=+-])+/g)
  if(!matches) throw new Error('Cannot unpack invalidly serialized op string')

  var ops = []
  matches.forEach(function(s) {
    var symbol = s.substr(0,1)
      , data = s.substr(1)
    if(Skip.prototype.symbol == symbol) return ops.push(Skip.unpack(data))
    if(Insert.prototype.symbol == symbol) return ops.push(Insert.unpack(data))
    if(Retain.prototype.symbol == symbol) return ops.push(Retain.unpack(data))
    throw new Error('Invalid changeset representation passed to Changeset.unpack')
  })

  var cs = new Changeset(ops)
  cs.addendum = addendum
  cs.removendum = removendum

  return cs
}

Changeset.create = function() {
  return new Builder
}

/**
 * Returns a Changeset containing the operations needed to transform text1 into text2
 *
 * @param text1 <String>
 * @param text2 <String>
 */
Changeset.fromDiff = function(diff) {
  /**
   * The data structure representing a diff is an array of tuples:
   * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
   * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
   */
  var DIFF_DELETE = -1;
  var DIFF_INSERT = 1;
  var DIFF_EQUAL = 0;

  var ops = []
    , removendum = ''
    , addendum = ''

  diff.forEach(function(d) {
    if (DIFF_DELETE == d[0]) {
      ops.push(new Skip(d[1].length))
      removendum += d[1]
    }

    if (DIFF_INSERT == d[0]) {
      ops.push(new Insert(d[1].length))
      addendum += d[1]
    }

    if(DIFF_EQUAL == d[0]) {
      ops.push(new Retain(d[1].length))
    }
  })

  var cs = new Changeset(ops)
  cs.addendum = addendum
  cs.removendum = removendum
  return cs
}


/***/ }),

/***/ "../structured-text-editor/node_modules/changesets/lib/ChangesetTransform.js":
/*!***********************************************************************************!*\
  !*** ../structured-text-editor/node_modules/changesets/lib/ChangesetTransform.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * changesets
 * A Changeset library incorporating operational ChangesetTransform (OT)
 * Copyright 2012 by Marcel Klehr <mklehr@gmx.net>
 *
 * (MIT LICENSE)
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var Retain = __webpack_require__(/*! ./operations/Retain */ "../structured-text-editor/node_modules/changesets/lib/operations/Retain.js")
  , Skip = __webpack_require__(/*! ./operations/Skip */ "../structured-text-editor/node_modules/changesets/lib/operations/Skip.js")
  , Insert = __webpack_require__(/*! ./operations/Insert */ "../structured-text-editor/node_modules/changesets/lib/operations/Insert.js")
  , Changeset = __webpack_require__(/*! ./Changeset */ "../structured-text-editor/node_modules/changesets/lib/Changeset.js")


function ChangesetTransform(inputCs, addendum) {
  this.output = []
  this.addendum = addendum
  this.newRemovendum = ''
  this.newAddendum = ''

  this.cs = inputCs
  this.pos = 0
  this.addendumPointer = 0
  this.removendumPointer = 0
}
module.exports = ChangesetTransform

ChangesetTransform.prototype.readInput = function (len) {
  var ret = this.cs.subrange(this.pos, len)
  this.pos += len
  return ret
}

ChangesetTransform.prototype.readAddendum = function (len) {
  //return [new Retain(len)]
  var ret = this.subrange(this.addendum, this.addendumPointer, len)
  this.addendumPointer += len
  return ret
}

ChangesetTransform.prototype.writeRemovendum = function (range) {
  range
    .filter(function(op) {return !op.output})
    .forEach(function(op) {
      this.removendumPointer += op.length
    }.bind(this))
}

ChangesetTransform.prototype.writeOutput = function (range) {
  this.output = this.output.concat(range)
  range
    .filter(function(op) {return !op.output})
    .forEach(function(op) {
      this.newRemovendum += this.cs.removendum.substr(this.removendumPointer, op.length)
      this.removendumPointer += op.length
    }.bind(this))
}

ChangesetTransform.prototype.subrange = function (range, start, len) {
  if(len) return this.cs.subrange.call(range, start, len)
  else return range.filter(function(op){ return !op.input})
}

ChangesetTransform.prototype.result = function() {
  this.writeOutput(this.readInput(Infinity))
  var newCs = new Changeset(this.output)
  newCs.addendum = this.cs.addendum
  newCs.removendum = this.newRemovendum
  return newCs
}


/***/ }),

/***/ "../structured-text-editor/node_modules/changesets/lib/Operator.js":
/*!*************************************************************************!*\
  !*** ../structured-text-editor/node_modules/changesets/lib/Operator.js ***!
  \*************************************************************************/
/***/ ((module) => {

function Operator() {
}

module.exports = Operator

Operator.prototype.clone = function() {
  return this.derive(this.length)
}

Operator.prototype.derive = function(len) {
  return new (this.constructor)(len)
}

Operator.prototype.pack = function() {
  return this.symbol + (this.length).toString(36)
}


/***/ }),

/***/ "../structured-text-editor/node_modules/changesets/lib/TextTransform.js":
/*!******************************************************************************!*\
  !*** ../structured-text-editor/node_modules/changesets/lib/TextTransform.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * changesets
 * A Changeset library incorporating operational Apply (OT)
 * Copyright 2012 by Marcel Klehr <mklehr@gmx.net>
 *
 * (MIT LICENSE)
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var Retain = __webpack_require__(/*! ./operations/Retain */ "../structured-text-editor/node_modules/changesets/lib/operations/Retain.js")
  , Skip = __webpack_require__(/*! ./operations/Skip */ "../structured-text-editor/node_modules/changesets/lib/operations/Skip.js")
  , Insert = __webpack_require__(/*! ./operations/Insert */ "../structured-text-editor/node_modules/changesets/lib/operations/Insert.js")
  , Insert = __webpack_require__(/*! ./Changeset */ "../structured-text-editor/node_modules/changesets/lib/Changeset.js")


function TextTransform(input, addendum, removendum) {
  this.output = ''

  this.input = input
  this.addendum = addendum
  this.removendum = removendum
  this.pos = 0
  this.addPos = 0
  this.remPos = 0
}
module.exports = TextTransform

TextTransform.prototype.readInput = function (len) {
  var ret = this.input.substr(this.pos, len)
  this.pos += len
  return ret
}

TextTransform.prototype.readAddendum = function (len) {
  var ret = this.addendum.substr(this.addPos, len)
  this.addPos += len
  return ret
}

TextTransform.prototype.writeRemovendum = function (range) {
  //var expected = this.removendum.substr(this.remPos, range.length)
  //if(range != expected) throw new Error('Removed chars don\'t match removendum. expected: '+expected+'; actual: '+range)
  this.remPos += range.length
}

TextTransform.prototype.writeOutput = function (range) {
  this.output += range
}

TextTransform.prototype.subrange = function (range, start, len) {
  return range.substr(start, len)
}

TextTransform.prototype.result = function() {
  this.writeOutput(this.readInput(Infinity))
  return this.output
}


/***/ }),

/***/ "../structured-text-editor/node_modules/changesets/lib/index.js":
/*!**********************************************************************!*\
  !*** ../structured-text-editor/node_modules/changesets/lib/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*!
 * changesets
 * A Changeset library incorporating operational transformation (OT)
 * Copyright 2012 by Marcel Klehr <mklehr@gmx.net>
 *
 * (MIT LICENSE)
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var Changeset = __webpack_require__(/*! ./Changeset */ "../structured-text-editor/node_modules/changesets/lib/Changeset.js")
  , Retain = __webpack_require__(/*! ./operations/Retain */ "../structured-text-editor/node_modules/changesets/lib/operations/Retain.js")
  , Skip = __webpack_require__(/*! ./operations/Skip */ "../structured-text-editor/node_modules/changesets/lib/operations/Skip.js")
  , Insert = __webpack_require__(/*! ./operations/Insert */ "../structured-text-editor/node_modules/changesets/lib/operations/Insert.js")

exports.Operator = __webpack_require__(/*! ./Operator */ "../structured-text-editor/node_modules/changesets/lib/Operator.js")
exports.Changeset = Changeset
exports.Insert = Insert
exports.Retain = Retain
exports.Skip = Skip

if('undefined' != typeof window) window.changesets = exports

/**
 * Serializes the given changeset in order to return a (hopefully) more compact representation
 * that can be sent through a network or stored in a database
 * @alias cs.text.Changeset#pack
 */
exports.pack = function(cs) {
  return cs.pack()
}

/**
 * Unserializes the output of cs.text.pack
 * @alias cs.text.Changeset.unpack
 */
exports.unpack = function(packed) {
  return Changeset.unpack(packed)
}




/**
 * shareJS ot type API sepc support
 */

exports.name = 'changesets'
exports.url = 'https://github.com/marcelklehr/changesets'

/**
 * create([initialText])
 *
 * creates a snapshot (optionally with supplied intial text)
 */
exports.create = function(initText) {
  return initText || ''
}

/**
 * Apply a changeset on a snapshot creating a new one
 *
 * The old snapshot object mustn't be used after calling apply on it
 * returns the resulting
 */
exports.apply = function(snapshot, op) {
  op = exports.unpack(op)
  return op.apply(snapshot)
}

/**
 * Transform changeset1 against changeset2
 */
exports.transform = function (op1, op2, side) {
  op1 = exports.unpack(op1)
  op2 = exports.unpack(op2)
  return exports.pack(op1.transformAgainst(op2, ('left'==side)))
}

/**
 * Merge two changesets into one
 */
exports.compose = function (op1, op2) {
  op1 = exports.unpack(op1)
  op2 = exports.unpack(op2)
  return exports.pack(op1.merge(op2))
}

/**
 * Invert a changeset
 */
exports.invert = function(op) {
  return exports.pack(exports.unpack(op).invert())
}


/***/ }),

/***/ "../structured-text-editor/node_modules/changesets/lib/operations/Insert.js":
/*!**********************************************************************************!*\
  !*** ../structured-text-editor/node_modules/changesets/lib/operations/Insert.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * changesets
 * A Changeset library incorporating operational transformation (OT)
 * Copyright 2012 by Marcel Klehr <mklehr@gmx.net>
 *
 * (MIT LICENSE)
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var Operator = __webpack_require__(/*! ../Operator */ "../structured-text-editor/node_modules/changesets/lib/Operator.js")

/**
 * Insert Operator
 * Defined by:
 * - length
 * - input=0
 * - output=length
 *
 * @param length <Number> How many chars to be inserted
 */
function Insert(length) {
  this.length = length
  this.input = 0
  this.output = length
}

// True inheritance
Insert.prototype = Object.create(Operator.prototype, {
  constructor: {
    value: Insert,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
module.exports = Insert
Insert.prototype.symbol = '+'

var Skip = __webpack_require__(/*! ./Skip */ "../structured-text-editor/node_modules/changesets/lib/operations/Skip.js")
  , Retain = __webpack_require__(/*! ./Retain */ "../structured-text-editor/node_modules/changesets/lib/operations/Retain.js")

Insert.prototype.apply = function(t) {
  t.writeOutput(t.readAddendum(this.output))
}

Insert.prototype.merge = function() {
  return this
}

Insert.prototype.invert = function() {
  return new Skip(this.length)
}

Insert.unpack = function(data) {
  return new Insert(parseInt(data, 36))
}


/***/ }),

/***/ "../structured-text-editor/node_modules/changesets/lib/operations/Retain.js":
/*!**********************************************************************************!*\
  !*** ../structured-text-editor/node_modules/changesets/lib/operations/Retain.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * changesets
 * A Changeset library incorporating operational transformation (OT)
 * Copyright 2012 by Marcel Klehr <mklehr@gmx.net>
 *
 * (MIT LICENSE)
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var Operator = __webpack_require__(/*! ../Operator */ "../structured-text-editor/node_modules/changesets/lib/Operator.js")

/**
 * Retain Operator
 * Defined by:
 * - length
 * - input=output=length
 *
 * @param length <Number> How many chars to retain
 */
function Retain(length) {
  this.length = length
  this.input = length
  this.output = length
}

// True inheritance
Retain.prototype = Object.create(Operator.prototype, {
  constructor: {
    value: Retain,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
module.exports = Retain
Retain.prototype.symbol = '='

Retain.prototype.apply = function(t) {
  t.writeOutput(t.readInput(this.input))
}

Retain.prototype.invert = function() {
  return this
}

Retain.prototype.merge = function(op2) {
  return this
}

Retain.unpack = function(data) {
  return new Retain(parseInt(data, 36))
}


/***/ }),

/***/ "../structured-text-editor/node_modules/changesets/lib/operations/Skip.js":
/*!********************************************************************************!*\
  !*** ../structured-text-editor/node_modules/changesets/lib/operations/Skip.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * changesets
 * A Changeset library incorporating operational transformation (OT)
 * Copyright 2012 by Marcel Klehr <mklehr@gmx.net>
 *
 * (MIT LICENSE)
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var Operator = __webpack_require__(/*! ../Operator */ "../structured-text-editor/node_modules/changesets/lib/Operator.js")

/**
 * Skip Operator
 * Defined by:
 * - length
 * - input=length
 * - output=0
 *
 * @param length <Number> How many chars to be Skip
 */
function Skip(length) {
  this.length = length
  this.input = length
  this.output = 0
}

// True inheritance
Skip.prototype = Object.create(Operator.prototype, {
  constructor: {
    value: Skip,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
module.exports = Skip
Skip.prototype.symbol = '-'

var Insert = __webpack_require__(/*! ./Insert */ "../structured-text-editor/node_modules/changesets/lib/operations/Insert.js")
  , Retain = __webpack_require__(/*! ./Retain */ "../structured-text-editor/node_modules/changesets/lib/operations/Retain.js")
  , Changeset = __webpack_require__(/*! ../Changeset */ "../structured-text-editor/node_modules/changesets/lib/Changeset.js")

Skip.prototype.apply = function(t) {
  var input = t.readInput(this.input)
  t.writeRemovendum(input)
  t.writeOutput(t.subrange(input, 0, this.output)) // retain Inserts in my range
}

Skip.prototype.merge = function(op2) {
  return this
}

Skip.prototype.invert = function() {
  return new Insert(this.length)
}

Skip.unpack = function(data) {
  return new Skip(parseInt(data, 36))
}


/***/ }),

/***/ "../structured-text-editor/node_modules/diff_match_patch/lib/diff_match_patch.js":
/*!***************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/diff_match_patch/lib/diff_match_patch.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

/**
 * Diff Match and Patch
 *
 * Copyright 2006 Google Inc.
 * http://code.google.com/p/google-diff-match-patch/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview Computes the difference between two texts to create a patch.
 * Applies the patch onto another text, allowing for errors.
 * @author fraser@google.com (Neil Fraser)
 */

/**
 * Class containing the diff, match and patch methods.
 * @constructor
 */
function diff_match_patch() {

  // Defaults.
  // Redefine these in your program to override the defaults.

  // Number of seconds to map a diff before giving up (0 for infinity).
  this.Diff_Timeout = 1.0;
  // Cost of an empty edit operation in terms of edit characters.
  this.Diff_EditCost = 4;
  // The size beyond which the double-ended diff activates.
  // Double-ending is twice as fast, but less accurate.
  this.Diff_DualThreshold = 32;
  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).
  this.Match_Threshold = 0.5;
  // How far to search for a match (0 = exact location, 1000+ = broad match).
  // A match this many characters away from the expected location will add
  // 1.0 to the score (0.0 is a perfect match).
  this.Match_Distance = 1000;
  // When deleting a large block of text (over ~64 characters), how close does
  // the contents have to match the expected contents. (0.0 = perfection,
  // 1.0 = very loose).  Note that Match_Threshold controls how closely the
  // end points of a delete need to match.
  this.Patch_DeleteThreshold = 0.5;
  // Chunk size for context length.
  this.Patch_Margin = 4;

  /**
   * Compute the number of bits in an int.
   * The normal answer for JavaScript is 32.
   * @return {number} Max bits
   */
  function getMaxBits() {
    var maxbits = 0;
    var oldi = 1;
    var newi = 2;
    while (oldi != newi) {
      maxbits++;
      oldi = newi;
      newi = newi << 1;
    }
    return maxbits;
  }
  // How many bits in a number?
  this.Match_MaxBits = getMaxBits();
}


//  DIFF FUNCTIONS


/**
 * The data structure representing a diff is an array of tuples:
 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
 */
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;


/**
 * Find the differences between two texts.  Simplifies the problem by stripping
 * any common prefix or suffix off the texts before diffing.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {boolean} opt_checklines Optional speedup flag.  If present and false,
 *     then don't run a line-level diff first to identify the changed areas.
 *     Defaults to true, which does a faster, slightly less optimal diff
 * @return {Array.<Array.<number|string>>} Array of diff tuples.
 */
diff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines) {
  // Check for null inputs.
  if (text1 == null || text2 == null) {
    throw new Error('Null input. (diff_main)');
  }

  // Check for equality (speedup).
  if (text1 == text2) {
    return [[DIFF_EQUAL, text1]];
  }

  if (typeof opt_checklines == 'undefined') {
    opt_checklines = true;
  }
  var checklines = opt_checklines;

  // Trim off common prefix (speedup).
  var commonlength = this.diff_commonPrefix(text1, text2);
  var commonprefix = text1.substring(0, commonlength);
  text1 = text1.substring(commonlength);
  text2 = text2.substring(commonlength);

  // Trim off common suffix (speedup).
  commonlength = this.diff_commonSuffix(text1, text2);
  var commonsuffix = text1.substring(text1.length - commonlength);
  text1 = text1.substring(0, text1.length - commonlength);
  text2 = text2.substring(0, text2.length - commonlength);

  // Compute the diff on the middle block.
  var diffs = this.diff_compute(text1, text2, checklines);

  // Restore the prefix and suffix.
  if (commonprefix) {
    diffs.unshift([DIFF_EQUAL, commonprefix]);
  }
  if (commonsuffix) {
    diffs.push([DIFF_EQUAL, commonsuffix]);
  }
  this.diff_cleanupMerge(diffs);
  return diffs;
};


/**
 * Find the differences between two texts.  Assumes that the texts do not
 * have any common prefix or suffix.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {boolean} checklines Speedup flag.  If false, then don't run a
 *     line-level diff first to identify the changed areas.
 *     If true, then run a faster, slightly less optimal diff
 * @return {Array.<Array.<number|string>>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_compute = function(text1, text2, checklines) {
  var diffs;

  if (!text1) {
    // Just add some text (speedup).
    return [[DIFF_INSERT, text2]];
  }

  if (!text2) {
    // Just delete some text (speedup).
    return [[DIFF_DELETE, text1]];
  }

  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  var i = longtext.indexOf(shorttext);
  if (i != -1) {
    // Shorter text is inside the longer text (speedup).
    diffs = [[DIFF_INSERT, longtext.substring(0, i)],
             [DIFF_EQUAL, shorttext],
             [DIFF_INSERT, longtext.substring(i + shorttext.length)]];
    // Swap insertions for deletions if diff is reversed.
    if (text1.length > text2.length) {
      diffs[0][0] = diffs[2][0] = DIFF_DELETE;
    }
    return diffs;
  }
  longtext = shorttext = null;  // Garbage collect.

  // Check to see if the problem can be split in two.
  var hm = this.diff_halfMatch(text1, text2);
  if (hm) {
    // A half-match was found, sort out the return data.
    var text1_a = hm[0];
    var text1_b = hm[1];
    var text2_a = hm[2];
    var text2_b = hm[3];
    var mid_common = hm[4];
    // Send both pairs off for separate processing.
    var diffs_a = this.diff_main(text1_a, text2_a, checklines);
    var diffs_b = this.diff_main(text1_b, text2_b, checklines);
    // Merge the results.
    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
  }

  // Perform a real diff.
  if (checklines && (text1.length < 100 || text2.length < 100)) {
    // Too trivial for the overhead.
    checklines = false;
  }
  var linearray;
  if (checklines) {
    // Scan the text on a line-by-line basis first.
    var a = this.diff_linesToChars(text1, text2);
    text1 = a[0];
    text2 = a[1];
    linearray = a[2];
  }
  diffs = this.diff_map(text1, text2);
  if (!diffs) {
    // No acceptable result.
    diffs = [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
  }
  if (checklines) {
    // Convert the diff back to original text.
    this.diff_charsToLines(diffs, linearray);
    // Eliminate freak matches (e.g. blank lines)
    this.diff_cleanupSemantic(diffs);

    // Rediff any replacement blocks, this time character-by-character.
    // Add a dummy entry at the end.
    diffs.push([DIFF_EQUAL, '']);
    var pointer = 0;
    var count_delete = 0;
    var count_insert = 0;
    var text_delete = '';
    var text_insert = '';
    while (pointer < diffs.length) {
      switch (diffs[pointer][0]) {
        case DIFF_INSERT:
          count_insert++;
          text_insert += diffs[pointer][1];
          break;
        case DIFF_DELETE:
          count_delete++;
          text_delete += diffs[pointer][1];
          break;
        case DIFF_EQUAL:
          // Upon reaching an equality, check for prior redundancies.
          if (count_delete >= 1 && count_insert >= 1) {
            // Delete the offending records and add the merged ones.
            var a = this.diff_main(text_delete, text_insert, false);
            diffs.splice(pointer - count_delete - count_insert,
                         count_delete + count_insert);
            pointer = pointer - count_delete - count_insert;
            for (var j = a.length - 1; j >= 0; j--) {
              diffs.splice(pointer, 0, a[j]);
            }
            pointer = pointer + a.length;
          }
          count_insert = 0;
          count_delete = 0;
          text_delete = '';
          text_insert = '';
          break;
      }
     pointer++;
    }
    diffs.pop();  // Remove the dummy entry at the end.
  }
  return diffs;
};


/**
 * Split two texts into an array of strings.  Reduce the texts to a string of
 * hashes where each Unicode character represents one line.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {Array.<string|Array.<string>>} Three element Array, containing the
 *     encoded text1, the encoded text2 and the array of unique strings.  The
 *     zeroth element of the array of unique strings is intentionally blank.
 * @private
 */
diff_match_patch.prototype.diff_linesToChars = function(text1, text2) {
  var lineArray = [];  // e.g. lineArray[4] == 'Hello\n'
  var lineHash = {};   // e.g. lineHash['Hello\n'] == 4

  // '\x00' is a valid character, but various debuggers don't like it.
  // So we'll insert a junk entry to avoid generating a null character.
  lineArray[0] = '';

  /**
   * Split a text into an array of strings.  Reduce the texts to a string of
   * hashes where each Unicode character represents one line.
   * Modifies linearray and linehash through being a closure.
   * @param {string} text String to encode.
   * @return {string} Encoded string.
   * @private
   */
  function diff_linesToCharsMunge(text) {
    var chars = '';
    // Walk the text, pulling out a substring for each line.
    // text.split('\n') would would temporarily double our memory footprint.
    // Modifying text would create many large strings to garbage collect.
    var lineStart = 0;
    var lineEnd = -1;
    // Keeping our own length variable is faster than looking it up.
    var lineArrayLength = lineArray.length;
    while (lineEnd < text.length - 1) {
      lineEnd = text.indexOf('\n', lineStart);
      if (lineEnd == -1) {
        lineEnd = text.length - 1;
      }
      var line = text.substring(lineStart, lineEnd + 1);
      lineStart = lineEnd + 1;

      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :
          (lineHash[line] !== undefined)) {
        chars += String.fromCharCode(lineHash[line]);
      } else {
        chars += String.fromCharCode(lineArrayLength);
        lineHash[line] = lineArrayLength;
        lineArray[lineArrayLength++] = line;
      }
    }
    return chars;
  }

  var chars1 = diff_linesToCharsMunge(text1);
  var chars2 = diff_linesToCharsMunge(text2);
  return [chars1, chars2, lineArray];
};


/**
 * Rehydrate the text in a diff from a string of line hashes to real lines of
 * text.
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 * @param {Array.<string>} lineArray Array of unique strings.
 * @private
 */
diff_match_patch.prototype.diff_charsToLines = function(diffs, lineArray) {
  for (var x = 0; x < diffs.length; x++) {
    var chars = diffs[x][1];
    var text = [];
    for (var y = 0; y < chars.length; y++) {
      text[y] = lineArray[chars.charCodeAt(y)];
    }
    diffs[x][1] = text.join('');
  }
};


/**
 * Explore the intersection points between the two texts.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @return {?Array.<Array.<number|string>>} Array of diff tuples or null if no
 *     diff available.
 * @private
 */
diff_match_patch.prototype.diff_map = function(text1, text2) {
  // Don't run for too long.
  var ms_end = (new Date()).getTime() + this.Diff_Timeout * 1000;
  // Cache the text lengths to prevent multiple calls.
  var text1_length = text1.length;
  var text2_length = text2.length;
  var max_d = text1_length + text2_length - 1;
  var doubleEnd = this.Diff_DualThreshold * 2 < max_d;
  // JavaScript efficiency note: (x << 32) + y doesn't work since numbers are
  // only 32 bit.  Use x + ',' + y to create a hash instead.
  var v_map1 = [];
  var v_map2 = [];
  var v1 = {};
  var v2 = {};
  v1[1] = 0;
  v2[1] = 0;
  var x, y;
  var footstep;  // Used to track overlapping paths.
  var footsteps = {};
  var done = false;
  // If the total number of characters is odd, then the front path will collide
  // with the reverse path.
  var front = (text1_length + text2_length) % 2;
  for (var d = 0; d < max_d; d++) {
    // Bail out if timeout reached.
    if (this.Diff_Timeout > 0 && (new Date()).getTime() > ms_end) {
      return null;
    }

    // Walk the front path one step.
    v_map1[d] = {};
    for (var k = -d; k <= d; k += 2) {
      if (k == -d || k != d && v1[k - 1] < v1[k + 1]) {
        x = v1[k + 1];
      } else {
        x = v1[k - 1] + 1;
      }
      y = x - k;
      if (doubleEnd) {
        footstep = x + ',' + y;
        if (front && footsteps[footstep] !== undefined) {
          done = true;
        }
        if (!front) {
          footsteps[footstep] = d;
        }
      }
      while (!done && x < text1_length && y < text2_length &&
             text1.charAt(x) == text2.charAt(y)) {
        x++;
        y++;
        if (doubleEnd) {
          footstep = x + ',' + y;
          if (front && footsteps[footstep] !== undefined) {
            done = true;
          }
          if (!front) {
            footsteps[footstep] = d;
          }
        }
      }
      v1[k] = x;
      v_map1[d][x + ',' + y] = true;
      if (x == text1_length && y == text2_length) {
        // Reached the end in single-path mode.
        return this.diff_path1(v_map1, text1, text2);
      } else if (done) {
        // Front path ran over reverse path.
        v_map2 = v_map2.slice(0, footsteps[footstep] + 1);
        var a = this.diff_path1(v_map1, text1.substring(0, x),
                                text2.substring(0, y));
        return a.concat(this.diff_path2(v_map2, text1.substring(x),
                                        text2.substring(y)));
      }
    }

    if (doubleEnd) {
      // Walk the reverse path one step.
      v_map2[d] = {};
      for (var k = -d; k <= d; k += 2) {
        if (k == -d || k != d && v2[k - 1] < v2[k + 1]) {
          x = v2[k + 1];
        } else {
          x = v2[k - 1] + 1;
        }
        y = x - k;
        footstep = (text1_length - x) + ',' + (text2_length - y);
        if (!front && footsteps[footstep] !== undefined) {
          done = true;
        }
        if (front) {
          footsteps[footstep] = d;
        }
        while (!done && x < text1_length && y < text2_length &&
               text1.charAt(text1_length - x - 1) ==
               text2.charAt(text2_length - y - 1)) {
          x++;
          y++;
          footstep = (text1_length - x) + ',' + (text2_length - y);
          if (!front && footsteps[footstep] !== undefined) {
            done = true;
          }
          if (front) {
            footsteps[footstep] = d;
          }
        }
        v2[k] = x;
        v_map2[d][x + ',' + y] = true;
        if (done) {
          // Reverse path ran over front path.
          v_map1 = v_map1.slice(0, footsteps[footstep] + 1);
          var a = this.diff_path1(v_map1, text1.substring(0, text1_length - x),
                                  text2.substring(0, text2_length - y));
          return a.concat(this.diff_path2(v_map2,
                          text1.substring(text1_length - x),
                          text2.substring(text2_length - y)));
        }
      }
    }
  }
  // Number of diffs equals number of characters, no commonality at all.
  return null;
};


/**
 * Work from the middle back to the start to determine the path.
 * @param {Array.<Object>} v_map Array of paths.
 * @param {string} text1 Old string fragment to be diffed.
 * @param {string} text2 New string fragment to be diffed.
 * @return {Array.<Array.<number|string>>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_path1 = function(v_map, text1, text2) {
  var path = [];
  var x = text1.length;
  var y = text2.length;
  /** @type {?number} */
  var last_op = null;
  for (var d = v_map.length - 2; d >= 0; d--) {
    while (1) {
      if (v_map[d][(x - 1) + ',' + y] !== undefined) {
        x--;
        if (last_op === DIFF_DELETE) {
          path[0][1] = text1.charAt(x) + path[0][1];
        } else {
          path.unshift([DIFF_DELETE, text1.charAt(x)]);
        }
        last_op = DIFF_DELETE;
        break;
      } else if (v_map[d][x + ',' + (y - 1)] !== undefined) {
        y--;
        if (last_op === DIFF_INSERT) {
          path[0][1] = text2.charAt(y) + path[0][1];
        } else {
          path.unshift([DIFF_INSERT, text2.charAt(y)]);
        }
        last_op = DIFF_INSERT;
        break;
      } else {
        x--;
        y--;
        if (text1.charAt(x) != text2.charAt(y)) {
          throw new Error('No diagonal.  Can\'t happen. (diff_path1)');
        }
        if (last_op === DIFF_EQUAL) {
          path[0][1] = text1.charAt(x) + path[0][1];
        } else {
          path.unshift([DIFF_EQUAL, text1.charAt(x)]);
        }
        last_op = DIFF_EQUAL;
      }
    }
  }
  return path;
};


/**
 * Work from the middle back to the end to determine the path.
 * @param {Array.<Object>} v_map Array of paths.
 * @param {string} text1 Old string fragment to be diffed.
 * @param {string} text2 New string fragment to be diffed.
 * @return {Array.<Array.<number|string>>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_path2 = function(v_map, text1, text2) {
  var path = [];
  var pathLength = 0;
  var x = text1.length;
  var y = text2.length;
  /** @type {?number} */
  var last_op = null;
  for (var d = v_map.length - 2; d >= 0; d--) {
    while (1) {
      if (v_map[d][(x - 1) + ',' + y] !== undefined) {
        x--;
        if (last_op === DIFF_DELETE) {
          path[pathLength - 1][1] += text1.charAt(text1.length - x - 1);
        } else {
          path[pathLength++] =
              [DIFF_DELETE, text1.charAt(text1.length - x - 1)];
        }
        last_op = DIFF_DELETE;
        break;
      } else if (v_map[d][x + ',' + (y - 1)] !== undefined) {
        y--;
        if (last_op === DIFF_INSERT) {
          path[pathLength - 1][1] += text2.charAt(text2.length - y - 1);
        } else {
          path[pathLength++] =
              [DIFF_INSERT, text2.charAt(text2.length - y - 1)];
        }
        last_op = DIFF_INSERT;
        break;
      } else {
        x--;
        y--;
        if (text1.charAt(text1.length - x - 1) !=
            text2.charAt(text2.length - y - 1)) {
          throw new Error('No diagonal.  Can\'t happen. (diff_path2)');
        }
        if (last_op === DIFF_EQUAL) {
          path[pathLength - 1][1] += text1.charAt(text1.length - x - 1);
        } else {
          path[pathLength++] =
              [DIFF_EQUAL, text1.charAt(text1.length - x - 1)];
        }
        last_op = DIFF_EQUAL;
      }
    }
  }
  return path;
};


/**
 * Determine the common prefix of two strings
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the start of each
 *     string.
 */
diff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerstart = 0;
  while (pointermin < pointermid) {
    if (text1.substring(pointerstart, pointermid) ==
        text2.substring(pointerstart, pointermid)) {
      pointermin = pointermid;
      pointerstart = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Determine the common suffix of two strings
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of each string.
 */
diff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 || text1.charAt(text1.length - 1) !=
                          text2.charAt(text2.length - 1)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerend = 0;
  while (pointermin < pointermid) {
    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
        text2.substring(text2.length - pointermid, text2.length - pointerend)) {
      pointermin = pointermid;
      pointerend = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Do the two texts share a substring which is at least half the length of the
 * longer text?
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {?Array.<string>} Five element Array, containing the prefix of
 *     text1, the suffix of text1, the prefix of text2, the suffix of
 *     text2 and the common middle.  Or null if there was no match.
 */
diff_match_patch.prototype.diff_halfMatch = function(text1, text2) {
  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  if (longtext.length < 10 || shorttext.length < 1) {
    return null;  // Pointless.
  }
  var dmp = this;  // 'this' becomes 'window' in a closure.

  /**
   * Does a substring of shorttext exist within longtext such that the substring
   * is at least half the length of longtext?
   * Closure, but does not reference any external variables.
   * @param {string} longtext Longer string.
   * @param {string} shorttext Shorter string.
   * @param {number} i Start index of quarter length substring within longtext
   * @return {?Array.<string>} Five element Array, containing the prefix of
   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
   *     of shorttext and the common middle.  Or null if there was no match.
   * @private
   */
  function diff_halfMatchI(longtext, shorttext, i) {
    // Start with a 1/4 length substring at position i as a seed.
    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
    var j = -1;
    var best_common = '';
    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),
                                               shorttext.substring(j));
      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),
                                               shorttext.substring(0, j));
      if (best_common.length < suffixLength + prefixLength) {
        best_common = shorttext.substring(j - suffixLength, j) +
            shorttext.substring(j, j + prefixLength);
        best_longtext_a = longtext.substring(0, i - suffixLength);
        best_longtext_b = longtext.substring(i + prefixLength);
        best_shorttext_a = shorttext.substring(0, j - suffixLength);
        best_shorttext_b = shorttext.substring(j + prefixLength);
      }
    }
    if (best_common.length >= longtext.length / 2) {
      return [best_longtext_a, best_longtext_b,
              best_shorttext_a, best_shorttext_b, best_common];
    } else {
      return null;
    }
  }

  // First check if the second quarter is the seed for a half-match.
  var hm1 = diff_halfMatchI(longtext, shorttext,
                            Math.ceil(longtext.length / 4));
  // Check again based on the third quarter.
  var hm2 = diff_halfMatchI(longtext, shorttext,
                            Math.ceil(longtext.length / 2));
  var hm;
  if (!hm1 && !hm2) {
    return null;
  } else if (!hm2) {
    hm = hm1;
  } else if (!hm1) {
    hm = hm2;
  } else {
    // Both matched.  Select the longest.
    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
  }

  // A half-match was found, sort out the return data.
  var text1_a, text1_b, text2_a, text2_b;
  if (text1.length > text2.length) {
    text1_a = hm[0];
    text1_b = hm[1];
    text2_a = hm[2];
    text2_b = hm[3];
  } else {
    text2_a = hm[0];
    text2_b = hm[1];
    text1_a = hm[2];
    text1_b = hm[3];
  }
  var mid_common = hm[4];
  return [text1_a, text1_b, text2_a, text2_b, mid_common];
};


/**
 * Reduce the number of edits by eliminating semantically trivial equalities.
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {
  var changes = false;
  var equalities = [];  // Stack of indices where equalities are found.
  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
  var lastequality = null;  // Always equal to equalities[equalitiesLength-1][1]
  var pointer = 0;  // Index of current position.
  // Number of characters that changed prior to the equality.
  var length_changes1 = 0;
  // Number of characters that changed after the equality.
  var length_changes2 = 0;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {  // equality found
      equalities[equalitiesLength++] = pointer;
      length_changes1 = length_changes2;
      length_changes2 = 0;
      lastequality = diffs[pointer][1];
    } else {  // an insertion or deletion
      length_changes2 += diffs[pointer][1].length;
      if (lastequality !== null && (lastequality.length <= length_changes1) &&
          (lastequality.length <= length_changes2)) {
        // Duplicate record
        diffs.splice(equalities[equalitiesLength - 1], 0,
                     [DIFF_DELETE, lastequality]);
        // Change second copy to insert.
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        // Throw away the equality we just deleted.
        equalitiesLength--;
        // Throw away the previous equality (it needs to be reevaluated).
        equalitiesLength--;
        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
        length_changes1 = 0;  // Reset the counters.
        length_changes2 = 0;
        lastequality = null;
        changes = true;
      }
    }
    pointer++;
  }
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
  this.diff_cleanupSemanticLossless(diffs);
};


/**
 * Look for single edits surrounded on both sides by equalities
 * which can be shifted sideways to align the edit to a word boundary.
 * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {
  // Define some regex patterns for matching boundaries.
  var punctuation = /[^a-zA-Z0-9]/;
  var whitespace = /\s/;
  var linebreak = /[\r\n]/;
  var blanklineEnd = /\n\r?\n$/;
  var blanklineStart = /^\r?\n\r?\n/;

  /**
   * Given two strings, compute a score representing whether the internal
   * boundary falls on logical boundaries.
   * Scores range from 5 (best) to 0 (worst).
   * Closure, makes reference to regex patterns defined above.
   * @param {string} one First string.
   * @param {string} two Second string.
   * @return {number} The score.
   */
  function diff_cleanupSemanticScore(one, two) {
    if (!one || !two) {
      // Edges are the best.
      return 5;
    }

    // Each port of this function behaves slightly differently due to
    // subtle differences in each language's definition of things like
    // 'whitespace'.  Since this function's purpose is largely cosmetic,
    // the choice has been made to use each language's native features
    // rather than force total conformity.
    var score = 0;
    // One point for non-alphanumeric.
    if (one.charAt(one.length - 1).match(punctuation) ||
        two.charAt(0).match(punctuation)) {
      score++;
      // Two points for whitespace.
      if (one.charAt(one.length - 1).match(whitespace) ||
          two.charAt(0).match(whitespace)) {
        score++;
        // Three points for line breaks.
        if (one.charAt(one.length - 1).match(linebreak) ||
            two.charAt(0).match(linebreak)) {
          score++;
          // Four points for blank lines.
          if (one.match(blanklineEnd) || two.match(blanklineStart)) {
            score++;
          }
        }
      }
    }
    return score;
  }

  var pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
        diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      var equality1 = diffs[pointer - 1][1];
      var edit = diffs[pointer][1];
      var equality2 = diffs[pointer + 1][1];

      // First, shift the edit as far left as possible.
      var commonOffset = this.diff_commonSuffix(equality1, edit);
      if (commonOffset) {
        var commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset);
        edit = commonString + edit.substring(0, edit.length - commonOffset);
        equality2 = commonString + equality2;
      }

      // Second, step character by character right, looking for the best fit.
      var bestEquality1 = equality1;
      var bestEdit = edit;
      var bestEquality2 = equality2;
      var bestScore = diff_cleanupSemanticScore(equality1, edit) +
          diff_cleanupSemanticScore(edit, equality2);
      while (edit.charAt(0) === equality2.charAt(0)) {
        equality1 += edit.charAt(0);
        edit = edit.substring(1) + equality2.charAt(0);
        equality2 = equality2.substring(1);
        var score = diff_cleanupSemanticScore(equality1, edit) +
            diff_cleanupSemanticScore(edit, equality2);
        // The >= encourages trailing rather than leading whitespace on edits.
        if (score >= bestScore) {
          bestScore = score;
          bestEquality1 = equality1;
          bestEdit = edit;
          bestEquality2 = equality2;
        }
      }

      if (diffs[pointer - 1][1] != bestEquality1) {
        // We have an improvement, save it back to the diff.
        if (bestEquality1) {
          diffs[pointer - 1][1] = bestEquality1;
        } else {
          diffs.splice(pointer - 1, 1);
          pointer--;
        }
        diffs[pointer][1] = bestEdit;
        if (bestEquality2) {
          diffs[pointer + 1][1] = bestEquality2;
        } else {
          diffs.splice(pointer + 1, 1);
          pointer--;
        }
      }
    }
    pointer++;
  }
};


/**
 * Reduce the number of edits by eliminating operationally trivial equalities.
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {
  var changes = false;
  var equalities = [];  // Stack of indices where equalities are found.
  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
  var lastequality = '';  // Always equal to equalities[equalitiesLength-1][1]
  var pointer = 0;  // Index of current position.
  // Is there an insertion operation before the last equality.
  var pre_ins = false;
  // Is there a deletion operation before the last equality.
  var pre_del = false;
  // Is there an insertion operation after the last equality.
  var post_ins = false;
  // Is there a deletion operation after the last equality.
  var post_del = false;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {  // equality found
      if (diffs[pointer][1].length < this.Diff_EditCost &&
          (post_ins || post_del)) {
        // Candidate found.
        equalities[equalitiesLength++] = pointer;
        pre_ins = post_ins;
        pre_del = post_del;
        lastequality = diffs[pointer][1];
      } else {
        // Not a candidate, and can never become one.
        equalitiesLength = 0;
        lastequality = '';
      }
      post_ins = post_del = false;
    } else {  // an insertion or deletion
      if (diffs[pointer][0] == DIFF_DELETE) {
        post_del = true;
      } else {
        post_ins = true;
      }
      /*
       * Five types to be split:
       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>
       * <ins>A</ins>X<ins>C</ins><del>D</del>
       * <ins>A</ins><del>B</del>X<ins>C</ins>
       * <ins>A</del>X<ins>C</ins><del>D</del>
       * <ins>A</ins><del>B</del>X<del>C</del>
       */
      if (lastequality && ((pre_ins && pre_del && post_ins && post_del) ||
                           ((lastequality.length < this.Diff_EditCost / 2) &&
                            (pre_ins + pre_del + post_ins + post_del) == 3))) {
        // Duplicate record
        diffs.splice(equalities[equalitiesLength - 1], 0,
                     [DIFF_DELETE, lastequality]);
        // Change second copy to insert.
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        equalitiesLength--;  // Throw away the equality we just deleted;
        lastequality = '';
        if (pre_ins && pre_del) {
          // No changes made which could affect previous entry, keep going.
          post_ins = post_del = true;
          equalitiesLength = 0;
        } else {
          equalitiesLength--;  // Throw away the previous equality;
          pointer = equalitiesLength > 0 ?
              equalities[equalitiesLength - 1] : -1;
          post_ins = post_del = false;
        }
        changes = true;
      }
    }
    pointer++;
  }

  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};


/**
 * Reorder and merge like edit sections.  Merge equalities.
 * Any edit section can move as long as it doesn't cross an equality.
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupMerge = function(diffs) {
  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = '';
  var text_insert = '';
  var commonlength;
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_EQUAL:
        // Upon reaching an equality, check for prior redundancies.
        if (count_delete !== 0 || count_insert !== 0) {
          if (count_delete !== 0 && count_insert !== 0) {
            // Factor out any common prefixies.
            commonlength = this.diff_commonPrefix(text_insert, text_delete);
            if (commonlength !== 0) {
              if ((pointer - count_delete - count_insert) > 0 &&
                  diffs[pointer - count_delete - count_insert - 1][0] ==
                  DIFF_EQUAL) {
                diffs[pointer - count_delete - count_insert - 1][1] +=
                    text_insert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, [DIFF_EQUAL,
                    text_insert.substring(0, commonlength)]);
                pointer++;
              }
              text_insert = text_insert.substring(commonlength);
              text_delete = text_delete.substring(commonlength);
            }
            // Factor out any common suffixies.
            commonlength = this.diff_commonSuffix(text_insert, text_delete);
            if (commonlength !== 0) {
              diffs[pointer][1] = text_insert.substring(text_insert.length -
                  commonlength) + diffs[pointer][1];
              text_insert = text_insert.substring(0, text_insert.length -
                  commonlength);
              text_delete = text_delete.substring(0, text_delete.length -
                  commonlength);
            }
          }
          // Delete the offending records and add the merged ones.
          if (count_delete === 0) {
            diffs.splice(pointer - count_delete - count_insert,
                count_delete + count_insert, [DIFF_INSERT, text_insert]);
          } else if (count_insert === 0) {
            diffs.splice(pointer - count_delete - count_insert,
                count_delete + count_insert, [DIFF_DELETE, text_delete]);
          } else {
            diffs.splice(pointer - count_delete - count_insert,
                count_delete + count_insert, [DIFF_DELETE, text_delete],
                [DIFF_INSERT, text_insert]);
          }
          pointer = pointer - count_delete - count_insert +
                    (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
          // Merge this equality with the previous one.
          diffs[pointer - 1][1] += diffs[pointer][1];
          diffs.splice(pointer, 1);
        } else {
          pointer++;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = '';
        text_insert = '';
        break;
    }
  }
  if (diffs[diffs.length - 1][1] === '') {
    diffs.pop();  // Remove the dummy entry at the end.
  }

  // Second pass: look for single edits surrounded on both sides by equalities
  // which can be shifted sideways to eliminate an equality.
  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
  var changes = false;
  pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
        diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      if (diffs[pointer][1].substring(diffs[pointer][1].length -
          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
        // Shift the edit over the previous equality.
        diffs[pointer][1] = diffs[pointer - 1][1] +
            diffs[pointer][1].substring(0, diffs[pointer][1].length -
                                        diffs[pointer - 1][1].length);
        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
        diffs.splice(pointer - 1, 1);
        changes = true;
      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
          diffs[pointer + 1][1]) {
        // Shift the edit over the next equality.
        diffs[pointer - 1][1] += diffs[pointer + 1][1];
        diffs[pointer][1] =
            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
            diffs[pointer + 1][1];
        diffs.splice(pointer + 1, 1);
        changes = true;
      }
    }
    pointer++;
  }
  // If shifts were made, the diff needs reordering and another shift sweep.
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};


/**
 * loc is a location in text1, compute and return the equivalent location in
 * text2.
 * e.g. 'The cat' vs 'The big cat', 1->1, 5->8
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 * @param {number} loc Location within text1.
 * @return {number} Location within text2.
 */
diff_match_patch.prototype.diff_xIndex = function(diffs, loc) {
  var chars1 = 0;
  var chars2 = 0;
  var last_chars1 = 0;
  var last_chars2 = 0;
  var x;
  for (x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.
      chars1 += diffs[x][1].length;
    }
    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.
      chars2 += diffs[x][1].length;
    }
    if (chars1 > loc) {  // Overshot the location.
      break;
    }
    last_chars1 = chars1;
    last_chars2 = chars2;
  }
  // Was the location was deleted?
  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {
    return last_chars2;
  }
  // Add the remaining character length.
  return last_chars2 + (loc - last_chars1);
};


/**
 * Convert a diff array into a pretty HTML report.
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 * @return {string} HTML representation.
 */
diff_match_patch.prototype.diff_prettyHtml = function(diffs) {
  var html = [];
  var i = 0;
  for (var x = 0; x < diffs.length; x++) {
    var op = diffs[x][0];    // Operation (insert, delete, equal)
    var data = diffs[x][1];  // Text of change.
    var text = data.replace(/&/g, '&amp;').replace(/</g, '&lt;')
        .replace(/>/g, '&gt;').replace(/\n/g, '&para;<BR>');
    switch (op) {
      case DIFF_INSERT:
        html[x] = '<INS STYLE="background:#E6FFE6;" TITLE="i=' + i + '">' +
                text + '</INS>';
        break;
      case DIFF_DELETE:
        html[x] = '<DEL STYLE="background:#FFE6E6;" TITLE="i=' + i + '">' +
                text + '</DEL>';
        break;
      case DIFF_EQUAL:
        html[x] = '<SPAN TITLE="i=' + i + '">' + text + '</SPAN>';
        break;
    }
    if (op !== DIFF_DELETE) {
      i += data.length;
    }
  }
  return html.join('');
};


/**
 * Compute and return the source text (all equalities and deletions).
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 * @return {string} Source text.
 */
diff_match_patch.prototype.diff_text1 = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {
      text[x] = diffs[x][1];
    }
  }
  return text.join('');
};


/**
 * Compute and return the destination text (all equalities and insertions).
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 * @return {string} Destination text.
 */
diff_match_patch.prototype.diff_text2 = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_DELETE) {
      text[x] = diffs[x][1];
    }
  }
  return text.join('');
};


/**
 * Compute the Levenshtein distance; the number of inserted, deleted or
 * substituted characters.
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 * @return {number} Number of changes.
 */
diff_match_patch.prototype.diff_levenshtein = function(diffs) {
  var levenshtein = 0;
  var insertions = 0;
  var deletions = 0;
  for (var x = 0; x < diffs.length; x++) {
    var op = diffs[x][0];
    var data = diffs[x][1];
    switch (op) {
      case DIFF_INSERT:
        insertions += data.length;
        break;
      case DIFF_DELETE:
        deletions += data.length;
        break;
      case DIFF_EQUAL:
        // A deletion and an insertion is one substitution.
        levenshtein += Math.max(insertions, deletions);
        insertions = 0;
        deletions = 0;
        break;
    }
  }
  levenshtein += Math.max(insertions, deletions);
  return levenshtein;
};


/**
 * Crush the diff into an encoded string which describes the operations
 * required to transform text1 into text2.
 * E.g. =3\t-2\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.
 * Operations are tab-separated.  Inserted text is escaped using %xx notation.
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 * @return {string} Delta text.
 */
diff_match_patch.prototype.diff_toDelta = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    switch (diffs[x][0]) {
      case DIFF_INSERT:
        text[x] = '+' + encodeURI(diffs[x][1]);
        break;
      case DIFF_DELETE:
        text[x] = '-' + diffs[x][1].length;
        break;
      case DIFF_EQUAL:
        text[x] = '=' + diffs[x][1].length;
        break;
    }
  }
  // Opera doesn't know how to encode char 0.
  return text.join('\t').replace(/\x00/g, '%00').replace(/%20/g, ' ');
};


/**
 * Given the original text1, and an encoded string which describes the
 * operations required to transform text1 into text2, compute the full diff.
 * @param {string} text1 Source string for the diff.
 * @param {string} delta Delta text.
 * @return {Array.<Array.<number|string>>} Array of diff tuples.
 * @throws {Error} If invalid input.
 */
diff_match_patch.prototype.diff_fromDelta = function(text1, delta) {
  var diffs = [];
  var diffsLength = 0;  // Keeping our own length var is faster in JS.
  var pointer = 0;  // Cursor in text1
  // Opera doesn't know how to decode char 0.
  delta = delta.replace(/%00/g, '\0');
  var tokens = delta.split(/\t/g);
  for (var x = 0; x < tokens.length; x++) {
    // Each token begins with a one character parameter which specifies the
    // operation of this token (delete, insert, equality).
    var param = tokens[x].substring(1);
    switch (tokens[x].charAt(0)) {
      case '+':
        try {
          diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)];
        } catch (ex) {
          // Malformed URI sequence.
          throw new Error('Illegal escape in diff_fromDelta: ' + param);
        }
        break;
      case '-':
        // Fall through.
      case '=':
        var n = parseInt(param, 10);
        if (isNaN(n) || n < 0) {
          throw new Error('Invalid number in diff_fromDelta: ' + param);
        }
        var text = text1.substring(pointer, pointer += n);
        if (tokens[x].charAt(0) == '=') {
          diffs[diffsLength++] = [DIFF_EQUAL, text];
        } else {
          diffs[diffsLength++] = [DIFF_DELETE, text];
        }
        break;
      default:
        // Blank tokens are ok (from a trailing \t).
        // Anything else is an error.
        if (tokens[x]) {
          throw new Error('Invalid diff operation in diff_fromDelta: ' +
                          tokens[x]);
        }
    }
  }
  if (pointer != text1.length) {
    throw new Error('Delta length (' + pointer +
        ') does not equal source text length (' + text1.length + ').');
  }
  return diffs;
};


//  MATCH FUNCTIONS


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc'.
 * @param {string} text The text to search.
 * @param {string} pattern The pattern to search for.
 * @param {number} loc The location to search around.
 * @return {number} Best match index or -1.
 */
diff_match_patch.prototype.match_main = function(text, pattern, loc) {
  // Check for null inputs.
  if (text == null || pattern == null || loc == null) {
    throw new Error('Null input. (match_main)');
  }

  loc = Math.max(0, Math.min(loc, text.length));
  if (text == pattern) {
    // Shortcut (potentially not guaranteed by the algorithm)
    return 0;
  } else if (!text.length) {
    // Nothing to match.
    return -1;
  } else if (text.substring(loc, loc + pattern.length) == pattern) {
    // Perfect match at the perfect spot!  (Includes case of null pattern)
    return loc;
  } else {
    // Do a fuzzy compare.
    return this.match_bitap(text, pattern, loc);
  }
};


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc' using the
 * Bitap algorithm.
 * @param {string} text The text to search.
 * @param {string} pattern The pattern to search for.
 * @param {number} loc The location to search around.
 * @return {number} Best match index or -1.
 * @private
 */
diff_match_patch.prototype.match_bitap = function(text, pattern, loc) {
  if (pattern.length > this.Match_MaxBits) {
    throw new Error('Pattern too long for this browser.');
  }

  // Initialise the alphabet.
  var s = this.match_alphabet(pattern);

  var dmp = this;  // 'this' becomes 'window' in a closure.

  /**
   * Compute and return the score for a match with e errors and x location.
   * Accesses loc and pattern through being a closure.
   * @param {number} e Number of errors in match.
   * @param {number} x Location of match.
   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).
   * @private
   */
  function match_bitapScore(e, x) {
    var accuracy = e / pattern.length;
    var proximity = Math.abs(loc - x);
    if (!dmp.Match_Distance) {
      // Dodge divide by zero error.
      return proximity ? 1.0 : accuracy;
    }
    return accuracy + (proximity / dmp.Match_Distance);
  }

  // Highest score beyond which we give up.
  var score_threshold = this.Match_Threshold;
  // Is there a nearby exact match? (speedup)
  var best_loc = text.indexOf(pattern, loc);
  if (best_loc != -1) {
    score_threshold = Math.min(match_bitapScore(0, best_loc), score_threshold);
    // What about in the other direction? (speedup)
    best_loc = text.lastIndexOf(pattern, loc + pattern.length);
    if (best_loc != -1) {
      score_threshold =
          Math.min(match_bitapScore(0, best_loc), score_threshold);
    }
  }

  // Initialise the bit arrays.
  var matchmask = 1 << (pattern.length - 1);
  best_loc = -1;

  var bin_min, bin_mid;
  var bin_max = pattern.length + text.length;
  var last_rd;
  for (var d = 0; d < pattern.length; d++) {
    // Scan for the best match; each iteration allows for one more error.
    // Run a binary search to determine how far from 'loc' we can stray at this
    // error level.
    bin_min = 0;
    bin_mid = bin_max;
    while (bin_min < bin_mid) {
      if (match_bitapScore(d, loc + bin_mid) <= score_threshold) {
        bin_min = bin_mid;
      } else {
        bin_max = bin_mid;
      }
      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);
    }
    // Use the result from this iteration as the maximum for the next.
    bin_max = bin_mid;
    var start = Math.max(1, loc - bin_mid + 1);
    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;

    var rd = Array(finish + 2);
    rd[finish + 1] = (1 << d) - 1;
    for (var j = finish; j >= start; j--) {
      // The alphabet (s) is a sparse hash, so the following line generates
      // warnings.
      var charMatch = s[text.charAt(j - 1)];
      if (d === 0) {  // First pass: exact match.
        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;
      } else {  // Subsequent passes: fuzzy match.
        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch |
                (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |
                last_rd[j + 1];
      }
      if (rd[j] & matchmask) {
        var score = match_bitapScore(d, j - 1);
        // This match will almost certainly be better than any existing match.
        // But check anyway.
        if (score <= score_threshold) {
          // Told you so.
          score_threshold = score;
          best_loc = j - 1;
          if (best_loc > loc) {
            // When passing loc, don't exceed our current distance from loc.
            start = Math.max(1, 2 * loc - best_loc);
          } else {
            // Already passed loc, downhill from here on in.
            break;
          }
        }
      }
    }
    // No hope for a (better) match at greater error levels.
    if (match_bitapScore(d + 1, loc) > score_threshold) {
      break;
    }
    last_rd = rd;
  }
  return best_loc;
};


/**
 * Initialise the alphabet for the Bitap algorithm.
 * @param {string} pattern The text to encode.
 * @return {Object} Hash of character locations.
 * @private
 */
diff_match_patch.prototype.match_alphabet = function(pattern) {
  var s = {};
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] = 0;
  }
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);
  }
  return s;
};


//  PATCH FUNCTIONS


/**
 * Increase the context until it is unique,
 * but don't let the pattern expand beyond Match_MaxBits.
 * @param {patch_obj} patch The patch to grow.
 * @param {string} text Source text.
 * @private
 */
diff_match_patch.prototype.patch_addContext = function(patch, text) {
  if (text.length == 0) {
    return;
  }
  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);
  var padding = 0;

  // Look for the first and last matches of pattern in text.  If two different
  // matches are found, increase the pattern length.
  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&
         pattern.length < this.Match_MaxBits - this.Patch_Margin -
         this.Patch_Margin) {
    padding += this.Patch_Margin;
    pattern = text.substring(patch.start2 - padding,
                             patch.start2 + patch.length1 + padding);
  }
  // Add one chunk for good luck.
  padding += this.Patch_Margin;

  // Add the prefix.
  var prefix = text.substring(patch.start2 - padding, patch.start2);
  if (prefix) {
    patch.diffs.unshift([DIFF_EQUAL, prefix]);
  }
  // Add the suffix.
  var suffix = text.substring(patch.start2 + patch.length1,
                              patch.start2 + patch.length1 + padding);
  if (suffix) {
    patch.diffs.push([DIFF_EQUAL, suffix]);
  }

  // Roll back the start points.
  patch.start1 -= prefix.length;
  patch.start2 -= prefix.length;
  // Extend the lengths.
  patch.length1 += prefix.length + suffix.length;
  patch.length2 += prefix.length + suffix.length;
};


/**
 * Compute a list of patches to turn text1 into text2.
 * Use diffs if provided, otherwise compute it ourselves.
 * There are four ways to call this function, depending on what data is
 * available to the caller:
 * Method 1:
 * a = text1, b = text2
 * Method 2:
 * a = diffs
 * Method 3 (optimal):
 * a = text1, b = diffs
 * Method 4 (deprecated, use method 3):
 * a = text1, b = text2, c = diffs
 *
 * @param {string|Array.<Array.<number|string>>} a text1 (methods 1,3,4) or
 * Array of diff tuples for text1 to text2 (method 2).
 * @param {string|Array.<Array.<number|string>>} opt_b text2 (methods 1,4) or
 * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).
 * @param {string|Array.<Array.<number|string>>} opt_c Array of diff tuples for
 * text1 to text2 (method 4) or undefined (methods 1,2,3).
 * @return {Array.<patch_obj>} Array of patch objects.
 */
diff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {
  var text1, diffs;
  if (typeof a == 'string' && typeof opt_b == 'string' &&
      typeof opt_c == 'undefined') {
    // Method 1: text1, text2
    // Compute diffs from text1 and text2.
    text1 = a;
    diffs = this.diff_main(text1, opt_b, true);
    if (diffs.length > 2) {
      this.diff_cleanupSemantic(diffs);
      this.diff_cleanupEfficiency(diffs);
    }
  } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&
      typeof opt_c == 'undefined') {
    // Method 2: diffs
    // Compute text1 from diffs.
    diffs = a;
    text1 = this.diff_text1(diffs);
  } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&
      typeof opt_c == 'undefined') {
    // Method 3: text1, diffs
    text1 = a;
    diffs = opt_b;
  } else if (typeof a == 'string' && typeof opt_b == 'string' &&
      opt_c && typeof opt_c == 'object') {
    // Method 4: text1, text2, diffs
    // text2 is not used.
    text1 = a;
    diffs = opt_c;
  } else {
    throw new Error('Unknown call format to patch_make.');
  }

  if (diffs.length === 0) {
    return [];  // Get rid of the null case.
  }
  var patches = [];
  var patch = new patch_obj();
  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.
  var char_count1 = 0;  // Number of characters into the text1 string.
  var char_count2 = 0;  // Number of characters into the text2 string.
  // Start with text1 (prepatch_text) and apply the diffs until we arrive at
  // text2 (postpatch_text).  We recreate the patches one by one to determine
  // context info.
  var prepatch_text = text1;
  var postpatch_text = text1;
  for (var x = 0; x < diffs.length; x++) {
    var diff_type = diffs[x][0];
    var diff_text = diffs[x][1];

    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
      // A new patch starts here.
      patch.start1 = char_count1;
      patch.start2 = char_count2;
    }

    switch (diff_type) {
      case DIFF_INSERT:
        patch.diffs[patchDiffLength++] = diffs[x];
        patch.length2 += diff_text.length;
        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +
                         postpatch_text.substring(char_count2);
        break;
      case DIFF_DELETE:
        patch.length1 += diff_text.length;
        patch.diffs[patchDiffLength++] = diffs[x];
        postpatch_text = postpatch_text.substring(0, char_count2) +
                         postpatch_text.substring(char_count2 +
                             diff_text.length);
        break;
      case DIFF_EQUAL:
        if (diff_text.length <= 2 * this.Patch_Margin &&
            patchDiffLength && diffs.length != x + 1) {
          // Small equality inside a patch.
          patch.diffs[patchDiffLength++] = diffs[x];
          patch.length1 += diff_text.length;
          patch.length2 += diff_text.length;
        } else if (diff_text.length >= 2 * this.Patch_Margin) {
          // Time for a new patch.
          if (patchDiffLength) {
            this.patch_addContext(patch, prepatch_text);
            patches.push(patch);
            patch = new patch_obj();
            patchDiffLength = 0;
            // Unlike Unidiff, our patch lists have a rolling context.
            // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff
            // Update prepatch text & pos to reflect the application of the
            // just completed patch.
            prepatch_text = postpatch_text;
            char_count1 = char_count2;
          }
        }
        break;
    }

    // Update the current character count.
    if (diff_type !== DIFF_INSERT) {
      char_count1 += diff_text.length;
    }
    if (diff_type !== DIFF_DELETE) {
      char_count2 += diff_text.length;
    }
  }
  // Pick up the leftover patch if not empty.
  if (patchDiffLength) {
    this.patch_addContext(patch, prepatch_text);
    patches.push(patch);
  }

  return patches;
};


/**
 * Given an array of patches, return another array that is identical.
 * @param {Array.<patch_obj>} patches Array of patch objects.
 * @return {Array.<patch_obj>} Array of patch objects.
 */
diff_match_patch.prototype.patch_deepCopy = function(patches) {
  // Making deep copies is hard in JavaScript.
  var patchesCopy = [];
  for (var x = 0; x < patches.length; x++) {
    var patch = patches[x];
    var patchCopy = new patch_obj();
    patchCopy.diffs = [];
    for (var y = 0; y < patch.diffs.length; y++) {
      patchCopy.diffs[y] = patch.diffs[y].slice();
    }
    patchCopy.start1 = patch.start1;
    patchCopy.start2 = patch.start2;
    patchCopy.length1 = patch.length1;
    patchCopy.length2 = patch.length2;
    patchesCopy[x] = patchCopy;
  }
  return patchesCopy;
};


/**
 * Merge a set of patches onto the text.  Return a patched text, as well
 * as a list of true/false values indicating which patches were applied.
 * @param {Array.<patch_obj>} patches Array of patch objects.
 * @param {string} text Old text.
 * @return {Array.<string|Array.<boolean>>} Two element Array, containing the
 *      new text and an array of boolean values.
 */
diff_match_patch.prototype.patch_apply = function(patches, text) {
  if (patches.length == 0) {
    return [text, []];
  }

  // Deep copy the patches so that no changes are made to originals.
  patches = this.patch_deepCopy(patches);

  var nullPadding = this.patch_addPadding(patches);
  text = nullPadding + text + nullPadding;

  this.patch_splitMax(patches);
  // delta keeps track of the offset between the expected and actual location
  // of the previous patch.  If there are patches expected at positions 10 and
  // 20, but the first patch was found at 12, delta is 2 and the second patch
  // has an effective expected position of 22.
  var delta = 0;
  var results = [];
  for (var x = 0; x < patches.length; x++) {
    var expected_loc = patches[x].start2 + delta;
    var text1 = this.diff_text1(patches[x].diffs);
    var start_loc;
    var end_loc = -1;
    if (text1.length > this.Match_MaxBits) {
      // patch_splitMax will only provide an oversized pattern in the case of
      // a monster delete.
      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),
                                  expected_loc);
      if (start_loc != -1) {
        end_loc = this.match_main(text,
            text1.substring(text1.length - this.Match_MaxBits),
            expected_loc + text1.length - this.Match_MaxBits);
        if (end_loc == -1 || start_loc >= end_loc) {
          // Can't find valid trailing context.  Drop this patch.
          start_loc = -1;
        }
      }
    } else {
      start_loc = this.match_main(text, text1, expected_loc);
    }
    if (start_loc == -1) {
      // No match found.  :(
      results[x] = false;
      // Subtract the delta for this failed patch from subsequent patches.
      delta -= patches[x].length2 - patches[x].length1;
    } else {
      // Found a match.  :)
      results[x] = true;
      delta = start_loc - expected_loc;
      var text2;
      if (end_loc == -1) {
        text2 = text.substring(start_loc, start_loc + text1.length);
      } else {
        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);
      }
      if (text1 == text2) {
        // Perfect match, just shove the replacement text in.
        text = text.substring(0, start_loc) +
               this.diff_text2(patches[x].diffs) +
               text.substring(start_loc + text1.length);
      } else {
        // Imperfect match.  Run a diff to get a framework of equivalent
        // indices.
        var diffs = this.diff_main(text1, text2, false);
        if (text1.length > this.Match_MaxBits &&
            this.diff_levenshtein(diffs) / text1.length >
            this.Patch_DeleteThreshold) {
          // The end points match, but the content is unacceptably bad.
          results[x] = false;
        } else {
          this.diff_cleanupSemanticLossless(diffs);
          var index1 = 0;
          var index2;
          for (var y = 0; y < patches[x].diffs.length; y++) {
            var mod = patches[x].diffs[y];
            if (mod[0] !== DIFF_EQUAL) {
              index2 = this.diff_xIndex(diffs, index1);
            }
            if (mod[0] === DIFF_INSERT) {  // Insertion
              text = text.substring(0, start_loc + index2) + mod[1] +
                     text.substring(start_loc + index2);
            } else if (mod[0] === DIFF_DELETE) {  // Deletion
              text = text.substring(0, start_loc + index2) +
                     text.substring(start_loc + this.diff_xIndex(diffs,
                         index1 + mod[1].length));
            }
            if (mod[0] !== DIFF_DELETE) {
              index1 += mod[1].length;
            }
          }
        }
      }
    }
  }
  // Strip the padding off.
  text = text.substring(nullPadding.length, text.length - nullPadding.length);
  return [text, results];
};


/**
 * Add some padding on text start and end so that edges can match something.
 * Intended to be called only from within patch_apply.
 * @param {Array.<patch_obj>} patches Array of patch objects.
 * @return {string} The padding string added to each side.
 */
diff_match_patch.prototype.patch_addPadding = function(patches) {
  var paddingLength = this.Patch_Margin;
  var nullPadding = '';
  for (var x = 1; x <= paddingLength; x++) {
    nullPadding += String.fromCharCode(x);
  }

  // Bump all the patches forward.
  for (var x = 0; x < patches.length; x++) {
    patches[x].start1 += paddingLength;
    patches[x].start2 += paddingLength;
  }

  // Add some padding on start of first diff.
  var patch = patches[0];
  var diffs = patch.diffs;
  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
    // Add nullPadding equality.
    diffs.unshift([DIFF_EQUAL, nullPadding]);
    patch.start1 -= paddingLength;  // Should be 0.
    patch.start2 -= paddingLength;  // Should be 0.
    patch.length1 += paddingLength;
    patch.length2 += paddingLength;
  } else if (paddingLength > diffs[0][1].length) {
    // Grow first equality.
    var extraLength = paddingLength - diffs[0][1].length;
    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
    patch.start1 -= extraLength;
    patch.start2 -= extraLength;
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }

  // Add some padding on end of last diff.
  patch = patches[patches.length - 1];
  diffs = patch.diffs;
  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
    // Add nullPadding equality.
    diffs.push([DIFF_EQUAL, nullPadding]);
    patch.length1 += paddingLength;
    patch.length2 += paddingLength;
  } else if (paddingLength > diffs[diffs.length - 1][1].length) {
    // Grow last equality.
    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;
    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }

  return nullPadding;
};


/**
 * Look through the patches and break up any which are longer than the maximum
 * limit of the match algorithm.
 * @param {Array.<patch_obj>} patches Array of patch objects.
 */
diff_match_patch.prototype.patch_splitMax = function(patches) {
  for (var x = 0; x < patches.length; x++) {
    if (patches[x].length1 > this.Match_MaxBits) {
      var bigpatch = patches[x];
      // Remove the big old patch.
      patches.splice(x--, 1);
      var patch_size = this.Match_MaxBits;
      var start1 = bigpatch.start1;
      var start2 = bigpatch.start2;
      var precontext = '';
      while (bigpatch.diffs.length !== 0) {
        // Create one of several smaller patches.
        var patch = new patch_obj();
        var empty = true;
        patch.start1 = start1 - precontext.length;
        patch.start2 = start2 - precontext.length;
        if (precontext !== '') {
          patch.length1 = patch.length2 = precontext.length;
          patch.diffs.push([DIFF_EQUAL, precontext]);
        }
        while (bigpatch.diffs.length !== 0 &&
               patch.length1 < patch_size - this.Patch_Margin) {
          var diff_type = bigpatch.diffs[0][0];
          var diff_text = bigpatch.diffs[0][1];
          if (diff_type === DIFF_INSERT) {
            // Insertions are harmless.
            patch.length2 += diff_text.length;
            start2 += diff_text.length;
            patch.diffs.push(bigpatch.diffs.shift());
            empty = false;
          } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&
                     patch.diffs[0][0] == DIFF_EQUAL &&
                     diff_text.length > 2 * patch_size) {
            // This is a large deletion.  Let it pass in one chunk.
            patch.length1 += diff_text.length;
            start1 += diff_text.length;
            empty = false;
            patch.diffs.push([diff_type, diff_text]);
            bigpatch.diffs.shift();
          } else {
            // Deletion or equality.  Only take as much as we can stomach.
            diff_text = diff_text.substring(0, patch_size - patch.length1 -
                                               this.Patch_Margin);
            patch.length1 += diff_text.length;
            start1 += diff_text.length;
            if (diff_type === DIFF_EQUAL) {
              patch.length2 += diff_text.length;
              start2 += diff_text.length;
            } else {
              empty = false;
            }
            patch.diffs.push([diff_type, diff_text]);
            if (diff_text == bigpatch.diffs[0][1]) {
              bigpatch.diffs.shift();
            } else {
              bigpatch.diffs[0][1] =
                  bigpatch.diffs[0][1].substring(diff_text.length);
            }
          }
        }
        // Compute the head context for the next patch.
        precontext = this.diff_text2(patch.diffs);
        precontext =
            precontext.substring(precontext.length - this.Patch_Margin);
        // Append the end context for this patch.
        var postcontext = this.diff_text1(bigpatch.diffs)
                              .substring(0, this.Patch_Margin);
        if (postcontext !== '') {
          patch.length1 += postcontext.length;
          patch.length2 += postcontext.length;
          if (patch.diffs.length !== 0 &&
              patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {
            patch.diffs[patch.diffs.length - 1][1] += postcontext;
          } else {
            patch.diffs.push([DIFF_EQUAL, postcontext]);
          }
        }
        if (!empty) {
          patches.splice(++x, 0, patch);
        }
      }
    }
  }
};


/**
 * Take a list of patches and return a textual representation.
 * @param {Array.<patch_obj>} patches Array of patch objects.
 * @return {string} Text representation of patches.
 */
diff_match_patch.prototype.patch_toText = function(patches) {
  var text = [];
  for (var x = 0; x < patches.length; x++) {
    text[x] = patches[x];
  }
  return text.join('');
};


/**
 * Parse a textual representation of patches and return a list of patch objects.
 * @param {string} textline Text representation of patches.
 * @return {Array.<patch_obj>} Array of patch objects.
 * @throws {Error} If invalid input.
 */
diff_match_patch.prototype.patch_fromText = function(textline) {
  var patches = [];
  if (!textline) {
    return patches;
  }
  // Opera doesn't know how to decode char 0.
  textline = textline.replace(/%00/g, '\0');
  var text = textline.split('\n');
  var textPointer = 0;
  while (textPointer < text.length) {
    var m = text[textPointer].match(/^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/);
    if (!m) {
      throw new Error('Invalid patch string: ' + text[textPointer]);
    }
    var patch = new patch_obj();
    patches.push(patch);
    patch.start1 = parseInt(m[1], 10);
    if (m[2] === '') {
      patch.start1--;
      patch.length1 = 1;
    } else if (m[2] == '0') {
      patch.length1 = 0;
    } else {
      patch.start1--;
      patch.length1 = parseInt(m[2], 10);
    }

    patch.start2 = parseInt(m[3], 10);
    if (m[4] === '') {
      patch.start2--;
      patch.length2 = 1;
    } else if (m[4] == '0') {
      patch.length2 = 0;
    } else {
      patch.start2--;
      patch.length2 = parseInt(m[4], 10);
    }
    textPointer++;

    while (textPointer < text.length) {
      var sign = text[textPointer].charAt(0);
      try {
        var line = decodeURI(text[textPointer].substring(1));
      } catch (ex) {
        // Malformed URI sequence.
        throw new Error('Illegal escape in patch_fromText: ' + line);
      }
      if (sign == '-') {
        // Deletion.
        patch.diffs.push([DIFF_DELETE, line]);
      } else if (sign == '+') {
        // Insertion.
        patch.diffs.push([DIFF_INSERT, line]);
      } else if (sign == ' ') {
        // Minor equality.
        patch.diffs.push([DIFF_EQUAL, line]);
      } else if (sign == '@') {
        // Start of next patch.
        break;
      } else if (sign === '') {
        // Blank line?  Whatever.
      } else {
        // WTF?
        throw new Error('Invalid patch mode "' + sign + '" in: ' + line);
      }
      textPointer++;
    }
  }
  return patches;
};


/**
 * Class representing one patch operation.
 * @constructor
 */
function patch_obj() {
  /** @type {Array.<Array.<number|string>>} */
  this.diffs = [];
  /** @type {?number} */
  this.start1 = null;
  /** @type {?number} */
  this.start2 = null;
  /** @type {number} */
  this.length1 = 0;
  /** @type {number} */
  this.length2 = 0;
}


/**
 * Emmulate GNU diff's format.
 * Header: @@ -382,8 +481,9 @@
 * Indicies are printed as 1-based, not 0-based.
 * @return {string} The GNU diff string.
 */
patch_obj.prototype.toString = function() {
  var coords1, coords2;
  if (this.length1 === 0) {
    coords1 = this.start1 + ',0';
  } else if (this.length1 == 1) {
    coords1 = this.start1 + 1;
  } else {
    coords1 = (this.start1 + 1) + ',' + this.length1;
  }
  if (this.length2 === 0) {
    coords2 = this.start2 + ',0';
  } else if (this.length2 == 1) {
    coords2 = this.start2 + 1;
  } else {
    coords2 = (this.start2 + 1) + ',' + this.length2;
  }
  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\n'];
  var op;
  // Escape the body of the patch with %xx notation.
  for (var x = 0; x < this.diffs.length; x++) {
    switch (this.diffs[x][0]) {
      case DIFF_INSERT:
        op = '+';
        break;
      case DIFF_DELETE:
        op = '-';
        break;
      case DIFF_EQUAL:
        op = ' ';
        break;
    }
    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\n';
  }
  // Opera doesn't know how to encode char 0.
  return text.join('').replace(/\x00/g, '%00').replace(/%20/g, ' ');
};


// Export these global variables so that they survive Google's JS compiler.
/*changed by lfborjas: changed `window` for `exports` to make it suitable for the node.js module conventions*/
exports.diff_match_patch = diff_match_patch;
exports.patch_obj = patch_obj;
exports.DIFF_DELETE = DIFF_DELETE;
exports.DIFF_INSERT = DIFF_INSERT;
exports.DIFF_EQUAL = DIFF_EQUAL;


/***/ }),

/***/ "../structured-text-editor/node_modules/prismjs/components/prism-latex.js":
/*!********************************************************************************!*\
  !*** ../structured-text-editor/node_modules/prismjs/components/prism-latex.js ***!
  \********************************************************************************/
/***/ (() => {

(function (Prism) {
	var funcPattern = /\\(?:[^a-z()[\]]|[a-z*]+)/i;
	var insideEqu = {
		'equation-command': {
			pattern: funcPattern,
			alias: 'regex'
		}
	};

	Prism.languages.latex = {
		'comment': /%.*/,
		// the verbatim environment prints whitespace to the document
		'cdata': {
			pattern: /(\\begin\{((?:lstlisting|verbatim)\*?)\})[\s\S]*?(?=\\end\{\2\})/,
			lookbehind: true
		},
		/*
		 * equations can be between $$ $$ or $ $ or \( \) or \[ \]
		 * (all are multiline)
		 */
		'equation': [
			{
				pattern: /\$\$(?:\\[\s\S]|[^\\$])+\$\$|\$(?:\\[\s\S]|[^\\$])+\$|\\\([\s\S]*?\\\)|\\\[[\s\S]*?\\\]/,
				inside: insideEqu,
				alias: 'string'
			},
			{
				pattern: /(\\begin\{((?:align|eqnarray|equation|gather|math|multline)\*?)\})[\s\S]*?(?=\\end\{\2\})/,
				lookbehind: true,
				inside: insideEqu,
				alias: 'string'
			}
		],
		/*
		 * arguments which are keywords or references are highlighted
		 * as keywords
		 */
		'keyword': {
			pattern: /(\\(?:begin|cite|documentclass|end|label|ref|usepackage)(?:\[[^\]]+\])?\{)[^}]+(?=\})/,
			lookbehind: true
		},
		'url': {
			pattern: /(\\url\{)[^}]+(?=\})/,
			lookbehind: true
		},
		/*
		 * section or chapter headlines are highlighted as bold so that
		 * they stand out more
		 */
		'headline': {
			pattern: /(\\(?:chapter|frametitle|paragraph|part|section|subparagraph|subsection|subsubparagraph|subsubsection|subsubsubparagraph)\*?(?:\[[^\]]+\])?\{)[^}]+(?=\})/,
			lookbehind: true,
			alias: 'class-name'
		},
		'function': {
			pattern: funcPattern,
			alias: 'selector'
		},
		'punctuation': /[[\]{}&]/
	};

	Prism.languages.tex = Prism.languages.latex;
	Prism.languages.context = Prism.languages.latex;
}(Prism));


/***/ }),

/***/ "../structured-text-editor/node_modules/prismjs/prism.js":
/*!***************************************************************!*\
  !*** ../structured-text-editor/node_modules/prismjs/prism.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/* **********************************************
     Begin prism-core.js
********************************************** */

/// <reference lib="WebWorker"/>

var _self = (typeof window !== 'undefined')
	? window   // if in browser
	: (
		(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
			? self // if in worker
			: {}   // if in node js
	);

/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 *
 * @license MIT <https://opensource.org/licenses/MIT>
 * @author Lea Verou <https://lea.verou.me>
 * @namespace
 * @public
 */
var Prism = (function (_self) {

	// Private helper vars
	var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
	var uniqueId = 0;

	// The grammar object for plaintext
	var plainTextGrammar = {};


	var _ = {
		/**
		 * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
		 * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
		 * additional languages or plugins yourself.
		 *
		 * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
		 *
		 * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
		 * empty Prism object into the global scope before loading the Prism script like this:
		 *
		 * ```js
		 * window.Prism = window.Prism || {};
		 * Prism.manual = true;
		 * // add a new <script> to load Prism's script
		 * ```
		 *
		 * @default false
		 * @type {boolean}
		 * @memberof Prism
		 * @public
		 */
		manual: _self.Prism && _self.Prism.manual,
		/**
		 * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
		 * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
		 * own worker, you don't want it to do this.
		 *
		 * By setting this value to `true`, Prism will not add its own listeners to the worker.
		 *
		 * You obviously have to change this value before Prism executes. To do this, you can add an
		 * empty Prism object into the global scope before loading the Prism script like this:
		 *
		 * ```js
		 * window.Prism = window.Prism || {};
		 * Prism.disableWorkerMessageHandler = true;
		 * // Load Prism's script
		 * ```
		 *
		 * @default false
		 * @type {boolean}
		 * @memberof Prism
		 * @public
		 */
		disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,

		/**
		 * A namespace for utility methods.
		 *
		 * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
		 * change or disappear at any time.
		 *
		 * @namespace
		 * @memberof Prism
		 */
		util: {
			encode: function encode(tokens) {
				if (tokens instanceof Token) {
					return new Token(tokens.type, encode(tokens.content), tokens.alias);
				} else if (Array.isArray(tokens)) {
					return tokens.map(encode);
				} else {
					return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
				}
			},

			/**
			 * Returns the name of the type of the given value.
			 *
			 * @param {any} o
			 * @returns {string}
			 * @example
			 * type(null)      === 'Null'
			 * type(undefined) === 'Undefined'
			 * type(123)       === 'Number'
			 * type('foo')     === 'String'
			 * type(true)      === 'Boolean'
			 * type([1, 2])    === 'Array'
			 * type({})        === 'Object'
			 * type(String)    === 'Function'
			 * type(/abc+/)    === 'RegExp'
			 */
			type: function (o) {
				return Object.prototype.toString.call(o).slice(8, -1);
			},

			/**
			 * Returns a unique number for the given object. Later calls will still return the same number.
			 *
			 * @param {Object} obj
			 * @returns {number}
			 */
			objId: function (obj) {
				if (!obj['__id']) {
					Object.defineProperty(obj, '__id', { value: ++uniqueId });
				}
				return obj['__id'];
			},

			/**
			 * Creates a deep clone of the given object.
			 *
			 * The main intended use of this function is to clone language definitions.
			 *
			 * @param {T} o
			 * @param {Record<number, any>} [visited]
			 * @returns {T}
			 * @template T
			 */
			clone: function deepClone(o, visited) {
				visited = visited || {};

				var clone; var id;
				switch (_.util.type(o)) {
					case 'Object':
						id = _.util.objId(o);
						if (visited[id]) {
							return visited[id];
						}
						clone = /** @type {Record<string, any>} */ ({});
						visited[id] = clone;

						for (var key in o) {
							if (o.hasOwnProperty(key)) {
								clone[key] = deepClone(o[key], visited);
							}
						}

						return /** @type {any} */ (clone);

					case 'Array':
						id = _.util.objId(o);
						if (visited[id]) {
							return visited[id];
						}
						clone = [];
						visited[id] = clone;

						(/** @type {Array} */(/** @type {any} */(o))).forEach(function (v, i) {
							clone[i] = deepClone(v, visited);
						});

						return /** @type {any} */ (clone);

					default:
						return o;
				}
			},

			/**
			 * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
			 *
			 * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
			 *
			 * @param {Element} element
			 * @returns {string}
			 */
			getLanguage: function (element) {
				while (element) {
					var m = lang.exec(element.className);
					if (m) {
						return m[1].toLowerCase();
					}
					element = element.parentElement;
				}
				return 'none';
			},

			/**
			 * Sets the Prism `language-xxxx` class of the given element.
			 *
			 * @param {Element} element
			 * @param {string} language
			 * @returns {void}
			 */
			setLanguage: function (element, language) {
				// remove all `language-xxxx` classes
				// (this might leave behind a leading space)
				element.className = element.className.replace(RegExp(lang, 'gi'), '');

				// add the new `language-xxxx` class
				// (using `classList` will automatically clean up spaces for us)
				element.classList.add('language-' + language);
			},

			/**
			 * Returns the script element that is currently executing.
			 *
			 * This does __not__ work for line script element.
			 *
			 * @returns {HTMLScriptElement | null}
			 */
			currentScript: function () {
				if (typeof document === 'undefined') {
					return null;
				}
				if ('currentScript' in document && 1 < 2 /* hack to trip TS' flow analysis */) {
					return /** @type {any} */ (document.currentScript);
				}

				// IE11 workaround
				// we'll get the src of the current script by parsing IE11's error stack trace
				// this will not work for inline scripts

				try {
					throw new Error();
				} catch (err) {
					// Get file src url from stack. Specifically works with the format of stack traces in IE.
					// A stack will look like this:
					//
					// Error
					//    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)
					//    at Global code (http://localhost/components/prism-core.js:606:1)

					var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
					if (src) {
						var scripts = document.getElementsByTagName('script');
						for (var i in scripts) {
							if (scripts[i].src == src) {
								return scripts[i];
							}
						}
					}
					return null;
				}
			},

			/**
			 * Returns whether a given class is active for `element`.
			 *
			 * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
			 * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
			 * given class is just the given class with a `no-` prefix.
			 *
			 * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
			 * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
			 * ancestors have the given class or the negated version of it, then the default activation will be returned.
			 *
			 * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
			 * version of it, the class is considered active.
			 *
			 * @param {Element} element
			 * @param {string} className
			 * @param {boolean} [defaultActivation=false]
			 * @returns {boolean}
			 */
			isActive: function (element, className, defaultActivation) {
				var no = 'no-' + className;

				while (element) {
					var classList = element.classList;
					if (classList.contains(className)) {
						return true;
					}
					if (classList.contains(no)) {
						return false;
					}
					element = element.parentElement;
				}
				return !!defaultActivation;
			}
		},

		/**
		 * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
		 *
		 * @namespace
		 * @memberof Prism
		 * @public
		 */
		languages: {
			/**
			 * The grammar for plain, unformatted text.
			 */
			plain: plainTextGrammar,
			plaintext: plainTextGrammar,
			text: plainTextGrammar,
			txt: plainTextGrammar,

			/**
			 * Creates a deep copy of the language with the given id and appends the given tokens.
			 *
			 * If a token in `redef` also appears in the copied language, then the existing token in the copied language
			 * will be overwritten at its original position.
			 *
			 * ## Best practices
			 *
			 * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
			 * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
			 * understand the language definition because, normally, the order of tokens matters in Prism grammars.
			 *
			 * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
			 * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
			 *
			 * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
			 * @param {Grammar} redef The new tokens to append.
			 * @returns {Grammar} The new language created.
			 * @public
			 * @example
			 * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
			 *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
			 *     // at its original position
			 *     'comment': { ... },
			 *     // CSS doesn't have a 'color' token, so this token will be appended
			 *     'color': /\b(?:red|green|blue)\b/
			 * });
			 */
			extend: function (id, redef) {
				var lang = _.util.clone(_.languages[id]);

				for (var key in redef) {
					lang[key] = redef[key];
				}

				return lang;
			},

			/**
			 * Inserts tokens _before_ another token in a language definition or any other grammar.
			 *
			 * ## Usage
			 *
			 * This helper method makes it easy to modify existing languages. For example, the CSS language definition
			 * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
			 * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
			 * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
			 * this:
			 *
			 * ```js
			 * Prism.languages.markup.style = {
			 *     // token
			 * };
			 * ```
			 *
			 * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
			 * before existing tokens. For the CSS example above, you would use it like this:
			 *
			 * ```js
			 * Prism.languages.insertBefore('markup', 'cdata', {
			 *     'style': {
			 *         // token
			 *     }
			 * });
			 * ```
			 *
			 * ## Special cases
			 *
			 * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
			 * will be ignored.
			 *
			 * This behavior can be used to insert tokens after `before`:
			 *
			 * ```js
			 * Prism.languages.insertBefore('markup', 'comment', {
			 *     'comment': Prism.languages.markup.comment,
			 *     // tokens after 'comment'
			 * });
			 * ```
			 *
			 * ## Limitations
			 *
			 * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
			 * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
			 * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
			 * deleting properties which is necessary to insert at arbitrary positions.
			 *
			 * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
			 * Instead, it will create a new object and replace all references to the target object with the new one. This
			 * can be done without temporarily deleting properties, so the iteration order is well-defined.
			 *
			 * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
			 * you hold the target object in a variable, then the value of the variable will not change.
			 *
			 * ```js
			 * var oldMarkup = Prism.languages.markup;
			 * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
			 *
			 * assert(oldMarkup !== Prism.languages.markup);
			 * assert(newMarkup === Prism.languages.markup);
			 * ```
			 *
			 * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
			 * object to be modified.
			 * @param {string} before The key to insert before.
			 * @param {Grammar} insert An object containing the key-value pairs to be inserted.
			 * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
			 * object to be modified.
			 *
			 * Defaults to `Prism.languages`.
			 * @returns {Grammar} The new grammar object.
			 * @public
			 */
			insertBefore: function (inside, before, insert, root) {
				root = root || /** @type {any} */ (_.languages);
				var grammar = root[inside];
				/** @type {Grammar} */
				var ret = {};

				for (var token in grammar) {
					if (grammar.hasOwnProperty(token)) {

						if (token == before) {
							for (var newToken in insert) {
								if (insert.hasOwnProperty(newToken)) {
									ret[newToken] = insert[newToken];
								}
							}
						}

						// Do not insert token which also occur in insert. See #1525
						if (!insert.hasOwnProperty(token)) {
							ret[token] = grammar[token];
						}
					}
				}

				var old = root[inside];
				root[inside] = ret;

				// Update references in other language definitions
				_.languages.DFS(_.languages, function (key, value) {
					if (value === old && key != inside) {
						this[key] = ret;
					}
				});

				return ret;
			},

			// Traverse a language definition with Depth First Search
			DFS: function DFS(o, callback, type, visited) {
				visited = visited || {};

				var objId = _.util.objId;

				for (var i in o) {
					if (o.hasOwnProperty(i)) {
						callback.call(o, i, o[i], type || i);

						var property = o[i];
						var propertyType = _.util.type(property);

						if (propertyType === 'Object' && !visited[objId(property)]) {
							visited[objId(property)] = true;
							DFS(property, callback, null, visited);
						} else if (propertyType === 'Array' && !visited[objId(property)]) {
							visited[objId(property)] = true;
							DFS(property, callback, i, visited);
						}
					}
				}
			}
		},

		plugins: {},

		/**
		 * This is the most high-level function in Prism’s API.
		 * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
		 * each one of them.
		 *
		 * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
		 *
		 * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
		 * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
		 * @memberof Prism
		 * @public
		 */
		highlightAll: function (async, callback) {
			_.highlightAllUnder(document, async, callback);
		},

		/**
		 * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
		 * {@link Prism.highlightElement} on each one of them.
		 *
		 * The following hooks will be run:
		 * 1. `before-highlightall`
		 * 2. `before-all-elements-highlight`
		 * 3. All hooks of {@link Prism.highlightElement} for each element.
		 *
		 * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
		 * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
		 * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
		 * @memberof Prism
		 * @public
		 */
		highlightAllUnder: function (container, async, callback) {
			var env = {
				callback: callback,
				container: container,
				selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
			};

			_.hooks.run('before-highlightall', env);

			env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));

			_.hooks.run('before-all-elements-highlight', env);

			for (var i = 0, element; (element = env.elements[i++]);) {
				_.highlightElement(element, async === true, env.callback);
			}
		},

		/**
		 * Highlights the code inside a single element.
		 *
		 * The following hooks will be run:
		 * 1. `before-sanity-check`
		 * 2. `before-highlight`
		 * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
		 * 4. `before-insert`
		 * 5. `after-highlight`
		 * 6. `complete`
		 *
		 * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
		 * the element's language.
		 *
		 * @param {Element} element The element containing the code.
		 * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
		 * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
		 * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
		 * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
		 *
		 * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
		 * asynchronous highlighting to work. You can build your own bundle on the
		 * [Download page](https://prismjs.com/download.html).
		 * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
		 * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
		 * @memberof Prism
		 * @public
		 */
		highlightElement: function (element, async, callback) {
			// Find language
			var language = _.util.getLanguage(element);
			var grammar = _.languages[language];

			// Set language on the element, if not present
			_.util.setLanguage(element, language);

			// Set language on the parent, for styling
			var parent = element.parentElement;
			if (parent && parent.nodeName.toLowerCase() === 'pre') {
				_.util.setLanguage(parent, language);
			}

			var code = element.textContent;

			var env = {
				element: element,
				language: language,
				grammar: grammar,
				code: code
			};

			function insertHighlightedCode(highlightedCode) {
				env.highlightedCode = highlightedCode;

				_.hooks.run('before-insert', env);

				env.element.innerHTML = env.highlightedCode;

				_.hooks.run('after-highlight', env);
				_.hooks.run('complete', env);
				callback && callback.call(env.element);
			}

			_.hooks.run('before-sanity-check', env);

			// plugins may change/add the parent/element
			parent = env.element.parentElement;
			if (parent && parent.nodeName.toLowerCase() === 'pre' && !parent.hasAttribute('tabindex')) {
				parent.setAttribute('tabindex', '0');
			}

			if (!env.code) {
				_.hooks.run('complete', env);
				callback && callback.call(env.element);
				return;
			}

			_.hooks.run('before-highlight', env);

			if (!env.grammar) {
				insertHighlightedCode(_.util.encode(env.code));
				return;
			}

			if (async && _self.Worker) {
				var worker = new Worker(_.filename);

				worker.onmessage = function (evt) {
					insertHighlightedCode(evt.data);
				};

				worker.postMessage(JSON.stringify({
					language: env.language,
					code: env.code,
					immediateClose: true
				}));
			} else {
				insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
			}
		},

		/**
		 * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
		 * and the language definitions to use, and returns a string with the HTML produced.
		 *
		 * The following hooks will be run:
		 * 1. `before-tokenize`
		 * 2. `after-tokenize`
		 * 3. `wrap`: On each {@link Token}.
		 *
		 * @param {string} text A string with the code to be highlighted.
		 * @param {Grammar} grammar An object containing the tokens to use.
		 *
		 * Usually a language definition like `Prism.languages.markup`.
		 * @param {string} language The name of the language definition passed to `grammar`.
		 * @returns {string} The highlighted HTML.
		 * @memberof Prism
		 * @public
		 * @example
		 * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
		 */
		highlight: function (text, grammar, language) {
			var env = {
				code: text,
				grammar: grammar,
				language: language
			};
			_.hooks.run('before-tokenize', env);
			if (!env.grammar) {
				throw new Error('The language "' + env.language + '" has no grammar.');
			}
			env.tokens = _.tokenize(env.code, env.grammar);
			_.hooks.run('after-tokenize', env);
			return Token.stringify(_.util.encode(env.tokens), env.language);
		},

		/**
		 * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
		 * and the language definitions to use, and returns an array with the tokenized code.
		 *
		 * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
		 *
		 * This method could be useful in other contexts as well, as a very crude parser.
		 *
		 * @param {string} text A string with the code to be highlighted.
		 * @param {Grammar} grammar An object containing the tokens to use.
		 *
		 * Usually a language definition like `Prism.languages.markup`.
		 * @returns {TokenStream} An array of strings and tokens, a token stream.
		 * @memberof Prism
		 * @public
		 * @example
		 * let code = `var foo = 0;`;
		 * let tokens = Prism.tokenize(code, Prism.languages.javascript);
		 * tokens.forEach(token => {
		 *     if (token instanceof Prism.Token && token.type === 'number') {
		 *         console.log(`Found numeric literal: ${token.content}`);
		 *     }
		 * });
		 */
		tokenize: function (text, grammar) {
			var rest = grammar.rest;
			if (rest) {
				for (var token in rest) {
					grammar[token] = rest[token];
				}

				delete grammar.rest;
			}

			var tokenList = new LinkedList();
			addAfter(tokenList, tokenList.head, text);

			matchGrammar(text, tokenList, grammar, tokenList.head, 0);

			return toArray(tokenList);
		},

		/**
		 * @namespace
		 * @memberof Prism
		 * @public
		 */
		hooks: {
			all: {},

			/**
			 * Adds the given callback to the list of callbacks for the given hook.
			 *
			 * The callback will be invoked when the hook it is registered for is run.
			 * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
			 *
			 * One callback function can be registered to multiple hooks and the same hook multiple times.
			 *
			 * @param {string} name The name of the hook.
			 * @param {HookCallback} callback The callback function which is given environment variables.
			 * @public
			 */
			add: function (name, callback) {
				var hooks = _.hooks.all;

				hooks[name] = hooks[name] || [];

				hooks[name].push(callback);
			},

			/**
			 * Runs a hook invoking all registered callbacks with the given environment variables.
			 *
			 * Callbacks will be invoked synchronously and in the order in which they were registered.
			 *
			 * @param {string} name The name of the hook.
			 * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
			 * @public
			 */
			run: function (name, env) {
				var callbacks = _.hooks.all[name];

				if (!callbacks || !callbacks.length) {
					return;
				}

				for (var i = 0, callback; (callback = callbacks[i++]);) {
					callback(env);
				}
			}
		},

		Token: Token
	};
	_self.Prism = _;


	// Typescript note:
	// The following can be used to import the Token type in JSDoc:
	//
	//   @typedef {InstanceType<import("./prism-core")["Token"]>} Token

	/**
	 * Creates a new token.
	 *
	 * @param {string} type See {@link Token#type type}
	 * @param {string | TokenStream} content See {@link Token#content content}
	 * @param {string|string[]} [alias] The alias(es) of the token.
	 * @param {string} [matchedStr=""] A copy of the full string this token was created from.
	 * @class
	 * @global
	 * @public
	 */
	function Token(type, content, alias, matchedStr) {
		/**
		 * The type of the token.
		 *
		 * This is usually the key of a pattern in a {@link Grammar}.
		 *
		 * @type {string}
		 * @see GrammarToken
		 * @public
		 */
		this.type = type;
		/**
		 * The strings or tokens contained by this token.
		 *
		 * This will be a token stream if the pattern matched also defined an `inside` grammar.
		 *
		 * @type {string | TokenStream}
		 * @public
		 */
		this.content = content;
		/**
		 * The alias(es) of the token.
		 *
		 * @type {string|string[]}
		 * @see GrammarToken
		 * @public
		 */
		this.alias = alias;
		// Copy of the full string this token was created from
		this.length = (matchedStr || '').length | 0;
	}

	/**
	 * A token stream is an array of strings and {@link Token Token} objects.
	 *
	 * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process
	 * them.
	 *
	 * 1. No adjacent strings.
	 * 2. No empty strings.
	 *
	 *    The only exception here is the token stream that only contains the empty string and nothing else.
	 *
	 * @typedef {Array<string | Token>} TokenStream
	 * @global
	 * @public
	 */

	/**
	 * Converts the given token or token stream to an HTML representation.
	 *
	 * The following hooks will be run:
	 * 1. `wrap`: On each {@link Token}.
	 *
	 * @param {string | Token | TokenStream} o The token or token stream to be converted.
	 * @param {string} language The name of current language.
	 * @returns {string} The HTML representation of the token or token stream.
	 * @memberof Token
	 * @static
	 */
	Token.stringify = function stringify(o, language) {
		if (typeof o == 'string') {
			return o;
		}
		if (Array.isArray(o)) {
			var s = '';
			o.forEach(function (e) {
				s += stringify(e, language);
			});
			return s;
		}

		var env = {
			type: o.type,
			content: stringify(o.content, language),
			tag: 'span',
			classes: ['token', o.type],
			attributes: {},
			language: language
		};

		var aliases = o.alias;
		if (aliases) {
			if (Array.isArray(aliases)) {
				Array.prototype.push.apply(env.classes, aliases);
			} else {
				env.classes.push(aliases);
			}
		}

		_.hooks.run('wrap', env);

		var attributes = '';
		for (var name in env.attributes) {
			attributes += ' ' + name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
		}

		return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + attributes + '>' + env.content + '</' + env.tag + '>';
	};

	/**
	 * @param {RegExp} pattern
	 * @param {number} pos
	 * @param {string} text
	 * @param {boolean} lookbehind
	 * @returns {RegExpExecArray | null}
	 */
	function matchPattern(pattern, pos, text, lookbehind) {
		pattern.lastIndex = pos;
		var match = pattern.exec(text);
		if (match && lookbehind && match[1]) {
			// change the match to remove the text matched by the Prism lookbehind group
			var lookbehindLength = match[1].length;
			match.index += lookbehindLength;
			match[0] = match[0].slice(lookbehindLength);
		}
		return match;
	}

	/**
	 * @param {string} text
	 * @param {LinkedList<string | Token>} tokenList
	 * @param {any} grammar
	 * @param {LinkedListNode<string | Token>} startNode
	 * @param {number} startPos
	 * @param {RematchOptions} [rematch]
	 * @returns {void}
	 * @private
	 *
	 * @typedef RematchOptions
	 * @property {string} cause
	 * @property {number} reach
	 */
	function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
		for (var token in grammar) {
			if (!grammar.hasOwnProperty(token) || !grammar[token]) {
				continue;
			}

			var patterns = grammar[token];
			patterns = Array.isArray(patterns) ? patterns : [patterns];

			for (var j = 0; j < patterns.length; ++j) {
				if (rematch && rematch.cause == token + ',' + j) {
					return;
				}

				var patternObj = patterns[j];
				var inside = patternObj.inside;
				var lookbehind = !!patternObj.lookbehind;
				var greedy = !!patternObj.greedy;
				var alias = patternObj.alias;

				if (greedy && !patternObj.pattern.global) {
					// Without the global flag, lastIndex won't work
					var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
					patternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');
				}

				/** @type {RegExp} */
				var pattern = patternObj.pattern || patternObj;

				for ( // iterate the token list and keep track of the current token/string position
					var currentNode = startNode.next, pos = startPos;
					currentNode !== tokenList.tail;
					pos += currentNode.value.length, currentNode = currentNode.next
				) {

					if (rematch && pos >= rematch.reach) {
						break;
					}

					var str = currentNode.value;

					if (tokenList.length > text.length) {
						// Something went terribly wrong, ABORT, ABORT!
						return;
					}

					if (str instanceof Token) {
						continue;
					}

					var removeCount = 1; // this is the to parameter of removeBetween
					var match;

					if (greedy) {
						match = matchPattern(pattern, pos, text, lookbehind);
						if (!match || match.index >= text.length) {
							break;
						}

						var from = match.index;
						var to = match.index + match[0].length;
						var p = pos;

						// find the node that contains the match
						p += currentNode.value.length;
						while (from >= p) {
							currentNode = currentNode.next;
							p += currentNode.value.length;
						}
						// adjust pos (and p)
						p -= currentNode.value.length;
						pos = p;

						// the current node is a Token, then the match starts inside another Token, which is invalid
						if (currentNode.value instanceof Token) {
							continue;
						}

						// find the last node which is affected by this match
						for (
							var k = currentNode;
							k !== tokenList.tail && (p < to || typeof k.value === 'string');
							k = k.next
						) {
							removeCount++;
							p += k.value.length;
						}
						removeCount--;

						// replace with the new match
						str = text.slice(pos, p);
						match.index -= pos;
					} else {
						match = matchPattern(pattern, 0, str, lookbehind);
						if (!match) {
							continue;
						}
					}

					// eslint-disable-next-line no-redeclare
					var from = match.index;
					var matchStr = match[0];
					var before = str.slice(0, from);
					var after = str.slice(from + matchStr.length);

					var reach = pos + str.length;
					if (rematch && reach > rematch.reach) {
						rematch.reach = reach;
					}

					var removeFrom = currentNode.prev;

					if (before) {
						removeFrom = addAfter(tokenList, removeFrom, before);
						pos += before.length;
					}

					removeRange(tokenList, removeFrom, removeCount);

					var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
					currentNode = addAfter(tokenList, removeFrom, wrapped);

					if (after) {
						addAfter(tokenList, currentNode, after);
					}

					if (removeCount > 1) {
						// at least one Token object was removed, so we have to do some rematching
						// this can only happen if the current pattern is greedy

						/** @type {RematchOptions} */
						var nestedRematch = {
							cause: token + ',' + j,
							reach: reach
						};
						matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);

						// the reach might have been extended because of the rematching
						if (rematch && nestedRematch.reach > rematch.reach) {
							rematch.reach = nestedRematch.reach;
						}
					}
				}
			}
		}
	}

	/**
	 * @typedef LinkedListNode
	 * @property {T} value
	 * @property {LinkedListNode<T> | null} prev The previous node.
	 * @property {LinkedListNode<T> | null} next The next node.
	 * @template T
	 * @private
	 */

	/**
	 * @template T
	 * @private
	 */
	function LinkedList() {
		/** @type {LinkedListNode<T>} */
		var head = { value: null, prev: null, next: null };
		/** @type {LinkedListNode<T>} */
		var tail = { value: null, prev: head, next: null };
		head.next = tail;

		/** @type {LinkedListNode<T>} */
		this.head = head;
		/** @type {LinkedListNode<T>} */
		this.tail = tail;
		this.length = 0;
	}

	/**
	 * Adds a new node with the given value to the list.
	 *
	 * @param {LinkedList<T>} list
	 * @param {LinkedListNode<T>} node
	 * @param {T} value
	 * @returns {LinkedListNode<T>} The added node.
	 * @template T
	 */
	function addAfter(list, node, value) {
		// assumes that node != list.tail && values.length >= 0
		var next = node.next;

		var newNode = { value: value, prev: node, next: next };
		node.next = newNode;
		next.prev = newNode;
		list.length++;

		return newNode;
	}
	/**
	 * Removes `count` nodes after the given node. The given node will not be removed.
	 *
	 * @param {LinkedList<T>} list
	 * @param {LinkedListNode<T>} node
	 * @param {number} count
	 * @template T
	 */
	function removeRange(list, node, count) {
		var next = node.next;
		for (var i = 0; i < count && next !== list.tail; i++) {
			next = next.next;
		}
		node.next = next;
		next.prev = node;
		list.length -= i;
	}
	/**
	 * @param {LinkedList<T>} list
	 * @returns {T[]}
	 * @template T
	 */
	function toArray(list) {
		var array = [];
		var node = list.head.next;
		while (node !== list.tail) {
			array.push(node.value);
			node = node.next;
		}
		return array;
	}


	if (!_self.document) {
		if (!_self.addEventListener) {
			// in Node.js
			return _;
		}

		if (!_.disableWorkerMessageHandler) {
			// In worker
			_self.addEventListener('message', function (evt) {
				var message = JSON.parse(evt.data);
				var lang = message.language;
				var code = message.code;
				var immediateClose = message.immediateClose;

				_self.postMessage(_.highlight(code, _.languages[lang], lang));
				if (immediateClose) {
					_self.close();
				}
			}, false);
		}

		return _;
	}

	// Get current script and highlight
	var script = _.util.currentScript();

	if (script) {
		_.filename = script.src;

		if (script.hasAttribute('data-manual')) {
			_.manual = true;
		}
	}

	function highlightAutomaticallyCallback() {
		if (!_.manual) {
			_.highlightAll();
		}
	}

	if (!_.manual) {
		// If the document state is "loading", then we'll use DOMContentLoaded.
		// If the document state is "interactive" and the prism.js script is deferred, then we'll also use the
		// DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they
		// might take longer one animation frame to execute which can create a race condition where only some plugins have
		// been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.
		// See https://github.com/PrismJS/prism/issues/2102
		var readyState = document.readyState;
		if (readyState === 'loading' || readyState === 'interactive' && script && script.defer) {
			document.addEventListener('DOMContentLoaded', highlightAutomaticallyCallback);
		} else {
			if (window.requestAnimationFrame) {
				window.requestAnimationFrame(highlightAutomaticallyCallback);
			} else {
				window.setTimeout(highlightAutomaticallyCallback, 16);
			}
		}
	}

	return _;

}(_self));

if ( true && module.exports) {
	module.exports = Prism;
}

// hack for components to work correctly in node.js
if (typeof __webpack_require__.g !== 'undefined') {
	__webpack_require__.g.Prism = Prism;
}

// some additional documentation/types

/**
 * The expansion of a simple `RegExp` literal to support additional properties.
 *
 * @typedef GrammarToken
 * @property {RegExp} pattern The regular expression of the token.
 * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)
 * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.
 * @property {boolean} [greedy=false] Whether the token is greedy.
 * @property {string|string[]} [alias] An optional alias or list of aliases.
 * @property {Grammar} [inside] The nested grammar of this token.
 *
 * The `inside` grammar will be used to tokenize the text value of each token of this kind.
 *
 * This can be used to make nested and even recursive language definitions.
 *
 * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into
 * each another.
 * @global
 * @public
 */

/**
 * @typedef Grammar
 * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}
 * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.
 * @global
 * @public
 */

/**
 * A function which will invoked after an element was successfully highlighted.
 *
 * @callback HighlightCallback
 * @param {Element} element The element successfully highlighted.
 * @returns {void}
 * @global
 * @public
 */

/**
 * @callback HookCallback
 * @param {Object<string, any>} env The environment variables of the hook.
 * @returns {void}
 * @global
 * @public
 */


/* **********************************************
     Begin prism-markup.js
********************************************** */

Prism.languages.markup = {
	'comment': {
		pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
		greedy: true
	},
	'prolog': {
		pattern: /<\?[\s\S]+?\?>/,
		greedy: true
	},
	'doctype': {
		// https://www.w3.org/TR/xml/#NT-doctypedecl
		pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
		greedy: true,
		inside: {
			'internal-subset': {
				pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
				lookbehind: true,
				greedy: true,
				inside: null // see below
			},
			'string': {
				pattern: /"[^"]*"|'[^']*'/,
				greedy: true
			},
			'punctuation': /^<!|>$|[[\]]/,
			'doctype-tag': /^DOCTYPE/i,
			'name': /[^\s<>'"]+/
		}
	},
	'cdata': {
		pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
		greedy: true
	},
	'tag': {
		pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
		greedy: true,
		inside: {
			'tag': {
				pattern: /^<\/?[^\s>\/]+/,
				inside: {
					'punctuation': /^<\/?/,
					'namespace': /^[^\s>\/:]+:/
				}
			},
			'special-attr': [],
			'attr-value': {
				pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
				inside: {
					'punctuation': [
						{
							pattern: /^=/,
							alias: 'attr-equals'
						},
						/"|'/
					]
				}
			},
			'punctuation': /\/?>/,
			'attr-name': {
				pattern: /[^\s>\/]+/,
				inside: {
					'namespace': /^[^\s>\/:]+:/
				}
			}

		}
	},
	'entity': [
		{
			pattern: /&[\da-z]{1,8};/i,
			alias: 'named-entity'
		},
		/&#x?[\da-f]{1,8};/i
	]
};

Prism.languages.markup['tag'].inside['attr-value'].inside['entity'] =
	Prism.languages.markup['entity'];
Prism.languages.markup['doctype'].inside['internal-subset'].inside = Prism.languages.markup;

// Plugin to make entity title show the real entity, idea by Roman Komarov
Prism.hooks.add('wrap', function (env) {

	if (env.type === 'entity') {
		env.attributes['title'] = env.content.replace(/&amp;/, '&');
	}
});

Object.defineProperty(Prism.languages.markup.tag, 'addInlined', {
	/**
	 * Adds an inlined language to markup.
	 *
	 * An example of an inlined language is CSS with `<style>` tags.
	 *
	 * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
	 * case insensitive.
	 * @param {string} lang The language key.
	 * @example
	 * addInlined('style', 'css');
	 */
	value: function addInlined(tagName, lang) {
		var includedCdataInside = {};
		includedCdataInside['language-' + lang] = {
			pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
			lookbehind: true,
			inside: Prism.languages[lang]
		};
		includedCdataInside['cdata'] = /^<!\[CDATA\[|\]\]>$/i;

		var inside = {
			'included-cdata': {
				pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
				inside: includedCdataInside
			}
		};
		inside['language-' + lang] = {
			pattern: /[\s\S]+/,
			inside: Prism.languages[lang]
		};

		var def = {};
		def[tagName] = {
			pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function () { return tagName; }), 'i'),
			lookbehind: true,
			greedy: true,
			inside: inside
		};

		Prism.languages.insertBefore('markup', 'cdata', def);
	}
});
Object.defineProperty(Prism.languages.markup.tag, 'addAttribute', {
	/**
	 * Adds an pattern to highlight languages embedded in HTML attributes.
	 *
	 * An example of an inlined language is CSS with `style` attributes.
	 *
	 * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
	 * case insensitive.
	 * @param {string} lang The language key.
	 * @example
	 * addAttribute('style', 'css');
	 */
	value: function (attrName, lang) {
		Prism.languages.markup.tag.inside['special-attr'].push({
			pattern: RegExp(
				/(^|["'\s])/.source + '(?:' + attrName + ')' + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
				'i'
			),
			lookbehind: true,
			inside: {
				'attr-name': /^[^\s=]+/,
				'attr-value': {
					pattern: /=[\s\S]+/,
					inside: {
						'value': {
							pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
							lookbehind: true,
							alias: [lang, 'language-' + lang],
							inside: Prism.languages[lang]
						},
						'punctuation': [
							{
								pattern: /^=/,
								alias: 'attr-equals'
							},
							/"|'/
						]
					}
				}
			}
		});
	}
});

Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;

Prism.languages.xml = Prism.languages.extend('markup', {});
Prism.languages.ssml = Prism.languages.xml;
Prism.languages.atom = Prism.languages.xml;
Prism.languages.rss = Prism.languages.xml;


/* **********************************************
     Begin prism-css.js
********************************************** */

(function (Prism) {

	var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;

	Prism.languages.css = {
		'comment': /\/\*[\s\S]*?\*\//,
		'atrule': {
			pattern: /@[\w-](?:[^;{\s]|\s+(?![\s{]))*(?:;|(?=\s*\{))/,
			inside: {
				'rule': /^@[\w-]+/,
				'selector-function-argument': {
					pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
					lookbehind: true,
					alias: 'selector'
				},
				'keyword': {
					pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
					lookbehind: true
				}
				// See rest below
			}
		},
		'url': {
			// https://drafts.csswg.org/css-values-3/#urls
			pattern: RegExp('\\burl\\((?:' + string.source + '|' + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ')\\)', 'i'),
			greedy: true,
			inside: {
				'function': /^url/i,
				'punctuation': /^\(|\)$/,
				'string': {
					pattern: RegExp('^' + string.source + '$'),
					alias: 'url'
				}
			}
		},
		'selector': {
			pattern: RegExp('(^|[{}\\s])[^{}\\s](?:[^{};"\'\\s]|\\s+(?![\\s{])|' + string.source + ')*(?=\\s*\\{)'),
			lookbehind: true
		},
		'string': {
			pattern: string,
			greedy: true
		},
		'property': {
			pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
			lookbehind: true
		},
		'important': /!important\b/i,
		'function': {
			pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
			lookbehind: true
		},
		'punctuation': /[(){};:,]/
	};

	Prism.languages.css['atrule'].inside.rest = Prism.languages.css;

	var markup = Prism.languages.markup;
	if (markup) {
		markup.tag.addInlined('style', 'css');
		markup.tag.addAttribute('style', 'css');
	}

}(Prism));


/* **********************************************
     Begin prism-clike.js
********************************************** */

Prism.languages.clike = {
	'comment': [
		{
			pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
			lookbehind: true,
			greedy: true
		},
		{
			pattern: /(^|[^\\:])\/\/.*/,
			lookbehind: true,
			greedy: true
		}
	],
	'string': {
		pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
		greedy: true
	},
	'class-name': {
		pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
		lookbehind: true,
		inside: {
			'punctuation': /[.\\]/
		}
	},
	'keyword': /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
	'boolean': /\b(?:false|true)\b/,
	'function': /\b\w+(?=\()/,
	'number': /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
	'operator': /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
	'punctuation': /[{}[\];(),.:]/
};


/* **********************************************
     Begin prism-javascript.js
********************************************** */

Prism.languages.javascript = Prism.languages.extend('clike', {
	'class-name': [
		Prism.languages.clike['class-name'],
		{
			pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
			lookbehind: true
		}
	],
	'keyword': [
		{
			pattern: /((?:^|\})\s*)catch\b/,
			lookbehind: true
		},
		{
			pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
			lookbehind: true
		},
	],
	// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
	'function': /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
	'number': {
		pattern: RegExp(
			/(^|[^\w$])/.source +
			'(?:' +
			(
				// constant
				/NaN|Infinity/.source +
				'|' +
				// binary integer
				/0[bB][01]+(?:_[01]+)*n?/.source +
				'|' +
				// octal integer
				/0[oO][0-7]+(?:_[0-7]+)*n?/.source +
				'|' +
				// hexadecimal integer
				/0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source +
				'|' +
				// decimal bigint
				/\d+(?:_\d+)*n/.source +
				'|' +
				// decimal number (integer or float) but no bigint
				/(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source
			) +
			')' +
			/(?![\w$])/.source
		),
		lookbehind: true
	},
	'operator': /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
});

Prism.languages.javascript['class-name'][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;

Prism.languages.insertBefore('javascript', 'keyword', {
	'regex': {
		pattern: RegExp(
			// lookbehind
			// eslint-disable-next-line regexp/no-dupe-characters-character-class
			/((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source +
			// Regex pattern:
			// There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
			// classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
			// with the only syntax, so we have to define 2 different regex patterns.
			/\//.source +
			'(?:' +
			/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source +
			'|' +
			// `v` flag syntax. This supports 3 levels of nested character classes.
			/(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source +
			')' +
			// lookahead
			/(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
		),
		lookbehind: true,
		greedy: true,
		inside: {
			'regex-source': {
				pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
				lookbehind: true,
				alias: 'language-regex',
				inside: Prism.languages.regex
			},
			'regex-delimiter': /^\/|\/$/,
			'regex-flags': /^[a-z]+$/,
		}
	},
	// This must be declared before keyword because we use "function" inside the look-forward
	'function-variable': {
		pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
		alias: 'function'
	},
	'parameter': [
		{
			pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
			lookbehind: true,
			inside: Prism.languages.javascript
		},
		{
			pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
			lookbehind: true,
			inside: Prism.languages.javascript
		},
		{
			pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
			lookbehind: true,
			inside: Prism.languages.javascript
		},
		{
			pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
			lookbehind: true,
			inside: Prism.languages.javascript
		}
	],
	'constant': /\b[A-Z](?:[A-Z_]|\dx?)*\b/
});

Prism.languages.insertBefore('javascript', 'string', {
	'hashbang': {
		pattern: /^#!.*/,
		greedy: true,
		alias: 'comment'
	},
	'template-string': {
		pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
		greedy: true,
		inside: {
			'template-punctuation': {
				pattern: /^`|`$/,
				alias: 'string'
			},
			'interpolation': {
				pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
				lookbehind: true,
				inside: {
					'interpolation-punctuation': {
						pattern: /^\$\{|\}$/,
						alias: 'punctuation'
					},
					rest: Prism.languages.javascript
				}
			},
			'string': /[\s\S]+/
		}
	},
	'string-property': {
		pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
		lookbehind: true,
		greedy: true,
		alias: 'property'
	}
});

Prism.languages.insertBefore('javascript', 'operator', {
	'literal-property': {
		pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
		lookbehind: true,
		alias: 'property'
	},
});

if (Prism.languages.markup) {
	Prism.languages.markup.tag.addInlined('script', 'javascript');

	// add attribute support for all DOM events.
	// https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events
	Prism.languages.markup.tag.addAttribute(
		/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
		'javascript'
	);
}

Prism.languages.js = Prism.languages.javascript;


/* **********************************************
     Begin prism-file-highlight.js
********************************************** */

(function () {

	if (typeof Prism === 'undefined' || typeof document === 'undefined') {
		return;
	}

	// https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill
	if (!Element.prototype.matches) {
		Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
	}

	var LOADING_MESSAGE = 'Loading…';
	var FAILURE_MESSAGE = function (status, message) {
		return '✖ Error ' + status + ' while fetching file: ' + message;
	};
	var FAILURE_EMPTY_MESSAGE = '✖ Error: File does not exist or is empty';

	var EXTENSIONS = {
		'js': 'javascript',
		'py': 'python',
		'rb': 'ruby',
		'ps1': 'powershell',
		'psm1': 'powershell',
		'sh': 'bash',
		'bat': 'batch',
		'h': 'c',
		'tex': 'latex'
	};

	var STATUS_ATTR = 'data-src-status';
	var STATUS_LOADING = 'loading';
	var STATUS_LOADED = 'loaded';
	var STATUS_FAILED = 'failed';

	var SELECTOR = 'pre[data-src]:not([' + STATUS_ATTR + '="' + STATUS_LOADED + '"])'
		+ ':not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';

	/**
	 * Loads the given file.
	 *
	 * @param {string} src The URL or path of the source file to load.
	 * @param {(result: string) => void} success
	 * @param {(reason: string) => void} error
	 */
	function loadFile(src, success, error) {
		var xhr = new XMLHttpRequest();
		xhr.open('GET', src, true);
		xhr.onreadystatechange = function () {
			if (xhr.readyState == 4) {
				if (xhr.status < 400 && xhr.responseText) {
					success(xhr.responseText);
				} else {
					if (xhr.status >= 400) {
						error(FAILURE_MESSAGE(xhr.status, xhr.statusText));
					} else {
						error(FAILURE_EMPTY_MESSAGE);
					}
				}
			}
		};
		xhr.send(null);
	}

	/**
	 * Parses the given range.
	 *
	 * This returns a range with inclusive ends.
	 *
	 * @param {string | null | undefined} range
	 * @returns {[number, number | undefined] | undefined}
	 */
	function parseRange(range) {
		var m = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range || '');
		if (m) {
			var start = Number(m[1]);
			var comma = m[2];
			var end = m[3];

			if (!comma) {
				return [start, start];
			}
			if (!end) {
				return [start, undefined];
			}
			return [start, Number(end)];
		}
		return undefined;
	}

	Prism.hooks.add('before-highlightall', function (env) {
		env.selector += ', ' + SELECTOR;
	});

	Prism.hooks.add('before-sanity-check', function (env) {
		var pre = /** @type {HTMLPreElement} */ (env.element);
		if (pre.matches(SELECTOR)) {
			env.code = ''; // fast-path the whole thing and go to complete

			pre.setAttribute(STATUS_ATTR, STATUS_LOADING); // mark as loading

			// add code element with loading message
			var code = pre.appendChild(document.createElement('CODE'));
			code.textContent = LOADING_MESSAGE;

			var src = pre.getAttribute('data-src');

			var language = env.language;
			if (language === 'none') {
				// the language might be 'none' because there is no language set;
				// in this case, we want to use the extension as the language
				var extension = (/\.(\w+)$/.exec(src) || [, 'none'])[1];
				language = EXTENSIONS[extension] || extension;
			}

			// set language classes
			Prism.util.setLanguage(code, language);
			Prism.util.setLanguage(pre, language);

			// preload the language
			var autoloader = Prism.plugins.autoloader;
			if (autoloader) {
				autoloader.loadLanguages(language);
			}

			// load file
			loadFile(
				src,
				function (text) {
					// mark as loaded
					pre.setAttribute(STATUS_ATTR, STATUS_LOADED);

					// handle data-range
					var range = parseRange(pre.getAttribute('data-range'));
					if (range) {
						var lines = text.split(/\r\n?|\n/g);

						// the range is one-based and inclusive on both ends
						var start = range[0];
						var end = range[1] == null ? lines.length : range[1];

						if (start < 0) { start += lines.length; }
						start = Math.max(0, Math.min(start - 1, lines.length));
						if (end < 0) { end += lines.length; }
						end = Math.max(0, Math.min(end, lines.length));

						text = lines.slice(start, end).join('\n');

						// add data-start for line numbers
						if (!pre.hasAttribute('data-start')) {
							pre.setAttribute('data-start', String(start + 1));
						}
					}

					// highlight code
					code.textContent = text;
					Prism.highlightElement(code);
				},
				function (error) {
					// mark as failed
					pre.setAttribute(STATUS_ATTR, STATUS_FAILED);

					code.textContent = error;
				}
			);
		}
	});

	Prism.plugins.fileHighlight = {
		/**
		 * Executes the File Highlight plugin for all matching `pre` elements under the given container.
		 *
		 * Note: Elements which are already loaded or currently loading will not be touched by this method.
		 *
		 * @param {ParentNode} [container=document]
		 */
		highlight: function highlight(container) {
			var elements = (container || document).querySelectorAll(SELECTOR);

			for (var i = 0, element; (element = elements[i++]);) {
				Prism.highlightElement(element);
			}
		}
	};

	var logged = false;
	/** @deprecated Use `Prism.plugins.fileHighlight.highlight` instead. */
	Prism.fileHighlight = function () {
		if (!logged) {
			console.warn('Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.');
			logged = true;
		}
		Prism.plugins.fileHighlight.highlight.apply(this, arguments);
	};

}());


/***/ }),

/***/ "../structured-text-editor/node_modules/tippy.js/dist/tippy.esm.js":
/*!*************************************************************************!*\
  !*** ../structured-text-editor/node_modules/tippy.js/dist/tippy.esm.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "animateFill": () => (/* binding */ animateFill),
/* harmony export */   "createSingleton": () => (/* binding */ createSingleton),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "delegate": () => (/* binding */ delegate),
/* harmony export */   "followCursor": () => (/* binding */ followCursor),
/* harmony export */   "hideAll": () => (/* binding */ hideAll),
/* harmony export */   "inlinePositioning": () => (/* binding */ inlinePositioning),
/* harmony export */   "roundArrow": () => (/* binding */ ROUND_ARROW),
/* harmony export */   "sticky": () => (/* binding */ sticky)
/* harmony export */ });
/* harmony import */ var _popperjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @popperjs/core */ "../structured-text-editor/node_modules/@popperjs/core/lib/popper.js");
/**!
* tippy.js v6.2.3
* (c) 2017-2020 atomiks
* MIT License
*/


var ROUND_ARROW = '<svg width="16" height="6" xmlns="http://www.w3.org/2000/svg"><path d="M0 6s1.796-.013 4.67-3.615C5.851.9 6.93.006 8 0c1.07-.006 2.148.887 3.343 2.385C14.233 6.005 16 6 16 6H0z"></svg>';
var BOX_CLASS = "tippy-box";
var CONTENT_CLASS = "tippy-content";
var BACKDROP_CLASS = "tippy-backdrop";
var ARROW_CLASS = "tippy-arrow";
var SVG_ARROW_CLASS = "tippy-svg-arrow";
var TOUCH_OPTIONS = {
  passive: true,
  capture: true
};

function hasOwnProperty(obj, key) {
  return {}.hasOwnProperty.call(obj, key);
}
function getValueAtIndexOrReturn(value, index, defaultValue) {
  if (Array.isArray(value)) {
    var v = value[index];
    return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;
  }

  return value;
}
function isType(value, type) {
  var str = {}.toString.call(value);
  return str.indexOf('[object') === 0 && str.indexOf(type + "]") > -1;
}
function invokeWithArgsOrReturn(value, args) {
  return typeof value === 'function' ? value.apply(void 0, args) : value;
}
function debounce(fn, ms) {
  // Avoid wrapping in `setTimeout` if ms is 0 anyway
  if (ms === 0) {
    return fn;
  }

  var timeout;
  return function (arg) {
    clearTimeout(timeout);
    timeout = setTimeout(function () {
      fn(arg);
    }, ms);
  };
}
function removeProperties(obj, keys) {
  var clone = Object.assign({}, obj);
  keys.forEach(function (key) {
    delete clone[key];
  });
  return clone;
}
function splitBySpaces(value) {
  return value.split(/\s+/).filter(Boolean);
}
function normalizeToArray(value) {
  return [].concat(value);
}
function pushIfUnique(arr, value) {
  if (arr.indexOf(value) === -1) {
    arr.push(value);
  }
}
function unique(arr) {
  return arr.filter(function (item, index) {
    return arr.indexOf(item) === index;
  });
}
function getBasePlacement(placement) {
  return placement.split('-')[0];
}
function arrayFrom(value) {
  return [].slice.call(value);
}

function div() {
  return document.createElement('div');
}
function isElement(value) {
  return ['Element', 'Fragment'].some(function (type) {
    return isType(value, type);
  });
}
function isNodeList(value) {
  return isType(value, 'NodeList');
}
function isMouseEvent(value) {
  return isType(value, 'MouseEvent');
}
function isReferenceElement(value) {
  return !!(value && value._tippy && value._tippy.reference === value);
}
function getArrayOfElements(value) {
  if (isElement(value)) {
    return [value];
  }

  if (isNodeList(value)) {
    return arrayFrom(value);
  }

  if (Array.isArray(value)) {
    return value;
  }

  return arrayFrom(document.querySelectorAll(value));
}
function setTransitionDuration(els, value) {
  els.forEach(function (el) {
    if (el) {
      el.style.transitionDuration = value + "ms";
    }
  });
}
function setVisibilityState(els, state) {
  els.forEach(function (el) {
    if (el) {
      el.setAttribute('data-state', state);
    }
  });
}
function getOwnerDocument(elementOrElements) {
  var _normalizeToArray = normalizeToArray(elementOrElements),
      element = _normalizeToArray[0];

  return element ? element.ownerDocument || document : document;
}
function isCursorOutsideInteractiveBorder(popperTreeData, event) {
  var clientX = event.clientX,
      clientY = event.clientY;
  return popperTreeData.every(function (_ref) {
    var popperRect = _ref.popperRect,
        popperState = _ref.popperState,
        props = _ref.props;
    var interactiveBorder = props.interactiveBorder;
    var basePlacement = getBasePlacement(popperState.placement);
    var offsetData = popperState.modifiersData.offset;

    if (!offsetData) {
      return true;
    }

    var topDistance = basePlacement === 'bottom' ? offsetData.top.y : 0;
    var bottomDistance = basePlacement === 'top' ? offsetData.bottom.y : 0;
    var leftDistance = basePlacement === 'right' ? offsetData.left.x : 0;
    var rightDistance = basePlacement === 'left' ? offsetData.right.x : 0;
    var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
    var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
    var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
    var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
  });
}
function updateTransitionEndListener(box, action, listener) {
  var method = action + "EventListener"; // some browsers apparently support `transition` (unprefixed) but only fire
  // `webkitTransitionEnd`...

  ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {
    box[method](event, listener);
  });
}

var currentInput = {
  isTouch: false
};
var lastMouseMoveTime = 0;
/**
 * When a `touchstart` event is fired, it's assumed the user is using touch
 * input. We'll bind a `mousemove` event listener to listen for mouse input in
 * the future. This way, the `isTouch` property is fully dynamic and will handle
 * hybrid devices that use a mix of touch + mouse input.
 */

function onDocumentTouchStart() {
  if (currentInput.isTouch) {
    return;
  }

  currentInput.isTouch = true;

  if (window.performance) {
    document.addEventListener('mousemove', onDocumentMouseMove);
  }
}
/**
 * When two `mousemove` event are fired consecutively within 20ms, it's assumed
 * the user is using mouse input again. `mousemove` can fire on touch devices as
 * well, but very rarely that quickly.
 */

function onDocumentMouseMove() {
  var now = performance.now();

  if (now - lastMouseMoveTime < 20) {
    currentInput.isTouch = false;
    document.removeEventListener('mousemove', onDocumentMouseMove);
  }

  lastMouseMoveTime = now;
}
/**
 * When an element is in focus and has a tippy, leaving the tab/window and
 * returning causes it to show again. For mouse users this is unexpected, but
 * for keyboard use it makes sense.
 * TODO: find a better technique to solve this problem
 */

function onWindowBlur() {
  var activeElement = document.activeElement;

  if (isReferenceElement(activeElement)) {
    var instance = activeElement._tippy;

    if (activeElement.blur && !instance.state.isVisible) {
      activeElement.blur();
    }
  }
}
function bindGlobalEventListeners() {
  document.addEventListener('touchstart', onDocumentTouchStart, TOUCH_OPTIONS);
  window.addEventListener('blur', onWindowBlur);
}

var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
var ua = isBrowser ? navigator.userAgent : '';
var isIE = /MSIE |Trident\//.test(ua);

function createMemoryLeakWarning(method) {
  var txt = method === 'destroy' ? 'n already-' : ' ';
  return [method + "() was called on a" + txt + "destroyed instance. This is a no-op but", 'indicates a potential memory leak.'].join(' ');
}
function clean(value) {
  var spacesAndTabs = /[ \t]{2,}/g;
  var lineStartWithSpaces = /^[ \t]*/gm;
  return value.replace(spacesAndTabs, ' ').replace(lineStartWithSpaces, '').trim();
}

function getDevMessage(message) {
  return clean("\n  %ctippy.js\n\n  %c" + clean(message) + "\n\n  %c\uD83D\uDC77\u200D This is a development-only message. It will be removed in production.\n  ");
}

function getFormattedMessage(message) {
  return [getDevMessage(message), // title
  'color: #00C584; font-size: 1.3em; font-weight: bold;', // message
  'line-height: 1.5', // footer
  'color: #a6a095;'];
} // Assume warnings and errors never have the same message

var visitedMessages;

if (true) {
  resetVisitedMessages();
}

function resetVisitedMessages() {
  visitedMessages = new Set();
}
function warnWhen(condition, message) {
  if (condition && !visitedMessages.has(message)) {
    var _console;

    visitedMessages.add(message);

    (_console = console).warn.apply(_console, getFormattedMessage(message));
  }
}
function errorWhen(condition, message) {
  if (condition && !visitedMessages.has(message)) {
    var _console2;

    visitedMessages.add(message);

    (_console2 = console).error.apply(_console2, getFormattedMessage(message));
  }
}
function validateTargets(targets) {
  var didPassFalsyValue = !targets;
  var didPassPlainObject = Object.prototype.toString.call(targets) === '[object Object]' && !targets.addEventListener;
  errorWhen(didPassFalsyValue, ['tippy() was passed', '`' + String(targets) + '`', 'as its targets (first) argument. Valid types are: String, Element,', 'Element[], or NodeList.'].join(' '));
  errorWhen(didPassPlainObject, ['tippy() was passed a plain object which is not supported as an argument', 'for virtual positioning. Use props.getReferenceClientRect instead.'].join(' '));
}

var pluginProps = {
  animateFill: false,
  followCursor: false,
  inlinePositioning: false,
  sticky: false
};
var renderProps = {
  allowHTML: false,
  animation: 'fade',
  arrow: true,
  content: '',
  inertia: false,
  maxWidth: 350,
  role: 'tooltip',
  theme: '',
  zIndex: 9999
};
var defaultProps = Object.assign({
  appendTo: function appendTo() {
    return document.body;
  },
  aria: {
    content: 'auto',
    expanded: 'auto'
  },
  delay: 0,
  duration: [300, 250],
  getReferenceClientRect: null,
  hideOnClick: true,
  ignoreAttributes: false,
  interactive: false,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  moveTransition: '',
  offset: [0, 10],
  onAfterUpdate: function onAfterUpdate() {},
  onBeforeUpdate: function onBeforeUpdate() {},
  onCreate: function onCreate() {},
  onDestroy: function onDestroy() {},
  onHidden: function onHidden() {},
  onHide: function onHide() {},
  onMount: function onMount() {},
  onShow: function onShow() {},
  onShown: function onShown() {},
  onTrigger: function onTrigger() {},
  onUntrigger: function onUntrigger() {},
  onClickOutside: function onClickOutside() {},
  placement: 'top',
  plugins: [],
  popperOptions: {},
  render: null,
  showOnCreate: false,
  touch: true,
  trigger: 'mouseenter focus',
  triggerTarget: null
}, pluginProps, {}, renderProps);
var defaultKeys = Object.keys(defaultProps);
var setDefaultProps = function setDefaultProps(partialProps) {
  /* istanbul ignore else */
  if (true) {
    validateProps(partialProps, []);
  }

  var keys = Object.keys(partialProps);
  keys.forEach(function (key) {
    defaultProps[key] = partialProps[key];
  });
};
function getExtendedPassedProps(passedProps) {
  var plugins = passedProps.plugins || [];
  var pluginProps = plugins.reduce(function (acc, plugin) {
    var name = plugin.name,
        defaultValue = plugin.defaultValue;

    if (name) {
      acc[name] = passedProps[name] !== undefined ? passedProps[name] : defaultValue;
    }

    return acc;
  }, {});
  return Object.assign({}, passedProps, {}, pluginProps);
}
function getDataAttributeProps(reference, plugins) {
  var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
    plugins: plugins
  }))) : defaultKeys;
  var props = propKeys.reduce(function (acc, key) {
    var valueAsString = (reference.getAttribute("data-tippy-" + key) || '').trim();

    if (!valueAsString) {
      return acc;
    }

    if (key === 'content') {
      acc[key] = valueAsString;
    } else {
      try {
        acc[key] = JSON.parse(valueAsString);
      } catch (e) {
        acc[key] = valueAsString;
      }
    }

    return acc;
  }, {});
  return props;
}
function evaluateProps(reference, props) {
  var out = Object.assign({}, props, {
    content: invokeWithArgsOrReturn(props.content, [reference])
  }, props.ignoreAttributes ? {} : getDataAttributeProps(reference, props.plugins));
  out.aria = Object.assign({}, defaultProps.aria, {}, out.aria);
  out.aria = {
    expanded: out.aria.expanded === 'auto' ? props.interactive : out.aria.expanded,
    content: out.aria.content === 'auto' ? props.interactive ? null : 'describedby' : out.aria.content
  };
  return out;
}
function validateProps(partialProps, plugins) {
  if (partialProps === void 0) {
    partialProps = {};
  }

  if (plugins === void 0) {
    plugins = [];
  }

  var keys = Object.keys(partialProps);
  keys.forEach(function (prop) {
    var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));
    var didPassUnknownProp = !hasOwnProperty(nonPluginProps, prop); // Check if the prop exists in `plugins`

    if (didPassUnknownProp) {
      didPassUnknownProp = plugins.filter(function (plugin) {
        return plugin.name === prop;
      }).length === 0;
    }

    warnWhen(didPassUnknownProp, ["`" + prop + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", 'a plugin, forgot to pass it in an array as props.plugins.', '\n\n', 'All props: https://atomiks.github.io/tippyjs/v6/all-props/\n', 'Plugins: https://atomiks.github.io/tippyjs/v6/plugins/'].join(' '));
  });
}

var innerHTML = function innerHTML() {
  return 'innerHTML';
};

function dangerouslySetInnerHTML(element, html) {
  element[innerHTML()] = html;
}

function createArrowElement(value) {
  var arrow = div();

  if (value === true) {
    arrow.className = ARROW_CLASS;
  } else {
    arrow.className = SVG_ARROW_CLASS;

    if (isElement(value)) {
      arrow.appendChild(value);
    } else {
      dangerouslySetInnerHTML(arrow, value);
    }
  }

  return arrow;
}

function setContent(content, props) {
  if (isElement(props.content)) {
    dangerouslySetInnerHTML(content, '');
    content.appendChild(props.content);
  } else if (typeof props.content !== 'function') {
    if (props.allowHTML) {
      dangerouslySetInnerHTML(content, props.content);
    } else {
      content.textContent = props.content;
    }
  }
}
function getChildren(popper) {
  var box = popper.firstElementChild;
  var boxChildren = arrayFrom(box.children);
  return {
    box: box,
    content: boxChildren.find(function (node) {
      return node.classList.contains(CONTENT_CLASS);
    }),
    arrow: boxChildren.find(function (node) {
      return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
    }),
    backdrop: boxChildren.find(function (node) {
      return node.classList.contains(BACKDROP_CLASS);
    })
  };
}
function render(instance) {
  var popper = div();
  var box = div();
  box.className = BOX_CLASS;
  box.setAttribute('data-state', 'hidden');
  box.setAttribute('tabindex', '-1');
  var content = div();
  content.className = CONTENT_CLASS;
  content.setAttribute('data-state', 'hidden');
  setContent(content, instance.props);
  popper.appendChild(box);
  box.appendChild(content);
  onUpdate(instance.props, instance.props);

  function onUpdate(prevProps, nextProps) {
    var _getChildren = getChildren(popper),
        box = _getChildren.box,
        content = _getChildren.content,
        arrow = _getChildren.arrow;

    if (nextProps.theme) {
      box.setAttribute('data-theme', nextProps.theme);
    } else {
      box.removeAttribute('data-theme');
    }

    if (typeof nextProps.animation === 'string') {
      box.setAttribute('data-animation', nextProps.animation);
    } else {
      box.removeAttribute('data-animation');
    }

    if (nextProps.inertia) {
      box.setAttribute('data-inertia', '');
    } else {
      box.removeAttribute('data-inertia');
    }

    box.style.maxWidth = typeof nextProps.maxWidth === 'number' ? nextProps.maxWidth + "px" : nextProps.maxWidth;

    if (nextProps.role) {
      box.setAttribute('role', nextProps.role);
    } else {
      box.removeAttribute('role');
    }

    if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
      setContent(content, instance.props);
    }

    if (nextProps.arrow) {
      if (!arrow) {
        box.appendChild(createArrowElement(nextProps.arrow));
      } else if (prevProps.arrow !== nextProps.arrow) {
        box.removeChild(arrow);
        box.appendChild(createArrowElement(nextProps.arrow));
      }
    } else if (arrow) {
      box.removeChild(arrow);
    }
  }

  return {
    popper: popper,
    onUpdate: onUpdate
  };
} // Runtime check to identify if the render function is the default one; this
// way we can apply default CSS transitions logic and it can be tree-shaken away

render.$$tippy = true;

var idCounter = 1;
var mouseMoveListeners = []; // Used by `hideAll()`

var mountedInstances = [];
function createTippy(reference, passedProps) {
  var props = evaluateProps(reference, Object.assign({}, defaultProps, {}, getExtendedPassedProps(passedProps))); // ===========================================================================
  // 🔒 Private members
  // ===========================================================================

  var showTimeout;
  var hideTimeout;
  var scheduleHideAnimationFrame;
  var isVisibleFromClick = false;
  var didHideDueToDocumentMouseDown = false;
  var didTouchMove = false;
  var ignoreOnFirstUpdate = false;
  var lastTriggerEvent;
  var currentTransitionEndListener;
  var onFirstUpdate;
  var listeners = [];
  var debouncedOnMouseMove = debounce(onMouseMove, props.interactiveDebounce);
  var currentTarget;
  var doc = getOwnerDocument(props.triggerTarget || reference); // ===========================================================================
  // 🔑 Public members
  // ===========================================================================

  var id = idCounter++;
  var popperInstance = null;
  var plugins = unique(props.plugins);
  var state = {
    // Is the instance currently enabled?
    isEnabled: true,
    // Is the tippy currently showing and not transitioning out?
    isVisible: false,
    // Has the instance been destroyed?
    isDestroyed: false,
    // Is the tippy currently mounted to the DOM?
    isMounted: false,
    // Has the tippy finished transitioning in?
    isShown: false
  };
  var instance = {
    // properties
    id: id,
    reference: reference,
    popper: div(),
    popperInstance: popperInstance,
    props: props,
    state: state,
    plugins: plugins,
    // methods
    clearDelayTimeouts: clearDelayTimeouts,
    setProps: setProps,
    setContent: setContent,
    show: show,
    hide: hide,
    hideWithInteractivity: hideWithInteractivity,
    enable: enable,
    disable: disable,
    unmount: unmount,
    destroy: destroy
  }; // TODO: Investigate why this early return causes a TDZ error in the tests —
  // it doesn't seem to happen in the browser

  /* istanbul ignore if */

  if (!props.render) {
    if (true) {
      errorWhen(true, 'render() function has not been supplied.');
    }

    return instance;
  } // ===========================================================================
  // Initial mutations
  // ===========================================================================


  var _props$render = props.render(instance),
      popper = _props$render.popper,
      onUpdate = _props$render.onUpdate;

  popper.setAttribute('data-tippy-root', '');
  popper.id = "tippy-" + instance.id;
  instance.popper = popper;
  reference._tippy = instance;
  popper._tippy = instance;
  var pluginsHooks = plugins.map(function (plugin) {
    return plugin.fn(instance);
  });
  var hasAriaExpanded = reference.hasAttribute('aria-expanded');
  addListeners();
  handleAriaExpandedAttribute();
  handleStyles();
  invokeHook('onCreate', [instance]);

  if (props.showOnCreate) {
    scheduleShow();
  } // Prevent a tippy with a delay from hiding if the cursor left then returned
  // before it started hiding


  popper.addEventListener('mouseenter', function () {
    if (instance.props.interactive && instance.state.isVisible) {
      instance.clearDelayTimeouts();
    }
  });
  popper.addEventListener('mouseleave', function (event) {
    if (instance.props.interactive && instance.props.trigger.indexOf('mouseenter') >= 0) {
      doc.addEventListener('mousemove', debouncedOnMouseMove);
      debouncedOnMouseMove(event);
    }
  });
  return instance; // ===========================================================================
  // 🔒 Private methods
  // ===========================================================================

  function getNormalizedTouchSettings() {
    var touch = instance.props.touch;
    return Array.isArray(touch) ? touch : [touch, 0];
  }

  function getIsCustomTouchBehavior() {
    return getNormalizedTouchSettings()[0] === 'hold';
  }

  function getIsDefaultRenderFn() {
    var _instance$props$rende;

    // @ts-ignore
    return !!((_instance$props$rende = instance.props.render) == null ? void 0 : _instance$props$rende.$$tippy);
  }

  function getCurrentTarget() {
    return currentTarget || reference;
  }

  function getDefaultTemplateChildren() {
    return getChildren(popper);
  }

  function getDelay(isShow) {
    // For touch or keyboard input, force `0` delay for UX reasons
    // Also if the instance is mounted but not visible (transitioning out),
    // ignore delay
    if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === 'focus') {
      return 0;
    }

    return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
  }

  function handleStyles() {
    popper.style.pointerEvents = instance.props.interactive && instance.state.isVisible ? '' : 'none';
    popper.style.zIndex = "" + instance.props.zIndex;
  }

  function invokeHook(hook, args, shouldInvokePropsHook) {
    if (shouldInvokePropsHook === void 0) {
      shouldInvokePropsHook = true;
    }

    pluginsHooks.forEach(function (pluginHooks) {
      if (pluginHooks[hook]) {
        pluginHooks[hook].apply(void 0, args);
      }
    });

    if (shouldInvokePropsHook) {
      var _instance$props;

      (_instance$props = instance.props)[hook].apply(_instance$props, args);
    }
  }

  function handleAriaContentAttribute() {
    var aria = instance.props.aria;

    if (!aria.content) {
      return;
    }

    var attr = "aria-" + aria.content;
    var id = popper.id;
    var nodes = normalizeToArray(instance.props.triggerTarget || reference);
    nodes.forEach(function (node) {
      var currentValue = node.getAttribute(attr);

      if (instance.state.isVisible) {
        node.setAttribute(attr, currentValue ? currentValue + " " + id : id);
      } else {
        var nextValue = currentValue && currentValue.replace(id, '').trim();

        if (nextValue) {
          node.setAttribute(attr, nextValue);
        } else {
          node.removeAttribute(attr);
        }
      }
    });
  }

  function handleAriaExpandedAttribute() {
    if (hasAriaExpanded || !instance.props.aria.expanded) {
      return;
    }

    var nodes = normalizeToArray(instance.props.triggerTarget || reference);
    nodes.forEach(function (node) {
      if (instance.props.interactive) {
        node.setAttribute('aria-expanded', instance.state.isVisible && node === getCurrentTarget() ? 'true' : 'false');
      } else {
        node.removeAttribute('aria-expanded');
      }
    });
  }

  function cleanupInteractiveMouseListeners() {
    doc.body.removeEventListener('mouseleave', scheduleHide);
    doc.removeEventListener('mousemove', debouncedOnMouseMove);
    mouseMoveListeners = mouseMoveListeners.filter(function (listener) {
      return listener !== debouncedOnMouseMove;
    });
  }

  function onDocumentPress(event) {
    // Moved finger to scroll instead of an intentional tap outside
    if (currentInput.isTouch) {
      if (didTouchMove || event.type === 'mousedown') {
        return;
      }
    } // Clicked on interactive popper


    if (instance.props.interactive && popper.contains(event.target)) {
      return;
    } // Clicked on the event listeners target


    if (getCurrentTarget().contains(event.target)) {
      if (currentInput.isTouch) {
        return;
      }

      if (instance.state.isVisible && instance.props.trigger.indexOf('click') >= 0) {
        return;
      }
    } else {
      invokeHook('onClickOutside', [instance, event]);
    }

    if (instance.props.hideOnClick === true) {
      isVisibleFromClick = false;
      instance.clearDelayTimeouts();
      instance.hide(); // `mousedown` event is fired right before `focus` if pressing the
      // currentTarget. This lets a tippy with `focus` trigger know that it
      // should not show

      didHideDueToDocumentMouseDown = true;
      setTimeout(function () {
        didHideDueToDocumentMouseDown = false;
      }); // The listener gets added in `scheduleShow()`, but this may be hiding it
      // before it shows, and hide()'s early bail-out behavior can prevent it
      // from being cleaned up

      if (!instance.state.isMounted) {
        removeDocumentPress();
      }
    }
  }

  function onTouchMove() {
    didTouchMove = true;
  }

  function onTouchStart() {
    didTouchMove = false;
  }

  function addDocumentPress() {
    doc.addEventListener('mousedown', onDocumentPress, true);
    doc.addEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);
    doc.addEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);
    doc.addEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);
  }

  function removeDocumentPress() {
    doc.removeEventListener('mousedown', onDocumentPress, true);
    doc.removeEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);
    doc.removeEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);
    doc.removeEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);
  }

  function onTransitionedOut(duration, callback) {
    onTransitionEnd(duration, function () {
      if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {
        callback();
      }
    });
  }

  function onTransitionedIn(duration, callback) {
    onTransitionEnd(duration, callback);
  }

  function onTransitionEnd(duration, callback) {
    var box = getDefaultTemplateChildren().box;

    function listener(event) {
      if (event.target === box) {
        updateTransitionEndListener(box, 'remove', listener);
        callback();
      }
    } // Make callback synchronous if duration is 0
    // `transitionend` won't fire otherwise


    if (duration === 0) {
      return callback();
    }

    updateTransitionEndListener(box, 'remove', currentTransitionEndListener);
    updateTransitionEndListener(box, 'add', listener);
    currentTransitionEndListener = listener;
  }

  function on(eventType, handler, options) {
    if (options === void 0) {
      options = false;
    }

    var nodes = normalizeToArray(instance.props.triggerTarget || reference);
    nodes.forEach(function (node) {
      node.addEventListener(eventType, handler, options);
      listeners.push({
        node: node,
        eventType: eventType,
        handler: handler,
        options: options
      });
    });
  }

  function addListeners() {
    if (getIsCustomTouchBehavior()) {
      on('touchstart', onTrigger, {
        passive: true
      });
      on('touchend', onMouseLeave, {
        passive: true
      });
    }

    splitBySpaces(instance.props.trigger).forEach(function (eventType) {
      if (eventType === 'manual') {
        return;
      }

      on(eventType, onTrigger);

      switch (eventType) {
        case 'mouseenter':
          on('mouseleave', onMouseLeave);
          break;

        case 'focus':
          on(isIE ? 'focusout' : 'blur', onBlurOrFocusOut);
          break;

        case 'focusin':
          on('focusout', onBlurOrFocusOut);
          break;
      }
    });
  }

  function removeListeners() {
    listeners.forEach(function (_ref) {
      var node = _ref.node,
          eventType = _ref.eventType,
          handler = _ref.handler,
          options = _ref.options;
      node.removeEventListener(eventType, handler, options);
    });
    listeners = [];
  }

  function onTrigger(event) {
    var _lastTriggerEvent;

    var shouldScheduleClickHide = false;

    if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
      return;
    }

    var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === 'focus';
    lastTriggerEvent = event;
    currentTarget = event.currentTarget;
    handleAriaExpandedAttribute();

    if (!instance.state.isVisible && isMouseEvent(event)) {
      // If scrolling, `mouseenter` events can be fired if the cursor lands
      // over a new target, but `mousemove` events don't get fired. This
      // causes interactive tooltips to get stuck open until the cursor is
      // moved
      mouseMoveListeners.forEach(function (listener) {
        return listener(event);
      });
    } // Toggle show/hide when clicking click-triggered tooltips


    if (event.type === 'click' && (instance.props.trigger.indexOf('mouseenter') < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
      shouldScheduleClickHide = true;
    } else {
      scheduleShow(event);
    }

    if (event.type === 'click') {
      isVisibleFromClick = !shouldScheduleClickHide;
    }

    if (shouldScheduleClickHide && !wasFocused) {
      scheduleHide(event);
    }
  }

  function onMouseMove(event) {
    var target = event.target;
    var isCursorOverReferenceOrPopper = reference.contains(target) || popper.contains(target);

    if (event.type === 'mousemove' && isCursorOverReferenceOrPopper) {
      return;
    }

    var popperTreeData = getNestedPopperTree().concat(popper).map(function (popper) {
      var _instance$popperInsta;

      var instance = popper._tippy;
      var state = (_instance$popperInsta = instance.popperInstance) == null ? void 0 : _instance$popperInsta.state;

      if (state) {
        return {
          popperRect: popper.getBoundingClientRect(),
          popperState: state,
          props: props
        };
      }

      return null;
    }).filter(Boolean);

    if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
      cleanupInteractiveMouseListeners();
      scheduleHide(event);
    }
  }

  function onMouseLeave(event) {
    var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf('click') >= 0 && isVisibleFromClick;

    if (shouldBail) {
      return;
    }

    if (instance.props.interactive) {
      instance.hideWithInteractivity(event);
      return;
    }

    scheduleHide(event);
  }

  function onBlurOrFocusOut(event) {
    if (instance.props.trigger.indexOf('focusin') < 0 && event.target !== getCurrentTarget()) {
      return;
    } // If focus was moved to within the popper


    if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {
      return;
    }

    scheduleHide(event);
  }

  function isEventListenerStopped(event) {
    return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf('touch') >= 0 : false;
  }

  function createPopperInstance() {
    destroyPopperInstance();
    var _instance$props2 = instance.props,
        popperOptions = _instance$props2.popperOptions,
        placement = _instance$props2.placement,
        offset = _instance$props2.offset,
        getReferenceClientRect = _instance$props2.getReferenceClientRect,
        moveTransition = _instance$props2.moveTransition;
    var arrow = getIsDefaultRenderFn() ? getChildren(popper).arrow : null;
    var computedReference = getReferenceClientRect ? {
      getBoundingClientRect: getReferenceClientRect,
      contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
    } : reference;
    var tippyModifier = {
      name: '$$tippy',
      enabled: true,
      phase: 'beforeWrite',
      requires: ['computeStyles'],
      fn: function fn(_ref2) {
        var state = _ref2.state;

        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh = getDefaultTemplateChildren(),
              box = _getDefaultTemplateCh.box;

          ['placement', 'reference-hidden', 'escaped'].forEach(function (attr) {
            if (attr === 'placement') {
              box.setAttribute('data-placement', state.placement);
            } else {
              if (state.attributes.popper["data-popper-" + attr]) {
                box.setAttribute("data-" + attr, '');
              } else {
                box.removeAttribute("data-" + attr);
              }
            }
          });
          state.attributes.popper = {};
        }
      }
    };
    var modifiers = [{
      name: 'offset',
      options: {
        offset: offset
      }
    }, {
      name: 'preventOverflow',
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    }, {
      name: 'flip',
      options: {
        padding: 5
      }
    }, {
      name: 'computeStyles',
      options: {
        adaptive: !moveTransition
      }
    }, tippyModifier];

    if (getIsDefaultRenderFn() && arrow) {
      modifiers.push({
        name: 'arrow',
        options: {
          element: arrow,
          padding: 3
        }
      });
    }

    modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
    instance.popperInstance = (0,_popperjs_core__WEBPACK_IMPORTED_MODULE_0__.createPopper)(computedReference, popper, Object.assign({}, popperOptions, {
      placement: placement,
      onFirstUpdate: onFirstUpdate,
      modifiers: modifiers
    }));
  }

  function destroyPopperInstance() {
    if (instance.popperInstance) {
      instance.popperInstance.destroy();
      instance.popperInstance = null;
    }
  }

  function mount() {
    var appendTo = instance.props.appendTo;
    var parentNode; // By default, we'll append the popper to the triggerTargets's parentNode so
    // it's directly after the reference element so the elements inside the
    // tippy can be tabbed to
    // If there are clipping issues, the user can specify a different appendTo
    // and ensure focus management is handled correctly manually

    var node = getCurrentTarget();

    if (instance.props.interactive && appendTo === defaultProps.appendTo || appendTo === 'parent') {
      parentNode = node.parentNode;
    } else {
      parentNode = invokeWithArgsOrReturn(appendTo, [node]);
    } // The popper element needs to exist on the DOM before its position can be
    // updated as Popper needs to read its dimensions


    if (!parentNode.contains(popper)) {
      parentNode.appendChild(popper);
    }

    createPopperInstance();
    /* istanbul ignore else */

    if (true) {
      // Accessibility check
      warnWhen(instance.props.interactive && appendTo === defaultProps.appendTo && node.nextElementSibling !== popper, ['Interactive tippy element may not be accessible via keyboard', 'navigation because it is not directly after the reference element', 'in the DOM source order.', '\n\n', 'Using a wrapper <div> or <span> tag around the reference element', 'solves this by creating a new parentNode context.', '\n\n', 'Specifying `appendTo: document.body` silences this warning, but it', 'assumes you are using a focus management solution to handle', 'keyboard navigation.', '\n\n', 'See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity'].join(' '));
    }
  }

  function getNestedPopperTree() {
    return arrayFrom(popper.querySelectorAll('[data-tippy-root]'));
  }

  function scheduleShow(event) {
    instance.clearDelayTimeouts();

    if (event) {
      invokeHook('onTrigger', [instance, event]);
    }

    addDocumentPress();
    var delay = getDelay(true);

    var _getNormalizedTouchSe = getNormalizedTouchSettings(),
        touchValue = _getNormalizedTouchSe[0],
        touchDelay = _getNormalizedTouchSe[1];

    if (currentInput.isTouch && touchValue === 'hold' && touchDelay) {
      delay = touchDelay;
    }

    if (delay) {
      showTimeout = setTimeout(function () {
        instance.show();
      }, delay);
    } else {
      instance.show();
    }
  }

  function scheduleHide(event) {
    instance.clearDelayTimeouts();
    invokeHook('onUntrigger', [instance, event]);

    if (!instance.state.isVisible) {
      removeDocumentPress();
      return;
    } // For interactive tippies, scheduleHide is added to a document.body handler
    // from onMouseLeave so must intercept scheduled hides from mousemove/leave
    // events when trigger contains mouseenter and click, and the tip is
    // currently shown as a result of a click.


    if (instance.props.trigger.indexOf('mouseenter') >= 0 && instance.props.trigger.indexOf('click') >= 0 && ['mouseleave', 'mousemove'].indexOf(event.type) >= 0 && isVisibleFromClick) {
      return;
    }

    var delay = getDelay(false);

    if (delay) {
      hideTimeout = setTimeout(function () {
        if (instance.state.isVisible) {
          instance.hide();
        }
      }, delay);
    } else {
      // Fixes a `transitionend` problem when it fires 1 frame too
      // late sometimes, we don't want hide() to be called.
      scheduleHideAnimationFrame = requestAnimationFrame(function () {
        instance.hide();
      });
    }
  } // ===========================================================================
  // 🔑 Public methods
  // ===========================================================================


  function enable() {
    instance.state.isEnabled = true;
  }

  function disable() {
    // Disabling the instance should also hide it
    // https://github.com/atomiks/tippy.js-react/issues/106
    instance.hide();
    instance.state.isEnabled = false;
  }

  function clearDelayTimeouts() {
    clearTimeout(showTimeout);
    clearTimeout(hideTimeout);
    cancelAnimationFrame(scheduleHideAnimationFrame);
  }

  function setProps(partialProps) {
    /* istanbul ignore else */
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('setProps'));
    }

    if (instance.state.isDestroyed) {
      return;
    }

    invokeHook('onBeforeUpdate', [instance, partialProps]);
    removeListeners();
    var prevProps = instance.props;
    var nextProps = evaluateProps(reference, Object.assign({}, instance.props, {}, partialProps, {
      ignoreAttributes: true
    }));
    instance.props = nextProps;
    addListeners();

    if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
      cleanupInteractiveMouseListeners();
      debouncedOnMouseMove = debounce(onMouseMove, nextProps.interactiveDebounce);
    } // Ensure stale aria-expanded attributes are removed


    if (prevProps.triggerTarget && !nextProps.triggerTarget) {
      normalizeToArray(prevProps.triggerTarget).forEach(function (node) {
        node.removeAttribute('aria-expanded');
      });
    } else if (nextProps.triggerTarget) {
      reference.removeAttribute('aria-expanded');
    }

    handleAriaExpandedAttribute();
    handleStyles();

    if (onUpdate) {
      onUpdate(prevProps, nextProps);
    }

    if (instance.popperInstance) {
      createPopperInstance(); // Fixes an issue with nested tippies if they are all getting re-rendered,
      // and the nested ones get re-rendered first.
      // https://github.com/atomiks/tippyjs-react/issues/177
      // TODO: find a cleaner / more efficient solution(!)

      getNestedPopperTree().forEach(function (nestedPopper) {
        // React (and other UI libs likely) requires a rAF wrapper as it flushes
        // its work in one
        requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
      });
    }

    invokeHook('onAfterUpdate', [instance, partialProps]);
  }

  function setContent(content) {
    instance.setProps({
      content: content
    });
  }

  function show() {
    /* istanbul ignore else */
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('show'));
    } // Early bail-out


    var isAlreadyVisible = instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
    var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);

    if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
      return;
    } // Normalize `disabled` behavior across browsers.
    // Firefox allows events on disabled elements, but Chrome doesn't.
    // Using a wrapper element (i.e. <span>) is recommended.


    if (getCurrentTarget().hasAttribute('disabled')) {
      return;
    }

    invokeHook('onShow', [instance], false);

    if (instance.props.onShow(instance) === false) {
      return;
    }

    instance.state.isVisible = true;

    if (getIsDefaultRenderFn()) {
      popper.style.visibility = 'visible';
    }

    handleStyles();
    addDocumentPress();

    if (!instance.state.isMounted) {
      popper.style.transition = 'none';
    } // If flipping to the opposite side after hiding at least once, the
    // animation will use the wrong placement without resetting the duration


    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh2 = getDefaultTemplateChildren(),
          box = _getDefaultTemplateCh2.box,
          content = _getDefaultTemplateCh2.content;

      setTransitionDuration([box, content], 0);
    }

    onFirstUpdate = function onFirstUpdate() {
      if (!instance.state.isVisible || ignoreOnFirstUpdate) {
        return;
      }

      ignoreOnFirstUpdate = true; // reflow

      void popper.offsetHeight;
      popper.style.transition = instance.props.moveTransition;

      if (getIsDefaultRenderFn() && instance.props.animation) {
        var _getDefaultTemplateCh3 = getDefaultTemplateChildren(),
            _box = _getDefaultTemplateCh3.box,
            _content = _getDefaultTemplateCh3.content;

        setTransitionDuration([_box, _content], duration);
        setVisibilityState([_box, _content], 'visible');
      }

      handleAriaContentAttribute();
      handleAriaExpandedAttribute();
      pushIfUnique(mountedInstances, instance);
      instance.state.isMounted = true;
      invokeHook('onMount', [instance]);

      if (instance.props.animation && getIsDefaultRenderFn()) {
        onTransitionedIn(duration, function () {
          instance.state.isShown = true;
          invokeHook('onShown', [instance]);
        });
      }
    };

    mount();
  }

  function hide() {
    /* istanbul ignore else */
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('hide'));
    } // Early bail-out


    var isAlreadyHidden = !instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);

    if (isAlreadyHidden || isDestroyed || isDisabled) {
      return;
    }

    invokeHook('onHide', [instance], false);

    if (instance.props.onHide(instance) === false) {
      return;
    }

    instance.state.isVisible = false;
    instance.state.isShown = false;
    ignoreOnFirstUpdate = false;

    if (getIsDefaultRenderFn()) {
      popper.style.visibility = 'hidden';
    }

    cleanupInteractiveMouseListeners();
    removeDocumentPress();
    handleStyles();

    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh4 = getDefaultTemplateChildren(),
          box = _getDefaultTemplateCh4.box,
          content = _getDefaultTemplateCh4.content;

      if (instance.props.animation) {
        setTransitionDuration([box, content], duration);
        setVisibilityState([box, content], 'hidden');
      }
    }

    handleAriaContentAttribute();
    handleAriaExpandedAttribute();

    if (instance.props.animation) {
      if (getIsDefaultRenderFn()) {
        onTransitionedOut(duration, instance.unmount);
      }
    } else {
      instance.unmount();
    }
  }

  function hideWithInteractivity(event) {
    /* istanbul ignore else */
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('hideWithInteractivity'));
    }

    doc.body.addEventListener('mouseleave', scheduleHide);
    doc.addEventListener('mousemove', debouncedOnMouseMove);
    pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
    debouncedOnMouseMove(event);
  }

  function unmount() {
    /* istanbul ignore else */
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('unmount'));
    }

    if (instance.state.isVisible) {
      instance.hide();
    }

    if (!instance.state.isMounted) {
      return;
    }

    destroyPopperInstance(); // If a popper is not interactive, it will be appended outside the popper
    // tree by default. This seems mainly for interactive tippies, but we should
    // find a workaround if possible

    getNestedPopperTree().forEach(function (nestedPopper) {
      nestedPopper._tippy.unmount();
    });

    if (popper.parentNode) {
      popper.parentNode.removeChild(popper);
    }

    mountedInstances = mountedInstances.filter(function (i) {
      return i !== instance;
    });
    instance.state.isMounted = false;
    invokeHook('onHidden', [instance]);
  }

  function destroy() {
    /* istanbul ignore else */
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('destroy'));
    }

    if (instance.state.isDestroyed) {
      return;
    }

    instance.clearDelayTimeouts();
    instance.unmount();
    removeListeners();
    delete reference._tippy;
    instance.state.isDestroyed = true;
    invokeHook('onDestroy', [instance]);
  }
}

function tippy(targets, optionalProps) {
  if (optionalProps === void 0) {
    optionalProps = {};
  }

  var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);
  /* istanbul ignore else */

  if (true) {
    validateTargets(targets);
    validateProps(optionalProps, plugins);
  }

  bindGlobalEventListeners();
  var passedProps = Object.assign({}, optionalProps, {
    plugins: plugins
  });
  var elements = getArrayOfElements(targets);
  /* istanbul ignore else */

  if (true) {
    var isSingleContentElement = isElement(passedProps.content);
    var isMoreThanOneReferenceElement = elements.length > 1;
    warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, ['tippy() was passed an Element as the `content` prop, but more than', 'one tippy instance was created by this invocation. This means the', 'content element will only be appended to the last tippy instance.', '\n\n', 'Instead, pass the .innerHTML of the element, or use a function that', 'returns a cloned version of the element instead.', '\n\n', '1) content: element.innerHTML\n', '2) content: () => element.cloneNode(true)'].join(' '));
  }

  var instances = elements.reduce(function (acc, reference) {
    var instance = reference && createTippy(reference, passedProps);

    if (instance) {
      acc.push(instance);
    }

    return acc;
  }, []);
  return isElement(targets) ? instances[0] : instances;
}

tippy.defaultProps = defaultProps;
tippy.setDefaultProps = setDefaultProps;
tippy.currentInput = currentInput;
var hideAll = function hideAll(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      excludedReferenceOrInstance = _ref.exclude,
      duration = _ref.duration;

  mountedInstances.forEach(function (instance) {
    var isExcluded = false;

    if (excludedReferenceOrInstance) {
      isExcluded = isReferenceElement(excludedReferenceOrInstance) ? instance.reference === excludedReferenceOrInstance : instance.popper === excludedReferenceOrInstance.popper;
    }

    if (!isExcluded) {
      var originalDuration = instance.props.duration;
      instance.setProps({
        duration: duration
      });
      instance.hide();

      if (!instance.state.isDestroyed) {
        instance.setProps({
          duration: originalDuration
        });
      }
    }
  });
};

var createSingleton = function createSingleton(tippyInstances, optionalProps) {
  if (optionalProps === void 0) {
    optionalProps = {};
  }

  /* istanbul ignore else */
  if (true) {
    errorWhen(!Array.isArray(tippyInstances), ['The first argument passed to createSingleton() must be an array of', 'tippy instances. The passed value was', String(tippyInstances)].join(' '));
  }

  var mutTippyInstances = tippyInstances;
  var references = [];
  var currentTarget;
  var overrides = optionalProps.overrides;

  function setReferences() {
    references = mutTippyInstances.map(function (instance) {
      return instance.reference;
    });
  }

  function enableInstances(isEnabled) {
    mutTippyInstances.forEach(function (instance) {
      if (isEnabled) {
        instance.enable();
      } else {
        instance.disable();
      }
    });
  }

  enableInstances(false);
  setReferences();
  var singleton = {
    fn: function fn() {
      return {
        onDestroy: function onDestroy() {
          enableInstances(true);
        },
        onTrigger: function onTrigger(instance, event) {
          var target = event.currentTarget;
          var index = references.indexOf(target); // bail-out

          if (target === currentTarget) {
            return;
          }

          currentTarget = target;
          var overrideProps = (overrides || []).concat('content').reduce(function (acc, prop) {
            acc[prop] = mutTippyInstances[index].props[prop];
            return acc;
          }, {});
          instance.setProps(Object.assign({}, overrideProps, {
            getReferenceClientRect: function getReferenceClientRect() {
              return target.getBoundingClientRect();
            }
          }));
        }
      };
    }
  };
  var instance = tippy(div(), Object.assign({}, removeProperties(optionalProps, ['overrides']), {
    plugins: [singleton].concat(optionalProps.plugins || []),
    triggerTarget: references
  }));
  var originalSetProps = instance.setProps;

  instance.setProps = function (props) {
    overrides = props.overrides || overrides;
    originalSetProps(props);
  };

  instance.setInstances = function (nextInstances) {
    enableInstances(true);
    mutTippyInstances = nextInstances;
    enableInstances(false);
    setReferences();
    instance.setProps({
      triggerTarget: references
    });
  };

  return instance;
};

var BUBBLING_EVENTS_MAP = {
  mouseover: 'mouseenter',
  focusin: 'focus',
  click: 'click'
};
/**
 * Creates a delegate instance that controls the creation of tippy instances
 * for child elements (`target` CSS selector).
 */

function delegate(targets, props) {
  /* istanbul ignore else */
  if (true) {
    errorWhen(!(props && props.target), ['You must specity a `target` prop indicating a CSS selector string matching', 'the target elements that should receive a tippy.'].join(' '));
  }

  var listeners = [];
  var childTippyInstances = [];
  var target = props.target;
  var nativeProps = removeProperties(props, ['target']);
  var parentProps = Object.assign({}, nativeProps, {
    trigger: 'manual',
    touch: false
  });
  var childProps = Object.assign({}, nativeProps, {
    showOnCreate: true
  });
  var returnValue = tippy(targets, parentProps);
  var normalizedReturnValue = normalizeToArray(returnValue);

  function onTrigger(event) {
    if (!event.target) {
      return;
    }

    var targetNode = event.target.closest(target);

    if (!targetNode) {
      return;
    } // Get relevant trigger with fallbacks:
    // 1. Check `data-tippy-trigger` attribute on target node
    // 2. Fallback to `trigger` passed to `delegate()`
    // 3. Fallback to `defaultProps.trigger`


    var trigger = targetNode.getAttribute('data-tippy-trigger') || props.trigger || defaultProps.trigger; // @ts-ignore

    if (targetNode._tippy) {
      return;
    }

    if (event.type === 'touchstart' && typeof childProps.touch === 'boolean') {
      return;
    }

    if (event.type !== 'touchstart' && trigger.indexOf(BUBBLING_EVENTS_MAP[event.type])) {
      return;
    }

    var instance = tippy(targetNode, childProps);

    if (instance) {
      childTippyInstances = childTippyInstances.concat(instance);
    }
  }

  function on(node, eventType, handler, options) {
    if (options === void 0) {
      options = false;
    }

    node.addEventListener(eventType, handler, options);
    listeners.push({
      node: node,
      eventType: eventType,
      handler: handler,
      options: options
    });
  }

  function addEventListeners(instance) {
    var reference = instance.reference;
    on(reference, 'touchstart', onTrigger);
    on(reference, 'mouseover', onTrigger);
    on(reference, 'focusin', onTrigger);
    on(reference, 'click', onTrigger);
  }

  function removeEventListeners() {
    listeners.forEach(function (_ref) {
      var node = _ref.node,
          eventType = _ref.eventType,
          handler = _ref.handler,
          options = _ref.options;
      node.removeEventListener(eventType, handler, options);
    });
    listeners = [];
  }

  function applyMutations(instance) {
    var originalDestroy = instance.destroy;

    instance.destroy = function (shouldDestroyChildInstances) {
      if (shouldDestroyChildInstances === void 0) {
        shouldDestroyChildInstances = true;
      }

      if (shouldDestroyChildInstances) {
        childTippyInstances.forEach(function (instance) {
          instance.destroy();
        });
      }

      childTippyInstances = [];
      removeEventListeners();
      originalDestroy();
    };

    addEventListeners(instance);
  }

  normalizedReturnValue.forEach(applyMutations);
  return returnValue;
}

var animateFill = {
  name: 'animateFill',
  defaultValue: false,
  fn: function fn(instance) {
    var _instance$props$rende;

    // @ts-ignore
    if (!((_instance$props$rende = instance.props.render) == null ? void 0 : _instance$props$rende.$$tippy)) {
      if (true) {
        errorWhen(instance.props.animateFill, 'The `animateFill` plugin requires the default render function.');
      }

      return {};
    }

    var _getChildren = getChildren(instance.popper),
        box = _getChildren.box,
        content = _getChildren.content;

    var backdrop = instance.props.animateFill ? createBackdropElement() : null;
    return {
      onCreate: function onCreate() {
        if (backdrop) {
          box.insertBefore(backdrop, box.firstElementChild);
          box.setAttribute('data-animatefill', '');
          box.style.overflow = 'hidden';
          instance.setProps({
            arrow: false,
            animation: 'shift-away'
          });
        }
      },
      onMount: function onMount() {
        if (backdrop) {
          var transitionDuration = box.style.transitionDuration;
          var duration = Number(transitionDuration.replace('ms', '')); // The content should fade in after the backdrop has mostly filled the
          // tooltip element. `clip-path` is the other alternative but is not
          // well-supported and is buggy on some devices.

          content.style.transitionDelay = Math.round(duration / 10) + "ms";
          backdrop.style.transitionDuration = transitionDuration;
          setVisibilityState([backdrop], 'visible');
        }
      },
      onShow: function onShow() {
        if (backdrop) {
          backdrop.style.transitionDuration = '0ms';
        }
      },
      onHide: function onHide() {
        if (backdrop) {
          setVisibilityState([backdrop], 'hidden');
        }
      }
    };
  }
};

function createBackdropElement() {
  var backdrop = div();
  backdrop.className = BACKDROP_CLASS;
  setVisibilityState([backdrop], 'hidden');
  return backdrop;
}

var followCursor = {
  name: 'followCursor',
  defaultValue: false,
  fn: function fn(instance) {
    var reference = instance.reference;
    var doc = getOwnerDocument(instance.props.triggerTarget || reference);
    var initialMouseCoords = null;

    function getIsManual() {
      return instance.props.trigger.trim() === 'manual';
    }

    function getIsEnabled() {
      // #597
      var isValidMouseEvent = getIsManual() ? true : // Check if a keyboard "click"
      initialMouseCoords !== null && !(initialMouseCoords.clientX === 0 && initialMouseCoords.clientY === 0);
      return instance.props.followCursor && isValidMouseEvent;
    }

    function getIsInitialBehavior() {
      return currentInput.isTouch || instance.props.followCursor === 'initial' && instance.state.isVisible;
    }

    function unsetReferenceClientRect(shouldUnset) {
      if (shouldUnset) {
        instance.setProps({
          getReferenceClientRect: null
        });
      }
    }

    function handleMouseMoveListener() {
      if (getIsEnabled()) {
        addListener();
      } else {
        unsetReferenceClientRect(instance.props.followCursor);
      }
    }

    function triggerLastMouseMove() {
      if (getIsEnabled()) {
        onMouseMove(initialMouseCoords);
      }
    }

    function addListener() {
      doc.addEventListener('mousemove', onMouseMove);
    }

    function removeListener() {
      doc.removeEventListener('mousemove', onMouseMove);
    }

    function onMouseMove(event) {
      initialMouseCoords = {
        clientX: event.clientX,
        clientY: event.clientY
      }; // If the instance is interactive, avoid updating the position unless it's
      // over the reference element

      var isCursorOverReference = event.target ? reference.contains(event.target) : true;
      var followCursor = instance.props.followCursor;
      var clientX = event.clientX,
          clientY = event.clientY;
      var rect = reference.getBoundingClientRect();
      var relativeX = clientX - rect.left;
      var relativeY = clientY - rect.top;

      if (isCursorOverReference || !instance.props.interactive) {
        instance.setProps({
          getReferenceClientRect: function getReferenceClientRect() {
            var rect = reference.getBoundingClientRect();
            var x = clientX;
            var y = clientY;

            if (followCursor === 'initial') {
              x = rect.left + relativeX;
              y = rect.top + relativeY;
            }

            var top = followCursor === 'horizontal' ? rect.top : y;
            var right = followCursor === 'vertical' ? rect.right : x;
            var bottom = followCursor === 'horizontal' ? rect.bottom : y;
            var left = followCursor === 'vertical' ? rect.left : x;
            return {
              width: right - left,
              height: bottom - top,
              top: top,
              right: right,
              bottom: bottom,
              left: left
            };
          }
        });
      }

      if (getIsInitialBehavior()) {
        removeListener();
      }
    }

    return {
      onAfterUpdate: function onAfterUpdate(_, _ref) {
        var followCursor = _ref.followCursor;

        if (followCursor !== undefined && !followCursor) {
          unsetReferenceClientRect(true);
        }
      },
      onMount: function onMount() {
        triggerLastMouseMove();
      },
      onShow: function onShow() {
        if (getIsManual()) {
          // Since there's no trigger event to use, we have to use these as
          // baseline coords
          initialMouseCoords = {
            clientX: 0,
            clientY: 0
          };
          handleMouseMoveListener();
        }
      },
      onTrigger: function onTrigger(_, event) {
        // Tapping on touch devices can trigger `mouseenter` then `focus`
        if (initialMouseCoords) {
          return;
        }

        if (isMouseEvent(event)) {
          initialMouseCoords = {
            clientX: event.clientX,
            clientY: event.clientY
          };
        }

        handleMouseMoveListener();
      },
      onUntrigger: function onUntrigger() {
        // If untriggered before showing (`onHidden` will never be invoked)
        if (!instance.state.isVisible) {
          removeListener();
          initialMouseCoords = null;
        }
      },
      onHidden: function onHidden() {
        removeListener();
        initialMouseCoords = null;
      }
    };
  }
};

function getProps(props, modifier) {
  var _props$popperOptions;

  return {
    popperOptions: Object.assign({}, props.popperOptions, {
      modifiers: [].concat((((_props$popperOptions = props.popperOptions) == null ? void 0 : _props$popperOptions.modifiers) || []).filter(function (_ref) {
        var name = _ref.name;
        return name !== modifier.name;
      }), [modifier])
    })
  };
}

var inlinePositioning = {
  name: 'inlinePositioning',
  defaultValue: false,
  fn: function fn(instance) {
    var reference = instance.reference;

    function isEnabled() {
      return !!instance.props.inlinePositioning;
    }

    var placement;
    var cursorRectIndex = -1;
    var isInternalUpdate = false;
    var modifier = {
      name: 'tippyInlinePositioning',
      enabled: true,
      phase: 'afterWrite',
      fn: function fn(_ref2) {
        var state = _ref2.state;

        if (isEnabled()) {
          if (placement !== state.placement) {
            instance.setProps({
              getReferenceClientRect: function getReferenceClientRect() {
                return _getReferenceClientRect(state.placement);
              }
            });
          }

          placement = state.placement;
        }
      }
    };

    function _getReferenceClientRect(placement) {
      return getInlineBoundingClientRect(getBasePlacement(placement), reference.getBoundingClientRect(), arrayFrom(reference.getClientRects()), cursorRectIndex);
    }

    function setInternalProps(partialProps) {
      isInternalUpdate = true;
      instance.setProps(partialProps);
      isInternalUpdate = false;
    }

    function addModifier() {
      if (!isInternalUpdate) {
        setInternalProps(getProps(instance.props, modifier));
      }
    }

    return {
      onCreate: addModifier,
      onAfterUpdate: addModifier,
      onTrigger: function onTrigger(_, event) {
        if (isMouseEvent(event)) {
          var rects = arrayFrom(instance.reference.getClientRects());
          var cursorRect = rects.find(function (rect) {
            return rect.left - 2 <= event.clientX && rect.right + 2 >= event.clientX && rect.top - 2 <= event.clientY && rect.bottom + 2 >= event.clientY;
          });
          cursorRectIndex = rects.indexOf(cursorRect);
        }
      },
      onUntrigger: function onUntrigger() {
        cursorRectIndex = -1;
      }
    };
  }
};
function getInlineBoundingClientRect(currentBasePlacement, boundingRect, clientRects, cursorRectIndex) {
  // Not an inline element, or placement is not yet known
  if (clientRects.length < 2 || currentBasePlacement === null) {
    return boundingRect;
  } // There are two rects and they are disjoined


  if (clientRects.length === 2 && cursorRectIndex >= 0 && clientRects[0].left > clientRects[1].right) {
    return clientRects[cursorRectIndex] || boundingRect;
  }

  switch (currentBasePlacement) {
    case 'top':
    case 'bottom':
      {
        var firstRect = clientRects[0];
        var lastRect = clientRects[clientRects.length - 1];
        var isTop = currentBasePlacement === 'top';
        var top = firstRect.top;
        var bottom = lastRect.bottom;
        var left = isTop ? firstRect.left : lastRect.left;
        var right = isTop ? firstRect.right : lastRect.right;
        var width = right - left;
        var height = bottom - top;
        return {
          top: top,
          bottom: bottom,
          left: left,
          right: right,
          width: width,
          height: height
        };
      }

    case 'left':
    case 'right':
      {
        var minLeft = Math.min.apply(Math, clientRects.map(function (rects) {
          return rects.left;
        }));
        var maxRight = Math.max.apply(Math, clientRects.map(function (rects) {
          return rects.right;
        }));
        var measureRects = clientRects.filter(function (rect) {
          return currentBasePlacement === 'left' ? rect.left === minLeft : rect.right === maxRight;
        });
        var _top = measureRects[0].top;
        var _bottom = measureRects[measureRects.length - 1].bottom;
        var _left = minLeft;
        var _right = maxRight;

        var _width = _right - _left;

        var _height = _bottom - _top;

        return {
          top: _top,
          bottom: _bottom,
          left: _left,
          right: _right,
          width: _width,
          height: _height
        };
      }

    default:
      {
        return boundingRect;
      }
  }
}

var sticky = {
  name: 'sticky',
  defaultValue: false,
  fn: function fn(instance) {
    var reference = instance.reference,
        popper = instance.popper;

    function getReference() {
      return instance.popperInstance ? instance.popperInstance.state.elements.reference : reference;
    }

    function shouldCheck(value) {
      return instance.props.sticky === true || instance.props.sticky === value;
    }

    var prevRefRect = null;
    var prevPopRect = null;

    function updatePosition() {
      var currentRefRect = shouldCheck('reference') ? getReference().getBoundingClientRect() : null;
      var currentPopRect = shouldCheck('popper') ? popper.getBoundingClientRect() : null;

      if (currentRefRect && areRectsDifferent(prevRefRect, currentRefRect) || currentPopRect && areRectsDifferent(prevPopRect, currentPopRect)) {
        if (instance.popperInstance) {
          instance.popperInstance.update();
        }
      }

      prevRefRect = currentRefRect;
      prevPopRect = currentPopRect;

      if (instance.state.isMounted) {
        requestAnimationFrame(updatePosition);
      }
    }

    return {
      onMount: function onMount() {
        if (instance.props.sticky) {
          updatePosition();
        }
      }
    };
  }
};

function areRectsDifferent(rectA, rectB) {
  if (rectA && rectB) {
    return rectA.top !== rectB.top || rectA.right !== rectB.right || rectA.bottom !== rectB.bottom || rectA.left !== rectB.left;
  }

  return true;
}

tippy.setDefaultProps({
  render: render
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (tippy);

//# sourceMappingURL=tippy.esm.js.map


/***/ }),

/***/ "../structured-text-editor/node_modules/uuid/lib/bytesToUuid.js":
/*!**********************************************************************!*\
  !*** ../structured-text-editor/node_modules/uuid/lib/bytesToUuid.js ***!
  \**********************************************************************/
/***/ ((module) => {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([bth[buf[i++]], bth[buf[i++]], 
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]]]).join('');
}

module.exports = bytesToUuid;


/***/ }),

/***/ "../structured-text-editor/node_modules/uuid/lib/rng-browser.js":
/*!**********************************************************************!*\
  !*** ../structured-text-editor/node_modules/uuid/lib/rng-browser.js ***!
  \**********************************************************************/
/***/ ((module) => {

// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}


/***/ }),

/***/ "../structured-text-editor/node_modules/uuid/v1.js":
/*!*********************************************************!*\
  !*** ../structured-text-editor/node_modules/uuid/v1.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var rng = __webpack_require__(/*! ./lib/rng */ "../structured-text-editor/node_modules/uuid/lib/rng-browser.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "../structured-text-editor/node_modules/uuid/lib/bytesToUuid.js");

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;
var _clockseq;

// Previous uuid creation time
var _lastMSecs = 0;
var _lastNSecs = 0;

// See https://github.com/broofa/node-uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189
  if (node == null || clockseq == null) {
    var seedBytes = rng();
    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [
        seedBytes[0] | 0x01,
        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]
      ];
    }
    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  }

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid(b);
}

module.exports = v1;


/***/ }),

/***/ "../structured-text-editor/src/caret.js":
/*!**********************************************!*\
  !*** ../structured-text-editor/src/caret.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../lib/pixelschubser/utils */ "../structured-text-editor/lib/pixelschubser/utils.js");

var Caret = function(editor) {
    var self = this;
    this.editor = editor;
    this.selectionchangeSubscribers = [];

    document.addEventListener('selectionchange', function(e) {
        var selection = window.getSelection();

        if(self._isSelectionProcessed(selection)) {
            self._markSelectionAsProcessed(selection)
            for(let i=0; i<self.selectionchangeSubscribers.length; i++) {
                self.selectionchangeSubscribers[i](selection);
            }
        }
    });
}

Caret.prototype = {

    subscribeSelectionChange: function(f) {
        this.selectionchangeSubscribers.push(f);
    },

    _markSelectionAsProcessed: function(selection) {
        this.lastProcessedSelectionChange = {
            anchorNode: selection.anchorNode,
            anchorOffset: selection.anchorOffset,
            focusNode: selection.focusNode,
            focusOffset: selection.focusOffset
        };
    },

    _isSelectionProcessed: function(selection) {
      return this.lastProcessedSelectionChange === undefined ||
             this.lastProcessedSelectionChange.anchorNode !==  selection.anchorNode ||
             this.lastProcessedSelectionChange.anchorOffset !==  selection.anchorOffset ||
             this.lastProcessedSelectionChange.focusNode !==  selection.focusNode ||
             this.lastProcessedSelectionChange.focusOffset !==  selection.focusOffset
    },

    _getElementsContentLengthIncrement: function(element) {
        if(['BR', 'IMG'].includes(element.tagName)) return 1;

        if(element && element.classList && element.classList.contains('toc-content')) return 0;
        if(element && element.classList && element.classList.contains('missingLevelHint')) return 0;

        if(element.tagName === 'LI' && element.innerText === '') return 1;
        if(element.getAttribute && element.getAttribute('contenteditable') === 'false') return 1;
        if(this.withinUnedidableReferenceEl(element)) return 0;

        if(['CAPTION', 'FIGCAPTION', 'CITESRC'].includes(element.tagName) && (element.children && element.children.length) === 0) { //Fixme: Should it not be childNodes instead of children
            return 1;
        }

        if(!element.length) return 0;
        return element.length;
    },

    // example Input:  "test<span class="footnote" data-note="note number 11" contenteditable="false">11</span> the editor interface to restoreX selection"
    // example Output: "test_ the editor interface to restoreX selection"
    // -> because we cannot place the caret within the footnote (or reference, inline equation, toc section)
    // we replace the footenote with one placeholder char.
    _getContentLengthIncrementMaskedText: function(rootElement) {
        var result = '';


        if(rootElement.length && rootElement.textContent) {
            return rootElement.textContent;
        }

        rootElement.childNodes.forEach(element => {
            if(['BR', 'IMG'].includes(element.tagName)) { result += '_'; }
            else if(element && element.classList && element.classList.contains('toc-content')) { result += ''; }
            else if(element && element.classList && element.classList.contains('missingLevelHint')) { result += ''; }
            else if(element.tagName === 'LI' && element.innerText === '') { result += '_'; }
            else if(element.getAttribute && element.getAttribute('contenteditable') === 'false') { result += '_'; }
            else if(this.withinUnedidableReferenceEl(element)) { result += ''; }

            else if(['CAPTION', 'FIGCAPTION', 'CITESRC'].includes(element.tagName) && (element.childNodes && element.childNodes.length) === 0) {
                result += '_';
            }
            else {
                result += this._getContentLengthIncrementMaskedText(element);
            }
        })

        return result;
    },

    _getContentLengthOfDOMElement: function(element, endChild) {
        if(!endChild && element.summarizedContentLength) {
            return element.summarizedContentLength;
        }

        var endSection = endChild && utils.getSubtreeByChildNode(element, endChild),
            endSectionIndex = endSection && element.children.indexOf(endSection),
            treeWalker = document.createTreeWalker(endSection || element),
            length = 0,
            currentEl;

        if(endSection) {
            for(var i=0; i<endSectionIndex; i++) {
                length += this._getContentLengthOfDOMElement(element.children[i])
            }
        }

        while((currentEl = treeWalker.currentNode)) {
            if(currentEl === endChild) return length;
            length += this._getElementsContentLengthIncrement(currentEl);

            if(!treeWalker.nextNode()) break;
        }

        if(!endChild) {
            element.summarizedContentLength = length;
        }

        return length;
    },

    _walkToNextEditableNode: function(treeWalker) {
        var candidte = treeWalker.nextNode();
        if(!candidte) { return candidte }

        while(this.withinUnedidableReferenceEl(candidte)) {
            candidte = treeWalker.nextNode();
            if(!candidte) { return candidte }
        }

        return candidte;
    },

    // rightMatch: when root element contains: '<p>Hello</p><p>World</p>' and contentLength is '5'
    //             it is not clear which element to return, if rightMatch is true then '<p>World</p>' will
    //             be returned, '<p>Hello</p>' otherwise
    _getElementByContentLength: function(rootEl, contentLength, rightMatch) {
        var treeWalker = document.createTreeWalker(rootEl),
            currentEl,
            length = 0,
            currentElLength;

        while(currentEl = treeWalker.currentNode) {
            currentElLength = this._getElementsContentLengthIncrement(currentEl);

            if((length + currentElLength) < contentLength) {
                length += currentElLength;
            } else if((length + currentElLength) === contentLength) {
                return rightMatch ? (this._walkToNextEditableNode(treeWalker) || currentEl) : currentEl;
            } else {
                return currentEl;
            }

            if(!treeWalker.nextNode()) break;
        }

        return null;
    },

    _getFirstParentWhichMatchContext: function(node, context) {
        if(!node) return;

        var tmpNode = node,
            contextType,
            matchFns;

        if(!Array.isArray(context)) {
            context = [context]
        }

        matchFns = context.map(function(ctx) {
            if(ctx.startsWith('.')) {
                contextType = 'class';
                ctx = ctx.substring(1);
            } else {
                contextType = 'tag';
            }

            if((contextType === 'tag' || !contextType)) {
                return function(node) {return node.tagName && node.tagName.toLowerCase() === ctx}
            } else {
                return function(node) {return node.classList && node.classList.contains(ctx)}
            }
        })

        while(tmpNode) {
            if(matchFns.some(function(matchFn) {return matchFn(tmpNode)})) {
                return tmpNode;
            }

            tmpNode = tmpNode.parentElement;
        }
    },

    isWithinElement: function(el) {
        var sel = window.getSelection();

        return sel.focusNode &&
               sel.anchorNode &&
               el.contains(sel.focusNode) &&
               el.contains(sel.anchorNode)
    },

    getPrecedingCharacter: function(contextElement) {
        var precedingChar = '', sel, range;
        var sel = window.getSelection();
        if (sel.rangeCount > 0) {
            range = sel.getRangeAt(0).cloneRange();
            range.collapse(true);
            range.setStart(contextElement, 0);
            precedingChar = range.toString().slice(-1);
        }
        return precedingChar;
    },

    isPrecedingCharacterWhitespace: function(contextElement) {
        var precedingCharacter = Caret.prototype.getPrecedingCharacter(contextElement),
            precedingCharacterCode;

        if(!precedingCharacter) { return false }
        precedingCharacterCode = precedingCharacter.charCodeAt(0);
        return (precedingCharacterCode === 32 || precedingCharacterCode === 160);
    },

    isCollapsedAndPositionedAtTheFirstLineOf: function(node) {
        if(!node.offsetTop) { return }

        if(node.innerText === '' && (node.tagName === 'OL' || node.tagName === 'UL')) {
            var targetEl = this.getContextElement('li');
            if(targetEl && targetEl !== node.firstChild) {
                return false;
            }
        } else if(node.innerText === '') {
            return true
        }

        var style = window.getComputedStyle(node),
            caretPos = this.getPosition(),
            caretPosY = caretPos && caretPos.y,
            paddingTop = parseInt(style.getPropertyValue('padding-top')),
            lineHeight = parseInt(style.getPropertyValue('line-height')),
            firstLineStartYPos = node.offsetTop + paddingTop,
            firstLineEndYPos = firstLineStartYPos + lineHeight;

        return firstLineStartYPos < caretPosY && firstLineEndYPos > caretPosY;
    },

    isCollapsedAndPositionedAtTheLastLineOf: function(node) {
        if(!node.offsetTop) { return }
        if(node.innerText === '') { return true }

        var style = window.getComputedStyle(node),
            caretPos = this.getPosition(),
            caretPosY = caretPos && caretPos.y,
            paddingBottom = parseInt(style.getPropertyValue('padding-bottom')),
            lineHeight = parseInt(style.getPropertyValue('line-height')),
            borderBottom = 1,
            lastLineEndYPos = (node.offsetTop + node.offsetHeight) - paddingBottom - borderBottom,
            lastLineStartYPos = lastLineEndYPos - lineHeight - 10;

        return lastLineEndYPos > caretPosY && lastLineStartYPos < caretPosY;
    },

    isCollapsedAndPositionedAtTheBeginningOf: function(node, ignoreFirstCharIfWhitespace) {
        var selection = window.getSelection(),
            pos;

        ignoreFirstCharIfWhitespace = ignoreFirstCharIfWhitespace === undefined ? true : ignoreFirstCharIfWhitespace;

        if(!selection.isCollapsed || !node) { return false }

        pos = this._getContentLengthOfDOMElement(node, selection.anchorNode) + selection.anchorOffset;
        if(ignoreFirstCharIfWhitespace &&
           pos === 1 &&
           node.childNodes && node.childNodes[0] === selection.anchorNode &&
           (selection.focusNode.nodeValue && (selection.focusNode.nodeValue[0] === '\u00A0' || selection.focusNode.nodeValue[0] === ' '))) {

            // when the first node of the section is focused and it starts with
            // a white space we do not mind whether the caret is placed right or
            // left from that whitespace. This is because for some reason the browser
            // just does not display this whitespace ?!?!? Blame this line in git
            // and see the spec in the same commit to get more details about this
            // specifc scenario.
            return true;
        }

        return pos === 0;
    },

    isCollapsedAndPositionedAtTheEndOf: function(node) {
        var selection = window.getSelection(),
            pos, nodeLength, lastEl;

        if(!selection.isCollapsed || !node) { return false }

        if(selection.anchorNode === node && selection.anchorOffset === node.childNodes.length) {
            return true;
        }

        pos = this._getContentLengthOfDOMElement(node, selection.anchorNode) + selection.anchorOffset;
        nodeLength = this._getContentLengthOfDOMElement(node);

        if(pos === nodeLength-1 && node.innerText[node.innerText.length-1] === '\n') {
            return true;
        }

        return pos === nodeLength;
    },

    positionAtTheBeginningOf: function(node) {
        var range = document.createRange(),
            selection = window.getSelection();

        range.setEnd(node, 0);
        range.setStart(node, 0);
        selection.removeAllRanges();
        selection.addRange(range);
    },

    positionAfter: function(node) {
        var nodeIndex,
            range = document.createRange(),
            selection = window.getSelection(),
            uneditableParent = this.withinUnedidableReferenceEl(node);

        if(uneditableParent) {
            node = uneditableParent
        }

        if(node.parentNode) {
            nodeIndex = Array.prototype.indexOf.call(node.parentNode.childNodes, node);
            range.setEnd(node.parentNode, nodeIndex+1);
            range.setStart(node.parentNode, nodeIndex+1);
            selection.removeAllRanges();
            selection.addRange(range);
        }
    },

    positionIn: function(node) {
        var range = document.createRange(),
            selection = window.getSelection();

        range.selectNodeContents(node);
        range.collapse();
        selection.removeAllRanges();
        selection.addRange(range);
    },

    modifyRangeToBeValidInsertPosition: function(range) {
        var node = range && range.collapsed && range.startContainer,
            firstLI;

        if(node && ['UL', 'OL'].includes(node.tagName) && range.startOffset === 0) {
            if(firstLI = node.querySelector('li')) {
                range.setStart(firstLI, 0);
                range.setEnd(firstLI, 0);
            }
        }

        return range;
    },

    insertNode: function (node) {
        var sel = window.getSelection(),
            range = sel.getRangeAt(0);

        this.modifyRangeToBeValidInsertPosition(range);
        range.insertNode(node);
        range.collapse();
        sel.removeAllRanges();
        sel.addRange(range);

        if(node.nextSibling && node.nextSibling.nodeValue === '') {
            node.nextSibling.remove();
        }
    },

    insertLineBreak: function() {
        var node = document.createElement('br'),
            focusedSection = this.editor.focusedSection(),
            index = this.editor.indexOfFocusedSection(),
            nextSection = 1;

        if(this.isPositionedAtTheBeginningOfFocusNode(window.getSelection())) {
            nextSection = 0;
        }

        this.editor.caret.insertNode(node);
        this.editor.replaceSectionWithHTML(focusedSection, focusedSection.outerHTML, {
            positionCaretAtTheEndOfSectionWithIndex: index+nextSection
        });
    },

    withinUnedidableReferenceEl: function(node) {
        if(node && node.isContentEditable) { return false }

        var sel = window.getSelection(),
            tmpNode = node || sel.focusNode;

        if(!tmpNode) { return false }

        while(tmpNode) {
            if(tmpNode.isContentEditable === true) {
                return false;
            }

            if(tmpNode.getAttribute && tmpNode.getAttribute('contenteditable') === 'false') {
                return tmpNode;
            }

            tmpNode = tmpNode.parentElement;
        }

        return false;
    },

    isPositionedAtTheEndOfFocusNode: function(selection) {
        return selection.isCollapsed &&
               selection.focusNode &&
               selection.focusOffset === selection.focusNode.length;
    },

    isPositionedAtTheBeginningOfFocusNode: function(selection) {
        return selection.isCollapsed &&
               selection.focusNode &&
               selection.focusOffset === 0;
    },

    getTangetNodes: function() {
        var self = this,
            selection = window.getSelection(),
            tangentNodes = {left: null, right: null},
            nodeIterator,
            ensureSameSection = function(n) { return n };

        if(this.editor && self.editor.focusedSection) {
            ensureSameSection = function(n) {
                if(n && self.editor.focusedSection() === self.editor.sectionByChildNode(n)) {
                    return n;
                }
            }
        }

        if(selection && selection.focusNode && selection.focusNode.nodeType !== Node.TEXT_NODE) {
            return {
                left: selection.focusNode.childNodes[selection.focusOffset-1],
                right: selection.focusNode.childNodes[selection.focusOffset]
            }
        }

        nodeIterator = utils.getNodeIteratorPointingTo(selection.focusNode);

        if(!nodeIterator) {
            return tangentNodes;
        }

        if(this.isPositionedAtTheBeginningOfFocusNode(selection)) {
            tangentNodes.left = ensureSameSection(nodeIterator.previousNode());
            nodeIterator.nextNode(); //move the iterator back to the focus node
        }

        if(this.isPositionedAtTheEndOfFocusNode(selection)) {
            tangentNodes.right = ensureSameSection(nodeIterator.nextNode());
        }

        return tangentNodes;
    },

    // This method finds a DOM element which wraps the passed selection and matches the context.
    //   - wraps means, focusNode and anchorNode are contained within the element
    //   - matches the context means, the returned element has either (depending on contextType, see below)
    //     the same tagName as specified in context, or a class name specified in context
    //   - the contextType is determined by the first char of the context argument. If it is '.' the type is
    //     "class" will match a element which has the according class assigned in its class attribute.
    //     If the context does not start with a '.' a element with the according tag name will match.
    getContextElement: function(context, selection, tangentNodes) {
        selection = selection || window.getSelection();
        tangentNodes = tangentNodes || this.getTangetNodes();

        if(selection.rangeCount === 0) return null;

        var commonAncestor = selection.getRangeAt(0).commonAncestorContainer;

        return this._getFirstParentWhichMatchContext(commonAncestor, context) ||
               this._getFirstParentWhichMatchContext(tangentNodes.right, context) ||
               this._getFirstParentWhichMatchContext(tangentNodes.left, context);
    },

    getPosition: function() {
        var selection = window.getSelection(),
            range = selection.getRangeAt(0),
            rect = range.getClientRects()[0],
            tn;

        if(rect) {
          return {x: rect.left, y: rect.top + window.scrollY, width: rect.width, height: rect.height};
        }

        tn = this.getTangetNodes();

        if(tn.left && tn.left.nodeType === Node.TEXT_NODE) {
            range = document.createRange();
            range.selectNodeContents(tn.left);
            range.collapse(false);
            rect = range.getClientRects()[0];
            return {x: rect.left+rect.width, y: rect.top + window.scrollY, width: 0, height: rect.height};
        } else if(tn.left) {
            rect = tn.left.getClientRects()[0];
            return {x: rect.left+rect.width, y: rect.top + window.scrollY, width: 0, height: rect.height};
        } else if(!rect && range.startContainer === range.endContainer)  {
            rect = range.startContainer.getClientRects()[0];
            return {x: rect.left, y: rect.top + window.scrollY, width: rect.width, height: rect.height};
        }

        // it seeems there is no known situation in which we have to consider tn.right
    },

    restoreSelection: function(moveToLeft, strategy) {
        strategy = strategy || 'OffsetStrategy';
        if(strategy === 'OffsetStrategy') {
            return this.restoreSelectionViaOffsetStrategy(moveToLeft);
        } else if(strategy === 'TryDOMStrategyFirst') {
            if(!this.restoreSelectionViaDOMStrategy()) {
                return this.restoreSelectionViaOffsetStrategy(moveToLeft);
            }
            return true;
        } else {
            return this.restoreSelectionViaDOMStrategy();
        }
    },

    // param 'moveToLeft': will correct the poistion by the given amount of char
    restoreSelectionViaOffsetStrategy: function(moveToLeft, savedSelection) {
        moveToLeft = moveToLeft || 0;

        if(savedSelection) {
            this.rootEl = savedSelection.rootEl;
            this.rangeStart = savedSelection.rangeStart;
            this.rangeEnd = savedSelection.rangeEnd;
            this.isAnchorLeft = savedSelection.isAnchorLeft;
            this.rangeStartAtZeroOffset = savedSelection.rangeStartAtZeroOffset;
            this.rangeEndAtZeroOffset =  savedSelection.rangeEndAtZeroOffset;
            this.selectionFocusNode = savedSelection.selectionFocusNode;
            this.selectionAnchorNode = savedSelection.selectionAnchorNode;
            this.rangeStartAtZeroOffset = savedSelection.rangeStartAtZeroOffset;
            this.rangeEndAtZeroOffset = savedSelection.rangeEndAtZeroOffset;
        }

        if(this.selectionIsUnedidable) {
            return true;
        }

        if(this.carretPlacementCorrection) {
            moveToLeft += this.carretPlacementCorrection;
        }

        this.rangeStartAtZeroOffset = (this.selectionAnchorOffset-moveToLeft) === 0;
        this.rangeEndAtZeroOffset = (this.selectionFocusOffset-moveToLeft) === 0;

        if(typeof this.rangeStart === 'number' && typeof this.rangeEnd === 'number') {

            var range,
                selection = window.getSelection(),
                startNode = this._getElementByContentLength(this.rootEl, this.rangeStart - moveToLeft, this.rangeStartAtZeroOffset),
                startOffset = this.rangeStart - moveToLeft - this._getContentLengthOfDOMElement(this.rootEl, startNode),
                endNode,
                endOffset,
                unediableContexEl;

            if(this.selectionIsCollapsed) {
                endNode = startNode;
                endOffset = startOffset;
            } else {
                endNode = this._getElementByContentLength(this.rootEl, this.rangeEnd - moveToLeft, this.rangeEndAtZeroOffset);
                endOffset = this.rangeEnd - moveToLeft - this._getContentLengthOfDOMElement(this.rootEl, endNode);
            }

            unediableContexEl = startNode == endNode && (unediableContexEl = this.withinUnedidableReferenceEl(startNode));

            try {
                if(unediableContexEl) {
                    startOffset = endOffset = unediableContexEl.parentElement.childNodes.indexOf(unediableContexEl) + 1;
                    startNode = endNode = unediableContexEl.parentElement;
                }

                range = document.createRange();
                if(this.isAnchorLeft) {
                    range.setStart(startNode, startOffset);
                    range.setEnd(endNode, endOffset);
                } else {
                    range.setEnd(startNode, startOffset);
                    range.setStart(endNode, endOffset);
                }

                selection.removeAllRanges();
                selection.addRange(range);
                return true;
            } catch(ex) {
                console.log('failed to set caret position via offset strategy', ex);
                return false;
            }
        }
    },

    restoreSelectionViaDOMStrategy: function() {
        var range, selection;

        if(!this.rootEl) {
            return false;
        }

        if(this.selectionIsUnedidable) {
            return true;
        }

        if(this.rootEl.contains(this.selectionAnchorNode) && this.rootEl.contains(this.selectionFocusNode)) {
            range = document.createRange();
            selection = window.getSelection();
            if(this.isAnchorLeft) {
                range.setEnd(this.selectionAnchorNode, this.selectionAnchorOffset);
                range.setStart(this.selectionFocusNode, this.selectionFocusOffset);
            } else {
                range.setStart(this.selectionAnchorNode, this.selectionAnchorOffset);
                range.setEnd(this.selectionFocusNode, this.selectionFocusOffset);
            }
            selection.removeAllRanges();
            selection.addRange(range);
            return true;
        }

        return false;
    },

    saveSelection: function(rootEl, insertedContent) {
        var selection = window.getSelection();

        if(this.withinUnedidableReferenceEl(selection.anchorNode)) {
            this.selectionIsUnedidable = true;
        } else if(!selection.isCollapsed && this.withinUnedidableReferenceEl(selection.focusNode)) {
            this.selectionIsUnedidable = true;
        } else {
            this.selectionIsUnedidable = false;
        }

        if(this.selectionIsUnedidable) {
            return { selectionIsUnedidable: true };
        }

        if(selection.anchorNode && selection.focusNode) {
            if(selection.anchorNode.nodeType === Node.TEXT_NODE) {
                this.rangeStart = this._getContentLengthOfDOMElement(rootEl, selection.anchorNode) + selection.anchorOffset;
            } else {
                this.rangeStart = this._getContentLengthOfDOMElement(rootEl, selection.anchorNode);
                for(let i=0; i<selection.anchorOffset; i++) {
                    this.rangeStart += this._getContentLengthOfDOMElement(selection.anchorNode.childNodes[i]);
                }
            }

            if(selection.isCollapsed) {
                this.rangeEnd = this.rangeStart;
            } else {
                if(selection.focusNode.nodeType === Node.TEXT_NODE) {
                    this.rangeEnd = this._getContentLengthOfDOMElement(rootEl, selection.focusNode) + selection.focusOffset;
                } else {
                    this.rangeEnd = this._getContentLengthOfDOMElement(rootEl, selection.focusNode);
                    for(let i=0; i<selection.focusOffset; i++) {
                        this.rangeEnd += this._getContentLengthOfDOMElement(selection.focusNode.childNodes[i]);
                    }
                }
            }

            this.rootEl = rootEl;
            this.selectionIsUnedidable = false;
            this.isAnchorLeft = this.rangeStart <= this.rangeEnd;
            this.rangeStartAtZeroOffset = selection.anchorOffset === 0;
            this.rangeEndAtZeroOffset = selection.focusOffset === 0;
            this.selectionAnchorNode = selection.anchorNode;
            this.selectionFocusNode = selection.focusNode;
            this.selectionAnchorOffset = selection.anchorOffset;
            this.selectionFocusOffset = selection.focusOffset;
            this.selectionIsCollapsed = selection.isCollapsed;

            this.followingSpaceTerminatesTextNode = selection.anchorNode === selection.focusNode &&
                                                    selection.focusNode.length &&
                                                    selection.anchorOffset === (selection.focusNode.length-1) &&
                                                    (selection.focusNode.nodeValue[selection.focusNode.length-1] === '\u00A0' ||
                                                     selection.focusNode.nodeValue[selection.focusNode.length-1] === ' ');

             if(insertedContent === ' ' && this.followingSpaceTerminatesTextNode) {
               this.carretPlacementCorrection = -1;
             } else {
               this.carretPlacementCorrection = 0;
             }

             return {
                rootEl: this.rootEl,
                rangeStart: this.rangeStart,
                rangeEnd: this.rangeEnd,
                isAnchorLeft: this.isAnchorLeft,
                rangeStartAtZeroOffset: this.rangeStartAtZeroOffset,
                rangeEndAtZeroOffset: this.rangeEndAtZeroOffset,
                selectionFocusNode: this.selectionFocusNode,
                selectionAnchorNode: this.selectionAnchorNode,
                selectionIsCollapsed: this.selectionIsCollapsed,
                selectionIsUnedidable: this.selectionIsUnedidable
             }
        }
    },

    clearSelection: function() {
        window.getSelection().removeAllRanges();
    },

    targetElement: function() {
        return window.getSelection().focusNode;
    },

    isCollapsed: function() {
        var sel = window.getSelection(),
            range;

        if(sel.rangeCount === 0) return;

        range = sel.getRangeAt(0);
        if(!range) return;
        return range.collapsed;
    },

    // If the selection is not collapsed and the start or end
    // is outsite the given element, this function will move the
    // corresponding selection end inside the given element.
    //
    // In the following Example the passed element is the p section
    // in the middle:
    // <p>text</p><p>w|ith</p><p>paragr|aphs</p>
    // =>
    // <p>text</p><p>w|ith|</p><p>paragraphs</p>
    //
    // This is actually not used on section level but to ensure
    // that the selection is within the editor iteself.
    ensureExpandedSelectionIsWithinElement: function(el) {
        var sel = window.getSelection(),
            n1 = sel.focusNode,
            o1 = sel.focusOffset,
            n2 = sel.anchorNode,
            o2 = sel.anchorOffset,
            tmp, n1IncludedInEl, n2IncludedInEl, n1Pos, n2Pos,
            n1AndN2AreFollowingEl, n1AndN2ArePrecedingEl, childEl,
            elWalker, newRange;

        if(!n1 || !n2 || sel.isCollapsed) { return }

        n1Pos = n1.compareDocumentPosition(el);
        n2Pos = n2.compareDocumentPosition(el);

        n1IncludedInEl = n1Pos & Node.DOCUMENT_POSITION_CONTAINS;
        n2IncludedInEl = n2Pos & Node.DOCUMENT_POSITION_CONTAINS;

        if(n1IncludedInEl && n2IncludedInEl) { return }

        n1AndN2AreFollowingEl = !!((n1Pos & Node.DOCUMENT_POSITION_FOLLOWING) && (n2Pos & Node.DOCUMENT_POSITION_FOLLOWING) && !n1IncludedInEl && !n2IncludedInEl);
        n1AndN2ArePrecedingEl = !!((n1Pos & Node.DOCUMENT_POSITION_PRECEDING) && (n2Pos & Node.DOCUMENT_POSITION_PRECEDING) && !n1IncludedInEl && !n2IncludedInEl);

        if(n1AndN2AreFollowingEl || n1AndN2ArePrecedingEl) { return }

        if(n1.compareDocumentPosition(n2) & Node.DOCUMENT_POSITION_PRECEDING) {
            tmp = n2; n2 = n1; n1 = tmp;
            tmp = o2; o2 = o1; o1 = tmp;
            tmp = n2IncludedInEl; n2IncludedInEl = n1IncludedInEl; n1IncludedInEl = tmp;
        }

        newRange = document.createRange();

        if(!n1IncludedInEl) {
            elWalker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null, false);
            newRange.setStart(elWalker.firstChild(), 0);
        } else {
            newRange.setStart(n1, o1);
        }

        if(!n2IncludedInEl) {
            elWalker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null, false);
            childEl = elWalker.lastChild();
            newRange.setEnd(childEl, childEl.length);
        } else {
            newRange.setEnd(n2, o2);
        }

        sel.removeAllRanges();
        sel.addRange(newRange);
    },

    getContentLengthTillSection: function(section) {
        var result = 0;
        section = section.previousSibling;

        while(section) {
            result += this._getContentLengthOfDOMElement(section);
            section = section.previousSibling;
        }

        return result;
    },
}

module.exports = Caret;


/***/ }),

/***/ "../structured-text-editor/src/editor.js":
/*!***********************************************!*\
  !*** ../structured-text-editor/src/editor.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var HTMLRazor = __webpack_require__(/*! ../lib/html_razor/html_razor */ "../structured-text-editor/lib/html_razor/html_razor.js"),
    TagTransformations = __webpack_require__(/*! ../lib/html_razor/tag_transformation */ "../structured-text-editor/lib/html_razor/tag_transformation.js"),
    Caret = __webpack_require__(/*! ./caret */ "../structured-text-editor/src/caret.js"),
    SectionTypeSelectorControl = __webpack_require__(/*! ./section_type_selector_control */ "../structured-text-editor/src/section_type_selector_control.js"),
    KeyPressHandler = __webpack_require__(/*! ./key_press_handler */ "../structured-text-editor/src/key_press_handler.js"),
    TextEnrichmentControl = __webpack_require__(/*! ./text_enrichment_control */ "../structured-text-editor/src/text_enrichment_control.js"),
    Documentupdater = __webpack_require__(/*! ../lib/documentupdater/documentupdater */ "../structured-text-editor/lib/documentupdater/documentupdater.js"),
    ModificationLogEntry = __webpack_require__(/*! ../lib/documentupdater/modification_log */ "../structured-text-editor/lib/documentupdater/modification_log.js"),
    ReferenceStore = __webpack_require__(/*! ./references/reference_store */ "../structured-text-editor/src/references/reference_store.js"),
    ReferenceController = __webpack_require__(/*! ./references/reference_controller */ "../structured-text-editor/src/references/reference_controller.js"),
    DeclarativForm = __webpack_require__(/*! ../lib/declarativ_forms/src/declarativ_form */ "../structured-text-editor/lib/declarativ_forms/src/declarativ_form.js"),
    Changeset = (__webpack_require__(/*! changesets */ "../structured-text-editor/node_modules/changesets/lib/index.js").Changeset),
    paragraphSectionType = __webpack_require__(/*! ./section_types/paragraph/paragraph_section_type */ "../structured-text-editor/src/section_types/paragraph/paragraph_section_type.js"),
    tableSectionType = __webpack_require__(/*! ./section_types/table/table_section_type */ "../structured-text-editor/src/section_types/table/table_section_type.js"),
    unorderedListSectionType = __webpack_require__(/*! ./section_types/list/unordered_list_section_type */ "../structured-text-editor/src/section_types/list/unordered_list_section_type.js"),
    orderedListSectionType = __webpack_require__(/*! ./section_types/list/ordered_list_section_type */ "../structured-text-editor/src/section_types/list/ordered_list_section_type.js"),
    imageSectionType = __webpack_require__(/*! ./section_types/image/image_section_type */ "../structured-text-editor/src/section_types/image/image_section_type.js"),
    codeSectionType = __webpack_require__(/*! ./section_types/code/code_section_type */ "../structured-text-editor/src/section_types/code/code_section_type.js"),
    tocSectionType = __webpack_require__(/*! ./section_types/toc/toc_section_type */ "../structured-text-editor/src/section_types/toc/toc_section_type.js"),
    bibliographieSectionType = __webpack_require__(/*! ./section_types/bibliographie/bibliographie_section_type */ "../structured-text-editor/src/section_types/bibliographie/bibliographie_section_type.js"),
    footnotesSectionType = __webpack_require__(/*! ./section_types/footnotes/footnotes_section_type */ "../structured-text-editor/src/section_types/footnotes/footnotes_section_type.js"),
    formulaSectionType = __webpack_require__(/*! ./section_types/formula/formula_section_type */ "../structured-text-editor/src/section_types/formula/formula_section_type.js"),
    mermaidSectionType = __webpack_require__(/*! ./section_types/mermaid/mermaid_section_type */ "../structured-text-editor/src/section_types/mermaid/mermaid_section_type.js"),
    blockquoteSectionType = __webpack_require__(/*! ./section_types/blockquote/blockquote_section_type */ "../structured-text-editor/src/section_types/blockquote/blockquote_section_type.js"),
    heading1SectionType = __webpack_require__(/*! ./section_types/heading/heading1 */ "../structured-text-editor/src/section_types/heading/heading1.js"),
    heading2SectionType = __webpack_require__(/*! ./section_types/heading/heading2 */ "../structured-text-editor/src/section_types/heading/heading2.js"),
    heading3SectionType = __webpack_require__(/*! ./section_types/heading/heading3 */ "../structured-text-editor/src/section_types/heading/heading3.js"),
    heading4SectionType = __webpack_require__(/*! ./section_types/heading/heading4 */ "../structured-text-editor/src/section_types/heading/heading4.js"),
    heading5SectionType = __webpack_require__(/*! ./section_types/heading/heading5 */ "../structured-text-editor/src/section_types/heading/heading5.js"),
    utils = __webpack_require__(/*! ../lib/pixelschubser/utils */ "../structured-text-editor/lib/pixelschubser/utils.js"),
    // katex = require('katex'), // make sure to load <script src="./katex.js" defer></script> in your html
    uuid = __webpack_require__(/*! uuid/v1 */ "../structured-text-editor/node_modules/uuid/v1.js"),
    isMac = navigator.platform.indexOf("Mac") === 0;

window.Changeset = Changeset;

DOMTokenList.prototype.find = Array.prototype.find;
NodeList.prototype.indexOf = Array.prototype.indexOf;
NodeList.prototype.filter = Array.prototype.filter;
NodeList.prototype.forEach = Array.prototype.forEach;
NodeList.prototype.map = Array.prototype.map;
HTMLCollection.prototype.indexOf = Array.prototype.indexOf;
HTMLCollection.prototype.filter = Array.prototype.filter;
HTMLCollection.prototype.forEach = Array.prototype.forEach;
HTMLCollection.prototype.map = Array.prototype.map;
Array.prototype.contains = Array.prototype.includes;
Array.prototype.includesAll = function() { var self = this, args = Array.from(arguments); return args.every(function(r) {return self.includes(r) })}
Array.prototype.unique = function() { return this.filter(function (value, index, self) { return self.indexOf(value) === index }) }

var Editor = function(domId, options) {
    var self = this;
    options = options || {}

    this._initDone = false;
    this._isContentEditable = true;
    this.reference = new ReferenceController(new ReferenceStore(options.contentID, options.ReferencePersitencyDriver), this);
    this.tagTransformations = new TagTransformations();
    this.domId = domId;
    this.hintEl = document.createElement('ste-input-hint')
    this.containerElement = document.getElementById(domId);
    this.containerElement.innerHTML = '';
    this.contentElement = document.createElement('div');
    this.caret = new Caret(this);
    this.subscribers = [];
    this.referenceInsertedSubscribers = [];
    this.sectionFocusChangeSubscribers = [];
    this.sectionTypeSelector = new SectionTypeSelectorControl(this.changeFocusedSectionType, this, this);
    this.textEnrichmentControl = new TextEnrichmentControl(this);
    this.keyPressHandler = new KeyPressHandler(this);

    this.contentElement.setAttribute('spellcheck', options.spellcheck);
    this.contentElement.className = 'structured-text-editor';

    this.hintEl.innerHTML = `Write Here... Press <code>${isMac ? '⌘' : 'Ctrl'}</code> + <code>i</code> to insert a reference, footnote or equation.`;

    this.containerElement.className = 'structured-text-editor-container';
    this.containerElement.appendChild(this.buildAddSectionButton('top'));
    this.containerElement.appendChild(this.contentElement);
    this.containerElement.appendChild(this.buildAddSectionButton('bottom'));

    this.supportedSectionTypes = {};

    this.history = [];
    this.undoneModifications = [];
    this.caretPositions = [];

    this.markupTransformations = [
        { to: 'table',     praefix: '#table'  },
        { to: 'pre',       praefix: '#code'   },
        { to: 'h1',        praefix: '#title'  },
        { to: 'h2',        praefix: '#'       },
        { to: 'h2',        praefix: '#h1'     },
        { to: 'h3',        praefix: '##'      },
        { to: 'h3',        praefix: '#h2'     },
        { to: 'h4',        praefix: '###'     },
        { to: 'h4',        praefix: '#h3'     },
        { to: 'h5',        praefix: '####'    },
        { to: 'h5',        praefix: '#h4'     },
        { to: 'p',         praefix: '#p'      },
        { to: 'ul',        praefix: '#ul'     },
        { to: 'ul',        praefix: '\\*'     },
        { to: 'ol',        praefix: '#ol'     },
        { to: 'ol',        praefix: '1\\)'    },
        { to: 'figure',    praefix: '#img'    },
        { to: 'figure',    praefix: '#image'  },
        { to: 'nav',       praefix: '#toc'    },
        { to: 'h2(Abstract)',   praefix: '#abstract'  },
        { to: 'h2(Abstract)',   praefix: '#Abstract'  },
        { to: 'bibliographie',  praefix: '#bib'       },
        { to: 'footnotes',      praefix: '#footnotes' },
        { to: 'formula',        praefix: '#formula'   },
        { to: 'formula',        praefix: '#eq'        },
        { to: 'mermaid',        praefix: '#dia'       },
        { to: 'bquote',         praefix: '#quote'     },
        { to: 'bquote',         praefix: '#"'         },
        { to: 'bquote',         praefix: "#'"         },
        { to: 'bquote',         praefix: '#blockquote'},
    ];

    Object.assign(this.tagTransformations, {
        '/p': this.markupTransformations,
        '/h1': this.markupTransformations,
        '/h2': this.markupTransformations,
        '/h3': this.markupTransformations,
        '/h4': this.markupTransformations,
        '/h5': this.markupTransformations,
        '/div': 'p',
        '/b': 'p',
        '/i': 'p',
        '/inlinecode': 'p',
        '/p/br': '=',
        '/h1/br': '=p',
        '/h2/br': '=p',
        '/h3/br': '=p',
        '/h4/br': '=p',
        '/h5/br': '=p',

        '/p/b/br': '=',
        '/p/b/i/br': '=',
        '/p/b/u/br': '=',
        '/p/b/a/br': '=',

        '/p/u/br': '=',
        '/p/u/i/br': '=',
        '/p/u/b/br': '=',
        '/p/u/a/br': '=',

        '/p/i/br': '=',
        '/p/i/u/br': '=',
        '/p/i/b/br': '=',
        '/p/i/a/br': '=',

        '/p/code': 'inlinecode',
        '/p/inlinecode/br': '=',
        '/p/inlinecode/inlinecode': '#content',
        '/p/inlinecode/b': '#content',
        '/p/inlinecode/u': '#content',
        '/p/inlinecode/i': '#content',
        '/p/inlinecode/a': '#content',
        '/p/i/code': '-',
        '/p/b/code': '-',
        '/p/u/code': '-',
        '/p/a/code': 'inlinecode',
        '/p/i/inlinecode': '-',
        '/p/b/inlinecode': '-',
        '/p/u/inlinecode': '-',

        '/p/a/br': '=',
        '/p/a/i/br': '=',
        '/p/a/u/br': '=',
        '/p/a/b/br': '=',

        '/p/div': '-',
        '/h1/div': '-',
        '/h2/div': '-',
        '/h3/div': '-',
        '/h4/div': '-',
        '/h5/div': '-',
        '/p/p': '#content',
        '/p/font': '#content',
        '/p/var': '#content',
        '/p/a/span': '#content',
        '/figure/div': '#content',
    });

     this.tagTransformations.allowOnlyTextIn('/table/caption');
     this.tagTransformations.allowOnlyTextIn('/figure/figcaption');
     this.tagTransformations.allowOnlyTextIn('/table/tbody/tr/td', { allowEquations: true, allowRefs: true, allowLinks: true, allowBoldItalicUnderline: true });
     this.tagTransformations.allowOnlyTextIn('/ul/li', { allowEquations: true, allowRefs: true, allowLinks: true, allowBoldItalicUnderline: true });
     this.tagTransformations.allowOnlyTextIn('/ol/li', { allowEquations: true, allowRefs: true, allowLinks: true, allowBoldItalicUnderline: true });

     this.tagTransformations.allowOnlyTextIn('/ol/ol/li', { allowEquations: true, allowRefs: true, allowLinks: true, allowBoldItalicUnderline: true });
     this.tagTransformations.allowOnlyTextIn('/ol/ol/ol/li', { allowEquations: true, allowRefs: true, allowLinks: true, allowBoldItalicUnderline: true });

     this.tagTransformations.allowOnlyTextIn('/ul/ul/li', { allowEquations: true, allowRefs: true, allowLinks: true, allowBoldItalicUnderline: true });
     this.tagTransformations.allowOnlyTextIn('/ul/ul/ul/li', { allowEquations: true, allowRefs: true, allowLinks: true, allowBoldItalicUnderline: true });

     this.tagTransformations.allowOnlyTextIn('/h1', { allowEquations: true });
     this.tagTransformations.allowOnlyTextIn('/h2', { allowEquations: true });
     this.tagTransformations.allowOnlyTextIn('/h3', { allowEquations: true });
     this.tagTransformations.allowOnlyTextIn('/h4', { allowEquations: true });
     this.tagTransformations.allowOnlyTextIn('/h5', { allowEquations: true });

     this.tagTransformations.allowRefsIn('/p');
     this.tagTransformations.allowRefsIn('/p/b');
     this.tagTransformations.allowRefsIn('/p/i');
     this.tagTransformations.allowRefsIn('/p/u');
     this.tagTransformations.allowRefsIn('/pre/caption');
     this.tagTransformations.allowRefsIn('/table/caption');
     this.tagTransformations.allowRefsIn('/formula/caption');
     this.tagTransformations.allowRefsIn('/mermaid/caption');
     this.tagTransformations.allowRefsIn('/figure/figcaption');
     // this.tagTransformations.allowRefsIn('/bquote/citesrc'); // this is specified in the section type code file itself

     this.tagTransformations.allowInlineequationsIn('/p');
     this.tagTransformations.allowInlineequationsIn('/pre/caption');
     this.tagTransformations.allowInlineequationsIn('/table/caption');
     this.tagTransformations.allowInlineequationsIn('/formula/caption');
     this.tagTransformations.allowInlineequationsIn('/mermaid/caption');
     this.tagTransformations.allowInlineequationsIn('/figure/figcaption');
     this.tagTransformations.allowInlineequationsIn('/bquote/citesrc');

    this.contentRules = {
        'i': {
            tagName: 'i',
            allowedChildren: ['#text', 'link', 'b', 'u', 'footnote', 'reference'],
            pruneSpaces: true,
            deleteIfEmpty: true
        },
        'b': {
            tagName: 'b',
            allowedChildren: ['#text', 'link', 'i', 'u', 'footnote', 'reference'],
            pruneSpaces: true,
            deleteIfEmpty: true
        },
        'u': {
            tagName: 'u',
            allowedChildren: ['#text', 'link', 'b', 'i', 'footnote', 'reference'],
            pruneSpaces: true,
            deleteIfEmpty: true
        },
        'inlinecode': {
            tagName: 'inlinecode',
            allowedChildren: ['#text'],
            pruneSpaces: true,
            deleteIfEmpty: true,
        },
        'link': {
            tagName: 'a',
            allowedChildren: ['#text', 'b', 'i', 'u', 'inlinecode'],
            allowedAttributes: ['href'],
            pruneSpaces: true,
            deleteIfEmpty: true
        },
        'footnote': {
            tagName: 'span',
            className: 'footnote',
            allowedAttributes: ['class', 'contenteditable', 'data-note'],
            allowedClassNames: ['footnote'],
            allowedChildren: [],
            buildAttributes: [{name: 'contenteditable', build: function() { return false }}]
        },
        'inlineequation': {
            tagName: 'inlineequation',
            allowedAttributes: ['contenteditable', 'data-latexequation', 'id'],
            allowedChildren: [],
            buildAttributes: [
                {name: 'contenteditable', build: function() { return false }},
                {name: 'id', build: function() { return uuid() }}
            ]
        },
        'reference': {
            tagName: 'span',
            className: 'reference',
            allowedAttributes: ['class', 'contenteditable', 'data-ref', 'data-external'],
            allowedClassNames: ['reference'],
            allowedChildren: [],
            buildAttributes: [{name: 'contenteditable', build: function() { return false }}]
        }
    };

    // According to this config:
    //   when the editor updated a section which
    //     - contains a "h2" element or
    //     - contained a "h2" element or
    //     - is a "h2" element or
    //     - was a "h2" element
    // the modificationLogEntry will have a field "mightIncludeHeadingUpdates" set to true
    this.modLogFlags = {
        Heading: ['h1', 'h2', 'h3', 'h4', 'h5'],
        TableOfContent: ['nav'],
        Bibliographie: ['bibliographie'],
        Reference: ['.reference[data-external="true"]'],
        Footnote: ['.footnote'],
        Inlinequation: ['.inlineequation'],
        FootnotesSection: ['footnotes'],
    };

    this.addSectionType(paragraphSectionType);
    this.addSectionType(tableSectionType);
    this.addSectionType(unorderedListSectionType);
    this.addSectionType(orderedListSectionType);
    this.addSectionType(codeSectionType);
    this.addSectionType(tocSectionType);
    this.addSectionType(bibliographieSectionType.setEditor(this));
    this.addSectionType(footnotesSectionType.setEditor(this));
    this.addSectionType(heading1SectionType);
    this.addSectionType(heading2SectionType);
    this.addSectionType(heading3SectionType);
    this.addSectionType(heading4SectionType);
    this.addSectionType(heading5SectionType);
    this.addSectionType(imageSectionType.setEditor(this));
    this.addSectionType(formulaSectionType);
    this.addSectionType(mermaidSectionType);
    this.addSectionType(blockquoteSectionType);

    this.htmlRazor = new HTMLRazor(this.tagTransformations, this.contentRules);
    this.documentupdater = new Documentupdater(this.contentElement, this.htmlRazor);
    this.activateInputEventProcessing();

    this.subscribe(function(modLogEntry) {
        if(modLogEntry.tags !== 'undo') {
            self.history.push(modLogEntry);
            if(self.history.length > 30) {
                self.history.shift();
            }
        }

        if(modLogEntry.tags !== 'redo' && modLogEntry.tags !== 'undo') {
            self.undoneModifications = [];
        }
    });

    window.addEventListener('resize', function() {
        var section = self.focusedSection();

        if(section && section.onWindowResize) {
            section.onWindowResize(self);
        }
    })

    document.addEventListener('selectionchange', function(e) {
        if(self.isContentEditable() && self._mouseDown && !self.caret.isCollapsed()) {
            self.setContentEditable(false);
        }

        var section = self.focusedSection();

        if(section && section.onSelectionChange) {
            section.onSelectionChange(self);
        }
    });

    document.addEventListener('mousedown', function(e) {
        self._mouseDown = true;
        self.setContentEditable(true);
    });

    document.addEventListener('mouseup', function(e) {
        self._mouseDown = false;
        if(!self.areMultipleSectionsSelected()) {
            self.setContentEditable(true);
        }
    });

    window.addEventListener('scroll', function(e) {
        self.sectionTypeSelector.displayNextTo(self.focusedSection());
    });

    window.addEventListener('resize', function(e) {
        self.sectionTypeSelector.displayNextTo(self.focusedSection());
        self.textEnrichmentControl.updatePositionIfVisible();
    });

    this.caret.subscribeSelectionChange(function(selection) {
        var section = self.sectionAtCaretPostion(),
            previousFocusedSection = self.focusedSection();

        if(section && !self.isFocused(section)) {
            self.focusSection(section);

            if(previousFocusedSection && self.shouldSectionBeRemovedIfUnfocused(previousFocusedSection)) {
                // this will delete the previous focused Section in case it is empty
                self.replaceSectionWithHTML(previousFocusedSection, previousFocusedSection.outerHTML);
            }
        }

        self.scrollToFocusedSectionIfNotInViewport();
    });

    this.contentElement.addEventListener('input', function(e) {
        if(self.isInputEventProcessingActivated() && e.target.tagName !== 'INPUT') {
            self.replaceSectionWithHTML(e.target, e.target.outerHTML, {inputEvent: e})
        }
    });

    this._initDone = true;
}

Editor.prototype = {

    displayModal: function(fields, handler, notFocusFirstInput) {
        var self = this, form;

        this.freezeSelection({
            'unfreezeCallback': function() {
                self.textEnrichmentControl.preventEnrichmentControllToBeHidden = false;
                self.textEnrichmentControl.hide();
            },
        });

        try {
            form = new DeclarativForm({fields: fields}, handler, () => {
                self.unfreezeSelection();
                self.unfocusSection();
                self.caret.clearSelection();
            });
            form.openInModal();

            if(!notFocusFirstInput && fields[0] && fields[0].domElement && fields[0].domElement.tagName === 'DL-SELECT') {
                form.formElement.querySelector('input').focus();
            }

            if(!notFocusFirstInput && fields[0] && fields[0].domElement && fields[0].domElement.tagName === 'TEXTAREA') {
                form.formElement.querySelector('textarea').focus();
            }

            if(!notFocusFirstInput && fields[0] && fields[0].domElement && fields[0].domElement.tagName === 'INPUT') {
                form.formElement.querySelector('input').focus();
            }
        } catch(e) {
            self.unfreezeSelection();
            throw e;
        }
    },

    undo: function() {
        var logEntry = this.history.pop();

        if(logEntry) {
            this.setContent(logEntry.beforeState(), { caretPosition: logEntry.beforeStateCaretPosition, modificationLogTags: 'undo' });
            this.focusSection(this.sectionAtCaretPostion(), { force: true });
            this.undoneModifications.push(logEntry);
        }
    },

    redo: function() {
        var logEntry = this.undoneModifications.pop();

        if(logEntry) {
            this.setContent(logEntry.afterState(), { caretPosition: logEntry.afterStateCaretPosition, modificationLogTags: 'redo' });
            this.focusSection(this.sectionAtCaretPostion(), { force: true });
        }
    },

    emptyHistory: function() {
        this.history = [];
        this.undoneModifications = [];
    },

    selectEverything: function() {
        var lastSection = this.contentElement.children[this.contentElement.children.length-1],
            firstSection = this.contentElement.children[0],
            lastNonEmptySectionIndex = lastSection.innerText !== '' ? this.contentElement.children.length-1 : this.contentElement.children.length-2,
            firstNonEmptySectionIndex = firstSection.innerText !== '' ? 0 : 1,
            range = document.createRange(),
            sel = window.getSelection(),
            allTextNodesOfFirstSection = this.allTextNodesOfSection(firstNonEmptySectionIndex),
            allTextNodesOfLastSection = this.allTextNodesOfSection(lastNonEmptySectionIndex),
            lastTextNodeOfLastSection = allTextNodesOfLastSection[allTextNodesOfLastSection.length-1];

        range.setStart(allTextNodesOfFirstSection[0], 0);
        range.setEnd(lastTextNodeOfLastSection, lastTextNodeOfLastSection.length);
        sel.removeAllRanges();
        sel.addRange(range);

        if(firstNonEmptySectionIndex !== lastNonEmptySectionIndex) {
            for(let i=0; i<this.contentElement.children.length; i++) {
                this.contentElement.children[i].blur();
            }
            this.setContentEditable(false);
        }
    },

    allTextNodesOfSection: function(index) {
        return utils.getAllTextNodesOfElement(this.sectionAt(index))
    },

    isSpellcheckEnabled: function() {
        return this.contentElement.getAttribute('spellcheck') === 'true';
    },

    buildAddSectionButton: function(type) {
        var self = this,
            btn = document.createElement('div');

        if(type !== 'bottom' && type !== 'top') return false

        btn.className = type + 'SectionInsertButton'
        btn.innerHTML = '<span>Add Section</span>';
        btn.onclick = function() { self.addSection(type); btn.onmouseover()}
        btn.onmouseover = function() {
            var section = self.contentElement[type == 'bottom' ? 'lastChild' : 'firstChild'];
            if(self.shouldSectionBeRemovedIfUnfocused(section)) {
               btn.classList.add('deactivatedSectionInsertButton');
            } else {
               btn.classList.remove('deactivatedSectionInsertButton');
            }
        };
        return btn;
    },

    isContentEditable: function() {
        return this._isContentEditable;
    },

    setContentEditable: function(shouldBeEditable) {
        var self = this,
            indexOfFocusedSection = this.indexOfFocusedSection();

        if(this._isContentEditable === shouldBeEditable) return;

        var updateDom = function(el, shouldBeEditable) {
            if(el.setContenteditable) {
                el.setContenteditable(shouldBeEditable, el);
            } else {
                if(shouldBeEditable) {
                    el.setAttribute('contenteditable', true);
                } else {
                    el.removeAttribute('contenteditable');
                }
            }
        }

        this._isContentEditable = shouldBeEditable;
        for(let i=0; i<this.contentElement.children.length; i++) {

            if(Math.abs(indexOfFocusedSection - i) <= 3) {
                updateDom(self.contentElement.children[i], shouldBeEditable);
            } else {
                (function(el) {
                    window.setTimeout(function() {
                        updateDom(el, shouldBeEditable);
                    }, 0);
                })(self.contentElement.children[i]);
            }
        }

        if(shouldBeEditable) {
            this.refreshFocus();
        }
    },

    refreshFocus: function() {
        var range, sel = window.getSelection();
        if(sel.rangeCount > 0 && !this.isSelectionFreezed) {
            range = sel.getRangeAt(0);
            if(range) {
                sel.removeRange(range);
                sel.addRange(range);
            }
        }
    },

    sectionAt: function(index) {
        return this.contentElement.children[index];
    },

    indexOf: function(section) {
        return this.contentElement.children.indexOf(section);
    },

    indexOfFocusedSection: function() {
        return this.indexOf(this.focusedSection());
    },

    scrollToFocusedSectionIfNotInViewport: function() {
        var section;
        if(this.isFocusedSectionInViewport() === false) {
            section = this.focusedSection();
            if(section) {
                window.scrollTo(0, section.offsetTop-(window.innerHeight/2));
            }
        }
    },

    isFocusedSectionInViewport: function() {
        var section = this.focusedSection();
        if(!section) return;
        return window.innerHeight-20 > section.getBoundingClientRect().y;
    },

    addSection: function(position) {
        position = position || 'bottom';

        if(position === 'bottom') {
            return this.addNewSectionNextTo(this.contentElement.lastChild);
        } else if(position === 'top') {
            return this.addNewSectionNextTo(this.contentElement.firstChild, 'before');
        } else {
            return false;
        }
    },

    addNewSectionNextTo: function(section, position) {
        if(this.shouldSectionBeRemovedIfUnfocused(section)) {
            return false;
        }

        var emptySection = document.createElement('p');

        this.modificationLogEntry = new ModificationLogEntry();
        emptySection.innerHTML = '';
        emptySection.originalHTML = emptySection.outerHTML;
        emptySection.setAttribute('contenteditable', true);

        this.contentElement.insertBefore(emptySection, (position === 'before' ? section : section.nextSibling));
        this.modificationLogEntry.retainAllSectionsBefore(emptySection);
        this.modificationLogEntry.insertSection(emptySection);
        this.modificationLogEntry.retainAllSectionsAfter(emptySection);

        this.focusSection(emptySection);
        this.caret.positionAtTheBeginningOf(emptySection);
        this.notifySubscribers(this.modificationLogEntry);
        return true;
    },

    removeSection: function(section) {
        if(!this.isSection(section)) return;

        if(this.contentElement.children.length === 1) {
            this.replaceSectionWithHTML(section, '<p></p>');
            this.caret.positionAtTheBeginningOf(this.contentElement.children[0]);
        } else {
            this.modificationLogEntry = new ModificationLogEntry();
            this.modificationLogEntry.modLogFlags = this.modLogFlags;
            this.modificationLogEntry.retainAllSectionsBefore(section);
            this.modificationLogEntry.deleteSection(section);
            this.modificationLogEntry.retainAllSectionsAfter(section);

            this.caret.saveSelection(this.contentElement);
            this.contentElement.removeChild(section);
            this.modificationLogEntry.wordCount = this.getWordCount();
            this.updateFootnotesNumbering();
            this.updateReferenceNumbering();
            this.caret.restoreSelection(0);
            this.notifySubscribers(this.modificationLogEntry);
        }
    },

    addSectionType: function(sectionType) {
        Object.assign(this.tagTransformations, sectionType.tagTransformations || {});
        Object.assign(this.contentRules, sectionType.contentRules || {});
        this.textEnrichmentControl.addEnrichments(sectionType.enrichments || []);
        this.supportedSectionTypes[sectionType.name] = sectionType;

        if(sectionType.onEditorContentChanged) {
            this.subscribe(sectionType.onEditorContentChanged, true);
        }
    },

    subscribe: function(callback, notifyOnMetadataChange) {

        if(notifyOnMetadataChange) {
            callback.notifyOnMetadataChange = true;
        }

        this.subscribers.push(callback);
    },

    subscribeReferenceInsertion: function(callback) {
        this.referenceInsertedSubscribers.push(callback);
    },

    subscribeSectionFocusChange: function(callback) {
        this.sectionFocusChangeSubscribers.push(callback)
    },

    isInputEventProcessingActivated: function() {
        return this.cleanupContentOnInputEvent;
    },

    deactivateInputEventProcessing: function() {
        for(let i=0; i<this.contentElement.children.length; i++) {
            this.contentElement.children[i].HTMLbevoreInputProcessingDeactivation = this.contentElement.children[i].outerHTML;
        }

        this.sectionCountBeforeInputProcessing = this.contentElement.children.length;
        this.cleanupContentOnInputEvent = false;
    },

    activateInputEventProcessing: function() {
        this.cleanupContentOnInputEvent = true;
        var changesMade = false;

        if(this.sectionCountBeforeInputProcessing === this.contentElement.children.length) {
            for(let i=0; i<this.contentElement.children.length; i++) {
                if(this.contentElement.children[i].forceUpdateOnInputProcesssingEnablement ||
                    this.contentElement.children[i].HTMLbevoreInputProcessingDeactivation !== this.contentElement.children[i].outerHTML) {
                    this.replaceSectionWithHTML(this.contentElement.children[i], this.contentElement.children[i].outerHTML);
                    changesMade = true;
                }

                delete this.contentElement.children[i].HTMLbevoreInputProcessingDeactivation;
                delete this.contentElement.children[i].forceUpdateOnInputProcesssingEnablement;
            }

            if(changesMade) {
                this.updateFootnotesNumbering();
                this.updateReferenceNumbering();
            }
        } else {
            this.content(this.contentElement.innerHTML);
        }

        delete this.sectionCountBeforeInputProcessing;
    },

    freezeSelection: function(args) {
        var args = args || {},
            clickableElement = args['unfreezeOnClicksOutsiteOf'],
            self = this,
            f;

        this.unfreezeCallback = args['unfreezeCallback'];

        if(clickableElement) {
            document.body.addEventListener('click', f = function(e) {
                var tmp = e.target,
                    path = [];

                while(tmp.parentElement) {
                    path.push(tmp.parentElement);
                    tmp = tmp.parentElement;
                }

                if(path.indexOf(clickableElement) === -1) {
                    self.unfreezeSelection(false);
                    document.body.removeEventListener('click', f);
                }
            });
        }

        if(!this.isSelectionFreezed) {
            this.deactivateInputEventProcessing();
            document.execCommand('backColor', false, '#b2d7fd');
            this.caret.saveSelection(this.contentElement);
            window.getSelection().removeAllRanges();
            this.isSelectionFreezed = true;
        }
    },

    unfreezeSelection: function(restoreSelection) {
        if(this.isSelectionFreezed) {
            restoreSelection = restoreSelection === undefined ? true : restoreSelection;

            if(restoreSelection) {
                if(this.caret.selectionIsCollapsed && this.caret.selectionFocusNode.tagName === 'TD') {
                    this.caret.restoreSelection(false, 'TryDOMStrategyFirst');
                } else {
                    this.caret.restoreSelection();
                }
            }

            this.activateInputEventProcessing();

            if(this.unfreezeCallback) {
                this.unfreezeCallback();
                this.unfreezeCallback = null;
            }
            this.isSelectionFreezed = false;
        }
    },

    notifySubscribers: function(modificationLogEntry) {
        this._cleanupModificationLogFromEditorSpecificMarkup(modificationLogEntry);

        const noNoOp = modificationLogEntry.log.find(l => {
            if(l.type === 'retain') {
                return false;
            }

            if(l.type === 'replace' && l.newSectionHTML === l.oldSectionHTML) {
                return false;
            }

            return true;
        })

        if(!noNoOp) {
            this.subscribers.filter(cb => cb.notifyOnMetadataChange).forEach(function(f) {f(modificationLogEntry)});
        } else {
            this.subscribers.forEach(function(f) {f(modificationLogEntry)});
        }
    },

    sectionByChildNode: function(child) {
        while(child) {
            if(this.isSection(child)) {
                return child;
            }
            child = child.parentNode;
        }
    },

    sectionAtCaretPostion: function() {
        return this.sectionByChildNode(this.caret.targetElement());
    },

    areMultipleSectionsSelected: function() {
        var sel = window.getSelection(), s1, s2;

        if(!sel || sel.isCollapsed) { return false }

        s1 = this.sectionByChildNode(sel.anchorNode);
        s2 = this.sectionByChildNode(sel.focusNode);

        return s1 && s2 && s1 !== s2;
    },

    placeCaretIntoSection: function(section, position, doNotFocusSection) {
        if(!section) return;
        position = position || 'end';

        if(position === 'preferredOrBeginning') {
            position = section.sectionType && section.sectionType.preferredCaretPositioning || 'beginning';
        }

        var targetEl = section,
            tmpTargetEl;

        if(section.sectionType && section.sectionType.editableElementSelector) {
            tmpTargetEl = section.querySelector(section.sectionType.editableElementSelector);
            targetEl = tmpTargetEl || section;
        }

        var range = document.createRange(),
            sel = window.getSelection(),
            textNodes = utils.getAllTextNodesOfElement(targetEl),
            textNode = position === 'end' ? textNodes[textNodes.length-1] : textNodes[0];

        // The focus/anchor node should be the deepest node possible.
        // Otherwise the text enrichment controlls will be placed at the wrong
        // position.

        if(position === 'end' && textNode) {
            this.caret.positionAfter(textNode);
        } else {
            range.selectNodeContents(textNode || targetEl);
            range.collapse(position !== 'end');
            sel.removeAllRanges();
            sel.addRange(range);
        }

        if(!doNotFocusSection) {
            this.focusSection(targetEl, {action: 'placeCaretIntoSection'});
        }
    },

    isSection: function(element) {
        return element &&
               element.parentElement === this.contentElement &&
               element.nodeType !== Node.TEXT_NODE;
    },

    focusSection: function(element, args) {
        args = args || {};
        if(!element || !this.isSection(element)) return;
        if(this.focusedElement === element && !args.force) return;
        var isAlreadyHighlighted = element.classList.contains('focused');

        this.unfocusSection();
        this.focusedElement = element;
        this.focusedElement.classList.add('focused');

        this.sectionFocusChangeSubscribers.forEach(function(cb) {cb()});
        this.sectionTypeSelector.displayNextTo(this.focusedElement);

        if(!isAlreadyHighlighted) {
            if(element && element.sectionType && element.sectionType.onFocus) {
                if(!this.areMultipleSectionsSelected()) {
                    element.sectionType.onFocus(element, this, args);
                }
            }
        }
    },

    unfocusSection: function() {
        var self = this,
            focusedSections = this.contentElement.querySelectorAll('.focused');

        focusedSections.forEach(function(sec) {
            if(sec.classList.contains('focused')) {
                sec.classList.remove('focused');

                if(sec.onUnfocus) {
                    sec.onUnfocus(self);
                }
            }
        });

        self.sectionTypeSelector.hide();
        this.focusedElement = null;
    },

    focusedSection: function() {
        return this.focusedElement;
    },

    isFocused: function(section) {
        return section === this.focusedElement;
    },

    moveCaretOneSectionUp: function(position) {
        position = position || 'end';
        var s = this.focusedSection();
        this.placeCaretIntoSection(s && s.previousSibling, position, true);
    },

    moveCaretOneSectionDown: function(position) {
        position = position || 'end';
        var s = this.focusedSection();
        this.placeCaretIntoSection(s && s.nextSibling, position, true);
    },

    moveFocusedSectionUp: function() {
        var focusedSection = this.focusedSection();
        if(focusedSection && focusedSection.previousSibling) {
            this.caret.saveSelection(this.contentElement);

            this.modificationLogEntry = new ModificationLogEntry();
            this.modificationLogEntry.modLogFlags = this.modLogFlags;
            this.modificationLogEntry.retainAllSectionsBefore(focusedSection.previousSibling);
            this.modificationLogEntry.replaceSection(focusedSection.previousSibling, focusedSection);
            this.modificationLogEntry.replaceSection(focusedSection, focusedSection.previousSibling);
            this.modificationLogEntry.retainAllSectionsAfter(focusedSection);

            this.contentElement.insertBefore(focusedSection, focusedSection.previousSibling);
            this.caret.restoreSelection(0, 'DOMStrategy');
            this.notifySubscribers(this.modificationLogEntry);
            this.sectionTypeSelector.displayNextTo(this.focusedSection());
            this.updateFootnotesNumbering();
            this.updateReferenceNumbering();
        }
    },

    moveFocusedSectionDown: function() {
        var focusedSection = this.focusedSection();
        if(focusedSection && focusedSection.nextSibling) {
            this.caret.saveSelection(this.contentElement);

            this.modificationLogEntry = new ModificationLogEntry();
            this.modificationLogEntry.modLogFlags = this.modLogFlags;
            this.modificationLogEntry.retainAllSectionsBefore(focusedSection);
            this.modificationLogEntry.replaceSection(focusedSection, focusedSection.nextSibling);
            this.modificationLogEntry.replaceSection(focusedSection.nextSibling, focusedSection);
            this.modificationLogEntry.retainAllSectionsAfter(focusedSection.nextSibling);

            if(focusedSection.nextSibling.nextSibling) {
                this.contentElement.insertBefore(focusedSection, focusedSection.nextSibling.nextSibling);
            } else  {
                this.contentElement.appendChild(focusedSection);
            }

            this.caret.restoreSelection(0, 'DOMStrategy');
            this.notifySubscribers(this.modificationLogEntry);
            this.sectionTypeSelector.displayNextTo(this.focusedSection());
            this.updateFootnotesNumbering();
            this.updateReferenceNumbering();
        }
    },

    changeFocusedSectionType: function(sectionTypeName, annotation) {
        var focusedSection = this.focusedSection(),
            st = this.supportedSectionTypes[sectionTypeName],
            newEl, sectionCreator, sectionIndex, changedSection,
            self = this, newContent, oldContent, rule;

        if(annotation) {
            annotation = [annotation]
        }

        sectionCreator = (st && st.getSectionElement) || function(existingSectionContent) {
            newContent = self.htmlRazor.cleanupHTML('<' + sectionTypeName + '>' +  existingSectionContent +  '<' + sectionTypeName + '>');
            newContent = newContent.next() || '';
            newContent = newContent.value || '';
            return newContent;
        }

        if(focusedSection) {
            rule = st && Object.values(st.contentRules).find(function(r) { return r.allowedToBeRoot });
            oldContent = focusedSection.innerHTML

            if(focusedSection.tagName === 'PRE' && focusedSection.querySelector('code')) {
                oldContent = focusedSection.querySelector('code').innerText
            }

            newEl = sectionCreator(oldContent, annotation, rule) || document.createElement(sectionTypeName);
            sectionIndex = this.indexOf(focusedSection);
            this.replaceSectionWithHTML(focusedSection, newEl.outerHTML, {action: 'changeFocusedSectionType'});
            utils.copyEventListenersRecursively(newEl, this.contentElement.children[sectionIndex]);
            this.focusSection(newEl, {action: 'changeFocusedSectionType'});
            changedSection = this.contentElement.children[sectionIndex];
        }
    },

    mergeParagraphIntoListIfSectionTypeMatch: function(s1, s2) {
        var liItem, newElement;

        if(s1.tagName !== 'UL' && s1.tagName !== 'OL') {
            return false;
        }

        if(s2.tagName !== 'P') {
            return false;
        }

        newElement = s1.cloneNode(false);
        newElement.innerHTML = s1.innerHTML + '<li>' +  s2.innerHTML + '</li>'
        return newElement;
    },

    mergeSimpleTextSectionsIfSectionTypeMatch: function(s1, s2) {
        if(!s1 || !s2) { return false }

        var s2IsEmpty = s2.innerHTML.trim() === '',
            mergeable = ['P', 'H1', 'H2', 'H3', 'H4', 'H5'],
            newElement;

        if(s2IsEmpty) {
            return s1;
        }

        if(mergeable.includesAll(s1.tagName, s2.tagName)) {
            newElement = s1.cloneNode(false);
            newElement.innerHTML = s1.innerHTML + s2.innerHTML;
            return newElement;
        }
    },

    mergeSections: function(s1, s2) {
        var sectionIndex = this.indexOf(s1),
            s2IsEmpty = s2.innerText.trim() === '',
            newElement;

        newElement = this.mergeParagraphIntoListIfSectionTypeMatch(s1, s2);

        if(!newElement) {
            newElement = this.mergeSimpleTextSectionsIfSectionTypeMatch(s1, s2);
        }

        if(newElement) {
            this.setContent(newElement.outerHTML, { startSection: s1, endSection: s2 });

            if(s2IsEmpty) {
                this.placeCaretIntoSection(this.contentElement.children[sectionIndex]);
            }
        }
    },

    replaceSectionWithHTML: function(oldSection, outerHTML, args) {
        args = args || {};
        args.section = oldSection;
        this.setContent(outerHTML, args);
    },

    content: function(content, args) {
        if(typeof content === 'undefined') {
            return this.getContent();
        } else {
            return this.setContent(content, args);
        }
    },

    getContent: function() {
        return this.getRenderedContent();
    },

    getRenderedContent: function() {
        var result = '',
        section = this.contentElement.children[0];

        while(section) {
            result += this._cleanupHTMLFromEditorSpecificMarkupForSectionHTML(section.outerHTML);
            section = section.nextSibling;
        }

        return result;
    },

    getOriginalContent: function() {
        var result = '',
            section = this.contentElement.children[0];

        while(section) {
            result += this._cleanupHTMLFromEditorSpecificMarkupForSectionHTML(section.originalHTML);
            section = section.nextSibling;
        }

        return result;
    },

    applyChangeset: function(changeset, attr) {
        var i = 0;
        var totalOldContentLength = 0;
        var changesetCursorOldVersion = 0;
        var changesetCursorNewVersion = 0;
        var lengthOfUnchangedSection = 0;
        var lengthOfRemainingContent = 0;
        var changesStartAfter = 0;
        var changesEndAfterInOldVersion = 0;
        var updateStartSection = this.contentElement.children[0];

        for(; i<changeset.length; i++) {
            if(changeset[i].constructor.name !== 'Retain') {
                break;
            }

            changesStartAfter += changeset[i].length;
            changesetCursorOldVersion += changeset[i].length;
        }

        while((lengthOfUnchangedSection + this._cleanupHTMLFromEditorSpecificMarkupForSectionHTML(updateStartSection.originalHTML).length) <= changesStartAfter) {
            if(!updateStartSection.nextSibling) {
                break;
            }

            lengthOfUnchangedSection += this._cleanupHTMLFromEditorSpecificMarkupForSectionHTML(updateStartSection.originalHTML).length;

            updateStartSection = updateStartSection.nextSibling;
        }

        changesetCursorNewVersion = changesetCursorOldVersion;

        for(; i<changeset.length; i++) {
            changesetCursorOldVersion += changeset[i].input;
            changesetCursorNewVersion += changeset[i].output;

            if(changeset[i].constructor.name === 'Skip') {
                changesEndAfterInOldVersion = changesetCursorOldVersion;
            }
        }

        var updateEndSection = updateStartSection;
        var tmpChangesEndPosition = lengthOfUnchangedSection;

        while((tmpChangesEndPosition + this._cleanupHTMLFromEditorSpecificMarkupForSectionHTML(updateEndSection.originalHTML).length) < changesEndAfterInOldVersion) {
            tmpChangesEndPosition += this._cleanupHTMLFromEditorSpecificMarkupForSectionHTML(updateEndSection.originalHTML).length;
            updateEndSection = updateEndSection.nextSibling;
        }

        var oldContent = '';
        var tmpSection = updateStartSection;

        while(tmpSection !== updateEndSection) {
            oldContent += this._cleanupHTMLFromEditorSpecificMarkupForSectionHTML(tmpSection.originalHTML);
            tmpSection = tmpSection.nextSibling;
        }

        oldContent += this._cleanupHTMLFromEditorSpecificMarkupForSectionHTML(updateEndSection.originalHTML);

        tmpSection = tmpSection.nextSibling;

        while(tmpSection) {
            lengthOfRemainingContent += this._cleanupHTMLFromEditorSpecificMarkupForSectionHTML(tmpSection.originalHTML).length;
            tmpSection = tmpSection.nextSibling;
        }

        totalOldContentLength = lengthOfUnchangedSection + oldContent.length + lengthOfRemainingContent;

        if(totalOldContentLength !== changeset.inputLength) {
            throw 'applyChangeset: the given changeset does not match the content length!!';
        }

        const slice = (cangeset, start, end) => {
            let processed = 0;
            let result = Changeset.create();

            for(let op of changeset) {
                let currentOpStart = processed;
                let currentOpEnd = processed + op.input;

                if(currentOpStart < start && currentOpEnd > start) {
                    if(op.constructor.name !== 'Retain') {
                        throw 'Retain operation expected when extracting the changes local to a section'
                    }

                    result.retain(op.input - (start - currentOpStart));
                } else if(currentOpStart >= start && currentOpEnd <= end) {
                    result.ops.push(op);
                } else if(currentOpStart >= start && currentOpStart < end && end < currentOpEnd) {
                    if(op.constructor.name !== 'Retain') {
                        throw 'Retain operation expected when extracting the changes local to a section';
                    }

                    result.retain(op.input - (currentOpEnd-end));

                } else if(currentOpStart > end) {
                   break;
                }

                processed += op.input;
            }

            return result.end();
        }

        var localChangeset = slice(changeset, lengthOfUnchangedSection, lengthOfUnchangedSection+oldContent.length);
        localChangeset.addendum = changeset.addendum;
        localChangeset.removendum = changeset.removendum;

        var newContent = localChangeset.apply(oldContent);

        this.setContent(newContent, {
            ...attr,
            startSection: updateStartSection,
            endSection: updateEndSection
        });
    },

    setContent: function(content, args) {
        args = args || {};

        var insertedContent = args.inputEvent && args.inputEvent.data,
            modificationLogEntry,
            currentCaretPosition,
            beforeStateCaretPosition,
            scrollPosition = this.saveScrollPosition(args.section);

        if(this.caret.isWithinElement(this.contentElement) && args.positionCaretAtTheEndOfSectionWithIndex === undefined) {
            currentCaretPosition = this.caret.saveSelection(this.contentElement, insertedContent),
            beforeStateCaretPosition = this.caretPositions[this.caretPositions.length-1];
        }

        args.modificationLogEntry = args.modificationLogEntry || new ModificationLogEntry();
        args.modificationLogEntry.modLogFlags = this.modLogFlags;

        args.modificationLogEntry.actor = args.actor

        this.caretPositions.push(args.caretPosition || currentCaretPosition);

        modificationLogEntry = this.documentupdater.updateHTML(content, this.focusedSection(), { ...args, caret: this.caret });

        if(modificationLogEntry.focusedSectionHasBeenModified && args.positionCaretAtTheEndOfSectionWithIndex === undefined) {
            if(modificationLogEntry.changeSectionType) {
                args.action = 'changeFocusedSectionType';
            }

            if(!args.caretPosition) {
                if(!modificationLogEntry.focusedSectionDOMWasNotModified || !(currentCaretPosition &&  currentCaretPosition.selectionIsCollapsed)) {

                    if(modificationLogEntry.insertedBeforeSelectionRangeStart) {
                        this.caret.rangeStart += modificationLogEntry.insertedBeforeSelectionRangeStart;
                    }

                    if(modificationLogEntry.insertedBeforeSelectionRangeEnd) {
                        this.caret.rangeEnd += modificationLogEntry.insertedBeforeSelectionRangeEnd;
                    }

                    this.caret.restoreSelection(modificationLogEntry.deletedCharsByMarkupTransformations, 'TryDOMStrategyFirst');
                }

                if(modificationLogEntry.focusedSectionReplacement) {
                    this.focusSection(modificationLogEntry.focusedSectionReplacement, args);
                }
            }
        } else if(args.positionCaretAtTheEndOfSectionWithIndex !== undefined) {
            this.caret.positionAtTheBeginningOf(this.sectionAt(args.positionCaretAtTheEndOfSectionWithIndex));
        }

        if(args.caretPosition) {
            this.caret.restoreSelectionViaOffsetStrategy(0, args.caretPosition);
        }

        this.restoreScrollPostion(modificationLogEntry.focusedSectionReplacement, scrollPosition);

        this.updateFootnotesNumbering();
        this.updateReferenceNumbering();
        this.updateInlineEquationNumbering(modificationLogEntry);

        modificationLogEntry.beforeStateCaretPosition = beforeStateCaretPosition;
        modificationLogEntry.afterStateCaretPosition = args.caretPosition || currentCaretPosition;
        modificationLogEntry.tags = args.modificationLogTags;

        modificationLogEntry.wordCount = this.getWordCount();

        this.showInputTooltipIfContentIsEmpty();

        this.focusSection(this.sectionAtCaretPostion(), args);
        this._removeEmptySectionsExceptOfFocusedSection(modificationLogEntry);
        this.notifySubscribers(modificationLogEntry);

        return modificationLogEntry;
    },

    showInputTooltipIfContentIsEmpty: function() {
        if(this._initDone && this.contentElement.children.length === 1 && this.contentElement.innerText.trim() === '' && this.contentElement.children[0].tagName === 'P') {
            this.containerElement.insertBefore(this.hintEl, this.contentElement);
        } else {
            this.hintEl.remove();
        }
    },

    getWordCount: function() {
        var result = 0;

        for(let i=0; i<this.contentElement.children.length; i++) {
            result += this.contentElement.children[i].wordCount;
        }

        return result;
    },

    saveScrollPosition: function(section) {
        var nestedCodeEl,
            isDiaSection = section && section.classList && section.classList.contains('m2dia'),
            isCodeSection = section && section.tagName === 'PRE';

        if(isDiaSection || isCodeSection) {
            nestedCodeEl = section.querySelector('code');

            return {
                x: window.scrollX,
                y: window.scrollY,
                codeScrollX: nestedCodeEl && nestedCodeEl.scrollLeft
            }
        }
    },

    restoreScrollPostion: function(section, scrollPosition) {
        var nestedCodeEl;
        if(scrollPosition) {
            window.scrollTo(scrollPosition.x, scrollPosition.y);
            if(scrollPosition.codeScrollX && section) {
                nestedCodeEl = section.querySelector('code')
                nestedCodeEl.scrollTo(scrollPosition.codeScrollX, nestedCodeEl.scrollY)
            }
        }
    },

    updateFootnotesNumbering: function() {
        var allFootnotes = this.contentElement.querySelectorAll('.footnote');
        for(var i=0; i<allFootnotes.length; i++) {
            if(allFootnotes[i].innerText !== (i+1).toString()) {
                allFootnotes[i].innerText = (i+1);
            }
        }
    },

    updateReferenceNumbering: function() {
        var refs = this.contentElement.querySelectorAll('.reference');

        for(var i=0; i<refs.length; i++) {
            this.reference.updateRefElement(refs[i]);
        }
    },

    updateInlineEquationNumbering: function(modificationLogEntry) {
        var eqs = this.contentElement.querySelectorAll('inlineequation'),
            latex, self = this;

        for(var i=0; i<eqs.length; i++) {
            let eq = eqs[i]
            eq.innerHTML = '';
            latex = utils.attributeSaveStringToString(eq.dataset.latexequation)

            eq.onclick = eq.onclick || function(e) {
                self.caret.positionAfter(utils.getFirstParentWithTagName(e.target));
            }

            try {
                katex.render(latex, eq, {
                    throwOnError: true,
                    displayMode: false
                });
            } catch (ex) {
                eq.innerHTML = '<span class="error">invalid LaTeX equation</span>';
            }
        }
    },

    shouldSectionBeRemovedIfUnfocused: function(section) {
        return section.innerText.trim() === '' &&
               !section.classList.find(c => c.startsWith('focused-by-api-actor')) &&
               !(this.htmlRazor.getRuleByElement(section).deleteIfEmpty === false);
    },

    deleteNonCollapsedSelectionContent: function(sel) {
        sel = sel || window.getSelection();

        if(!sel) return;

        var s1 = this.sectionByChildNode(sel.anchorNode),
            s2 = this.sectionByChildNode(sel.focusNode),
            i1 = this.indexOf(s1),
            i2 = this.indexOf(s2),
            tmp, newElement;

        if(i1 === undefined || i2 === undefined) return;

        if(i1 > i2) {
            tmp = s1; s1 = s2; s2 = tmp;
        }

        // We have to keep the sections in between the selection in order
        // to caclulate the modificationLogEntry. They will be removed by
        // the setContent function which also calculates the LogEntry.
        this._deleteSelectedTextButKeepAllSelectedSections(s1, s2, sel);

        newElement = s1.cloneNode(false);
        newElement.innerHTML = s1.innerHTML + s2.innerHTML;

        this.setContent(newElement.outerHTML, {startSection: s1, endSection: s2});

        if(!this.sectionAtCaretPostion()) {
            this.placeCaretIntoSection(this.contentElement.lastChild);
        }

        this.setContentEditable(true);
    },

    setFilePersistHandler: function(handler) {
        Object.values(this.supportedSectionTypes)
            .filter(section => section.persistFile)
            .forEach(section => {
                section.persistFile = handler;
        })
    },

    addReferenceData: function(data) {
        this.reference.addReferenceData(data);
        this.updateReferenceNumbering();

        if(this.contentElement.children[0]) {
            this.modificationLogEntry = new ModificationLogEntry();
            this.modificationLogEntry.retainSection(this.contentElement.children[0]);
            this.modificationLogEntry.retainAllSectionsAfter(this.contentElement.children[0]);
            this.modificationLogEntry.mightIncludeReferenceUpdates = true;
            this.notifySubscribers(this.modificationLogEntry);
        }
    },

    _removeEmptySectionsExceptOfFocusedSection: function(finalizedModificationLogEntry) {
        var sections = this.contentElement.children,
            toBeDeleted = [], indexCorrection = 0, oldModLog, deletedSection;

        if(sections.length === 1) return;

        for(let i=0; i<sections.length; i++) {
            if(this.shouldSectionBeRemovedIfUnfocused(sections[i]) &&
               sections[i] !== this.focusedSection()) {
                 toBeDeleted.push({section: sections[i], index: i});
            }
        }

        for(let i=0; i<toBeDeleted.length; i++) {
            deletedSection = this.contentElement.removeChild(toBeDeleted[i].section);
            oldModLog = finalizedModificationLogEntry.deleteSectionAt(toBeDeleted[i+indexCorrection].index, deletedSection);
            if(oldModLog.type === 'insert') {
                indexCorrection--;
            }
        }

        this.sectionTypeSelector.displayNextTo(this.focusedSection());
    },

    // Example: the pipes ("|") show where the selection starts/ends
    // content before execution: <p>section |one</p><p>section two</p><p>section three</p><p>section |four</p>
    // content after execution: <p>section ||</p><p></p><p></p><p>four</p>
    _deleteSelectedTextButKeepAllSelectedSections: function(s1, s2, sel) {
        var inBetweenSections = [],
            i1 = this.indexOf(s1),
            i2 = this.indexOf(s2),
            cec = this.contentElement.children,
            tmp, i, range, selection, lastInsertedDummySection, clonedRange;

        if(i1 > i2) {
            tmp = s1; s1 = s2; s2 = tmp;
            tmp = i1; i1 = i2; i2 = tmp;
        }

        s1.summarizedContentLength = undefined;
        s2.summarizedContentLength = undefined;

        for(i=i1+1 ; i<i2; i++) {
            tmp = cec[i].cloneNode(false);
            tmp.originalHTML = cec[i].originalHTML;
            tmp.summarizedContentLength = undefined;

            Object.keys(this.modLogFlags).forEach(function(flag) {
                tmp['originalHTMLContains' + flag] = cec[i]['originalHTMLContains' + flag];
            });

            inBetweenSections.push(tmp);
        }

        range = sel.getRangeAt(0);
        clonedRange = range.cloneRange();
        range.deleteContents();
        // clonedRange.collapse; ?? why not clonedRange.collapse()
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(clonedRange);

        lastInsertedDummySection = s2;
        while(inBetweenSections.length > 0) {
            tmp = inBetweenSections.pop();
            this.contentElement.insertBefore(tmp, lastInsertedDummySection);
            lastInsertedDummySection = tmp;
        }
    },

    _cleanupHTMLFromEditorSpecificMarkupForSectionHTML: function(HTML) {
        return HTML.replace(/^<([a-zA-Z0-9\-]+?)\s(.*?)>/, (match, tagName, attributes) => {
            attributes = attributes
                .match(/([a-zA-Z0-9\-]+=".*?")|[a-zA-Z0-9\-]*/g)
                .map(x => x.trim())
                .filter(x => x !== '')
                .map(attr => {
                    attr = attr.split('=')

                    if(attr[1]) {
                        attr[1] = attr[1].replace(/^("|')/g, '').replace(/("|')$/g, '')
                    }

                    if(attr[0] === 'class') {
                        attr[1] = attr[1]
                            .split(' ')
                            .map(c => c.trim())
                            .filter(c => c !== 'focused' && !c.startsWith('focused-by-api-actor'))
                            .join(' ')
                    }

                    if(attr[1]) {
                        attr[1] = `"${attr[1].trim()}"`
                    }

                    return attr.join('=')
                })
                .filter(attr => !attr.match(/contenteditable="true"/))
                .filter(attr => attr !== 'class=')
                .join(' ')


            return attributes !== '' ?
                `<${tagName} ${attributes}>` :
                `<${tagName}>`
        }).replaceAll('&nbsp;', ' ');
    },

    _cleanupModificationLogFromEditorSpecificMarkup: function(modificationLogEntry) {
        modificationLogEntry.log.forEach(log => {
            if(log.oldSectionHTML) {
                log.oldSectionHTML = this._cleanupHTMLFromEditorSpecificMarkupForSectionHTML(log.oldSectionHTML);
            }
            if(log.newSectionHTML) {
                log.newSectionHTML = this._cleanupHTMLFromEditorSpecificMarkupForSectionHTML(log.newSectionHTML);
            }
            if(log.sectionHTML) {
                log.sectionHTML = this._cleanupHTMLFromEditorSpecificMarkupForSectionHTML(log.sectionHTML);
            }
        });
    }
}

module.exports = Editor;


/***/ }),

/***/ "../structured-text-editor/src/key_press_handler.js":
/*!**********************************************************!*\
  !*** ../structured-text-editor/src/key_press_handler.js ***!
  \**********************************************************/
/***/ ((module) => {

function KeyPressHandler(editor) {
    var self = this;
    this.editor = editor;

    document.addEventListener("paste", function (e) {
        var pasteData;
        editor.caret.ensureExpandedSelectionIsWithinElement(editor.contentElement);

        if(self.editor.areMultipleSectionsSelected()) {
            self.editor.deleteNonCollapsedSelectionContent();
        }

        if((editor.caret.getContextElement('code') && editor.caret.getContextElement('pre'))
           || editor.caret.getContextElement('caption')
           || editor.caret.getContextElement('citesrc'))
            {
            pasteData = e.clipboardData.getData('text/plain').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            e.preventDefault();
            document.execCommand('inserthtml', false, pasteData);
        }
    });

    document.addEventListener("keydown", function (e) {
        var section, handleEnterKey;

        if(!e.metaKey && !e.ctrlKey) {
            if(e.key === ' ')              { !editor.isContentEditable() && e.preventDefault(); }

            if(e.key === 'Backspace') {
                section = editor.sectionByChildNode(e.target);
                editor.caret.ensureExpandedSelectionIsWithinElement(editor.contentElement);
                if(section && section.onKeyBackspace) {
                    section.onKeyBackspace(e, editor);
                } else {
                    self.handleBackspace(e);
                }
            }

            if(e.key === 'ArrowUp') {
                section = editor.sectionByChildNode(e.target);
                if(section && section.onKeyUp) {
                    section.onKeyUp(e, editor);
                } else {
                    editor.moveCaretOneSectionUp();
                    e.preventDefault();
                }
            }

            if(e.key === 'ArrowDown') {
                section = editor.sectionByChildNode(e.target);
                if(section && section.onKeyDown) {
                    section.onKeyDown(e, editor);
                } else {
                    editor.moveCaretOneSectionDown();
                    e.preventDefault();
                }
            }

            if(e.key === 'Enter') {
                section = editor.sectionByChildNode(e.target);
                handleEnterKey = function() {
                    if(e.shiftKey) {
                        self.handleShiftEnter(e);
                    } else if(section && section.onKeyEnter) {
                        section.onKeyEnter(e, editor);
                    } else if(section) {
                        editor.caret.insertLineBreak();
                        e.preventDefault();
                    }
                }

                if(e.isComposing) {
                    // e.target.dispatchEvent(new CompositionEvent('compositionend'));
                    // window.setTimeout(function() { handleEnterKey() }, 100);
                } else {
                    handleEnterKey();
                }
            }

            if(e.key === 'Tab') {
                section = editor.sectionByChildNode(e.target);
                if(section && section.onKeyTab) {
                    section.onKeyTab(e, editor);
                } else if(section && section.nextSibling && !e.shiftKey) {
                    editor.placeCaretIntoSection(section.nextSibling)
                    e.preventDefault();
                } else if(section && section.previousSibling && e.shiftKey) {
                    editor.placeCaretIntoSection(section.previousSibling)
                    e.preventDefault();
                }
            }

            if(e.key === ' ' && !(e.isComposing || e.keyCode === 229)) {
                section = editor.sectionByChildNode(e.target);
                if(section && !self.editor.caret.isPrecedingCharacterWhitespace(section)) {
                    document.execCommand('insertText', false, self.editor.htmlRazor.temproaryPruneProtectedWhitespace);
                    e.preventDefault();
                }
            }

            //do not handle the keys below if CMD or Control
            //is not pressed at the same time
            return;
        }

        if(e.key === 'Enter')             { self.handleShiftEnter(e); }
        else if(e.key === 'ArrowUp')      { editor.moveFocusedSectionUp(); e.preventDefault(); }
        else if(e.key === 'ArrowDown')    { editor.moveFocusedSectionDown(); e.preventDefault(); }
        else if(e.key === 'i')            { editor.textEnrichmentControl.show(true); e.preventDefault(); }
        else if(e.key === 'a')            { self.handleCmdA(e); }
        else if(e.key === 'z')            { editor.undo(); e.preventDefault(); }
        else if(e.key === 'y')            { editor.redo(); e.preventDefault(); }
        else {
            section = editor.sectionByChildNode(e.target);
            if(section && section.onKeyCombination) {
                section.onKeyCombination(e, editor);
            }
        }

        return true;
    });
}

KeyPressHandler.prototype = {

    handleShiftEnter: function(event) {
        var section = this.editor.sectionByChildNode(event.target);
        this.editor.addNewSectionNextTo(section);
        event.preventDefault();
    },

    handleBackspace: function(event) {
        var sel = window.getSelection(), s1, s2;

        if(!sel) return; //no caret positioned, no deletion required

        if(this.editor.caret.isCollapsedAndPositionedAtTheBeginningOf(this.editor.focusedSection())) {
            s2 = this.editor.sectionByChildNode(sel.anchorNode);
            s1 = s2.previousSibling;
            this.editor.mergeSections(s1, s2);
            event.preventDefault();
        }

        if(this.editor.areMultipleSectionsSelected()) {
            this.editor.deleteNonCollapsedSelectionContent(sel);
            event.preventDefault();
        }

        // for some reason there is a edge case in which the backspace doesn't
        // trigger a selection change and so the controlls will not been hidden
        // by the handler inteded to do this.
        this.editor.textEnrichmentControl.hide();
    },

    handleCmdA: function(event) {
        var elTag = event.target && event.target.tagName;
        var nativeEventHandlingTag = ['TEXTAREA', 'INPUT']

        if(!nativeEventHandlingTag.includes(elTag)) {
            this.editor.selectEverything();
            event.preventDefault();
        }
    }
}

module.exports = KeyPressHandler;


/***/ }),

/***/ "../structured-text-editor/src/references/reference_controller.js":
/*!************************************************************************!*\
  !*** ../structured-text-editor/src/references/reference_controller.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uuid = __webpack_require__(/*! uuid/v1 */ "../structured-text-editor/node_modules/uuid/v1.js");
var lookupRefs = __webpack_require__(/*! ../../lib/lookup_refs */ "../structured-text-editor/lib/lookup_refs/index.js");
var lookupURL = __webpack_require__(/*! ../../lib/lookup_refs/lookup_by_url */ "../structured-text-editor/lib/lookup_refs/lookup_by_url.js");
var throttle = __webpack_require__(/*! ../../lib/throttle/throttle */ "../structured-text-editor/lib/throttle/throttle.js");

var Reference = function(store, editor) {
    this.store = store;
    this.editor = editor;
}

Reference.prototype = {

    addReferenceData: function(data) {
        this.store.addReferenceData(data);
    },

    storeExternalRefData: function(id, attr) {
        this.store.set(id, attr);
        this.editor.referenceInsertedSubscribers.forEach((cb) => {
            cb(id, attr);
        })
    },

    getExternalRefData: function(id) {
        return this.store.get(id);
    },

    getAllExternalRefs: function() {
        return this.store.all(true);
    },

    updateRefElement: function(ref) {
        if(ref.getAttribute('data-external') !== 'true') {
            this.updateInternalRefElement(ref);
        } else {
            this.updateExternalRefElement(ref);
        }
    },

    // Argument: A DOM Element which is a clild element of the editor's content
    // element. The element should have the "data-ref" attribute representing the id
    // of an external reference (external references are books, papers).
    // The function will update the innerHTML of the passed reference element.
    updateExternalRefElement: function(ref) {
        var self = this, tmpContent, refkey, referencee = this.getExternalRefData(ref.getAttribute('data-ref'));

        if(!referencee) {
            ref.classList.add('warning');
            ref.innerHTML = '[<i>not found</i>]';
            return;
        }

        refkey = referencee.author.split(' ').reduce(function(a, e) {return a + (e[0] || '')}, '');
        refkey += '-';
        refkey += referencee.title.split(' ').reduce(function(a, e) {return a + (e[0] || '')}, '');
        refkey += '-';
        refkey += referencee.year;

        tmpContent = '[<i>' + refkey + '</i>]';

        ref.onclick = function() {self.showEditExternalRefDialog(this)};

        if(referencee.author.trim() === '' ||
           referencee.title.trim() === '') {
            ref.classList.add('warning');
        }

        if(ref.innerHTML !== tmpContent) {
            ref.innerHTML = tmpContent;
        }
    },

    // According to updateExternalRefElement but for internal refs, like tables,
    // figures, sections
    updateInternalRefElement: function(ref) {
        var referencee = document.getElementById(ref.getAttribute('data-ref')),
            tmpContent, indexPrefix = '', allSelector;

        if(referencee) {
            allSelector = referencee.tagName;

            if(referencee.tagName === 'FIGURE' || referencee.tagName === 'MERMAID') {
                allSelector = 'FIGURE, MERMAID';
            }

            if(referencee.tagName == 'PRE') {
                allSelector = 'pre.code';
            }

            referenceeIndex = this.editor.contentElement.querySelectorAll(allSelector).indexOf(referencee);

            if(referencee.tagName === 'FIGURE') {
                indexPrefix = 'fig-' + (referenceeIndex+1);
            } else if(referencee.tagName === 'TABLE') {
                indexPrefix = 'table-' + (referenceeIndex+1);
            } else if(referencee.tagName === 'PRE') {
                indexPrefix = 'listing-' + (referenceeIndex+1);
            } else if(referencee.classList.contains('formula')) {
                indexPrefix = 'eq-' + (referenceeIndex+1);
            } else if(referencee.classList.contains('mermaid')) {
                indexPrefix = 'fig-' + (referenceeIndex+1);
            }
            else if(referencee.tagName === 'H2' || referencee.tagName === 'H3' || referencee.tagName === 'H4' || referencee.tagName === 'H5') {
                indexPrefix = 'section: ' + referencee.innerHTML;
            }

            tmpContent = '[<i><a href="#' + referencee.id + '">' + indexPrefix + '</a></i>]';

            if(ref.innerHTML !== tmpContent) {
                ref.innerHTML = tmpContent;
            }

            ref.classList.remove('warning');
        } else {
            ref.innerHTML = '[ref not found]';
            ref.classList.add('warning');
        }
    },

    getRefCaptionHTML: function(referenceEl) {
        var refId = referenceEl.getAttribute('data-ref');
        if(referenceEl.getAttribute('data-external') === 'true') {
            return this.getExternalRefCaptionHTML(refId);
        } else {
            return this.getInternalRefCaptionHTML(document.getElementById(refId));
        }
    },

    getValuesForCrossReferenceSelectBox: function() {
        var result = [],
            internals = this.editor.contentElement.querySelectorAll('figure, table, h2, h3, h4, h5, pre.code, .formula, .mermaid');

        internals = internals.filter(function(int) {
            if(int.tagName === 'FIGURE' && !int.querySelector('figcaption')) {
                return false;
            }

            if(int.tagName === 'TABLE' && !int.querySelector('caption')) {
                return false;
            }

            if(int.tagName === 'PRE' && !int.querySelector('caption')) {
                return false;
            }

            if(int.classList.contains('formula') && !int.querySelector('caption')) {
                return false;
            }

            if(int.classList.contains('mermaid') && !int.querySelector('caption')) {
                return false;
            }

            return true;
        });

        for(var i=0; i<internals.length; i++) {
            result.push([internals[i].id, this.getInternalRefCaptionHTML(internals[i])]);
        }

        return result;
    },

    getValuesForExistingReferenceSelectBox: async function() {
        var result = [],
            allRefs = await this.store.allAsync(true),
            externals = Object.keys(allRefs);

        for(var j=0; j<externals.length; j++) {
            result.push([externals[j], this.getExternalRefCaptionHTML(externals[j], allRefs)]);
        }

        return result;
    },

    areExistingReferencesAvailable: function() {
        var allRefs = this.getAllExternalRefs();

        return allRefs && Object.keys(allRefs).length;
    },

    // returns the caption to display in the reference select box.
    getInternalRefCaptionHTML: function(refereeEl) {
        if(!refereeEl) {
            return '[ref not found]';
        }

        var tmpCaption,
            allSelector = refereeEl.tagName;

        if(refereeEl.tagName === 'FIGURE' || refereeEl.tagName ===  'MERMAID') {
            allSelector = 'FIGURE, MERMAID';
        }

        if(refereeEl.tagName === 'PRE') {
            allSelector = 'pre.code';
        }

        referenceeIndex = this.editor.contentElement.querySelectorAll(allSelector).indexOf(refereeEl);

        if(refereeEl.tagName === 'FIGURE') {
            tmpCaption = refereeEl.querySelector('figcaption').innerHTML;
            return '<b>Image</b> ' + (referenceeIndex+1) + ': ' + tmpCaption;
        } else if(refereeEl.tagName === 'TABLE') {
            tmpCaption = refereeEl.querySelector('caption').innerHTML;
            return '<b>Table</b> ' + (referenceeIndex+1) + ': ' + tmpCaption;
        } else if(refereeEl.tagName === 'H2' || refereeEl.tagName === 'H3' || refereeEl.tagName === 'H4' || refereeEl.tagName === 'H5') {
            return '<b>Section</b>: ' + refereeEl.innerHTML;
        } else if(refereeEl.tagName === 'PRE') {
            tmpCaption = refereeEl.querySelector('caption').innerHTML;
            return '<b>Listing</b> ' + (referenceeIndex+1) + ': ' + tmpCaption;
        } else if(refereeEl.classList.contains('formula')) {
            tmpCaption = refereeEl.querySelector('caption').innerHTML;
            return '<b>Equation</b> ' + (referenceeIndex+1) + ': ' + tmpCaption;
        } else if(refereeEl.classList.contains('mermaid')) {
            tmpCaption = refereeEl.querySelector('caption').innerHTML;
            return '<b>Image</b> ' + (referenceeIndex+1) + ': ' + tmpCaption;
        }
    },

    // returns the caption to display in the reference select box.
    getExternalRefCaptionHTML: function(refereeId, allRefs) {
        var ref = (allRefs || this.getAllExternalRefs())[refereeId];
        if(!ref) { return '' }
        return [ref.author, ref.title, (ref.publisher || ref.journal), ref.year].filter(function (f) { return f !== '' && f }).join(' - ');
    },

    insertInternalReference: function(formData) {
        var node = document.createElement('span');
        node.classList.add('reference');
        node.setAttribute('data-ref', formData.ref);

        if(this.getExternalRefData(formData.ref)) {
            node.setAttribute('data-external', 'true');
        }

        node.setAttribute('contenteditable', false);
        this.editor.caret.insertNode(node);
    },

    insertExternalReference: function(formData) {
        var node = document.createElement('span'),
            refId = uuid(),
            self = this;

        node.classList.add('reference');
        node.setAttribute('contenteditable', false);
        node.setAttribute('data-external', 'true');
        node.setAttribute('data-ref', refId);
        node.onclick = function() {self.showEditExternalRefDialog(this)};
        this.storeExternalRefData(refId, formData);
        this.editor.caret.insertNode(node);
    },

    showEditExternalRefDialog: function(refNode) {
        var refId = refNode.getAttribute('data-ref'),
            ref = this.getExternalRefData(refId),
            self = this;

        if(!ref) { return }

        self.editor.unfocusSection();

        self.editor.displayModal(self.getExternalRefDialogAttributes(ref, refId), function(formData) {
            var section = self.editor.sectionByChildNode(refNode);
            if(section) {
                section.forceUpdateOnInputProcesssingEnablement = true;
            }

            self.storeExternalRefData(refId, formData);
            self.editor.unfreezeSelection();
            self.editor.textEnrichmentControl.hide();

            self.editor.reference.updateRefElement(refNode);
            self.editor.unfocusSection();
            self.editor.caret.clearSelection();
            window.setTimeout(function() {
                self.editor.sectionTypeSelector.hide();
            }, 50)
        });
    },

    getExternalRefDialogAttributes: function(dataRecord, refId) {
        dataRecord = dataRecord || {};

        var self = this;

        var referenceTypes = {
            'Article': {
                required: ['author', 'title', 'journal', 'year'],
                optional: ['volume', 'number', 'pages', 'month', 'subtitle']
            },
            'Book': {
                required: ['author', 'title', 'publisher', 'year'],
                optional: ['editor', 'volume', 'number', 'series', 'edition', 'month', 'subtitle']
            },
            'Conference/Inproceedings': {
                required: ['author', 'title', 'booktitle', 'year'],
                optional: ['editor', 'volume', 'number', 'series', 'pages', 'month', 'organization']
            },
            'Inbook': {
                required: ['title', 'publisher', 'year'],
                optional: ['author', 'editor', 'chapter', 'pages', 'subtitle']
            },
            'Manual': {
                required: ['title'],
                optional: ['author', 'organization', 'edition', 'month', 'year', 'subtitle']
            },
            'Mastersthesis': {
                required: ['author', 'title', 'school', 'year'],
                optional: ['month', 'subtitle']
            },
            'Phdthesis': {
                required: ['author', 'title', 'school', 'year'],
                optional: ['month', 'subtitle']
            },
            'Proceedings': {
                required: ['title', 'year'],
                optional: ['editor', 'volume', 'number', 'series', 'month', 'organization', 'subtitle']
            },
            'Techreport': {
                required: ['author', 'title', 'institution', 'year'],
                optional: ['type', 'number', 'month', 'subtitle']
            },
            'Website': {
                required: ['url'],
                optional: ['author', 'date', 'month', 'year', 'title']
            }
        }

        var allowedTypeValues = Object.keys(referenceTypes)
            .map(rt => [
                rt,
                rt,
                'Type: ' + rt
            ])

        var handleUrlFieldChange = async function (formData, dFrom, triggerElement, allExistingRefs, url) {

            var url = url || formData.url;
            var fields = ['url', 'author', 'title', 'year', 'month']

            if(lookupURL.isValidID(url)) {
                fields.forEach(field => dFrom.setTooltip(field, 'Wait for it ...', '', 'tooltip-loading'))

                try {
                    var urlMeta = await lookupURL.fetchJSON(url);

                    Object.keys(urlMeta).forEach(key => {
                        let field = dFrom.fields.find(f => f.name == key);
                        if(field && field.domElement && field.domElement.setValue && formData[field.name] !== urlMeta[key]) {
                            field.domElement.setValue(urlMeta[key]);
                        }
                    })
                } finally {
                    fields.forEach(field => dFrom.resetTooltip(field));
                    dFrom.resetTooltip('lookupId');
                }
            }
        }

        var handleLookupIdFieldChange = function(formData, dFrom, triggerElement, allExistingRefs) {
            dFrom.setTooltip('lookupId', 'Wait for it ...', '', 'tooltip-loading')

            const similarRef = allExistingRefs.find(ref => (ref.lookupId && ref.lookupId.trim().toLowerCase() === formData.lookupId.trim().toLowerCase()))

            if(formData.lookupId
                && similarRef
                && (!refId || refId !== similarRef.id)) {
                dFrom.setTooltipError('lookupId', 'You already referenced this document before. You can find it in the "Find Reference" tab of this dialog.');
                return;
            }

            var errorText = 'Something went wrong. Maybe the provided DOI / ISBN / Website URL / arXiv ID does not exists?';

            lookupRefs.fetchJSON(formData.lookupId)
                .catch(err => {
                    console.log('error when fetching ref data', err)
                    if(err instanceof lookupRefs.errors.InvalidID) {
                        dFrom.setTooltipWarning('lookupId', 'It needs to be a valid DOI or ISBN');
                    } else if(err instanceof lookupRefs.errors.EmptyID) {
                        dFrom.resetTooltip('lookupId');
                    } else if(err instanceof lookupRefs.errors.NotFound) {
                        dFrom.setTooltipError('lookupId', 'No data found for the given DOI / ISBN');
                    } else {
                        dFrom.setTooltipError('lookupId', errorText);
                    }
                })
                .then(data => {
                    if(data) {
                        dFrom.setTooltip('lookupId', 'MonsterWriter filled out all the information it could find. You can still complete or change the data below.', '&#10003;', 'tooltip-success');

                        Object.keys(data)
                            .map(fieldName => dFrom.fields.find(f => f.name == fieldName))
                            .filter(field => field && field.domElement && field.domElement.setValue)
                            .forEach(field => {
                                if(formData[field.name] !== data[field.name]) {
                                    field.domElement.setValue(data[field.name]);
                                }
                            })
                    }
                }).catch(ex => {
                    dFrom.setTooltipError('lookupId', errorText);
                })
        }

        var handleTitleFieldChange = function (formData, dFrom, triggerElement, allExistingRefs) {
            const similarRef = allExistingRefs.find(ref => (ref.title && ref.title.trim().toLowerCase() === formData.title.trim().toLowerCase()))

            if(formData.title
                && similarRef
                && (!refId || refId !== similarRef.id)) {
                dFrom.setTooltipWarning('title', 'You already referenced a document with the same title. Consider to choose it in the "Find Reference" tab of this dialog.');
                return;
            } else {
                dFrom.resetTooltip('title');
            }
        }

        var onFormChange = throttle(100, function (formData, dFrom, triggerElement) {
            if(!triggerElement) {
                return;
            }

            var allExistingRefs = Object.values(self.getAllExternalRefs());

            if(triggerElement.name === 'lookupId') {
                handleLookupIdFieldChange(formData, dFrom, triggerElement, allExistingRefs);
            } else if(triggerElement.name === 'title') {
                handleTitleFieldChange(formData, dFrom, triggerElement, allExistingRefs);
            } else if(triggerElement.name === 'url') {
                handleUrlFieldChange(formData, dFrom, triggerElement, allExistingRefs);
            }
        });

        return [
            {name: 'lookupId', displayName: 'Automatically Fetch and Fill Out Information By:', tooltip: { text: 'Insert a valid DOI, ISBN, arXiv ID or the URL of a website you want to cite. MonsterWriter will try to find all the information on the internet for you.', inInput: true }, autocomplete: 'off', placeholder: 'ISBN / DOI / arXiv ID / Website URL', onFormChange: onFormChange },
            {name: 'type', displayName: 'Manually Specify Information:', defaultValue: 'Article', allowedValues: allowedTypeValues },
            {name: 'url', placeholder: 'Website URL', tooltip: 'The address of the website.'},
            {name: 'date', placeholder: 'Lookup Date', tooltip: 'The date when you accessed the website. This is usally todays date.', defaultValue: () => (new Date()).getFullYear() + '-' + ((new Date()).getMonth() + 1).toString().padStart(2, '0') + '-' + ((new Date()).getDate()).toString().padStart(2, '0') },
            {name: 'author', placeholder: 'Author(s)', tooltip: 'All authors separated by the word "and". Comma is used to distinguish first and last name. e.g "Wolf, Oliver and Barnett, Phillip".'},
            {name: 'title', placeholder: 'Title', tooltip: 'The title of the reference.'},
            {name: 'subtitle', placeholder: 'Subtitle', tooltip: 'The sub title of the reference.'},
            {name: 'booktitle', placeholder: 'Book Title', tooltip: 'The title of the book.'},
            {name: 'organization', placeholder: 'Organization', tooltip: 'The organization that organizes the conference or publishes the work.'},
            {name: 'journal', placeholder: 'Journal', tooltip: 'The journal that published the article.'},
            {name: 'publisher', placeholder: 'Publisher', tooltip: 'The publisher of the work.'},
            {name: 'school', placeholder: 'School', tooltip: 'The institution in which the author is enrolled.'},
            {name: 'institution', placeholder: 'Institution', tooltip: 'The institution that sponsors the research work.'},
            {name: 'editor', placeholder: 'Editor(s)', tooltip: 'All editors separated by the word "and". Comma is used to distinguish first and last name. e.g "Wolf, Oliver and Barnett, Phillip'},
            {name: 'series', placeholder: 'Series', tooltip: 'The series name of the book/work'},
            {name: 'year', placeholder: 'Year', tooltip: 'The year of the publication consisting of four digits (e.g. "2020").'},
            {name: 'month', placeholder: 'Month', tooltip: 'The month of the publication. Use the three letter abbreviation: Jan. Feb. Mar. Apr. May. Jun. Jul. Aug. Sep. Oct. Nov. Dec.'},
            {name: 'edition', placeholder: 'Edition', tooltip: 'The edition of the publication (e.g. "Second"). The first letter should be capitalized.'},
            {name: 'volume', placeholder: 'Volume', tooltip: 'The volume of the publication.'},
            {name: 'number', placeholder: 'Number', tooltip: 'The work\'s number within a series.'},
            {name: 'chapter', placeholder: 'Chapter', tooltip: 'A chapter if you reference to a particular part of the work.'},
            {name: 'pages', placeholder: 'Pages', tooltip: 'The page number(s) if you reference to a particular part of the work (e.g. "23-50" or "417,423,590-601" or 50+).'},
        ].map(field =>
            Object.assign(field, {
                defaultValue: (dataRecord[field.name] || field.defaultValue || ''),
                isActive: function(formData) {
                    if(field.name === 'type' || field.name === 'lookupId') {
                        return true;
                    }

                    if(!referenceTypes[formData.type]) {
                        return false;
                    }

                    if(referenceTypes[formData.type].required.includes(field.name)) {
                        return true;
                    }

                    if(referenceTypes[formData.type].optional.includes(field.name)) {
                        return true
                    }
                }
            })
        )
    },
}

module.exports = Reference;


/***/ }),

/***/ "../structured-text-editor/src/references/reference_sources/index.js":
/*!***************************************************************************!*\
  !*** ../structured-text-editor/src/references/reference_sources/index.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const referenceSourcesConfig = [
    { id, displayName, isValidRecord, renderEntry, fields, sync } = __webpack_require__(/*! ./zotero_online */ "../structured-text-editor/src/references/reference_sources/zotero_online.js"),
    { id, displayName, isValidRecord, renderEntry, fields, sync } = __webpack_require__(/*! ./zotero_desktop */ "../structured-text-editor/src/references/reference_sources/zotero_desktop.js")
]

async function saveReferenceSources(formData, ReferenceStore) {
    await ReferenceStore.deleteAllSources()
    await Promise.all(formData['reference-sources'].map(async rs => {
        await ReferenceStore.addSource(rs)
    }))

    await ReferenceStore.cleanupReferencesFromSources()
}

const syncAllSources = async function(ReferenceStore) {
    const referenceSources = await ReferenceStore.getAllSources()

    referenceSources.forEach(rcFormData => {
        const rsc = referenceSourcesConfig.find(rs => rs.id === rcFormData.type)

        if(rsc && rsc.sync) {
            rsc.sync(rcFormData, ReferenceStore)
        } else {
            console.log('No reference source implementation for ' + rcFormData.type + ' found')
        }
    })
}

const getReferenceSourcesFields = async function(ReferenceStore) {
    const referenceSources = await ReferenceStore.getAllSources()

    return [
        {
            tab: 'Reference Sources',
            isActive: formData => !formData['reference-sources'] || !formData['reference-sources'].length,
            render: (el, formData) => {
                el.classList.add('integration-info');
                el.innerHTML = 'No integration(s) configured. Click the "Configure New Integration" button below to do so.'
            }
        },
        {
            name: 'reference-sources',
            newButtonLabel: 'Configure New Reference Source',
            tab: 'Reference Sources',
            isValidRecord: (formData, dForm) => {
                const rsc = referenceSourcesConfig.find(rs => rs.id === formData.type)
                return rsc && rsc.isValidRecord(formData, dForm, ReferenceStore)
            },
            renderEntry: (formData, dForm) => {
                const rsc = referenceSourcesConfig.find(rs => rs.id === formData.type)
                return rsc && rsc.renderEntry(formData, dForm)
            },
            defaultValue: referenceSources,
            onChange: formData => saveReferenceSources(formData, ReferenceStore),
            arrayOf: [
                {
                    name: 'type',
                    displayName: 'Source:',
                    allowedValues: referenceSourcesConfig.map(i => [i.id, i.displayName]),
                },
                ...referenceSourcesConfig.flatMap(i => i.fields)
            ]
        }
    ]
}

module.exports = {
    getReferenceSourcesFields,
    syncAllSources
}

/***/ }),

/***/ "../structured-text-editor/src/references/reference_sources/zotero_desktop.js":
/*!************************************************************************************!*\
  !*** ../structured-text-editor/src/references/reference_sources/zotero_desktop.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const throttle = __webpack_require__(/*! ../../../lib/throttle/throttle */ "../structured-text-editor/lib/throttle/throttle.js")

const transformResponseItem = function(item, libraryID, CollectionID) {
    const typeMap = {
        'article-journal': 'Article',
        'article': 'Article',
        'article-magazine': 'Article',
        'article-newspaper': 'Article',
        'bill': 'Article',
        'book': 'Book',
        'broadcast': 'Article',
        'chapter': 'Inbook',
        'classic': 'Article',
        'collection': 'Article',
        'dataset': 'Article',
        'document': 'Article',
        'entry': 'Article',
        'entry-dictionary': 'Article',
        'entry-encyclopedia': 'Website',
        'event': 'Article',
        'figure': 'Article',
        'graphic': 'Article',
        'hearing': 'Article',
        'interview': 'Article',
        'legal_case': 'Article',
        'legislation': 'Article',
        'manuscript': 'Article',
        'map': 'Article',
        'motion_picture': 'Article',
        'musical_score': 'Article',
        'pamphlet': 'Article',
        'paper-conference': 'Conference/Inproceedings',
        'patent': 'Article',
        'performance': 'Article',
        'periodical': 'Article',
        'personal_communication': 'Article',
        'post': 'Website',
        'post-weblog': 'Website',
        'regulation': 'Article',
        'report': 'Article',
        'review': 'Article',
        'review-book': 'Article',
        'software': 'Article',
        'song': 'Article',
        'speech': 'Article',
        'standard': 'Article',
        'thesis': 'Mastersthesis',
        'treaty': 'Article',
        'webpage': 'Website'
    }

    const convertNameValue = nameEntry => {
        return [nameEntry.family, nameEntry.given]
            .filter(f => f && f.trim)
            .map(f => f.trim())
            .filter(f => f !== '')
            .join(', ')
    }

    const tryToParseDate = dateParts => {
        if(dateParts && dateParts['date-parts'] && dateParts['date-parts'][0]) {
            return dateParts['date-parts'][0].join('-')
        }
    }

    const tryToParseYear = dateParts => {
        if(dateParts && dateParts['date-parts'] && dateParts['date-parts'][0] && dateParts['date-parts'][0][0]) {
            return dateParts['date-parts'][0][0].toString()
        }
    }

    const tryToParseMonth = dateParts => {
        if(dateParts && dateParts['date-parts'] && dateParts['date-parts'][0] && dateParts['date-parts'][0][1]) {
            return dateParts['date-parts'][0][1].toString()
        }
    }

    return {
        lookupId: item.ISBN || item.DOI,
        id: item.id,
        type: typeMap[item.type] || 'Article',
        referenceSource: `zotero-desktop-${libraryID}-${CollectionID}`,
        title: item.title,
        author: item.author && item.author.map(convertNameValue).join(' and '),
        pages: item['number-of-pages'],
        volume: item.valume,
        url: item.URL,
        publisher: item.publisher,
        edition: item.edition,
        date: tryToParseDate(item.accessed),
        year: tryToParseYear(item.issued),
        month: tryToParseMonth(item.issued),
        editor: item.editor && item.editor.map(convertNameValue).join(' and '),
    }
}

const renderEntry = function(entry) {
    if(entry.type === 'zotero-desktop') {
        return `Zotero Destkop`
    }
}

const isValidRecord = throttle(100, async function(formData, dFrom, ReferenceStore) {
    window.store = ReferenceStore
    if(formData.type === 'zotero-desktop' && formData['zotero-desktop-libraryID']) {
        var itemResponse;
        try {
            dFrom.setTooltip('zotero-desktop-libraryID', 'Wait for it ...', '', 'tooltip-loading')
            dFrom.setTooltip('zotero-desktop-collectionID', 'Wait for it ...', '', 'tooltip-loading')

            if(formData['zotero-desktop-collectionID'] === 'no-collection') {
                itemResponse = await fetch(`http://127.0.0.1:23119/better-bibtex/export/library?/${formData['zotero-desktop-libraryID']}/library.csljson`)
            } else {
                itemResponse = await fetch(`http://127.0.0.1:23119/better-bibtex/collection?/${formData['zotero-desktop-libraryID']}/${formData['zotero-desktop-collectionID']}.csljson`)
            }

            const items = await itemResponse.json();

            items.forEach(item => {
                ReferenceStore.set(`zotero-desktop-item-${formData['zotero-desktop-libraryID']}-${formData['zotero-desktop-collectionID']}-${item.id}`, transformResponseItem(item, formData['zotero-desktop-libraryID'], formData['zotero-desktop-collectionID']))
            })

            dFrom.resetTooltips(['zotero-desktop-libraryID', 'zotero-desktop-collectionID'])

            const hintField = formData['zotero-desktop-collectionID'] === 'no-collection' ? 'zotero-desktop-libraryID' : 'zotero-desktop-collectionID'
            const hintFieldType = formData['zotero-desktop-collectionID'] === 'no-collection' ? 'library' : 'collection'

            if(!items.length) {
                dFrom.setTooltipWarning(hintField, `No items found in this ${hintFieldType}!`)
            } else {
                dFrom.setTooltipSuccess(hintField, `${items.length} items found.`)
            }

            return true;
        } catch(ex) {
            dFrom.setTooltipError('zotero-desktop-libraryID', `Something went wrong fetching items from Zotero.`)
            dFrom.setTooltipError('zotero-desktop-collectionID', `Something went wrong fetching items from Zotero.`)
            return false
        }
    }
})

const sync = async function(formData, ReferenceStore) {
    if(formData.type === 'zotero-desktop' && formData['zotero-desktop-libraryID']) {
        var itemResponse;
        try {
            if(formData['zotero-desktop-collectionID'] === 'no-collection') {
                itemResponse = await fetch(`http://127.0.0.1:23119/better-bibtex/export/library?/${formData['zotero-desktop-libraryID']}/library.csljson`)
            } else {
                itemResponse = await fetch(`http://127.0.0.1:23119/better-bibtex/collection?/${formData['zotero-desktop-libraryID']}/${formData['zotero-desktop-collectionID']}.csljson`)
            }

            const items = await itemResponse.json();

            items.forEach(item => {
                ReferenceStore.set(`zotero-desktop-item-${formData['zotero-desktop-libraryID']}-${formData['zotero-desktop-collectionID']}-${item.id}`, transformResponseItem(item, formData['zotero-desktop-libraryID'], formData['zotero-desktop-collectionID']))
            })

            return true;
        } catch(ex) {
            return false
        }
    }
}

const fetchLibraries = throttle(100, async function() {
    var response;

    try {
        response = await fetch(`http://localhost:23119/better-bibtex/json-rpc`, {
            method: 'POST',
            body: JSON.stringify({ jsonrpc: "2.0", method: "user.groups", params: [true] }),
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json',
            },
        })
    } catch(ex) {
        throw { message: 'Make sure you have startet the Zotero desktop app' }
    }

    if(response.status === 404) {
        throw { message: 'Make sure you have the "Better BibTeX for Zotero" add-on installed in Zotero. You can download it here: https://retorque.re/zotero-better-bibtex/installation/' }
    } else if(response.status === 500) {
        throw { message: 'Make sure you have at least version <b>6.7.1</b> of "Better BibTeX for Zotero" installed. You can download it here: https://retorque.re/zotero-better-bibtex/installation/' }
    }

    if(response.status !== 200) {
        throw { message: 'Something went wrong fetching items from Zotero' }
    }

    var jsonResponse = (await response.json())

    if(!jsonResponse.result) {
        throw { message: 'Something went wrong fetching items from Zotero. Please send the following error test to info@monsterwriter.app: ' + JSON.stringify(jsonResponse.error) }
    }

    if(jsonResponse.result.length === 0) {
        throw { message: 'No libraries available!' }
    }

    return jsonResponse.result
})

const onValuesCalculationFailedMessage = function(fromData, err) {
    return {
        level: err.level || 'error',
        text: err.message || 'Something went wrong fetching items from Zotero.'
    }
}

const fields = [
    {
        name: 'zotero-desktop-libraryID',
        displayName: 'Library',
        tooltip: 'Choose a library from your local Zotero installation',
        isActive: formData => formData['type'] === 'zotero-desktop',
        onValuesCalculationFailedMessage,
        allowedValues: async () => (await fetchLibraries()).map(lib => [lib.id, lib.name]),
    },
    {
        name: 'zotero-desktop-collectionID',
        displayName: 'Collection',
        reloadOnChangeOf: ['zotero-desktop-libraryID'],
        tooltip: 'Choose a collection from your local Zotero installation',
        isActive: formData => formData['type'] === 'zotero-desktop',
        defaultValue: 'no-collection',
        onValuesCalculationFailedMessage,
        allowedValues: async formData => {
            if(!formData['zotero-desktop-libraryID']) {
                throw { message: 'Choose a library first!' }
            }

            var libraries = await fetchLibraries()
            var library = libraries.find(lib => lib.id.toString() === formData['zotero-desktop-libraryID'])

            if(!library.collections || !library.collections.length) {
                throw { message: 'No collections available in the choosen library!' }
            }

            return [
                ['no-collection', 'Entire Library'],
                ...library.collections.map(col => [ col.key, col.name ])
            ]
        },
    }
]

module.exports = {
    id: 'zotero-desktop',
    displayName: 'Zotero (Desktop via Better BibTeX Add-On)',
    isValidRecord,
    renderEntry,
    fields,
    sync
}

/***/ }),

/***/ "../structured-text-editor/src/references/reference_sources/zotero_online.js":
/*!***********************************************************************************!*\
  !*** ../structured-text-editor/src/references/reference_sources/zotero_online.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const throttle = __webpack_require__(/*! ./../../../lib/throttle/throttle */ "../structured-text-editor/lib/throttle/throttle.js")
const { ZoteroOnline } = __webpack_require__(/*! ./../../../lib/zotero-client */ "../structured-text-editor/lib/zotero-client/index.js")
var latestLoadedGroups = [], clientsWithoutStore = {}

const isValidRecord = throttle(100, async function(formData, dFrom, ReferenceStore) {
    if(formData.type === 'zotero-online') {
        const isGroup = formData['zotero-online-userOrGroup'] === 'group'

        if(formData['zotero-online-apiKey'].trim() === '') {
            dFrom.setTooltipWarning('zotero-online-apiKey', 'An Zotero API key is needed. You can create an API key here: https://www.zotero.org/settings/keys')
            return false
        }

        if(isGroup && formData['zotero-online-groupID'] === '') {
            dFrom.setTooltipWarning('zotero-online-groupID', 'Choose a group from which you want to retrieve references from. If you do not want to retrieve references from a Zotero group choose "User" in "User or Group Scoped Integration"')
            return false
        }

        try {
            dFrom.setTooltip('zotero-online-apiKey', 'Wait for it ...', '', 'tooltip-loading')

            const zoteroOnlineClient = new ZoteroOnline(formData['zotero-online-apiKey'], ReferenceStore)
            await zoteroOnlineClient.loadUserInfo()

            const itemCount = (isGroup ?
                await zoteroOnlineClient.itemsByGroupID(formData['zotero-online-groupID']) :
                await zoteroOnlineClient.items()).length

            dFrom.resetTooltips(['zotero-online-groupID', 'zotero-online-apiKey'])

            if(itemCount) {
                dFrom.setTooltipSuccess('zotero-online-apiKey', `${itemCount} items have been fetched from Zotero`)
            } else {
                dFrom.setTooltipWarning('zotero-online-apiKey', 'It seems like this user or group does not has any items saved')
            }

            return true
        } catch(err) {
            console.log(err)
            const errorText = `There was an error connecting to Zotero. Make sure ${isGroup ? 'Group' : 'User'} ID and API Key are correct!`
            dFrom.setTooltipError('zotero-online-apiKey', errorText)
            return false
        }
    }
})

const sync = async function(formData, ReferenceStore) {
    if(formData.type === 'zotero-online') {
        const isGroup = formData['zotero-online-userOrGroup'] === 'group'

        if(formData['zotero-online-apiKey'].trim() === '') {
            return false
        }

        if(isGroup && formData['zotero-online-groupID'] === '') {
            return false
        }

        try {
            const zoteroOnlineClient = new ZoteroOnline(formData['zotero-online-apiKey'], ReferenceStore)
            await zoteroOnlineClient.loadUserInfo()

            if(isGroup) {
                await zoteroOnlineClient.itemsByGroupID(formData['zotero-online-groupID'])
            } else {
                await zoteroOnlineClient.items()
            }

            return true
        } catch(err) {
            console.log(err)
            return false
        }
    }
}

const getClientWithoutStore = async function(apiKey) {
    if(!clientsWithoutStore[apiKey]) {
        clientsWithoutStore[apiKey] = []
        clientsWithoutStore[apiKey][0] = new ZoteroOnline(apiKey)
        clientsWithoutStore[apiKey][1] = clientsWithoutStore[apiKey][0].loadUserInfo()
    }

    await clientsWithoutStore[apiKey][1]

    return clientsWithoutStore[apiKey][0]
}

const renderEntry = function(entry) {
    if(entry.type === 'zotero-online') {
        const isGroup = entry['zotero-online-userOrGroup'] === 'group'
        const userOrGroup = entry['zotero-online-userOrGroup'].charAt(0).toUpperCase() + entry['zotero-online-userOrGroup'].slice(1)
        var displayName = ''

        if(!isGroup) {
            displayName = entry['zotero-online-userName']
        } else if(isGroup) {
            displayName = entry['zotero-online-groupName']
        }

        return `Zotero.org (Online) - ${userOrGroup}: ${displayName}`
    }
}

const fields = [
    {
        name: 'zotero-online-userOrGroup',
        displayName: 'Zotero Library Type:',
        isActive: formData => formData['type'] === 'zotero-online',
        allowedValues: [['user', 'User'], ['group', 'Group']],
        defaultValue: 'user',
    },
    {
        name: 'zotero-online-apiKey',
        isActive: formData => formData['type'] === 'zotero-online',
        displayName: 'API Key:',
        inputType: 'password',
        tooltip: 'You can create an API key here: https://www.zotero.org/settings/keys',
    },
    {
        name: 'zotero-online-userID',
        reloadOnChangeOf: ['zotero-online-apiKey'],
        calculate: async formData => {
            if(!formData || !formData['zotero-online-apiKey'] || formData['zotero-online-apiKey'] === '') {
                return;
            }

            const client = await getClientWithoutStore(formData['zotero-online-apiKey'])
            return client.userID
        }
    },
    {
        name: 'zotero-online-userName',
        reloadOnChangeOf: ['zotero-online-apiKey'],
        calculate: async formData => {
            if(!formData || !formData['zotero-online-apiKey'] || formData['zotero-online-apiKey'] === '') {
                return;
            }

            const client = await getClientWithoutStore(formData['zotero-online-apiKey'])
            return client.userName
        }
    },
    {
        name: 'zotero-online-groupName',
        reloadOnChangeOf: ['zotero-online-apiKey', 'zotero-online-userOrGroup', 'zotero-online-groupID'],
        calculate: formData => {
            if(!latestLoadedGroups
                || !latestLoadedGroups.find
                || !formData
                || !formData['zotero-online-groupID']
                || formData['zotero-online-userOrGroup'] === 'user') {
                return;
            }

            const group = latestLoadedGroups.find(gr => gr.id.toString() === formData['zotero-online-groupID'].toString())

            if(group) {
                return group.name
            }
        }
    },
    {
        name: 'zotero-online-groupID',
        displayName: 'Group',
        tooltip: 'If you want to cite references which are managed in a Zotero group, select the group here. If not, select "User" in "User or Group Scoped Integration"',
        isActive: formData => formData['type'] === 'zotero-online' && formData['zotero-online-userOrGroup'] === 'group',
        reloadOnChangeOf: ['zotero-online-apiKey', 'zotero-online-userOrGroup'],
        allowedValues: async formData => {
            if(!formData
                || !formData['zotero-online-apiKey']
                || formData['zotero-online-apiKey'].trim() === ''
                || formData['zotero-online-userOrGroup'] !== 'group') {
                return []
            }

            const client = await getClientWithoutStore(formData['zotero-online-apiKey'])
            latestLoadedGroups = await client.groups()

            return latestLoadedGroups.map(r => [r.id, r.name])
        },
    }
]

module.exports = {
    id: 'zotero-online',
    displayName: 'Zotero.org (Cloud Version)',
    isValidRecord,
    renderEntry,
    fields,
    sync
}

/***/ }),

/***/ "../structured-text-editor/src/references/reference_store.js":
/*!*******************************************************************!*\
  !*** ../structured-text-editor/src/references/reference_store.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const throttle = __webpack_require__(/*! ../../lib/throttle/throttle */ "../structured-text-editor/lib/throttle/throttle.js");
const escapeID = id => id.replace(/[^a-zA-Z0-9\-]/g, "x");

class SimplePersitencyDriver {
    constructor() {
        this.data = {}
    }

    async set(id, attr) {
        this.data[id] = { id, ...attr }
        return this.data[id]
    }

    async all() {
        return Object.values(this.data)
    }

    async get(id) {
        return this.data[id]
    }

    async deleteAll() {
        this.data = {}
    }
}

class ReferenceStore {

    static citedInCurrentDocument() {
        if(document && document.querySelectorAll) {
            return document
                .querySelectorAll('.reference[data-external="true"]')
                .map(el => el.dataset.ref)
        }

        return []
    }

    static isCitedInCurrentDocument(id) {
        return ReferenceStore.citedInCurrentDocument().includes(id)
    }

    //FIXME: make this calculated attribute of formData
    static getSourceID(formData) {
        if(formData['type'] === 'zotero-online') {
            if(formData['zotero-online-userOrGroup'] === 'user') {
                return `zotero-online-user-${formData['zotero-online-userID']}`
            } else if(formData['zotero-online-userOrGroup'] === 'group') {
                return `zotero-online-group-${formData['zotero-online-groupID']}`
            }
        } else if(formData['type'] === 'zotero-desktop') {
            return `zotero-desktop-${formData['zotero-desktop-libraryID']}-${formData['zotero-desktop-collectionID']}`
        }
    }

    constructor(contentId, PersitencyDriver = SimplePersitencyDriver) {
        this.contentId = contentId
        this.data = {}
        this.persistentReferenceStore = new PersitencyDriver('reference')
        this.persistentReferenceSourceStore = new PersitencyDriver('reference_sources')
    }

    initCache = throttle(100, async () => {
        const allRefsFromStore = await this.persistentReferenceStore.all({ updatedSince: this.lastCacheUpdate })
        this.lastCacheUpdate = Date.now()

        allRefsFromStore
            .filter(r => (r.contentId === this.contentId || r.referenceSource !== 'intern'))
            .forEach(r => { this.data[r.id] = r })
    })

    set(id, attr) {
        id = escapeID(id)

        var filteredAttr = {
            ...attr,
            contentId: this.contentId,
            lookupId: (attr.lookupId || '').trim(),
            url: (attr.url || '').trim(),
            date: (attr.date || '').trim(),
            type: (attr.type || '').trim(),
            author: (attr.author || '').trim(),
            title: (attr.title || '').trim(),
            subtitle: (attr.subtitle || '').trim(),
            booktitle: (attr.booktitle || '').trim(),
            organization: (attr.organization || '').trim(),
            journal: (attr.journal || '').trim(),
            publisher: (attr.publisher || '').trim(),
            school: (attr.school || '').trim(),
            institution: (attr.institution || '').trim(),
            editor: (attr.editor || '').trim(),
            series: (attr.series || '').trim(),
            year: (attr.year || '').trim(),
            month: (attr.month || '').trim(),
            edition: (attr.edition || '').trim(),
            volume: (attr.volume || '').trim(),
            number: (attr.number || '').trim(),
            chapter: (attr.chapter || '').trim(),
            pages: (attr.pages || '').trim(),
            _deleted: false,
            id: id
        }

        this.data[id] = filteredAttr

        return this.persistentReferenceStore.set(id, filteredAttr)
    }

    get(id) {
        id = escapeID(id)

        return this.data[id]
    }

    delete(id) {
        id = escapeID(id)

        this.data[id]._deleted = true

        this.persistentReferenceStore.get(id).then(item => {
            this.persistentReferenceStore.set(id, {
                ...item,
                _deleted: true
            })
        })
    }

    all(withID) {
        var result = {}

        Object.keys(this.data).forEach(refId => {
            if(!this.isRefEmpty(refId) && (!this.data[refId]._deleted || ReferenceStore.isCitedInCurrentDocument(refId))) {
                result[refId] = this.data[refId]

                if(withID) {
                    result[refId].id = refId;
                }
            }
        })

        return result;
    }

    addReferenceData(data) {
        Object.entries(data).forEach(refRecord => {
            this.set(refRecord[0], refRecord[1]);
        })
    }

    async allAsync(withID) {
        var result = {}

        Object.keys(this.data).forEach(refId => {
            if(!this.isRefEmpty(refId) && (!this.data[refId]._deleted || ReferenceStore.isCitedInCurrentDocument(refId))) {
                result[refId] = this.data[refId]

                if(withID) {
                    result[refId].id = refId;
                }
            }
        })

        return result;
    }

    isRefEmpty(id) {
        id = escapeID(id)

        var record = this.data[id];

        return record.author === ''
            && record.title === ''
            && record.url === '';
    }

    async deleteAllSources() {
        await this.persistentReferenceSourceStore.deleteAll()
    }

    async addSource(attr) {
        const id = ReferenceStore.getSourceID(attr)

        if(!id) {
            throw "unable to save reference source"
        }

        await this.persistentReferenceSourceStore.set(id, attr)

        const allrefs = (await this.persistentReferenceStore.all())
            .filter(r => r.id && r.id.startsWith(`zotero-online-item-${id.split('-')[3]}`) && r._deleted)

        await Promise.all(allrefs.map(item => this.set(item.id, item)))
    }

    async cleanupReferencesFromSources() {
        const allSourceIds = (await this.getAllSources()).map(src => src.id)
        const allRefs = this.all(true)

        const refsToBeDeleted = Object.values(allRefs)
            .filter(ref => {
                if(!ref.referenceSource || ref.referenceSource === 'intern') {
                    return false
                }

                return !allSourceIds.find(srcId => srcId === ref.referenceSource)
            })

        refsToBeDeleted.forEach(ref => {
            this.delete(ref.id)
        })
    }

    async getAllSources() {
        return await this.persistentReferenceSourceStore.all()
    }
}

module.exports = ReferenceStore;

/***/ }),

/***/ "../structured-text-editor/src/section_type_selector_control.js":
/*!**********************************************************************!*\
  !*** ../structured-text-editor/src/section_type_selector_control.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var utils = __webpack_require__(/*! ../lib/pixelschubser/utils */ "../structured-text-editor/lib/pixelschubser/utils.js"),
    DeclarativForm = __webpack_require__(/*! ../lib/declarativ_forms/src/declarativ_form */ "../structured-text-editor/lib/declarativ_forms/src/declarativ_form.js");

function SectionTypeSelectorControl(onChangeCallback, onChangeCallbackContext, editor) {
    var self = this;

    this.editor = editor;
    this.sectionTypeSelector = document.createElement('div');
    this.sectionTypeSelector.id = 'sectionTypeSelector';

    this.sectionTypeSelector.innerHTML = '<span class="option-btn delete-option-btn" data-option-for="img"><i class="fas fa-trash"></i></span>' +
                                         '<span class="option-btn delete-option-btn" data-option-for="table"><i class="fas fa-trash"></i></span>' +
                                         '<span class="option-btn delete-option-btn" data-option-for="code"><i class="fas fa-trash"></i></span>' +
                                         '<span class="option-btn delete-option-btn" data-option-for="toc"><i class="fas fa-trash"></i></span>' +
                                         '<span class="option-btn delete-option-btn" data-option-for="bquote"><i class="fas fa-trash"></i></span>' +
                                         '<span class="option-btn delete-option-btn" data-option-for="bibliographie"><i class="fas fa-trash"></i></span>' +
                                         '<span class="option-btn delete-option-btn" data-option-for="footnotes"><i class="fas fa-trash"></i></span>' +
                                         '<span class="option-btn delete-option-btn" data-option-for="formula"><i class="fas fa-trash"></i></span>' +
                                         '<span class="option-btn delete-option-btn" data-option-for="mermaid"><i class="fas fa-trash"></i></span>' +
                                         '<span class="option-btn config-option-btn" data-option-for="code"><i class="fas fa-cog"></i></span>' +
                                         '<span class="option-btn config-option-btn" data-option-for="table"><i class="fas fa-cog"></i></span>' +
                                         '<span class="option-btn config-option-btn" data-option-for="img"><i class="fas fa-cog"></i></span>' +
                                         '<span class="option-btn config-option-btn" data-option-for="bquote"><i class="fas fa-cog"></i></span>' +
                                         '<span class="option-btn config-option-btn" data-option-for="bibliographie"><i class="fas fa-cog"></i></span>' +
                                         '<span class="option-btn config-option-btn" data-option-for="footnotes"><i class="fas fa-cog"></i></span>' +
                                         '<span class="option-btn config-option-btn" data-option-for="formula"><i class="fas fa-cog"></i></span>' +
                                         '<span class="option-btn config-option-btn" data-option-for="mermaid"><i class="fas fa-cog"></i></span>' +
                                         '<span class="option-btn config-option-btn" data-option-for="h2"><i class="fas fa-cog"></i></span>' +
                                         '<span class="sectionTypeBtn" data-type="h1">title</span>' +
                                         '<span class="sectionTypeBtn" data-type="h2" unannotated-caption="h1" unactive-caption="heading-1">heading-1</span>' +
                                         '<span class="sectionTypeBtn" data-type="h3" unannotated-caption="h2" unactive-caption="heading-2">heading-2</span>' +
                                         '<span class="sectionTypeBtn" data-type="h4" unannotated-caption="h3" unactive-caption="heading-3">heading-3</span>' +
                                         '<span class="sectionTypeBtn" data-type="h5" unannotated-caption="h4" unactive-caption="heading-4">heading-4</span>' +
                                         '<span class="sectionTypeBtn" data-type="p">paragraph</span>'+
                                         '<span class="sectionTypeBtn notChangeable" data-type="bquote" unannotated-caption="quote" unactive-caption="blockquote">blockquote</span>'+
                                         '<span class="sectionTypeBtn notChangeable" data-type="table">table</span>' +
                                         '<span class="sectionTypeBtn" data-type="code" data-section-tag="pre" unannotated-caption="code">code</span>' +
                                         '<span class="sectionTypeBtn notChangeable" data-type="ul" unannotated-caption="list" unactive-caption="unordered-list">unordered-list</span>' +
                                         '<span class="sectionTypeBtn notChangeable" data-type="ol" unannotated-caption="list" unactive-caption="ordered-list">ordered-list</span>' +
                                         '<span class="sectionTypeBtn notChangeable" data-type="img" data-section-tag="figure">image</span>' +
                                         '<span class="sectionTypeBtn notChangeable" data-type="formula">formula</span>' +
                                         '<span class="sectionTypeBtn notChangeable" data-type="mermaid">mermaid</span>' +
                                         '<span class="sectionTypeBtn notChangeable" data-type="toc" data-section-tag="nav">toc</span>' +
                                         '<span class="sectionTypeBtn notChangeable" data-type="bibliographie" unannotated-caption="bib" unactive-caption="bibliographie">bibliographie</span>' +
                                         '<span class="sectionTypeBtn" data-type="h2(abstract)">abstract</span>' +
                                         '<span class="sectionTypeBtn" data-type="h2(declaration)">declaration</span>' +
                                         '<span class="sectionTypeBtn" data-type="h2(appendix)">appendix</span>' +
                                         '<span class="sectionTypeBtn" data-type="h2(acknowledgement)">acknowledgement</span>' +
                                         '<span class="sectionTypeBtn notChangeable" data-type="footnotes">footnotes</span>';

    this.buttons = Array.prototype.slice.call(this.sectionTypeSelector.children);

    this.sectionTypeSelector.onmouseover = function(e) {
        var isTypeBtn = e.target.classList.contains('sectionTypeBtn');

        if(e.target.id === 'sectionTypeSelector') { return }

        self.buttons.forEach(function(b) {
            isTypeBtn ? b.classList.add('hover') : b.classList.remove('hover');
        });
    }

    this.sectionTypeSelector.onmouseleave = function(e) {
        self.buttons.forEach(function(b) { b.classList.remove('hover') });
    }

    this.buttons.filter(function(btn) {
        return btn.classList.contains('delete-option-btn');
    }).forEach(function(btn) {
        btn.onclick = function() {
            if(self.editor) {
                if(self.sectionElement.onUnfocus) {
                    self.sectionElement.onUnfocus(self.editor)
                }

                self.editor.removeSection(self.sectionElement);
            } else {
                self.sectionElement.parentElement.removeChild(self.sectionElement);
            }

            self.hide();
        }
    });

    this.buttons.filter(function(btn) {
        return btn.classList.contains('config-option-btn');
    }).forEach(function(btn) {
        btn.addEventListener("click", function(){
            if(self.sectionElement.sectionType && self.sectionElement.sectionType.getOptions) {
                var form = new DeclarativForm({fields: self.sectionElement.sectionType.getOptions(self.sectionElement)}, function(formData) {
                    self.sectionElement.sectionType.onOptionsChange(formData, self.editor)
                    self.update();
                });

                form.openInModal();
            }
        });
    });

    this.sectionTypeSelector.addEventListener('click', function(e) {
        var clickedButton = e.target,
            currentSectionBtn = clickedButton.parentNode.querySelector('.sectionTypeBtn.active'),
            currentSectionIsChangeable = currentSectionBtn && !currentSectionBtn.classList.contains('notChangeable'),
            annotation, sectionTypeName;

        if(clickedButton.dataset.type && currentSectionIsChangeable) {
            sectionTypeName = clickedButton.dataset.type.split(/\(|\)/)[0];
            annotation = clickedButton.dataset.type.split(/\(|\)/)[1];
            onChangeCallback.apply(onChangeCallbackContext, [sectionTypeName, annotation]);
            self.setActiveSelection(clickedButton.dataset.sectionTag || clickedButton.dataset.type);
        }
    });

    document.body.appendChild(this.sectionTypeSelector);
}

SectionTypeSelectorControl.prototype = {
    getSectionTypeBySectionTag: function(sectionTag) {
        var btn = this.buttons.find(function (btn) {
            return btn.dataset.sectionTag === sectionTag || btn.dataset.type === sectionTag;
        });

        return btn && btn.dataset && btn.dataset.type;
    },

    setActiveSelection: function(sectionTag) {
        var self = this,
            unannotatedCaption,
            unactiveCaption,
            captionAnnotation,
            activeBtn;

        this.buttons.forEach(function(btn) {
            btn.classList.remove('active');
            btn.classList.remove('unusable');
            var tagName = btn.dataset.sectionTag || btn.dataset.type;

            unannotatedCaption = btn.getAttribute('unannotated-caption');
            unactiveCaption = btn.getAttribute('unactive-caption');

            if(unannotatedCaption) {
                btn.innerHTML = unannotatedCaption;
            }

            if(tagName === sectionTag || btn.dataset.optionFor === self.getSectionTypeBySectionTag(sectionTag)) {
                btn.classList.add('active');
                activeBtn = btn;
                if(unannotatedCaption &&
                   self.sectionElement &&
                   self.sectionElement.sectionType &&
                   self.sectionElement.sectionType.getSectionTypeCaptionAnnotation) {
                    captionAnnotation = self.sectionElement.sectionType.getSectionTypeCaptionAnnotation(self.sectionElement);
                }
            } else if (unactiveCaption) {
                btn.innerHTML = unactiveCaption;
            }

            if(captionAnnotation) {
                btn.innerHTML = unannotatedCaption + '<span class="annotation">(' + captionAnnotation + ')<span>';
            }

            captionAnnotation = undefined;
            unactiveCaption = undefined;
        });

        if(activeBtn.classList.contains('notChangeable')) {
            this.buttons.forEach(function(btn) {
                if(btn !== activeBtn) {
                    btn.classList.add('unusable');
                }
            });
        }
    },

    hide: function() {
        var sectionTypeSelectorElement = document.getElementById('sectionTypeSelector');
        sectionTypeSelectorElement.style.left = -1000 + 'px';
        sectionTypeSelectorElement.style.top = -1000 + 'px';
    },

    update: function() {
        var sectionElement = self.editor.focusedSection();
        if(sectionElement && sectionElement.tagName) {
            this.setActiveSelection(sectionElement.tagName.toLowerCase());
        }
    },

    displayNextTo: function(sectionElement, skipAnimation) {
        if(!sectionElement) return false;

        var self = this,
            sectionPosition = utils.getElementPosition(sectionElement),
            sectionTypeSelectorElement = document.getElementById('sectionTypeSelector'),
            sectionElementTopMargin = parseInt(window.getComputedStyle(sectionElement).getPropertyValue('margin-top').replace('px', '')),
            posX = sectionPosition.x,
            posY = sectionPosition.y,
            minY = window.scrollY + sectionElementTopMargin + 5, //add 5px so that there is a small room between the end of the browser screen and the selector button
            maxY = sectionElement.offsetHeight + sectionElement.offsetTop - sectionTypeSelectorElement.children[0].offsetHeight - 30,
            executeUpdate;

        posY = posY < minY ? minY : posY;
        posY = posY > maxY ? maxY : posY;

        this.sectionElement = sectionElement;
        this.setActiveSelection(sectionElement.tagName.toLowerCase());

        if(this.displaySectionTypeSelectorTimeout)
            clearTimeout(this.displaySectionTypeSelectorTimeout);

        executeUpdate = function() {
            sectionTypeSelectorElement.style.left = posX + 'px';
            sectionTypeSelectorElement.style.top = posY + 'px';
            if(utils.getDistanceToRightWindowBorder(self.editor.containerElement) < 150) {
                sectionTypeSelectorElement.classList.add('lessSpace');
            } else {
                sectionTypeSelectorElement.classList.remove('lessSpace');
            }
        }

        if(skipAnimation) {
            executeUpdate()
        } else {
            this.displaySectionTypeSelectorTimeout = setTimeout(executeUpdate, 10);
        }

    }
}

module.exports = SectionTypeSelectorControl;


/***/ }),

/***/ "../structured-text-editor/src/section_types/bibliographie/bibliographie_section_type.js":
/*!***********************************************************************************************!*\
  !*** ../structured-text-editor/src/section_types/bibliographie/bibliographie_section_type.js ***!
  \***********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uuid = __webpack_require__(/*! uuid/v1 */ "../structured-text-editor/node_modules/uuid/v1.js");

function getSectionElement() {
    var  el = document.createElement('bibliographie'),
         heading = document.createElement('h2'),
         content = document.createElement('div');
    el.classList.add('bibliographie');
    heading.classList.add('bibliographie-heading');
    content.classList.add('bibliographie-content');

    el.setAttribute('contenteditable', 'false');
    heading.setAttribute('contenteditable', 'true');
    content.setAttribute('contenteditable', 'false');

    heading.innerHTML = 'Bibliography';

    el.sectionType = module.exports;
    el.onFocus = module.exports.onFocus;
    el.onKeyBackspace = module.exports.onKeyBackspace;

    el.appendChild(heading);
    el.appendChild(content);

    return el;
}

Object.assign(module.exports, {

    name: 'bibliographie',

    preferredCaretPositioning: 'end',

    editableElementSelector: 'h2',

    contentRules: {
        'bibliographie': {
            tagName: 'bibliographie',
            allowedAttributes: ['class', 'contenteditable'],
            allowedClassNames: ['focused'],
            allowedChildren: ['bibliographie-heading', 'bibliographie-content'],
            allowedToBeRoot: true,
            deleteIfEmpty: false,
            doNotBreakOutRootElements: true,
            buildEmptyElement: getSectionElement
        },

        'bibliographie-heading': {
            tagName: 'h2',
            className: 'bibliographie-heading',
            allowedAttributes: ['id', 'class', 'contenteditable', 'unnumbered-heading'],
            allowedClassNames: ['bibliographie-heading'],
            allowedChildren: ['#text'],
            pruneSpaces: true,
            buildAttributes: [
                {name: 'id', build: function() {return uuid()}},
                {name: 'unnumbered-heading', build: function() {return 'Yes'}}
            ]
        },

        'bibliographie-content': {
            tagName: 'div',
            className: 'bibliographie-content',
            allowedAttributes: ['class', 'contenteditable'],
            allowedClassNames: ['bibliographie-content'],
            allowedChildren: ['bibliographie-entry'],
        },

        'bibliographie-entry': {
            tagName: 'div',
            className: 'entry',
            allowedAttributes: ['class'],
            allowedClassNames: ['entry', 'note'],
            allowedChildren: ['#text'],
        }
    },

    enrichments: [],

    getSectionElement: getSectionElement,

    getOptions: function(sectionElement) {
        return [
            {
                name: 'numberedHeading',
                displayName: 'Should the heading be numbered',
                allowedValues: ['Yes', 'No'],
                defaultValue: sectionElement.querySelector('h2').getAttribute('unnumbered-heading') === 'Yes' ? 'No' : 'Yes'
            }
        ]
    },

    onOptionsChange: function(opt, editor) {
        var section = editor.focusedSection();
        if(opt.numberedHeading === 'Yes' || opt.numberedHeading === 'No') {
            section.querySelector('h2').setAttribute('unnumbered-heading', opt.numberedHeading === 'Yes' ? 'No' : 'Yes');
            self.editor.replaceSectionWithHTML(section, section.outerHTML);
        }
    },

    onEditorContentChanged: function(modificationLog) {
        if(!modificationLog.mightIncludeReferenceUpdates && !modificationLog.mightIncludeBibliographieUpdates) {
            return;
        }

        var bibs = document.querySelectorAll('bibliographie .bibliographie-content'),
            refs = document.querySelectorAll('.reference[data-external]').map(function(r) { return r.getAttribute('data-ref')}).unique(),
            allRefs = module.exports.editor.reference.getAllExternalRefs(), refData;

        bibs.forEach(function(bib) {
            bib.innerHTML = '';
            if(refs.length === 0) {
                bib.innerHTML += '<div class="entry note">Insert references to see them here.</div>';
            }

            refs.forEach(function(refId) {
                refData = allRefs[refId];

                if(refData) {
                    let tmp = document.createElement('div');
                    tmp.classList.add('entry')
                    tmp.setAttribute('data-ref', refId);
                    tmp.innerHTML = [refData.url, refData.author, refData.title, refData.year, (refData.publisher || refData.journal)].filter(function(x) {return x}).join(' - ');
                    tmp.onclick = function() { module.exports.editor.reference.showEditExternalRefDialog(tmp) };
                    bib.appendChild(tmp);
                }
            });
        });
    },

    onKeyBackspace: function(e, editor) {
        var heading = editor.caret.getContextElement('h2', window.getSelection(), []),
            sectionIndex = editor.indexOf(editor.focusedSection());

        if(!heading || editor.caret.isCollapsedAndPositionedAtTheBeginningOf(heading, false)) {
            e.preventDefault();
        } else if(heading.innerText.length === 1) {
            document.execCommand('delete');
            editor.caret.positionIn(editor.sectionAt(sectionIndex).querySelector('h2'));
            e.preventDefault();
        } else if(heading.innerText.length === 0) {
            e.preventDefault();
        }
    },

    onFocus: function(el, editor, args) {
        var heading = el.querySelector('h2'),
            isCaretInsideSection = (editor.sectionAtCaretPostion() === el && editor.caret.getContextElement('h2')),
            hasBeenFocusedAfterSectionTypeChange = args.action === 'changeFocusedSectionType';

        if(hasBeenFocusedAfterSectionTypeChange || !isCaretInsideSection) {
            heading && editor.caret.positionIn(heading);
        }
    },

    setEditor: function(editor) {
        this.editor = editor;
        return this;
    }
});


/***/ }),

/***/ "../structured-text-editor/src/section_types/blockquote/blockquote_section_type.js":
/*!*****************************************************************************************!*\
  !*** ../structured-text-editor/src/section_types/blockquote/blockquote_section_type.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uuid = __webpack_require__(/*! uuid/v1 */ "../structured-text-editor/node_modules/uuid/v1.js");

var getSectionElement = function(existingSectionContent) {
    var el = document.createElement('bquote'),
        blockquoteEl = document.createElement('blockquote'),
        captionEl = document.createElement('citesrc');

    el.setAttribute('contenteditable', 'false')
    el.setAttribute('display-citesrc', 'Yes');
    el.id = uuid();
    el.setContenteditable = module.exports.setContenteditable;
    el.sectionType = module.exports;

    blockquoteEl.innerHTML = existingSectionContent;
    blockquoteEl.setAttribute('contenteditable', 'true');

    captionEl.innerHTML = 'citation source';

    el.appendChild(blockquoteEl);
    el.appendChild(captionEl);

    return el;
}

Object.assign(module.exports, {

    name: 'bquote',

    tagTransformations: {
      '/bquote/blockquote/div': '#content',
      '/bquote/blockquote/span': '#content',
      '/bquote/blockquote': '#text-content',
    },

    contentRules: {
        'bquote': {
            tagName: 'bquote',
            allowedAttributes: ['class', 'contenteditable', 'display-caption', 'id', 'reference'],
            allowedClassNames: ['focused'],
            allowedChildren: ['blockquote', 'citesrc'],
            allowedToBeRoot: true,
            buildEmptyElement: getSectionElement,
            deleteIfEmpty: false,
            buildAttributes: [
              {name: 'id', build: function() {return uuid()}},
              {name: 'display-caption', build: function() {return 'Yes'}}
            ]
        },
        'blockquote': {
            tagName: 'blockquote',
            allowedSuccessors: ['citesrc'],
            allowedAttributes: ['contenteditable'],
            allowedChildren: ['#text'],
        },
        'citesrc': {
            tagName: 'citesrc',
            allowedChildren: ['#text', 'reference',  'inlineequation'],
            deleteIfEmpty: false,
            pruneSpaces: true,
        }
    },

    enrichments: [],

    getOptions: function(sectionElement) {
        return [
            {
              name: 'displayCaption',
              displayName: 'Display Source',
              allowedValues: ['Yes', 'No'],
              defaultValue: sectionElement.getAttribute('display-caption') || 'Yes'
            }
        ]
    },

    onOptionsChange: function(opt, editor) {
        var section = editor.focusedSection();

        if(section) {
            if(opt.displayCaption === 'Yes' || opt.displayCaption === 'No') {
                section.setAttribute('display-caption', opt.displayCaption);
            }

            editor.replaceSectionWithHTML(section, section.outerHTML);
        }
    },

    getSectionElement: getSectionElement,
})


/***/ }),

/***/ "../structured-text-editor/src/section_types/code/code_section_type.js":
/*!*****************************************************************************!*\
  !*** ../structured-text-editor/src/section_types/code/code_section_type.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var HTMLRazor = __webpack_require__(/*! ../../../lib/html_razor/html_razor */ "../structured-text-editor/lib/html_razor/html_razor.js"),
    utils = __webpack_require__(/*! ../../../lib/pixelschubser/utils */ "../structured-text-editor/lib/pixelschubser/utils.js"),
    shared = __webpack_require__(/*! ../shared/shared */ "../structured-text-editor/src/section_types/shared/shared.js"),
    primsjs = __webpack_require__(/*! prismjs */ "../structured-text-editor/node_modules/prismjs/prism.js"),
    progLanguages = ["XML", "HTML", "MathML", "SVG", "CSS", "clike", "JavaScript"],
    progLanguagesShort = {'JavaScript': 'JS'},
    defaultLanguage = 'JavaScript',
    uuid = __webpack_require__(/*! uuid/v1 */ "../structured-text-editor/node_modules/uuid/v1.js");

var getSectionElement = function(existingSectionContent, params) {
    var el = document.createElement('pre'),
        codeEl = document.createElement('code'),
        captionEl = document.createElement('caption'),
        capitalizedLangauge;

    el.classList.add('code');
    el.setAttribute('contenteditable', 'false')
    el.setAttribute('display-caption', 'Yes');
    el.id = uuid();
    el.onKeyUp = module.exports.onKeyUp;
    el.onKeyDown = module.exports.onKeyDown;
    el.onKeyEnter = module.exports.onKeyEnter;
    el.onKeyTab = module.exports.onKeyTab;
    el.onKeyBackspace = module.exports.onKeyBackspace;
    el.onMarkupCleaningFinshed = module.exports.onMarkupCleaningFinshed;
    el.setContenteditable = module.exports.setContenteditable;
    el.sectionType = module.exports;

    codeEl.innerHTML = existingSectionContent;
    codeEl.setAttribute('contenteditable', 'true');

    captionEl.innerHTML = 'listing title';

    el.appendChild(codeEl);
    el.appendChild(captionEl);

    if(params && params[0]) {
        params[0] = params[0].toLowerCase();
        capitalizedLangauge = progLanguages.find(function(lan) {
            return lan.toLowerCase() === params[0];
        });
    }

    capitalizedLangauge = capitalizedLangauge || defaultLanguage;
    el.setAttribute('language', capitalizedLangauge);

    return el;
}

Object.assign(module.exports, {

    name: 'code',

    tagTransformations: {
      '/pre/code/div': '#content',
      '/pre/code/span': '#content',
      '/pre/code': '#text-content',
    },

    contentRules: {
        'pre': {
            tagName: 'pre',
            allowedAttributes: ['class', 'language', 'contenteditable', 'display-caption', 'id'],
            allowedClassNames: ['focused', 'code'],
            allowedChildren: ['code', 'caption'],
            allowedToBeRoot: true,
            buildEmptyElement: getSectionElement,
            deleteIfEmpty: false,
            buildAttributes: [
              {name: 'id', build: function() {return uuid()}},
              {name: 'language', build: function() {return defaultLanguage}},
              {name: 'display-caption', build: function() {return 'Yes'}}
            ]
        },
        'code': {
            tagName: 'code',
            allowedSuccessors: ['caption'],
            allowedAttributes: ['contenteditable'],
            allowedChildren: ['#text'],
        }
    },

    enrichments: [],

    getOptions: function(sectionElement) {
        return [
            {
              name: 'language',
              displayName: 'Syntax Highlighting for',
              allowedValues: progLanguages,
              defaultValue: sectionElement.getAttribute('language')
            },
            {
              name: 'displayCaption',
              displayName: 'Display Listing Caption',
              allowedValues: ['Yes', 'No'],
              defaultValue: sectionElement.getAttribute('display-caption') || 'Yes'
            }
        ]
    },

    onOptionsChange: function(opt, editor) {
        var section = editor.focusedSection();

        if(section) {
            if(opt['language']) {
                section.setAttribute('language', opt['language']);
            }

            if(opt.displayCaption === 'Yes' || opt.displayCaption === 'No') {
                section.setAttribute('display-caption', opt.displayCaption);
            }

            editor.replaceSectionWithHTML(section, section.outerHTML);
        }
    },

    getSectionElement: getSectionElement,

    onMarkupCleaningFinshed: function(sectionElement) {
        var codeEl = sectionElement.querySelector('code'), content, lan;

        if(!codeEl) { return }

        content = codeEl.innerHTML;
        lan = sectionElement.getAttribute('language');

        if(!lan || lan === 'true') {
            lan = defaultLanguage;
        }

        lan = lan.toLowerCase();
        content = HTMLRazor.prototype.strip(content);
        content = primsjs.highlight(content, primsjs.languages[lan], lan);
        sectionElement.querySelector('code').innerHTML = content;
    },

    getSectionTypeCaptionAnnotation: function(sectionElement) {
        var lan = sectionElement.getAttribute('language');

        if(progLanguagesShort[lan]) {
            return progLanguagesShort[lan];
        }

        return lan;
    },

    onKeyTab: function(e) {
        document.execCommand('insertText', false, '  ');
        e.preventDefault();
    },

    setContenteditable: function(shouldBeEditable, section) {
        var el = section.querySelector('code')
        if(el) {
            if(shouldBeEditable) {
                el.setAttribute('contenteditable', true);
            } else {
                el.removeAttribute('contenteditable');
            }
        }
    },

    onKeyUp: shared.onKeyUpForFreestyleSections,
    onKeyDown: shared.onKeyDownForFreestyleSections,
    onKeyBackspace: function(e, editor) {
        var caption = editor.caret.getContextElement('caption', window.getSelection(), []),
            sectionEl, sectionIndex;

        if(caption) {
            if(caption.innerText.length === 1) {
                sectionEl = caption.parentElement;
                sectionIndex = editor.indexOf(sectionEl);

                if(sectionIndex) {
                    document.execCommand('delete');

                    sectionEl = editor.sectionAt(sectionIndex);
                    caption = sectionEl && sectionEl.querySelector('caption');

                    if(caption) {
                        editor.caret.positionIn(caption);
                    }

                    e.preventDefault();
                }
            } else if(!caption.innerText || caption.innerText.length === 0 || editor.caret.isCollapsedAndPositionedAtTheBeginningOf(caption, false)) {
                e.preventDefault();
            }
        } else {
            shared.onKeyBackspaceForBackspaceDeletableSections(e, editor)
        }
    },
    onKeyEnter: shared.onKeyEnterForFreestyleSections
})


/***/ }),

/***/ "../structured-text-editor/src/section_types/footnotes/footnotes_section_type.js":
/*!***************************************************************************************!*\
  !*** ../structured-text-editor/src/section_types/footnotes/footnotes_section_type.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uuid = __webpack_require__(/*! uuid/v1 */ "../structured-text-editor/node_modules/uuid/v1.js"),
utils = __webpack_require__(/*! ../../../lib/pixelschubser/utils */ "../structured-text-editor/lib/pixelschubser/utils.js");

function getSectionElement() {
    var  el = document.createElement('footnotes'),
         heading = document.createElement('h2'),
         content = document.createElement('div');
    el.classList.add('footnotes');

    heading.classList.add('footnotes-heading');
    content.classList.add('footnotes-content');

    el.setAttribute('contenteditable', 'false');
    heading.setAttribute('contenteditable', 'true');
    content.setAttribute('contenteditable', 'false');

    heading.innerHTML = 'Footnotes';

    el.onKeyBackspace = module.exports.onKeyBackspace;
    el.sectionType = module.exports;

    el.appendChild(heading);
    el.appendChild(content);

    return el;
}

Object.assign(module.exports, {

    name: 'footnotes',

    editableElementSelector: 'h2',

    preferredCaretPositioning: 'end',

    contentRules: {
        'footnotes': {
            tagName: 'footnotes',
            allowedAttributes: ['class', 'contenteditable'],
            allowedClassNames: ['focused'],
            allowedChildren: ['footnotes-heading', 'footnotes-content'],
            allowedToBeRoot: true,
            deleteIfEmpty: false,
            doNotBreakOutRootElements: true,
            buildEmptyElement: getSectionElement
        },

        'footnotes-heading': {
            tagName: 'h2',
            className: 'footnotes-heading',
            allowedAttributes: ['id', 'class', 'contenteditable', 'unnumbered-heading'],
            allowedClassNames: ['footnotes-heading'],
            allowedChildren: ['#text'],
            pruneSpaces: true,
            buildAttributes: [
                {name: 'id', build: function() {return uuid()}},
                {name: 'unnumbered-heading', build: function() {return 'Yes'}}
            ]
        },

        'footnotes-content': {
            tagName: 'div',
            className: 'footnotes-content',
            allowedAttributes: ['class', 'contenteditable'],
            allowedClassNames: ['footnotes-content'],
            allowedChildren: ['footnotes-entry'],
        },

        'footnotes-entry': {
            tagName: 'div',
            className: 'entry',
            allowedAttributes: ['class'],
            allowedClassNames: ['entry', 'note'],
            allowedChildren: ['#text'],
        }
    },

    enrichments: [],

    getSectionElement: getSectionElement,

    getOptions: function(sectionElement) {
        return [
            {
                name: 'numberedHeading',
                displayName: 'Should the heading be numbered',
                allowedValues: ['Yes', 'No'],
                defaultValue: sectionElement.querySelector('h2').getAttribute('unnumbered-heading') === 'Yes' ? 'No' : 'Yes'
            }
        ]
    },

    onOptionsChange: function(opt, editor) {
        var section = editor.focusedSection();
        if(opt.numberedHeading === 'Yes' || opt.numberedHeading === 'No') {
            section.querySelector('h2').setAttribute('unnumbered-heading', opt.numberedHeading === 'Yes' ? 'No' : 'Yes');
            self.editor.replaceSectionWithHTML(section, section.outerHTML);
        }
    },

    onEditorContentChanged: function(modificationLog) {
        if(!modificationLog.mightIncludeFootnoteUpdates && !modificationLog.mightIncludeFootnotesSectionUpdates) {
            return;
        }

        var notesSections = document.querySelectorAll('footnotes .footnotes-content'),
            notes = document.querySelectorAll('.footnote'),
            noteIndex, tmp;

        notesSections.forEach(function(notesSection) {
            notesSection.innerHTML = '';

            if(notes.length === 0) {
                notesSection.innerHTML += '<div class="entry note">Insert footnotes to see them here.</div>';
            }

            noteIndex = 0;

            notes.forEach(function(note) {
                noteIndex++;
                tmp = document.createElement('div');
                tmp.classList.add('entry')
                tmp.innerHTML = noteIndex + ') ' + utils.attributeSaveStringToHTMLEncoded(note.getAttribute('data-note'));
                tmp.onclick = function() {
                    module.exports.showFootnoteEditDialog(note);

                };
                notesSection.appendChild(tmp);
            });
        });
    },

    showFootnoteEditDialog: function(note) {
        var self = this,
            section = self.editor.sectionByChildNode(note),
            noteIndex,
            args = [{
            name: 'note',
            placeholder: 'footnote',
            displayName: 'Footnote',
            largetext: true,
            defaultValue: utils.attributeSaveStringToString(note.dataset.note)
        }];

        if(!section) {
            return;
        }

        self.editor.displayModal(args, function(formData) {
            noteIndex = document.querySelectorAll('.footnote').indexOf(note),
            self.editor.unfreezeSelection(false);
            note = document.querySelectorAll('.footnote')[noteIndex];
            section = self.editor.sectionByChildNode(note);

            if(!formData.note) return;
            if(typeof formData.note !== 'string') return;
            if(formData.note.trim() === '') return;
            note.setAttribute('data-note', utils.stringToAttributeSaveString(formData.note));

            self.editor.replaceSectionWithHTML(section, section.outerHTML);
        });
    },

    onKeyBackspace: function(e, editor) {
        var heading = editor.caret.getContextElement('h2', window.getSelection(), []),
            sectionIndex = editor.indexOf(editor.focusedSection());

        if(!heading || editor.caret.isCollapsedAndPositionedAtTheBeginningOf(heading, false)) {
            e.preventDefault();
        } else if(heading.innerText.length === 1) {
            document.execCommand('delete');
            editor.caret.positionIn(editor.sectionAt(sectionIndex).querySelector('h2'));
            e.preventDefault();
        } else if(heading.innerText.length === 0) {
            e.preventDefault();
        }
    },

    onFocus: function(el, editor, args) {
        var toCHeading = el.querySelector('h2'),
            isCaretInsideSection = (editor.sectionAtCaretPostion() === el && editor.caret.getContextElement('h2')),
            hasBeenFocusedAfterSectionTypeChange = args.action === 'changeFocusedSectionType';

        if(hasBeenFocusedAfterSectionTypeChange || !isCaretInsideSection) {
            toCHeading && editor.caret.positionIn(toCHeading);
        }
    },

    setEditor: function(editor) {
        this.editor = editor;
        return this;
    }
});


/***/ }),

/***/ "../structured-text-editor/src/section_types/formula/formula_section_type.js":
/*!***********************************************************************************!*\
  !*** ../structured-text-editor/src/section_types/formula/formula_section_type.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var code2dia = __webpack_require__(/*! ../shared/code2dia_section_type */ "../structured-text-editor/src/section_types/shared/code2dia_section_type.js"),
    // katex = require('katex'), // make sure to load <script src="./katex.js" defer></script> in your html
    latex = __webpack_require__(/*! prismjs/components/prism-latex */ "../structured-text-editor/node_modules/prismjs/components/prism-latex.js"),
    render;

render = function(renderEl, content) {
    if(content.trim().length === 0) {
        renderEl.innerHTML = 'Write a LaTeX formula into the input field above <span class="arrow">&#10548;</span>';
    } else {
        renderEl.innerHTML = '';
        katex.render(content, renderEl, {
            throwOnError: false,
            displayMode: true
        });
    }
}

module.exports = code2dia(render, 'formula', 'latex', 'equation caption')


/***/ }),

/***/ "../structured-text-editor/src/section_types/heading/heading1.js":
/*!***********************************************************************!*\
  !*** ../structured-text-editor/src/section_types/heading/heading1.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uuid = __webpack_require__(/*! uuid/v1 */ "../structured-text-editor/node_modules/uuid/v1.js"),
    paragraphSectionType = __webpack_require__(/*! ../paragraph/paragraph_section_type */ "../structured-text-editor/src/section_types/paragraph/paragraph_section_type.js");

var getSectionElement = function(existingSectionContent) {
    var el = document.createElement('h1');
    el.innerHTML = existingSectionContent || '';
    el.id = uuid();
    el.onKeyUp = module.exports.onKeyUp;
    el.onKeyDown = module.exports.onKeyDown;
    el.onKeyEnter = module.exports.onKeyEnter;
    return el;
}

module.exports = {

    name: 'h1',

    contentRules: {
        'h1': {
            tagName: 'h1',
            allowedAttributes: ['class', 'id'],
            allowedChildren: ['#text', 'inlineequation'],
            allowedClassNames: ['focused'],
            pruneSpaces: true,
            allowedToBeRoot: true,
            buildEmptyElement: getSectionElement,
            buildAttributes: [{name: 'id', build: function() {return uuid()}}]
        }
    },

    enrichments: [],

    onKeyUp: paragraphSectionType.onKeyUp,
    onKeyDown: paragraphSectionType.onKeyDown,
    onKeyEnter: function(e, editor) {
        if(editor.caret.isCollapsedAndPositionedAtTheBeginningOf(editor.focusedSection())) {
            if(editor.focusedSection()) {
                editor.addNewSectionNextTo(editor.focusedSection(), 'before')
            }
        } else {
            editor.caret.insertLineBreak();
        }

        e.preventDefault();
    },

    getSectionElement: getSectionElement,
}


/***/ }),

/***/ "../structured-text-editor/src/section_types/heading/heading2.js":
/*!***********************************************************************!*\
  !*** ../structured-text-editor/src/section_types/heading/heading2.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uuid = __webpack_require__(/*! uuid/v1 */ "../structured-text-editor/node_modules/uuid/v1.js"),
    paragraphSectionType = __webpack_require__(/*! ../paragraph/paragraph_section_type */ "../structured-text-editor/src/section_types/paragraph/paragraph_section_type.js"),
    h1SectionType = __webpack_require__(/*! ./heading1.js */ "../structured-text-editor/src/section_types/heading/heading1.js");

var getSectionElement = function(existingSectionContent, params) {
    var el = document.createElement('h2');

    if(params && (params.includes('abstract') || params.includes('Abstract'))) {
        el.setAttribute('role', 'Abstract')
    } else if(params && (params.includes('declaration') || params.includes('Declaration'))) {
        el.setAttribute('role', 'Declaration')
    } else if(params && (params.includes('appendix') || params.includes('Appendix'))) {
        el.setAttribute('role', 'Appendix')
    } else if(params && (params.includes('acknowledgement') || params.includes('Acknowledgement'))) {
        el.setAttribute('role', 'Acknowledgement')
    }

    el.innerHTML = existingSectionContent || '';
    el.onKeyUp = module.exports.onKeyUp;
    el.onKeyDown = module.exports.onKeyDown;
    el.onKeyEnter = module.exports.onKeyEnter;
    el.id = uuid();
    el.sectionType = module.exports;
    return el;
}

module.exports = {

    name: 'h2',

    contentRules: {
        'h2': {
            tagName: 'h2',
            allowedAttributes: ['class', 'id', 'role'],
            allowedChildren: ['#text', 'inlineequation'],
            allowedClassNames: ['focused'],
            pruneSpaces: true,
            allowedToBeRoot: true,
            buildEmptyElement: getSectionElement,
            buildAttributes: [{name: 'id', build: function() {return uuid()}}]
        }
    },

    enrichments: [],

    getOptions: function(sectionElement) {
        return [
            {
              name: 'role',
              displayName: 'Assign a special role to the heading',
              allowedValues: ['None', 'Abstract', 'Declaration', 'Appendix', 'Acknowledgement'],
              defaultValue: sectionElement.getAttribute('role') || 'None'
            }
        ]
    },

    onOptionsChange: function(opt, editor) {
        var section = editor.focusedSection();

        if(section) {
            if(opt['role']) {
                section.setAttribute('role', opt['role']);
            }

            editor.replaceSectionWithHTML(section, section.outerHTML);
        }
    },

    getSectionTypeCaptionAnnotation: function(sectionElement) {
        var role = sectionElement.getAttribute('role');
        if(role === 'None') {
            role = null;
        }

        if(role === 'Acknowledgement') {
            return 'Ack.'
        }

        if(role === 'Declaration') {
            return 'Decl.'
        }

        return role;
    },

    onKeyUp: paragraphSectionType.onKeyUp,
    onKeyDown: paragraphSectionType.onKeyDown,
    onKeyEnter: h1SectionType.onKeyEnter,

    getSectionElement: getSectionElement,
}


/***/ }),

/***/ "../structured-text-editor/src/section_types/heading/heading3.js":
/*!***********************************************************************!*\
  !*** ../structured-text-editor/src/section_types/heading/heading3.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uuid = __webpack_require__(/*! uuid/v1 */ "../structured-text-editor/node_modules/uuid/v1.js"),
    paragraphSectionType = __webpack_require__(/*! ../paragraph/paragraph_section_type */ "../structured-text-editor/src/section_types/paragraph/paragraph_section_type.js"),
    h1SectionType = __webpack_require__(/*! ./heading1.js */ "../structured-text-editor/src/section_types/heading/heading1.js");

var getSectionElement = function(existingSectionContent) {
    var el = document.createElement('h3');
    el.innerHTML = existingSectionContent || '';
    el.onKeyUp = module.exports.onKeyUp;
    el.onKeyDown = module.exports.onKeyDown;
    el.onKeyEnter = module.exports.onKeyEnter;
    el.id = uuid();
    return el;
}

module.exports = {

    name: 'h3',

    contentRules: {
        'h3': {
            tagName: 'h3',
            allowedAttributes: ['class', 'id'],
            allowedChildren: ['#text', 'inlineequation'],
            allowedClassNames: ['focused'],
            pruneSpaces: true,
            allowedToBeRoot: true,
            buildEmptyElement: getSectionElement,
            buildAttributes: [{name: 'id', build: function() {return uuid()}}]
        }
    },

    enrichments: [],

    onKeyUp: paragraphSectionType.onKeyUp,
    onKeyDown: paragraphSectionType.onKeyDown,
    onKeyEnter: h1SectionType.onKeyEnter,

    getSectionElement: getSectionElement,
}


/***/ }),

/***/ "../structured-text-editor/src/section_types/heading/heading4.js":
/*!***********************************************************************!*\
  !*** ../structured-text-editor/src/section_types/heading/heading4.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uuid = __webpack_require__(/*! uuid/v1 */ "../structured-text-editor/node_modules/uuid/v1.js"),
    paragraphSectionType = __webpack_require__(/*! ../paragraph/paragraph_section_type */ "../structured-text-editor/src/section_types/paragraph/paragraph_section_type.js"),
    h1SectionType = __webpack_require__(/*! ./heading1.js */ "../structured-text-editor/src/section_types/heading/heading1.js");

var getSectionElement = function(existingSectionContent) {
    var el = document.createElement('h4');
    el.innerHTML = existingSectionContent || '';
    el.onKeyUp = module.exports.onKeyUp;
    el.onKeyDown = module.exports.onKeyDown;
    el.onKeyEnter = module.exports.onKeyEnter;
    el.id = uuid();
    return el;
}

module.exports = {

    name: 'h4',

    contentRules: {
        'h4': {
            tagName: 'h4',
            allowedAttributes: ['class', 'id'],
            allowedChildren: ['#text', 'inlineequation'],
            allowedClassNames: ['focused'],
            pruneSpaces: true,
            allowedToBeRoot: true,
            buildEmptyElement: getSectionElement,
            buildAttributes: [{name: 'id', build: function() {return uuid()}}]
        }
    },

    enrichments: [],

    onKeyUp: paragraphSectionType.onKeyUp,
    onKeyDown: paragraphSectionType.onKeyDown,
    onKeyEnter: h1SectionType.onKeyEnter,

    getSectionElement: getSectionElement,
}


/***/ }),

/***/ "../structured-text-editor/src/section_types/heading/heading5.js":
/*!***********************************************************************!*\
  !*** ../structured-text-editor/src/section_types/heading/heading5.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uuid = __webpack_require__(/*! uuid/v1 */ "../structured-text-editor/node_modules/uuid/v1.js"),
    paragraphSectionType = __webpack_require__(/*! ../paragraph/paragraph_section_type */ "../structured-text-editor/src/section_types/paragraph/paragraph_section_type.js"),
    h1SectionType = __webpack_require__(/*! ./heading1.js */ "../structured-text-editor/src/section_types/heading/heading1.js");

var getSectionElement = function(existingSectionContent) {
    var el = document.createElement('h5');
    el.innerHTML = existingSectionContent || '';
    el.onKeyUp = module.exports.onKeyUp;
    el.onKeyDown = module.exports.onKeyDown;
    el.onKeyEnter = module.exports.onKeyEnter;
    el.id = uuid();
    return el;
}

module.exports = {

    name: 'h5',

    contentRules: {
        'h5': {
            tagName: 'h5',
            allowedAttributes: ['class', 'id'],
            allowedChildren: ['#text', 'inlineequation'],
            allowedClassNames: ['focused'],
            pruneSpaces: true,
            allowedToBeRoot: true,
            buildEmptyElement: getSectionElement,
            buildAttributes: [{name: 'id', build: function() {return uuid()}}]
        }
    },

    enrichments: [],

    onKeyUp: paragraphSectionType.onKeyUp,
    onKeyDown: paragraphSectionType.onKeyDown,
    onKeyEnter: h1SectionType.onKeyEnter,

    getSectionElement: getSectionElement,
}


/***/ }),

/***/ "../structured-text-editor/src/section_types/image/image_section_type.js":
/*!*******************************************************************************!*\
  !*** ../structured-text-editor/src/section_types/image/image_section_type.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var chooseFileBtnCounter = 0,
    imageSectionType,
    uuid = __webpack_require__(/*! uuid/v1 */ "../structured-text-editor/node_modules/uuid/v1.js");

var buildEmptyImgPlacehoder = function() {
    var imgPlaceholder = document.createElement('span'),
        emptyImage = document.createElement('i'),
        chooseFileLabel = document.createElement('label'),
        chooseFileBtn = document.createElement('input'),
        chooseFileBtnId = 'chooseFileBtn' + chooseFileBtnCounter++;

    emptyImage.classList.add('empty-image');
    chooseFileBtn.classList.add('choose-img-btn');
    chooseFileBtn.setAttribute('type', 'file');
    chooseFileBtn.setAttribute('id', chooseFileBtnId);

    chooseFileLabel.classList.add('choose-img-btn-label');
    chooseFileLabel.innerHTML = 'Click to Import Image (or drag and drop it)';

    imgPlaceholder.setAttribute('contenteditable', false);
    imgPlaceholder.classList.add('image-img-placeholder');
    imgPlaceholder.appendChild(chooseFileLabel);
    imgPlaceholder.appendChild(chooseFileBtn);
    imgPlaceholder.appendChild(emptyImage);

    var getImageOrPlaceholderByAChild = function(child) {
        if(!child) {
            return;
        }

        if(child.classList.contains('image-img-placeholder') || child.tagName === 'IMG') {
           return child;
        }

        return getImageOrPlaceholderByAChild(child.parentElement);
    }

    imgPlaceholder.onclick = function(e) {
        if(imageSectionType) {
            imageSectionType.editor.focusSection(e.target.parentElement)
        }

        chooseFileBtn.click()
    }

    imgPlaceholder.ondrop = chooseFileBtn.onchange = function(e) {
        e.preventDefault();

        var currentImg = getImageOrPlaceholderByAChild(e.target),
            sectionElement = currentImg.parentNode;

        if(!sectionElement || !document.body.contains(sectionElement)) {
            sectionElement = imageSectionType.editor.focusedSection();
            currentImg = sectionElement.querySelector('img') || sectionElement.querySelector('.image-img-placeholder')
        }

        currentImg.classList.remove('dragover');

        var files = e.target.files || e.dataTransfer.files;

        var img = document.createElement('img');
        var persistResult = imageSectionType.persistFile(files[0]);

        if(persistResult.then) {
            persistResult.then(url => img.src = url);
        } else {
            img.src = persistResult;
        }

        currentImg.parentElement.replaceChild(img, currentImg);
        img.ondrop = currentImg.ondrop;
        img.ondragover = currentImg.ondragover;
        img.ondragleave = currentImg.ondragleave;
        img.onclick = imgPlaceholder.onclick

        sectionElement.dispatchEvent(new CustomEvent('image-upload', {bubbles: true, detail: {url: img.src}}));
        sectionElement.dispatchEvent(new Event('input', {bubbles: true}));
    }

    imgPlaceholder.ondragover = function(e) { getImageOrPlaceholderByAChild(e.target).classList.add('dragover'); e.preventDefault(); }
    imgPlaceholder.ondragleave = function(e) { getImageOrPlaceholderByAChild(e.target).classList.remove('dragover'); e.preventDefault(); }

    return imgPlaceholder;
}

var getSectionElement = function(existingSectionContent) {
    var el = document.createElement('figure'),
        caption = document.createElement('figcaption');

    el.id = uuid();
    el.sectionType = imageSectionType;
    el.setAttribute('display-caption', 'Yes');
    caption.innerHTML = 'image title';
    el.appendChild(buildEmptyImgPlacehoder());
    el.appendChild(caption);
    el.onKeyBackspace = imageSectionType.onKeyBackspace;
    el.onKeyEnter = imageSectionType.onKeyEnter;

    return el;
}

imageSectionType = {

    name: 'img',

    contentRules: {
        'image': {
            tagName: 'figure',
            allowedAttributes: ['class', 'display-caption', 'id'],
            allowedClassNames: ['focused'],
            allowedChildren: ['image-img', 'image-caption', 'image-img-placeholder'],
            childrenCardinality: {'image-caption': {max: 1}, 'image-img-placeholder': {max: 1}},
            allowedToBeRoot: true,
            deleteIfEmpty: false,
            buildEmptyElement: getSectionElement,
            buildAttributes: [
                {name: 'id', build: function() {return uuid()}},
                {name: 'display-caption', build: function() {return 'Yes'}}
            ]
        },
        'image-img': {
            tagName: 'img',
            allowedAttributes: ['src'],
            allowedSuccessors: ['image-caption'],
            allowedChildren: []
        },
        'image-img-placeholder': {
            tagName: 'span',
            className: 'image-img-placeholder',
            allowedAttributes: ['class', 'contenteditable'],
            allowedClassNames: ['image-img-placeholder'],
            allowedSuccessors: ['image-caption'],
            allowedChildren: ['empty-image', 'choose-img-btn', 'choose-img-btn-label'],
            deleteIfEmpty: false,
            buildEmptyElement: buildEmptyImgPlacehoder
        },
        'empty-image': {
            tagName: 'i',
            className: 'empty-image',
            allowedAttributes: ['class'],
            allowedClassNames: ['empty-image'],
            allowedChildren: [],
            deleteIfEmpty: false,
        },
        'choose-img-btn': {
            tagName: 'input',
            className: 'choose-img-btn',
            allowedAttributes: ['class', 'type', 'id'],
            allowedClassNames: ['choose-img-btn'],
            deleteIfEmpty: false
        },
        'choose-img-btn-label': {
            tagName: 'label',
            className: 'choose-img-btn-label',
            allowedClassNames: ['choose-img-btn-label'],
            allowedAttributes: ['class'],
            allowedChildren: ['#text']
        },
        'image-caption': {
            tagName: 'figcaption',
            allowedChildren: ['#text', 'reference', 'inlineequation'],
            allowedPredecessors: ['image-img-placeholder', 'image-img'],
            deleteIfEmpty: false,
            pruneSpaces: true
        }
    },

    enrichments: [],

    getOptions: function(sectionElement) {
        return [
            {
              name: 'displayCaption',
              displayName: 'Display Image Caption',
              allowedValues: ['Yes', 'No'],
              defaultValue: sectionElement.getAttribute('display-caption')
            }
        ]
    },

    onOptionsChange: function(opt, editor) {
        var section = editor.focusedSection();
        if(opt.displayCaption === 'Yes' || opt.displayCaption === 'No') {
            section.setAttribute('display-caption', opt.displayCaption);
        }
    },

    setEditor: function(editor) {
        this.editor = editor;
        return this;
    },

    persistFile: function(blob) {
        return URL.createObjectURL(blob);
    },

    onKeyBackspace: function(e, editor) {
        var caption = editor.caret.getContextElement('figcaption');
        if(caption.innerText === '') {
            e.preventDefault();
        }
    },

    onKeyEnter: function(e) {
        e.preventDefault();
    },

    onFocus: function(el, editor, args) {
        var caption = el.querySelector('figcaption'),
            isCaretInsideSection = (editor.sectionAtCaretPostion() === el && editor.caret.getContextElement('figcaption')),
            hasBeenFocusedAfterSectionTypeChange = args.action === 'changeFocusedSectionType';

        if(hasBeenFocusedAfterSectionTypeChange || !isCaretInsideSection) {
            caption && editor.caret.positionIn(caption);
        }
    },

    getSectionElement: getSectionElement
}

module.exports = imageSectionType;


/***/ }),

/***/ "../structured-text-editor/src/section_types/list/ordered_list_section_type.js":
/*!*************************************************************************************!*\
  !*** ../structured-text-editor/src/section_types/list/ordered_list_section_type.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var shared = __webpack_require__(/*! ../shared/shared */ "../structured-text-editor/src/section_types/shared/shared.js");
var unorderedListSectionType = __webpack_require__(/*! ./unordered_list_section_type */ "../structured-text-editor/src/section_types/list/unordered_list_section_type.js");

var getSectionElement = function(existingSectionContent) {
    var el = document.createElement('ol');
    el.onKeyUp = module.exports.onKeyUp;
    el.onKeyDown = module.exports.onKeyDown;
    el.onKeyEnter = module.exports.onKeyEnter;
    el.onKeyTab = module.exports.onKeyTab;
    el.onKeyBackspace = module.exports.onKeyBackspace;
    el.innerHTML = '<li>' + existingSectionContent + '</li>';
    return el;
}

module.exports = {

    name: 'ol',

    contentRules: {
        'ol': {
            tagName: 'ol',
            allowedAttributes: ['class'],
            allowedClassNames: ['focused'],
            allowedChildren: ['li', 'ol'],
            allowedToBeRoot: true,
            buildEmptyElement: getSectionElement
        },
        'li': {
            tagName: 'li',
            pruneSpaces: true,
            doNotBreakOutRootElements: true,
            allowedChildren: ['#text', 'link', 'b', 'i', 'u', 'reference', 'footnote', 'inlinecode', 'inlineequation'],
        }
    },

    enrichments: [],

    getSectionElement: getSectionElement,
    indentFocusedListItem: unorderedListSectionType.indentFocusedListItem,
    onKeyUp: unorderedListSectionType.onKeyUp,
    onKeyDown: unorderedListSectionType.onKeyDown,
    onKeyBackspace: unorderedListSectionType.onKeyBackspace,
    onKeyEnter: function(e) {},
    onKeyTab: unorderedListSectionType.onKeyTab
}


/***/ }),

/***/ "../structured-text-editor/src/section_types/list/unordered_list_section_type.js":
/*!***************************************************************************************!*\
  !*** ../structured-text-editor/src/section_types/list/unordered_list_section_type.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var shared = __webpack_require__(/*! ../shared/shared */ "../structured-text-editor/src/section_types/shared/shared.js"),
    paragraphSectionType = __webpack_require__(/*! ../paragraph/paragraph_section_type */ "../structured-text-editor/src/section_types/paragraph/paragraph_section_type.js");

var getSectionElement = function(existingSectionContent) {
    var el = document.createElement('ul');
    el.onKeyUp = module.exports.onKeyUp;
    el.onKeyDown = module.exports.onKeyDown;
    el.onKeyEnter = module.exports.onKeyEnter;
    el.onKeyTab = module.exports.onKeyTab;
    el.onKeyBackspace = module.exports.onKeyBackspace;
    el.innerHTML = '<li>' + existingSectionContent + '</li>';
    return el;
}

module.exports = {

    name: 'ul',

    contentRules: {
        'ul': {
            tagName: 'ul',
            allowedAttributes: ['class'],
            allowedClassNames: ['focused'],
            allowedChildren: ['li', 'ul'],
            allowedToBeRoot: true,
            buildEmptyElement: getSectionElement
        },
        // The li content rules are defined in the ordered list section type
        // 'li': {}
    },

    enrichments: [],

    getSectionElement: getSectionElement,

    onKeyUp: paragraphSectionType.onKeyUp,
    onKeyDown: paragraphSectionType.onKeyDown,

    onKeyBackspace: function(e, editor) {
        var focusedSection = editor.focusedSection(),
            upperSection,
            allListItems,
            targetListItem = editor.caret.getContextElement('li'),
            targetListItemIndex,
            upperListItem;

        if(targetListItem && targetListItem.innerText.trim() === '') {
            upperSection = focusedSection.previousSibling,
            allListItems = focusedSection.querySelectorAll('li'),
            targetListItemIndex = allListItems.indexOf(targetListItem),
            upperListItem = allListItems[targetListItemIndex-1];

            if(upperListItem) {
                editor.caret.positionIn(upperListItem);
                targetListItem.remove();
                editor.replaceSectionWithHTML(focusedSection, focusedSection.outerHTML);
                e.preventDefault();
            } else if(upperSection) {
                targetListItem.remove();
                editor.replaceSectionWithHTML(focusedSection, focusedSection.outerHTML);
                editor.caret.positionIn(upperSection);
                e.preventDefault();
            } else {
                e.preventDefault();
            }
        }
    },

    onKeyEnter: function(e) {},
    onKeyTab: function(e, editor)  {
        if(!e.shiftKey) {
            module.exports.indentFocusedListItem(editor)
        } else {
            document.execCommand('outdent');
        }

        e.preventDefault();
    },

    indentFocusedListItem: function (editor) {
        var targetListItem = editor.caret.getContextElement('li'),
            previousListItem, nextListItem, parentElement,
            isTargetListItemEmpty = targetListItem.innerText === '';

        if(targetListItem) {
            previousListItem = targetListItem.previousSibling;
            nextListItem = targetListItem.nextSibling;
            parentElement = targetListItem.parentElement;
        }

        document.execCommand('indent');

        if(isTargetListItemEmpty) {
            if(previousListItem && previousListItem.nextSibling) {
                editor.caret.positionIn(previousListItem.nextSibling);
            } else if(nextListItem && nextListItem.previousSibling) {
                editor.caret.positionIn(nextListItem.previousSibling);
            } else if(!previousListItem && !nextListItem && parentElement && parentElement.firstChild) {
                editor.caret.positionIn(parentElement.firstChild);
            }
        }
    }
}


/***/ }),

/***/ "../structured-text-editor/src/section_types/mermaid/mermaid_section_type.js":
/*!***********************************************************************************!*\
  !*** ../structured-text-editor/src/section_types/mermaid/mermaid_section_type.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var code2dia = __webpack_require__(/*! ../shared/code2dia_section_type */ "../structured-text-editor/src/section_types/shared/code2dia_section_type.js"),
    // mermaid = require('mermaid'), // make sure to load <script src="./mermaid.js" defer></script> in your html
    render;

function docReady(fn) {
    if (document.readyState === "complete" || document.readyState === "interactive") {
        setTimeout(fn, 1);
    } else {
        document.addEventListener("DOMContentLoaded", fn);
    }
}

docReady(function() {
    mermaid.initialize({ startOnLoad: false, 'font-size': '10px' })
})

render = function(renderEl, content) {
    var tmpContainer, id;

    if(content.trim().length === 0) {
        renderEl.innerHTML = 'Write some mermaid here <span class="arrow">&#10548;</span>';
    } else {
        renderEl.id = renderEl.id || 'test2';
        id = 'r' + renderEl.parentElement.id;
        renderEl.innerHTML = '';
        renderEl.classList.add('mermaid');

        try {
            mermaid.render(id, content, (re) => {
                renderEl.innerHTML = re;
            });
        } catch (ex) {
            renderEl.innerHTML = ex.message.replace(/\n/g, '<br/>');
        }

        tmpContainer = document.getElementById('d' + id);
        if(tmpContainer) {
            tmpContainer.remove();
        }
    }
}

module.exports = code2dia(render, 'mermaid', 'latex', 'image title')


/***/ }),

/***/ "../structured-text-editor/src/section_types/paragraph/paragraph_section_type.js":
/*!***************************************************************************************!*\
  !*** ../structured-text-editor/src/section_types/paragraph/paragraph_section_type.js ***!
  \***************************************************************************************/
/***/ ((module) => {

var getSectionElement = function(existingSectionContent) {
    existingSectionContent = existingSectionContent || '';
    existingSectionContent = existingSectionContent.replace(/<caption>.*?<\/caption>/, '');

    var el = document.createElement('p');
    el.innerHTML = existingSectionContent;
    el.onKeyUp = module.exports.onKeyUp;
    el.onKeyDown = module.exports.onKeyDown;
    return el;
}

module.exports = {

    name: 'p',

    contentRules: {
        'p': {
            tagName: 'p',
            allowedAttributes: ['class'],
            allowedClassNames: ['focused'],
            allowedChildren: ['#text', 'b', 'i', 'u', 'link', 'footnote', 'reference', 'inlinecode', 'inlineequation'],
            pruneSpaces: true,
            allowedToBeRoot: true,
            buildEmptyElement: getSectionElement
        }
    },

    enrichments: [],

    onKeyUp: function(e, editor) {
        if(editor.caret.isCollapsedAndPositionedAtTheFirstLineOf(editor.focusedSection())) {
            editor.moveCaretOneSectionUp('end');
            e.preventDefault();
        }
    },

    onKeyDown: function(e, editor) {
        if(editor.caret.isCollapsedAndPositionedAtTheLastLineOf(editor.focusedSection())) {
            editor.moveCaretOneSectionDown('preferredOrBeginning');
            e.preventDefault();
        }
    },

    getSectionElement: getSectionElement,
}


/***/ }),

/***/ "../structured-text-editor/src/section_types/shared/code2dia_section_type.js":
/*!***********************************************************************************!*\
  !*** ../structured-text-editor/src/section_types/shared/code2dia_section_type.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var HTMLRazor = __webpack_require__(/*! ../../../lib/html_razor/html_razor */ "../structured-text-editor/lib/html_razor/html_razor.js"),
    throttle = __webpack_require__(/*! ../../../lib/throttle/throttle */ "../structured-text-editor/lib/throttle/throttle.js"),
    codeSectionType = __webpack_require__(/*! ../code/code_section_type */ "../structured-text-editor/src/section_types/code/code_section_type.js"),
    primsjs = __webpack_require__(/*! prismjs */ "../structured-text-editor/node_modules/prismjs/prism.js"),
    uuid = __webpack_require__(/*! uuid/v1 */ "../structured-text-editor/node_modules/uuid/v1.js");

module.exports = function(render, tagName, syntaxHighlighting, defaultCaption) {
    var sectionType = {};

    var getSectionElement = function(existingSectionContent, directives, rule) {
        var el = document.createElement(rule.tagName),
            pre = document.createElement('pre')
            caption = document.createElement('caption'),
            inputEl = document.createElement('code');

        caption.classList.add('m2dia-caption');
        inputEl.classList.add('m2dia-code');
        pre.classList.add('m2dia-pre');

        caption.innerHTML = rule.defaultCaption || 'caption';

        pre.appendChild(inputEl);
        el.appendChild(pre);
        el.appendChild(caption);
        el.setAttribute('display-caption', 'Yes');
        el.classList.add(rule.tagName);
        el.classList.add('m2dia');
        el.id = uuid();

        el.onFocus = sectionType.onFocus;
        el.onKeyUp = sectionType.onKeyUp;
        el.onKeyDown = sectionType.onKeyDown;
        el.onKeyEnter = sectionType.onKeyEnter;
        el.onKeyTab = sectionType.onKeyTab;
        el.onKeyBackspace = sectionType.onKeyBackspace;
        el.onMarkupCleaningFinshed = sectionType.onMarkupCleaningFinshed;
        el.setContenteditable = sectionType.setContenteditable;
        el.sectionType = sectionType;

        return el;
    };

    Object.assign(sectionType, {
        name: tagName,

        contentRules: {
            'm2dia-pre': {
                tagName: 'pre',
                className: 'm2dia-pre',
                allowedAttributes: ['class'],
                allowedClassNames: ['m2dia-pre'],
                allowedChildren: ['m2dia-code'],
            },
            'm2dia-code': {
                tagName: 'code',
                className: 'm2dia-code',
                allowedClassNames: ['m2dia-code'],
                allowedAttributes: ['class'],
                allowedChildren: ['#text'],
            },
            'm2dia-caption': {
                tagName: 'caption',
                allowedAttributes: ['class'],
                className: 'm2dia-caption',
                allowedClassNames: ['m2dia-caption'],
                allowedChildren: ['#text', 'reference', 'inlineequation'],
                deleteIfEmpty: false,
                pruneSpaces: true,
            }
        },

        enrichments: [],

        onMarkupCleaningFinshed: function(sectionElement) {
            var codeEl = sectionElement.querySelector('code'),
                preEl = sectionElement.querySelector('pre'),
                renderEl = sectionElement.querySelector('.render'),
                lan = syntaxHighlighting,
                content;

            if(!codeEl) { return }

            if(!renderEl) {
                renderEl = document.createElement('div');
                renderEl.classList.add('render');
                renderEl.setAttribute('contenteditable', false);
                sectionElement.insertBefore(renderEl, preEl.nextSibling);
            }

            content = codeEl.innerHTML;
            content = HTMLRazor.prototype.strip(content);

            throttle(700, _ => render(renderEl, content))()

            if(lan && primsjs.languages[lan]) {
                content = primsjs.highlight(content, primsjs.languages[lan], lan);
                sectionElement.querySelector('code').innerHTML = content; 
            }
        },

        onFocus: function(el, editor, args) {
            var isCaretInsideCaption = (editor.sectionAtCaretPostion() === el && editor.caret.getContextElement(['caption'])),
                code = el.querySelector('code');

            if(!isCaretInsideCaption && code) {
                editor.caret.positionIn(code);
            }
        },

        getOptions: function(sectionElement) {
            return [
                {
                  name: 'displayCaption',
                  displayName: 'Display Caption',
                  allowedValues: ['Yes', 'No'],
                  defaultValue: sectionElement.getAttribute('display-caption')
                }
            ]
        },

        onOptionsChange: function(opt, editor) {
            var section = editor.focusedSection();
            if(opt.displayCaption === 'Yes' || opt.displayCaption === 'No') {
                section.setAttribute('display-caption', opt.displayCaption);
            }
        },

        onKeyTab: codeSectionType.onKeyTab,
        onKeyUp: codeSectionType.onKeyUp,
        onKeyDown: codeSectionType.onKeyDown,
        onKeyBackspace: codeSectionType.onKeyBackspace,
        onKeyEnter: codeSectionType.onKeyEnter,
        getSectionElement: getSectionElement,
    });

    sectionType.contentRules[tagName] = {
        tagName: tagName,
        className: tagName,
        allowedAttributes: ['class', 'display-caption', 'id'],
        allowedClassNames: ['focused', tagName, 'm2dia'],
        allowedChildren: ['m2dia-caption', 'm2dia-pre'],
        pruneSpaces: true,
        allowedToBeRoot: true,
        deleteIfEmpty: false,
        buildEmptyElement: sectionType.getSectionElement,
        defaultCaption: defaultCaption,
        buildAttributes: [
            {name: 'display-caption', build: function() {return 'Yes'}},
            {name: 'id', build: function() {return uuid()}}
        ]
    };

    sectionType.tagTransformations = {};
    sectionType.tagTransformations['/'+tagName+'/div.render'] = '#no-content';
    sectionType.tagTransformations['/'+tagName+'/pre/code'] = '#text-content';

    return sectionType;
}


/***/ }),

/***/ "../structured-text-editor/src/section_types/shared/shared.js":
/*!********************************************************************!*\
  !*** ../structured-text-editor/src/section_types/shared/shared.js ***!
  \********************************************************************/
/***/ ((module) => {

module.exports = {
    onKeyUpForFreestyleSections: function(e, editor) {
        var focusedSection = editor.focusedSection(),
            upperSection = focusedSection.previousSibling;

        if(!upperSection) { return true; }

        if(editor.caret.isCollapsedAndPositionedAtTheBeginningOf(focusedSection)) {
            editor.placeCaretIntoSection(upperSection);

            // trigger the removal of empty sections
            editor.replaceSectionWithHTML(focusedSection, focusedSection.outerHTML);
            e.preventDefault();
        }
    },

    onKeyDownForFreestyleSections: function(e, editor) {
        var focusedSection = editor.focusedSection(),
            lowerSection = focusedSection.nextSibling;

        if(!lowerSection) { return true; }

        if(editor.caret.isCollapsedAndPositionedAtTheEndOf(focusedSection)) {
            editor.placeCaretIntoSection(lowerSection);

            // trigger the removal of empty sections
            editor.replaceSectionWithHTML(focusedSection, focusedSection.outerHTML);
            e.preventDefault();
        }
    },

    onKeyEnterForFreestyleSections: function(e, editor) {
        document.execCommand('insertHTML', false, '&NewLine;');

        var char = editor.caret.getPrecedingCharacter(editor.focusedSection());
        if(char !== '\n') {
            document.execCommand('insertHTML', false, '&NewLine;');
        }

        e.preventDefault();

        // We do not have to set the content of the editor because execcommand triggers
        // an input event which will handle the content change on the editor site.
    },

    onKeyBackspaceForBackspaceDeletableSections: function(e, editor) {
        var focusedSection = editor.focusedSection(),
            upperSection = focusedSection.previousSibling;

        if(!upperSection) { return true; }

        if(focusedSection.innerText.trim() === '') {
            editor.placeCaretIntoSection(upperSection);

            // trigger the removal of empty sections
            editor.replaceSectionWithHTML(focusedSection, focusedSection.outerHTML);
            e.preventDefault();
        }
    }
}


/***/ }),

/***/ "../structured-text-editor/src/section_types/table/table_section_type.js":
/*!*******************************************************************************!*\
  !*** ../structured-text-editor/src/section_types/table/table_section_type.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uuid = __webpack_require__(/*! uuid/v1 */ "../structured-text-editor/node_modules/uuid/v1.js");
var utils = __webpack_require__(/*! ../../../lib/pixelschubser/utils */ "../structured-text-editor/lib/pixelschubser/utils.js");
var lastFocusedCell, focusedCell, onUnfocusTimeout;

var getSectionElement = function(existingSectionContent) {
    var tableElement = document.createElement('table');
    tableElement.id = uuid();
    tableElement.sectionType = module.exports;
    tableElement.setAttribute('display-heading', 'Yes');
    tableElement.setAttribute('display-caption', 'Yes');

    tableElement.onKeyUp = module.exports.onKeyUp;
    tableElement.onKeyDown = module.exports.onKeyDown;
    tableElement.onKeyTab = module.exports.onKeyTab;
    tableElement.onKeyCombination = module.exports.onKeyCombination;
    tableElement.onKeyBackspace = module.exports.onKeyBackspace;
    tableElement.onKeyEnter = module.exports.onKeyEnter;
    tableElement.onSelectionChange = module.exports.onSelectionChange;
    tableElement.onUnfocus = module.exports.onUnfocus;
    tableElement.onWindowResize = module.exports.onWindowResize;

    tableElement.innerHTML = '<tbody>' +
                             '  <tr><td></td><td></td></tr>' +
                             '  <tr><td></td><td></td></tr>' +
                             '  <tr><td></td><td></td></tr>' +
                             '</tbody>' +
                             '<caption>table title</caption>';

    return tableElement;
}

var getAddRowBelowButton = function(editor) {
    var btn = document.querySelector('#tableAddRowBelowBtn');

    if(btn) {
        return btn;
    }

    var btn = document.createElement('span');
    btn.id = 'tableAddRowBelowBtn';
    btn.innerHTML = '<svg id="Layer_1" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" width="12.67" height="19.69" viewBox="0 0 12.67 19.69"><defs><style>.cls-1,.cls-3{fill:none;}.cls-1{stroke:#231f20;}.cls-1,.cls-2,.cls-3{stroke-miterlimit:10;}.cls-2{fill:#98cf8d;}.cls-2,.cls-3{stroke:#297027;}</style></defs><polyline class="cls-1" points="5.98 1.26 5.98 7.07 5.98 12.72 5.98 18.42"/><path class="cls-1" d="M327.38,413.59" transform="translate(-326.88 -401.94)"/><rect class="cls-1" x="0.5" y="1.26" width="10.97" height="17.17"/><polyline class="cls-1" points="11.47 7.07 5.98 7.07 0.5 7.07"/><polyline class="cls-1" points="11.47 12.72 5.98 12.72 0.5 12.72"/><path class="cls-2" d="M339.05,402.44c0,2.07,0,4.13-.05,6.19h-6.13v-6.19Z" transform="translate(-326.88 -401.94)"/><path class="cls-2" d="M339,408.63c0,2.25,0,4.5-.06,6.75h-6.07v-6.75Z" transform="translate(-326.88 -401.94)"/><path class="cls-2" d="M338.94,415.38c0,1.92,0,3.83,0,5.75h-6v-5.75Z" transform="translate(-326.88 -401.94)"/><line class="cls-3" x1="5.99" y1="6.69" x2="5.98" y2="6.69"/><line class="cls-3" x1="5.99" y1="13.44" x2="5.98" y2="13.44"/></svg>';

    btn.onmousedown = function(e) {
        setTimeout(function() {
            module.exports.addRow(undefined, editor);
        }, 100);
    }

    return btn;
}

var getAddRowAboveButton = function(editor) {
    var btn = document.querySelector('#tableAddRowAboveBtn');

    if(btn) {
        return btn;
    }

    var btn = document.createElement('span');
    btn.id = 'tableAddRowAboveBtn';
    btn.innerHTML = '<svg id="Layer_1" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" width="12.37" height="19.69" viewBox="0 0 12.37 19.69"><defs><style>.cls-1,.cls-3{fill:none;}.cls-1{stroke:#231f20;}.cls-1,.cls-2,.cls-3{stroke-miterlimit:10;}.cls-2{fill:#98cf8d;}.cls-2,.cls-3{stroke:#297027;}</style></defs><path class="cls-1" d="M300.83,397.41" transform="translate(-299.93 -385.76)"/><rect class="cls-1" x="0.9" y="1.26" width="10.97" height="17.17"/><polyline class="cls-1" points="6.38 1.26 6.38 7.07 6.38 12.72 6.38 18.42"/><polyline class="cls-1" points="11.87 7.07 6.38 7.07 0.9 7.07"/><polyline class="cls-1" points="11.87 12.72 6.38 12.72 0.9 12.72"/><path class="cls-2" d="M306.61,386.26c0,2.06,0,4.13-.05,6.19h-6.13v-6.19Z" transform="translate(-299.93 -385.76)"/><path class="cls-2" d="M306.56,392.45q0,3.38-.05,6.75h-6.08v-6.75Z" transform="translate(-299.93 -385.76)"/><path class="cls-2" d="M306.51,399.2c0,1.92,0,3.83,0,5.75h-6V399.2Z" transform="translate(-299.93 -385.76)"/><line class="cls-3" x1="0.5" y1="6.69" x2="0.49" y2="6.69"/><line class="cls-3" x1="0.5" y1="13.44" x2="0.49" y2="13.44"/></svg>';

    btn.onmousedown = function(e) {
        setTimeout(function() {
            module.exports.addRow(undefined, editor, true);
        }, 100);
    }

    return btn;
}

var getDeleteRowButton = function(editor) {
    var btn = document.querySelector('#tableDeleteRowBtn');

    if(btn) {
        return btn;
    }

    var btn = document.createElement('span');
    btn.id = 'tableDeleteRowBtn';
    btn.innerHTML = '<svg data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" width="17.96" height="19.69" viewBox="0 0 17.96 19.69"><defs></defs><rect class="cls-1-red" x="0.5" y="1.36" width="16.96" height="16.96"/><path class="cls-1-red" d="M316.57,393" transform="translate(-295.66 -385.76)"/><polyline class="cls-1-red" points="0.5 7.27 5.99 7.27 11.91 7.27 17.47 7.27"/><polyline class="cls-1-red" points="0.5 12.62 5.99 12.62 11.91 12.62 17.47 12.62"/><polyline class="cls-1-red" points="5.99 1.36 5.99 7.27 5.99 12.62 5.99 18.32"/><polyline class="cls-1-red" points="11.91 1.36 11.91 7.27 11.91 12.62 11.91 18.32"/><path class="cls-2-red" d="M307.86,386.26c0,2.06,0,4.13-.05,6.19h-6.13v-6.19Z" transform="translate(-295.66 -385.76)"/><path class="cls-2-red" d="M307.81,392.45q0,3.38-.05,6.75h-6.08v-6.75Z" transform="translate(-295.66 -385.76)"/><path class="cls-2-red" d="M307.76,399.2c0,1.92,0,3.83-.05,5.75h-6V399.2Z" transform="translate(-295.66 -385.76)"/><line class="cls-2-red" x1="6.02" y1="6.69" x2="6.01" y2="6.69"/><line class="cls-2-red" x1="6.02" y1="13.44" x2="6.01" y2="13.44"/></svg>';

    btn.onmousedown = function(e) {
        setTimeout(function() {
            module.exports.deleteRow(undefined, editor);
        }, 100);
    }

    return btn;
}

var getAddColumnLeftButton = function(editor) {
    var btn = document.querySelector('#tableAddColumnLeftBtn');

    if(btn) {
        return btn;
    }

    var btn = document.createElement('span');
    btn.id = 'tableAddColumnLeftBtn';
    btn.innerHTML = '<svg id="Layer_1" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" width="12.37" height="19.69" viewBox="0 0 12.37 19.69"><defs><style>.cls-1,.cls-3{fill:none;}.cls-1{stroke:#231f20;}.cls-1,.cls-2,.cls-3{stroke-miterlimit:10;}.cls-2{fill:#98cf8d;}.cls-2,.cls-3{stroke:#297027;}</style></defs><path class="cls-1" d="M300.83,397.41" transform="translate(-299.93 -385.76)"/><rect class="cls-1" x="0.9" y="1.26" width="10.97" height="17.17"/><polyline class="cls-1" points="6.38 1.26 6.38 7.07 6.38 12.72 6.38 18.42"/><polyline class="cls-1" points="11.87 7.07 6.38 7.07 0.9 7.07"/><polyline class="cls-1" points="11.87 12.72 6.38 12.72 0.9 12.72"/><path class="cls-2" d="M306.61,386.26c0,2.06,0,4.13-.05,6.19h-6.13v-6.19Z" transform="translate(-299.93 -385.76)"/><path class="cls-2" d="M306.56,392.45q0,3.38-.05,6.75h-6.08v-6.75Z" transform="translate(-299.93 -385.76)"/><path class="cls-2" d="M306.51,399.2c0,1.92,0,3.83,0,5.75h-6V399.2Z" transform="translate(-299.93 -385.76)"/><line class="cls-3" x1="0.5" y1="6.69" x2="0.49" y2="6.69"/><line class="cls-3" x1="0.5" y1="13.44" x2="0.49" y2="13.44"/></svg>';

    btn.onmousedown = function(e) {
        setTimeout(function() {
            module.exports.addColumn(undefined, editor, true);
        }, 100);
    }

    return btn;
}

var getAddColumnRightButton = function(editor) {
    var btn = document.querySelector('#tableAddColumnRightBtn');

    if(btn) {
        return btn;
    }

    var btn = document.createElement('span');
    btn.id = 'tableAddColumnRightBtn';
    btn.innerHTML = '<svg id="Layer_1" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" width="12.67" height="19.69" viewBox="0 0 12.67 19.69"><defs><style>.cls-1,.cls-3{fill:none;}.cls-1{stroke:#231f20;}.cls-1,.cls-2,.cls-3{stroke-miterlimit:10;}.cls-2{fill:#98cf8d;}.cls-2,.cls-3{stroke:#297027;}</style></defs><polyline class="cls-1" points="5.98 1.26 5.98 7.07 5.98 12.72 5.98 18.42"/><path class="cls-1" d="M327.38,413.59" transform="translate(-326.88 -401.94)"/><rect class="cls-1" x="0.5" y="1.26" width="10.97" height="17.17"/><polyline class="cls-1" points="11.47 7.07 5.98 7.07 0.5 7.07"/><polyline class="cls-1" points="11.47 12.72 5.98 12.72 0.5 12.72"/><path class="cls-2" d="M339.05,402.44c0,2.07,0,4.13-.05,6.19h-6.13v-6.19Z" transform="translate(-326.88 -401.94)"/><path class="cls-2" d="M339,408.63c0,2.25,0,4.5-.06,6.75h-6.07v-6.75Z" transform="translate(-326.88 -401.94)"/><path class="cls-2" d="M338.94,415.38c0,1.92,0,3.83,0,5.75h-6v-5.75Z" transform="translate(-326.88 -401.94)"/><line class="cls-3" x1="5.99" y1="6.69" x2="5.98" y2="6.69"/><line class="cls-3" x1="5.99" y1="13.44" x2="5.98" y2="13.44"/></svg>';

    btn.onmousedown = function(e) {
        setTimeout(function() {
            module.exports.addColumn(undefined, editor);
        }, 100);
    }

    return btn;
}

var getDeleteColumnButton = function(editor) {
    var btn = document.querySelector('#tableDeleteColumnBtn');

    if(btn) {
        return btn;
    }

    var btn = document.createElement('span');
    btn.id = 'tableDeleteColumnBtn';
    btn.innerHTML = '<svg data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" width="17.96" height="19.69" viewBox="0 0 17.96 19.69"><defs></defs><rect class="cls-1-red" x="0.5" y="1.36" width="16.96" height="16.96"/><path class="cls-1-red" d="M316.57,393" transform="translate(-295.66 -385.76)"/><polyline class="cls-1-red" points="0.5 7.27 5.99 7.27 11.91 7.27 17.47 7.27"/><polyline class="cls-1-red" points="0.5 12.62 5.99 12.62 11.91 12.62 17.47 12.62"/><polyline class="cls-1-red" points="5.99 1.36 5.99 7.27 5.99 12.62 5.99 18.32"/><polyline class="cls-1-red" points="11.91 1.36 11.91 7.27 11.91 12.62 11.91 18.32"/><path class="cls-2-red" d="M307.86,386.26c0,2.06,0,4.13-.05,6.19h-6.13v-6.19Z" transform="translate(-295.66 -385.76)"/><path class="cls-2-red" d="M307.81,392.45q0,3.38-.05,6.75h-6.08v-6.75Z" transform="translate(-295.66 -385.76)"/><path class="cls-2-red" d="M307.76,399.2c0,1.92,0,3.83-.05,5.75h-6V399.2Z" transform="translate(-295.66 -385.76)"/><line class="cls-2-red" x1="6.02" y1="6.69" x2="6.01" y2="6.69"/><line class="cls-2-red" x1="6.02" y1="13.44" x2="6.01" y2="13.44"/></svg>';

    btn.onmousedown = function(e) {
        setTimeout(function() {
            module.exports.deleteColumn(undefined, editor);
        }, 100);
    }

    return btn;
}

var getHorizontalControlsBar = function(editor) {
    var bar = document.querySelector('#horizontalTableControlsBar');

    if(bar) {
        return bar;
    }

    bar = document.createElement('div');
    bar.id = 'horizontalTableControlsBar';
    bar.classList.add('tableControlsBar');

    var arrow = document.createElement('div');
    arrow.classList.add('arrow')

    bar.appendChild(getAddColumnLeftButton(editor));
    bar.appendChild(getDeleteColumnButton(editor));
    bar.appendChild(getAddColumnRightButton(editor));
    bar.appendChild(arrow);

    bar.onclick = function(e) {
        e.preventDefault();
        return false;
    }

    document.body.appendChild(bar);

    return bar;
}

var getVerticalControlsBar = function(editor) {
    var bar = document.querySelector('#verticalTableControlsBar');

    if(bar) {
        return bar;
    }

    bar = document.createElement('div');
    bar.id = 'verticalTableControlsBar';
    bar.classList.add('tableControlsBar')

    var arrow = document.createElement('div');
    arrow.classList.add('arrow')

    bar.appendChild(getAddRowAboveButton(editor));
    bar.appendChild(getDeleteRowButton(editor));
    bar.appendChild(getAddRowBelowButton(editor));
    bar.appendChild(arrow);

    bar.onclick = function(e) {
        e.preventDefault();
        return false;
    }

    document.body.appendChild(bar);

    return bar;
}

Object.assign(module.exports, {

    name: 'table',

    contentRules: {
        'table': {
            tagName: 'table',
            allowedAttributes: ['class', 'display-heading', 'display-caption', 'id'],
            allowedClassNames: ['focused'],
            allowedChildren: ['tbody', 'caption'],
            childrenCardinality: {'caption': {max: 1}},
            allowedToBeRoot: true,
            deleteIfEmpty: false,
            buildEmptyElement: getSectionElement,
            buildAttributes: [
                {name: 'id', build: function() {return uuid()}},
                {name: 'display-heading', build: function() {return 'Yes'}},
                {name: 'display-caption', build: function() {return 'Yes'}}
            ]
        },
        'caption': {
            tagName: 'caption',
            allowedChildren: ['#text', 'reference', 'inlineequation'],
            deleteIfEmpty: false,
            pruneSpaces: true,
        },
        'tbody': {
            tagName: 'tbody',
            allowedSuccessors: ['caption'],
            allowedChildren: ['tr'],
        },
        'tr': {
            tagName: 'tr',
            allowedChildren: ['td'],
        },
        'td': {
            tagName: 'td',
            allowedChildren: ['#text', 'b', 'i', 'u', 'link', 'footnote', 'reference', 'inlinecode', 'inlineequation'],
            doNotBreakOutRootElements: true,
            pruneSpaces: true
        }
    },

    getOptions: function(sectionElement) {
        return [
            {
              name: 'displayHeading',
              displayName: 'Display Head Row',
              allowedValues: ['Yes', 'No'],
              defaultValue: sectionElement.getAttribute('display-heading')
            },
            {
              name: 'displayCaption',
              displayName: 'Display Table Caption',
              allowedValues: ['Yes', 'No'],
              defaultValue: sectionElement.getAttribute('display-caption')
            }
        ]
    },

    onFocus: function(el, editor, args) {
        var td = el.querySelector('td'),
            isCaretInsideTable = (editor.sectionAtCaretPostion() === el && editor.caret.getContextElement(['td', 'caption'])),
            hasBeenFocusedAfterSectionTypeChange = args.action === 'changeFocusedSectionType';

        if(hasBeenFocusedAfterSectionTypeChange || !isCaretInsideTable) {
            td && editor.caret.positionIn(td);
        }
    },

    onOptionsChange: function(opt, editor) {
        var section = editor.focusedSection();
        if(opt.displayHeading === 'Yes' || opt.displayHeading === 'No') {
            section.setAttribute('display-heading', opt.displayHeading);
        }

        if(opt.displayCaption === 'Yes' || opt.displayCaption === 'No') {
            section.setAttribute('display-caption', opt.displayCaption);
        }
    },

    getVerticalNeighborField: function(td, lowerNeighbor) {
        if(!td) { return }

        var xIndex = Array.prototype.indexOf.call(td.parentElement.children, td),
            neighborRow = td.parentNode && td.parentNode[(lowerNeighbor ? 'nextSibling' : 'previousSibling')],
            colspan, tmpField;

        if(!neighborRow) { return }

        for(var i=0; i<=xIndex;) {
            colspan = parseInt(neighborRow.children[i].getAttribute('colspan')) || 1;
            tmpField = neighborRow.children[i];
            i += colspan;
        }

        return tmpField;
    },

    getNextField: function(td) {
        if(td.nextSibling) {
            return td.nextSibling;
        }

        if(td.parentElement &&
           td.parentElement.nextSibling &&
           td.parentElement.nextSibling.children &&
           td.parentElement.nextSibling.children[0] &&
           td.parentElement.nextSibling.children[0].tagName === 'TD') {
             return td.parentElement.nextSibling.children[0];
        }
    },

    getPreviousField: function(td) {
        if(td.previousSibling) {
            return td.previousSibling;
        }

        if(td.parentElement &&
           td.parentElement.previousSibling &&
           td.parentElement.previousSibling.children &&
           td.parentElement.previousSibling.children[td.parentElement.previousSibling.children.length-1] &&
           td.parentElement.previousSibling.children[td.parentElement.previousSibling.children.length-1].tagName === 'TD') {
             return td.parentElement.previousSibling.children[td.parentElement.previousSibling.children.length-1];
        }
    },

    onKeyUp: function(e, editor) {
        var targetField = module.exports.getVerticalNeighborField(editor.caret.getContextElement('td'));

        if(targetField) {
            editor.caret.positionIn(targetField);
        } else {
            editor.placeCaretIntoSection(editor.focusedSection().previousSibling);
        }

        e.preventDefault();
    },

    onKeyDown: function(e, editor) {
        var targetField = module.exports.getVerticalNeighborField(editor.caret.getContextElement('td'), true);

        if(targetField) {
            editor.caret.positionIn(targetField);
        } else {
            editor.placeCaretIntoSection(editor.focusedSection().nextSibling);
        }

        e.preventDefault();
    },

    onKeyTab: function(e, editor) {

        var getTargetField = e.shiftKey ? module.exports.getPreviousField: module.exports.getNextField,
            targetField = getTargetField(editor.caret.getContextElement('td'));

        if(targetField) {
            editor.caret.positionIn(targetField);
        }

        e.preventDefault();
    },

    onKeyEnter: function(e) {
        e.preventDefault();
    },

    onWindowResize: function(editor) {
        module.exports.onSelectionChange(editor, true);
    },

    onSelectionChange: function(editor, force) {
        var cell = editor.caret.getContextElement('td');

        if(!cell) {
            this.onUnfocus(editor);
            return;
        }

        var table = cell.parentElement.parentElement.parentElement;

        if(focusedCell !== cell || force) {
            window.clearTimeout(onUnfocusTimeout);
            var hbar = getHorizontalControlsBar(editor);
            var vbar = getVerticalControlsBar(editor);
            var tablePos = utils.getElementPosition(table);
            var cellPos = utils.getElementPosition(cell);

            hbar.style.opacity = 1;
            hbar.style.top = (tablePos.y - 32) + 'px';
            hbar.style.left = Math.floor(cellPos.x + ((cell.offsetWidth/2)-(hbar.offsetWidth/2))) + 'px';

            vbar.style.opacity = 1;
            vbar.style.top = Math.floor(cellPos.y + ((cell.offsetHeight/2)-(vbar.offsetHeight/2))) + 'px';
            vbar.style.left = (tablePos.x - 30) + 'px';
        }

        focusedCell = cell;
    },

    onUnfocus: function(editor) {
        var hbar = getHorizontalControlsBar(editor);
        var vbar = getVerticalControlsBar(editor);

        lastFocusedCell = focusedCell;
        focusedCell = null;

        hbar.style.opacity = 0;
        vbar.style.opacity = 0;

        onUnfocusTimeout = window.setTimeout(function() {
            hbar.style.top = -1000 + 'px';
            hbar.style.left = -1000 + 'px';

            vbar.style.top = -1000 + 'px';
            vbar.style.left = -1000 + 'px';
        }, 100);
    },

    onKeyCombination: function(e, editor) {
        if((e.metaKey || e.ctrlKey) && !e.shiftKey && e.key === 'r') {
            module.exports.addRow(editor.caret.getContextElement('td'), editor);
            e.preventDefault();
        } else if((e.metaKey || e.ctrlKey) && !e.shiftKey && e.key === 'e') {
            module.exports.addColumn(editor.caret.getContextElement('td'), editor);
            e.preventDefault();
        } else if((e.metaKey || e.ctrlKey) && e.shiftKey && (e.key === 'e' || e.key === 'E') ) {
            module.exports.deleteColumn(editor.caret.getContextElement('td'), editor);
            e.preventDefault();
        } else if((e.metaKey || e.ctrlKey) && e.shiftKey && (e.key === 'r' || e.key === 'R') ) {
            module.exports.deleteRow(editor.caret.getContextElement('td'), editor);
            e.preventDefault();
        }
    },

    addRow: function(contextElement, editor, insertBefore) {
        var sel;
        if(!contextElement && !editor) { return }

        contextElement = contextElement || lastFocusedCell || editor.caret.getContextElement('td');

        if(!contextElement) {
            sel = window.getSelection();
            if(sel.anchorNode === sel.focusNode &&
               sel.anchorNode.tagName &&
               sel.anchorNode.tagName.toLowerCase() === 'tbody') {
                contextElement = sel.anchorNode.children[sel.anchorOffset].children[0];
            }
        }

        var colcount = contextElement.parentNode.children.length,
            currentTr = contextElement.parentNode,
            tbody = currentTr.parentNode,
            table = editor.sectionByChildNode(tbody),
            newTr = document.createElement('tr');

        for(let i=0; i<colcount; i++) {
            newTr.appendChild(document.createElement('td'));
        }

        tbody.insertBefore(newTr, insertBefore ? currentTr : currentTr.nextSibling);
        editor.replaceSectionWithHTML(table, table.outerHTML);
    },

    addColumn: function(contextElement, editor, insertLeft) {
        var sel;
        if(!contextElement && !editor) { return }
        contextElement = contextElement || lastFocusedCell || editor.caret.getContextElement('td');

        if(!contextElement) {
            sel = window.getSelection();
            if(sel.anchorNode === sel.focusNode &&
               sel.anchorNode.tagName &&
               sel.anchorNode.tagName.toLowerCase() === 'tr') {
                contextElement = sel.anchorNode.children[sel.anchorOffset];
            }
        }

        var colIndex = Array.prototype.indexOf.call(contextElement.parentNode.children, contextElement),
            tableRows = contextElement.parentNode.parentNode.children,
            table = contextElement.parentNode.parentNode.parentNode;

        Array.prototype.forEach.call(tableRows, function(tr) {
            tr.insertBefore(document.createElement('td'), insertLeft ? tr.children[colIndex] : tr.children[colIndex].nextSibling)
        });

        editor.replaceSectionWithHTML(table, table.outerHTML);
    },

    deleteColumn: function(contextElement, editor) {
        var sel;

        if(!contextElement && !editor) { return }

        contextElement = contextElement || lastFocusedCell || editor.caret.getContextElement('td');

        if(!contextElement) {
            sel = window.getSelection();
            if(sel.anchorNode === sel.focusNode &&
               sel.anchorNode.tagName &&
               sel.anchorNode.tagName.toLowerCase() === 'tr') {
                contextElement = sel.anchorNode.children[sel.anchorOffset];
            }
        }

        var columns = contextElement.parentNode.children,
            colIndex = Array.prototype.indexOf.call(columns, contextElement),
            tableRows = contextElement.parentNode.parentNode.children,
            table = contextElement.parentNode.parentNode.parentNode;

        if(columns.length <= 1) {
            return;
        }

        Array.prototype.forEach.call(tableRows, function(tr) {
            tr.removeChild(tr.children[colIndex])
        });
        editor.replaceSectionWithHTML(table, table.outerHTML);
    },

    deleteRow: function(contextElement, editor) {
        var sel, table;

        if(!contextElement && !editor) { return }

        contextElement = contextElement || lastFocusedCell || editor.caret.getContextElement('td');
        contextElement = contextElement.parentElement;

        if(!contextElement) {
            sel = window.getSelection();
            if(sel.anchorNode === sel.focusNode &&
               sel.anchorNode.tagName &&
               sel.anchorNode.tagName.toLowerCase() === 'tbody') {
                contextElement = sel.anchorNode.children[sel.anchorOffset];
            }
        }

        table = contextElement.parentNode.parentNode;

        if(contextElement.parentNode.children.length <= 1) {
            return;
        }

        contextElement.remove();
        editor.replaceSectionWithHTML(table, table.outerHTML);
    },

    onKeyBackspace: function(e, editor) {
        var sel,
            table = editor.caret.getContextElement('table'),
            caption = editor.caret.getContextElement('caption', window.getSelection(), []),
            td = editor.caret.getContextElement('td', window.getSelection(), []),
            inCaption = !!caption,
            el = td || caption,
            tableId = table.id,
            tr, trIndex, tdIndex;

        if(!el) return;

        if(el.innerText && el.innerText.length === 1) {
            if(!inCaption) {
                tr = td.parentElement;
                tdIndex = tr.children.indexOf(td);
                trIndex = tr.parentElement.children.indexOf(tr);
            }

            document.execCommand('delete');

            table = document.getElementById(tableId);

            if(!inCaption) {
                el = table.querySelector('tbody').children[trIndex].children[tdIndex];
            } else {
                el = table.querySelector('caption')
            }

            editor.caret.positionIn(el);

            e.preventDefault();
        } else if(!el.innerText || el.innerText.length === 0 || editor.caret.isCollapsedAndPositionedAtTheBeginningOf(caption, false)) {
            e.preventDefault();
        }
    },

    getSectionElement: getSectionElement
})


/***/ }),

/***/ "../structured-text-editor/src/section_types/toc/toc_section_type.js":
/*!***************************************************************************!*\
  !*** ../structured-text-editor/src/section_types/toc/toc_section_type.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var buildToC = __webpack_require__(/*! ../../../lib/toc_builder/toc_builder */ "../structured-text-editor/lib/toc_builder/toc_builder.js"),
    bibSectionType = __webpack_require__(/*! ../bibliographie/bibliographie_section_type */ "../structured-text-editor/src/section_types/bibliographie/bibliographie_section_type.js"),
    uuid = __webpack_require__(/*! uuid/v1 */ "../structured-text-editor/node_modules/uuid/v1.js");

function getSectionElement() {
    var  el = document.createElement('nav'),
         heading = document.createElement('h2');

    heading.setAttribute('contenteditable', 'true');
    heading.classList.add('toc-heading');
    heading.classList.add('no-toc-listing');
    heading.innerHTML = 'Table of Contents';

    el.onKeyBackspace = module.exports.onKeyBackspace;
    el.sectionType = module.exports;
    el.classList.add('toc');
    el.appendChild(heading);

    return el;
}

module.exports = {

    name: 'toc',

    preferredCaretPositioning: 'end',

    contentRules: {
        'toc': {
            tagName: 'nav',
            className: 'toc',
            allowedAttributes: ['class', 'contenteditable'],
            allowedClassNames: ['focused', 'toc'],
            allowedChildren: ['toc-heading'],
            allowedToBeRoot: true,
            deleteIfEmpty: false,
            buildEmptyElement: getSectionElement
        },
        'toc-heading': {
            tagName: 'h2',
            className: 'toc-heading',
            allowedAttributes: ['id', 'class', 'contenteditable', 'unnumbered-heading'],
            allowedClassNames: ['toc-heading', 'no-toc-listing'],
            allowedChildren: ['#text'],
            pruneSpaces: true,
            buildAttributes: [
                {name: 'id', build: function() {return uuid()}},
                {name: 'unnumbered-heading', build: function() {return 'Yes'}}
            ]
        },
    },

    enrichments: [],

    getSectionElement: getSectionElement,

    onKeyBackspace: bibSectionType.onKeyBackspace,

    onFocus: function(el, editor, args) {
        var toCHeading = el.querySelector('h2'),
            isCaretInsideSection = (editor.sectionAtCaretPostion() === el && editor.caret.getContextElement('h2')),
            hasBeenFocusedAfterSectionTypeChange = args.action === 'changeFocusedSectionType';

        if(hasBeenFocusedAfterSectionTypeChange || !isCaretInsideSection) {
            toCHeading && editor.caret.positionIn(toCHeading);
        }
    },

    onEditorContentChanged: function(modificationLog) {
        if(!modificationLog.mightIncludeHeadingUpdates && !modificationLog.mightIncludeTableOfContentUpdates) {
            return;
        }

        var tocSections = document.querySelectorAll('nav.toc'),
            newContent, tmpEl, toc;

        if(tocSections.length === 0) { return; }

        toc = buildToC(document.querySelector('.structured-text-editor'), {withLinks: true, startNumberingAtLevel: 2});
        toc.querySelectorAll('ol, li').forEach(function(entry) { entry.classList.add('toc') });
        toc.classList.add('toc');

        if(toc.innerHTML === '') {
            newContent = '<span class="hint">Insert some headings into your document to see a table of contents here.</span>';
        } else {
            newContent = toc.outerHTML;
        }

        tocSections.forEach(function(tocSection) {
            tocSection.summarizedContentLength = undefined;
            tmpEl = tocSection.querySelector('.toc-content');

            if(!tmpEl) {
                tmpEl = document.createElement('span');
                tmpEl.classList.add('toc-content');
                tocSection.appendChild(tmpEl);
            }

            tmpEl.setAttribute('contenteditable', 'false');

            if(tmpEl.innerHTML !== newContent) {
                tmpEl.innerHTML = newContent;
            }
        });
    }
}


/***/ }),

/***/ "../structured-text-editor/src/text_enrichment_control.js":
/*!****************************************************************!*\
  !*** ../structured-text-editor/src/text_enrichment_control.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Caret = __webpack_require__(/*! ./caret */ "../structured-text-editor/src/caret.js"),
    HTMLRazor = __webpack_require__(/*! ../lib/html_razor/html_razor */ "../structured-text-editor/lib/html_razor/html_razor.js"),
    utils = __webpack_require__(/*! ../lib/pixelschubser/utils */ "../structured-text-editor/lib/pixelschubser/utils.js"),
    // katex = require('katex'), // make sure to load <script src="./katex.js" defer></script> in your html
    latexCheatsheet = __webpack_require__(/*! ../assets/latex_cheatsheet */ "../structured-text-editor/assets/latex_cheatsheet.js"),
    DeclarativForm = __webpack_require__(/*! ../lib/declarativ_forms/src/declarativ_form */ "../structured-text-editor/lib/declarativ_forms/src/declarativ_form.js"),
    { getReferenceSourcesFields, syncAllSources } = __webpack_require__(/*! ./references/reference_sources */ "../structured-text-editor/src/references/reference_sources/index.js")

function TextEnrichmentControl(editor) {
    var self = this;

    this.caret = new Caret(editor);
    this.editor = editor;
    this.visible = false;
    this.domElement = document.createElement('div');
    this.domElement.className += ' textEnrichmentControl';
    this.hide();

    document.body.appendChild(this.domElement);

    document.addEventListener ("keydown", function (e) {
        if(e.code === 'Escape') {
            self.editor.unfreezeSelection();
            self.hide(true);
        }

        return true;
    });

    this.enrichments = [
        {className: 'italic',     command: 'italic',        diplayName: '<i>I</i>', allowedContext: ['p', 'table', 'ol', 'ul'], notAllowedContext: ['caption', 'nav']},
        {className: 'bold',       command: 'bold',          diplayName: '<b>B</b>', allowedContext: ['p', 'table', 'ol', 'ul'], notAllowedContext: ['caption', 'nav']},
        {className: 'underline',  command: 'underline',     diplayName: '<u>U</u>', allowedContext: ['p', 'table', 'ol', 'ul'], notAllowedContext: ['caption', 'nav']},
        {
            className: 'code',
            diplayName: '<code class="code-text-enrichment-button"><i class="fas fa-code"></i></code>',
            allowedContext: ['p', 'table', 'ol', 'ul'],
            notAllowedContext: ['caption', 'nav'],
            action: function() {
                var sel = window.getSelection(),
                    range = sel.getRangeAt(0),
                    newElement = document.createElement('inlinecode'),
                    section = self.editor.focusedSection(),
                    contextEl = self.caret.getContextElement('inlinecode'),
                    allCodesInSection, content, textNodeLeft, textNodeRight;

                if(contextEl) {
                    content = range.extractContents();
                    sel = window.getSelection();
                    range = sel.getRangeAt(0);

                    textNodeLeft = sel.focusNode;
                    textNodeRight = textNodeLeft.splitText(sel.focusOffset);

                    newElement.appendChild(textNodeRight);
                    contextEl.parentNode.insertBefore(newElement, contextEl.nextSibling);
                    contextEl.parentNode.insertBefore(content, contextEl.nextSibling);
                } else {
                    newElement.appendChild(range.extractContents());
                    range.insertNode(newElement);

                    allCodesInSection = section.querySelectorAll('inlinecode');

                    for(let i=0; i<allCodesInSection.length; i++) {
                        let next = allCodesInSection[i].nextSibling;

                        if(next && next.tagName === 'INLINECODE') {
                            allCodesInSection[i].innerHTML += next.innerHTML;
                            next.remove();
                            allCodesInSection = section.querySelectorAll('inlinecode');
                            i=-1;
                        }

                        if(next && next.nodeType === Node.TEXT_NODE && next.textContent === '') {
                            next.remove();
                            allCodesInSection = section.querySelectorAll('inlinecode');
                            i=-1;
                        }
                    }
                }

                self.hide();
            }
        },
        {
            className: 'link',
            command: 'createLink',
            diplayName: '<i class="fas fa-link fa-xs"></i>',
            allowedContext: ['p', 'table', 'ol', 'ul'],
            notAllowedContext: ['a', 'caption', 'nav'],
            arguments: [{name: 'url', placeholder: 'http://...', displayName: 'URL', type: 'text'}]
        },
        {
            className: 'unlink',
            rangeRequire: false,
            diplayName: '<i class="fas fa-unlink fa-xs"></i>',
            allowedContext: 'a',
            notAllowedContext: ['nav'],
            action: function(contextElement) {
                var parent = contextElement.parentNode;
                while (contextElement.firstChild) parent.insertBefore(contextElement.firstChild, contextElement);
                parent.removeChild(contextElement);
                self.hide();
            }
        },
        {
            rangeRequire: false,
            className: 'visit-link',
            diplayName: '<i class="fas fa-external-link-alt fa-xs"></i>',
            allowedContext: 'a',
            notAllowedContext: ['nav'],
            action: function(contextElement) {
                if(navigator && navigator.userAgent && navigator.userAgent.match('MonsterWriter')) {
                    var prefix = ''
                    if(!contextElement.getAttribute('href').match(/^https?:\/\//i)) {
                        prefix = 'https://'
                    }
                    // require('electron').shell.openExternal(prefix + contextElement.getAttribute('href'))
                } else {
                    window.open(contextElement.getAttribute('href'))
                }
            }
        },
        {
            className: 'edit-footnote',
            rangeRequire: false,
            diplayName: '<i class="fas fa-edit fa-xs"></i>',
            allowedContext: '.footnote',
            notAllowedContext: ['caption'],
            arguments: [{
                name: 'note',
                placeholder: 'footnote',
                displayName: 'Footnote',
                largetext: true,
                defaultValue: function(contextElement) {
                    if(!(contextElement && contextElement.dataset && contextElement.dataset.note)) {
                        return '';
                    }

                    return utils.attributeSaveStringToString((new HTMLRazor).strip(contextElement.dataset.note));
                }
            }],
            action: function(contextElement, argValue) {
                if(!argValue.note) return;
                if(typeof argValue.note !== 'string') return;
                if(argValue.note.trim() === '') return;

                contextElement.setAttribute('data-note', utils.stringToAttributeSaveString(argValue.note));
            }
        },
        {
            className: 'footnote-content',
            rangeRequire: false,
            diplayName: function(contextElement) {
                return contextElement.innerText + ': ' + utils.attributeSaveStringToHTMLEncoded(contextElement.dataset.note);
            },
            allowedContext: '.footnote',
            action: function() {}
        },
        {
            rangeRequire: false,
            insertAction: true,
            className: 'footnote',
            diplayName: 'fn<sup>*</sup>',
            allowedContext: ['p', 'table', 'ol', 'ul'],
            notAllowedContext: ['caption', 'nav'],
            arguments: [{name: 'note', placeholder: 'footnote', displayName: 'Footnote', largetext: true}],
            action: function(contextElement, argValue) {
                if(!argValue.note) return;
                if(typeof argValue.note !== 'string') return;
                if(argValue.note.trim() === '') return;

                var node = document.createElement('span');

                node.classList.add('footnote');
                node.setAttribute('data-note', utils.stringToAttributeSaveString(argValue.note));
                node.setAttribute('contenteditable', false);
                self.caret.insertNode(node);
            }
        },
        {
            rangeRequire: false,
            insertAction: true,
            className: 'ref',
            diplayName: 'ref',
            allowedContext: ['p', 'table', 'ol', 'ul', 'citesrc', 'caption', 'figcaption'],
            notAllowedContext: ['a', 'blockquote', 'code'],
            notFocusFirstInput: true,
            arguments: [
                {
                    allowedValues: function() { return self.editor.reference.getValuesForCrossReferenceSelectBox() },
                    isActive: function() { return self.editor.reference.getValuesForCrossReferenceSelectBox().length },
                    name: 'cross-ref',
                    displayName: 'Reference a part of your document (figures, tables, ...):',
                    tab: 'Cross-Reference'
                },
                {
                    name: 'no-cross-ref-available-hint',
                    message: '<div class="no-data-hint"><div class="no-data-icon"></div><div class="no-data-message-heading">No Cross-References Available!</div><div class="no-data-message">Once you have inserted a heading, table, image, etc. into your document, you will be able to reference/select it here.</div></div>',
                    isActive: function() { return !self.editor.reference.getValuesForCrossReferenceSelectBox().length },
                    tab: 'Cross-Reference'
                },
                {
                    reloadOnChangeOf: ['fetch-ref-btn', 'manage-ref-btn'],
                    allowedValues: function() { return self.editor.reference.getValuesForExistingReferenceSelectBox() },
                    isActive: function() { return self.editor.reference.areExistingReferencesAvailable() },
                    name: 'existing-ref',
                    displayName: 'Reference work you\'ve referenced before:',
                    tab: 'Find Reference'
                },
                {
                    name: 'no-existing-reference-available-hint',
                    message: '<div class="no-data-hint"><div class="no-data-icon"></div><div class="no-data-message-heading">No References Available!</div><div class="no-data-message">Select the tab "Add Reference" to insert a new reference. The next time you want to reference the same work, it will show up here.</div></div>',
                    isActive: function() { return !self.editor.reference.areExistingReferencesAvailable() },
                    tab: 'Find Reference'
                },
                {
                    name: 'fetch-ref-btn',
                    isActive: function() { return self.editor.reference.areExistingReferencesAvailable() },
                    render: function(dom, formData, dlFrom) {
                        dom.innerHTML = ''
                        const addRefSrcBtn = document.createElement('div');
                        addRefSrcBtn.classList.add('fetch-external-ref-btn');
                        addRefSrcBtn.innerHTML = 'Fetch Newest Data From Reference Sources';

                        addRefSrcBtn.onclick = async function() {
                            if(addRefSrcBtn.classList.contains('fetch-external-ref-btn-loading')) {
                                return;
                            }

                            const extRefField = dlFrom.fields.find(field => field.name === 'existing-ref');
                            extRefField.domElement.setLoadingStatus();

                            addRefSrcBtn.classList.add('fetch-external-ref-btn-loading');
                            await syncAllSources(self.editor.reference.store);
                            await self.editor.reference.store.initCache();
                            await self.editor.reference.store.cleanupReferencesFromSources();
                            await new Promise(res => setTimeout(res, 1000));

                            extRefField.domElement.setLoadingStatus();
                            addRefSrcBtn.classList.remove('fetch-external-ref-btn-loading');

                            dom.onChange(true);
                        }

                        dom.appendChild(addRefSrcBtn);
                    },
                    tab: 'Find Reference',
                },
                {
                    name: 'manage-ref-btn',
                    render: function(dom) {
                        dom.innerHTML = ''
                        const addRefSrcBtn = document.createElement('div');
                        addRefSrcBtn.classList.add('add-external-ref-btn')
                        addRefSrcBtn.innerHTML = 'Manage Reference Sources (Zotero)'

                        addRefSrcBtn.onclick = async function() {
                            const referenceSourcesFields = await getReferenceSourcesFields(self.editor.reference.store)
                            const configForm = new DeclarativForm(
                                { fields: [...referenceSourcesFields] },
                                () => { dom.onChange(true) },
                                () => { dom.onChange(true) },
                                'Back to References')

                            configForm.openInModal()
                        }

                        dom.appendChild(addRefSrcBtn);
                    },
                    tab: 'Find Reference',
                },
                ...(!self.editor.reference ? [] : self.editor.reference.getExternalRefDialogAttributes().map(field => Object.assign(field, { tab: 'Add Reference' })))
            ],
            action: function(contextElement, formData) {
                var ref = formData && (formData['cross-ref'] || formData['existing-ref']);
                if(formData.activeTab === 'Add Reference') {
                    self.editor.reference.insertExternalReference(formData);
                } else if(ref) {
                    self.editor.reference.insertInternalReference({ref: ref});
                }
            }
        },
        {
            rangeRequire: false,
            className: 'edit-ref',
            diplayName: '<i class="fas fa-edit fa-xs"></i>',
            allowedContext: '.reference',
            shouldBeDisplayed: function(contextElement) {
                return contextElement.getAttribute('data-external') === 'true';
            },
            action: function(contextElement, formData) {
                self.editor.reference.showEditExternalRefDialog(contextElement);
            }
        },
        {
            className: 'reference-caption',
            rangeRequire: false,
            diplayName: function(contextElement) {
                var caption = self.editor.reference.getRefCaptionHTML(contextElement);
                caption = caption.replace(/\<b\>/g, '')
                                 .replace(/\<\/b\>/g, '')
                                 .replace(/\</g, '&lt;')
                                 .replace(/\>/g, '&gt;');
                return caption;
            },
            shouldBeDisplayed: function(contextElement) {
                var caption = self.editor.reference.getRefCaptionHTML(contextElement);
                return caption && caption.length !== 0
            },
            allowedContext: '.reference',
            action: function() {}
        },
        {
            rangeRequire: false,
            insertAction: true,
            className: 'inlineequation',
            diplayName: '&radic;',
            allowedContext: ['p', 'table', 'ol', 'ul', 'h1', 'h2', 'h3', 'h4', 'h5', 'caption', 'figcaption', 'citesrc'],
            notAllowedContext: ['nav', 'a', 'inlinecode', 'code'],
            arguments: [
                {name: 'latexequation', placeholder: 'LaTeX Equation', displayName: 'LaTeX Equation', tooltip: latexCheatsheet},
                {
                    displayName: 'Preview',
                    tooltip: 'It shows you how the LaTeX equation will be rendered',
                    render: function(element, formData) {
                        if(formData && formData.latexequation && formData.latexequation.trim() !== '') {
                            try {
                                katex.render(formData.latexequation, element, {
                                    throwOnError: true,
                                    displayMode: false
                                });
                            } catch (ex) {
                                element.innerHTML = '<span class="error">invalid LaTeX equation</span>';
                            }
                        } else {
                            element.innerHTML = 'Insert a LaTeX in the input field above to see the equation here.';
                        }
                    }
                }
            ],
            action: function(contextElement, argValue) {
                if(!argValue.latexequation) return;
                if(typeof argValue.latexequation !== 'string') return;
                if(argValue.latexequation.trim() === '') return;

                var eq = utils.stringToAttributeSaveString(argValue.latexequation)
                var node = document.createElement('inlineequation');

                node.setAttribute('data-latexequation', eq);
                node.setAttribute('contenteditable', false);

                self.caret.insertNode(node);
                self.caret.insertNode(document.createTextNode(' '));
            }
        },
        {
            className: 'edit-inlineequation',
            rangeRequire: false,
            diplayName: '<i class="fas fa-edit fa-xs"></i>',
            allowedContext: 'inlineequation',
            notAllowedContext: [],
            arguments: [{
                name: 'latexequation',
                placeholder: 'LaTeX Equation',
                tooltip: latexCheatsheet,
                displayName: 'LaTeX Equation',
                defaultValue: function(contextElement) {
                    if(!(contextElement && contextElement.dataset && contextElement.dataset.latexequation)) {
                        return '';
                    }

                    return utils.attributeSaveStringToString(contextElement.dataset.latexequation);
                },
            },
            {
                displayName: 'Preview:',
                tooltip: 'It shows you how the LaTeX equation will be rendered',
                render: function(element, formData) {
                    if(formData && formData.latexequation && formData.latexequation.trim() !== '') {
                        try {
                            katex.render(formData.latexequation, element, {
                                throwOnError: true,
                                displayMode: false
                            });
                        } catch (ex) {
                            element.innerHTML = '<span class="error">invalid LaTeX equation</span>';
                        }
                    }
                }
            }],
            action: function(contextElement, argValue) {
                if(!argValue.latexequation) return;
                if(typeof argValue.latexequation !== 'string') return;
                if(argValue.latexequation.trim() === '') return;

                var section = self.editor.focusedSection();
                contextElement.setAttribute('data-latexequation', utils.stringToAttributeSaveString(argValue.latexequation));
                self.editor.replaceSectionWithHTML(section, section.outerHTML);
            }
        },
        {
            className: 'inlineequation-content',
            rangeRequire: false,
            diplayName: function(contextElement) {
                return utils.attributeSaveStringToHTMLEncoded(contextElement.dataset.latexequation);
            },
            allowedContext: 'inlineequation',
            action: function() {}
        },
        {
            rangeRequire: true,
            insertAction: false,
            className: 'enrichment-info',
            allowedContext: '',
            diplayName: function(contextElement) {
                var text = window.getSelection().toString();
                var wordCount = text.split(/[\s\.:\?\!']/)
                    .filter(w => w.trim().length > 0)
                    .length;
                var charCount = text.length;

                return `${wordCount} / ${charCount}`;
            },
            action: function() {}
        },
    ];

    this.caret.subscribeSelectionChange(function(selection) {
        var enrichments = self.getMeaningfulEnrichments();

        enrichments.length !== 0 ?
            self.show(false, enrichments) :
            self.hide();
    })
}

TextEnrichmentControl.prototype = {

    isVisible: function() {
        return this.visible;
    },

    addEnrichments: function(enrichments) {
        Array.prototype.push.apply(this.enrichments, enrichments);
    },

    hide: function(force) {
        if(force || !this.preventEnrichmentControllToBeHidden) {
            this.domElement.style.display = 'none';
            this.domElement.innerHTML = '';
            this.visible = false;
        }
    },

    show: function(isInsertBtnPressed, enrichments) {
        var self = this,
            el = this.domElement,
            tmpBtn, section;

        enrichments = enrichments || this.getMeaningfulEnrichments(isInsertBtnPressed);

        if(enrichments.length === 0 && !isInsertBtnPressed) return;

        if(enrichments.length === 0) {
            enrichments.push({
                diplayName: 'Nothing to do here!',
                className: 'enrichment-info',
                allowedContext: '',
                action: function() {}
            },
            {
                diplayName: '<i class="fas fa-info fa-xs"></i>',
                className: 'enrichment-more-info-btn',
                allowedContext: 'body',
                arguments: [{
                    message: 'Some parts of the document (like headings) don\'t allow to insert footnotes or references as they might not make much sence there.<br/><br/>Please give us some <a href="mailto:info@monsterwriter.app?subject=Feedback">feedback</a> if you have an use case which requires this to be changed. <br/><br/>BTW. we would &#x1F496;to hear how you like MonsterWriter in general!'
                }],
                action: function() {}
            });
        }

        el.innerHTML = '<span class="textEnrichmentControlArrow"></span>';
        enrichments.forEach(function(enrichment) {

            tmpBtn = document.createElement('span');
            tmpBtn.className = enrichment.className;

            tmpBtn.innerHTML =  (typeof enrichment.diplayName === 'function') ?
                                    enrichment.diplayName(enrichment.contextElement) :
                                    enrichment.diplayName;

            tmpBtn.onmousedown = function (e) {

                if(!enrichment.arguments && enrichment.command) {
                    document.execCommand(enrichment.command);
                } else if(!enrichment.arguments && enrichment.action) {
                    enrichment.action(self.caret.getContextElement(enrichment.allowedContext), undefined, self);
                    section = self.editor.focusedSection();
                    self.editor.replaceSectionWithHTML(section, section.outerHTML);
                } else if(enrichment.arguments.length === 1 && enrichment.arguments[0].type === 'text') {
                    self.displaySingleArgumentTextInput(enrichment);
                } else {
                    self.displayArgumentInput(enrichment);
                }

                return false;
            }

            tmpBtn.onclick = tmpBtn.onmouseup = function () { return false }

            el.appendChild(tmpBtn);
        });

        this.visible = true;
        this.updatePosition();
        el.style.display = 'block';
    },

    updatePosition: function() {
        var caretPos = this.caret.getPosition(),
            el = this.domElement,
            xOffset = (caretPos.width > 11 ? 0 : -11),
            originalDisplay = el.style.display;

        el.style.display = 'none';
        el.style.left = (caretPos.x + xOffset) + 'px';
        el.style.top = (caretPos.y - 32) + 'px';
        el.style.display = originalDisplay;
    },

    updatePositionIfVisible: function() {
        if(this.visible) {
            this.updatePosition();
        }
    },

    displayArgumentInput: function(enrichment) {
        var self = this, section;

        var args = enrichment.arguments.map(function(arg) {
            if(typeof arg.defaultValue !== 'function') {
                return arg;
            }

            var newArg = {};
            Object.assign(newArg, arg);
            newArg.defaultValue = arg.defaultValue(enrichment.contextElement);
            return newArg;
        });

        self.editor.displayModal(args, function(formData) {
            self.editor.unfreezeSelection();
            self.hide();

            enrichment.action(self.caret.getContextElement(enrichment.allowedContext), formData, self);
            section = self.editor.focusedSection();
            self.editor.replaceSectionWithHTML(section, section.outerHTML);
        }, enrichment.notFocusFirstInput);
    },

    displaySingleArgumentTextInput: function(enrichment) {
        var self = this,
            argument = enrichment.arguments[0],
            el = this.domElement,
            attrInput = document.createElement('input'),
            okBtn = document.createElement('span'),
            cachedContextElement = enrichment.contextElement,
            section;

        attrInput.placeholder = argument.placeholder;
        okBtn.innerHTML = 'OK';
        okBtn.className = 'confirmLink';

        if(typeof argument.value === 'function') {
            attrInput.value = argument.value(cachedContextElement);
        } else {
            attrInput.value = argument.value || '';
        }

        attrInput.onmousedown = function() {
            //simulate the text focus, because it should still be visible what
            //text is slected even when the foucs changes to the input field
            self.editor.freezeSelection({
                'unfreezeOnClicksOutsiteOf': el,
                'unfreezeCallback': function() {
                    self.preventEnrichmentControllToBeHidden = false;
                    self.hide()
                },
            });
            self.preventEnrichmentControllToBeHidden = true;

            attrInput.focus();
        }

        okBtn.onmousedown = function() {
            self.editor.unfreezeSelection();
            if(enrichment.command) {
                if(!document.execCommand(enrichment.command, false, attrInput.value)) {
                    window.getSelection().getRangeAt(0).collapse();
                }
            } else if(enrichment.action) {
                var attrValue = {};
                attrValue[argument.name] = attrInput.value;
                enrichment.action(self.caret.getContextElement(enrichment.allowedContext), attrValue, self);
                section = self.editor.focusedSection();
                self.editor.replaceSectionWithHTML(section, section.outerHTML);
            }

            self.hide();
            return false;
        }

        attrInput.onkeydown = function(e) {
            if(e.keyCode === 13) { // Enter
                okBtn.onmousedown();
                e.preventDefault();
                e.stopPropagation();
                return false;
            }
        }

        el.innerHTML = '<span class="textEnrichmentControlArrow"></span>';
        el.appendChild(attrInput);
        el.appendChild(okBtn);

        attrInput.onmousedown();
    },

    getMeaningfulEnrichments: function(isInsertBtnPressed, selection) {
        var self = this,
            tangentNodes = self.caret.getTangetNodes();

        selection = selection || window.getSelection();

        var collapsedMatch = function(e) {
            if(typeof e.rangeRequire === 'undefined') {
                e.rangeRequire = true;
            }

            return !e.rangeRequire || !selection.isCollapsed === e.rangeRequire;
        }

        var contextMatch = function(e) {
            if(!e.allowedContext) return true;

            if(e.notAllowedContext) {
                if(self.caret.getContextElement(e.notAllowedContext, selection, tangentNodes)) {
                    return false;
                }
            }

            e.contextElement = self.caret.getContextElement(e.allowedContext, selection, tangentNodes);
            return !!e.contextElement;
        }

        var insertActionMatch = function(e) {
            if(isInsertBtnPressed) {
                return selection.isCollapsed && e.insertAction === true;
            } else {
                return e.insertAction !== true;
            }
        }

        var enrichmentMatch = function(e) {
            if(!e.shouldBeDisplayed) { return true }

            return e.shouldBeDisplayed(self.caret.getContextElement(e.allowedContext, selection, tangentNodes));
        }

        return this.enrichments.filter(function(e) {
            return collapsedMatch(e) &&
                   contextMatch(e) &&
                   insertActionMatch(e) &&
                   enrichmentMatch(e);
        });
    }
}

module.exports = TextEnrichmentControl;


/***/ }),

/***/ "./node_modules/changesets/lib/Builder.js":
/*!************************************************!*\
  !*** ./node_modules/changesets/lib/Builder.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Changeset = __webpack_require__(/*! ./Changeset */ "./node_modules/changesets/lib/Changeset.js")
  , Retain = __webpack_require__(/*! ./operations/Retain */ "./node_modules/changesets/lib/operations/Retain.js")
  , Skip = __webpack_require__(/*! ./operations/Skip */ "./node_modules/changesets/lib/operations/Skip.js")
  , Insert = __webpack_require__(/*! ./operations/Insert */ "./node_modules/changesets/lib/operations/Insert.js")

function Builder() {
  this.ops = []
  this.addendum = ''
  this.removendum = ''
}

module.exports = Builder

Builder.prototype.keep =
Builder.prototype.retain = function(len) {
  this.ops.push(new Retain(len))
  return this
}

Builder.prototype.delete =
Builder.prototype.skip = function(str) {
  this.removendum += str
  this.ops.push(new Skip(str.length))
  return this
}

Builder.prototype.add =
Builder.prototype.insert = function(str) {
  this.addendum += str
  this.ops.push(new Insert(str.length))
  return this
}

Builder.prototype.end = function() {
  var cs = new Changeset(this.ops)
  cs.addendum = this.addendum
  cs.removendum = this.removendum
  return cs
}


/***/ }),

/***/ "./node_modules/changesets/lib/Changeset.js":
/*!**************************************************!*\
  !*** ./node_modules/changesets/lib/Changeset.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * changesets
 * A Changeset library incorporating operational transformation (OT)
 * Copyright 2012 by Marcel Klehr <mklehr@gmx.net>
 *
 * (MIT LICENSE)
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * A sequence of consecutive operations
 *
 * @param ops.. <Operation> all passed operations will be added to the changeset
 */
function Changeset(ops/*or ops..*/) {
  this.addendum = ""
  this.removendum = ""
  this.inputLength = 0
  this.outputLength = 0

  if(!Array.isArray(ops)) ops = arguments
  for(var i=0; i<ops.length; i++) {
    this.push(ops[i])
    this.inputLength += ops[i].input
    this.outputLength += ops[i].output
  }
}

// True inheritance
Changeset.prototype = Object.create(Array.prototype, {
  constructor: {
    value: Changeset,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
module.exports = Changeset

var TextTransform = __webpack_require__(/*! ./TextTransform */ "./node_modules/changesets/lib/TextTransform.js")
  , ChangesetTransform = __webpack_require__(/*! ./ChangesetTransform */ "./node_modules/changesets/lib/ChangesetTransform.js")

var Retain = __webpack_require__(/*! ./operations/Retain */ "./node_modules/changesets/lib/operations/Retain.js")
  , Skip = __webpack_require__(/*! ./operations/Skip */ "./node_modules/changesets/lib/operations/Skip.js")
  , Insert = __webpack_require__(/*! ./operations/Insert */ "./node_modules/changesets/lib/operations/Insert.js")

var Builder = __webpack_require__(/*! ./Builder */ "./node_modules/changesets/lib/Builder.js")

/**
 * Returns an array containing the ops that are within the passed range
 * (only op.input is counted; thus not counting inserts to the range length, yet they are part of the range)
 */
Changeset.prototype.subrange = function(start, len) {
  var range = []
    , op, oplen
    , l=0
  for(var i=0, pos=0; i<this.length && l < len; i++) {
    op = this[i]
    if(op.input+pos >= start) {
      if(op.input) {
        if(op.length != Infinity) oplen = op.length -Math.max(0, start-pos) -Math.max(0, (op.length+pos)-(start+len))
        else oplen = len
        if (oplen !== 0) range.push( op.derive(oplen) ) // (Don't copy over more than len param allows)
      }
      else {
        range.push( op.derive(op.length) )
        oplen = 0
      }
      l += oplen
    }
    pos += op.input
  }
  return range
}

/**
 * Merge two changesets (that are based on the same state!) so that the resulting changseset
 * has the same effect as both orignal ones applied one after the other
 *
 * @param otherCs <Changeset>
 * @param left <boolean> Which op to choose if there's an insert tie (If you use this function in a distributed, synchronous environment, be sure to invert this param on the other site, otherwise it can be omitted safely))
 * @returns <Changeset>
 */
Changeset.prototype.merge = function(otherCs, left) {
  if(!(otherCs instanceof Changeset)) {
    throw new Error('Argument must be a #<Changeset>, but received '+otherCs.__proto__.constructor.name)
  }

  if(otherCs.inputLength !== this.outputLength) {
    throw new Error("Changeset lengths for merging don't match! Input length of younger cs: "+otherCs.inputLength+', output length of older cs:'+this.outputLength)
  }

  var newops = []
    , addPtr1 = 0
    , remPtr1 = 0
    , addPtr2 = 0
    , remPtr2 = 0
    , newaddendum = ''
    , newremovendum = ''

  zip(this, otherCs, function(op1, op2) {
    // console.log(newops)
    // console.log(op1, op2)

    // I'm deleting something -- the other cs can't know that, so just overtake my op
    if(op1 && !op1.output) {
      newops.push(op1.merge().clone())
      newremovendum += this.removendum.substr(remPtr1, op1.length) // overtake added chars
      remPtr1 += op1.length
      op1.length = 0 // don't gimme that one again.
      return
    }

    // op2 is an insert
    if(op2 && !op2.input) {
      newops.push(op2.merge().clone())
      newaddendum += otherCs.addendum.substr(addPtr2, op2.length) // overtake added chars
      addPtr2 += op2.length
      op2.length = 0 // don't gimme that one again.
      return
    }

    // op2 is either a retain or a skip
    if(op2 && op2.input && op1) {
      // op2 retains whatever we do here (retain or insert), so just clone my op
      if(op2.output) {
        newops.push(op1.merge(op2).clone())
        if(!op1.input) { // overtake addendum
          newaddendum += this.addendum.substr(addPtr1, op1.length)
          addPtr1 += op1.length
        }
        op1.length = 0 // don't gimme these again
        op2.length = 0
      }else

      // op2 deletes my retain here, so just clone the delete
      // (op1 can only be a retain and no skip here, cause we've handled skips above already)
      if(!op2.output && op1.input) {
        newops.push(op2.merge(op1).clone())
        newremovendum += otherCs.removendum.substr(remPtr2, op2.length) // overtake added chars
        remPtr2 += op2.length
        op1.length = 0 // don't gimme these again
        op2.length = 0
      }else

      //otherCs deletes something I added (-1) +1 = 0
      {
        addPtr1 += op1.length
        op1.length = 0 // don't gimme these again
        op2.length = 0
      }
      return
    }

    console.log('oops', arguments)
    throw new Error('oops. This case hasn\'t been considered by the developer (error code: PBCAC)')
  }.bind(this))

  var newCs = new Changeset(newops)
  newCs.addendum = newaddendum
  newCs.removendum = newremovendum

  return newCs
}

/**
 * A private and quite handy function that slices ops into equally long pieces and applies them on a mapping function
 * that can determine the iteration steps by setting op.length to 0 on an op (equals using .next() in a usual iterator)
 */
function zip(cs1, cs2, func) {
  var opstack1 = cs1.map(function(op) {return op.clone()}) // copy ops
    , opstack2 = cs2.map(function(op) {return op.clone()})

  var op2, op1
  while(opstack1.length || opstack2.length) {// iterate through all outstanding ops of this cs
    op1 = opstack1[0]? opstack1[0].clone() : null
    op2 = opstack2[0]? opstack2[0].clone() : null

    if(op1) {
      if(op2) op1 = op1.derive(Math.min(op1.length, op2.length)) // slice 'em into equally long pieces
      if(opstack1[0].length > op1.length) opstack1[0] = opstack1[0].derive(opstack1[0].length-op1.length)
      else opstack1.shift()
    }

    if(op2) {
      if(op1) op2 = op2.derive(Math.min(op1.length, op2.length)) // slice 'em into equally long pieces
      if(opstack2[0].length > op2.length) opstack2[0] = opstack2[0].derive(opstack2[0].length-op2.length)
      else opstack2.shift()
    }

    func(op1, op2)

    if(op1 && op1.length) opstack1.unshift(op1)
    if(op2 && op2.length) opstack2.unshift(op2)
  }
}

/**
 * Inclusion Transformation (IT) or Forward Transformation
 *
 * transforms the operations of the current changeset against the
 * all operations in another changeset in such a way that the
 * effects of the latter are effectively included.
 * This is basically like a applying the other cs on this one.
 *
 * @param otherCs <Changeset>
 * @param left <boolean> Which op to choose if there's an insert tie (If you use this function in a distributed, synchronous environment, be sure to invert this param on the other site, otherwise it can be omitted safely)
 *
 * @returns <Changeset>
 */
Changeset.prototype.transformAgainst = function(otherCs, left) {
  if(!(otherCs instanceof Changeset)) {
    throw new Error('Argument to Changeset#transformAgainst must be a #<Changeset>, but received '+otherCs.__proto__.constructor.name)
  }

  if(this.inputLength != otherCs.inputLength) {
    throw new Error('Can\'t transform changesets with differing inputLength: '+this.inputLength+' and '+otherCs.inputLength)
  }

  var transformation = new ChangesetTransform(this, [new Retain(Infinity)])
  otherCs.forEach(function(op) {
    var nextOp = this.subrange(transformation.pos, Infinity)[0] // next op of this cs
    if(nextOp && !nextOp.input && !op.input) { // two inserts tied; left breaks it
      if (left) transformation.writeOutput(transformation.readInput(nextOp.length))
    }
    op.apply(transformation)
  }.bind(this))

  return transformation.result()
}

/**
 * Exclusion Transformation (ET) or Backwards Transformation
 *
 * transforms all operations in the current changeset against the operations
 * in another changeset in such a way that the impact of the latter are effectively excluded
 *
 * @param changeset <Changeset> the changeset to substract from this one
 * @param left <boolean> Which op to choose if there's an insert tie (If you use this function in a distributed, synchronous environment, be sure to invert this param on the other site, otherwise it can be omitted safely)
 * @returns <Changeset>
 */
Changeset.prototype.substract = function(changeset, left) {
  // The current operations assume that the changes in
  // `changeset` happened before, so for each of those ops
  // we create an operation that undoes its effect and
  // transform all our operations on top of the inverse changes
  return this.transformAgainst(changeset.invert(), left)
}

/**
 * Returns the inverse Changeset of the current one
 *
 * Changeset.invert().apply(Changeset.apply(document)) == document
 */
Changeset.prototype.invert = function() {
  // invert all ops
  var newCs = new Changeset(this.map(function(op) {
    return op.invert()
  }))

  // removendum becomes addendum and vice versa
  newCs.addendum = this.removendum
  newCs.removendum = this.addendum

  return newCs
}

/**
 * Applies this changeset on a text
 */
Changeset.prototype.apply = function(input) {
  // pre-requisites
  if(input.length != this.inputLength) throw new Error('Input length doesn\'t match expected length. expected: '+this.inputLength+'; actual: '+input.length)

  var operation = new TextTransform(input, this.addendum, this.removendum)

  this.forEach(function(op) {
    // each Operation has access to all pointers as well as the input, addendum and removendum (the latter are immutable)
    op.apply(operation)
  }.bind(this))

  return operation.result()
}

/**
 * Returns an array of strings describing this changeset's operations
 */
Changeset.prototype.inspect = function() {
  var j = 0
  return this.map(function(op) {
    var string = ''

    if(!op.input) { // if Insert
      string = this.addendum.substr(j,op.length)
      j += op.length
      return string
    }

    for(var i=0; i<op.length; i++) string += op.symbol
    return string
  }.bind(this)).join('')
}

/**
 * Serializes the given changeset in order to return a (hopefully) more compact representation
 * than json that can be sent through a network or stored in a database
 *
 * Numbers are converted to the base 36, unsafe chars in the text are urlencoded
 *
 * @param cs <Changeset> The changeset to be serialized
 * @returns <String> The serialized changeset
 */
Changeset.prototype.pack = function() {
  var packed = this.map(function(op) {
    return op.pack()
  }).join('')

  var addendum = this.addendum.replace(/%/g, '%25').replace(/\|/g, '%7C')
    , removendum = this.removendum.replace(/%/g, '%25').replace(/\|/g, '%7C')
  return packed+'|'+addendum+'|'+removendum
}
Changeset.prototype.toString = function() {
  return this.pack()
}

/**
 * Unserializes the output of cs.text.Changeset#toString()
 *
 * @param packed <String> The serialized changeset
 * @param <cs.Changeset>
 */
Changeset.unpack = function(packed) {
  if(packed == '') throw new Error('Cannot unpack from empty string')
  var components = packed.split('|')
    , opstring = components[0]
    , addendum = components[1].replace(/%7c/gi, '|').replace(/%25/g, '%')
    , removendum = components[2].replace(/%7c/gi, '|').replace(/%25/g, '%')

  var matches = opstring.match(/[=+-]([^=+-])+/g)
  if(!matches) throw new Error('Cannot unpack invalidly serialized op string')

  var ops = []
  matches.forEach(function(s) {
    var symbol = s.substr(0,1)
      , data = s.substr(1)
    if(Skip.prototype.symbol == symbol) return ops.push(Skip.unpack(data))
    if(Insert.prototype.symbol == symbol) return ops.push(Insert.unpack(data))
    if(Retain.prototype.symbol == symbol) return ops.push(Retain.unpack(data))
    throw new Error('Invalid changeset representation passed to Changeset.unpack')
  })

  var cs = new Changeset(ops)
  cs.addendum = addendum
  cs.removendum = removendum

  return cs
}

Changeset.create = function() {
  return new Builder
}

/**
 * Returns a Changeset containing the operations needed to transform text1 into text2
 *
 * @param text1 <String>
 * @param text2 <String>
 */
Changeset.fromDiff = function(diff) {
  /**
   * The data structure representing a diff is an array of tuples:
   * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
   * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
   */
  var DIFF_DELETE = -1;
  var DIFF_INSERT = 1;
  var DIFF_EQUAL = 0;

  var ops = []
    , removendum = ''
    , addendum = ''

  diff.forEach(function(d) {
    if (DIFF_DELETE == d[0]) {
      ops.push(new Skip(d[1].length))
      removendum += d[1]
    }

    if (DIFF_INSERT == d[0]) {
      ops.push(new Insert(d[1].length))
      addendum += d[1]
    }

    if(DIFF_EQUAL == d[0]) {
      ops.push(new Retain(d[1].length))
    }
  })

  var cs = new Changeset(ops)
  cs.addendum = addendum
  cs.removendum = removendum
  return cs
}


/***/ }),

/***/ "./node_modules/changesets/lib/ChangesetTransform.js":
/*!***********************************************************!*\
  !*** ./node_modules/changesets/lib/ChangesetTransform.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * changesets
 * A Changeset library incorporating operational ChangesetTransform (OT)
 * Copyright 2012 by Marcel Klehr <mklehr@gmx.net>
 *
 * (MIT LICENSE)
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var Retain = __webpack_require__(/*! ./operations/Retain */ "./node_modules/changesets/lib/operations/Retain.js")
  , Skip = __webpack_require__(/*! ./operations/Skip */ "./node_modules/changesets/lib/operations/Skip.js")
  , Insert = __webpack_require__(/*! ./operations/Insert */ "./node_modules/changesets/lib/operations/Insert.js")
  , Changeset = __webpack_require__(/*! ./Changeset */ "./node_modules/changesets/lib/Changeset.js")


function ChangesetTransform(inputCs, addendum) {
  this.output = []
  this.addendum = addendum
  this.newRemovendum = ''
  this.newAddendum = ''

  this.cs = inputCs
  this.pos = 0
  this.addendumPointer = 0
  this.removendumPointer = 0
}
module.exports = ChangesetTransform

ChangesetTransform.prototype.readInput = function (len) {
  var ret = this.cs.subrange(this.pos, len)
  this.pos += len
  return ret
}

ChangesetTransform.prototype.readAddendum = function (len) {
  //return [new Retain(len)]
  var ret = this.subrange(this.addendum, this.addendumPointer, len)
  this.addendumPointer += len
  return ret
}

ChangesetTransform.prototype.writeRemovendum = function (range) {
  range
    .filter(function(op) {return !op.output})
    .forEach(function(op) {
      this.removendumPointer += op.length
    }.bind(this))
}

ChangesetTransform.prototype.writeOutput = function (range) {
  this.output = this.output.concat(range)
  range
    .filter(function(op) {return !op.output})
    .forEach(function(op) {
      this.newRemovendum += this.cs.removendum.substr(this.removendumPointer, op.length)
      this.removendumPointer += op.length
    }.bind(this))
}

ChangesetTransform.prototype.subrange = function (range, start, len) {
  if(len) return this.cs.subrange.call(range, start, len)
  else return range.filter(function(op){ return !op.input})
}

ChangesetTransform.prototype.result = function() {
  this.writeOutput(this.readInput(Infinity))
  var newCs = new Changeset(this.output)
  newCs.addendum = this.cs.addendum
  newCs.removendum = this.newRemovendum
  return newCs
}


/***/ }),

/***/ "./node_modules/changesets/lib/Operator.js":
/*!*************************************************!*\
  !*** ./node_modules/changesets/lib/Operator.js ***!
  \*************************************************/
/***/ ((module) => {

function Operator() {
}

module.exports = Operator

Operator.prototype.clone = function() {
  return this.derive(this.length)
}

Operator.prototype.derive = function(len) {
  return new (this.constructor)(len)
}

Operator.prototype.pack = function() {
  return this.symbol + (this.length).toString(36)
}


/***/ }),

/***/ "./node_modules/changesets/lib/TextTransform.js":
/*!******************************************************!*\
  !*** ./node_modules/changesets/lib/TextTransform.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * changesets
 * A Changeset library incorporating operational Apply (OT)
 * Copyright 2012 by Marcel Klehr <mklehr@gmx.net>
 *
 * (MIT LICENSE)
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var Retain = __webpack_require__(/*! ./operations/Retain */ "./node_modules/changesets/lib/operations/Retain.js")
  , Skip = __webpack_require__(/*! ./operations/Skip */ "./node_modules/changesets/lib/operations/Skip.js")
  , Insert = __webpack_require__(/*! ./operations/Insert */ "./node_modules/changesets/lib/operations/Insert.js")
  , Insert = __webpack_require__(/*! ./Changeset */ "./node_modules/changesets/lib/Changeset.js")


function TextTransform(input, addendum, removendum) {
  this.output = ''

  this.input = input
  this.addendum = addendum
  this.removendum = removendum
  this.pos = 0
  this.addPos = 0
  this.remPos = 0
}
module.exports = TextTransform

TextTransform.prototype.readInput = function (len) {
  var ret = this.input.substr(this.pos, len)
  this.pos += len
  return ret
}

TextTransform.prototype.readAddendum = function (len) {
  var ret = this.addendum.substr(this.addPos, len)
  this.addPos += len
  return ret
}

TextTransform.prototype.writeRemovendum = function (range) {
  //var expected = this.removendum.substr(this.remPos, range.length)
  //if(range != expected) throw new Error('Removed chars don\'t match removendum. expected: '+expected+'; actual: '+range)
  this.remPos += range.length
}

TextTransform.prototype.writeOutput = function (range) {
  this.output += range
}

TextTransform.prototype.subrange = function (range, start, len) {
  return range.substr(start, len)
}

TextTransform.prototype.result = function() {
  this.writeOutput(this.readInput(Infinity))
  return this.output
}


/***/ }),

/***/ "./node_modules/changesets/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/changesets/lib/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*!
 * changesets
 * A Changeset library incorporating operational transformation (OT)
 * Copyright 2012 by Marcel Klehr <mklehr@gmx.net>
 *
 * (MIT LICENSE)
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var Changeset = __webpack_require__(/*! ./Changeset */ "./node_modules/changesets/lib/Changeset.js")
  , Retain = __webpack_require__(/*! ./operations/Retain */ "./node_modules/changesets/lib/operations/Retain.js")
  , Skip = __webpack_require__(/*! ./operations/Skip */ "./node_modules/changesets/lib/operations/Skip.js")
  , Insert = __webpack_require__(/*! ./operations/Insert */ "./node_modules/changesets/lib/operations/Insert.js")

exports.Operator = __webpack_require__(/*! ./Operator */ "./node_modules/changesets/lib/Operator.js")
exports.Changeset = Changeset
exports.Insert = Insert
exports.Retain = Retain
exports.Skip = Skip

if('undefined' != typeof window) window.changesets = exports

/**
 * Serializes the given changeset in order to return a (hopefully) more compact representation
 * that can be sent through a network or stored in a database
 * @alias cs.text.Changeset#pack
 */
exports.pack = function(cs) {
  return cs.pack()
}

/**
 * Unserializes the output of cs.text.pack
 * @alias cs.text.Changeset.unpack
 */
exports.unpack = function(packed) {
  return Changeset.unpack(packed)
}




/**
 * shareJS ot type API sepc support
 */

exports.name = 'changesets'
exports.url = 'https://github.com/marcelklehr/changesets'

/**
 * create([initialText])
 *
 * creates a snapshot (optionally with supplied intial text)
 */
exports.create = function(initText) {
  return initText || ''
}

/**
 * Apply a changeset on a snapshot creating a new one
 *
 * The old snapshot object mustn't be used after calling apply on it
 * returns the resulting
 */
exports.apply = function(snapshot, op) {
  op = exports.unpack(op)
  return op.apply(snapshot)
}

/**
 * Transform changeset1 against changeset2
 */
exports.transform = function (op1, op2, side) {
  op1 = exports.unpack(op1)
  op2 = exports.unpack(op2)
  return exports.pack(op1.transformAgainst(op2, ('left'==side)))
}

/**
 * Merge two changesets into one
 */
exports.compose = function (op1, op2) {
  op1 = exports.unpack(op1)
  op2 = exports.unpack(op2)
  return exports.pack(op1.merge(op2))
}

/**
 * Invert a changeset
 */
exports.invert = function(op) {
  return exports.pack(exports.unpack(op).invert())
}


/***/ }),

/***/ "./node_modules/changesets/lib/operations/Insert.js":
/*!**********************************************************!*\
  !*** ./node_modules/changesets/lib/operations/Insert.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * changesets
 * A Changeset library incorporating operational transformation (OT)
 * Copyright 2012 by Marcel Klehr <mklehr@gmx.net>
 *
 * (MIT LICENSE)
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var Operator = __webpack_require__(/*! ../Operator */ "./node_modules/changesets/lib/Operator.js")

/**
 * Insert Operator
 * Defined by:
 * - length
 * - input=0
 * - output=length
 *
 * @param length <Number> How many chars to be inserted
 */
function Insert(length) {
  this.length = length
  this.input = 0
  this.output = length
}

// True inheritance
Insert.prototype = Object.create(Operator.prototype, {
  constructor: {
    value: Insert,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
module.exports = Insert
Insert.prototype.symbol = '+'

var Skip = __webpack_require__(/*! ./Skip */ "./node_modules/changesets/lib/operations/Skip.js")
  , Retain = __webpack_require__(/*! ./Retain */ "./node_modules/changesets/lib/operations/Retain.js")

Insert.prototype.apply = function(t) {
  t.writeOutput(t.readAddendum(this.output))
}

Insert.prototype.merge = function() {
  return this
}

Insert.prototype.invert = function() {
  return new Skip(this.length)
}

Insert.unpack = function(data) {
  return new Insert(parseInt(data, 36))
}


/***/ }),

/***/ "./node_modules/changesets/lib/operations/Retain.js":
/*!**********************************************************!*\
  !*** ./node_modules/changesets/lib/operations/Retain.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * changesets
 * A Changeset library incorporating operational transformation (OT)
 * Copyright 2012 by Marcel Klehr <mklehr@gmx.net>
 *
 * (MIT LICENSE)
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var Operator = __webpack_require__(/*! ../Operator */ "./node_modules/changesets/lib/Operator.js")

/**
 * Retain Operator
 * Defined by:
 * - length
 * - input=output=length
 *
 * @param length <Number> How many chars to retain
 */
function Retain(length) {
  this.length = length
  this.input = length
  this.output = length
}

// True inheritance
Retain.prototype = Object.create(Operator.prototype, {
  constructor: {
    value: Retain,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
module.exports = Retain
Retain.prototype.symbol = '='

Retain.prototype.apply = function(t) {
  t.writeOutput(t.readInput(this.input))
}

Retain.prototype.invert = function() {
  return this
}

Retain.prototype.merge = function(op2) {
  return this
}

Retain.unpack = function(data) {
  return new Retain(parseInt(data, 36))
}


/***/ }),

/***/ "./node_modules/changesets/lib/operations/Skip.js":
/*!********************************************************!*\
  !*** ./node_modules/changesets/lib/operations/Skip.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * changesets
 * A Changeset library incorporating operational transformation (OT)
 * Copyright 2012 by Marcel Klehr <mklehr@gmx.net>
 *
 * (MIT LICENSE)
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var Operator = __webpack_require__(/*! ../Operator */ "./node_modules/changesets/lib/Operator.js")

/**
 * Skip Operator
 * Defined by:
 * - length
 * - input=length
 * - output=0
 *
 * @param length <Number> How many chars to be Skip
 */
function Skip(length) {
  this.length = length
  this.input = length
  this.output = 0
}

// True inheritance
Skip.prototype = Object.create(Operator.prototype, {
  constructor: {
    value: Skip,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
module.exports = Skip
Skip.prototype.symbol = '-'

var Insert = __webpack_require__(/*! ./Insert */ "./node_modules/changesets/lib/operations/Insert.js")
  , Retain = __webpack_require__(/*! ./Retain */ "./node_modules/changesets/lib/operations/Retain.js")
  , Changeset = __webpack_require__(/*! ../Changeset */ "./node_modules/changesets/lib/Changeset.js")

Skip.prototype.apply = function(t) {
  var input = t.readInput(this.input)
  t.writeRemovendum(input)
  t.writeOutput(t.subrange(input, 0, this.output)) // retain Inserts in my range
}

Skip.prototype.merge = function(op2) {
  return this
}

Skip.prototype.invert = function() {
  return new Insert(this.length)
}

Skip.unpack = function(data) {
  return new Skip(parseInt(data, 36))
}


/***/ }),

/***/ "./node_modules/diff_match_patch/lib/diff_match_patch.js":
/*!***************************************************************!*\
  !*** ./node_modules/diff_match_patch/lib/diff_match_patch.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

/**
 * Diff Match and Patch
 *
 * Copyright 2006 Google Inc.
 * http://code.google.com/p/google-diff-match-patch/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview Computes the difference between two texts to create a patch.
 * Applies the patch onto another text, allowing for errors.
 * @author fraser@google.com (Neil Fraser)
 */

/**
 * Class containing the diff, match and patch methods.
 * @constructor
 */
function diff_match_patch() {

  // Defaults.
  // Redefine these in your program to override the defaults.

  // Number of seconds to map a diff before giving up (0 for infinity).
  this.Diff_Timeout = 1.0;
  // Cost of an empty edit operation in terms of edit characters.
  this.Diff_EditCost = 4;
  // The size beyond which the double-ended diff activates.
  // Double-ending is twice as fast, but less accurate.
  this.Diff_DualThreshold = 32;
  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).
  this.Match_Threshold = 0.5;
  // How far to search for a match (0 = exact location, 1000+ = broad match).
  // A match this many characters away from the expected location will add
  // 1.0 to the score (0.0 is a perfect match).
  this.Match_Distance = 1000;
  // When deleting a large block of text (over ~64 characters), how close does
  // the contents have to match the expected contents. (0.0 = perfection,
  // 1.0 = very loose).  Note that Match_Threshold controls how closely the
  // end points of a delete need to match.
  this.Patch_DeleteThreshold = 0.5;
  // Chunk size for context length.
  this.Patch_Margin = 4;

  /**
   * Compute the number of bits in an int.
   * The normal answer for JavaScript is 32.
   * @return {number} Max bits
   */
  function getMaxBits() {
    var maxbits = 0;
    var oldi = 1;
    var newi = 2;
    while (oldi != newi) {
      maxbits++;
      oldi = newi;
      newi = newi << 1;
    }
    return maxbits;
  }
  // How many bits in a number?
  this.Match_MaxBits = getMaxBits();
}


//  DIFF FUNCTIONS


/**
 * The data structure representing a diff is an array of tuples:
 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
 */
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;


/**
 * Find the differences between two texts.  Simplifies the problem by stripping
 * any common prefix or suffix off the texts before diffing.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {boolean} opt_checklines Optional speedup flag.  If present and false,
 *     then don't run a line-level diff first to identify the changed areas.
 *     Defaults to true, which does a faster, slightly less optimal diff
 * @return {Array.<Array.<number|string>>} Array of diff tuples.
 */
diff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines) {
  // Check for null inputs.
  if (text1 == null || text2 == null) {
    throw new Error('Null input. (diff_main)');
  }

  // Check for equality (speedup).
  if (text1 == text2) {
    return [[DIFF_EQUAL, text1]];
  }

  if (typeof opt_checklines == 'undefined') {
    opt_checklines = true;
  }
  var checklines = opt_checklines;

  // Trim off common prefix (speedup).
  var commonlength = this.diff_commonPrefix(text1, text2);
  var commonprefix = text1.substring(0, commonlength);
  text1 = text1.substring(commonlength);
  text2 = text2.substring(commonlength);

  // Trim off common suffix (speedup).
  commonlength = this.diff_commonSuffix(text1, text2);
  var commonsuffix = text1.substring(text1.length - commonlength);
  text1 = text1.substring(0, text1.length - commonlength);
  text2 = text2.substring(0, text2.length - commonlength);

  // Compute the diff on the middle block.
  var diffs = this.diff_compute(text1, text2, checklines);

  // Restore the prefix and suffix.
  if (commonprefix) {
    diffs.unshift([DIFF_EQUAL, commonprefix]);
  }
  if (commonsuffix) {
    diffs.push([DIFF_EQUAL, commonsuffix]);
  }
  this.diff_cleanupMerge(diffs);
  return diffs;
};


/**
 * Find the differences between two texts.  Assumes that the texts do not
 * have any common prefix or suffix.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {boolean} checklines Speedup flag.  If false, then don't run a
 *     line-level diff first to identify the changed areas.
 *     If true, then run a faster, slightly less optimal diff
 * @return {Array.<Array.<number|string>>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_compute = function(text1, text2, checklines) {
  var diffs;

  if (!text1) {
    // Just add some text (speedup).
    return [[DIFF_INSERT, text2]];
  }

  if (!text2) {
    // Just delete some text (speedup).
    return [[DIFF_DELETE, text1]];
  }

  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  var i = longtext.indexOf(shorttext);
  if (i != -1) {
    // Shorter text is inside the longer text (speedup).
    diffs = [[DIFF_INSERT, longtext.substring(0, i)],
             [DIFF_EQUAL, shorttext],
             [DIFF_INSERT, longtext.substring(i + shorttext.length)]];
    // Swap insertions for deletions if diff is reversed.
    if (text1.length > text2.length) {
      diffs[0][0] = diffs[2][0] = DIFF_DELETE;
    }
    return diffs;
  }
  longtext = shorttext = null;  // Garbage collect.

  // Check to see if the problem can be split in two.
  var hm = this.diff_halfMatch(text1, text2);
  if (hm) {
    // A half-match was found, sort out the return data.
    var text1_a = hm[0];
    var text1_b = hm[1];
    var text2_a = hm[2];
    var text2_b = hm[3];
    var mid_common = hm[4];
    // Send both pairs off for separate processing.
    var diffs_a = this.diff_main(text1_a, text2_a, checklines);
    var diffs_b = this.diff_main(text1_b, text2_b, checklines);
    // Merge the results.
    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
  }

  // Perform a real diff.
  if (checklines && (text1.length < 100 || text2.length < 100)) {
    // Too trivial for the overhead.
    checklines = false;
  }
  var linearray;
  if (checklines) {
    // Scan the text on a line-by-line basis first.
    var a = this.diff_linesToChars(text1, text2);
    text1 = a[0];
    text2 = a[1];
    linearray = a[2];
  }
  diffs = this.diff_map(text1, text2);
  if (!diffs) {
    // No acceptable result.
    diffs = [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
  }
  if (checklines) {
    // Convert the diff back to original text.
    this.diff_charsToLines(diffs, linearray);
    // Eliminate freak matches (e.g. blank lines)
    this.diff_cleanupSemantic(diffs);

    // Rediff any replacement blocks, this time character-by-character.
    // Add a dummy entry at the end.
    diffs.push([DIFF_EQUAL, '']);
    var pointer = 0;
    var count_delete = 0;
    var count_insert = 0;
    var text_delete = '';
    var text_insert = '';
    while (pointer < diffs.length) {
      switch (diffs[pointer][0]) {
        case DIFF_INSERT:
          count_insert++;
          text_insert += diffs[pointer][1];
          break;
        case DIFF_DELETE:
          count_delete++;
          text_delete += diffs[pointer][1];
          break;
        case DIFF_EQUAL:
          // Upon reaching an equality, check for prior redundancies.
          if (count_delete >= 1 && count_insert >= 1) {
            // Delete the offending records and add the merged ones.
            var a = this.diff_main(text_delete, text_insert, false);
            diffs.splice(pointer - count_delete - count_insert,
                         count_delete + count_insert);
            pointer = pointer - count_delete - count_insert;
            for (var j = a.length - 1; j >= 0; j--) {
              diffs.splice(pointer, 0, a[j]);
            }
            pointer = pointer + a.length;
          }
          count_insert = 0;
          count_delete = 0;
          text_delete = '';
          text_insert = '';
          break;
      }
     pointer++;
    }
    diffs.pop();  // Remove the dummy entry at the end.
  }
  return diffs;
};


/**
 * Split two texts into an array of strings.  Reduce the texts to a string of
 * hashes where each Unicode character represents one line.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {Array.<string|Array.<string>>} Three element Array, containing the
 *     encoded text1, the encoded text2 and the array of unique strings.  The
 *     zeroth element of the array of unique strings is intentionally blank.
 * @private
 */
diff_match_patch.prototype.diff_linesToChars = function(text1, text2) {
  var lineArray = [];  // e.g. lineArray[4] == 'Hello\n'
  var lineHash = {};   // e.g. lineHash['Hello\n'] == 4

  // '\x00' is a valid character, but various debuggers don't like it.
  // So we'll insert a junk entry to avoid generating a null character.
  lineArray[0] = '';

  /**
   * Split a text into an array of strings.  Reduce the texts to a string of
   * hashes where each Unicode character represents one line.
   * Modifies linearray and linehash through being a closure.
   * @param {string} text String to encode.
   * @return {string} Encoded string.
   * @private
   */
  function diff_linesToCharsMunge(text) {
    var chars = '';
    // Walk the text, pulling out a substring for each line.
    // text.split('\n') would would temporarily double our memory footprint.
    // Modifying text would create many large strings to garbage collect.
    var lineStart = 0;
    var lineEnd = -1;
    // Keeping our own length variable is faster than looking it up.
    var lineArrayLength = lineArray.length;
    while (lineEnd < text.length - 1) {
      lineEnd = text.indexOf('\n', lineStart);
      if (lineEnd == -1) {
        lineEnd = text.length - 1;
      }
      var line = text.substring(lineStart, lineEnd + 1);
      lineStart = lineEnd + 1;

      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :
          (lineHash[line] !== undefined)) {
        chars += String.fromCharCode(lineHash[line]);
      } else {
        chars += String.fromCharCode(lineArrayLength);
        lineHash[line] = lineArrayLength;
        lineArray[lineArrayLength++] = line;
      }
    }
    return chars;
  }

  var chars1 = diff_linesToCharsMunge(text1);
  var chars2 = diff_linesToCharsMunge(text2);
  return [chars1, chars2, lineArray];
};


/**
 * Rehydrate the text in a diff from a string of line hashes to real lines of
 * text.
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 * @param {Array.<string>} lineArray Array of unique strings.
 * @private
 */
diff_match_patch.prototype.diff_charsToLines = function(diffs, lineArray) {
  for (var x = 0; x < diffs.length; x++) {
    var chars = diffs[x][1];
    var text = [];
    for (var y = 0; y < chars.length; y++) {
      text[y] = lineArray[chars.charCodeAt(y)];
    }
    diffs[x][1] = text.join('');
  }
};


/**
 * Explore the intersection points between the two texts.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @return {?Array.<Array.<number|string>>} Array of diff tuples or null if no
 *     diff available.
 * @private
 */
diff_match_patch.prototype.diff_map = function(text1, text2) {
  // Don't run for too long.
  var ms_end = (new Date()).getTime() + this.Diff_Timeout * 1000;
  // Cache the text lengths to prevent multiple calls.
  var text1_length = text1.length;
  var text2_length = text2.length;
  var max_d = text1_length + text2_length - 1;
  var doubleEnd = this.Diff_DualThreshold * 2 < max_d;
  // JavaScript efficiency note: (x << 32) + y doesn't work since numbers are
  // only 32 bit.  Use x + ',' + y to create a hash instead.
  var v_map1 = [];
  var v_map2 = [];
  var v1 = {};
  var v2 = {};
  v1[1] = 0;
  v2[1] = 0;
  var x, y;
  var footstep;  // Used to track overlapping paths.
  var footsteps = {};
  var done = false;
  // If the total number of characters is odd, then the front path will collide
  // with the reverse path.
  var front = (text1_length + text2_length) % 2;
  for (var d = 0; d < max_d; d++) {
    // Bail out if timeout reached.
    if (this.Diff_Timeout > 0 && (new Date()).getTime() > ms_end) {
      return null;
    }

    // Walk the front path one step.
    v_map1[d] = {};
    for (var k = -d; k <= d; k += 2) {
      if (k == -d || k != d && v1[k - 1] < v1[k + 1]) {
        x = v1[k + 1];
      } else {
        x = v1[k - 1] + 1;
      }
      y = x - k;
      if (doubleEnd) {
        footstep = x + ',' + y;
        if (front && footsteps[footstep] !== undefined) {
          done = true;
        }
        if (!front) {
          footsteps[footstep] = d;
        }
      }
      while (!done && x < text1_length && y < text2_length &&
             text1.charAt(x) == text2.charAt(y)) {
        x++;
        y++;
        if (doubleEnd) {
          footstep = x + ',' + y;
          if (front && footsteps[footstep] !== undefined) {
            done = true;
          }
          if (!front) {
            footsteps[footstep] = d;
          }
        }
      }
      v1[k] = x;
      v_map1[d][x + ',' + y] = true;
      if (x == text1_length && y == text2_length) {
        // Reached the end in single-path mode.
        return this.diff_path1(v_map1, text1, text2);
      } else if (done) {
        // Front path ran over reverse path.
        v_map2 = v_map2.slice(0, footsteps[footstep] + 1);
        var a = this.diff_path1(v_map1, text1.substring(0, x),
                                text2.substring(0, y));
        return a.concat(this.diff_path2(v_map2, text1.substring(x),
                                        text2.substring(y)));
      }
    }

    if (doubleEnd) {
      // Walk the reverse path one step.
      v_map2[d] = {};
      for (var k = -d; k <= d; k += 2) {
        if (k == -d || k != d && v2[k - 1] < v2[k + 1]) {
          x = v2[k + 1];
        } else {
          x = v2[k - 1] + 1;
        }
        y = x - k;
        footstep = (text1_length - x) + ',' + (text2_length - y);
        if (!front && footsteps[footstep] !== undefined) {
          done = true;
        }
        if (front) {
          footsteps[footstep] = d;
        }
        while (!done && x < text1_length && y < text2_length &&
               text1.charAt(text1_length - x - 1) ==
               text2.charAt(text2_length - y - 1)) {
          x++;
          y++;
          footstep = (text1_length - x) + ',' + (text2_length - y);
          if (!front && footsteps[footstep] !== undefined) {
            done = true;
          }
          if (front) {
            footsteps[footstep] = d;
          }
        }
        v2[k] = x;
        v_map2[d][x + ',' + y] = true;
        if (done) {
          // Reverse path ran over front path.
          v_map1 = v_map1.slice(0, footsteps[footstep] + 1);
          var a = this.diff_path1(v_map1, text1.substring(0, text1_length - x),
                                  text2.substring(0, text2_length - y));
          return a.concat(this.diff_path2(v_map2,
                          text1.substring(text1_length - x),
                          text2.substring(text2_length - y)));
        }
      }
    }
  }
  // Number of diffs equals number of characters, no commonality at all.
  return null;
};


/**
 * Work from the middle back to the start to determine the path.
 * @param {Array.<Object>} v_map Array of paths.
 * @param {string} text1 Old string fragment to be diffed.
 * @param {string} text2 New string fragment to be diffed.
 * @return {Array.<Array.<number|string>>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_path1 = function(v_map, text1, text2) {
  var path = [];
  var x = text1.length;
  var y = text2.length;
  /** @type {?number} */
  var last_op = null;
  for (var d = v_map.length - 2; d >= 0; d--) {
    while (1) {
      if (v_map[d][(x - 1) + ',' + y] !== undefined) {
        x--;
        if (last_op === DIFF_DELETE) {
          path[0][1] = text1.charAt(x) + path[0][1];
        } else {
          path.unshift([DIFF_DELETE, text1.charAt(x)]);
        }
        last_op = DIFF_DELETE;
        break;
      } else if (v_map[d][x + ',' + (y - 1)] !== undefined) {
        y--;
        if (last_op === DIFF_INSERT) {
          path[0][1] = text2.charAt(y) + path[0][1];
        } else {
          path.unshift([DIFF_INSERT, text2.charAt(y)]);
        }
        last_op = DIFF_INSERT;
        break;
      } else {
        x--;
        y--;
        if (text1.charAt(x) != text2.charAt(y)) {
          throw new Error('No diagonal.  Can\'t happen. (diff_path1)');
        }
        if (last_op === DIFF_EQUAL) {
          path[0][1] = text1.charAt(x) + path[0][1];
        } else {
          path.unshift([DIFF_EQUAL, text1.charAt(x)]);
        }
        last_op = DIFF_EQUAL;
      }
    }
  }
  return path;
};


/**
 * Work from the middle back to the end to determine the path.
 * @param {Array.<Object>} v_map Array of paths.
 * @param {string} text1 Old string fragment to be diffed.
 * @param {string} text2 New string fragment to be diffed.
 * @return {Array.<Array.<number|string>>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_path2 = function(v_map, text1, text2) {
  var path = [];
  var pathLength = 0;
  var x = text1.length;
  var y = text2.length;
  /** @type {?number} */
  var last_op = null;
  for (var d = v_map.length - 2; d >= 0; d--) {
    while (1) {
      if (v_map[d][(x - 1) + ',' + y] !== undefined) {
        x--;
        if (last_op === DIFF_DELETE) {
          path[pathLength - 1][1] += text1.charAt(text1.length - x - 1);
        } else {
          path[pathLength++] =
              [DIFF_DELETE, text1.charAt(text1.length - x - 1)];
        }
        last_op = DIFF_DELETE;
        break;
      } else if (v_map[d][x + ',' + (y - 1)] !== undefined) {
        y--;
        if (last_op === DIFF_INSERT) {
          path[pathLength - 1][1] += text2.charAt(text2.length - y - 1);
        } else {
          path[pathLength++] =
              [DIFF_INSERT, text2.charAt(text2.length - y - 1)];
        }
        last_op = DIFF_INSERT;
        break;
      } else {
        x--;
        y--;
        if (text1.charAt(text1.length - x - 1) !=
            text2.charAt(text2.length - y - 1)) {
          throw new Error('No diagonal.  Can\'t happen. (diff_path2)');
        }
        if (last_op === DIFF_EQUAL) {
          path[pathLength - 1][1] += text1.charAt(text1.length - x - 1);
        } else {
          path[pathLength++] =
              [DIFF_EQUAL, text1.charAt(text1.length - x - 1)];
        }
        last_op = DIFF_EQUAL;
      }
    }
  }
  return path;
};


/**
 * Determine the common prefix of two strings
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the start of each
 *     string.
 */
diff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerstart = 0;
  while (pointermin < pointermid) {
    if (text1.substring(pointerstart, pointermid) ==
        text2.substring(pointerstart, pointermid)) {
      pointermin = pointermid;
      pointerstart = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Determine the common suffix of two strings
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of each string.
 */
diff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 || text1.charAt(text1.length - 1) !=
                          text2.charAt(text2.length - 1)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerend = 0;
  while (pointermin < pointermid) {
    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
        text2.substring(text2.length - pointermid, text2.length - pointerend)) {
      pointermin = pointermid;
      pointerend = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Do the two texts share a substring which is at least half the length of the
 * longer text?
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {?Array.<string>} Five element Array, containing the prefix of
 *     text1, the suffix of text1, the prefix of text2, the suffix of
 *     text2 and the common middle.  Or null if there was no match.
 */
diff_match_patch.prototype.diff_halfMatch = function(text1, text2) {
  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  if (longtext.length < 10 || shorttext.length < 1) {
    return null;  // Pointless.
  }
  var dmp = this;  // 'this' becomes 'window' in a closure.

  /**
   * Does a substring of shorttext exist within longtext such that the substring
   * is at least half the length of longtext?
   * Closure, but does not reference any external variables.
   * @param {string} longtext Longer string.
   * @param {string} shorttext Shorter string.
   * @param {number} i Start index of quarter length substring within longtext
   * @return {?Array.<string>} Five element Array, containing the prefix of
   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
   *     of shorttext and the common middle.  Or null if there was no match.
   * @private
   */
  function diff_halfMatchI(longtext, shorttext, i) {
    // Start with a 1/4 length substring at position i as a seed.
    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
    var j = -1;
    var best_common = '';
    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),
                                               shorttext.substring(j));
      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),
                                               shorttext.substring(0, j));
      if (best_common.length < suffixLength + prefixLength) {
        best_common = shorttext.substring(j - suffixLength, j) +
            shorttext.substring(j, j + prefixLength);
        best_longtext_a = longtext.substring(0, i - suffixLength);
        best_longtext_b = longtext.substring(i + prefixLength);
        best_shorttext_a = shorttext.substring(0, j - suffixLength);
        best_shorttext_b = shorttext.substring(j + prefixLength);
      }
    }
    if (best_common.length >= longtext.length / 2) {
      return [best_longtext_a, best_longtext_b,
              best_shorttext_a, best_shorttext_b, best_common];
    } else {
      return null;
    }
  }

  // First check if the second quarter is the seed for a half-match.
  var hm1 = diff_halfMatchI(longtext, shorttext,
                            Math.ceil(longtext.length / 4));
  // Check again based on the third quarter.
  var hm2 = diff_halfMatchI(longtext, shorttext,
                            Math.ceil(longtext.length / 2));
  var hm;
  if (!hm1 && !hm2) {
    return null;
  } else if (!hm2) {
    hm = hm1;
  } else if (!hm1) {
    hm = hm2;
  } else {
    // Both matched.  Select the longest.
    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
  }

  // A half-match was found, sort out the return data.
  var text1_a, text1_b, text2_a, text2_b;
  if (text1.length > text2.length) {
    text1_a = hm[0];
    text1_b = hm[1];
    text2_a = hm[2];
    text2_b = hm[3];
  } else {
    text2_a = hm[0];
    text2_b = hm[1];
    text1_a = hm[2];
    text1_b = hm[3];
  }
  var mid_common = hm[4];
  return [text1_a, text1_b, text2_a, text2_b, mid_common];
};


/**
 * Reduce the number of edits by eliminating semantically trivial equalities.
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {
  var changes = false;
  var equalities = [];  // Stack of indices where equalities are found.
  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
  var lastequality = null;  // Always equal to equalities[equalitiesLength-1][1]
  var pointer = 0;  // Index of current position.
  // Number of characters that changed prior to the equality.
  var length_changes1 = 0;
  // Number of characters that changed after the equality.
  var length_changes2 = 0;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {  // equality found
      equalities[equalitiesLength++] = pointer;
      length_changes1 = length_changes2;
      length_changes2 = 0;
      lastequality = diffs[pointer][1];
    } else {  // an insertion or deletion
      length_changes2 += diffs[pointer][1].length;
      if (lastequality !== null && (lastequality.length <= length_changes1) &&
          (lastequality.length <= length_changes2)) {
        // Duplicate record
        diffs.splice(equalities[equalitiesLength - 1], 0,
                     [DIFF_DELETE, lastequality]);
        // Change second copy to insert.
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        // Throw away the equality we just deleted.
        equalitiesLength--;
        // Throw away the previous equality (it needs to be reevaluated).
        equalitiesLength--;
        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
        length_changes1 = 0;  // Reset the counters.
        length_changes2 = 0;
        lastequality = null;
        changes = true;
      }
    }
    pointer++;
  }
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
  this.diff_cleanupSemanticLossless(diffs);
};


/**
 * Look for single edits surrounded on both sides by equalities
 * which can be shifted sideways to align the edit to a word boundary.
 * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {
  // Define some regex patterns for matching boundaries.
  var punctuation = /[^a-zA-Z0-9]/;
  var whitespace = /\s/;
  var linebreak = /[\r\n]/;
  var blanklineEnd = /\n\r?\n$/;
  var blanklineStart = /^\r?\n\r?\n/;

  /**
   * Given two strings, compute a score representing whether the internal
   * boundary falls on logical boundaries.
   * Scores range from 5 (best) to 0 (worst).
   * Closure, makes reference to regex patterns defined above.
   * @param {string} one First string.
   * @param {string} two Second string.
   * @return {number} The score.
   */
  function diff_cleanupSemanticScore(one, two) {
    if (!one || !two) {
      // Edges are the best.
      return 5;
    }

    // Each port of this function behaves slightly differently due to
    // subtle differences in each language's definition of things like
    // 'whitespace'.  Since this function's purpose is largely cosmetic,
    // the choice has been made to use each language's native features
    // rather than force total conformity.
    var score = 0;
    // One point for non-alphanumeric.
    if (one.charAt(one.length - 1).match(punctuation) ||
        two.charAt(0).match(punctuation)) {
      score++;
      // Two points for whitespace.
      if (one.charAt(one.length - 1).match(whitespace) ||
          two.charAt(0).match(whitespace)) {
        score++;
        // Three points for line breaks.
        if (one.charAt(one.length - 1).match(linebreak) ||
            two.charAt(0).match(linebreak)) {
          score++;
          // Four points for blank lines.
          if (one.match(blanklineEnd) || two.match(blanklineStart)) {
            score++;
          }
        }
      }
    }
    return score;
  }

  var pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
        diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      var equality1 = diffs[pointer - 1][1];
      var edit = diffs[pointer][1];
      var equality2 = diffs[pointer + 1][1];

      // First, shift the edit as far left as possible.
      var commonOffset = this.diff_commonSuffix(equality1, edit);
      if (commonOffset) {
        var commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset);
        edit = commonString + edit.substring(0, edit.length - commonOffset);
        equality2 = commonString + equality2;
      }

      // Second, step character by character right, looking for the best fit.
      var bestEquality1 = equality1;
      var bestEdit = edit;
      var bestEquality2 = equality2;
      var bestScore = diff_cleanupSemanticScore(equality1, edit) +
          diff_cleanupSemanticScore(edit, equality2);
      while (edit.charAt(0) === equality2.charAt(0)) {
        equality1 += edit.charAt(0);
        edit = edit.substring(1) + equality2.charAt(0);
        equality2 = equality2.substring(1);
        var score = diff_cleanupSemanticScore(equality1, edit) +
            diff_cleanupSemanticScore(edit, equality2);
        // The >= encourages trailing rather than leading whitespace on edits.
        if (score >= bestScore) {
          bestScore = score;
          bestEquality1 = equality1;
          bestEdit = edit;
          bestEquality2 = equality2;
        }
      }

      if (diffs[pointer - 1][1] != bestEquality1) {
        // We have an improvement, save it back to the diff.
        if (bestEquality1) {
          diffs[pointer - 1][1] = bestEquality1;
        } else {
          diffs.splice(pointer - 1, 1);
          pointer--;
        }
        diffs[pointer][1] = bestEdit;
        if (bestEquality2) {
          diffs[pointer + 1][1] = bestEquality2;
        } else {
          diffs.splice(pointer + 1, 1);
          pointer--;
        }
      }
    }
    pointer++;
  }
};


/**
 * Reduce the number of edits by eliminating operationally trivial equalities.
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {
  var changes = false;
  var equalities = [];  // Stack of indices where equalities are found.
  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
  var lastequality = '';  // Always equal to equalities[equalitiesLength-1][1]
  var pointer = 0;  // Index of current position.
  // Is there an insertion operation before the last equality.
  var pre_ins = false;
  // Is there a deletion operation before the last equality.
  var pre_del = false;
  // Is there an insertion operation after the last equality.
  var post_ins = false;
  // Is there a deletion operation after the last equality.
  var post_del = false;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {  // equality found
      if (diffs[pointer][1].length < this.Diff_EditCost &&
          (post_ins || post_del)) {
        // Candidate found.
        equalities[equalitiesLength++] = pointer;
        pre_ins = post_ins;
        pre_del = post_del;
        lastequality = diffs[pointer][1];
      } else {
        // Not a candidate, and can never become one.
        equalitiesLength = 0;
        lastequality = '';
      }
      post_ins = post_del = false;
    } else {  // an insertion or deletion
      if (diffs[pointer][0] == DIFF_DELETE) {
        post_del = true;
      } else {
        post_ins = true;
      }
      /*
       * Five types to be split:
       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>
       * <ins>A</ins>X<ins>C</ins><del>D</del>
       * <ins>A</ins><del>B</del>X<ins>C</ins>
       * <ins>A</del>X<ins>C</ins><del>D</del>
       * <ins>A</ins><del>B</del>X<del>C</del>
       */
      if (lastequality && ((pre_ins && pre_del && post_ins && post_del) ||
                           ((lastequality.length < this.Diff_EditCost / 2) &&
                            (pre_ins + pre_del + post_ins + post_del) == 3))) {
        // Duplicate record
        diffs.splice(equalities[equalitiesLength - 1], 0,
                     [DIFF_DELETE, lastequality]);
        // Change second copy to insert.
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        equalitiesLength--;  // Throw away the equality we just deleted;
        lastequality = '';
        if (pre_ins && pre_del) {
          // No changes made which could affect previous entry, keep going.
          post_ins = post_del = true;
          equalitiesLength = 0;
        } else {
          equalitiesLength--;  // Throw away the previous equality;
          pointer = equalitiesLength > 0 ?
              equalities[equalitiesLength - 1] : -1;
          post_ins = post_del = false;
        }
        changes = true;
      }
    }
    pointer++;
  }

  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};


/**
 * Reorder and merge like edit sections.  Merge equalities.
 * Any edit section can move as long as it doesn't cross an equality.
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupMerge = function(diffs) {
  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = '';
  var text_insert = '';
  var commonlength;
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_EQUAL:
        // Upon reaching an equality, check for prior redundancies.
        if (count_delete !== 0 || count_insert !== 0) {
          if (count_delete !== 0 && count_insert !== 0) {
            // Factor out any common prefixies.
            commonlength = this.diff_commonPrefix(text_insert, text_delete);
            if (commonlength !== 0) {
              if ((pointer - count_delete - count_insert) > 0 &&
                  diffs[pointer - count_delete - count_insert - 1][0] ==
                  DIFF_EQUAL) {
                diffs[pointer - count_delete - count_insert - 1][1] +=
                    text_insert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, [DIFF_EQUAL,
                    text_insert.substring(0, commonlength)]);
                pointer++;
              }
              text_insert = text_insert.substring(commonlength);
              text_delete = text_delete.substring(commonlength);
            }
            // Factor out any common suffixies.
            commonlength = this.diff_commonSuffix(text_insert, text_delete);
            if (commonlength !== 0) {
              diffs[pointer][1] = text_insert.substring(text_insert.length -
                  commonlength) + diffs[pointer][1];
              text_insert = text_insert.substring(0, text_insert.length -
                  commonlength);
              text_delete = text_delete.substring(0, text_delete.length -
                  commonlength);
            }
          }
          // Delete the offending records and add the merged ones.
          if (count_delete === 0) {
            diffs.splice(pointer - count_delete - count_insert,
                count_delete + count_insert, [DIFF_INSERT, text_insert]);
          } else if (count_insert === 0) {
            diffs.splice(pointer - count_delete - count_insert,
                count_delete + count_insert, [DIFF_DELETE, text_delete]);
          } else {
            diffs.splice(pointer - count_delete - count_insert,
                count_delete + count_insert, [DIFF_DELETE, text_delete],
                [DIFF_INSERT, text_insert]);
          }
          pointer = pointer - count_delete - count_insert +
                    (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
          // Merge this equality with the previous one.
          diffs[pointer - 1][1] += diffs[pointer][1];
          diffs.splice(pointer, 1);
        } else {
          pointer++;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = '';
        text_insert = '';
        break;
    }
  }
  if (diffs[diffs.length - 1][1] === '') {
    diffs.pop();  // Remove the dummy entry at the end.
  }

  // Second pass: look for single edits surrounded on both sides by equalities
  // which can be shifted sideways to eliminate an equality.
  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
  var changes = false;
  pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
        diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      if (diffs[pointer][1].substring(diffs[pointer][1].length -
          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
        // Shift the edit over the previous equality.
        diffs[pointer][1] = diffs[pointer - 1][1] +
            diffs[pointer][1].substring(0, diffs[pointer][1].length -
                                        diffs[pointer - 1][1].length);
        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
        diffs.splice(pointer - 1, 1);
        changes = true;
      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
          diffs[pointer + 1][1]) {
        // Shift the edit over the next equality.
        diffs[pointer - 1][1] += diffs[pointer + 1][1];
        diffs[pointer][1] =
            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
            diffs[pointer + 1][1];
        diffs.splice(pointer + 1, 1);
        changes = true;
      }
    }
    pointer++;
  }
  // If shifts were made, the diff needs reordering and another shift sweep.
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};


/**
 * loc is a location in text1, compute and return the equivalent location in
 * text2.
 * e.g. 'The cat' vs 'The big cat', 1->1, 5->8
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 * @param {number} loc Location within text1.
 * @return {number} Location within text2.
 */
diff_match_patch.prototype.diff_xIndex = function(diffs, loc) {
  var chars1 = 0;
  var chars2 = 0;
  var last_chars1 = 0;
  var last_chars2 = 0;
  var x;
  for (x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.
      chars1 += diffs[x][1].length;
    }
    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.
      chars2 += diffs[x][1].length;
    }
    if (chars1 > loc) {  // Overshot the location.
      break;
    }
    last_chars1 = chars1;
    last_chars2 = chars2;
  }
  // Was the location was deleted?
  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {
    return last_chars2;
  }
  // Add the remaining character length.
  return last_chars2 + (loc - last_chars1);
};


/**
 * Convert a diff array into a pretty HTML report.
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 * @return {string} HTML representation.
 */
diff_match_patch.prototype.diff_prettyHtml = function(diffs) {
  var html = [];
  var i = 0;
  for (var x = 0; x < diffs.length; x++) {
    var op = diffs[x][0];    // Operation (insert, delete, equal)
    var data = diffs[x][1];  // Text of change.
    var text = data.replace(/&/g, '&amp;').replace(/</g, '&lt;')
        .replace(/>/g, '&gt;').replace(/\n/g, '&para;<BR>');
    switch (op) {
      case DIFF_INSERT:
        html[x] = '<INS STYLE="background:#E6FFE6;" TITLE="i=' + i + '">' +
                text + '</INS>';
        break;
      case DIFF_DELETE:
        html[x] = '<DEL STYLE="background:#FFE6E6;" TITLE="i=' + i + '">' +
                text + '</DEL>';
        break;
      case DIFF_EQUAL:
        html[x] = '<SPAN TITLE="i=' + i + '">' + text + '</SPAN>';
        break;
    }
    if (op !== DIFF_DELETE) {
      i += data.length;
    }
  }
  return html.join('');
};


/**
 * Compute and return the source text (all equalities and deletions).
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 * @return {string} Source text.
 */
diff_match_patch.prototype.diff_text1 = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {
      text[x] = diffs[x][1];
    }
  }
  return text.join('');
};


/**
 * Compute and return the destination text (all equalities and insertions).
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 * @return {string} Destination text.
 */
diff_match_patch.prototype.diff_text2 = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_DELETE) {
      text[x] = diffs[x][1];
    }
  }
  return text.join('');
};


/**
 * Compute the Levenshtein distance; the number of inserted, deleted or
 * substituted characters.
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 * @return {number} Number of changes.
 */
diff_match_patch.prototype.diff_levenshtein = function(diffs) {
  var levenshtein = 0;
  var insertions = 0;
  var deletions = 0;
  for (var x = 0; x < diffs.length; x++) {
    var op = diffs[x][0];
    var data = diffs[x][1];
    switch (op) {
      case DIFF_INSERT:
        insertions += data.length;
        break;
      case DIFF_DELETE:
        deletions += data.length;
        break;
      case DIFF_EQUAL:
        // A deletion and an insertion is one substitution.
        levenshtein += Math.max(insertions, deletions);
        insertions = 0;
        deletions = 0;
        break;
    }
  }
  levenshtein += Math.max(insertions, deletions);
  return levenshtein;
};


/**
 * Crush the diff into an encoded string which describes the operations
 * required to transform text1 into text2.
 * E.g. =3\t-2\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.
 * Operations are tab-separated.  Inserted text is escaped using %xx notation.
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 * @return {string} Delta text.
 */
diff_match_patch.prototype.diff_toDelta = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    switch (diffs[x][0]) {
      case DIFF_INSERT:
        text[x] = '+' + encodeURI(diffs[x][1]);
        break;
      case DIFF_DELETE:
        text[x] = '-' + diffs[x][1].length;
        break;
      case DIFF_EQUAL:
        text[x] = '=' + diffs[x][1].length;
        break;
    }
  }
  // Opera doesn't know how to encode char 0.
  return text.join('\t').replace(/\x00/g, '%00').replace(/%20/g, ' ');
};


/**
 * Given the original text1, and an encoded string which describes the
 * operations required to transform text1 into text2, compute the full diff.
 * @param {string} text1 Source string for the diff.
 * @param {string} delta Delta text.
 * @return {Array.<Array.<number|string>>} Array of diff tuples.
 * @throws {Error} If invalid input.
 */
diff_match_patch.prototype.diff_fromDelta = function(text1, delta) {
  var diffs = [];
  var diffsLength = 0;  // Keeping our own length var is faster in JS.
  var pointer = 0;  // Cursor in text1
  // Opera doesn't know how to decode char 0.
  delta = delta.replace(/%00/g, '\0');
  var tokens = delta.split(/\t/g);
  for (var x = 0; x < tokens.length; x++) {
    // Each token begins with a one character parameter which specifies the
    // operation of this token (delete, insert, equality).
    var param = tokens[x].substring(1);
    switch (tokens[x].charAt(0)) {
      case '+':
        try {
          diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)];
        } catch (ex) {
          // Malformed URI sequence.
          throw new Error('Illegal escape in diff_fromDelta: ' + param);
        }
        break;
      case '-':
        // Fall through.
      case '=':
        var n = parseInt(param, 10);
        if (isNaN(n) || n < 0) {
          throw new Error('Invalid number in diff_fromDelta: ' + param);
        }
        var text = text1.substring(pointer, pointer += n);
        if (tokens[x].charAt(0) == '=') {
          diffs[diffsLength++] = [DIFF_EQUAL, text];
        } else {
          diffs[diffsLength++] = [DIFF_DELETE, text];
        }
        break;
      default:
        // Blank tokens are ok (from a trailing \t).
        // Anything else is an error.
        if (tokens[x]) {
          throw new Error('Invalid diff operation in diff_fromDelta: ' +
                          tokens[x]);
        }
    }
  }
  if (pointer != text1.length) {
    throw new Error('Delta length (' + pointer +
        ') does not equal source text length (' + text1.length + ').');
  }
  return diffs;
};


//  MATCH FUNCTIONS


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc'.
 * @param {string} text The text to search.
 * @param {string} pattern The pattern to search for.
 * @param {number} loc The location to search around.
 * @return {number} Best match index or -1.
 */
diff_match_patch.prototype.match_main = function(text, pattern, loc) {
  // Check for null inputs.
  if (text == null || pattern == null || loc == null) {
    throw new Error('Null input. (match_main)');
  }

  loc = Math.max(0, Math.min(loc, text.length));
  if (text == pattern) {
    // Shortcut (potentially not guaranteed by the algorithm)
    return 0;
  } else if (!text.length) {
    // Nothing to match.
    return -1;
  } else if (text.substring(loc, loc + pattern.length) == pattern) {
    // Perfect match at the perfect spot!  (Includes case of null pattern)
    return loc;
  } else {
    // Do a fuzzy compare.
    return this.match_bitap(text, pattern, loc);
  }
};


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc' using the
 * Bitap algorithm.
 * @param {string} text The text to search.
 * @param {string} pattern The pattern to search for.
 * @param {number} loc The location to search around.
 * @return {number} Best match index or -1.
 * @private
 */
diff_match_patch.prototype.match_bitap = function(text, pattern, loc) {
  if (pattern.length > this.Match_MaxBits) {
    throw new Error('Pattern too long for this browser.');
  }

  // Initialise the alphabet.
  var s = this.match_alphabet(pattern);

  var dmp = this;  // 'this' becomes 'window' in a closure.

  /**
   * Compute and return the score for a match with e errors and x location.
   * Accesses loc and pattern through being a closure.
   * @param {number} e Number of errors in match.
   * @param {number} x Location of match.
   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).
   * @private
   */
  function match_bitapScore(e, x) {
    var accuracy = e / pattern.length;
    var proximity = Math.abs(loc - x);
    if (!dmp.Match_Distance) {
      // Dodge divide by zero error.
      return proximity ? 1.0 : accuracy;
    }
    return accuracy + (proximity / dmp.Match_Distance);
  }

  // Highest score beyond which we give up.
  var score_threshold = this.Match_Threshold;
  // Is there a nearby exact match? (speedup)
  var best_loc = text.indexOf(pattern, loc);
  if (best_loc != -1) {
    score_threshold = Math.min(match_bitapScore(0, best_loc), score_threshold);
    // What about in the other direction? (speedup)
    best_loc = text.lastIndexOf(pattern, loc + pattern.length);
    if (best_loc != -1) {
      score_threshold =
          Math.min(match_bitapScore(0, best_loc), score_threshold);
    }
  }

  // Initialise the bit arrays.
  var matchmask = 1 << (pattern.length - 1);
  best_loc = -1;

  var bin_min, bin_mid;
  var bin_max = pattern.length + text.length;
  var last_rd;
  for (var d = 0; d < pattern.length; d++) {
    // Scan for the best match; each iteration allows for one more error.
    // Run a binary search to determine how far from 'loc' we can stray at this
    // error level.
    bin_min = 0;
    bin_mid = bin_max;
    while (bin_min < bin_mid) {
      if (match_bitapScore(d, loc + bin_mid) <= score_threshold) {
        bin_min = bin_mid;
      } else {
        bin_max = bin_mid;
      }
      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);
    }
    // Use the result from this iteration as the maximum for the next.
    bin_max = bin_mid;
    var start = Math.max(1, loc - bin_mid + 1);
    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;

    var rd = Array(finish + 2);
    rd[finish + 1] = (1 << d) - 1;
    for (var j = finish; j >= start; j--) {
      // The alphabet (s) is a sparse hash, so the following line generates
      // warnings.
      var charMatch = s[text.charAt(j - 1)];
      if (d === 0) {  // First pass: exact match.
        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;
      } else {  // Subsequent passes: fuzzy match.
        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch |
                (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |
                last_rd[j + 1];
      }
      if (rd[j] & matchmask) {
        var score = match_bitapScore(d, j - 1);
        // This match will almost certainly be better than any existing match.
        // But check anyway.
        if (score <= score_threshold) {
          // Told you so.
          score_threshold = score;
          best_loc = j - 1;
          if (best_loc > loc) {
            // When passing loc, don't exceed our current distance from loc.
            start = Math.max(1, 2 * loc - best_loc);
          } else {
            // Already passed loc, downhill from here on in.
            break;
          }
        }
      }
    }
    // No hope for a (better) match at greater error levels.
    if (match_bitapScore(d + 1, loc) > score_threshold) {
      break;
    }
    last_rd = rd;
  }
  return best_loc;
};


/**
 * Initialise the alphabet for the Bitap algorithm.
 * @param {string} pattern The text to encode.
 * @return {Object} Hash of character locations.
 * @private
 */
diff_match_patch.prototype.match_alphabet = function(pattern) {
  var s = {};
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] = 0;
  }
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);
  }
  return s;
};


//  PATCH FUNCTIONS


/**
 * Increase the context until it is unique,
 * but don't let the pattern expand beyond Match_MaxBits.
 * @param {patch_obj} patch The patch to grow.
 * @param {string} text Source text.
 * @private
 */
diff_match_patch.prototype.patch_addContext = function(patch, text) {
  if (text.length == 0) {
    return;
  }
  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);
  var padding = 0;

  // Look for the first and last matches of pattern in text.  If two different
  // matches are found, increase the pattern length.
  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&
         pattern.length < this.Match_MaxBits - this.Patch_Margin -
         this.Patch_Margin) {
    padding += this.Patch_Margin;
    pattern = text.substring(patch.start2 - padding,
                             patch.start2 + patch.length1 + padding);
  }
  // Add one chunk for good luck.
  padding += this.Patch_Margin;

  // Add the prefix.
  var prefix = text.substring(patch.start2 - padding, patch.start2);
  if (prefix) {
    patch.diffs.unshift([DIFF_EQUAL, prefix]);
  }
  // Add the suffix.
  var suffix = text.substring(patch.start2 + patch.length1,
                              patch.start2 + patch.length1 + padding);
  if (suffix) {
    patch.diffs.push([DIFF_EQUAL, suffix]);
  }

  // Roll back the start points.
  patch.start1 -= prefix.length;
  patch.start2 -= prefix.length;
  // Extend the lengths.
  patch.length1 += prefix.length + suffix.length;
  patch.length2 += prefix.length + suffix.length;
};


/**
 * Compute a list of patches to turn text1 into text2.
 * Use diffs if provided, otherwise compute it ourselves.
 * There are four ways to call this function, depending on what data is
 * available to the caller:
 * Method 1:
 * a = text1, b = text2
 * Method 2:
 * a = diffs
 * Method 3 (optimal):
 * a = text1, b = diffs
 * Method 4 (deprecated, use method 3):
 * a = text1, b = text2, c = diffs
 *
 * @param {string|Array.<Array.<number|string>>} a text1 (methods 1,3,4) or
 * Array of diff tuples for text1 to text2 (method 2).
 * @param {string|Array.<Array.<number|string>>} opt_b text2 (methods 1,4) or
 * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).
 * @param {string|Array.<Array.<number|string>>} opt_c Array of diff tuples for
 * text1 to text2 (method 4) or undefined (methods 1,2,3).
 * @return {Array.<patch_obj>} Array of patch objects.
 */
diff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {
  var text1, diffs;
  if (typeof a == 'string' && typeof opt_b == 'string' &&
      typeof opt_c == 'undefined') {
    // Method 1: text1, text2
    // Compute diffs from text1 and text2.
    text1 = a;
    diffs = this.diff_main(text1, opt_b, true);
    if (diffs.length > 2) {
      this.diff_cleanupSemantic(diffs);
      this.diff_cleanupEfficiency(diffs);
    }
  } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&
      typeof opt_c == 'undefined') {
    // Method 2: diffs
    // Compute text1 from diffs.
    diffs = a;
    text1 = this.diff_text1(diffs);
  } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&
      typeof opt_c == 'undefined') {
    // Method 3: text1, diffs
    text1 = a;
    diffs = opt_b;
  } else if (typeof a == 'string' && typeof opt_b == 'string' &&
      opt_c && typeof opt_c == 'object') {
    // Method 4: text1, text2, diffs
    // text2 is not used.
    text1 = a;
    diffs = opt_c;
  } else {
    throw new Error('Unknown call format to patch_make.');
  }

  if (diffs.length === 0) {
    return [];  // Get rid of the null case.
  }
  var patches = [];
  var patch = new patch_obj();
  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.
  var char_count1 = 0;  // Number of characters into the text1 string.
  var char_count2 = 0;  // Number of characters into the text2 string.
  // Start with text1 (prepatch_text) and apply the diffs until we arrive at
  // text2 (postpatch_text).  We recreate the patches one by one to determine
  // context info.
  var prepatch_text = text1;
  var postpatch_text = text1;
  for (var x = 0; x < diffs.length; x++) {
    var diff_type = diffs[x][0];
    var diff_text = diffs[x][1];

    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
      // A new patch starts here.
      patch.start1 = char_count1;
      patch.start2 = char_count2;
    }

    switch (diff_type) {
      case DIFF_INSERT:
        patch.diffs[patchDiffLength++] = diffs[x];
        patch.length2 += diff_text.length;
        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +
                         postpatch_text.substring(char_count2);
        break;
      case DIFF_DELETE:
        patch.length1 += diff_text.length;
        patch.diffs[patchDiffLength++] = diffs[x];
        postpatch_text = postpatch_text.substring(0, char_count2) +
                         postpatch_text.substring(char_count2 +
                             diff_text.length);
        break;
      case DIFF_EQUAL:
        if (diff_text.length <= 2 * this.Patch_Margin &&
            patchDiffLength && diffs.length != x + 1) {
          // Small equality inside a patch.
          patch.diffs[patchDiffLength++] = diffs[x];
          patch.length1 += diff_text.length;
          patch.length2 += diff_text.length;
        } else if (diff_text.length >= 2 * this.Patch_Margin) {
          // Time for a new patch.
          if (patchDiffLength) {
            this.patch_addContext(patch, prepatch_text);
            patches.push(patch);
            patch = new patch_obj();
            patchDiffLength = 0;
            // Unlike Unidiff, our patch lists have a rolling context.
            // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff
            // Update prepatch text & pos to reflect the application of the
            // just completed patch.
            prepatch_text = postpatch_text;
            char_count1 = char_count2;
          }
        }
        break;
    }

    // Update the current character count.
    if (diff_type !== DIFF_INSERT) {
      char_count1 += diff_text.length;
    }
    if (diff_type !== DIFF_DELETE) {
      char_count2 += diff_text.length;
    }
  }
  // Pick up the leftover patch if not empty.
  if (patchDiffLength) {
    this.patch_addContext(patch, prepatch_text);
    patches.push(patch);
  }

  return patches;
};


/**
 * Given an array of patches, return another array that is identical.
 * @param {Array.<patch_obj>} patches Array of patch objects.
 * @return {Array.<patch_obj>} Array of patch objects.
 */
diff_match_patch.prototype.patch_deepCopy = function(patches) {
  // Making deep copies is hard in JavaScript.
  var patchesCopy = [];
  for (var x = 0; x < patches.length; x++) {
    var patch = patches[x];
    var patchCopy = new patch_obj();
    patchCopy.diffs = [];
    for (var y = 0; y < patch.diffs.length; y++) {
      patchCopy.diffs[y] = patch.diffs[y].slice();
    }
    patchCopy.start1 = patch.start1;
    patchCopy.start2 = patch.start2;
    patchCopy.length1 = patch.length1;
    patchCopy.length2 = patch.length2;
    patchesCopy[x] = patchCopy;
  }
  return patchesCopy;
};


/**
 * Merge a set of patches onto the text.  Return a patched text, as well
 * as a list of true/false values indicating which patches were applied.
 * @param {Array.<patch_obj>} patches Array of patch objects.
 * @param {string} text Old text.
 * @return {Array.<string|Array.<boolean>>} Two element Array, containing the
 *      new text and an array of boolean values.
 */
diff_match_patch.prototype.patch_apply = function(patches, text) {
  if (patches.length == 0) {
    return [text, []];
  }

  // Deep copy the patches so that no changes are made to originals.
  patches = this.patch_deepCopy(patches);

  var nullPadding = this.patch_addPadding(patches);
  text = nullPadding + text + nullPadding;

  this.patch_splitMax(patches);
  // delta keeps track of the offset between the expected and actual location
  // of the previous patch.  If there are patches expected at positions 10 and
  // 20, but the first patch was found at 12, delta is 2 and the second patch
  // has an effective expected position of 22.
  var delta = 0;
  var results = [];
  for (var x = 0; x < patches.length; x++) {
    var expected_loc = patches[x].start2 + delta;
    var text1 = this.diff_text1(patches[x].diffs);
    var start_loc;
    var end_loc = -1;
    if (text1.length > this.Match_MaxBits) {
      // patch_splitMax will only provide an oversized pattern in the case of
      // a monster delete.
      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),
                                  expected_loc);
      if (start_loc != -1) {
        end_loc = this.match_main(text,
            text1.substring(text1.length - this.Match_MaxBits),
            expected_loc + text1.length - this.Match_MaxBits);
        if (end_loc == -1 || start_loc >= end_loc) {
          // Can't find valid trailing context.  Drop this patch.
          start_loc = -1;
        }
      }
    } else {
      start_loc = this.match_main(text, text1, expected_loc);
    }
    if (start_loc == -1) {
      // No match found.  :(
      results[x] = false;
      // Subtract the delta for this failed patch from subsequent patches.
      delta -= patches[x].length2 - patches[x].length1;
    } else {
      // Found a match.  :)
      results[x] = true;
      delta = start_loc - expected_loc;
      var text2;
      if (end_loc == -1) {
        text2 = text.substring(start_loc, start_loc + text1.length);
      } else {
        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);
      }
      if (text1 == text2) {
        // Perfect match, just shove the replacement text in.
        text = text.substring(0, start_loc) +
               this.diff_text2(patches[x].diffs) +
               text.substring(start_loc + text1.length);
      } else {
        // Imperfect match.  Run a diff to get a framework of equivalent
        // indices.
        var diffs = this.diff_main(text1, text2, false);
        if (text1.length > this.Match_MaxBits &&
            this.diff_levenshtein(diffs) / text1.length >
            this.Patch_DeleteThreshold) {
          // The end points match, but the content is unacceptably bad.
          results[x] = false;
        } else {
          this.diff_cleanupSemanticLossless(diffs);
          var index1 = 0;
          var index2;
          for (var y = 0; y < patches[x].diffs.length; y++) {
            var mod = patches[x].diffs[y];
            if (mod[0] !== DIFF_EQUAL) {
              index2 = this.diff_xIndex(diffs, index1);
            }
            if (mod[0] === DIFF_INSERT) {  // Insertion
              text = text.substring(0, start_loc + index2) + mod[1] +
                     text.substring(start_loc + index2);
            } else if (mod[0] === DIFF_DELETE) {  // Deletion
              text = text.substring(0, start_loc + index2) +
                     text.substring(start_loc + this.diff_xIndex(diffs,
                         index1 + mod[1].length));
            }
            if (mod[0] !== DIFF_DELETE) {
              index1 += mod[1].length;
            }
          }
        }
      }
    }
  }
  // Strip the padding off.
  text = text.substring(nullPadding.length, text.length - nullPadding.length);
  return [text, results];
};


/**
 * Add some padding on text start and end so that edges can match something.
 * Intended to be called only from within patch_apply.
 * @param {Array.<patch_obj>} patches Array of patch objects.
 * @return {string} The padding string added to each side.
 */
diff_match_patch.prototype.patch_addPadding = function(patches) {
  var paddingLength = this.Patch_Margin;
  var nullPadding = '';
  for (var x = 1; x <= paddingLength; x++) {
    nullPadding += String.fromCharCode(x);
  }

  // Bump all the patches forward.
  for (var x = 0; x < patches.length; x++) {
    patches[x].start1 += paddingLength;
    patches[x].start2 += paddingLength;
  }

  // Add some padding on start of first diff.
  var patch = patches[0];
  var diffs = patch.diffs;
  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
    // Add nullPadding equality.
    diffs.unshift([DIFF_EQUAL, nullPadding]);
    patch.start1 -= paddingLength;  // Should be 0.
    patch.start2 -= paddingLength;  // Should be 0.
    patch.length1 += paddingLength;
    patch.length2 += paddingLength;
  } else if (paddingLength > diffs[0][1].length) {
    // Grow first equality.
    var extraLength = paddingLength - diffs[0][1].length;
    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
    patch.start1 -= extraLength;
    patch.start2 -= extraLength;
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }

  // Add some padding on end of last diff.
  patch = patches[patches.length - 1];
  diffs = patch.diffs;
  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
    // Add nullPadding equality.
    diffs.push([DIFF_EQUAL, nullPadding]);
    patch.length1 += paddingLength;
    patch.length2 += paddingLength;
  } else if (paddingLength > diffs[diffs.length - 1][1].length) {
    // Grow last equality.
    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;
    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }

  return nullPadding;
};


/**
 * Look through the patches and break up any which are longer than the maximum
 * limit of the match algorithm.
 * @param {Array.<patch_obj>} patches Array of patch objects.
 */
diff_match_patch.prototype.patch_splitMax = function(patches) {
  for (var x = 0; x < patches.length; x++) {
    if (patches[x].length1 > this.Match_MaxBits) {
      var bigpatch = patches[x];
      // Remove the big old patch.
      patches.splice(x--, 1);
      var patch_size = this.Match_MaxBits;
      var start1 = bigpatch.start1;
      var start2 = bigpatch.start2;
      var precontext = '';
      while (bigpatch.diffs.length !== 0) {
        // Create one of several smaller patches.
        var patch = new patch_obj();
        var empty = true;
        patch.start1 = start1 - precontext.length;
        patch.start2 = start2 - precontext.length;
        if (precontext !== '') {
          patch.length1 = patch.length2 = precontext.length;
          patch.diffs.push([DIFF_EQUAL, precontext]);
        }
        while (bigpatch.diffs.length !== 0 &&
               patch.length1 < patch_size - this.Patch_Margin) {
          var diff_type = bigpatch.diffs[0][0];
          var diff_text = bigpatch.diffs[0][1];
          if (diff_type === DIFF_INSERT) {
            // Insertions are harmless.
            patch.length2 += diff_text.length;
            start2 += diff_text.length;
            patch.diffs.push(bigpatch.diffs.shift());
            empty = false;
          } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&
                     patch.diffs[0][0] == DIFF_EQUAL &&
                     diff_text.length > 2 * patch_size) {
            // This is a large deletion.  Let it pass in one chunk.
            patch.length1 += diff_text.length;
            start1 += diff_text.length;
            empty = false;
            patch.diffs.push([diff_type, diff_text]);
            bigpatch.diffs.shift();
          } else {
            // Deletion or equality.  Only take as much as we can stomach.
            diff_text = diff_text.substring(0, patch_size - patch.length1 -
                                               this.Patch_Margin);
            patch.length1 += diff_text.length;
            start1 += diff_text.length;
            if (diff_type === DIFF_EQUAL) {
              patch.length2 += diff_text.length;
              start2 += diff_text.length;
            } else {
              empty = false;
            }
            patch.diffs.push([diff_type, diff_text]);
            if (diff_text == bigpatch.diffs[0][1]) {
              bigpatch.diffs.shift();
            } else {
              bigpatch.diffs[0][1] =
                  bigpatch.diffs[0][1].substring(diff_text.length);
            }
          }
        }
        // Compute the head context for the next patch.
        precontext = this.diff_text2(patch.diffs);
        precontext =
            precontext.substring(precontext.length - this.Patch_Margin);
        // Append the end context for this patch.
        var postcontext = this.diff_text1(bigpatch.diffs)
                              .substring(0, this.Patch_Margin);
        if (postcontext !== '') {
          patch.length1 += postcontext.length;
          patch.length2 += postcontext.length;
          if (patch.diffs.length !== 0 &&
              patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {
            patch.diffs[patch.diffs.length - 1][1] += postcontext;
          } else {
            patch.diffs.push([DIFF_EQUAL, postcontext]);
          }
        }
        if (!empty) {
          patches.splice(++x, 0, patch);
        }
      }
    }
  }
};


/**
 * Take a list of patches and return a textual representation.
 * @param {Array.<patch_obj>} patches Array of patch objects.
 * @return {string} Text representation of patches.
 */
diff_match_patch.prototype.patch_toText = function(patches) {
  var text = [];
  for (var x = 0; x < patches.length; x++) {
    text[x] = patches[x];
  }
  return text.join('');
};


/**
 * Parse a textual representation of patches and return a list of patch objects.
 * @param {string} textline Text representation of patches.
 * @return {Array.<patch_obj>} Array of patch objects.
 * @throws {Error} If invalid input.
 */
diff_match_patch.prototype.patch_fromText = function(textline) {
  var patches = [];
  if (!textline) {
    return patches;
  }
  // Opera doesn't know how to decode char 0.
  textline = textline.replace(/%00/g, '\0');
  var text = textline.split('\n');
  var textPointer = 0;
  while (textPointer < text.length) {
    var m = text[textPointer].match(/^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/);
    if (!m) {
      throw new Error('Invalid patch string: ' + text[textPointer]);
    }
    var patch = new patch_obj();
    patches.push(patch);
    patch.start1 = parseInt(m[1], 10);
    if (m[2] === '') {
      patch.start1--;
      patch.length1 = 1;
    } else if (m[2] == '0') {
      patch.length1 = 0;
    } else {
      patch.start1--;
      patch.length1 = parseInt(m[2], 10);
    }

    patch.start2 = parseInt(m[3], 10);
    if (m[4] === '') {
      patch.start2--;
      patch.length2 = 1;
    } else if (m[4] == '0') {
      patch.length2 = 0;
    } else {
      patch.start2--;
      patch.length2 = parseInt(m[4], 10);
    }
    textPointer++;

    while (textPointer < text.length) {
      var sign = text[textPointer].charAt(0);
      try {
        var line = decodeURI(text[textPointer].substring(1));
      } catch (ex) {
        // Malformed URI sequence.
        throw new Error('Illegal escape in patch_fromText: ' + line);
      }
      if (sign == '-') {
        // Deletion.
        patch.diffs.push([DIFF_DELETE, line]);
      } else if (sign == '+') {
        // Insertion.
        patch.diffs.push([DIFF_INSERT, line]);
      } else if (sign == ' ') {
        // Minor equality.
        patch.diffs.push([DIFF_EQUAL, line]);
      } else if (sign == '@') {
        // Start of next patch.
        break;
      } else if (sign === '') {
        // Blank line?  Whatever.
      } else {
        // WTF?
        throw new Error('Invalid patch mode "' + sign + '" in: ' + line);
      }
      textPointer++;
    }
  }
  return patches;
};


/**
 * Class representing one patch operation.
 * @constructor
 */
function patch_obj() {
  /** @type {Array.<Array.<number|string>>} */
  this.diffs = [];
  /** @type {?number} */
  this.start1 = null;
  /** @type {?number} */
  this.start2 = null;
  /** @type {number} */
  this.length1 = 0;
  /** @type {number} */
  this.length2 = 0;
}


/**
 * Emmulate GNU diff's format.
 * Header: @@ -382,8 +481,9 @@
 * Indicies are printed as 1-based, not 0-based.
 * @return {string} The GNU diff string.
 */
patch_obj.prototype.toString = function() {
  var coords1, coords2;
  if (this.length1 === 0) {
    coords1 = this.start1 + ',0';
  } else if (this.length1 == 1) {
    coords1 = this.start1 + 1;
  } else {
    coords1 = (this.start1 + 1) + ',' + this.length1;
  }
  if (this.length2 === 0) {
    coords2 = this.start2 + ',0';
  } else if (this.length2 == 1) {
    coords2 = this.start2 + 1;
  } else {
    coords2 = (this.start2 + 1) + ',' + this.length2;
  }
  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\n'];
  var op;
  // Escape the body of the patch with %xx notation.
  for (var x = 0; x < this.diffs.length; x++) {
    switch (this.diffs[x][0]) {
      case DIFF_INSERT:
        op = '+';
        break;
      case DIFF_DELETE:
        op = '-';
        break;
      case DIFF_EQUAL:
        op = ' ';
        break;
    }
    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\n';
  }
  // Opera doesn't know how to encode char 0.
  return text.join('').replace(/\x00/g, '%00').replace(/%20/g, ' ');
};


// Export these global variables so that they survive Google's JS compiler.
/*changed by lfborjas: changed `window` for `exports` to make it suitable for the node.js module conventions*/
exports.diff_match_patch = diff_match_patch;
exports.patch_obj = patch_obj;
exports.DIFF_DELETE = DIFF_DELETE;
exports.DIFF_INSERT = DIFF_INSERT;
exports.DIFF_EQUAL = DIFF_EQUAL;


/***/ }),

/***/ "./example/client/index.ts":
/*!*********************************!*\
  !*** ./example/client/index.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const changesets_1 = __webpack_require__(/*! changesets */ "./node_modules/changesets/lib/index.js");
const editor_1 = __importDefault(__webpack_require__(/*! structured-text-editor/src/editor */ "../structured-text-editor/src/editor.js"));
const index_1 = __importDefault(__webpack_require__(/*! ../../src/browser_sdk/index */ "./src/browser_sdk/index.ts"));
const long_text_change_1 = __importDefault(__webpack_require__(/*! ../../src/attributes/long_text/long_text_change */ "./src/attributes/long_text/long_text_change.ts"));
const key_value_change_1 = __importDefault(__webpack_require__(/*! ../../src/attributes/key_value/key_value_change */ "./src/attributes/key_value/key_value_change.ts"));
document.addEventListener('DOMContentLoaded', (event) => __awaiter(void 0, void 0, void 0, function* () {
    const editor = new editor_1.default('value');
    const linkedRecords = new index_1.default(new URL('http://10.60.3.218:3000'));
    // const content = await linkedRecords.Attribute.create('longText', 'inital');
    // console.log('New ContentId', content.id);
    // const contentId = content.id;
    const contentId = 'l-39d5ab07-b571-4d3b-abf0-2a5974fe41df';
    let { content: contentAttribute, refernces: [referencesAttribute] } = yield linkedRecords.Attribute.findAll({
        content: contentId,
        refernces: [
            ['isA', 'referenceStore'],
            ['belongsTo', contentId],
        ],
        referenceSources: [
            ['isA', 'referenceSourceStore'],
            ['belongsTo', contentId],
            ['belongsTo', 'usr-xx'],
        ]
    });
    if (!referencesAttribute) {
        referencesAttribute = (yield linkedRecords.Attribute.create('keyValue', {}));
        yield linkedRecords.Fact.createAll([
            [referencesAttribute.id, 'isA', 'referenceStore'],
            [referencesAttribute.id, 'belongsTo', contentId]
        ]);
    }
    editor.setContent(yield contentAttribute.getValue());
    editor.addReferenceData(yield referencesAttribute.getValue());
    referencesAttribute.subscribe((changeset) => __awaiter(void 0, void 0, void 0, function* () {
        const newData = {};
        changeset.change.forEach(({ key, value }) => {
            newData[key] = value;
        });
        editor.addReferenceData(newData);
    }));
    editor.subscribeReferenceInsertion((key, value) => __awaiter(void 0, void 0, void 0, function* () {
        referencesAttribute.change(new key_value_change_1.default([{ key, value }]));
    }));
    contentAttribute.subscribe((changeset, changeInfo) => __awaiter(void 0, void 0, void 0, function* () {
        const attr = { actor: { id: changeInfo.actorId } };
        try {
            editor.applyChangeset(changeset.changeset, attr);
        }
        catch (ex) {
            console.log('failed to apply changeset to EDITOR content. Falling back to replace the whole editors content', ex);
            editor.setContent(yield contentAttribute.getValue(), attr);
        }
    }));
    editor.subscribe((modificationLog) => __awaiter(void 0, void 0, void 0, function* () {
        if (!modificationLog.actor) {
            try {
                yield contentAttribute.change(new long_text_change_1.default(modificationLog.toChangeset(changesets_1.Changeset)));
            }
            catch (ex) {
                console.log('failed to apply changeset to ATTRIBUTE. Falling back to replace whole attribute content', ex);
                yield contentAttribute.set(editor.getOriginalContent());
            }
        }
    }));
}));


/***/ }),

/***/ "./lib/server-side-events/client/index.ts":
/*!************************************************!*\
  !*** ./lib/server-side-events/client/index.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
class ServerSideEvents {
    constructor() {
        this.subscriptions = {};
        this.connetions = {};
        this.isPaused = false;
        this.messagesWhilePaused = [];
        this.tabId = (Math.random() + 1).toString(36).substring(7);
    }
    getEventSourceAsync(url) {
        if (!url.searchParams.has('tabId')) {
            url.searchParams.append('tabId', this.tabId);
        }
        return new Promise((resolve, reject) => {
            const source = new EventSource(url.toString());
            source.onerror = reject;
            source.onopen = () => resolve(source);
        });
    }
    subscribe(url, channel, handler) {
        return __awaiter(this, void 0, void 0, function* () {
            const parsedUrl = new URL(url);
            const subId = `${parsedUrl.origin}-${channel}`;
            if (!parsedUrl.searchParams.has('tabId')) {
                parsedUrl.searchParams.append('tabId', this.tabId);
            }
            yield this.ensureConnection(parsedUrl.origin);
            yield fetch(parsedUrl.toString());
            this.subscriptions[subId] = this.subscriptions[subId] || [];
            this.subscriptions[subId].push(handler);
        });
    }
    unsubscribeAll() {
        Object.values(this.connetions).forEach((connection) => {
            connection.close();
        });
        this.connetions = {};
    }
    pauseNotification() {
        this.isPaused = true;
    }
    unpauseNotification() {
        this.messagesWhilePaused.forEach(({ cb, data }) => {
            cb(data);
        });
        this.messagesWhilePaused = [];
    }
    ensureConnection(origin) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = new URL(origin);
            url.pathname = '/server-sent-events';
            if (!this.connetions[url.origin]) {
                try {
                    this.connetions[url.origin] = yield this.getEventSourceAsync(url);
                }
                catch (ex) {
                    this.connetions[url.origin] = yield this.getEventSourceAsync(url);
                }
                this.connetions[url.origin].onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    const { sseChannel } = data;
                    if (!sseChannel) {
                        return;
                    }
                    delete data.sseChannel;
                    const subscriptions = this.subscriptions[`${url.origin}-${sseChannel}`];
                    if (subscriptions) {
                        subscriptions.forEach((cb) => {
                            if (this.isPaused) {
                                this.messagesWhilePaused.push({ cb, data });
                            }
                            else {
                                cb(data);
                            }
                        });
                    }
                };
            }
            return this.connetions[origin];
        });
    }
}
exports["default"] = ServerSideEvents;


/***/ }),

/***/ "./src/attributes/abstract/abstract_attribute_client.ts":
/*!**************************************************************!*\
  !*** ./src/attributes/abstract/abstract_attribute_client.ts ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* eslint-disable import/no-cycle */
/* eslint-disable class-methods-use-this */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const uuid_1 = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/index.js");
class AbstractAttributeClient {
    constructor(linkedRecords, serverSideEvents, id) {
        this.id = id;
        this.linkedRecords = linkedRecords;
        this.serverSideEvents = serverSideEvents;
        this.serverURL = linkedRecords.serverURL;
        this.observers = [];
        // because the same user can be logged on two browsers/laptops, we need
        // a clientId and an actorId
        this.clientId = linkedRecords.clientId;
        this.actorId = linkedRecords.actorId;
        this.version = '0';
        this.value = this.getDefaultValue();
        this.isInitialized = false;
    }
    static getDataTypeName() {
        throw new Error('getDataTypeName needs to be implemented in child class');
    }
    static isAttributeId(id) {
        return id.split('-')[0] === this.prototype.getDataTypePrefix();
    }
    create(value) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.id) {
                throw new Error(`Cannot create attribute because it has an id assigned (${this.id})`);
            }
            this.id = `${this.getDataTypePrefix()}-${(0, uuid_1.v4)()}`;
            const response = yield this.withConnectionLostHandler(() => fetch(`${this.linkedRecords.serverURL}attributes/${this.id}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    clientId: this.clientId,
                    actorId: this.actorId,
                    value,
                }),
            }));
            if (!response) {
                throw new Error('Error communicating with the server when creating attribute.');
            }
            if (response.status === 401) {
                this.handleExpiredLoginSession();
                return;
            }
            if (response.status !== 200) {
                throw new Error(`Error creating attribute: ${yield response.text()}`);
            }
            const responseBody = yield response.json();
            yield this.load(responseBody);
        });
    }
    get() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.load();
            return {
                value: this.value,
                changeId: this.version,
                actorId: this.actorId,
            };
        });
    }
    getValue() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.load();
            return this.value;
        });
    }
    set(newValue) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.load();
            if (newValue === this.value) {
                return;
            }
            yield this.rawSet(newValue);
        });
    }
    change(change) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.load();
            yield this.rawChange(change);
        });
    }
    subscribe(observer) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.load();
            this.observers.push(observer);
        });
    }
    handleExpiredLoginSession() {
        const win = window;
        win.location = '/login';
    }
    handleConnectionError(error) {
        console.log('Connection Lost', error);
    }
    withConnectionLostHandler(fn) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield fn();
            }
            catch (ex) {
                if (ex.message === 'Failed to fetch') {
                    this.handleConnectionError(ex);
                }
                return false;
            }
        });
    }
    load(serverState) {
        return __awaiter(this, void 0, void 0, function* () {
            let result = serverState;
            if (this.isInitialized) {
                return;
            }
            if (!this.id) {
                throw new Error('cannot load an attribute without id');
            }
            this.isInitialized = true;
            if (!result) {
                const url = `${this.serverURL}attributes/${this.id}?clientId=${this.clientId}&actorId=${this.actorId}`;
                const response = yield this.withConnectionLostHandler(() => fetch(url));
                if (response.status === 401) {
                    this.handleExpiredLoginSession();
                    return;
                }
                const jsonBody = yield response.json();
                result = {
                    changeId: jsonBody.changeId,
                    value: jsonBody.value,
                };
            }
            this.version = result.changeId;
            this.value = this.deserializeValue(typeof result.value === 'string' ? result.value : JSON.stringify(result.value));
            this.onLoad();
            this.notifySubscribers(undefined, undefined);
            const url = `${this.serverURL}attributes/${this.id}/changes?clientId=${this.clientId}&actorId=${this.actorId}`;
            yield this.serverSideEvents.subscribe(url, this.id, (parsedData) => {
                if (parsedData.attributeId !== this.id) {
                    return;
                }
                this.onServerMessage(parsedData);
            });
        });
    }
    sendToServer(change) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `${this.serverURL}attributes/${this.id}?clientId=${this.clientId}&actorId=${this.actorId}`;
            const response = yield this.withConnectionLostHandler(() => fetch(url, {
                method: 'PATCH',
                headers: {
                    Accept: 'application/json',
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(change.toJSON()),
            }));
            if (response.status === 401) {
                this.handleExpiredLoginSession();
            }
        });
    }
    notifySubscribers(change, fullChangeInfo) {
        this.observers.forEach((callback) => {
            callback(change, fullChangeInfo);
        });
    }
}
exports["default"] = AbstractAttributeClient;


/***/ }),

/***/ "./src/attributes/abstract/serialized_change_with_metadata.ts":
/*!********************************************************************!*\
  !*** ./src/attributes/abstract/serialized_change_with_metadata.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class SerializedChangeWithMetadata {
    constructor(attributeId, actorId, clientId, change) {
        this.attributeId = attributeId;
        this.actorId = actorId;
        this.clientId = clientId;
        this.change = change;
    }
    toJSON() {
        return {
            attributeId: this.attributeId,
            change: this.change.toJSON(),
            actorId: this.actorId,
            clientId: this.clientId,
        };
    }
}
exports["default"] = SerializedChangeWithMetadata;


/***/ }),

/***/ "./src/attributes/key_value/client/index.ts":
/*!**************************************************!*\
  !*** ./src/attributes/key_value/client/index.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* eslint-disable @typescript-eslint/no-empty-function */
/* eslint-disable import/no-cycle */
/* eslint-disable class-methods-use-this */
const abstract_attribute_client_1 = __importDefault(__webpack_require__(/*! ../../abstract/abstract_attribute_client */ "./src/attributes/abstract/abstract_attribute_client.ts"));
const serialized_change_with_metadata_1 = __importDefault(__webpack_require__(/*! ../../abstract/serialized_change_with_metadata */ "./src/attributes/abstract/serialized_change_with_metadata.ts"));
const key_value_change_1 = __importDefault(__webpack_require__(/*! ../key_value_change */ "./src/attributes/key_value/key_value_change.ts"));
class KeyValueAttribute extends abstract_attribute_client_1.default {
    static getDataTypePrefix() {
        return 'kv';
    }
    static getDataTypeName() {
        return 'keyValue';
    }
    getDataTypePrefix() {
        return KeyValueAttribute.getDataTypePrefix();
    }
    getDataTypeName() {
        return KeyValueAttribute.getDataTypeName();
    }
    getDefaultValue() {
        return {};
    }
    deserializeValue(serializedValue) {
        return JSON.parse(serializedValue);
    }
    rawSet(newValue) {
        return __awaiter(this, void 0, void 0, function* () {
            let changes = [];
            Object.entries(this.value).forEach(([key]) => {
                changes.push({ key, value: null });
            });
            Object.entries(newValue).forEach(([key, value]) => {
                changes = changes.filter((ch) => ch.key !== key);
                changes.push({ key, value });
            });
            this.change(new key_value_change_1.default(changes));
        });
    }
    rawChange(change) {
        return __awaiter(this, void 0, void 0, function* () {
            this.transmitChange(new key_value_change_1.default(change.change, this.version));
            this.value = change.apply(this.value);
        });
    }
    onLoad() {
    }
    onServerMessage(changeWithMetadata) {
        const change = new key_value_change_1.default(changeWithMetadata.change, changeWithMetadata.change.changeId);
        if (changeWithMetadata.clientId === this.clientId) {
            return;
        }
        this.value = change.apply(this.value);
        this.version = change.changeId;
        this.notifySubscribers(change, changeWithMetadata);
    }
    transmitChange(changeset) {
        if (!this.id) {
            throw new Error('change can not be transmitted because attribute does not has an id');
        }
        this.sendToServer(new serialized_change_with_metadata_1.default(this.id, this.actorId, this.clientId, changeset));
    }
}
exports["default"] = KeyValueAttribute;


/***/ }),

/***/ "./src/attributes/key_value/key_value_change.ts":
/*!******************************************************!*\
  !*** ./src/attributes/key_value/key_value_change.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class KeyValueChange {
    constructor(changeset, changeId) {
        this.changeId = changeId !== null && changeId !== void 0 ? changeId : 'uncommited';
        this.change = changeset;
    }
    static fromJSON(input, changeId) {
        return new KeyValueChange(input, changeId);
    }
    static fromString(input) {
        return new KeyValueChange(JSON.parse(input));
    }
    toString() {
        return JSON.stringify(this.change);
    }
    toJSON() {
        return this.change;
    }
    apply(input) {
        const result = JSON.parse(JSON.stringify(input));
        this.change.forEach((aChange) => {
            if (aChange.value === null) {
                delete result[aChange.key];
            }
            else {
                result[aChange.key] = aChange.value;
            }
        });
        return result;
    }
    merge(other) {
        let mergedChanges = [];
        this.change.forEach((ch) => {
            mergedChanges = mergedChanges.filter((x) => x.key !== ch.key);
            mergedChanges.push(ch);
        });
        other.change.forEach((ch) => {
            mergedChanges = mergedChanges.filter((x) => x.key !== ch.key);
            mergedChanges.push(ch);
        });
        return new KeyValueChange(mergedChanges);
    }
}
exports["default"] = KeyValueChange;


/***/ }),

/***/ "./src/attributes/long_text/client/buffer.ts":
/*!***************************************************!*\
  !*** ./src/attributes/long_text/client/buffer.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class ChangeBuffer {
    add(changeset) {
        this.value = this.value ? this.value.merge(changeset) : changeset;
    }
    // this function returns a transformed version of the foreignChange which
    // fits into the current client state. This is required because the client
    // could have some changes which has not been send to the server yet. So, the
    // server don't know about these changes and the changes comming from the server
    // would not fit into the client state.
    transformAgainst(foreignChange, changeInTransmission) {
        var _a, _b;
        if (!changeInTransmission) {
            return foreignChange;
        }
        this.inFlightOp = this.inFlightOp || changeInTransmission;
        const c2 = foreignChange.transformAgainst(this.inFlightOp, true);
        this.inFlightOp = (_a = this.inFlightOp) === null || _a === void 0 ? void 0 : _a.transformAgainst(foreignChange, false);
        if (!this.value)
            return c2;
        // instead of using a bridge we use c2 to transform the
        // foreignChange (change from server) into the client state.
        const c1 = c2.transformAgainst(this.value, true);
        // "Once we have this inferred operation, c2, we can use it
        // to transform the buffer (b) "down" one step"
        this.value = (_b = this.value) === null || _b === void 0 ? void 0 : _b.transformAgainst(c2, false);
        return c1;
    }
    clear() {
        this.value = undefined;
        this.inFlightOp = undefined;
    }
    getValue() {
        return this.value;
    }
}
exports["default"] = ChangeBuffer;


/***/ }),

/***/ "./src/attributes/long_text/client/index.ts":
/*!**************************************************!*\
  !*** ./src/attributes/long_text/client/index.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* eslint-disable import/no-cycle */
/* eslint-disable class-methods-use-this */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const abstract_attribute_client_1 = __importDefault(__webpack_require__(/*! ../../abstract/abstract_attribute_client */ "./src/attributes/abstract/abstract_attribute_client.ts"));
const serialized_change_with_metadata_1 = __importDefault(__webpack_require__(/*! ../../abstract/serialized_change_with_metadata */ "./src/attributes/abstract/serialized_change_with_metadata.ts"));
const long_text_change_1 = __importDefault(__webpack_require__(/*! ../long_text_change */ "./src/attributes/long_text/long_text_change.ts"));
const buffer_1 = __importDefault(__webpack_require__(/*! ./buffer */ "./src/attributes/long_text/client/buffer.ts"));
class LongTextAttribute extends abstract_attribute_client_1.default {
    constructor() {
        super(...arguments);
        this.buffer = new buffer_1.default();
        this.changeInTransmission = undefined;
    }
    static getDataTypePrefix() {
        return 'l';
    }
    static getDataTypeName() {
        return 'longText';
    }
    getDataTypePrefix() {
        return 'l';
    }
    getDataTypeName() {
        return LongTextAttribute.getDataTypeName();
    }
    getDefaultValue() {
        return '';
    }
    deserializeValue(serializedValue) {
        return serializedValue;
    }
    rawSet(newValue) {
        return __awaiter(this, void 0, void 0, function* () {
            const changeset = long_text_change_1.default.fromDiff(this.value, newValue);
            yield this.change(changeset);
        });
    }
    rawChange(changeset) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: Check for version is valid
            // if (this.version === '0') {
            //   throw Error('Cannot change attribute as attributed state is not loaded from server!');
            // }
            this.value = changeset.apply(this.value);
            if (this.changeInTransmission) {
                this.buffer.add(changeset);
            }
            else {
                this.transmitChange(new long_text_change_1.default(changeset.changeset, this.version));
            }
        });
    }
    onLoad() {
        this.buffer.clear();
    }
    onServerMessage(changeWithMetadata) {
        if (changeWithMetadata.clientId === this.clientId) {
            this.processApproval(changeWithMetadata);
        }
        else {
            this.processForeignChange(changeWithMetadata);
        }
    }
    processForeignChange(foreignChangeWithMetadata) {
        var _a;
        try {
            const foreignChangeset = long_text_change_1.default.fromString(foreignChangeWithMetadata.change.changeset);
            const transformedForeignChange = this.buffer.transformAgainst(foreignChangeset, (_a = this.changeInTransmission) === null || _a === void 0 ? void 0 : _a.change);
            this.value = transformedForeignChange.apply(this.value);
            this.version = foreignChangeWithMetadata.change.changeId;
            this.notifySubscribers(transformedForeignChange, foreignChangeWithMetadata);
        }
        catch (ex) {
            console.log('ERROR: processing foreign change failed (probably because of a previous message loss). Reload server state to recover.', ex);
            this.load();
        }
    }
    processApproval(approval) {
        const bufferedChanges = this.buffer.getValue();
        this.changeInTransmission = undefined;
        this.version = approval.change.changeId;
        this.buffer.clear();
        if (bufferedChanges) {
            this.transmitChange(new long_text_change_1.default(bufferedChanges.changeset, approval.change.changeId));
        }
    }
    transmitChange(changeset) {
        if (!this.id) {
            throw new Error('change can not be transmitted because attribute does not has an id');
        }
        this.changeInTransmission = new serialized_change_with_metadata_1.default(this.id, this.actorId, this.clientId, changeset);
        this.sendToServer(this.changeInTransmission);
    }
}
exports["default"] = LongTextAttribute;


/***/ }),

/***/ "./src/attributes/long_text/long_text_change.ts":
/*!******************************************************!*\
  !*** ./src/attributes/long_text/long_text_change.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const changesets_1 = __webpack_require__(/*! changesets */ "./node_modules/changesets/lib/index.js");
const diff_match_patch_1 = __webpack_require__(/*! diff_match_patch */ "./node_modules/diff_match_patch/lib/diff_match_patch.js");
const diffEngine = new diff_match_patch_1.diff_match_patch();
class LongTextChange {
    constructor(changeset, changeId) {
        this.changeset = changeset;
        this.changeId = changeId !== null && changeId !== void 0 ? changeId : 'uncommited';
    }
    static fromString(change) {
        return new LongTextChange(changesets_1.Changeset.unpack(change));
    }
    static fromDiff(a, b) {
        return new LongTextChange(changesets_1.Changeset.fromDiff(diffEngine.diff_main(a, b)));
    }
    apply(value) {
        return this.changeset.apply(value);
    }
    toString() {
        return typeof this.changeset === 'string'
            ? this.changeset
            : this.changeset.pack();
    }
    transformAgainst(change, side) {
        if (!change) {
            return this;
        }
        return new LongTextChange(this.changeset.transformAgainst(change.changeset, side));
    }
    merge(otherChange) {
        return new LongTextChange(this.changeset.merge(otherChange.changeset));
    }
    toJSON() {
        return {
            changeset: this.toString(),
            changeId: this.changeId,
        };
    }
}
exports["default"] = LongTextChange;


/***/ }),

/***/ "./src/browser_sdk/index.ts":
/*!**********************************!*\
  !*** ./src/browser_sdk/index.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* eslint-disable max-classes-per-file */
/* eslint-disable import/no-cycle */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const uuid_1 = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/index.js");
const client_1 = __importDefault(__webpack_require__(/*! ../attributes/long_text/client */ "./src/attributes/long_text/client/index.ts"));
const client_2 = __importDefault(__webpack_require__(/*! ../attributes/key_value/client */ "./src/attributes/key_value/client/index.ts"));
const client_3 = __importDefault(__webpack_require__(/*! ../../lib/server-side-events/client */ "./lib/server-side-events/client/index.ts"));
const client_4 = __importDefault(__webpack_require__(/*! ../facts/client */ "./src/facts/client/index.ts"));
class AttributesRepository {
    constructor(linkedRecords, serverSideEvents) {
        this.linkedRecords = linkedRecords;
        this.serverSideEvents = serverSideEvents;
    }
    create(attributeType, value) {
        return __awaiter(this, void 0, void 0, function* () {
            const AttributeClass = AttributesRepository
                .attributeTypes
                .find((c) => c.getDataTypeName() === attributeType);
            if (!AttributeClass) {
                throw new Error(`Attribute Type ${attributeType} is unknown`);
            }
            const attribute = new AttributeClass(this.linkedRecords, this.serverSideEvents);
            yield attribute.create(value);
            return attribute;
        });
    }
    find(attributeId) {
        return __awaiter(this, void 0, void 0, function* () {
            const [attributeTypePrefix] = attributeId.split('-');
            const AttributeClass = AttributesRepository
                .attributeTypes
                .find((c) => c.getDataTypePrefix() === attributeTypePrefix);
            if (!AttributeClass) {
                throw new Error(`Attribute ID ${attributeId} is unknown`);
            }
            const attribute = new AttributeClass(this.linkedRecords, this.serverSideEvents, attributeId);
            yield attribute.get();
            return attribute;
        });
    }
    findAll(query) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = {};
            const qEntries = Object.entries(query);
            const promises = [];
            for (let j = 0; j < qEntries.length; j += 1) {
                const qEntry = qEntries[j];
                if (qEntry) {
                    const n = qEntry[0];
                    const q = qEntry[1];
                    if (typeof q === 'string') {
                        promises.push(this.find(q).then((attribute) => {
                            result[n] = attribute;
                        }).catch(() => {
                            result[n] = null;
                        }));
                    }
                    else {
                        result[n] = [];
                        promises.push(this.linkedRecords.Fact.findAll({ subject: q }).then((facts) => {
                            var _a;
                            for (let i = 0; i < facts.length; i += 1) {
                                const subjectId = (_a = facts[i]) === null || _a === void 0 ? void 0 : _a.subject;
                                if (subjectId && !result[n].find((attr) => attr.id === subjectId)) {
                                    const AttributeClass = AttributesRepository.attributeTypes
                                        .find((at) => at.isAttributeId(subjectId));
                                    if (AttributeClass) {
                                        const attribute = new AttributeClass(this.linkedRecords, this.serverSideEvents, subjectId);
                                        result[n].push(attribute);
                                    }
                                }
                            }
                        }));
                    }
                }
            }
            yield Promise.all(promises);
            return result;
        });
    }
}
AttributesRepository.attributeTypes = [
    client_1.default,
    client_2.default,
];
class FactsRepository {
    constructor(linkedRecords) {
        this.linkedRecords = linkedRecords;
    }
    createAll(facts) {
        return __awaiter(this, void 0, void 0, function* () {
            const createdFacts = yield Promise.all(facts.map((attr) => this.create(attr[0], attr[1], attr[2])));
            return createdFacts;
        });
    }
    create(subjectId, predicateId, objectId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!subjectId) {
                throw Error('subjectId can not be null');
            }
            if (!objectId) {
                throw Error('objectId can not be null');
            }
            if (!predicateId) {
                throw Error('predicateId can not be null');
            }
            const fact = new client_4.default(this.linkedRecords, subjectId, predicateId, objectId);
            yield fact.save();
            return fact;
        });
    }
    deleteAll() {
        return __awaiter(this, void 0, void 0, function* () {
            yield fetch(`${this.linkedRecords.serverURL}facts`, {
                method: 'DELETE',
                headers: {
                    Accept: 'application/json',
                    'Content-Type': 'application/json',
                },
            });
        });
    }
    findAll({ subject, predicate, object }) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryURL = new URL(`${this.linkedRecords.serverURL}facts`);
            if (subject) {
                queryURL.searchParams.append('subject', JSON.stringify(subject));
            }
            if (predicate) {
                queryURL.searchParams.append('predicate', JSON.stringify(predicate));
            }
            if (object) {
                queryURL.searchParams.append('object', JSON.stringify(object));
            }
            const response = yield fetch(queryURL, {
                headers: {
                    Accept: 'application/json',
                    'Content-Type': 'application/json',
                },
            });
            const responseJson = yield response.json();
            return responseJson.map((record) => new client_4.default(this.linkedRecords, record.subject, record.predicate, record.object));
        });
    }
}
class LinkedRecords {
    constructor(serverURL, serverSideEvents) {
        this.serverURL = serverURL;
        this.actorId = (0, uuid_1.v4)();
        this.clientId = (0, uuid_1.v4)();
        this.serverSideEvents = serverSideEvents || new client_3.default();
        this.Attribute = new AttributesRepository(this, this.serverSideEvents);
        this.Fact = new FactsRepository(this);
    }
}
exports["default"] = LinkedRecords;


/***/ }),

/***/ "./src/facts/client/index.ts":
/*!***********************************!*\
  !*** ./src/facts/client/index.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
class Fact {
    constructor(linkedRecords, subject, predicate, object) {
        this.serverURL = linkedRecords.serverURL;
        this.subject = subject;
        this.predicate = predicate;
        this.object = object;
    }
    save() {
        return __awaiter(this, void 0, void 0, function* () {
            yield fetch(`${this.serverURL}facts`, {
                method: 'POST',
                headers: {
                    Accept: 'application/json',
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    subject: this.subject,
                    predicate: this.predicate,
                    object: this.object,
                }),
            });
        });
    }
}
exports["default"] = Fact;


/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NIL": () => (/* reexport safe */ _nil_js__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   "parse": () => (/* reexport safe */ _parse_js__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   "stringify": () => (/* reexport safe */ _stringify_js__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   "v1": () => (/* reexport safe */ _v1_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "v3": () => (/* reexport safe */ _v3_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   "v4": () => (/* reexport safe */ _v4_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   "v5": () => (/* reexport safe */ _v5_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   "validate": () => (/* reexport safe */ _validate_js__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   "version": () => (/* reexport safe */ _version_js__WEBPACK_IMPORTED_MODULE_5__["default"])
/* harmony export */ });
/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v1.js */ "./node_modules/uuid/dist/esm-browser/v1.js");
/* harmony import */ var _v3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./v3.js */ "./node_modules/uuid/dist/esm-browser/v3.js");
/* harmony import */ var _v4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./v4.js */ "./node_modules/uuid/dist/esm-browser/v4.js");
/* harmony import */ var _v5_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./v5.js */ "./node_modules/uuid/dist/esm-browser/v5.js");
/* harmony import */ var _nil_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./nil.js */ "./node_modules/uuid/dist/esm-browser/nil.js");
/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./version.js */ "./node_modules/uuid/dist/esm-browser/version.js");
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/esm-browser/validate.js");
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/esm-browser/stringify.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./parse.js */ "./node_modules/uuid/dist/esm-browser/parse.js");










/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/md5.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/md5.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 * Browser-compatible JavaScript MD5
 *
 * Modification of JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */
function md5(bytes) {
  if (typeof bytes === 'string') {
    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = new Uint8Array(msg.length);

    for (var i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }

  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
/*
 * Convert an array of little-endian words to an array of bytes
 */


function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = '0123456789abcdef';

  for (var i = 0; i < length32; i += 8) {
    var x = input[i >> 5] >>> i % 32 & 0xff;
    var hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
    output.push(hex);
  }

  return output;
}
/**
 * Calculate output length with padding and bit length
 */


function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */


function wordsToMd5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << len % 32;
  x[getOutputLength(len) - 1] = len;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;

  for (var i = 0; i < x.length; i += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }

  return [a, b, c, d];
}
/*
 * Convert an array bytes to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */


function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }

  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));

  for (var i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
  }

  return output;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */


function safeAdd(x, y) {
  var lsw = (x & 0xffff) + (y & 0xffff);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xffff;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */


function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
/*
 * These functions implement the four basic operations the algorithm uses.
 */


function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}

function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}

function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}

function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}

function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (md5);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/nil.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/nil.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ('00000000-0000-0000-0000-000000000000');

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/parse.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/parse.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/esm-browser/validate.js");


function parse(uuid) {
  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Invalid UUID');
  }

  var v;
  var arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parse);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/regex.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/regex.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/rng.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/rng.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ rng)
/* harmony export */ });
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/sha1.js":
/*!****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/sha1.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;

    case 1:
      return x ^ y ^ z;

    case 2:
      return x & y ^ x & z ^ y & z;

    case 3:
      return x ^ y ^ z;
  }
}

function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}

function sha1(bytes) {
  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

  if (typeof bytes === 'string') {
    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = [];

    for (var i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    // Convert Array-like to Array
    bytes = Array.prototype.slice.call(bytes);
  }

  bytes.push(0x80);
  var l = bytes.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);

  for (var _i = 0; _i < N; ++_i) {
    var arr = new Uint32Array(16);

    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
    }

    M[_i] = arr;
  }

  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

  for (var _i2 = 0; _i2 < N; ++_i2) {
    var W = new Uint32Array(80);

    for (var t = 0; t < 16; ++t) {
      W[t] = M[_i2][t];
    }

    for (var _t = 16; _t < 80; ++_t) {
      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }

    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];

    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }

    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }

  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sha1);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/stringify.js":
/*!*********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/stringify.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/esm-browser/validate.js");

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

var byteToHex = [];

for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v1.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v1.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ "./node_modules/uuid/dist/esm-browser/rng.js");
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/esm-browser/stringify.js");

 // **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;

var _clockseq; // Previous uuid creation time


var _lastMSecs = 0;
var _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || new Array(16);
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__["default"])();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  var msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__["default"])(b);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v1);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v3.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v3.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ "./node_modules/uuid/dist/esm-browser/v35.js");
/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./md5.js */ "./node_modules/uuid/dist/esm-browser/md5.js");


var v3 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__["default"])('v3', 0x30, _md5_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v3);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v35.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v35.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DNS": () => (/* binding */ DNS),
/* harmony export */   "URL": () => (/* binding */ URL),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/esm-browser/stringify.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ "./node_modules/uuid/dist/esm-browser/parse.js");



function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  var bytes = [];

  for (var i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

var DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
var URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__["default"])(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__["default"])(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v4.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v4.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ "./node_modules/uuid/dist/esm-browser/rng.js");
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/esm-browser/stringify.js");



function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__["default"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__["default"])(rnds);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v5.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v5.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ "./node_modules/uuid/dist/esm-browser/v35.js");
/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sha1.js */ "./node_modules/uuid/dist/esm-browser/sha1.js");


var v5 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__["default"])('v5', 0x50, _sha1_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v5);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/validate.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/validate.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ "./node_modules/uuid/dist/esm-browser/regex.js");


function validate(uuid) {
  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__["default"].test(uuid);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/version.js":
/*!*******************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/version.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/esm-browser/validate.js");


function version(uuid) {
  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.substr(14, 1), 16);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (version);

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./example/client/index.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBLDREQUE0RCxXQUFXO0FBQ3ZFOztBQUVBO0FBQ0EsMEVBQTBFLFVBQVU7QUFDcEYsVUFBVTtBQUNWLHNEQUFzRCxVQUFVO0FBQ2hFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0Esa0RBQWtEO0FBQ2xELEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw2RUFBNkUsV0FBVzs7QUFFeEY7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvQ0FBb0M7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7QUNqMkJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0EsWUFBWSwrQkFBK0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0EsWUFBWSwrQkFBK0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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WTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3Q1REQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFH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VDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUEsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtEQUFrRDs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLEdBQUc7QUFDSCxtQ0FBbUM7QUFDbkM7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7O0FBR0EsMEdBQTBHOztBQUUxRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLElBQXFDO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBLEtBQUs7O0FBRUw7QUFDQSw4QkFBOEI7QUFDOUIsb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsOENBQThDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7O0FBRTlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBOztBQUVBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw2Q0FBNkMsZUFBZTtBQUMzRixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2Q0FBNkMsZUFBZTtBQUM3RSxpQkFBaUIsZ0NBQWdDO0FBQ2pEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw2Q0FBNkMsZUFBZTtBQUMzRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSx1RUFBdUUsY0FBYztBQUNyRjtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtB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S0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLG9CQUFvQjtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsY0FBYyxvQkFBb0I7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxpR0FBaUcsNEJBQTRCOztBQUU3SDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFL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O0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQ0FBK0Msd0VBQXdFO0FBQ3ZIO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7Ozs7OztBQ3BPQSxXQUFXLG1CQUFPLENBQUMsa0VBQVM7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztB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QUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EseUNBQXlDOztBQUV6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFlBQVk7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBLHlDQUF5Qzs7QUFFekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FB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O0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQSxZQUFZLCtCQUErQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQSxZQUFZLCtCQUErQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Ozs7Ozs7Ozs7Ozs7QUN2QlU7QUFDRTtBQUM3QixTQUFTLG1EQUFHLGFBQWEsZ0RBQUk7QUFDN0IsaUVBQWUsRUFBRTs7Ozs7Ozs7Ozs7Ozs7OztBQ0hjOztBQUUvQjtBQUNBLHFDQUFxQyxzREFBVTtBQUMvQzs7QUFFQSxpRUFBZSxRQUFROzs7Ozs7Ozs7Ozs7Ozs7O0FDTmM7O0FBRXJDO0FBQ0EsT0FBTyx3REFBUTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpRUFBZSxPQUFPOzs7Ozs7VUNWdEI7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7Ozs7V0N0QkE7V0FDQTtXQUNBO1dBQ0E7V0FDQSx5Q0FBeUMsd0NBQXdDO1dBQ2pGO1dBQ0E7V0FDQTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEdBQUc7V0FDSDtXQUNBO1dBQ0EsQ0FBQzs7Ozs7V0NQRDs7Ozs7V0NBQTtXQUNBO1dBQ0E7V0FDQSx1REFBdUQsaUJBQWlCO1dBQ3hFO1dBQ0EsZ0RBQWdELGFBQWE7V0FDN0Q7Ozs7O1VFTkE7VUFDQTtVQUNBO1VBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3IvYXNzZXRzL2xhdGV4X2NoZWF0c2hlZXQuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL2xpYi9kZWNsYXJhdGl2X2Zvcm1zL3NyYy9kZWNsYXJhdGl2X2Zvcm0uanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL2xpYi9kZWNsYXJhdGl2X2Zvcm1zL3NyYy9kbF9zZWxlY3QuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL2xpYi9kb2N1bWVudHVwZGF0ZXIvZG9jdW1lbnR1cGRhdGVyLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9saWIvZG9jdW1lbnR1cGRhdGVyL21vZGlmaWNhdGlvbl9sb2cuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL2xpYi9nZW5lcmF0b3Jsb29rYWhlYWQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL2xpYi9odG1sX3Jhem9yL2h0bWxfcmF6b3IuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL2xpYi9odG1sX3Jhem9yL3N0YXRlX21hY2hpbmUuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL2xpYi9odG1sX3Jhem9yL3RhZ190cmFuc2Zvcm1hdGlvbi5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3IvbGliL2xvb2t1cF9yZWZzL2Vycm9ycy5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3IvbGliL2xvb2t1cF9yZWZzL2luZGV4LmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9saWIvbG9va3VwX3JlZnMvbG9va3VwX2J5X2FyeGl2LmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9saWIvbG9va3VwX3JlZnMvbG9va3VwX2J5X2RvaS5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3IvbGliL2xvb2t1cF9yZWZzL2xvb2t1cF9ieV9pc2JuLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9saWIvbG9va3VwX3JlZnMvbG9va3VwX2J5X3VybC5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3IvbGliL3BpeGVsc2NodWJzZXIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL2xpYi90aHJvdHRsZS90aHJvdHRsZS5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3IvbGliL3RvY19idWlsZGVyL3RvY19idWlsZGVyLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9saWIvem90ZXJvLWNsaWVudC9pbmRleC5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3IvbGliL3pvdGVyby1jbGllbnQvb25saW5lLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9jb250YWlucy5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Qm9yZGVycy5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDbGlwcGluZ1JlY3QuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENvbXBvc2l0ZVJlY3QuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERlY29yYXRpb25zLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50UmVjdC5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0SFRNTEVsZW1lbnRTY3JvbGwuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldExheW91dFJlY3QuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE5vZGVOYW1lLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXROb2RlU2Nyb2xsLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFBhcmVudE5vZGUuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFNjcm9sbFBhcmVudC5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Vmlld3BvcnRSZWN0LmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3cuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvd1Njcm9sbC5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93U2Nyb2xsQmFyWC5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaXNTY3JvbGxQYXJlbnQuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzVGFibGVFbGVtZW50LmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9saXN0U2Nyb2xsUGFyZW50cy5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9lbnVtcy5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvYXBwbHlTdHlsZXMuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2Fycm93LmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9jb21wdXRlU3R5bGVzLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9ldmVudExpc3RlbmVycy5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvZmxpcC5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvaGlkZS5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvb2Zmc2V0LmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9wb3BwZXJPZmZzZXRzLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9wcmV2ZW50T3ZlcmZsb3cuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvcG9wcGVyLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2NvbXB1dGVBdXRvUGxhY2VtZW50LmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2NvbXB1dGVPZmZzZXRzLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2RlYm91bmNlLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2V4cGFuZFRvSGFzaE1hcC5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9mb3JtYXQuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0QWx0QXhpcy5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEZyZXNoU2lkZU9iamVjdC5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0T3Bwb3NpdGVQbGFjZW1lbnQuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0VmFyaWF0aW9uLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21lcmdlQnlOYW1lLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21lcmdlUGFkZGluZ09iamVjdC5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9vcmRlck1vZGlmaWVycy5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9yZWN0VG9DbGllbnRSZWN0LmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3VuaXF1ZUJ5LmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3ZhbGlkYXRlTW9kaWZpZXJzLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3dpdGhpbi5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL2NoYW5nZXNldHMvbGliL0J1aWxkZXIuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9jaGFuZ2VzZXRzL2xpYi9DaGFuZ2VzZXQuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9jaGFuZ2VzZXRzL2xpYi9DaGFuZ2VzZXRUcmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9jaGFuZ2VzZXRzL2xpYi9PcGVyYXRvci5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL2NoYW5nZXNldHMvbGliL1RleHRUcmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9jaGFuZ2VzZXRzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL2NoYW5nZXNldHMvbGliL29wZXJhdGlvbnMvSW5zZXJ0LmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvY2hhbmdlc2V0cy9saWIvb3BlcmF0aW9ucy9SZXRhaW4uanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9jaGFuZ2VzZXRzL2xpYi9vcGVyYXRpb25zL1NraXAuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9kaWZmX21hdGNoX3BhdGNoL2xpYi9kaWZmX21hdGNoX3BhdGNoLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvcHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWxhdGV4LmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvcHJpc21qcy9wcmlzbS5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL3RpcHB5LmpzL2Rpc3QvdGlwcHkuZXNtLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvdXVpZC9saWIvYnl0ZXNUb1V1aWQuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy91dWlkL2xpYi9ybmctYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL3V1aWQvdjEuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL3NyYy9jYXJldC5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivc3JjL2VkaXRvci5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivc3JjL2tleV9wcmVzc19oYW5kbGVyLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9zcmMvcmVmZXJlbmNlcy9yZWZlcmVuY2VfY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivc3JjL3JlZmVyZW5jZXMvcmVmZXJlbmNlX3NvdXJjZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL3NyYy9yZWZlcmVuY2VzL3JlZmVyZW5jZV9zb3VyY2VzL3pvdGVyb19kZXNrdG9wLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9zcmMvcmVmZXJlbmNlcy9yZWZlcmVuY2Vfc291cmNlcy96b3Rlcm9fb25saW5lLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9zcmMvcmVmZXJlbmNlcy9yZWZlcmVuY2Vfc3RvcmUuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL3NyYy9zZWN0aW9uX3R5cGVfc2VsZWN0b3JfY29udHJvbC5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivc3JjL3NlY3Rpb25fdHlwZXMvYmlibGlvZ3JhcGhpZS9iaWJsaW9ncmFwaGllX3NlY3Rpb25fdHlwZS5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivc3JjL3NlY3Rpb25fdHlwZXMvYmxvY2txdW90ZS9ibG9ja3F1b3RlX3NlY3Rpb25fdHlwZS5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivc3JjL3NlY3Rpb25fdHlwZXMvY29kZS9jb2RlX3NlY3Rpb25fdHlwZS5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivc3JjL3NlY3Rpb25fdHlwZXMvZm9vdG5vdGVzL2Zvb3Rub3Rlc19zZWN0aW9uX3R5cGUuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL3NyYy9zZWN0aW9uX3R5cGVzL2Zvcm11bGEvZm9ybXVsYV9zZWN0aW9uX3R5cGUuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL3NyYy9zZWN0aW9uX3R5cGVzL2hlYWRpbmcvaGVhZGluZzEuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL3NyYy9zZWN0aW9uX3R5cGVzL2hlYWRpbmcvaGVhZGluZzIuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL3NyYy9zZWN0aW9uX3R5cGVzL2hlYWRpbmcvaGVhZGluZzMuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL3NyYy9zZWN0aW9uX3R5cGVzL2hlYWRpbmcvaGVhZGluZzQuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL3NyYy9zZWN0aW9uX3R5cGVzL2hlYWRpbmcvaGVhZGluZzUuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL3NyYy9zZWN0aW9uX3R5cGVzL2ltYWdlL2ltYWdlX3NlY3Rpb25fdHlwZS5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivc3JjL3NlY3Rpb25fdHlwZXMvbGlzdC9vcmRlcmVkX2xpc3Rfc2VjdGlvbl90eXBlLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9zcmMvc2VjdGlvbl90eXBlcy9saXN0L3Vub3JkZXJlZF9saXN0X3NlY3Rpb25fdHlwZS5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivc3JjL3NlY3Rpb25fdHlwZXMvbWVybWFpZC9tZXJtYWlkX3NlY3Rpb25fdHlwZS5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivc3JjL3NlY3Rpb25fdHlwZXMvcGFyYWdyYXBoL3BhcmFncmFwaF9zZWN0aW9uX3R5cGUuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL3NyYy9zZWN0aW9uX3R5cGVzL3NoYXJlZC9jb2RlMmRpYV9zZWN0aW9uX3R5cGUuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL3NyYy9zZWN0aW9uX3R5cGVzL3NoYXJlZC9zaGFyZWQuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL3NyYy9zZWN0aW9uX3R5cGVzL3RhYmxlL3RhYmxlX3NlY3Rpb25fdHlwZS5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivc3JjL3NlY3Rpb25fdHlwZXMvdG9jL3RvY19zZWN0aW9uX3R5cGUuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL3NyYy90ZXh0X2VucmljaG1lbnRfY29udHJvbC5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4vbm9kZV9tb2R1bGVzL2NoYW5nZXNldHMvbGliL0J1aWxkZXIuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uL25vZGVfbW9kdWxlcy9jaGFuZ2VzZXRzL2xpYi9DaGFuZ2VzZXQuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uL25vZGVfbW9kdWxlcy9jaGFuZ2VzZXRzL2xpYi9DaGFuZ2VzZXRUcmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uL25vZGVfbW9kdWxlcy9jaGFuZ2VzZXRzL2xpYi9PcGVyYXRvci5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4vbm9kZV9tb2R1bGVzL2NoYW5nZXNldHMvbGliL1RleHRUcmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uL25vZGVfbW9kdWxlcy9jaGFuZ2VzZXRzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4vbm9kZV9tb2R1bGVzL2NoYW5nZXNldHMvbGliL29wZXJhdGlvbnMvSW5zZXJ0LmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi9ub2RlX21vZHVsZXMvY2hhbmdlc2V0cy9saWIvb3BlcmF0aW9ucy9SZXRhaW4uanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uL25vZGVfbW9kdWxlcy9jaGFuZ2VzZXRzL2xpYi9vcGVyYXRpb25zL1NraXAuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uL25vZGVfbW9kdWxlcy9kaWZmX21hdGNoX3BhdGNoL2xpYi9kaWZmX21hdGNoX3BhdGNoLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi9leGFtcGxlL2NsaWVudC9pbmRleC50cyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4vbGliL3NlcnZlci1zaWRlLWV2ZW50cy9jbGllbnQvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uL3NyYy9hdHRyaWJ1dGVzL2Fic3RyYWN0L2Fic3RyYWN0X2F0dHJpYnV0ZV9jbGllbnQudHMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uL3NyYy9hdHRyaWJ1dGVzL2Fic3RyYWN0L3NlcmlhbGl6ZWRfY2hhbmdlX3dpdGhfbWV0YWRhdGEudHMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uL3NyYy9hdHRyaWJ1dGVzL2tleV92YWx1ZS9jbGllbnQvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uL3NyYy9hdHRyaWJ1dGVzL2tleV92YWx1ZS9rZXlfdmFsdWVfY2hhbmdlLnRzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi9zcmMvYXR0cmlidXRlcy9sb25nX3RleHQvY2xpZW50L2J1ZmZlci50cyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4vc3JjL2F0dHJpYnV0ZXMvbG9uZ190ZXh0L2NsaWVudC9pbmRleC50cyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4vc3JjL2F0dHJpYnV0ZXMvbG9uZ190ZXh0L2xvbmdfdGV4dF9jaGFuZ2UudHMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uL3NyYy9icm93c2VyX3Nkay9pbmRleC50cyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4vc3JjL2ZhY3RzL2NsaWVudC9pbmRleC50cyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9tZDUuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvbmlsLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3BhcnNlLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3JlZ2V4LmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3JuZy5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9zaGExLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3N0cmluZ2lmeS5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci92MS5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci92My5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci92MzUuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjQuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjUuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdmFsaWRhdGUuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdmVyc2lvbi5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvd2VicGFjay9iZWZvcmUtc3RhcnR1cCIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzL3dlYnBhY2svc3RhcnR1cCIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzL3dlYnBhY2svYWZ0ZXItc3RhcnR1cCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGBcbjxkaXYgY2xhc3M9XCJsYXRleC1lcS10b29sdGlwXCI+XG5Tb21lIEV4YW1wbGVzIHdoYXQgeW91IGNhbiBpbnNlcnQgaGVyZS4gWW91IGNhbiBzY3JvbGwgdGhlIGxpc3QgdG8gc2VlIG1vcmUuXG48dGFibGU+XG48dHI+XG48dGQ+XG4gIDxkaXYgY2xhc3M9XCJtYXJrdXBcIj5lPW1jXjI8L2Rpdj5cbjwvdGQ+XG48dGQ+XG4gIDxzcGFuIGNsYXNzPVwia2F0ZXgtZGlzcGxheVwiPjxzcGFuIGNsYXNzPVwia2F0ZXhcIj48c3BhbiBjbGFzcz1cImthdGV4LW1hdGhtbFwiPjxtYXRoIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiPjxzZW1hbnRpY3M+PG1yb3c+PG1pPmU8L21pPjxtbz49PC9tbz48bWk+bTwvbWk+PG1zdXA+PG1pPmM8L21pPjxtbj4yPC9tbj48L21zdXA+PC9tcm93Pjxhbm5vdGF0aW9uIGVuY29kaW5nPVwiYXBwbGljYXRpb24veC10ZXhcIj5lPW1jXjI8L2Fubm90YXRpb24+PC9zZW1hbnRpY3M+PC9tYXRoPjwvc3Bhbj48c3BhbiBjbGFzcz1cImthdGV4LWh0bWxcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48c3BhbiBjbGFzcz1cImJhc2VcIj48c3BhbiBjbGFzcz1cInN0cnV0XCIgc3R5bGU9XCJoZWlnaHQ6IDAuNDMwNTZlbTsgdmVydGljYWwtYWxpZ246IDBlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJtb3JkIG1hdGhkZWZhdWx0XCI+ZTwvc3Bhbj48c3BhbiBjbGFzcz1cIm1zcGFjZVwiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAwLjI3Nzc3OGVtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1yZWxcIj49PC9zcGFuPjxzcGFuIGNsYXNzPVwibXNwYWNlXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDAuMjc3Nzc4ZW07XCI+PC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cImJhc2VcIj48c3BhbiBjbGFzcz1cInN0cnV0XCIgc3R5bGU9XCJoZWlnaHQ6IDAuODY0MTA4ZW07IHZlcnRpY2FsLWFsaWduOiAwZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwibW9yZCBtYXRoZGVmYXVsdFwiPm08L3NwYW4+PHNwYW4gY2xhc3M9XCJtb3JkXCI+PHNwYW4gY2xhc3M9XCJtb3JkIG1hdGhkZWZhdWx0XCI+Yzwvc3Bhbj48c3BhbiBjbGFzcz1cIm1zdXBzdWJcIj48c3BhbiBjbGFzcz1cInZsaXN0LXRcIj48c3BhbiBjbGFzcz1cInZsaXN0LXJcIj48c3BhbiBjbGFzcz1cInZsaXN0XCIgc3R5bGU9XCJoZWlnaHQ6IDAuODY0MTA4ZW07XCI+PHNwYW4gY2xhc3M9XCJcIiBzdHlsZT1cInRvcDogLTMuMTEzZW07IG1hcmdpbi1yaWdodDogMC4wNWVtO1wiPjxzcGFuIGNsYXNzPVwicHN0cnV0XCIgc3R5bGU9XCJoZWlnaHQ6IDIuN2VtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cInNpemluZyByZXNldC1zaXplNiBzaXplMyBtdGlnaHRcIj48c3BhbiBjbGFzcz1cIm1vcmQgbXRpZ2h0XCI+Mjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPlxuPC90ZD5cbjwvdHI+XG48dHI+XG48dGQ+XG4gIDxkaXYgY2xhc3M9XCJtYXJrdXBcIj55ID0gXFxcXGZyYWN7MnheMn17OHh9PC9kaXY+XG48L3RkPlxuPHRkPlxuICA8c3BhbiBjbGFzcz1cImthdGV4LWRpc3BsYXlcIj48c3BhbiBjbGFzcz1cImthdGV4XCI+PHNwYW4gY2xhc3M9XCJrYXRleC1tYXRobWxcIj48bWF0aCB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIj48c2VtYW50aWNzPjxtcm93PjxtaT55PC9taT48bW8+PTwvbW8+PG1mcmFjPjxtcm93Pjxtbj4yPC9tbj48bXN1cD48bWk+eDwvbWk+PG1uPjI8L21uPjwvbXN1cD48L21yb3c+PG1yb3c+PG1uPjg8L21uPjxtaT54PC9taT48L21yb3c+PC9tZnJhYz48L21yb3c+PGFubm90YXRpb24gZW5jb2Rpbmc9XCJhcHBsaWNhdGlvbi94LXRleFwiPnkgPSBcXFxcZnJhY3syeF4yfXs4eH08L2Fubm90YXRpb24+PC9zZW1hbnRpY3M+PC9tYXRoPjwvc3Bhbj48c3BhbiBjbGFzcz1cImthdGV4LWh0bWxcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48c3BhbiBjbGFzcz1cImJhc2VcIj48c3BhbiBjbGFzcz1cInN0cnV0XCIgc3R5bGU9XCJoZWlnaHQ6IDAuNjI1ZW07IHZlcnRpY2FsLWFsaWduOiAtMC4xOTQ0NGVtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1vcmQgbWF0aGRlZmF1bHRcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMC4wMzU4OGVtO1wiPnk8L3NwYW4+PHNwYW4gY2xhc3M9XCJtc3BhY2VcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMC4yNzc3NzhlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJtcmVsXCI+PTwvc3Bhbj48c3BhbiBjbGFzcz1cIm1zcGFjZVwiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAwLjI3Nzc3OGVtO1wiPjwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJiYXNlXCI+PHNwYW4gY2xhc3M9XCJzdHJ1dFwiIHN0eWxlPVwiaGVpZ2h0OiAyLjE3NzExZW07IHZlcnRpY2FsLWFsaWduOiAtMC42ODZlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJtb3JkXCI+PHNwYW4gY2xhc3M9XCJtb3BlbiBudWxsZGVsaW1pdGVyXCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwibWZyYWNcIj48c3BhbiBjbGFzcz1cInZsaXN0LXQgdmxpc3QtdDJcIj48c3BhbiBjbGFzcz1cInZsaXN0LXJcIj48c3BhbiBjbGFzcz1cInZsaXN0XCIgc3R5bGU9XCJoZWlnaHQ6IDEuNDkxMTFlbTtcIj48c3BhbiBjbGFzcz1cIlwiIHN0eWxlPVwidG9wOiAtMi4zMTRlbTtcIj48c3BhbiBjbGFzcz1cInBzdHJ1dFwiIHN0eWxlPVwiaGVpZ2h0OiAzZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwibW9yZFwiPjxzcGFuIGNsYXNzPVwibW9yZFwiPjg8L3NwYW4+PHNwYW4gY2xhc3M9XCJtb3JkIG1hdGhkZWZhdWx0XCI+eDwvc3Bhbj48L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwiXCIgc3R5bGU9XCJ0b3A6IC0zLjIzZW07XCI+PHNwYW4gY2xhc3M9XCJwc3RydXRcIiBzdHlsZT1cImhlaWdodDogM2VtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cImZyYWMtbGluZVwiIHN0eWxlPVwiYm9yZGVyLWJvdHRvbS13aWR0aDogMC4wNGVtO1wiPjwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJcIiBzdHlsZT1cInRvcDogLTMuNjc3ZW07XCI+PHNwYW4gY2xhc3M9XCJwc3RydXRcIiBzdHlsZT1cImhlaWdodDogM2VtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1vcmRcIj48c3BhbiBjbGFzcz1cIm1vcmRcIj4yPC9zcGFuPjxzcGFuIGNsYXNzPVwibW9yZFwiPjxzcGFuIGNsYXNzPVwibW9yZCBtYXRoZGVmYXVsdFwiPng8L3NwYW4+PHNwYW4gY2xhc3M9XCJtc3Vwc3ViXCI+PHNwYW4gY2xhc3M9XCJ2bGlzdC10XCI+PHNwYW4gY2xhc3M9XCJ2bGlzdC1yXCI+PHNwYW4gY2xhc3M9XCJ2bGlzdFwiIHN0eWxlPVwiaGVpZ2h0OiAwLjgxNDEwOGVtO1wiPjxzcGFuIGNsYXNzPVwiXCIgc3R5bGU9XCJ0b3A6IC0zLjA2M2VtOyBtYXJnaW4tcmlnaHQ6IDAuMDVlbTtcIj48c3BhbiBjbGFzcz1cInBzdHJ1dFwiIHN0eWxlPVwiaGVpZ2h0OiAyLjdlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJzaXppbmcgcmVzZXQtc2l6ZTYgc2l6ZTMgbXRpZ2h0XCI+PHNwYW4gY2xhc3M9XCJtb3JkIG10aWdodFwiPjI8L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwidmxpc3Qtc1wiPuKAizwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJ2bGlzdC1yXCI+PHNwYW4gY2xhc3M9XCJ2bGlzdFwiIHN0eWxlPVwiaGVpZ2h0OiAwLjY4NmVtO1wiPjxzcGFuIGNsYXNzPVwiXCI+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1jbG9zZSBudWxsZGVsaW1pdGVyXCI+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+XG48L3RkPlxuPC90cj5cbjx0cj5cbjx0ZD5cbiAgPGRpdiBjbGFzcz1cIm1hcmt1cFwiPlxcXFxpbnRee2ErMX1fe2EtMX08L2Rpdj5cbjwvdGQ+XG48dGQ+XG4gIDxzcGFuIGNsYXNzPVwia2F0ZXgtZGlzcGxheVwiPjxzcGFuIGNsYXNzPVwia2F0ZXhcIj48c3BhbiBjbGFzcz1cImthdGV4LW1hdGhtbFwiPjxtYXRoIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiPjxzZW1hbnRpY3M+PG1yb3c+PG1zdWJzdXA+PG1vPuKIqzwvbW8+PG1yb3c+PG1pPmE8L21pPjxtbz7iiJI8L21vPjxtbj4xPC9tbj48L21yb3c+PG1yb3c+PG1pPmE8L21pPjxtbz4rPC9tbz48bW4+MTwvbW4+PC9tcm93PjwvbXN1YnN1cD48L21yb3c+PGFubm90YXRpb24gZW5jb2Rpbmc9XCJhcHBsaWNhdGlvbi94LXRleFwiPlxcXFxpbnRee2ErMX1fe2EtMX08L2Fubm90YXRpb24+PC9zZW1hbnRpY3M+PC9tYXRoPjwvc3Bhbj48c3BhbiBjbGFzcz1cImthdGV4LWh0bWxcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48c3BhbiBjbGFzcz1cImJhc2VcIj48c3BhbiBjbGFzcz1cInN0cnV0XCIgc3R5bGU9XCJoZWlnaHQ6IDIuNTM0MjllbTsgdmVydGljYWwtYWxpZ246IC0wLjk3MDI4MWVtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1vcFwiPjxzcGFuIGNsYXNzPVwibW9wIG9wLXN5bWJvbCBsYXJnZS1vcFwiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAwLjQ0NDQ1ZW07IHBvc2l0aW9uOiByZWxhdGl2ZTsgdG9wOiAtMC4wMDExMjVlbTtcIj7iiKs8L3NwYW4+PHNwYW4gY2xhc3M9XCJtc3Vwc3ViXCI+PHNwYW4gY2xhc3M9XCJ2bGlzdC10IHZsaXN0LXQyXCI+PHNwYW4gY2xhc3M9XCJ2bGlzdC1yXCI+PHNwYW4gY2xhc3M9XCJ2bGlzdFwiIHN0eWxlPVwiaGVpZ2h0OiAxLjU2NDAxZW07XCI+PHNwYW4gY2xhc3M9XCJcIiBzdHlsZT1cInRvcDogLTEuNzg4MDVlbTsgbWFyZ2luLWxlZnQ6IC0wLjQ0NDQ1ZW07IG1hcmdpbi1yaWdodDogMC4wNWVtO1wiPjxzcGFuIGNsYXNzPVwicHN0cnV0XCIgc3R5bGU9XCJoZWlnaHQ6IDIuN2VtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cInNpemluZyByZXNldC1zaXplNiBzaXplMyBtdGlnaHRcIj48c3BhbiBjbGFzcz1cIm1vcmQgbXRpZ2h0XCI+PHNwYW4gY2xhc3M9XCJtb3JkIG1hdGhkZWZhdWx0IG10aWdodFwiPmE8L3NwYW4+PHNwYW4gY2xhc3M9XCJtYmluIG10aWdodFwiPuKIkjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1vcmQgbXRpZ2h0XCI+MTwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cIlwiIHN0eWxlPVwidG9wOiAtMy44MTI5ZW07IG1hcmdpbi1yaWdodDogMC4wNWVtO1wiPjxzcGFuIGNsYXNzPVwicHN0cnV0XCIgc3R5bGU9XCJoZWlnaHQ6IDIuN2VtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cInNpemluZyByZXNldC1zaXplNiBzaXplMyBtdGlnaHRcIj48c3BhbiBjbGFzcz1cIm1vcmQgbXRpZ2h0XCI+PHNwYW4gY2xhc3M9XCJtb3JkIG1hdGhkZWZhdWx0IG10aWdodFwiPmE8L3NwYW4+PHNwYW4gY2xhc3M9XCJtYmluIG10aWdodFwiPis8L3NwYW4+PHNwYW4gY2xhc3M9XCJtb3JkIG10aWdodFwiPjE8L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwidmxpc3Qtc1wiPuKAizwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJ2bGlzdC1yXCI+PHNwYW4gY2xhc3M9XCJ2bGlzdFwiIHN0eWxlPVwiaGVpZ2h0OiAwLjk3MDI4MWVtO1wiPjxzcGFuIGNsYXNzPVwiXCI+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPlxuPC90ZD5cbjwvdHI+XG48dHI+XG48dGQ+XG4gIDxkaXYgY2xhc3M9XCJtYXJrdXBcIj5cXFxcc3VtX3tpPTF9Xm4gYV9pPC9kaXY+XG48L3RkPlxuPHRkPlxuICA8c3BhbiBjbGFzcz1cImthdGV4LWRpc3BsYXlcIj48c3BhbiBjbGFzcz1cImthdGV4XCI+PHNwYW4gY2xhc3M9XCJrYXRleC1tYXRobWxcIj48bWF0aCB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIj48c2VtYW50aWNzPjxtcm93PjxtdW5kZXJvdmVyPjxtbz7iiJE8L21vPjxtcm93PjxtaT5pPC9taT48bW8+PTwvbW8+PG1uPjE8L21uPjwvbXJvdz48bWk+bjwvbWk+PC9tdW5kZXJvdmVyPjxtc3ViPjxtaT5hPC9taT48bWk+aTwvbWk+PC9tc3ViPjwvbXJvdz48YW5ub3RhdGlvbiBlbmNvZGluZz1cImFwcGxpY2F0aW9uL3gtdGV4XCI+XFxcXHN1bV97aT0xfV5uIGFfaTwvYW5ub3RhdGlvbj48L3NlbWFudGljcz48L21hdGg+PC9zcGFuPjxzcGFuIGNsYXNzPVwia2F0ZXgtaHRtbFwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjxzcGFuIGNsYXNzPVwiYmFzZVwiPjxzcGFuIGNsYXNzPVwic3RydXRcIiBzdHlsZT1cImhlaWdodDogMi45MjkwN2VtOyB2ZXJ0aWNhbC1hbGlnbjogLTEuMjc3NjdlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJtb3Agb3AtbGltaXRzXCI+PHNwYW4gY2xhc3M9XCJ2bGlzdC10IHZsaXN0LXQyXCI+PHNwYW4gY2xhc3M9XCJ2bGlzdC1yXCI+PHNwYW4gY2xhc3M9XCJ2bGlzdFwiIHN0eWxlPVwiaGVpZ2h0OiAxLjY1MTRlbTtcIj48c3BhbiBjbGFzcz1cIlwiIHN0eWxlPVwidG9wOiAtMS44NzIzM2VtOyBtYXJnaW4tbGVmdDogMGVtO1wiPjxzcGFuIGNsYXNzPVwicHN0cnV0XCIgc3R5bGU9XCJoZWlnaHQ6IDMuMDVlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJzaXppbmcgcmVzZXQtc2l6ZTYgc2l6ZTMgbXRpZ2h0XCI+PHNwYW4gY2xhc3M9XCJtb3JkIG10aWdodFwiPjxzcGFuIGNsYXNzPVwibW9yZCBtYXRoZGVmYXVsdCBtdGlnaHRcIj5pPC9zcGFuPjxzcGFuIGNsYXNzPVwibXJlbCBtdGlnaHRcIj49PC9zcGFuPjxzcGFuIGNsYXNzPVwibW9yZCBtdGlnaHRcIj4xPC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwiXCIgc3R5bGU9XCJ0b3A6IC0zLjA1MDAxZW07XCI+PHNwYW4gY2xhc3M9XCJwc3RydXRcIiBzdHlsZT1cImhlaWdodDogMy4wNWVtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cIlwiPjxzcGFuIGNsYXNzPVwibW9wIG9wLXN5bWJvbCBsYXJnZS1vcFwiPuKIkTwvc3Bhbj48L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwiXCIgc3R5bGU9XCJ0b3A6IC00LjMwMDAxZW07IG1hcmdpbi1sZWZ0OiAwZW07XCI+PHNwYW4gY2xhc3M9XCJwc3RydXRcIiBzdHlsZT1cImhlaWdodDogMy4wNWVtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cInNpemluZyByZXNldC1zaXplNiBzaXplMyBtdGlnaHRcIj48c3BhbiBjbGFzcz1cIm1vcmQgbWF0aGRlZmF1bHQgbXRpZ2h0XCI+bjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cInZsaXN0LXNcIj7igIs8L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwidmxpc3QtclwiPjxzcGFuIGNsYXNzPVwidmxpc3RcIiBzdHlsZT1cImhlaWdodDogMS4yNzc2N2VtO1wiPjxzcGFuIGNsYXNzPVwiXCI+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1zcGFjZVwiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAwLjE2NjY2N2VtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1vcmRcIj48c3BhbiBjbGFzcz1cIm1vcmQgbWF0aGRlZmF1bHRcIj5hPC9zcGFuPjxzcGFuIGNsYXNzPVwibXN1cHN1YlwiPjxzcGFuIGNsYXNzPVwidmxpc3QtdCB2bGlzdC10MlwiPjxzcGFuIGNsYXNzPVwidmxpc3QtclwiPjxzcGFuIGNsYXNzPVwidmxpc3RcIiBzdHlsZT1cImhlaWdodDogMC4zMTE2NjRlbTtcIj48c3BhbiBjbGFzcz1cIlwiIHN0eWxlPVwidG9wOiAtMi41NWVtOyBtYXJnaW4tbGVmdDogMGVtOyBtYXJnaW4tcmlnaHQ6IDAuMDVlbTtcIj48c3BhbiBjbGFzcz1cInBzdHJ1dFwiIHN0eWxlPVwiaGVpZ2h0OiAyLjdlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJzaXppbmcgcmVzZXQtc2l6ZTYgc2l6ZTMgbXRpZ2h0XCI+PHNwYW4gY2xhc3M9XCJtb3JkIG1hdGhkZWZhdWx0IG10aWdodFwiPmk8L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJ2bGlzdC1zXCI+4oCLPC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cInZsaXN0LXJcIj48c3BhbiBjbGFzcz1cInZsaXN0XCIgc3R5bGU9XCJoZWlnaHQ6IDAuMTVlbTtcIj48c3BhbiBjbGFzcz1cIlwiPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj5cbjwvdGQ+XG48L3RyPlxuPHRyPlxuPHRkPlxuICA8ZGl2IGNsYXNzPVwibWFya3VwXCI+XFxcXGJpZ1t4XFxcXGJpZ108L2Rpdj5cbjwvdGQ+XG48dGQ+XG4gIDxzcGFuIGNsYXNzPVwia2F0ZXgtZGlzcGxheVwiPjxzcGFuIGNsYXNzPVwia2F0ZXhcIj48c3BhbiBjbGFzcz1cImthdGV4LW1hdGhtbFwiPjxtYXRoIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiPjxzZW1hbnRpY3M+PG1yb3c+PG1vIGZlbmNlPVwiZmFsc2VcIj5bPC9tbz48bWk+eDwvbWk+PG1vIGZlbmNlPVwiZmFsc2VcIj5dPC9tbz48L21yb3c+PGFubm90YXRpb24gZW5jb2Rpbmc9XCJhcHBsaWNhdGlvbi94LXRleFwiPlxcXFxiaWdbeFxcXFxiaWddPC9hbm5vdGF0aW9uPjwvc2VtYW50aWNzPjwvbWF0aD48L3NwYW4+PHNwYW4gY2xhc3M9XCJrYXRleC1odG1sXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PHNwYW4gY2xhc3M9XCJiYXNlXCI+PHNwYW4gY2xhc3M9XCJzdHJ1dFwiIHN0eWxlPVwiaGVpZ2h0OiAxLjIwMDAxZW07IHZlcnRpY2FsLWFsaWduOiAtMC4zNTAwMWVtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1vcmRcIj48c3BhbiBjbGFzcz1cImRlbGltc2l6aW5nIHNpemUxXCI+Wzwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJtb3JkIG1hdGhkZWZhdWx0XCI+eDwvc3Bhbj48c3BhbiBjbGFzcz1cIm1vcmRcIj48c3BhbiBjbGFzcz1cImRlbGltc2l6aW5nIHNpemUxXCI+XTwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPlxuPC90ZD5cbjwvdHI+XG48dHI+XG48dGQ+XG4gIDxkaXYgY2xhc3M9XCJtYXJrdXBcIj5cXFxcQmlnW3hcXFxcQmlnXTwvZGl2PlxuPC90ZD5cbjx0ZD5cbiAgPHNwYW4gY2xhc3M9XCJrYXRleC1kaXNwbGF5XCI+PHNwYW4gY2xhc3M9XCJrYXRleFwiPjxzcGFuIGNsYXNzPVwia2F0ZXgtbWF0aG1sXCI+PG1hdGggeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCI+PHNlbWFudGljcz48bXJvdz48bW8gZmVuY2U9XCJmYWxzZVwiPls8L21vPjxtaT54PC9taT48bW8gZmVuY2U9XCJmYWxzZVwiPl08L21vPjwvbXJvdz48YW5ub3RhdGlvbiBlbmNvZGluZz1cImFwcGxpY2F0aW9uL3gtdGV4XCI+XFxcXEJpZ1t4XFxcXEJpZ108L2Fubm90YXRpb24+PC9zZW1hbnRpY3M+PC9tYXRoPjwvc3Bhbj48c3BhbiBjbGFzcz1cImthdGV4LWh0bWxcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48c3BhbiBjbGFzcz1cImJhc2VcIj48c3BhbiBjbGFzcz1cInN0cnV0XCIgc3R5bGU9XCJoZWlnaHQ6IDEuODAwMDJlbTsgdmVydGljYWwtYWxpZ246IC0wLjY1MDAyZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwibW9yZFwiPjxzcGFuIGNsYXNzPVwiZGVsaW1zaXppbmcgc2l6ZTJcIj5bPC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1vcmQgbWF0aGRlZmF1bHRcIj54PC9zcGFuPjxzcGFuIGNsYXNzPVwibW9yZFwiPjxzcGFuIGNsYXNzPVwiZGVsaW1zaXppbmcgc2l6ZTJcIj5dPC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+XG48L3RkPlxuPC90cj5cbjx0cj5cbjx0ZD5cbiAgPGRpdiBjbGFzcz1cIm1hcmt1cFwiPlxcXFxsaW1fe2hcXFxcdG8wfSBcXFxcZnJhY3sxfXtufTwvZGl2PlxuPC90ZD5cbjx0ZD5cbiAgPHNwYW4gY2xhc3M9XCJrYXRleC1kaXNwbGF5XCI+PHNwYW4gY2xhc3M9XCJrYXRleFwiPjxzcGFuIGNsYXNzPVwia2F0ZXgtbWF0aG1sXCI+PG1hdGggeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCI+PHNlbWFudGljcz48bXJvdz48bXVuZGVyPjxtbz48bWk+bGltPC9taT48bW8+4oGhPC9tbz48L21vPjxtcm93PjxtaT5oPC9taT48bW8+4oaSPC9tbz48bW4+MDwvbW4+PC9tcm93PjwvbXVuZGVyPjxtZnJhYz48bW4+MTwvbW4+PG1pPm48L21pPjwvbWZyYWM+PC9tcm93Pjxhbm5vdGF0aW9uIGVuY29kaW5nPVwiYXBwbGljYXRpb24veC10ZXhcIj5cXFxcbGltX3toXFxcXHRvMH0gXFxcXGZyYWN7MX17bn08L2Fubm90YXRpb24+PC9zZW1hbnRpY3M+PC9tYXRoPjwvc3Bhbj48c3BhbiBjbGFzcz1cImthdGV4LWh0bWxcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48c3BhbiBjbGFzcz1cImJhc2VcIj48c3BhbiBjbGFzcz1cInN0cnV0XCIgc3R5bGU9XCJoZWlnaHQ6IDIuMDczNTVlbTsgdmVydGljYWwtYWxpZ246IC0wLjc1MjEwOGVtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1vcCBvcC1saW1pdHNcIj48c3BhbiBjbGFzcz1cInZsaXN0LXQgdmxpc3QtdDJcIj48c3BhbiBjbGFzcz1cInZsaXN0LXJcIj48c3BhbiBjbGFzcz1cInZsaXN0XCIgc3R5bGU9XCJoZWlnaHQ6IDAuNjk0NDRlbTtcIj48c3BhbiBjbGFzcz1cIlwiIHN0eWxlPVwidG9wOiAtMi4zNDc4OWVtOyBtYXJnaW4tbGVmdDogMGVtO1wiPjxzcGFuIGNsYXNzPVwicHN0cnV0XCIgc3R5bGU9XCJoZWlnaHQ6IDNlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJzaXppbmcgcmVzZXQtc2l6ZTYgc2l6ZTMgbXRpZ2h0XCI+PHNwYW4gY2xhc3M9XCJtb3JkIG10aWdodFwiPjxzcGFuIGNsYXNzPVwibW9yZCBtYXRoZGVmYXVsdCBtdGlnaHRcIj5oPC9zcGFuPjxzcGFuIGNsYXNzPVwibXJlbCBtdGlnaHRcIj7ihpI8L3NwYW4+PHNwYW4gY2xhc3M9XCJtb3JkIG10aWdodFwiPjA8L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJcIiBzdHlsZT1cInRvcDogLTNlbTtcIj48c3BhbiBjbGFzcz1cInBzdHJ1dFwiIHN0eWxlPVwiaGVpZ2h0OiAzZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwiXCI+PHNwYW4gY2xhc3M9XCJtb3BcIj5saW08L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJ2bGlzdC1zXCI+4oCLPC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cInZsaXN0LXJcIj48c3BhbiBjbGFzcz1cInZsaXN0XCIgc3R5bGU9XCJoZWlnaHQ6IDAuNzUyMTA4ZW07XCI+PHNwYW4gY2xhc3M9XCJcIj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwibXNwYWNlXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDAuMTY2NjY3ZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwibW9yZFwiPjxzcGFuIGNsYXNzPVwibW9wZW4gbnVsbGRlbGltaXRlclwiPjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1mcmFjXCI+PHNwYW4gY2xhc3M9XCJ2bGlzdC10IHZsaXN0LXQyXCI+PHNwYW4gY2xhc3M9XCJ2bGlzdC1yXCI+PHNwYW4gY2xhc3M9XCJ2bGlzdFwiIHN0eWxlPVwiaGVpZ2h0OiAxLjMyMTQ0ZW07XCI+PHNwYW4gY2xhc3M9XCJcIiBzdHlsZT1cInRvcDogLTIuMzE0ZW07XCI+PHNwYW4gY2xhc3M9XCJwc3RydXRcIiBzdHlsZT1cImhlaWdodDogM2VtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1vcmRcIj48c3BhbiBjbGFzcz1cIm1vcmQgbWF0aGRlZmF1bHRcIj5uPC9zcGFuPjwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJcIiBzdHlsZT1cInRvcDogLTMuMjNlbTtcIj48c3BhbiBjbGFzcz1cInBzdHJ1dFwiIHN0eWxlPVwiaGVpZ2h0OiAzZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwiZnJhYy1saW5lXCIgc3R5bGU9XCJib3JkZXItYm90dG9tLXdpZHRoOiAwLjA0ZW07XCI+PC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cIlwiIHN0eWxlPVwidG9wOiAtMy42NzdlbTtcIj48c3BhbiBjbGFzcz1cInBzdHJ1dFwiIHN0eWxlPVwiaGVpZ2h0OiAzZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwibW9yZFwiPjxzcGFuIGNsYXNzPVwibW9yZFwiPjE8L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJ2bGlzdC1zXCI+4oCLPC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cInZsaXN0LXJcIj48c3BhbiBjbGFzcz1cInZsaXN0XCIgc3R5bGU9XCJoZWlnaHQ6IDAuNjg2ZW07XCI+PHNwYW4gY2xhc3M9XCJcIj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwibWNsb3NlIG51bGxkZWxpbWl0ZXJcIj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj5cbjwvdGQ+XG48L3RyPlxuPHRyPlxuPHRkPlxuICA8ZGl2IGNsYXNzPVwibWFya3VwXCI+XFxcXHNxcnR7OX0gPSBcXFxcc3FydFsyXXs5fSA8L2Rpdj5cbjwvdGQ+XG48dGQ+XG4gIDxzcGFuIGNsYXNzPVwia2F0ZXgtZGlzcGxheVwiPjxzcGFuIGNsYXNzPVwia2F0ZXhcIj48c3BhbiBjbGFzcz1cImthdGV4LW1hdGhtbFwiPjxtYXRoIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiPjxzZW1hbnRpY3M+PG1yb3c+PG1zcXJ0Pjxtbj45PC9tbj48L21zcXJ0Pjxtbz49PC9tbz48bXJvb3Q+PG1uPjk8L21uPjxtbj4yPC9tbj48L21yb290PjwvbXJvdz48YW5ub3RhdGlvbiBlbmNvZGluZz1cImFwcGxpY2F0aW9uL3gtdGV4XCI+XFxcXHNxcnR7OX0gPSBcXFxcc3FydFsyXXs5fSA8L2Fubm90YXRpb24+PC9zZW1hbnRpY3M+PC9tYXRoPjwvc3Bhbj48c3BhbiBjbGFzcz1cImthdGV4LWh0bWxcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48c3BhbiBjbGFzcz1cImJhc2VcIj48c3BhbiBjbGFzcz1cInN0cnV0XCIgc3R5bGU9XCJoZWlnaHQ6IDEuMDRlbTsgdmVydGljYWwtYWxpZ246IC0wLjA4MzkwNWVtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1vcmQgc3FydFwiPjxzcGFuIGNsYXNzPVwidmxpc3QtdCB2bGlzdC10MlwiPjxzcGFuIGNsYXNzPVwidmxpc3QtclwiPjxzcGFuIGNsYXNzPVwidmxpc3RcIiBzdHlsZT1cImhlaWdodDogMC45NTYwOTVlbTtcIj48c3BhbiBjbGFzcz1cInN2Zy1hbGlnblwiIHN0eWxlPVwidG9wOiAtM2VtO1wiPjxzcGFuIGNsYXNzPVwicHN0cnV0XCIgc3R5bGU9XCJoZWlnaHQ6IDNlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJtb3JkXCIgc3R5bGU9XCJwYWRkaW5nLWxlZnQ6IDAuODMzZW07XCI+PHNwYW4gY2xhc3M9XCJtb3JkXCI+OTwvc3Bhbj48L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwiXCIgc3R5bGU9XCJ0b3A6IC0yLjkxNjA5ZW07XCI+PHNwYW4gY2xhc3M9XCJwc3RydXRcIiBzdHlsZT1cImhlaWdodDogM2VtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cImhpZGUtdGFpbFwiIHN0eWxlPVwibWluLXdpZHRoOiAwLjg1M2VtOyBoZWlnaHQ6IDEuMDhlbTtcIj48c3ZnIHdpZHRoPVwiNDAwZW1cIiBoZWlnaHQ9XCIxLjA4ZW1cIiB2aWV3Qm94PVwiMCAwIDQwMDAwMCAxMDgwXCIgcHJlc2VydmVBc3BlY3RSYXRpbz1cInhNaW5ZTWluIHNsaWNlXCI+PHBhdGggZD1cIk05NSw3MDJcbiAgICBjLTIuNywwLC03LjE3LC0yLjcsLTEzLjUsLThjLTUuOCwtNS4zLC05LjUsLTEwLC05LjUsLTE0XG4gICAgYzAsLTIsMC4zLC0zLjMsMSwtNGMxLjMsLTIuNywyMy44MywtMjAuNyw2Ny41LC01NFxuICAgIGM0NC4yLC0zMy4zLDY1LjgsLTUwLjMsNjYuNSwtNTFjMS4zLC0xLjMsMywtMiw1LC0yYzQuNywwLDguNywzLjMsMTIsMTBcbiAgICBzMTczLDM3OCwxNzMsMzc4YzAuNywwLDM1LjMsLTcxLDEwNCwtMjEzYzY4LjcsLTE0MiwxMzcuNSwtMjg1LDIwNi41LC00MjlcbiAgICBjNjksLTE0NCwxMDQuNSwtMjE3LjcsMTA2LjUsLTIyMVxuICAgIGwwIC0wXG4gICAgYzUuMywtOS4zLDEyLC0xNCwyMCwtMTRcbiAgICBINDAwMDAwdjQwSDg0NS4yNzI0XG4gICAgcy0yMjUuMjcyLDQ2NywtMjI1LjI3Miw0NjdzLTIzNSw0ODYsLTIzNSw0ODZjLTIuNyw0LjcsLTksNywtMTksN1xuICAgIGMtNiwwLC0xMCwtMSwtMTIsLTNzLTE5NCwtNDIyLC0xOTQsLTQyMnMtNjUsNDcsLTY1LDQ3elxuICAgIE04MzQgODBoNDAwMDAwdjQwaC00MDAwMDB6XCI+PC9wYXRoPjwvc3ZnPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwidmxpc3Qtc1wiPuKAizwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJ2bGlzdC1yXCI+PHNwYW4gY2xhc3M9XCJ2bGlzdFwiIHN0eWxlPVwiaGVpZ2h0OiAwLjA4MzkwNWVtO1wiPjxzcGFuIGNsYXNzPVwiXCI+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1zcGFjZVwiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAwLjI3Nzc3OGVtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1yZWxcIj49PC9zcGFuPjxzcGFuIGNsYXNzPVwibXNwYWNlXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDAuMjc3Nzc4ZW07XCI+PC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cImJhc2VcIj48c3BhbiBjbGFzcz1cInN0cnV0XCIgc3R5bGU9XCJoZWlnaHQ6IDEuMDRlbTsgdmVydGljYWwtYWxpZ246IC0wLjA4MzkwNWVtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1vcmQgc3FydFwiPjxzcGFuIGNsYXNzPVwicm9vdFwiPjxzcGFuIGNsYXNzPVwidmxpc3QtdFwiPjxzcGFuIGNsYXNzPVwidmxpc3QtclwiPjxzcGFuIGNsYXNzPVwidmxpc3RcIiBzdHlsZT1cImhlaWdodDogMC44NDU1MzRlbTtcIj48c3BhbiBjbGFzcz1cIlwiIHN0eWxlPVwidG9wOiAtMy4wMjMzMWVtO1wiPjxzcGFuIGNsYXNzPVwicHN0cnV0XCIgc3R5bGU9XCJoZWlnaHQ6IDIuNWVtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cInNpemluZyByZXNldC1zaXplNiBzaXplMSBtdGlnaHRcIj48c3BhbiBjbGFzcz1cIm1vcmQgbXRpZ2h0XCI+PHNwYW4gY2xhc3M9XCJtb3JkIG10aWdodFwiPjI8L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwidmxpc3QtdCB2bGlzdC10MlwiPjxzcGFuIGNsYXNzPVwidmxpc3QtclwiPjxzcGFuIGNsYXNzPVwidmxpc3RcIiBzdHlsZT1cImhlaWdodDogMC45NTYwOTVlbTtcIj48c3BhbiBjbGFzcz1cInN2Zy1hbGlnblwiIHN0eWxlPVwidG9wOiAtM2VtO1wiPjxzcGFuIGNsYXNzPVwicHN0cnV0XCIgc3R5bGU9XCJoZWlnaHQ6IDNlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJtb3JkXCIgc3R5bGU9XCJwYWRkaW5nLWxlZnQ6IDAuODMzZW07XCI+PHNwYW4gY2xhc3M9XCJtb3JkXCI+OTwvc3Bhbj48L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwiXCIgc3R5bGU9XCJ0b3A6IC0yLjkxNjA5ZW07XCI+PHNwYW4gY2xhc3M9XCJwc3RydXRcIiBzdHlsZT1cImhlaWdodDogM2VtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cImhpZGUtdGFpbFwiIHN0eWxlPVwibWluLXdpZHRoOiAwLjg1M2VtOyBoZWlnaHQ6IDEuMDhlbTtcIj48c3ZnIHdpZHRoPVwiNDAwZW1cIiBoZWlnaHQ9XCIxLjA4ZW1cIiB2aWV3Qm94PVwiMCAwIDQwMDAwMCAxMDgwXCIgcHJlc2VydmVBc3BlY3RSYXRpbz1cInhNaW5ZTWluIHNsaWNlXCI+PHBhdGggZD1cIk05NSw3MDJcbiAgICBjLTIuNywwLC03LjE3LC0yLjcsLTEzLjUsLThjLTUuOCwtNS4zLC05LjUsLTEwLC05LjUsLTE0XG4gICAgYzAsLTIsMC4zLC0zLjMsMSwtNGMxLjMsLTIuNywyMy44MywtMjAuNyw2Ny41LC01NFxuICAgIGM0NC4yLC0zMy4zLDY1LjgsLTUwLjMsNjYuNSwtNTFjMS4zLC0xLjMsMywtMiw1LC0yYzQuNywwLDguNywzLjMsMTIsMTBcbiAgICBzMTczLDM3OCwxNzMsMzc4YzAuNywwLDM1LjMsLTcxLDEwNCwtMjEzYzY4LjcsLTE0MiwxMzcuNSwtMjg1LDIwNi41LC00MjlcbiAgICBjNjksLTE0NCwxMDQuNSwtMjE3LjcsMTA2LjUsLTIyMVxuICAgIGwwIC0wXG4gICAgYzUuMywtOS4zLDEyLC0xNCwyMCwtMTRcbiAgICBINDAwMDAwdjQwSDg0NS4yNzI0XG4gICAgcy0yMjUuMjcyLDQ2NywtMjI1LjI3Miw0NjdzLTIzNSw0ODYsLTIzNSw0ODZjLTIuNyw0LjcsLTksNywtMTksN1xuICAgIGMtNiwwLC0xMCwtMSwtMTIsLTNzLTE5NCwtNDIyLC0xOTQsLTQyMnMtNjUsNDcsLTY1LDQ3elxuICAgIE04MzQgODBoNDAwMDAwdjQwaC00MDAwMDB6XCI+PC9wYXRoPjwvc3ZnPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwidmxpc3Qtc1wiPuKAizwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJ2bGlzdC1yXCI+PHNwYW4gY2xhc3M9XCJ2bGlzdFwiIHN0eWxlPVwiaGVpZ2h0OiAwLjA4MzkwNWVtO1wiPjxzcGFuIGNsYXNzPVwiXCI+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+XG48L3RkPlxuPC90cj5cbjx0cj5cbjx0ZD5cbiAgPGRpdiBjbGFzcz1cIm1hcmt1cFwiPlxuICAgIFxcXFxiZWdpbntwbWF0cml4fTxici8+XG4gICAgJm5ic3A7Jm5ic3A7YSAmJiBiIFxcXFxcXFxcPGJyLz5cbiAgICAmbmJzcDsmbmJzcDtjICYmIGQ8YnIvPlxuICAgIFxcXFxlbmR7cG1hdHJpeH08YnIvPlxuICA8L2Rpdj5cbjwvdGQ+XG48dGQ+XG4gIDxzcGFuIGNsYXNzPVwia2F0ZXgtZGlzcGxheVwiPjxzcGFuIGNsYXNzPVwia2F0ZXhcIj48c3BhbiBjbGFzcz1cImthdGV4LW1hdGhtbFwiPjxtYXRoIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiPjxzZW1hbnRpY3M+PG1yb3c+PG1vIGZlbmNlPVwidHJ1ZVwiPig8L21vPjxtdGFibGUgcm93c3BhY2luZz1cIjAuMTU5OTk5OTk5OTk5OTk5OTJlbVwiIGNvbHVtbnNwYWNpbmc9XCIxZW1cIj48bXRyPjxtdGQ+PG1zdHlsZSBzY3JpcHRsZXZlbD1cIjBcIiBkaXNwbGF5c3R5bGU9XCJmYWxzZVwiPjxtaT5hPC9taT48L21zdHlsZT48L210ZD48bXRkPjxtc3R5bGUgc2NyaXB0bGV2ZWw9XCIwXCIgZGlzcGxheXN0eWxlPVwiZmFsc2VcIj48bXJvdz48L21yb3c+PC9tc3R5bGU+PC9tdGQ+PG10ZD48bXN0eWxlIHNjcmlwdGxldmVsPVwiMFwiIGRpc3BsYXlzdHlsZT1cImZhbHNlXCI+PG1pPmI8L21pPjwvbXN0eWxlPjwvbXRkPjwvbXRyPjxtdHI+PG10ZD48bXN0eWxlIHNjcmlwdGxldmVsPVwiMFwiIGRpc3BsYXlzdHlsZT1cImZhbHNlXCI+PG1pPmM8L21pPjwvbXN0eWxlPjwvbXRkPjxtdGQ+PG1zdHlsZSBzY3JpcHRsZXZlbD1cIjBcIiBkaXNwbGF5c3R5bGU9XCJmYWxzZVwiPjxtcm93PjwvbXJvdz48L21zdHlsZT48L210ZD48bXRkPjxtc3R5bGUgc2NyaXB0bGV2ZWw9XCIwXCIgZGlzcGxheXN0eWxlPVwiZmFsc2VcIj48bWk+ZDwvbWk+PC9tc3R5bGU+PC9tdGQ+PC9tdHI+PC9tdGFibGU+PG1vIGZlbmNlPVwidHJ1ZVwiPik8L21vPjwvbXJvdz48YW5ub3RhdGlvbiBlbmNvZGluZz1cImFwcGxpY2F0aW9uL3gtdGV4XCI+XFxcXGJlZ2lue3BtYXRyaXh9XG4gICAgYSAmYW1wOyZhbXA7IGIgXFxcXFxcXFxcbiAgICBjICZhbXA7JmFtcDsgZFxuICBcXFxcZW5ke3BtYXRyaXh9XG4gIDwvYW5ub3RhdGlvbj48L3NlbWFudGljcz48L21hdGg+PC9zcGFuPjxzcGFuIGNsYXNzPVwia2F0ZXgtaHRtbFwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjxzcGFuIGNsYXNzPVwiYmFzZVwiPjxzcGFuIGNsYXNzPVwic3RydXRcIiBzdHlsZT1cImhlaWdodDogMi40MDAwM2VtOyB2ZXJ0aWNhbC1hbGlnbjogLTAuOTUwMDNlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJtaW5uZXJcIj48c3BhbiBjbGFzcz1cIm1vcGVuIGRlbGltY2VudGVyXCIgc3R5bGU9XCJ0b3A6IDBlbTtcIj48c3BhbiBjbGFzcz1cImRlbGltc2l6aW5nIHNpemUzXCI+KDwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJtb3JkXCI+PHNwYW4gY2xhc3M9XCJtdGFibGVcIj48c3BhbiBjbGFzcz1cImNvbC1hbGlnbi1jXCI+PHNwYW4gY2xhc3M9XCJ2bGlzdC10IHZsaXN0LXQyXCI+PHNwYW4gY2xhc3M9XCJ2bGlzdC1yXCI+PHNwYW4gY2xhc3M9XCJ2bGlzdFwiIHN0eWxlPVwiaGVpZ2h0OiAxLjQ1ZW07XCI+PHNwYW4gY2xhc3M9XCJcIiBzdHlsZT1cInRvcDogLTMuNjFlbTtcIj48c3BhbiBjbGFzcz1cInBzdHJ1dFwiIHN0eWxlPVwiaGVpZ2h0OiAzZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwibW9yZFwiPjxzcGFuIGNsYXNzPVwibW9yZCBtYXRoZGVmYXVsdFwiPmE8L3NwYW4+PC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cIlwiIHN0eWxlPVwidG9wOiAtMi40MWVtO1wiPjxzcGFuIGNsYXNzPVwicHN0cnV0XCIgc3R5bGU9XCJoZWlnaHQ6IDNlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJtb3JkXCI+PHNwYW4gY2xhc3M9XCJtb3JkIG1hdGhkZWZhdWx0XCI+Yzwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cInZsaXN0LXNcIj7igIs8L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwidmxpc3QtclwiPjxzcGFuIGNsYXNzPVwidmxpc3RcIiBzdHlsZT1cImhlaWdodDogMC45NWVtO1wiPjxzcGFuIGNsYXNzPVwiXCI+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cImFycmF5Y29sc2VwXCIgc3R5bGU9XCJ3aWR0aDogMC41ZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwiYXJyYXljb2xzZXBcIiBzdHlsZT1cIndpZHRoOiAwLjVlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJjb2wtYWxpZ24tY1wiPjxzcGFuIGNsYXNzPVwidmxpc3QtdCB2bGlzdC10MlwiPjxzcGFuIGNsYXNzPVwidmxpc3QtclwiPjxzcGFuIGNsYXNzPVwidmxpc3RcIiBzdHlsZT1cImhlaWdodDogMS40NWVtO1wiPjxzcGFuIGNsYXNzPVwiXCIgc3R5bGU9XCJ0b3A6IC0zLjQ1ZW07XCI+PHNwYW4gY2xhc3M9XCJwc3RydXRcIiBzdHlsZT1cImhlaWdodDogMi44NGVtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1vcmRcIj48L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwiXCIgc3R5bGU9XCJ0b3A6IC0yLjI1ZW07XCI+PHNwYW4gY2xhc3M9XCJwc3RydXRcIiBzdHlsZT1cImhlaWdodDogMi44NGVtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1vcmRcIj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cInZsaXN0LXNcIj7igIs8L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwidmxpc3QtclwiPjxzcGFuIGNsYXNzPVwidmxpc3RcIiBzdHlsZT1cImhlaWdodDogMC45NWVtO1wiPjxzcGFuIGNsYXNzPVwiXCI+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cImFycmF5Y29sc2VwXCIgc3R5bGU9XCJ3aWR0aDogMC41ZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwiYXJyYXljb2xzZXBcIiBzdHlsZT1cIndpZHRoOiAwLjVlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJjb2wtYWxpZ24tY1wiPjxzcGFuIGNsYXNzPVwidmxpc3QtdCB2bGlzdC10MlwiPjxzcGFuIGNsYXNzPVwidmxpc3QtclwiPjxzcGFuIGNsYXNzPVwidmxpc3RcIiBzdHlsZT1cImhlaWdodDogMS40NWVtO1wiPjxzcGFuIGNsYXNzPVwiXCIgc3R5bGU9XCJ0b3A6IC0zLjYxZW07XCI+PHNwYW4gY2xhc3M9XCJwc3RydXRcIiBzdHlsZT1cImhlaWdodDogM2VtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1vcmRcIj48c3BhbiBjbGFzcz1cIm1vcmQgbWF0aGRlZmF1bHRcIj5iPC9zcGFuPjwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJcIiBzdHlsZT1cInRvcDogLTIuNDFlbTtcIj48c3BhbiBjbGFzcz1cInBzdHJ1dFwiIHN0eWxlPVwiaGVpZ2h0OiAzZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwibW9yZFwiPjxzcGFuIGNsYXNzPVwibW9yZCBtYXRoZGVmYXVsdFwiPmQ8L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJ2bGlzdC1zXCI+4oCLPC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cInZsaXN0LXJcIj48c3BhbiBjbGFzcz1cInZsaXN0XCIgc3R5bGU9XCJoZWlnaHQ6IDAuOTVlbTtcIj48c3BhbiBjbGFzcz1cIlwiPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1jbG9zZSBkZWxpbWNlbnRlclwiIHN0eWxlPVwidG9wOiAwZW07XCI+PHNwYW4gY2xhc3M9XCJkZWxpbXNpemluZyBzaXplM1wiPik8L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+XG48L3RkPlxuXG48dHI+XG4gIDx0ZD5cbiAgICA8ZGl2IGNsYXNzPVwibWFya3VwXCI+XG4gICAgICBmPVxcXFxiZWdpbntjYXNlc308YnIvPlxuICAgICAgMCAgICYgYzFcXFxcXFxcXDxici8+XG4gICAgICAxICAgJiBjMlxcXFxcXFxcPGJyLz5cbiAgICAgIDIgICAmIGMyPGJyLz5cbiAgICAgIFxcXFxlbmR7Y2FzZXN9PGJyLz5cbiAgICA8L2Rpdj5cbiAgPC90ZD5cbiAgPHRkPlxuICAgIDxzcGFuIGNsYXNzPVwia2F0ZXgtZGlzcGxheVwiPjxzcGFuIGNsYXNzPVwia2F0ZXhcIj48c3BhbiBjbGFzcz1cImthdGV4LW1hdGhtbFwiPjxtYXRoIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiPjxzZW1hbnRpY3M+PG1yb3c+PG1pPmY8L21pPjxtbz49PC9tbz48bXJvdz48bW8gZmVuY2U9XCJ0cnVlXCI+ezwvbW8+PG10YWJsZSByb3dzcGFjaW5nPVwiMC4zNTk5OTk5OTk5OTk5OTk5ZW1cIiBjb2x1bW5hbGlnbj1cImxlZnQgbGVmdFwiIGNvbHVtbnNwYWNpbmc9XCIxZW1cIj48bXRyPjxtdGQ+PG1zdHlsZSBzY3JpcHRsZXZlbD1cIjBcIiBkaXNwbGF5c3R5bGU9XCJmYWxzZVwiPjxtbj4wPC9tbj48L21zdHlsZT48L210ZD48bXRkPjxtc3R5bGUgc2NyaXB0bGV2ZWw9XCIwXCIgZGlzcGxheXN0eWxlPVwiZmFsc2VcIj48bXJvdz48bWk+YzwvbWk+PG1uPjE8L21uPjwvbXJvdz48L21zdHlsZT48L210ZD48L210cj48bXRyPjxtdGQ+PG1zdHlsZSBzY3JpcHRsZXZlbD1cIjBcIiBkaXNwbGF5c3R5bGU9XCJmYWxzZVwiPjxtbj4xPC9tbj48L21zdHlsZT48L210ZD48bXRkPjxtc3R5bGUgc2NyaXB0bGV2ZWw9XCIwXCIgZGlzcGxheXN0eWxlPVwiZmFsc2VcIj48bXJvdz48bWk+YzwvbWk+PG1uPjI8L21uPjwvbXJvdz48L21zdHlsZT48L210ZD48L210cj48bXRyPjxtdGQ+PG1zdHlsZSBzY3JpcHRsZXZlbD1cIjBcIiBkaXNwbGF5c3R5bGU9XCJmYWxzZVwiPjxtbj4yPC9tbj48L21zdHlsZT48L210ZD48bXRkPjxtc3R5bGUgc2NyaXB0bGV2ZWw9XCIwXCIgZGlzcGxheXN0eWxlPVwiZmFsc2VcIj48bXJvdz48bWk+YzwvbWk+PG1uPjI8L21uPjwvbXJvdz48L21zdHlsZT48L210ZD48L210cj48L210YWJsZT48L21yb3c+PC9tcm93Pjxhbm5vdGF0aW9uIGVuY29kaW5nPVwiYXBwbGljYXRpb24veC10ZXhcIj5mID1cbiAgICAgIFxcXFxiZWdpbntjYXNlc31cbiAgICAgIDAgICAmYW1wOyBjMVxcXFxcXFxcXG4gICAgICAxICAgJmFtcDsgYzJcXFxcXFxcXFxuICAgICAgMiAgICZhbXA7IGMyXG4gICAgICBcXFxcZW5ke2Nhc2VzfTwvYW5ub3RhdGlvbj48L3NlbWFudGljcz48L21hdGg+PC9zcGFuPjxzcGFuIGNsYXNzPVwia2F0ZXgtaHRtbFwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjxzcGFuIGNsYXNzPVwiYmFzZVwiPjxzcGFuIGNsYXNzPVwic3RydXRcIiBzdHlsZT1cImhlaWdodDogMC44ODg4OGVtOyB2ZXJ0aWNhbC1hbGlnbjogLTAuMTk0NDRlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJtb3JkIG1hdGhkZWZhdWx0XCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDAuMTA3NjRlbTtcIj5mPC9zcGFuPjxzcGFuIGNsYXNzPVwibXNwYWNlXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDAuMjc3Nzc4ZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwibXJlbFwiPj08L3NwYW4+PHNwYW4gY2xhc3M9XCJtc3BhY2VcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMC4yNzc3NzhlbTtcIj48L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwiYmFzZVwiPjxzcGFuIGNsYXNzPVwic3RydXRcIiBzdHlsZT1cImhlaWdodDogNC4zMmVtOyB2ZXJ0aWNhbC1hbGlnbjogLTEuOTFlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJtaW5uZXJcIj48c3BhbiBjbGFzcz1cIm1vcGVuXCI+PHNwYW4gY2xhc3M9XCJkZWxpbXNpemluZyBtdWx0XCI+PHNwYW4gY2xhc3M9XCJ2bGlzdC10IHZsaXN0LXQyXCI+PHNwYW4gY2xhc3M9XCJ2bGlzdC1yXCI+PHNwYW4gY2xhc3M9XCJ2bGlzdFwiIHN0eWxlPVwiaGVpZ2h0OiAyLjM1MDAyZW07XCI+PHNwYW4gY2xhc3M9XCJcIiBzdHlsZT1cInRvcDogLTIuMTk5OTllbTtcIj48c3BhbiBjbGFzcz1cInBzdHJ1dFwiIHN0eWxlPVwiaGVpZ2h0OiAzLjE1ZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwiZGVsaW1zaXppbmdpbm5lciBkZWxpbS1zaXplNFwiPjxzcGFuIGNsYXNzPVwiXCI+4o6pPC9zcGFuPjwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJcIiBzdHlsZT1cInRvcDogLTIuMTk0OTllbTtcIj48c3BhbiBjbGFzcz1cInBzdHJ1dFwiIHN0eWxlPVwiaGVpZ2h0OiAzLjE1ZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwiZGVsaW1zaXppbmdpbm5lciBkZWxpbS1zaXplNFwiPjxzcGFuIGNsYXNzPVwiXCI+4o6qPC9zcGFuPjwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJcIiBzdHlsZT1cInRvcDogLTIuMjA0OTllbTtcIj48c3BhbiBjbGFzcz1cInBzdHJ1dFwiIHN0eWxlPVwiaGVpZ2h0OiAzLjE1ZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwiZGVsaW1zaXppbmdpbm5lciBkZWxpbS1zaXplNFwiPjxzcGFuIGNsYXNzPVwiXCI+4o6qPC9zcGFuPjwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJcIiBzdHlsZT1cInRvcDogLTMuMTUwMDFlbTtcIj48c3BhbiBjbGFzcz1cInBzdHJ1dFwiIHN0eWxlPVwiaGVpZ2h0OiAzLjE1ZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwiZGVsaW1zaXppbmdpbm5lciBkZWxpbS1zaXplNFwiPjxzcGFuIGNsYXNzPVwiXCI+4o6oPC9zcGFuPjwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJcIiBzdHlsZT1cInRvcDogLTQuMjk1MDFlbTtcIj48c3BhbiBjbGFzcz1cInBzdHJ1dFwiIHN0eWxlPVwiaGVpZ2h0OiAzLjE1ZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwiZGVsaW1zaXppbmdpbm5lciBkZWxpbS1zaXplNFwiPjxzcGFuIGNsYXNzPVwiXCI+4o6qPC9zcGFuPjwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJcIiBzdHlsZT1cInRvcDogLTQuMzA1MDFlbTtcIj48c3BhbiBjbGFzcz1cInBzdHJ1dFwiIHN0eWxlPVwiaGVpZ2h0OiAzLjE1ZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwiZGVsaW1zaXppbmdpbm5lciBkZWxpbS1zaXplNFwiPjxzcGFuIGNsYXNzPVwiXCI+4o6qPC9zcGFuPjwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJcIiBzdHlsZT1cInRvcDogLTQuNjAwMDJlbTtcIj48c3BhbiBjbGFzcz1cInBzdHJ1dFwiIHN0eWxlPVwiaGVpZ2h0OiAzLjE1ZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwiZGVsaW1zaXppbmdpbm5lciBkZWxpbS1zaXplNFwiPjxzcGFuIGNsYXNzPVwiXCI+4o6nPC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwidmxpc3Qtc1wiPuKAizwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJ2bGlzdC1yXCI+PHNwYW4gY2xhc3M9XCJ2bGlzdFwiIHN0eWxlPVwiaGVpZ2h0OiAxLjg1MDAyZW07XCI+PHNwYW4gY2xhc3M9XCJcIj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1vcmRcIj48c3BhbiBjbGFzcz1cIm10YWJsZVwiPjxzcGFuIGNsYXNzPVwiY29sLWFsaWduLWxcIj48c3BhbiBjbGFzcz1cInZsaXN0LXQgdmxpc3QtdDJcIj48c3BhbiBjbGFzcz1cInZsaXN0LXJcIj48c3BhbiBjbGFzcz1cInZsaXN0XCIgc3R5bGU9XCJoZWlnaHQ6IDIuNDFlbTtcIj48c3BhbiBjbGFzcz1cIlwiIHN0eWxlPVwidG9wOiAtNC40MWVtO1wiPjxzcGFuIGNsYXNzPVwicHN0cnV0XCIgc3R5bGU9XCJoZWlnaHQ6IDMuMDA4ZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwibW9yZFwiPjxzcGFuIGNsYXNzPVwibW9yZFwiPjA8L3NwYW4+PC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cIlwiIHN0eWxlPVwidG9wOiAtMi45N2VtO1wiPjxzcGFuIGNsYXNzPVwicHN0cnV0XCIgc3R5bGU9XCJoZWlnaHQ6IDMuMDA4ZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwibW9yZFwiPjxzcGFuIGNsYXNzPVwibW9yZFwiPjE8L3NwYW4+PC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cIlwiIHN0eWxlPVwidG9wOiAtMS41M2VtO1wiPjxzcGFuIGNsYXNzPVwicHN0cnV0XCIgc3R5bGU9XCJoZWlnaHQ6IDMuMDA4ZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwibW9yZFwiPjxzcGFuIGNsYXNzPVwibW9yZFwiPjI8L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJ2bGlzdC1zXCI+4oCLPC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cInZsaXN0LXJcIj48c3BhbiBjbGFzcz1cInZsaXN0XCIgc3R5bGU9XCJoZWlnaHQ6IDEuOTFlbTtcIj48c3BhbiBjbGFzcz1cIlwiPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJhcnJheWNvbHNlcFwiIHN0eWxlPVwid2lkdGg6IDFlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJjb2wtYWxpZ24tbFwiPjxzcGFuIGNsYXNzPVwidmxpc3QtdCB2bGlzdC10MlwiPjxzcGFuIGNsYXNzPVwidmxpc3QtclwiPjxzcGFuIGNsYXNzPVwidmxpc3RcIiBzdHlsZT1cImhlaWdodDogMi40MWVtO1wiPjxzcGFuIGNsYXNzPVwiXCIgc3R5bGU9XCJ0b3A6IC00LjQxZW07XCI+PHNwYW4gY2xhc3M9XCJwc3RydXRcIiBzdHlsZT1cImhlaWdodDogMy4wMDhlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJtb3JkXCI+PHNwYW4gY2xhc3M9XCJtb3JkIG1hdGhkZWZhdWx0XCI+Yzwvc3Bhbj48c3BhbiBjbGFzcz1cIm1vcmRcIj4xPC9zcGFuPjwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJcIiBzdHlsZT1cInRvcDogLTIuOTdlbTtcIj48c3BhbiBjbGFzcz1cInBzdHJ1dFwiIHN0eWxlPVwiaGVpZ2h0OiAzLjAwOGVtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1vcmRcIj48c3BhbiBjbGFzcz1cIm1vcmQgbWF0aGRlZmF1bHRcIj5jPC9zcGFuPjxzcGFuIGNsYXNzPVwibW9yZFwiPjI8L3NwYW4+PC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cIlwiIHN0eWxlPVwidG9wOiAtMS41M2VtO1wiPjxzcGFuIGNsYXNzPVwicHN0cnV0XCIgc3R5bGU9XCJoZWlnaHQ6IDMuMDA4ZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwibW9yZFwiPjxzcGFuIGNsYXNzPVwibW9yZCBtYXRoZGVmYXVsdFwiPmM8L3NwYW4+PHNwYW4gY2xhc3M9XCJtb3JkXCI+Mjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cInZsaXN0LXNcIj7igIs8L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwidmxpc3QtclwiPjxzcGFuIGNsYXNzPVwidmxpc3RcIiBzdHlsZT1cImhlaWdodDogMS45MWVtO1wiPjxzcGFuIGNsYXNzPVwiXCI+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwibWNsb3NlIG51bGxkZWxpbWl0ZXJcIj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj5cbiAgPC90ZD5cbjwvdHI+XG48L3RyPlxuPC90YWJsZT5cbjxkaXY+YCIsInZhciBkbCA9IHJlcXVpcmUoJy4vZGxfc2VsZWN0Jyk7XG52YXIgdGlwcHkgPSByZXF1aXJlKCd0aXBweS5qcycpLmRlZmF1bHQ7XG52YXIgdGlwcHlJbnN0YW5jZXMgPSBuZXcgTWFwKCk7XG52YXIgbW9kYWxEaWFsb2dzID0gW107XG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGUgPT4ge1xuICAgIGlmKG1vZGFsRGlhbG9ncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxhc3REaWFsb2cgPSBtb2RhbERpYWxvZ3NbbW9kYWxEaWFsb2dzLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYoZS5rZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgICAgIGxhc3REaWFsb2cuZXNjSGFuZGxlcihlKVxuICAgIH0gZWxzZSBpZihlLmtleSA9PT0gJ0VudGVyJykge1xuICAgICAgICBpZihPYmplY3Qua2V5cyhsYXN0RGlhbG9nLmJ1dHRvbnMpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgbGFzdERpYWxvZy5lbnRlckhhbmRsZXIoZSlcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiBEZWNsYXJhdGl2Rm9ybShhdHRycywgb25DaGFuZ2VDYWxsYmFjaywgb25DYW5jZWxDYWxsYmFjaywgY29uZmlybUJ1dHRvbkNhcHRpb24pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5maWVsZHMgPSBhdHRycy5maWVsZHNcbiAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgdGhpcy5kb20uY2xhc3NMaXN0LmFkZCgnZGwtZm9ybScpXG4gICAgdGhpcy5mb3JtRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKVxuICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKHRoaXMuZm9ybUVsZW1lbnQpXG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gb25DaGFuZ2VDYWxsYmFja1xuICAgIHRoaXMub25DYW5jZWxDYWxsYmFjayA9IG9uQ2FuY2VsQ2FsbGJhY2tcbiAgICB0aGlzLmJ1dHRvbnMgPSBhdHRycy5idXR0b25zIHx8IHsgW2NvbmZpcm1CdXR0b25DYXB0aW9uIHx8ICdPSyddOiB7IGFjdGlvbjogb25DaGFuZ2VDYWxsYmFjaywgaWQ6ICdjb25maXJtQnRuLScgKyBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkqMTAwMDAwMCkgfSAgfVxuICAgIHRoaXMuaW5pdFByb21pc2VzID0ge31cbiAgICB0aGlzLmFsbFByb21pc2VzID0gW11cblxuICAgIGlmKE9iamVjdC5rZXlzKHRoaXMuYnV0dG9ucykubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IE9iamVjdC52YWx1ZXModGhpcy5idXR0b25zKVswXS5hY3Rpb24gfHwgT2JqZWN0LnZhbHVlcyh0aGlzLmJ1dHRvbnMpWzBdXG4gICAgfVxuXG4gICAgaWYoYXR0cnMuY2xhc3NOYW1lcykge1xuICAgICAgICBhdHRycy5jbGFzc05hbWVzLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgc2VsZi5mb3JtRWxlbWVudC5jbGFzc0xpc3QuYWRkKG5hbWUpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy5mb3JtRWxlbWVudC5vbnN1Ym1pdCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5lc2NIYW5kbGVyID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmNhbmNlbE1vZGFsSWZDYW5jZWxhYmxlKClcbiAgICB9XG5cbiAgICB0aGlzLmVudGVySGFuZGxlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIGZpZWxkID0gc2VsZi5maWVsZHMuZmluZChmdW5jdGlvbihmKSB7IHJldHVybiBmLm5hbWUgPT09IGUudGFyZ2V0Lm5hbWV9KVxuICAgICAgICB2YXIgY29uZmlybUJ0bkVsSUQgPSAgT2JqZWN0LnZhbHVlcyhzZWxmLmJ1dHRvbnMpLm1hcChiID0+IGIuaWQpLmZpbmQoaWQgPT4gISFpZClcbiAgICAgICAgdmFyIGNvbmZpcm1CdG5FbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNvbmZpcm1CdG5FbElEKVxuXG4gICAgICAgIGlmKCFmaWVsZCB8fCAhZmllbGQubGFyZ2V0ZXh0KSB7XG4gICAgICAgICAgICBpZighY29uZmlybUJ0bkVsIHx8ICFjb25maXJtQnRuRWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdkaXNhYmxlZCcpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jbG9zZU1vZGFsSWZPcGVuKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgIH0gZWxzZSBpZighZmllbGQuYWxsb3dOZXdsaW5lcykge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmZpZWxkcy5mb3JFYWNoKChmaWVsZCwgZmllbGRJbmRleCkgPT4ge1xuICAgICAgICB2YXIgZmllbGRXcmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICAgICAgICBmaWVsZEVsZW1lbnQsIGxhYmVsLCBhbGxvd2VkVmFsdWVzLFxuICAgICAgICAgICAgbWVzc2FnZSwgdG9vbHRpcFxuXG4gICAgICAgIGFsbG93ZWRWYWx1ZXMgPSAoZmllbGQuYWxsb3dlZFZhbHVlcyBpbnN0YW5jZW9mIEZ1bmN0aW9uKSA/XG4gICAgICAgICAgICBmaWVsZC5hbGxvd2VkVmFsdWVzKCkgOlxuICAgICAgICAgICAgZmllbGQuYWxsb3dlZFZhbHVlc1xuXG4gICAgICAgIG1lc3NhZ2UgPSAoZmllbGQubWVzc2FnZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSA/XG4gICAgICAgICAgICBmaWVsZC5tZXNzYWdlKCkgOlxuICAgICAgICAgICAgZmllbGQubWVzc2FnZVxuXG4gICAgICAgIGZpZWxkV3JhcHBlci5pZCA9ICdkbC1mb3JtLWZpZWxkLXdyYXBwZXItZm9yLScgKyBmaWVsZC5uYW1lXG4gICAgICAgIGZpZWxkV3JhcHBlci5jbGFzc0xpc3QuYWRkKCdkbC1mb3JtLWZpZWxkLXdyYXBwZXInKVxuXG4gICAgICAgIGlmKGZpZWxkLnRhYikge1xuICAgICAgICAgICAgZmllbGRXcmFwcGVyLmNsYXNzTGlzdC5hZGQoZmllbGQudGFiLnJlcGxhY2UoL1xccy9nLCAnJykpXG4gICAgICAgIH1cblxuICAgICAgICBpZihhbGxvd2VkVmFsdWVzKSB7XG4gICAgICAgICAgICBmaWVsZEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkbC1zZWxlY3QnKVxuICAgICAgICAgICAgZmllbGRXcmFwcGVyLmNsYXNzTGlzdC5hZGQoJ2RsLXNlbGVjdC13cmFwcGVyJylcbiAgICAgICAgICAgIGZpZWxkRWxlbWVudC5zZXRMb2FkaW5nU3RhdHVzKClcbiAgICAgICAgICAgIHNlbGYuaW5pdFByb21pc2VzW2ZpZWxkLm5hbWVdID0gUHJvbWlzZS5yZXNvbHZlKGFsbG93ZWRWYWx1ZXMpLnRoZW4odmFsdWVzID0+IHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMuZm9yRWFjaCgodmFsKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvcHRFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RsLW9wdGlvbicpXG4gICAgICAgICAgICAgICAgICAgIGlmKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0RWwuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHZhbFswXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdEVsLmlubmVySFRNTCA9IHZhbFsxXVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodmFsWzJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0RWwuc2V0QXR0cmlidXRlKCdkaXNwbGF5V2hlblNlbGVjdGVkJywgdmFsWzJdKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0RWwuaW5uZXJIVE1MID0gdmFsXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmaWVsZEVsZW1lbnQub25jaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZUZvcm0oZmllbGRFbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZmllbGRFbGVtZW50LmFkZE9wdGlvbihvcHRFbClcbiAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgZmllbGRFbGVtZW50LnVuc2V0TG9hZGluZ1N0YXR1cygpXG4gICAgICAgICAgICB9KS5jYXRjaChfID0+IHtcbiAgICAgICAgICAgICAgICBmaWVsZEVsZW1lbnQudW5zZXRMb2FkaW5nU3RhdHVzKClcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHRoaXMuYWxsUHJvbWlzZXMucHVzaChzZWxmLmluaXRQcm9taXNlc1tmaWVsZC5uYW1lXSlcbiAgICAgICAgfSBlbHNlIGlmIChmaWVsZC5tZXNzYWdlKSB7XG4gICAgICAgICAgICBmaWVsZEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJylcbiAgICAgICAgICAgIGZpZWxkRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdtZXNzYWdlJylcbiAgICAgICAgICAgIGZpZWxkRWxlbWVudC5pbm5lckhUTUwgPSBmaWVsZC5tZXNzYWdlXG4gICAgICAgIH0gZWxzZSBpZiAoZmllbGQuYXJyYXlPZikge1xuICAgICAgICAgICAgZmllbGRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgICAgICAgIGZpZWxkRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdhcnJheS1vZicpXG4gICAgICAgICAgICBmaWVsZEVsZW1lbnQuc2V0VmFsdWUgPSAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBmaWVsZEVsZW1lbnQudmFsdWUgPSB2YWx1ZVxuICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlRm9ybShmaWVsZEVsZW1lbnQpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZpZWxkLnJlbmRlciA9IChkb20sIGZvcm1EYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgZG9tLmlubmVySFRNTCA9ICcnXG5cbiAgICAgICAgICAgICAgICBsZXQgcmVuZGVyRW50cnkgPSBmaWVsZC5yZW5kZXJFbnRyeSB8fCAob2JqID0+IE9iamVjdC52YWx1ZXMob2JqKS5maWx0ZXIodmFsID0+ICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykgJiYgdmFsLnRyaW0oKSAhPT0gJycpLmpvaW4oJywgJykpXG5cbiAgICAgICAgICAgICAgICBpZihmaWVsZC5zdWdnZXN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN1Z2dlc3RlZENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICAgICAgICAgICAgICAgIHN1Z2dlc3RlZENvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdkbC1mb3JtLWFycmF5LXN1Z2dlc3RlZC1jb250YWluZXInKVxuICAgICAgICAgICAgICAgICAgICBsZXQgc3VnZ2VzdGVkRW50cmllcyA9IHR5cGVvZiBmaWVsZC5zdWdnZXN0ZWQgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQuc3VnZ2VzdGVkKGZvcm1EYXRhLCBtb2RhbERpYWxvZ3MubWFwKGQgPT4gZC5nZXRWYWx1ZXMoKSkpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkLnN1Z2dlc3RlZDtcblxuICAgICAgICAgICAgICAgICAgICAoc3VnZ2VzdGVkRW50cmllcyB8fCBbXSkuZm9yRWFjaCgoc3VnZ2VzdGVkRW50cnksIGZpZWxkSW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrYm94RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJylcblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNiID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2IuaWQgPSAnZmllbGQtJyArIGZpZWxkSW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiLnNldEF0dHJpYnV0ZSgndHlwZScsICdjaGVja2JveCcpXG4gICAgICAgICAgICAgICAgICAgICAgICBjYi5vbmlucHV0ID0gY2Iub25jaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQuZG9tRWxlbWVudC5hY2NlcHRlZFN1Z2dlc3Rpb25zID0gZmllbGQuZG9tRWxlbWVudC5hY2NlcHRlZFN1Z2dlc3Rpb25zIHx8IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tib3hFbC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgY2IuY2hlY2tlZClcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNiLmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQuZG9tRWxlbWVudC5hY2NlcHRlZFN1Z2dlc3Rpb25zLnB1c2goW3N1Z2dlc3RlZEVudHJ5LCBmaWVsZEluZGV4XSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZC5kb21FbGVtZW50LmFjY2VwdGVkU3VnZ2VzdGlvbnMgPSBmaWVsZC5kb21FbGVtZW50LmFjY2VwdGVkU3VnZ2VzdGlvbnMuZmlsdGVyKHggPT4geFsxXSAhPT0gZmllbGRJbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsYWJlbEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxFbC5zZXRBdHRyaWJ1dGUoJ2ZvcicsICdmaWVsZC0nICsgZmllbGRJbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsRWwuaW5uZXJIVE1MID0gcmVuZGVyRW50cnkoc3VnZ2VzdGVkRW50cnkpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrYm94RWwuY2xhc3NMaXN0LmFkZCgnY2hlY2snKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tib3hFbC5jbGFzc0xpc3QuYWRkKCdkbC1mb3JtLWFycmF5LW9mLXN1Z2dlc3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tib3hFbC5hcHBlbmRDaGlsZChjYilcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrYm94RWwuYXBwZW5kQ2hpbGQobGFiZWxFbClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrYm94RWwuc2V0QXR0cmlidXRlKCd2YWx1ZScsIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tib3hFbC5qc29uVmFsdWUgPSBzdWdnZXN0ZWRFbnRyeVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWdnZXN0ZWRDb250YWluZXIuYXBwZW5kQ2hpbGQoY2hlY2tib3hFbClcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrYm94RWxcbiAgICAgICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgICAgICBkb20uYXBwZW5kQ2hpbGQoc3VnZ2VzdGVkQ29udGFpbmVyKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGdldENvbmZpcm1CdXR0b24gPSBhY3Rpb24gPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgJ09LJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdhZGRJbnRlZ3JhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FjdGl2ZTogZm9ybURhdGEgPT4gZmllbGQuaXNWYWxpZFJlY29yZCA/IGZpZWxkLmlzVmFsaWRSZWNvcmQoZm9ybURhdGEsIHNlbGYpIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICBkb20udmFsdWUgJiYgZG9tLnZhbHVlLmZvckVhY2ggJiYgZG9tLnZhbHVlLmZvckVhY2goKGVudHJ5T2JqLCBlbEluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlbnRyeUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRlbGV0ZUVsQnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJylcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVkaXRFbEJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZUVsQnRuLmlubmVySFRNTCA9ICdSZW1vdmUnXG4gICAgICAgICAgICAgICAgICAgIGVkaXRFbEJ0bi5pbm5lckhUTUwgPSAnRWRpdCdcbiAgICAgICAgICAgICAgICAgICAgZW50cnlFbC5pbm5lckhUTUwgPSAnPHNwYW4+JyArIHJlbmRlckVudHJ5KGVudHJ5T2JqKSArICc8L3NwYW4+J1xuICAgICAgICAgICAgICAgICAgICBlbnRyeUVsLmRhdGFzZXQuRWxJbmRleCA9IGVsSW5kZXhcbiAgICAgICAgICAgICAgICAgICAgZW50cnlFbC5jbGFzc0xpc3QuYWRkKCdkbC1mb3JtLWFycmF5LW9mLWVudHJ5JylcblxuICAgICAgICAgICAgICAgICAgICBlbnRyeUVsLmFwcGVuZENoaWxkKGVkaXRFbEJ0bilcbiAgICAgICAgICAgICAgICAgICAgZW50cnlFbC5hcHBlbmRDaGlsZChkZWxldGVFbEJ0bilcblxuICAgICAgICAgICAgICAgICAgICBkZWxldGVFbEJ0bi5jbGFzc0xpc3QuYWRkKCdkZWxldGUtYXJyYXktb2YtYnRuJylcblxuICAgICAgICAgICAgICAgICAgICBlZGl0RWxCdG4uY2xhc3NMaXN0LmFkZCgnZWRpdC1hcnJheS1vZi1idG4nKVxuICAgICAgICAgICAgICAgICAgICBlZGl0RWxCdG4uZGF0YXNldC5FbEluZGV4ID0gZWxJbmRleFxuICAgICAgICAgICAgICAgICAgICBlZGl0RWxCdG4ub25jbGljayA9IGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlZGl0RmllZHMgPSBmaWVsZC5hcnJheU9mLm1hcChmaWVsZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uZmllbGQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZG9tLnZhbHVlW2RlbGV0ZUVsQnRuLmRhdGFzZXQuRWxJbmRleF1bZmllbGQubmFtZV0gfHwgJydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IERlY2xhcmF0aXZGb3JtKHsgY2xhc3NOYW1lczogW2Bmb3JtLWZvci1hcnJheS1vZi0ke2ZpZWxkLm5hbWV9YF0sIGZpZWxkczogZWRpdEZpZWRzLCBidXR0b25zOiBnZXRDb25maXJtQnV0dG9uKGZvcm1EYXRhID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb20udmFsdWUgPSBkb20udmFsdWUgfHwgW11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb20udmFsdWVbZGVsZXRlRWxCdG4uZGF0YXNldC5FbEluZGV4XSA9IGZvcm1EYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tLnNldFZhbHVlKGRvbS52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihmaWVsZC5vbkNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLmFsbFNldHRsZWQodGhpcy5hbGxQcm9taXNlcykudGhlbigoKSA9PiBmaWVsZC5vbkNoYW5nZSh0aGlzLmdldFZhbHVlcygpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSB9LCAoKSA9PiB7fSwgKCkgPT4ge30pLm9wZW5Jbk1vZGFsKClcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZUVsQnRuLmRhdGFzZXQuRWxJbmRleCA9IGVsSW5kZXhcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlRWxCdG4ub25jbGljayA9IGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tLnZhbHVlLnNwbGljZShkZWxldGVFbEJ0bi5kYXRhc2V0LkVsSW5kZXgsIDEpXG4gICAgICAgICAgICAgICAgICAgICAgICBkb20uc2V0VmFsdWUoZG9tLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihmaWVsZC5vbkNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2UuYWxsU2V0dGxlZCh0aGlzLmFsbFByb21pc2VzKS50aGVuKCgpID0+IGZpZWxkLm9uQ2hhbmdlKHRoaXMuZ2V0VmFsdWVzKCkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZG9tLmFwcGVuZENoaWxkKGVudHJ5RWwpXG4gICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgIGxldCBhZGRCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKVxuICAgICAgICAgICAgICAgIGFkZEJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdkbC1mb3JtLWFycmF5LW9mLWFkZC1lbnRyeScpXG4gICAgICAgICAgICAgICAgYWRkQnV0dG9uLmlubmVySFRNTCA9IGZpZWxkLm5ld0J1dHRvbkxhYmVsIHx8ICdBZGQnXG5cbiAgICAgICAgICAgICAgICBhZGRCdXR0b24ub25jbGljayA9IGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBuZXcgRGVjbGFyYXRpdkZvcm0oeyBjbGFzc05hbWVzOiBbYGZvcm0tZm9yLWFycmF5LW9mLSR7ZmllbGQubmFtZX1gXSwgZmllbGRzOiBmaWVsZC5hcnJheU9mLCBidXR0b25zOiBnZXRDb25maXJtQnV0dG9uKGZvcm1EYXRhID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbS52YWx1ZSA9IGRvbS52YWx1ZSB8fCBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tLnZhbHVlLnB1c2goZm9ybURhdGEpXG4gICAgICAgICAgICAgICAgICAgICAgICBkb20uc2V0VmFsdWUoZG9tLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZmllbGQub25DaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLmFsbCh0aGlzLmFsbFByb21pc2VzKS50aGVuKCgpID0+IGZpZWxkLm9uQ2hhbmdlKHRoaXMuZ2V0VmFsdWVzKCkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KX0sICgpID0+IHt9LCAoKSA9PiB7fSkub3BlbkluTW9kYWwoKVxuXG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRvbS5hcHBlbmRDaGlsZChhZGRCdXR0b24pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZpZWxkLnJlbmRlcihmaWVsZEVsZW1lbnQsIHNlbGYuZm9ybURhdGEsIHNlbGYpXG4gICAgICAgIH0gZWxzZSBpZiAoZmllbGQucmVuZGVyKSB7XG4gICAgICAgICAgICBmaWVsZEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJylcbiAgICAgICAgICAgIGZpZWxkRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdyZW5kZXInKVxuXG4gICAgICAgICAgICBmaWVsZEVsZW1lbnQub25DaGFuZ2UgPSBmdW5jdGlvbiAoZm9yY2VGb3JtVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi51cGRhdGVGb3JtKGZpZWxkRWxlbWVudCwgZm9yY2VGb3JtVXBkYXRlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmllbGQucmVuZGVyKGZpZWxkRWxlbWVudCwgc2VsZi5mb3JtRGF0YSwgc2VsZilcbiAgICAgICAgfSBlbHNlIGlmIChmaWVsZC5sYXJnZXRleHQpIHtcbiAgICAgICAgICAgIGZpZWxkRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJylcbiAgICAgICAgICAgIGZpZWxkRWxlbWVudC5vbmlucHV0ID0gZmllbGRFbGVtZW50Lm9uY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi51cGRhdGVGb3JtKGZpZWxkRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZmllbGQuY2hlY2spIHtcbiAgICAgICAgICAgIGZpZWxkRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKVxuXG4gICAgICAgICAgICBsZXQgY2IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpXG4gICAgICAgICAgICBjYi5pZCA9ICdmaWVsZC0nICsgZmllbGRJbmRleFxuICAgICAgICAgICAgY2Iuc2V0QXR0cmlidXRlKCd0eXBlJywgJ2NoZWNrYm94JylcbiAgICAgICAgICAgIGNiLm9uaW5wdXQgPSBjYi5vbmNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGZpZWxkRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgY2IuY2hlY2tlZClcbiAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZUZvcm0oY2IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgbGFiZWxFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJylcbiAgICAgICAgICAgIGxhYmVsRWwuc2V0QXR0cmlidXRlKCdmb3InLCAnZmllbGQtJyArIGZpZWxkSW5kZXgpXG4gICAgICAgICAgICBsYWJlbEVsLmlubmVySFRNTCA9IGZpZWxkLmNoZWNrXG5cbiAgICAgICAgICAgIGZpZWxkRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdjaGVjaycpXG4gICAgICAgICAgICBmaWVsZEVsZW1lbnQuYXBwZW5kQ2hpbGQoY2IpXG4gICAgICAgICAgICBmaWVsZEVsZW1lbnQuYXBwZW5kQ2hpbGQobGFiZWxFbClcbiAgICAgICAgICAgIGZpZWxkRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgdHlwZW9mIGZpZWxkLmRlZmF1bHRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IGZpZWxkLmRlZmF1bHRWYWx1ZShzZWxmLmZvcm1EYXRhKSA6IGZpZWxkLmRlZmF1bHRWYWx1ZSlcbiAgICAgICAgICAgIGZpZWxkRWxlbWVudC5zZXRWYWx1ZSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgIGNiLmNoZWNrZWQgPSAhIXZhbFxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGZpZWxkLmRldGFpbGVkT3B0aW9ucykge1xuICAgICAgICAgICAgZmllbGRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgICAgICAgIGZpZWxkRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdkZXRhaWxlZC1vcHRpb25zJylcblxuICAgICAgICAgICAgZmllbGQuZGV0YWlsZWRPcHRpb25zLmZvckVhY2goZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbkVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgb3B0aW9uRWwuY2xhc3NMaXN0LmFkZCgnZGV0YWlsZWQtb3B0aW9uJyk7XG5cbiAgICAgICAgICAgICAgICBvcHRpb25FbC5pbm5lckhUTUwgPSBvcHRpb24uaHRtbDtcbiAgICAgICAgICAgICAgICBvcHRpb25FbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtdmFsdWUnLCBvcHRpb24udmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgb3B0aW9uRWwuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZEVsZW1lbnQudmFsdWUgPSBvcHRpb24udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkRWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZGV0YWlsZWQtb3B0aW9uJykuZm9yRWFjaChmdW5jdGlvbihvcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbi5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uRWwuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlRm9ybShvcHRpb25FbCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBmaWVsZEVsZW1lbnQuYXBwZW5kQ2hpbGQob3B0aW9uRWwpXG4gICAgICAgICAgICAgICAgZmllbGRFbGVtZW50LnNldFZhbHVlID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IGZpZWxkRWxlbWVudC5xdWVyeVNlbGVjdG9yKGBkaXZbZGF0YS12YWx1ZT1cIiR7dmFsfVwiXWApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKCFlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZmllbGRFbGVtZW50LnZhbHVlID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICBmaWVsZEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmRldGFpbGVkLW9wdGlvbicpLmZvckVhY2goZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb24uY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGZpZWxkLmNhbGN1bGF0ZSkge1xuICAgICAgICAgICAgZmllbGRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKVxuICAgICAgICAgICAgZmllbGRFbGVtZW50LnR5cGUgPSAnaGlkZGVuJ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmllbGRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKVxuICAgICAgICAgICAgZmllbGRFbGVtZW50LnNldFZhbHVlID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgZmllbGRFbGVtZW50LnZhbHVlID0gdmFsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihmaWVsZC5pbnB1dFR5cGUpIHtcbiAgICAgICAgICAgICAgICBmaWVsZEVsZW1lbnQuc2V0QXR0cmlidXRlKCd0eXBlJywgZmllbGQuaW5wdXRUeXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoZmllbGQuYXV0b2NvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgZmllbGRFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXV0b2NvbXBsZXRlJywgZmllbGQuYXV0b2NvbXBsZXRlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoZmllbGQucGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgICBmaWVsZEVsZW1lbnQucGxhY2Vob2xkZXIgPSBmaWVsZC5wbGFjZWhvbGRlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmllbGRFbGVtZW50Lm9uaW5wdXQgPSBmaWVsZEVsZW1lbnQub25jaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZUZvcm0oZmllbGRFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZpZWxkLmRvbUVsZW1lbnQgPSBmaWVsZEVsZW1lbnRcbiAgICAgICAgZmllbGRFbGVtZW50Lm5hbWUgPSBmaWVsZC5uYW1lXG4gICAgICAgIGZpZWxkRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ25hbWUnLCBmaWVsZC5uYW1lKVxuXG4gICAgICAgIGlmKGZpZWxkLmRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgICBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJylcbiAgICAgICAgICAgIGxhYmVsLmlubmVySFRNTCA9IGZpZWxkLmRpc3BsYXlOYW1lXG4gICAgICAgICAgICBsYWJlbC5zZXRBdHRyaWJ1dGUoJ2ZvcicsIGZpZWxkLm5hbWUpXG4gICAgICAgICAgICBmaWVsZFdyYXBwZXIuYXBwZW5kQ2hpbGQobGFiZWwpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaWVsZFdyYXBwZXIuY2xhc3NMaXN0LmFkZCgnd2l0aG91dExhYmVsJylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGZpZWxkLnRvb2x0aXApIHtcbiAgICAgICAgICAgIHRvb2x0aXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJylcbiAgICAgICAgICAgIHRvb2x0aXAuZGF0YXNldFsndGlwcHlDb250ZW50J10gPSBmaWVsZC50b29sdGlwLnRleHQgfHwgZmllbGQudG9vbHRpcFxuICAgICAgICAgICAgdG9vbHRpcC5kYXRhc2V0Wydpbml0aWFsVGlwcHlDb250ZW50J10gPSBmaWVsZC50b29sdGlwLnRleHQgfHwgZmllbGQudG9vbHRpcFxuICAgICAgICAgICAgdG9vbHRpcC5jbGFzc0xpc3QuYWRkKCdkbC10b29sdGlwJylcbiAgICAgICAgICAgIHRvb2x0aXAuaW5uZXJIVE1MID0gJz8nXG5cbiAgICAgICAgICAgIGlmKGxhYmVsICYmICFmaWVsZC50b29sdGlwLmluSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBsYWJlbC5hcHBlbmRDaGlsZCh0b29sdGlwKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b29sdGlwLmNsYXNzTGlzdC5hZGQoJ2RsLXRvb2x0aXAtaW4taW5wdXQnKVxuICAgICAgICAgICAgICAgIGZpZWxkRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdkbC10b29sdGlwLWluc2lkZScpXG4gICAgICAgICAgICAgICAgZmllbGRXcmFwcGVyLmFwcGVuZENoaWxkKHRvb2x0aXApXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZihmaWVsZEVsZW1lbnQudHlwZSA9PT0gJ2hpZGRlbicpIHtcbiAgICAgICAgICAgIGZpZWxkV3JhcHBlci5jbGFzc0xpc3QuYWRkKCdkbC1mb3JtLWhpZGRlbi1maWVsZCcpXG4gICAgICAgIH1cblxuICAgICAgICBmaWVsZFdyYXBwZXIuYXBwZW5kQ2hpbGQoZmllbGRFbGVtZW50KVxuICAgICAgICBzZWxmLmRvbS5jaGlsZHJlblswXS5hcHBlbmRDaGlsZChmaWVsZFdyYXBwZXIpXG5cbiAgICAgICAgaWYoZmllbGQuZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmFsbFByb21pc2VzLnB1c2goUHJvbWlzZS5yZXNvbHZlKHNlbGYuaW5pdFByb21pc2VzW2ZpZWxkLm5hbWVdKS50aGVuKF8gPT4ge1xuICAgICAgICAgICAgICAgIGxldCB0bXBEZWZhdWx0VmFsdWUgPSB0eXBlb2YgZmllbGQuZGVmYXVsdFZhbHVlID09PSAnZnVuY3Rpb24nID8gZmllbGQuZGVmYXVsdFZhbHVlKHNlbGYuZm9ybURhdGEpIDogZmllbGQuZGVmYXVsdFZhbHVlXG5cbiAgICAgICAgICAgICAgICBpZihmaWVsZEVsZW1lbnQuc2V0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRFbGVtZW50LnNldFZhbHVlKHRtcERlZmF1bHRWYWx1ZSlcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZpZWxkRWxlbWVudC50YWdOYW1lID09PSAnSU5QVVQnIHx8IGZpZWxkRWxlbWVudC50YWdOYW1lID09PSAnVEVYVEFSRUEnKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkRWxlbWVudC52YWx1ZSA9IHRtcERlZmF1bHRWYWx1ZVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgdG1wRGVmYXVsdFZhbHVlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKVxuICAgICAgICB9XG4gICAgfSlcblxuICAgIFByb21pc2UuYWxsU2V0dGxlZCh0aGlzLmFsbFByb21pc2VzKS50aGVuKF8gPT4gc2VsZi51cGRhdGVGb3JtKCkpXG59XG5cbkRlY2xhcmF0aXZGb3JtLnByb3RvdHlwZSA9IHtcblxuICAgIHVwZGF0ZUZvcm06IGZ1bmN0aW9uKHRyaWdnZXJFbGVtZW50LCBmb3JjZUZvcm1VcGRhdGUpIHtcbiAgICAgICAgdmFyIGZvcm1EYXRhID0gdGhpcy5nZXRWYWx1ZXMoKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgICAgIHZhciB0cmlnZ2VyRmllbGROYW1lID0gdHJpZ2dlckVsZW1lbnQgJiYgdHJpZ2dlckVsZW1lbnQubmFtZVxuXG4gICAgICAgIGlmKHRoaXMuX2xhc3RGcm9tVXBkYXRTYXRlID09PSBKU09OLnN0cmluZ2lmeShmb3JtRGF0YSkgJiYgIWZvcmNlRm9ybVVwZGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbGFzdEZyb21VcGRhdFNhdGUgPSBKU09OLnN0cmluZ2lmeShmb3JtRGF0YSlcblxuICAgICAgICB0aGlzLmZpZWxkcy5mb3JFYWNoKGZpZWxkID0+IHtcbiAgICAgICAgICAgIHZhciBzaG91bGRSZWxvYWQgPSAoIXRyaWdnZXJGaWVsZE5hbWUgfHwgKGZpZWxkLnJlbG9hZE9uQ2hhbmdlT2YgJiYgZmllbGQucmVsb2FkT25DaGFuZ2VPZi5pbmNsdWRlcyh0cmlnZ2VyRmllbGROYW1lKSkpXG5cbiAgICAgICAgICAgIGlmKCFmaWVsZC5kb21FbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihmaWVsZC5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgICAgIGxldCB0bXBJc0FjdGl2ZSA9IGZpZWxkLmlzQWN0aXZlKGZvcm1EYXRhLCBtb2RhbERpYWxvZ3MubWFwKGQgPT4gZC5nZXRWYWx1ZXMoKSkpXG4gICAgICAgICAgICAgICAgaWYodG1wSXNBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQuZG9tRWxlbWVudC5wYXJlbnRFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2luYWN0aXZlJylcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZC5kb21FbGVtZW50LnBhcmVudEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnaW5hY3RpdmUnKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoZmllbGQub25Gb3JtQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgZmllbGQub25Gb3JtQ2hhbmdlKGZvcm1EYXRhLCBzZWxmLCB0cmlnZ2VyRWxlbWVudClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoZmllbGQucmVuZGVyKSB7XG4gICAgICAgICAgICAgICAgZmllbGQucmVuZGVyKGZpZWxkLmRvbUVsZW1lbnQsIGZvcm1EYXRhLCBzZWxmKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihmaWVsZC5hbGxvd2VkVmFsdWVzIGluc3RhbmNlb2YgRnVuY3Rpb24gJiYgc2hvdWxkUmVsb2FkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWxsb3dlZFZhbHVlcyA9IGZpZWxkLmFsbG93ZWRWYWx1ZXMoZm9ybURhdGEpXG4gICAgICAgICAgICAgICAgZmllbGQuZG9tRWxlbWVudC5zZXRMb2FkaW5nU3RhdHVzKClcbiAgICAgICAgICAgICAgICB0aGlzLmFsbFByb21pc2VzLnB1c2goYWxsb3dlZFZhbHVlcylcblxuICAgICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShhbGxvd2VkVmFsdWVzKS50aGVuKHZhbHVlcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXRUb29sdGlwKGZpZWxkLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkLmRvbUVsZW1lbnQucmVtb3ZlQWxsT3B0aW9ucygpXG5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzICYmIHZhbHVlcy5mb3JFYWNoKCh2YWwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvcHRFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RsLW9wdGlvbicpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRFbC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgdmFsWzBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdEVsLmlubmVySFRNTCA9IHZhbFsxXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHZhbFsyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRFbC5zZXRBdHRyaWJ1dGUoJ2Rpc3BsYXlXaGVuU2VsZWN0ZWQnLCB2YWxbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRFbC5pbm5lckhUTUwgPSB2YWxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQuZG9tRWxlbWVudC5vbmNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlRm9ybShmaWVsZC5kb21FbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZC5kb21FbGVtZW50LmFkZE9wdGlvbihvcHRFbClcbiAgICAgICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgICAgICBmaWVsZC5kb21FbGVtZW50LnVuc2V0TG9hZGluZ1N0YXR1cygpXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkLmRvbUVsZW1lbnQuc2V0VmFsdWUoZmllbGQuZG9tRWxlbWVudC5nZXRWYWx1ZSgpKVxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkLmRvbUVsZW1lbnQudW5zZXRMb2FkaW5nU3RhdHVzKClcbiAgICAgICAgICAgICAgICAgICAgaWYoZmllbGQub25WYWx1ZXNDYWxjdWxhdGlvbkZhaWxlZE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBmaWVsZC5vblZhbHVlc0NhbGN1bGF0aW9uRmFpbGVkTWVzc2FnZShmb3JtRGF0YSwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG1lc3NhZ2UubGV2ZWwgPT09ICdpbmZvJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0VG9vbHRpcFdhcm5pbmcoZmllbGQubmFtZSwgbWVzc2FnZS50ZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKG1lc3NhZ2UubGV2ZWwgPT09ICd3YXJuaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0VG9vbHRpcFdhcm5pbmcoZmllbGQubmFtZSwgbWVzc2FnZS50ZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKG1lc3NhZ2UubGV2ZWwgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFRvb2x0aXBFcnJvcihmaWVsZC5uYW1lLCBtZXNzYWdlLnRleHQpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBQcm9taXNlLmFsbFNldHRsZWQodGhpcy5hbGxQcm9taXNlcykudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBmb3JtRGF0YSA9IHRoaXMuZ2V0VmFsdWVzKCk7XG5cbiAgICAgICAgICAgIE9iamVjdC52YWx1ZXModGhpcy5idXR0b25zKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoYnRuID0+IChidG4uaXNBY3RpdmUgJiYgYnRuLmlkKSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChidG4gPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYnV0dG9uRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChidG4uaWQpXG4gICAgICAgICAgICAgICAgICAgIGlmKCFidXR0b25FbCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbkVsLmNsYXNzTGlzdC5hZGQoJ2Rpc2FibGVkJylcblxuICAgICAgICAgICAgICAgICAgICBsZXQgaXNBY3RpdmVDaGVja1BybWlzZSA9IGJ0bi5pc0FjdGl2ZShmb3JtRGF0YSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbGxQcm9taXNlcy5wdXNoKGlzQWN0aXZlQ2hlY2tQcm1pc2UpXG5cbiAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGlzQWN0aXZlQ2hlY2tQcm1pc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihCdG5Jc0FjdGl2ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoQnRuSXNBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uRWwuY2xhc3NMaXN0LnJlbW92ZSgnZGlzYWJsZWQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkVsLmNsYXNzTGlzdC5hZGQoJ2Rpc2FibGVkJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgIH0sXG5cbiAgICB1cGRhdGVDYWxjdWxhdGVkRmllbGRzKHRyaWdnZXJGaWVsZE5hbWUsIGZvcm1EYXRhKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbFNldHRsZWQodGhpcy5maWVsZHMubWFwKGZpZWxkID0+IG5ldyBQcm9taXNlKGRvbmUgPT4ge1xuICAgICAgICAgICAgdmFyIHNob3VsZFJlbG9hZCA9ICghdHJpZ2dlckZpZWxkTmFtZSB8fCAoZmllbGQucmVsb2FkT25DaGFuZ2VPZiAmJiBmaWVsZC5yZWxvYWRPbkNoYW5nZU9mLmluY2x1ZGVzKHRyaWdnZXJGaWVsZE5hbWUpKSlcblxuICAgICAgICAgICAgaWYoZmllbGQuY2FsY3VsYXRlICYmIHNob3VsZFJlbG9hZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbFNldHRsZWQodGhpcy5hbGxQcm9taXNlcykudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRoaXNVcGRhdGVQcm9taXNlID0gZmllbGQuY2FsY3VsYXRlKGZvcm1EYXRhIHx8IHRoaXMuZ2V0VmFsdWVzKCkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWxsUHJvbWlzZXMucHVzaCh0aGlzVXBkYXRlUHJvbWlzZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzVXBkYXRlUHJvbWlzZSkudGhlbih2ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkLmRvbUVsZW1lbnQuX3ZhbHVlID0gdlxuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZG9uZSgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKSlcbiAgICB9LFxuXG4gICAgZ2V0SFRNTDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvbS5vdXRlckhUTUw7XG4gICAgfSxcblxuICAgIG9wZW5Jbk1vZGFsOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICAgIG1vZGFsRGlhbG9ncy5wdXNoKHRoaXMpO1xuXG4gICAgICAgIHRoaXMubW9kYWxFbCA9IHRoaXMubW9kYWxFbCB8fCB0aGlzLmNyZWF0ZU1vZGFsRWxlbWVudChhdHRyKVxuXG4gICAgICAgIHZhciBtb2RhbENvbnRlbnQgPSB0aGlzLm1vZGFsRWwucXVlcnlTZWxlY3RvcignLm1vZGFsLWNvbnRlbnQnKVxuICAgICAgICB2YXIgbW9kYWxXaW5kb3cgPSB0aGlzLm1vZGFsRWwucXVlcnlTZWxlY3RvcignLm1vZGFsJylcblxuICAgICAgICB0aGlzLnVwZGF0ZVRhYnMoKVxuICAgICAgICBtb2RhbENvbnRlbnQuYXBwZW5kQ2hpbGQodGhpcy5kb20pXG4gICAgICAgIHRoaXMubW9kYWxFbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuXG4gICAgICAgIGlmKGF0dHIgJiYgYXR0ci5jbGFzc05hbWVzKSB7XG4gICAgICAgICAgICBhdHRyLmNsYXNzTmFtZXMuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgbW9kYWxXaW5kb3cuY2xhc3NMaXN0LmFkZChuYW1lKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlVG9vbHRpcHMoKTtcblxuICAgICAgICBpZihtb2RhbERpYWxvZ3MubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgIG1vZGFsRGlhbG9nc1ttb2RhbERpYWxvZ3MubGVuZ3RoLTJdLmhpZGUoKVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGFwcGVuZEluRWxlbWVudDogZnVuY3Rpb24oZWwsIGF0dHIpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgICAgIHRoaXMubW9kYWxFbCA9IHRoaXMubW9kYWxFbCB8fCB0aGlzLmNyZWF0ZU1vZGFsRWxlbWVudChhdHRyLCB0cnVlKVxuICAgICAgICB0aGlzLm1vZGFsRWwuc3R5bGUuZGlzcGxheSA9ICdibG9jaydcblxuICAgICAgICB2YXIgbW9kYWxDb250ZW50ID0gdGhpcy5tb2RhbEVsLnF1ZXJ5U2VsZWN0b3IoJy5tb2RhbC1jb250ZW50JylcblxuICAgICAgICB0aGlzLm1vZGFsRWwuY2xhc3NMaXN0LmFkZCgnbm9Nb2RhbERpYWxvZycpXG5cbiAgICAgICAgaWYoYXR0ciAmJiBhdHRyLmNsYXNzTmFtZXMpIHtcbiAgICAgICAgICAgIGF0dHIuY2xhc3NOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLm1vZGFsRWwuY2xhc3NMaXN0LmFkZChuYW1lKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIG1vZGFsQ29udGVudC5hcHBlbmRDaGlsZCh0aGlzLmRvbSlcbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5tb2RhbEVsKVxuICAgICAgICB0aGlzLnVwZGF0ZVRhYnMoKVxuXG4gICAgICAgIHRoaXMudXBkYXRlVG9vbHRpcHMoKVxuICAgIH0sXG5cbiAgICBoaWRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5tb2RhbEVsICYmIHRoaXMubW9kYWxFbC5jbGFzc0xpc3QuYWRkKCdkbC1tb2RhbC1oaWRkZW4nKVxuICAgIH0sXG5cbiAgICBzaG93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5tb2RhbEVsICYmIHRoaXMubW9kYWxFbC5jbGFzc0xpc3QucmVtb3ZlKCdkbC1tb2RhbC1oaWRkZW4nKVxuICAgIH0sXG5cbiAgICB1cGRhdGVUb29sdGlwczogZnVuY3Rpb24oc2VsKSB7XG4gICAgICAgIHNlbCA9IHNlbCB8fCAnW2RhdGEtdGlwcHktY29udGVudF0nO1xuXG4gICAgICAgIHZhciBkb21FbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsKTtcblxuICAgICAgICBkb21FbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgIGlmKHRpcHB5SW5zdGFuY2VzLmdldChlbCkpIHtcbiAgICAgICAgICAgICAgICB0aXBweUluc3RhbmNlcy5nZXQoZWwpLmZvckVhY2goZWwgPT4gZWwuZGVzdHJveSgpKTtcbiAgICAgICAgICAgICAgICB0aXBweUluc3RhbmNlcy5kZWxldGUoZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIHZhciB0aXBwaWVzID0gdGlwcHkoc2VsLCB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6ICdyaWdodCcsXG4gICAgICAgICAgICBhbGxvd0hUTUw6IHRydWUsXG4gICAgICAgICAgICBpbnRlcmFjdGl2ZTogdHJ1ZVxuICAgICAgICB9KVxuXG4gICAgICAgIHRpcHBpZXMuZm9yRWFjaCh0aXBweSA9PiB7XG4gICAgICAgICAgICBpZih0aXBweUluc3RhbmNlcy5nZXQodGlwcHkucmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgICAgIHRpcHB5SW5zdGFuY2VzLmdldCh0aXBweS5yZWZlcmVuY2UpLnB1c2godGlwcHkpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRpcHB5SW5zdGFuY2VzLnNldCh0aXBweS5yZWZlcmVuY2UsIFt0aXBweV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgc2V0VG9vbHRpcDogZnVuY3Rpb24oZmllbGROYW1lLCB0ZXh0LCBpY29uQ29udGVudCwgY2xhc3NOYW1lKSB7XG4gICAgICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZSB8fCAnJztcbiAgICAgICAgdmFyIHRvb2x0aXBTZWxlY3RvciA9IGAjZGwtZm9ybS1maWVsZC13cmFwcGVyLWZvci0ke2ZpZWxkTmFtZX0gLmRsLXRvb2x0aXBgO1xuICAgICAgICB2YXIgdG9vbHRpcEVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0b29sdGlwU2VsZWN0b3IpO1xuXG4gICAgICAgIGlmKHRvb2x0aXBFbC5jbGFzc0xpc3QudmFsdWUuaW5jbHVkZXMoJ2RsLXRvb2x0aXAtaW4taW5wdXQnKSkge1xuICAgICAgICAgICAgdG9vbHRpcEVsLmNsYXNzTGlzdC52YWx1ZSA9IGBkbC10b29sdGlwIGRsLXRvb2x0aXAtaW4taW5wdXQgJHtjbGFzc05hbWV9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvb2x0aXBFbC5jbGFzc0xpc3QudmFsdWUgPSBgZGwtdG9vbHRpcCAke2NsYXNzTmFtZX1gO1xuICAgICAgICB9XG5cbiAgICAgICAgdG9vbHRpcEVsLmRhdGFzZXRbJ3RpcHB5Q29udGVudCddID0gdGV4dDtcbiAgICAgICAgdG9vbHRpcEVsLmlubmVySFRNTCA9IGljb25Db250ZW50O1xuXG4gICAgICAgIHRoaXMudXBkYXRlVG9vbHRpcHModG9vbHRpcFNlbGVjdG9yKTtcbiAgICB9LFxuXG4gICAgc2V0VG9vbHRpcFN1Y2Nlc3M6IGZ1bmN0aW9uKGZpZWxkTmFtZSwgdGV4dCkge1xuICAgICAgICB0aGlzLnNldFRvb2x0aXAoZmllbGROYW1lLCB0ZXh0LCAnJiMxMDAwMzsnLCAndG9vbHRpcC1zdWNjZXNzJylcbiAgICB9LFxuXG4gICAgc2V0VG9vbHRpcFdhcm5pbmc6IGZ1bmN0aW9uKGZpZWxkTmFtZSwgdGV4dCkge1xuICAgICAgICB0aGlzLnNldFRvb2x0aXAoZmllbGROYW1lLCB0ZXh0LCAnIScsICd0b29sdGlwLXdhcm5pbmcnKTtcbiAgICB9LFxuXG4gICAgc2V0VG9vbHRpcEVycm9yOiBmdW5jdGlvbihmaWVsZE5hbWUsIHRleHQpIHtcbiAgICAgICAgdGhpcy5zZXRUb29sdGlwKGZpZWxkTmFtZSwgdGV4dCwgJyEnLCAndG9vbHRpcC1lcnJvcicpO1xuICAgIH0sXG5cbiAgICByZXNldFRvb2x0aXA6IGZ1bmN0aW9uKGZpZWxkTmFtZSkge1xuICAgICAgICB2YXIgdG9vbHRpcEVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgI2RsLWZvcm0tZmllbGQtd3JhcHBlci1mb3ItJHtmaWVsZE5hbWV9IC5kbC10b29sdGlwYCk7XG5cbiAgICAgICAgaWYodG9vbHRpcEVsKSB7XG4gICAgICAgICAgICB0aGlzLnNldFRvb2x0aXAoZmllbGROYW1lLCB0b29sdGlwRWwuZGF0YXNldFsnaW5pdGlhbFRpcHB5Q29udGVudCddLCAnPycsICcnKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZXNldFRvb2x0aXBzOiBmdW5jdGlvbihmaWVsZE5hbWVzKSB7XG4gICAgICAgIGZpZWxkTmFtZXMuZm9yRWFjaChmaWVsZE5hbWUgPT4gdGhpcy5yZXNldFRvb2x0aXAoZmllbGROYW1lKSlcbiAgICB9LFxuXG4gICAgdXBkYXRlVGFiczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0YWJzV3JhcHBlciA9IHRoaXMubW9kYWxFbC5xdWVyeVNlbGVjdG9yKCcudGFiV3JhcHBlcicpLFxuICAgICAgICAgICAgdGFicyA9IHRoaXMuZmllbGRzLmZpbHRlcihmID0+IGYudGFiKS5tYXAoZiA9PiBmLnRhYikuZmlsdGVyKCh2YWx1ZSwgaW5kZXgsIHNlbGYpID0+IHNlbGYuaW5kZXhPZih2YWx1ZSkgPT09IGluZGV4KSxcbiAgICAgICAgICAgIHNlbGYgPSB0aGlzLCB0bXBUYWJFbFxuXG4gICAgICAgIHRhYnNXcmFwcGVyLmlubmVySFRNTCA9ICcnXG5cbiAgICAgICAgdGFicy5mb3JFYWNoKCh0YWIpID0+IHtcbiAgICAgICAgICAgIHRtcFRhYkVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgICAgICAgIHRtcFRhYkVsLmNsYXNzTGlzdC5hZGQoJ2RsLXRhYi1idG4nKVxuICAgICAgICAgICAgdG1wVGFiRWwuY2xhc3NMaXN0LmFkZCh0YWIucmVwbGFjZSgvXFxzL2csICcnKSlcbiAgICAgICAgICAgIHRtcFRhYkVsLmlubmVySFRNTCA9IHRhYlxuICAgICAgICAgICAgdG1wVGFiRWwub25jbGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuc2V0QWN0aXZlVGFiKHRhYilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhYnNXcmFwcGVyLmFwcGVuZENoaWxkKHRtcFRhYkVsKVxuICAgICAgICB9KVxuXG4gICAgICAgIGlmKHRhYnNbMF0pIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QWN0aXZlVGFiKHRhYnNbMF0pXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0QWN0aXZlVGFiOiBmdW5jdGlvbih0YWIpIHtcbiAgICAgICAgaWYoIXRhYikge1xuICAgICAgICAgICAgdGFiID0gdGhpcy5hY3RpdmVUYWJcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0YWJDbGFzc05hbWUgPSB0YWIucmVwbGFjZSgvXFxzL2csICcnKSxcbiAgICAgICAgICAgIGN1cnJlbnRBY3RpdmVUYWJCdG4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZGwtdGFiLWJ0bi5hY3RpdmUnKSxcbiAgICAgICAgICAgIHRhYkJ0biA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5kbC10YWItYnRuLicgKyB0YWJDbGFzc05hbWUpXG5cbiAgICAgICAgaWYoY3VycmVudEFjdGl2ZVRhYkJ0bikge1xuICAgICAgICAgICAgY3VycmVudEFjdGl2ZVRhYkJ0bi5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKVxuICAgICAgICB9XG5cbiAgICAgICAgdGFiQnRuLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpXG5cbiAgICAgICAgdGhpcy5hY3RpdmVUYWIgPSB0YWI7XG4gICAgICAgIHRoaXMuZmllbGRzLmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgICAgICAgaWYoIWZpZWxkLmRvbUVsZW1lbnQpIHsgcmV0dXJuIH1cbiAgICAgICAgICAgIGlmKGZpZWxkLnRhYiA9PT0gdGFiKSB7XG4gICAgICAgICAgICAgICAgZmllbGQuZG9tRWxlbWVudC5wYXJlbnRFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ25vdEluVGFiJylcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmllbGQuZG9tRWxlbWVudC5wYXJlbnRFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ25vdEluVGFiJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9LFxuXG4gICAgZGVsZXRlRnJvbVN0YWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgbW9kYWxEaWFsb2dzID0gbW9kYWxEaWFsb2dzLmZpbHRlcihkaWEgPT4gZGlhICE9PSB0aGlzKVxuICAgIH0sXG5cbiAgICBjYW5jZWxNb2RhbElmQ2FuY2VsYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmKHRoaXMub25DYW5jZWxDYWxsYmFjaykge1xuICAgICAgICAgICAgaWYodGhpcy5tb2RhbEVsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RhbEVsLnJlbW92ZSgpXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RhbEVsID0gbnVsbFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm9uQ2FuY2VsQ2FsbGJhY2soKVxuICAgICAgICAgICAgdGhpcy5kZWxldGVGcm9tU3RhY2soKVxuXG4gICAgICAgICAgICBpZihtb2RhbERpYWxvZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbW9kYWxEaWFsb2dzW21vZGFsRGlhbG9ncy5sZW5ndGgtMV0uc2hvdygpXG4gICAgICAgICAgICAgICAgbW9kYWxEaWFsb2dzW21vZGFsRGlhbG9ncy5sZW5ndGgtMV0uc2V0QWN0aXZlVGFiKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjbG9zZU1vZGFsSWZPcGVuOiBmdW5jdGlvbihjYWxsYWJhY2spIHtcbiAgICAgICAgY2FsbGFiYWNrID0gY2FsbGFiYWNrIHx8IHRoaXMub25DaGFuZ2VDYWxsYmFja1xuXG4gICAgICAgIGlmKHRoaXMubW9kYWxFbCkge1xuICAgICAgICAgICAgdGhpcy5tb2RhbEVsLnJlbW92ZSgpXG4gICAgICAgICAgICB0aGlzLm1vZGFsRWwgPSBudWxsXG4gICAgICAgIH1cblxuICAgICAgICBpZihjYWxsYWJhY2spIHtcbiAgICAgICAgICAgIGNhbGxhYmFjayh0aGlzLmdldFZhbHVlcygpKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kZWxldGVGcm9tU3RhY2soKVxuXG4gICAgICAgIGlmKG1vZGFsRGlhbG9ncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG1vZGFsRGlhbG9nc1ttb2RhbERpYWxvZ3MubGVuZ3RoLTFdLnNob3coKVxuICAgICAgICAgICAgbW9kYWxEaWFsb2dzW21vZGFsRGlhbG9ncy5sZW5ndGgtMV0uc2V0QWN0aXZlVGFiKClcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRWYWx1ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVzdWx0ICA9IHt9XG5cbiAgICAgICAgLy9UT0RPOiBmaWx0ZXIgY2FsY3VsYXRlZCBmaWVsZHNcbiAgICAgICAgdGhpcy5maWVsZHMuZmlsdGVyKGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmllbGQuZG9tRWxlbWVudCAmJiAhZmllbGQuZG9tRWxlbWVudC5wYXJlbnRFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnaW5hY3RpdmUnKVxuICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgICAgICAgICBpZighZmllbGQuZG9tRWxlbWVudCkgeyByZXR1cm4gfVxuICAgICAgICAgICAgcmVzdWx0W2ZpZWxkLm5hbWVdID0gZmllbGQuZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJykgfHwgZmllbGQuZG9tRWxlbWVudC5fdmFsdWUgfHwgZmllbGQuZG9tRWxlbWVudC52YWx1ZVxuXG4gICAgICAgICAgICBpZihmaWVsZC5kb21FbGVtZW50LmFjY2VwdGVkU3VnZ2VzdGlvbnMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbZmllbGQubmFtZV0gPSByZXN1bHRbZmllbGQubmFtZV0gfHwgW107XG4gICAgICAgICAgICAgICAgZmllbGQuZG9tRWxlbWVudC5hY2NlcHRlZFN1Z2dlc3Rpb25zXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZWwgPT4gZWxbMF0pXG4gICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKGNhbmRpZGF0ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZighcmVzdWx0W2ZpZWxkLm5hbWVdLmZpbmQocHJvY2Vzc2VkID0+IEpTT04uc3RyaW5naWZ5KGNhbmRpZGF0ZSkgPT09IEpTT04uc3RyaW5naWZ5KHByb2Nlc3NlZCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ZpZWxkLm5hbWVdLnB1c2goY2FuZGlkYXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZighcmVzdWx0W2ZpZWxkLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ZpZWxkLm5hbWVdID0gJydcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoZmllbGQuY2hlY2spIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbZmllbGQubmFtZV0gPSByZXN1bHRbZmllbGQubmFtZV0gPT09ICd0cnVlJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIHJlc3VsdC5hY3RpdmVUYWIgPSB0aGlzLmFjdGl2ZVRhYjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH0sXG5cbiAgICBjcmVhdGVNb2RhbEVsZW1lbnQ6IGZ1bmN0aW9uKGF0dHIsIGRvTm90TW91bnQpIHtcblxuICAgICAgICBhdHRyID0gYXR0ciB8fCB7fVxuICAgICAgICBhdHRyLmNsYXNzTmFtZXMgPSBhdHRyLmNsYXNzTmFtZXMgfHwgW11cblxuICAgICAgICB2YXIgbW9kYWxXcmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICAgICAgICBtb2RhbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICAgICAgbW9kYWxDb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICAgICAgICBsb3dCYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgICAgICAgIHVwQmFyICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICAgICAgY2FuY2VsQnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICAgICAgICB0YWJXcmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICAgICAgICB0bXBCdG5cblxuICAgICAgICBtb2RhbFdyYXBwZXIuY2xhc3NMaXN0LmFkZCgnZGwtbW9kYWwnKVxuICAgICAgICBtb2RhbFdyYXBwZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgICAgICBtb2RhbC5jbGFzc0xpc3QuYWRkKCdtb2RhbCcpXG4gICAgICAgIG1vZGFsQ29udGVudC5jbGFzc0xpc3QuYWRkKCdtb2RhbC1jb250ZW50JylcbiAgICAgICAgdGFiV3JhcHBlci5jbGFzc0xpc3QuYWRkKCd0YWJXcmFwcGVyJylcbiAgICAgICAgbG93QmFyLmNsYXNzTGlzdC5hZGQoJ2xvdy1iYXInKVxuXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuYnV0dG9ucykuZm9yRWFjaCgoYnRuID0+IHtcbiAgICAgICAgICAgIGxldCBjYWxsYmFjayA9IHR5cGVvZiB0aGlzLmJ1dHRvbnNbYnRuXSA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMuYnV0dG9uc1tidG5dIDogdGhpcy5idXR0b25zW2J0bl0uYWN0aW9uXG4gICAgICAgICAgICB0bXBCdG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgICAgICAgdG1wQnRuLmNsYXNzTGlzdC5hZGQoJ2J0bicpXG4gICAgICAgICAgICB0bXBCdG4uaW5uZXJIVE1MID0gYnRuXG5cbiAgICAgICAgICAgIGlmKHRoaXMuYnV0dG9uc1tidG5dLmlkKSB7XG4gICAgICAgICAgICAgICAgdG1wQnRuLmlkID0gdGhpcy5idXR0b25zW2J0bl0uaWRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG1wQnRuLm9uY2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGFzc2VzID0gZXZlbnQudGFyZ2V0LmNsYXNzTGlzdFxuXG4gICAgICAgICAgICAgICAgaWYoY2xhc3Nlcy5jb250YWlucygnbG9hZGluZy1idG4nKSB8fCBjbGFzc2VzLmNvbnRhaW5zKCdkaXNhYmxlZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIFByb21pc2UuYWxsU2V0dGxlZCh0aGlzLmFsbFByb21pc2VzKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYoIWNsYXNzZXMuY29udGFpbnMoJ2Rpc2FibGVkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ2FsY3VsYXRlZEZpZWxkcygpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VNb2RhbElmT3BlbihjYWxsYmFjaylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLnJlbW92ZSgnbG9hZGluZy1idG4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxvd0Jhci5hcHBlbmRDaGlsZCh0bXBCdG4pXG4gICAgICAgIH0pKVxuXG4gICAgICAgIGlmKHRoaXMub25DYW5jZWxDYWxsYmFjaykge1xuICAgICAgICAgICAgdXBCYXIuY2xhc3NMaXN0LmFkZCgndXAtYmFyJylcbiAgICAgICAgICAgIGNhbmNlbEJ0bi5jbGFzc0xpc3QuYWRkKCdjYW5jZWxCdG4nKVxuICAgICAgICAgICAgY2FuY2VsQnRuLm9uY2xpY2sgPSAoKSA9PiB7IHRoaXMuY2FuY2VsTW9kYWxJZkNhbmNlbGFibGUoKSB9XG4gICAgICAgICAgICB1cEJhci5hcHBlbmRDaGlsZChjYW5jZWxCdG4pXG4gICAgICAgIH1cblxuICAgICAgICBtb2RhbFdyYXBwZXIuYXBwZW5kQ2hpbGQobW9kYWwpXG4gICAgICAgIG1vZGFsLmFwcGVuZENoaWxkKHVwQmFyKVxuICAgICAgICBtb2RhbC5hcHBlbmRDaGlsZCh0YWJXcmFwcGVyKVxuICAgICAgICBtb2RhbC5hcHBlbmRDaGlsZChtb2RhbENvbnRlbnQpXG4gICAgICAgIG1vZGFsLmFwcGVuZENoaWxkKGxvd0JhcilcblxuICAgICAgICBpZighZG9Ob3RNb3VudCkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChtb2RhbFdyYXBwZXIpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbW9kYWxXcmFwcGVyXG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERlY2xhcmF0aXZGb3JtXG4iLCJ2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpLFxuICAgIHhtbG5zID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJ1xuXG5zdHlsZS50ZXh0Q29udGVudCA9IGBcbiAgICBAa2V5ZnJhbWVzIHBsYWNlSG9sZGVyU2hpbW1lcntcbiAgICAgICAgMCV7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtNDY4cHggMFxuICAgICAgICB9XG4gICAgICAgIDEwMCV7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiA0NjhweCAwXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkbC1zZWxlY3Qge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiAzMDA7XG4gICAgICAgIGZvbnQtZmFtaWx5OiAnUnViaWsnLCBzYW5zLXNlcmlmO1xuICAgIH1cblxuICAgIGRsLXNlbGVjdCAuaW5wdXQtd3JhcHBlciB7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgYm9yZGVyOiAycHggc29saWQgI2RkZDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICAgIH1cblxuICAgIGRsLXNlbGVjdC5kbC1mb2N1c2VkIC5pbnB1dC13cmFwcGVyIHtcbiAgICAgICAgYm9yZGVyOiAycHggc29saWQgI2JiYjtcbiAgICB9XG5cbiAgICBkbC1zZWxlY3QuZGwtZm9jdXNlZCAuaW5wdXQtd3JhcHBlciBzdmcge1xuICAgICAgICBib3JkZXItbGVmdDogMXB4IHNvbGlkICNiYmI7XG4gICAgICAgIGZpbGw6ICNiYmI7XG4gICAgfVxuXG4gICAgZGwtc2VsZWN0IC5vcHRpb25zLXdyYXBwZXIge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGxlZnQ6IDBweDtcbiAgICAgICAgdG9wOiAyMHB4O1xuICAgICAgICBmb250LXNpemU6IDAuOWVtO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgbWF4LWhlaWdodDogMjMwcHg7XG4gICAgICAgIG92ZXJmbG93OiBzY3JvbGw7XG4gICAgICAgIGJveC1zaGFkb3c6IDBweCAwcHggMTBweCAtMnB4IHJnYmEoMCwwLDAsMC40KTtcbiAgICAgICAgei1pbmRleDogMTAwO1xuICAgIH1cblxuICAgIGRsLXNlbGVjdCAub3B0aW9ucy13cmFwcGVyIGRsLW9wdGlvbiB7XG4gICAgICAgIGJvcmRlci1sZWZ0OiAxcHggc29saWQgI2JiYjtcbiAgICAgICAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgI2JiYjtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIH1cblxuICAgIGRsLXNlbGVjdCAub3B0aW9ucy13cmFwcGVyIC5ub01hdGNoZXNIaW50IHtcbiAgICAgICAgYm9yZGVyLWxlZnQ6IDFweCBzb2xpZCAjYmJiO1xuICAgICAgICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCAjYmJiO1xuICAgICAgICBwYWRkaW5nOiA1cHg7XG4gICAgICAgIGZvbnQtc3R5bGU6IGl0YWxpYztcbiAgICB9XG5cbiAgICBkbC1zZWxlY3QgLm9wdGlvbnMtd3JhcHBlciB7XG4gICAgICAgIGJvcmRlci10b3A6IDFweCBzb2xpZCAjYmJiO1xuICAgICAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2JiYjtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICAgIH1cblxuICAgIGRsLXNlbGVjdCAuaW5wdXQtd3JhcHBlciBpbnB1dCB7XG4gICAgICAgIHdpZHRoOiAzNzFweDtcbiAgICAgICAgb3V0bGluZS13aWR0aDogMDtcbiAgICAgICAgbWFyZ2luLXRvcDogMnB4O1xuICAgICAgICBwYWRkaW5nOiA2cHg7XG4gICAgICAgIGZvbnQtc2l6ZTogMC45ZW07XG4gICAgICAgIGZvbnQtZmFtaWx5OiAnUnViaWsnLCBzYW5zLXNlcmlmO1xuICAgICAgICBmb250LXdlaWdodDogMzAwO1xuICAgICAgICBib3JkZXI6IDBweDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICAgICAgICBmbG9hdDogbGVmdDtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICBib3gtc2l6aW5nOiBjb250ZW50LWJveDtcbiAgICB9XG5cbiAgICBkbC1zZWxlY3QgLmlucHV0LXdyYXBwZXIgc3ZnIHtcbiAgICAgICAgd2lkdGg6IDIwcHg7XG4gICAgICAgIGhlaWdodDogMjBweDtcbiAgICAgICAgbWFyZ2luLXRvcDogNXB4O1xuICAgICAgICBtYXJnaW4tcmlnaHQ6IDRweDtcbiAgICAgICAgcGFkZGluZy1sZWZ0OiA0cHg7XG4gICAgICAgIGZpbGw6ICNkZGQ7XG4gICAgICAgIGZsb2F0OiByaWdodDtcbiAgICAgICAgYm9yZGVyLWxlZnQ6IDFweCBzb2xpZCAjZGRkO1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgfVxuXG4gICAgZGwtc2VsZWN0IC5vcHRpb25zLXdyYXBwZXIgZGwtb3B0aW9uIHtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIHBhZGRpbmc6IDVweDtcbiAgICAgICAgY29sb3I6ICM1NDU0NTQ7XG4gICAgfVxuXG4gICAgZGwtc2VsZWN0IC5vcHRpb25zLXdyYXBwZXIgZGwtb3B0aW9uOmhvdmVyIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyMjQsIDI0MCwgMjI3LCAwLjQpO1xuICAgIH1cblxuICAgIGRsLXNlbGVjdCAub3B0aW9ucy13cmFwcGVyIGRsLW9wdGlvbi5kbC1mb2N1c2VkIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyMjQsIDI0MCwgMjI3LCAwLjQpO1xuICAgIH1cblxuICAgIGRsLXNlbGVjdCAuZGwtb3B0aW9uLXRhZyB7XG4gICAgICAgIGZsb2F0OiByaWdodDtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgIzg4ODtcbiAgICAgICAgZm9udC1zaXplOiAwLjhlbTtcbiAgICAgICAgcGFkZGluZzogMnB4O1xuICAgICAgICBmb250LWZhbWlseTogJ1NvdXJjZSBDb2RlIFBybycsIG1vbm9zcGFjZTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMnB4O1xuICAgICAgICBtYXJnaW4tdG9wOiAtMXB4O1xuICAgIH1cblxuICAgIGRsLXNlbGVjdCAuZGwtb3B0aW9uLXRhZzpsYXN0LWNoaWxkIHtcbiAgICAgICBtYXJnaW4tcmlnaHQ6IDEwcHg7XG4gICAgfVxuXG4gICAgLmRsLXNlbGVjdC1sb2FkaW5nIHtcblxuICAgIH1cblxuICAgIC5kbC1zZWxlY3Qtbm8tb3B0aW9ucy1hdmFpbGFibGUgc3ZnIHBhdGgge1xuICAgICAgICBkaXNwbGF5OiBub25lO1xuICAgIH1cblxuICAgIC5kbC1zZWxlY3Qtbm8tb3B0aW9ucy1hdmFpbGFibGUgc3ZnIHtcbiAgICAgICAgYm9yZGVyLWxlZnQ6IG5vbmUgIWltcG9ydGFudDtcbiAgICB9XG5cbiAgICAuZGwtc2VsZWN0LWxvYWRpbmcgc3ZnLCAuZGwtc2VsZWN0LW5vLW9wdGlvbnMtYXZhaWxhYmxlIHN2ZyB7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgIH1cblxuICAgIC5kbC1zZWxlY3QtbG9hZGluZyBpbnB1dCwgLmRsLXNlbGVjdC1uby1vcHRpb25zLWF2YWlsYWJsZSBpbnB1dCB7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgIH1cblxuICAgIGJvZHkuZGFyay10aGVtZSBkbC1zZWxlY3Qge1xuICAgICAgICAtLWRsLXNlbGVjdC1sb2FkaW5nLWNvbDE6ICMyODI3Mjc7XG4gICAgICAgIC0tZGwtc2VsZWN0LWxvYWRpbmctY29sMjogIzUwNTY1NjtcbiAgICB9XG5cbiAgICBkbC1zZWxlY3Qge1xuICAgICAgICAtLWRsLXNlbGVjdC1sb2FkaW5nLWNvbDE6ICNlZWVlZWU7XG4gICAgICAgIC0tZGwtc2VsZWN0LWxvYWRpbmctY29sMjogI2RkZGRkZDtcbiAgICB9XG5cbiAgICAuZGwtc2VsZWN0LWxvYWRpbmcgLmlucHV0LXdyYXBwZXIge1xuICAgICAgICBhbmltYXRpb24tZHVyYXRpb246IDEuMjVzO1xuICAgICAgICBhbmltYXRpb24tZmlsbC1tb2RlOiBmb3J3YXJkcztcbiAgICAgICAgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogaW5maW5pdGU7XG4gICAgICAgIGFuaW1hdGlvbi1uYW1lOiBwbGFjZUhvbGRlclNoaW1tZXI7XG4gICAgICAgIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGxpbmVhcjtcbiAgICAgICAgYmFja2dyb3VuZDogZGFya2dyYXk7XG4gICAgICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh0byByaWdodCwgdmFyKC0tZGwtc2VsZWN0LWxvYWRpbmctY29sMSkgMTAlLCB2YXIoLS1kbC1zZWxlY3QtbG9hZGluZy1jb2wyKSAxOCUsIHZhcigtLWRsLXNlbGVjdC1sb2FkaW5nLWNvbDEpIDMzJSk7XG4gICAgICAgIGJhY2tncm91bmQtc2l6ZTogODAwcHggMTA0cHg7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgd2lkdGg6IDQxMnB4O1xuICAgICAgICBoZWlnaHQ6IDMxcHg7XG4gICAgfVxuICAgIC5kbC1zZWxlY3QtbG9hZGluZyBpbnB1dCB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgfVxuYFxuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHN0eWxlKVxufSlcblxuY2xhc3MgRGxTZWxlY3QgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKClcbiAgICAgICAgdGhpcy5sb2FkaW5nU2NyZWVuVGltZW91dHMgPSBbXVxuICAgICAgICB0aGlzLmxvYWRpbmdTdGFydGVkQXQgPSB1bmRlZmluZWRcbiAgICAgICAgdGhpcy5vcHRpb25zV3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICAgIHRoaXMuaW5wdXRXcmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpXG4gICAgICAgIHRoaXMubm9NYXRjaGVzSGludCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKVxuICAgICAgICB0aGlzLmlucHV0RmllbGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpXG4gICAgICAgIHRoaXMuYXJyb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoeG1sbnMsICdzdmcnKVxuICAgIH1cblxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXNcblxuICAgICAgICBpZih0aGlzLmlzSW5pdGlhbGl6ZWQpIHsgcmV0dXJuIH1cblxuICAgICAgICB0aGlzLmlucHV0V3JhcHBlci5jbGFzc0xpc3QuYWRkKCdpbnB1dC13cmFwcGVyJylcbiAgICAgICAgdGhpcy5vcHRpb25zV3JhcHBlci5jbGFzc0xpc3QuYWRkKCdvcHRpb25zLXdyYXBwZXInKVxuICAgICAgICB0aGlzLm9wdGlvbnNXcmFwcGVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnBsYWNlaG9sZGVyID0gJ1NlbGVjdCAuLi4nXG4gICAgICAgIHRoaXMubm9NYXRjaGVzSGludC5jbGFzc0xpc3QuYWRkKCdub01hdGNoZXNIaW50JylcbiAgICAgICAgdGhpcy5ub01hdGNoZXNIaW50LmlubmVySFRNTCA9ICdObyBNYXRjaGVzJ1xuICAgICAgICB0aGlzLm5vTWF0Y2hlc0hpbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgICAgICB0aGlzLmlucHV0RmllbGQub25mb2N1cyA9ICgpID0+IHsgc2VsZi5mb2N1cygpIH1cbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkLm9uYmx1ciA9IChlKSA9PiB7IHNlbGYudW5mb2N1cygpIH1cbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkLm9uaW5wdXQgPSAoKSA9PiB7IHNlbGYuZmlsdGVyT3B0aW9ucyh0aGlzLmlucHV0RmllbGQudmFsdWUpIH1cbiAgICAgICAgdGhpcy5hcnJvdy5vbmNsaWNrID0gKCkgPT4geyBzZWxmLmlucHV0RmllbGQuZm9jdXMoKSB9XG4gICAgICAgIHRoaXMuYXJyb3cuaW5uZXJIVE1MID0gJzxwYXRoIGQ9XCJNNC41MTYgNy41NDhjMC40MzYtMC40NDYgMS4wNDMtMC40ODEgMS41NzYgMGwzLjkwOCAzLjc0NyAzLjkwOC0zLjc0N2MwLjUzMy0wLjQ4MSAxLjE0MS0wLjQ0NiAxLjU3NCAwIDAuNDM2IDAuNDQ1IDAuNDA4IDEuMTk3IDAgMS42MTUtMC40MDYgMC40MTgtNC42OTUgNC41MDItNC42OTUgNC41MDItMC4yMTcgMC4yMjMtMC41MDIgMC4zMzUtMC43ODcgMC4zMzVzLTAuNTctMC4xMTItMC43ODktMC4zMzVjMCAwLTQuMjg3LTQuMDg0LTQuNjk1LTQuNTAycy0wLjQzNi0xLjE3IDAtMS42MTV6XCI+PC9wYXRoPidcblxuICAgICAgICB0aGlzLm9wdGlvbnNXcmFwcGVyLmFwcGVuZENoaWxkKHRoaXMubm9NYXRjaGVzSGludClcblxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2RsLXNlbGVjdC1uby1vcHRpb25zLWF2YWlsYWJsZScpXG5cbiAgICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICdsb2FkaW5nJykge1xuICAgICAgICAgICAgdGhpcy5sb2FkT3B0aW9ucygpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtzZWxmLmxvYWRPcHRpb25zKCl9KVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCAoZSkgPT4ge1xuICAgICAgICAgICAgdmFyIG9wdGlvbiA9IHNlbGYuZm9jdXNlZE9wdGlvbigpXG4gICAgICAgICAgICBpZihlLmtleSA9PT0gJ0Fycm93RG93bicpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmZvY3VzT3B0aW9uKHNlbGYubmV4dFZpc2libGVPcHRpb25BZnRlcihvcHRpb24pKVxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgICAgIH0gZWxzZSBpZihlLmtleSA9PT0gJ0Fycm93VXAnKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5mb2N1c09wdGlvbihzZWxmLnByZXZpb3VzVmlzaWJsZU9wdGlvbkFmdGVyKG9wdGlvbikpXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICAgICAgfSBlbHNlIGlmKGUua2V5ID09PSAnRW50ZXInKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zZXRPcHRpb24ob3B0aW9uKVxuICAgICAgICAgICAgICAgIHNlbGYudW5mb2N1cygpXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgfVxuXG4gICAgc2V0TG9hZGluZ1N0YXR1cygpIHtcbiAgICAgICAgdGhpcy5sb2FkaW5nU2NyZWVuVGltZW91dHMucHVzaChzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZGwtc2VsZWN0LWxvYWRpbmcnKVxuICAgICAgICAgICAgdGhpcy5vcHRpb25zV3JhcHBlci5yZW1vdmUoKVxuICAgICAgICAgICAgdGhpcy5sb2FkaW5nU3RhcnRlZEF0ID0gRGF0ZS5ub3coKVxuICAgICAgICB9LCAxMDApKVxuICAgIH1cblxuICAgIHVuc2V0TG9hZGluZ1N0YXR1cygpIHtcbiAgICAgICAgdGhpcy5sb2FkaW5nU2NyZWVuVGltZW91dHMuZm9yRWFjaChjbGVhclRpbWVvdXQpXG4gICAgICAgIHRoaXMubG9hZGluZ1NjcmVlblRpbWVvdXRzID0gW11cblxuICAgICAgICBjb25zdCBtaW5Mb2FkVGltZUluU2Vjb25kcyA9IDEuNVxuICAgICAgICBjb25zdCBkZWxheSA9IHRoaXMubG9hZGluZ1N0YXJ0ZWRBdCA/XG4gICAgICAgICAgICAobWluTG9hZFRpbWVJblNlY29uZHMgKiAxMDAwKSAtIChEYXRlLm5vdygpIC0gdGhpcy5sb2FkaW5nU3RhcnRlZEF0KVxuICAgICAgICAgICAgOiAwXG5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKHRoaXMub3B0aW9uc1dyYXBwZXIpXG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ2RsLXNlbGVjdC1sb2FkaW5nJylcbiAgICAgICAgfSwgZGVsYXkpXG4gICAgfVxuXG4gICAgbG9hZE9wdGlvbnMoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpc1xuICAgICAgICB3aGlsZShzZWxmLmZpcnN0RWxlbWVudENoaWxkKSB7XG4gICAgICAgICAgICBzZWxmLmZpcnN0RWxlbWVudENoaWxkLm9ubW91c2Vkb3duID0gZnVuY3Rpb24oKSB7IHNlbGYuc2V0T3B0aW9uKHRoaXMpIH1cbiAgICAgICAgICAgIHNlbGYuZmlyc3RFbGVtZW50Q2hpbGQub25tb3VzZW92ZXIgPSBmdW5jdGlvbigpIHsgc2VsZi5jbGVhckZvY3VzZWRPcHRpb24oKSB9XG4gICAgICAgICAgICBzZWxmLm9wdGlvbnNXcmFwcGVyLmFwcGVuZENoaWxkKHNlbGYuZmlyc3RFbGVtZW50Q2hpbGQpXG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLmlucHV0V3JhcHBlci5hcHBlbmRDaGlsZChzZWxmLmlucHV0RmllbGQpXG4gICAgICAgIHNlbGYuaW5wdXRXcmFwcGVyLmFwcGVuZENoaWxkKHNlbGYuYXJyb3cpXG4gICAgICAgIHNlbGYuYXBwZW5kQ2hpbGQoc2VsZi5pbnB1dFdyYXBwZXIpXG4gICAgICAgIHNlbGYuYXBwZW5kQ2hpbGQoc2VsZi5vcHRpb25zV3JhcHBlcilcbiAgICAgICAgc2VsZi5zZXRWYWx1ZShzZWxmLmdldFZhbHVlKCkpXG4gICAgICAgIHRoaXMudXBkYXRlUGxhY2Vob2xkZXJUZXh0KClcbiAgICB9XG5cbiAgICByZW1vdmVBbGxPcHRpb25zKCkge1xuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2RsLXNlbGVjdC1uby1vcHRpb25zLWF2YWlsYWJsZScpXG4gICAgICAgIHRoaXMucXVlcnlTZWxlY3RvckFsbCgnZGwtb3B0aW9uJykuZm9yRWFjaChvcHQgPT4gb3B0LnJlbW92ZSgpKVxuICAgICAgICB0aGlzLnVwZGF0ZVBsYWNlaG9sZGVyVGV4dCgpXG4gICAgfVxuXG4gICAgYWRkT3B0aW9uKG9wdGlvbkVsKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpc1xuXG4gICAgICAgIG9wdGlvbkVsLm9ubW91c2Vkb3duID0gZnVuY3Rpb24oKSB7IHNlbGYuc2V0T3B0aW9uKHRoaXMpIH1cbiAgICAgICAgb3B0aW9uRWwub25tb3VzZW92ZXIgPSBmdW5jdGlvbigpIHsgc2VsZi5jbGVhckZvY3VzZWRPcHRpb24oKSB9XG4gICAgICAgIHNlbGYub3B0aW9uc1dyYXBwZXIuYXBwZW5kQ2hpbGQob3B0aW9uRWwpXG5cbiAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCdkbC1zZWxlY3Qtbm8tb3B0aW9ucy1hdmFpbGFibGUnKVxuICAgICAgICB0aGlzLnVwZGF0ZVBsYWNlaG9sZGVyVGV4dCgpXG4gICAgfVxuXG4gICAgY2xlYXJGb2N1c2VkT3B0aW9uKCkge1xuICAgICAgICB0aGlzLl9mb2N1c2VkT3B0aW9uID0gbnVsbFxuICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKHRoaXMub3B0aW9uc1dyYXBwZXIuY2hpbGRyZW4sIChvcHQpID0+IHtcbiAgICAgICAgICAgIG9wdC5jbGFzc0xpc3QucmVtb3ZlKCdkbC1mb2N1c2VkJylcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBmb2N1c2VkT3B0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9jdXNlZE9wdGlvblxuICAgIH1cblxuICAgIGZvY3VzT3B0aW9uKG9wdGlvbikge1xuICAgICAgICBvcHRpb24gPSBvcHRpb24gfHwgdGhpcy5uZXh0VmlzaWJsZU9wdGlvbkFmdGVyKG9wdGlvbilcblxuICAgICAgICB0aGlzLmNsZWFyRm9jdXNlZE9wdGlvbigpXG5cbiAgICAgICAgdGhpcy5fZm9jdXNlZE9wdGlvbiA9IG9wdGlvblxuICAgICAgICBpZihvcHRpb24pIHtcbiAgICAgICAgICAgIG9wdGlvbi5jbGFzc0xpc3QuYWRkKCdkbC1mb2N1c2VkJylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5leHRWaXNpYmxlT3B0aW9uQWZ0ZXIob3B0aW9uKSB7XG4gICAgICAgIG9wdGlvbiA9IG9wdGlvbiB8fCB0aGlzLm9wdGlvbnNXcmFwcGVyLmNoaWxkcmVuWzBdXG4gICAgICAgIHdoaWxlKG9wdGlvbikge1xuICAgICAgICAgICAgaWYob3B0aW9uLm5leHRTaWJsaW5nICYmIG9wdGlvbi5uZXh0U2libGluZy5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9uLm5leHRTaWJsaW5nXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9wdGlvbiA9IG9wdGlvbi5uZXh0U2libGluZ1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJldmlvdXNWaXNpYmxlT3B0aW9uQWZ0ZXIob3B0aW9uKSB7XG4gICAgICAgIG9wdGlvbiA9IG9wdGlvbiB8fCB0aGlzLm9wdGlvbnNXcmFwcGVyLmNoaWxkcmVuWzBdXG4gICAgICAgIHdoaWxlKG9wdGlvbikge1xuICAgICAgICAgICAgaWYob3B0aW9uLnByZXZpb3VzU2libGluZyAmJiBvcHRpb24ucHJldmlvdXNTaWJsaW5nLnN0eWxlLmRpc3BsYXkgIT09ICdub25lJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb24ucHJldmlvdXNTaWJsaW5nXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9wdGlvbiA9IG9wdGlvbi5wcmV2aW91c1NpYmxpbmdcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZpbHRlck9wdGlvbnMoc3RyKSB7XG4gICAgICAgIHZhciBoYXNNYXRjaGVkID0gZmFsc2U7XG4gICAgICAgIHN0ciA9IHN0ci50b0xvd2VyQ2FzZSgpXG5cbiAgICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbCh0aGlzLm9wdGlvbnNXcmFwcGVyLmNoaWxkcmVuLCAob3B0KSA9PiB7XG4gICAgICAgICAgICBpZihzdHIgPT09ICcnIHx8IHN0ci5zcGxpdCgnICcpLmV2ZXJ5KHRlcm0gPT4gb3B0LmlubmVyVGV4dC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHRlcm0pKSkge1xuICAgICAgICAgICAgICAgIG9wdC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgICAgICAgICAgICAgIGhhc01hdGNoZWQgPSB0cnVlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgdGhpcy5ub01hdGNoZXNIaW50LnN0eWxlLmRpc3BsYXkgPSBoYXNNYXRjaGVkID8gJ25vbmUnIDogJ2Jsb2NrJ1xuICAgIH1cblxuICAgIHNldFZhbHVlKHZhbCkge1xuICAgICAgICBpZighdmFsKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvcHRpb24gPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ2RsLW9wdGlvblt2YWx1ZT1cIicrdmFsKydcIl0nKSB8fFxuICAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLmZpbmQuY2FsbCh0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoJ2RsLW9wdGlvbicpLCBmdW5jdGlvbihlbCkge3JldHVybiBlbC5pbm5lclRleHQgPT0gdmFsfSlcblxuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgndG1wLXZhbHVlJywgdmFsKVxuICAgICAgICB0aGlzLnNldE9wdGlvbihvcHRpb24pXG4gICAgfVxuXG4gICAgc2V0T3B0aW9uKG9wdGlvbkVsKSB7XG4gICAgICAgIGlmKCFvcHRpb25FbCkgeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRPcHRpb25FbCA9IG9wdGlvbkVsXG4gICAgICAgIHRoaXMuaW5wdXRGaWVsZC52YWx1ZSA9IHRoaXMuZ2V0RGlzcGxheWVkVGV4dCgpXG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCd2YWx1ZScsIG9wdGlvbkVsLmdldEF0dHJpYnV0ZSgndmFsdWUnKSB8fCBvcHRpb25FbC5pbm5lclRleHQpXG5cbiAgICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiSFRNTEV2ZW50c1wiKVxuICAgICAgICBldnQuaW5pdEV2ZW50KFwiY2hhbmdlXCIsIGZhbHNlLCB0cnVlKVxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZ0KVxuICAgIH1cblxuICAgIGdldERpc3BsYXllZFRleHQoKSB7XG4gICAgICAgIGlmKHRoaXMuc2VsZWN0ZWRPcHRpb25FbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRPcHRpb25FbC5nZXRBdHRyaWJ1dGUoJ2Rpc3BsYXlXaGVuU2VsZWN0ZWQnKSB8fCB0aGlzLnNlbGVjdGVkT3B0aW9uRWwuaW5uZXJUZXh0XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJydcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldFBsYWNlaG9sZGVyVGV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc1dyYXBwZXIucXVlcnlTZWxlY3RvckFsbCgnZGwtb3B0aW9uJykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJ05vIE9wdGlvbnMgQXZhaWxhYmxlJ1xuICAgICAgICB9IGVsc2UgaWYodGhpcy5zZWxlY3RlZE9wdGlvbkVsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZE9wdGlvbkVsLmlubmVyVGV4dFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICdTZWxlY3QgLi4uJ1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlUGxhY2Vob2xkZXJUZXh0KCkge1xuICAgICAgICB0aGlzLmlucHV0RmllbGQucGxhY2Vob2xkZXIgPSB0aGlzLmdldFBsYWNlaG9sZGVyVGV4dCgpXG4gICAgfVxuXG4gICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgIGlmKHRoaXMuZ2V0QXR0cmlidXRlKCd2YWx1ZScpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJylcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0bXBWYWx1ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCd0bXAtdmFsdWUnKVxuICAgICAgICB2YXIgb3B0aW9uID0gdGhpcy5xdWVyeVNlbGVjdG9yKCdkbC1vcHRpb25bdmFsdWU9XCInK3RoaXMuZ2V0QXR0cmlidXRlKCd0bXAtdmFsdWUnKSsnXCJdJylcblxuICAgICAgICBpZihvcHRpb24gJiYgdG1wVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0bXBWYWx1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9jdXMoKSB7XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZGwtZm9jdXNlZCcpXG4gICAgICAgIHRoaXMudXBkYXRlUGxhY2Vob2xkZXJUZXh0KClcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnZhbHVlID0gJydcbiAgICAgICAgdGhpcy5vcHRpb25zV3JhcHBlci5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jaydcbiAgICAgICAgdGhpcy5maWx0ZXJPcHRpb25zKHRoaXMuaW5wdXRGaWVsZC52YWx1ZSlcbiAgICB9XG5cbiAgICB1bmZvY3VzKCkge1xuICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ2RsLWZvY3VzZWQnKVxuICAgICAgICB0aGlzLm9wdGlvbnNXcmFwcGVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnZhbHVlID0gdGhpcy5nZXREaXNwbGF5ZWRUZXh0KClcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkLmJsdXIoKVxuICAgIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdkbC1zZWxlY3QnLCBEbFNlbGVjdClcbiIsInZhciBNb2RpZmljYXRpb25Mb2dFbnRyeSA9IHJlcXVpcmUoJy4vbW9kaWZpY2F0aW9uX2xvZycpLFxuICAgIHV0aWxzID0gcmVxdWlyZSgnLi4vcGl4ZWxzY2h1YnNlci91dGlscycpLFxuICAgIGRpZmZNYXRjaFBhdGNoID0gcmVxdWlyZSgnZGlmZl9tYXRjaF9wYXRjaCcpLFxuICAgIGRpZmZFbmdpbmUgPSBuZXcgZGlmZk1hdGNoUGF0Y2guZGlmZl9tYXRjaF9wYXRjaCxcbiAgICB3aXRoTG9va2FoZWFkID0gcmVxdWlyZSgnLi4vZ2VuZXJhdG9ybG9va2FoZWFkJyk7XG5cbi8vIFRoaXMgY3JlYXRlcyBhIHZpdHVhbCBET00gZm9yIHRoZSBwYXNzZWQgYGNvbnRlbnRFbGVtZW50YFxuLy8gVXNpbmcgdGhlIHVwZGF0ZUhUTUwgZnVuY3Rpb24gb2YgdGhpcyBvYmplY3QgcHJvdmlkZXMgdGhlIGZvbGxvd2luZyBhZHZhbnRhZ2VzOlxuLy8gLSBQYXNzZWQgSFRNTCBpcyBzYW5pdGl6ZWQgYmFzZWQgb24gdGhlIGNvbnRlbnQgcnVsZXMgb2YgdGhlIGBodG1sUmF6b3JgLlxuLy8gLSBJdCByZXR1cm5zIGEgbW9kaWZpY2F0aW9uTG9nRW50cnkgd2hpY2ggaW5jbHVkZXMgdGhlIGNoYW5nZXMgbWFkZS5cbi8vIC0gT25seSB1cGRhdGVzIHRoZSBkb20gZnJhY3Rpb25zIHRoYXQgbXVzdCBiZSBjaGFuZ2VkIChvcHRpbWl6ZWRcbi8vICAgZm9yIGxvbmcgYW5kIHF1aXRlIGZsYXQgZG9jdW1lbnRzKVxuZnVuY3Rpb24gRG9jdW1lbnR1cGRhdGVyKGNvbnRlbnRFbGVtZW50LCBodG1sUmF6b3IpIHtcbiAgICB0aGlzLmNvbnRlbnRFbGVtZW50ID0gY29udGVudEVsZW1lbnQ7XG4gICAgdGhpcy5odG1sUmF6b3IgPSBodG1sUmF6b3I7XG59XG5cbkRvY3VtZW50dXBkYXRlci5wcm90b3R5cGUgPSB7XG4gICAgdXBkYXRlSFRNTDogZnVuY3Rpb24oY29udGVudCwgZm9jdXNlZFNlY3Rpb24sIGFyZ3MpIHtcbiAgICAgICAgYXJncyA9IGFyZ3MgfHwge307XG5cbiAgICAgICAgaWYodGhpcy5jb250ZW50RWxlbWVudC5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudEVsZW1lbnQuaW5uZXJIVE1MID0gJzxwPjwvcD4nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoYXJncy5hY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50RWxlbWVudFxuICAgICAgICAgICAgICAgIC5xdWVyeVNlbGVjdG9yQWxsKCcuZm9jdXNlZC1ieS1hcGktYWN0b3InICsgYXJncy5hY3Rvci5pZCArICctZmJhYWVuZCcpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZWwgPT4gZWwuY2xhc3NMaXN0LnJlbW92ZSgnZm9jdXNlZC1ieS1hcGktYWN0b3InKyBhcmdzLmFjdG9yLmlkICsgJy1mYmFhZW5kJykpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1vZGlmaWNhdGlvbkxvZ0VudHJ5ID0gYXJncy5tb2RpZmljYXRpb25Mb2dFbnRyeSB8fCBuZXcgTW9kaWZpY2F0aW9uTG9nRW50cnkoKTtcbiAgICAgICAgdGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeS5pbnNlcnRlZEJlZm9yZVNlbGVjdGlvblJhbmdlU3RhcnQgPSAwO1xuICAgICAgICB0aGlzLm1vZGlmaWNhdGlvbkxvZ0VudHJ5Lmluc2VydGVkQmVmb3JlU2VsZWN0aW9uUmFuZ2VFbmQgPSAwO1xuXG4gICAgICAgIHZhciBmaXJzdFNlY3Rpb25Ub1VwZGF0ZSA9IGFyZ3Muc2VjdGlvbiB8fCBhcmdzLnN0YXJ0U2VjdGlvbiB8fCB0aGlzLmNvbnRlbnRFbGVtZW50LmNoaWxkcmVuWzBdLFxuICAgICAgICAgICAgbGFzdFNlY3Rpb25Ub1VwZGF0ZSA9ICBhcmdzLnNlY3Rpb24gfHwgYXJncy5lbmRTZWN0aW9uIHx8IHRoaXMuY29udGVudEVsZW1lbnQuY2hpbGRyZW5bdGhpcy5jb250ZW50RWxlbWVudC5jaGlsZHJlbi5sZW5ndGgtMV0sXG4gICAgICAgICAgICBuZXdTZWN0aW9uU3RyZWFtLFxuICAgICAgICAgICAgcGFpclN0cmVhbSxcbiAgICAgICAgICAgIGxhc3RVcGRhdGVkU2VjdGlvbixcbiAgICAgICAgICAgIHBhaXI7XG5cbiAgICAgICAgaWYoYXJncy5zdGFydFNlY3Rpb24gJiZcbiAgICAgICAgICAgYXJncy5lbmRTZWN0aW9uICYmXG4gICAgICAgIC8vICAgIHRoaXMuY29udGVudEVsZW1lbnQuY2hpbGRyZW5bMF0gIT09IGFyZ3Muc3RhcnRTZWN0aW9uICYmXG4gICAgICAgIC8vICAgIHRoaXMuY29udGVudEVsZW1lbnQuY2hpbGRyZW5bdGhpcy5jb250ZW50RWxlbWVudC5jaGlsZHJlbi5sZW5ndGgtMV0gIT09IGFyZ3MuZW5kU2VjdGlvbiAmJlxuICAgICAgICAgICBjb250ZW50ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgY29udGVudCAhPT0gbnVsbCAmJlxuICAgICAgICAgICBjb250ZW50LnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgICAgIHBhaXJTdHJlYW0gPSB0aGlzLl9kZWxldGVPbGRTZWN0aW9uc1BhaXJTdHJlYW0oZmlyc3RTZWN0aW9uVG9VcGRhdGUsIGxhc3RTZWN0aW9uVG9VcGRhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3U2VjdGlvblN0cmVhbSA9IHRoaXMuaHRtbFJhem9yLmNsZWFudXBIVE1MQW5kQXR0YWNoRXZlbnRIYW5kbGVycyhjb250ZW50LCB0aGlzLm1vZGlmaWNhdGlvbkxvZ0VudHJ5KTtcbiAgICAgICAgICAgIHBhaXJTdHJlYW0gPSB0aGlzLl9vbGRBbmROZXdTZWN0aW9uUGFpclN0cmVhbShuZXdTZWN0aW9uU3RyZWFtLCBmaXJzdFNlY3Rpb25Ub1VwZGF0ZSwgbGFzdFNlY3Rpb25Ub1VwZGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZvY3VzZWRTZWN0aW9uID0gZm9jdXNlZFNlY3Rpb247XG4gICAgICAgIHRoaXMubW9kaWZpY2F0aW9uTG9nRW50cnkucmV0YWluQWxsU2VjdGlvbnNCZWZvcmUoZmlyc3RTZWN0aW9uVG9VcGRhdGUpO1xuXG4gICAgICAgIHdoaWxlKHBhaXIgPSBwYWlyU3RyZWFtLm5leHQoKS52YWx1ZSkge1xuICAgICAgICAgICAgaWYocGFpci5vbGQgJiYgcGFpci5uZXcpIHtcbiAgICAgICAgICAgICAgICBsYXN0VXBkYXRlZFNlY3Rpb24gPSB0aGlzLl9yZXBsYWNlU2VjdGlvbnMocGFpci5vbGQsIHBhaXIubmV3LCBhcmdzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZihwYWlyLm5ldykge1xuICAgICAgICAgICAgICAgIGlmKGxhc3RVcGRhdGVkU2VjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBsYXN0VXBkYXRlZFNlY3Rpb24gPSB0aGlzLl9pbnNlcnRTZWN0aW9uQWZ0ZXIobGFzdFVwZGF0ZWRTZWN0aW9uLCBwYWlyLm5ldywgYXJncyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKGZpcnN0U2VjdGlvblRvVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RVcGRhdGVkU2VjdGlvbiA9IHRoaXMuX2luc2VydFNlY3Rpb25CZWZvcmUoZmlyc3RTZWN0aW9uVG9VcGRhdGUsIHBhaXIubmV3LCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsYXN0VXBkYXRlZFNlY3Rpb24gPSB0aGlzLl9pbnNlcnRTZWN0aW9uQXRCZWdpbm5pbmcocGFpci5uZXcsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIGlmKHBhaXIub2xkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlU2VjdGlvbihwYWlyLm9sZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGxhc3RVcGRhdGVkU2VjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmKCFsYXN0VXBkYXRlZFNlY3Rpb24ud29yZENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RVcGRhdGVkU2VjdGlvbi53b3JkQ291bnQgPSBsYXN0VXBkYXRlZFNlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC5pbm5lclRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zcGxpdCgvW1xcc1xcLjpcXD9cXCEnXS8pXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKHcgPT4gdy50cmltKCkubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeS5yZXRhaW5BbGxTZWN0aW9uc0FmdGVyKGxhc3RVcGRhdGVkU2VjdGlvbik7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubW9kaWZpY2F0aW9uTG9nRW50cnk7XG4gICAgfSxcblxuICAgIF9kZWxldGVPbGRTZWN0aW9uc1BhaXJTdHJlYW06IGZ1bmN0aW9uKihmaXJzdFNlY3Rpb25Ub1VwZGF0ZSwgbGFzdFNlY3Rpb25Ub1VwZGF0ZSkge1xuICAgICAgICB2YXIgbmV4dE9sZFNlY3Rpb24gPSBmaXJzdFNlY3Rpb25Ub1VwZGF0ZSxcbiAgICAgICAgICAgIG5leHROZXh0T2xkU2VjdGlvbjtcblxuICAgICAgICBpZihmaXJzdFNlY3Rpb25Ub1VwZGF0ZSA9PT0gbGFzdFNlY3Rpb25Ub1VwZGF0ZSkge1xuICAgICAgICAgICAgeWllbGQgeyBvbGQ6IGZpcnN0U2VjdGlvblRvVXBkYXRlLCBuZXc6IG51bGwgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlKG5leHRPbGRTZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgbmV4dE5leHRPbGRTZWN0aW9uID0gbmV4dE9sZFNlY3Rpb24ubmV4dFNpYmxpbmc7XG5cbiAgICAgICAgICAgICAgICB5aWVsZCB7IG9sZDogbmV4dE9sZFNlY3Rpb24sIG5ldzogbnVsbCB9O1xuICAgICAgICAgICAgICAgIG5leHRPbGRTZWN0aW9uID0gbmV4dE5leHRPbGRTZWN0aW9uO1xuXG4gICAgICAgICAgICAgICAgaWYobmV4dE9sZFNlY3Rpb24gPT09IGxhc3RTZWN0aW9uVG9VcGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgeyBvbGQ6IG5leHRPbGRTZWN0aW9uLCBuZXc6IG51bGwgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9vbGRBbmROZXdTZWN0aW9uUGFpclN0cmVhbTogZnVuY3Rpb24qKG5ld1NlY3Rpb25TdHJlYW0sIGZpcnN0U2VjdGlvblRvVXBkYXRlLCBsYXN0U2VjdGlvblRvVXBkYXRlKSB7XG4gICAgICAgIG5ld1NlY3Rpb25TdHJlYW0gPSB3aXRoTG9va2FoZWFkKG5ld1NlY3Rpb25TdHJlYW0pXG5cbiAgICAgICAgdmFyIG5leHRPbGRTZWN0aW9uID0gZmlyc3RTZWN0aW9uVG9VcGRhdGUsXG4gICAgICAgICAgICBuZXh0TmV4dE9sZFNlY3Rpb24sIG5leHRTZWN0aW9uVG9CZUluc2VydGVkLFxuICAgICAgICAgICAgbmV3U2VjdGlvbiwgbmV4dE5ld1NlY3Rpb247XG5cbiAgICAgICAgd2hpbGUobmV4dE9sZFNlY3Rpb24pIHtcbiAgICAgICAgICAgIG5leHROZXh0T2xkU2VjdGlvbiA9IG5leHRPbGRTZWN0aW9uLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgbmV3U2VjdGlvbiA9IG5ld1NlY3Rpb25TdHJlYW0ubmV4dCgpLnZhbHVlO1xuICAgICAgICAgICAgbmV4dE5ld1NlY3Rpb24gPSBuZXdTZWN0aW9uU3RyZWFtLmxvb2thaGVhZCgpLnZhbHVlO1xuXG4gICAgICAgICAgICBpZighdGhpcy5fYXJlRXF1YWxTZWN0aW9ucyhuZXh0T2xkU2VjdGlvbiwgbmV3U2VjdGlvbikgJiZcbiAgICAgICAgICAgICAgICF0aGlzLl9hcmVFcXVhbFNlY3Rpb25zKG5leHROZXh0T2xkU2VjdGlvbiwgbmV4dE9sZFNlY3Rpb24pICYmXG4gICAgICAgICAgICAgICB0aGlzLl9hcmVFcXVhbFNlY3Rpb25zKG5leHRPbGRTZWN0aW9uLCBuZXh0TmV3U2VjdGlvbilcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHsgb2xkOiB1bmRlZmluZWQsIG5ldzogbmV3U2VjdGlvbiB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB7IG9sZDogbmV4dE9sZFNlY3Rpb24sIG5ldzogbmV3U2VjdGlvbiB9O1xuICAgICAgICAgICAgICAgIGlmKG5leHRPbGRTZWN0aW9uID09PSBsYXN0U2VjdGlvblRvVXBkYXRlKSB7IGJyZWFrIH1cbiAgICAgICAgICAgICAgICBuZXh0T2xkU2VjdGlvbiA9IG5leHROZXh0T2xkU2VjdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlKG5leHRTZWN0aW9uVG9CZUluc2VydGVkID0gbmV3U2VjdGlvblN0cmVhbS5uZXh0KCkudmFsdWUpIHtcbiAgICAgICAgICAgIHlpZWxkIHsgb2xkOiBudWxsLCBuZXc6IG5leHRTZWN0aW9uVG9CZUluc2VydGVkIH07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3JlbW92ZVNlY3Rpb246IGZ1bmN0aW9uKHNlY3Rpb24pIHtcbiAgICAgICAgaWYoIXNlY3Rpb24pIHJldHVybiBmYWxzZTtcblxuICAgICAgICBpZihzZWN0aW9uID09PSB0aGlzLmZvY3VzZWRTZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmaWNhdGlvbkxvZ0VudHJ5LmZvY3VzZWRTZWN0aW9uSGFzQmVlbk1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubW9kaWZpY2F0aW9uTG9nRW50cnkuZGVsZXRlU2VjdGlvbihzZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoc2VjdGlvbik7XG4gICAgfSxcblxuICAgIF9pbnNlcnRTZWN0aW9uQXRCZWdpbm5pbmc6IGZ1bmN0aW9uKHNlY3Rpb25Ub0luc2VydCwgYXJncykge1xuICAgICAgICBpZighc2VjdGlvblRvSW5zZXJ0KSB7IHJldHVybiBmYWxzZSB9XG5cbiAgICAgICAgc2VjdGlvblRvSW5zZXJ0LnNldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJywgdHJ1ZSk7XG5cbiAgICAgICAgaWYoc2VjdGlvblRvSW5zZXJ0Lm9uTWFya3VwQ2xlYW5pbmdGaW5zaGVkKSB7XG4gICAgICAgICAgICBzZWN0aW9uVG9JbnNlcnQub25NYXJrdXBDbGVhbmluZ0ZpbnNoZWQoc2VjdGlvblRvSW5zZXJ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGFyZ3MuYWN0b3IpIHtcbiAgICAgICAgICAgIHNlY3Rpb25Ub0luc2VydC5jbGFzc0xpc3QuYWRkKCdmb2N1c2VkLWJ5LWFwaS1hY3RvcicgKyBhcmdzLmFjdG9yLmlkICsgJy1mYmFhZW5kJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1vZGlmaWNhdGlvbkxvZ0VudHJ5Lmluc2VydFNlY3Rpb24oc2VjdGlvblRvSW5zZXJ0KTtcblxuICAgICAgICBpZih0aGlzLmNvbnRlbnRFbGVtZW50LmNoaWxkcmVuWzBdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50RWxlbWVudC5pbnNlcnRCZWZvcmUoc2VjdGlvblRvSW5zZXJ0LCB0aGlzLmNvbnRlbnRFbGVtZW50LmNoaWxkcmVuWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRFbGVtZW50LmFwcGVuZENoaWxkKHNlY3Rpb25Ub0luc2VydCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2luc2VydFNlY3Rpb25BZnRlcjogZnVuY3Rpb24ocHJlZGVjZXNzb3JTZWN0aW9uLCBzZWN0aW9uVG9JbnNlcnQsIGFyZ3MpIHtcbiAgICAgICAgaWYoIXByZWRlY2Vzc29yU2VjdGlvbiB8fCAhc2VjdGlvblRvSW5zZXJ0KSB7IHJldHVybiBmYWxzZSB9XG4gICAgICAgIHNlY3Rpb25Ub0luc2VydC5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScsIHRydWUpO1xuXG4gICAgICAgIGlmKHNlY3Rpb25Ub0luc2VydC5vbk1hcmt1cENsZWFuaW5nRmluc2hlZCkge1xuICAgICAgICAgICAgc2VjdGlvblRvSW5zZXJ0Lm9uTWFya3VwQ2xlYW5pbmdGaW5zaGVkKHNlY3Rpb25Ub0luc2VydCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihhcmdzLmFjdG9yKSB7XG4gICAgICAgICAgICBzZWN0aW9uVG9JbnNlcnQuY2xhc3NMaXN0LmFkZCgnZm9jdXNlZC1ieS1hcGktYWN0b3InKyBhcmdzLmFjdG9yLmlkICsgJy1mYmFhZW5kJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1vZGlmaWNhdGlvbkxvZ0VudHJ5Lmluc2VydFNlY3Rpb24oc2VjdGlvblRvSW5zZXJ0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudEVsZW1lbnQuaW5zZXJ0QmVmb3JlKHNlY3Rpb25Ub0luc2VydCwgcHJlZGVjZXNzb3JTZWN0aW9uLm5leHRTaWJsaW5nKTsgICAvLyBpZiBwcmVkZWNlc3NvclNlY3Rpb24ubmV4dFNpYmxpbmcgaXMgbnVsbCwgdGhlIG5ld05vZGUgaXMgaW5zZXJ0ZWQgYXQgdGhlIGVuZCBvZiB0aGUgbGlzdCBvZiBjaGlsZCBub2Rlcy5cbiAgICB9LFxuXG4gICAgX2luc2VydFNlY3Rpb25CZWZvcmU6IGZ1bmN0aW9uKHByZWRlY2Vzc29yU2VjdGlvbiwgc2VjdGlvblRvSW5zZXJ0LCBhcmdzKSB7XG4gICAgICAgIGlmKCFwcmVkZWNlc3NvclNlY3Rpb24gfHwgIXNlY3Rpb25Ub0luc2VydCkgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgICBzZWN0aW9uVG9JbnNlcnQuc2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnLCB0cnVlKTtcblxuICAgICAgICBpZihzZWN0aW9uVG9JbnNlcnQub25NYXJrdXBDbGVhbmluZ0ZpbnNoZWQpIHtcbiAgICAgICAgICAgIHNlY3Rpb25Ub0luc2VydC5vbk1hcmt1cENsZWFuaW5nRmluc2hlZChzZWN0aW9uVG9JbnNlcnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoYXJncy5hY3Rvcikge1xuICAgICAgICAgICAgc2VjdGlvblRvSW5zZXJ0LmNsYXNzTGlzdC5hZGQoJ2ZvY3VzZWQtYnktYXBpLWFjdG9yJysgYXJncy5hY3Rvci5pZCArICctZmJhYWVuZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeS5pbnNlcnRTZWN0aW9uKHNlY3Rpb25Ub0luc2VydCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRFbGVtZW50Lmluc2VydEJlZm9yZShzZWN0aW9uVG9JbnNlcnQsIHByZWRlY2Vzc29yU2VjdGlvbik7ICAgLy8gaWYgcHJlZGVjZXNzb3JTZWN0aW9uLm5leHRTaWJsaW5nIGlzIG51bGwsIHRoZSBuZXdOb2RlIGlzIGluc2VydGVkIGF0IHRoZSBlbmQgb2YgdGhlIGxpc3Qgb2YgY2hpbGQgbm9kZXMuXG4gICAgfSxcblxuICAgIF9pc1NhbWVTZWN0aW9uVHlwZTogZnVuY3Rpb24oc2VjdGlvbjEsIHNlY3Rpb24yKSB7XG4gICAgICAgIGlmKCFzZWN0aW9uMSB8fCAhc2VjdGlvbjIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzYW1lQ2xhc3NlcyA9IHNlY3Rpb24xLmNsYXNzTGlzdC50b1N0cmluZygpLnJlcGxhY2UoL2ZvY3VzZWQtYnktYXBpLWFjdG9yLiotZmJhYWVuZC9nLCAnJykucmVwbGFjZSgvZm9jdXNlZC9nLCAnJykucmVwbGFjZSgvXFxzL2csICcnKSA9PT0gc2VjdGlvbjIuY2xhc3NMaXN0LnRvU3RyaW5nKCkucmVwbGFjZSgvZm9jdXNlZC1ieS1hcGktYWN0b3IuKi1mYmFhZW5kL2csICcnKS5yZXBsYWNlKC9mb2N1c2VkL2csICcnKS5yZXBsYWNlKC9cXHMvZywgJycpLFxuICAgICAgICAgIHNhbWVUYWdzID0gc2VjdGlvbjEudGFnTmFtZSA9PT0gc2VjdGlvbjIudGFnTmFtZTtcblxuICAgICAgICByZXR1cm4gc2FtZVRhZ3MgJiYgc2FtZUNsYXNzZXM7XG4gICAgfSxcblxuICAgIF9nZXRTZWN0aW9uQXR0cmlidXRlU2lnbml0dXJlOiBmdW5jdGlvbihzZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShPYmplY3QudmFsdWVzKHNlY3Rpb24uYXR0cmlidXRlcylcbiAgICAgICAgICAgIC5maWx0ZXIoYXR0ciA9PiBhdHRyLm5hbWUgIT09ICdjbGFzcycgJiYgYXR0ci5uYW1lICE9PSAnY29udGVudGVkaXRhYmxlJylcbiAgICAgICAgICAgIC5tYXAoYXR0ciA9PiAoeyBbYXR0ci5uYW1lXTogYXR0ci52YWx1ZSB9KSkpXG4gICAgfSxcblxuICAgIF9hcmVFcXVhbFNlY3Rpb25zOiBmdW5jdGlvbihzZWN0aW9uMSwgc2VjdGlvbjIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzU2FtZVNlY3Rpb25UeXBlKHNlY3Rpb24xLCBzZWN0aW9uMikgJiZcbiAgICAgICAgICAgIHNlY3Rpb24xLmlubmVySFRNTC5sZW5ndGggPT09IHNlY3Rpb24yLmlubmVySFRNTC5sZW5ndGggJiZcbiAgICAgICAgICAgIHRoaXMuX2dldFNlY3Rpb25BdHRyaWJ1dGVTaWduaXR1cmUoc2VjdGlvbjEpID09PSB0aGlzLl9nZXRTZWN0aW9uQXR0cmlidXRlU2lnbml0dXJlKHNlY3Rpb24yKSAmJlxuICAgICAgICAgICAgc2VjdGlvbjEuaW5uZXJIVE1MID09PSBzZWN0aW9uMi5pbm5lckhUTUxcbiAgICB9LFxuXG4gICAgX3JlcGxhY2VTZWN0aW9uczogZnVuY3Rpb24ob2xkU2VjdGlvbiwgbmV3U2VjdGlvbiwgYXJncykge1xuICAgICAgICBuZXdTZWN0aW9uLnNldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJywgdHJ1ZSk7XG5cbiAgICAgICAgb2xkU2VjdGlvbi5zdW1tYXJpemVkQ29udGVudExlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbmV3U2VjdGlvbi5zdW1tYXJpemVkQ29udGVudExlbmd0aCA9IHVuZGVmaW5lZDtcblxuICAgICAgICBpZih0aGlzLl9pc1NhbWVTZWN0aW9uVHlwZShvbGRTZWN0aW9uLCBuZXdTZWN0aW9uKSkge1xuICAgICAgICAgICAgdXRpbHMuY29weUV2ZW50TGlzdGVuZXJzUmVjdXJzaXZlbHkob2xkU2VjdGlvbiwgbmV3U2VjdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZihuZXdTZWN0aW9uLm9uTWFya3VwQ2xlYW5pbmdGaW5zaGVkKSB7XG4gICAgICAgICAgICBuZXdTZWN0aW9uLm9uTWFya3VwQ2xlYW5pbmdGaW5zaGVkKG5ld1NlY3Rpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIXRoaXMuX2FyZUVxdWFsU2VjdGlvbnMobmV3U2VjdGlvbiwgb2xkU2VjdGlvbikgfHwgKG5ld1NlY3Rpb24gJiYgbmV3U2VjdGlvbi5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZpY2F0aW9uTG9nRW50cnkucmVwbGFjZVNlY3Rpb24ob2xkU2VjdGlvbiwgbmV3U2VjdGlvbik7XG5cbiAgICAgICAgICAgIGlmKGFyZ3MuYWN0b3IpIHtcbiAgICAgICAgICAgICAgICBuZXdTZWN0aW9uLmNsYXNzTGlzdC5hZGQoJ2ZvY3VzZWQtYnktYXBpLWFjdG9yJysgYXJncy5hY3Rvci5pZCArICctZmJhYWVuZCcpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudExlbmd0aFRpbGxTZWN0aW9uU3RhcnQgPSBhcmdzLmNhcmV0LmdldENvbnRlbnRMZW5ndGhUaWxsU2VjdGlvbihvbGRTZWN0aW9uKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkaWZmID0gZGlmZkVuZ2luZVxuICAgICAgICAgICAgICAgICAgICAuZGlmZl9tYWluKGFyZ3MuY2FyZXQuX2dldENvbnRlbnRMZW5ndGhJbmNyZW1lbnRNYXNrZWRUZXh0KG9sZFNlY3Rpb24pLCBhcmdzLmNhcmV0Ll9nZXRDb250ZW50TGVuZ3RoSW5jcmVtZW50TWFza2VkVGV4dChuZXdTZWN0aW9uKSlcbiAgICAgICAgICAgICAgICAgICAgLmZsYXRNYXAoYSA9PiBhWzFdLnNwbGl0KCcnKS5tYXAoaWEgPT4gYVswXSkpO1xuXG4gICAgICAgICAgICAgICAgaWYoYXJncy5jYXJldC5yYW5nZVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvblN0YXJ0T2Zmc2V0V2l0aGluU2VjdGlvbiA9IGFyZ3MuY2FyZXQucmFuZ2VTdGFydCAtIGNvbnRlbnRMZW5ndGhUaWxsU2VjdGlvblN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGlmaWNhdGlvbkxvZ0VudHJ5Lmluc2VydGVkQmVmb3JlU2VsZWN0aW9uUmFuZ2VTdGFydCArPSBkaWZmXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2xpY2UoMCwgc2VsZWN0aW9uU3RhcnRPZmZzZXRXaXRoaW5TZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYyArIHZhbCwgMCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYoYXJncy5jYXJldC5yYW5nZUVuZCAmJiBhcmdzLmNhcmV0LnJhbmdlRW5kICE9PSBhcmdzLmNhcmV0LnJhbmdlU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uU3RhcnRPZmZzZXRXaXRoaW5TZWN0aW9uID0gYXJncy5jYXJldC5yYW5nZUVuZCAtIGNvbnRlbnRMZW5ndGhUaWxsU2VjdGlvblN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGlmaWNhdGlvbkxvZ0VudHJ5Lmluc2VydGVkQmVmb3JlU2VsZWN0aW9uUmFuZ2VFbmQgKz0gZGlmZlxuICAgICAgICAgICAgICAgICAgICAgICAgLnNsaWNlKDAsIHNlbGVjdGlvblN0YXJ0T2Zmc2V0V2l0aGluU2VjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MgKyB2YWwsIDApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZihhcmdzLmNhcmV0LnJhbmdlRW5kID09PSBhcmdzLmNhcmV0LnJhbmdlU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeS5pbnNlcnRlZEJlZm9yZVNlbGVjdGlvblJhbmdlRW5kID0gdGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeS5pbnNlcnRlZEJlZm9yZVNlbGVjdGlvblJhbmdlU3RhcnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRFbGVtZW50LnJlcGxhY2VDaGlsZChuZXdTZWN0aW9uLCBvbGRTZWN0aW9uKTtcblxuICAgICAgICAgICAgaWYob2xkU2VjdGlvbiA9PT0gdGhpcy5mb2N1c2VkU2VjdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZpY2F0aW9uTG9nRW50cnkuZm9jdXNlZFNlY3Rpb25IYXNCZWVuTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZpY2F0aW9uTG9nRW50cnkuZm9jdXNlZFNlY3Rpb25SZXBsYWNlbWVudCA9IG5ld1NlY3Rpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXdTZWN0aW9uO1xuICAgICAgICB9IGVsc2UgaWYob2xkU2VjdGlvbi5vcmlnaW5hbEhUTUwgIT09IG5ld1NlY3Rpb24ub3JpZ2luYWxIVE1MKSB7XG4gICAgICAgICAgICAvLyB3ZSBlbmQgdXAgaW4gdGhpcyBicmFuY2ggd2hlbiB3ZSBzaW1wbHkgdHlwZSB0ZXh0IGludG8gYSBzZWN0aW9uLlxuICAgICAgICAgICAgLy8gaW4gdGhpcyBjYXNlIHRoZSBhY3R1YWwgRE9NIGlzIGFscmVhZHkgb24gdGhlIGFjdHVhbCBzdGF0ZSwgb25seVxuICAgICAgICAgICAgLy8gdGhlIG9yaWdpbmFsSFRNTCBhdHRyaWJ1dGUgbXVzdCBiZSB1cGRhdGVkLlxuICAgICAgICAgICAgdGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeS5yZXBsYWNlU2VjdGlvbihvbGRTZWN0aW9uLCBuZXdTZWN0aW9uKTtcblxuICAgICAgICAgICAgb2xkU2VjdGlvbi5vcmlnaW5hbEhUTUwgPSBuZXdTZWN0aW9uLm9yaWdpbmFsSFRNTDtcblxuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeS5tb2RMb2dGbGFncykuZm9yRWFjaChmdW5jdGlvbihmbGFnKSB7XG4gICAgICAgICAgICAgICAgb2xkU2VjdGlvblsnb3JpZ2luYWxIVE1MQ29udGFpbnMnICsgZmxhZ10gPSBuZXdTZWN0aW9uWydvcmlnaW5hbEhUTUxDb250YWlucycgKyBmbGFnXTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZihvbGRTZWN0aW9uID09PSB0aGlzLmZvY3VzZWRTZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeS5mb2N1c2VkU2VjdGlvbkhhc0JlZW5Nb2RpZmllZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeS5mb2N1c2VkU2VjdGlvbkRPTVdhc05vdE1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmaWNhdGlvbkxvZ0VudHJ5LmZvY3VzZWRTZWN0aW9uUmVwbGFjZW1lbnQgPSBuZXdTZWN0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvbGRTZWN0aW9uLndvcmRDb3VudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJldHVybiBvbGRTZWN0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeS5yZXRhaW5TZWN0aW9uKG9sZFNlY3Rpb24pO1xuICAgICAgICByZXR1cm4gb2xkU2VjdGlvbjtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRG9jdW1lbnR1cGRhdGVyO1xuIiwidmFyIGRpZmZNYXRjaFBhdGNoID0gcmVxdWlyZSgnZGlmZl9tYXRjaF9wYXRjaCcpLFxuICAgIGRpZmZFbmdpbmUgPSBuZXcgZGlmZk1hdGNoUGF0Y2guZGlmZl9tYXRjaF9wYXRjaDtcblxudmFyIERJRkZfREVMRVRFID0gLTE7XG52YXIgRElGRl9JTlNFUlQgPSAxO1xudmFyIERJRkZfRVFVQUwgPSAwO1xuXG5mdW5jdGlvbiBNb2RpZmljYXRpb25Mb2dFbnRyeSgpIHtcbiAgICB0aGlzLmxvZyA9IFtdO1xufVxuXG5Nb2RpZmljYXRpb25Mb2dFbnRyeS5wcm90b3R5cGUgPSB7XG5cbiAgICBzZXRGbGFnc0ZvcjogZnVuY3Rpb24oc2VjdGlvbikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBtb2RMb2dGbGFncyA9IHRoaXMubW9kTG9nRmxhZ3M7XG5cbiAgICAgICAgaWYoIW1vZExvZ0ZsYWdzKSB7IHJldHVybjsgfVxuXG4gICAgICAgIE9iamVjdC5rZXlzKG1vZExvZ0ZsYWdzKS5mb3JFYWNoKGZ1bmN0aW9uKGZsYWcpIHtcbiAgICAgICAgICAgIGlmKHNlbGZbJ21pZ2h0SW5jbHVkZScgKyBmbGFnICsgJ1VwZGF0ZXMnXSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoc2VjdGlvblsnb3JpZ2luYWxIVE1MQ29udGFpbnMnICsgZmxhZ10pIHtcbiAgICAgICAgICAgICAgICBzZWxmWydtaWdodEluY2x1ZGUnICsgZmxhZyArICdVcGRhdGVzJ10gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZlsnbWlnaHRJbmNsdWRlJyArIGZsYWcgKyAnVXBkYXRlcyddID0gbW9kTG9nRmxhZ3NbZmxhZ10uc29tZShmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWN0aW9uLm1hdGNoZXMoc2VsZWN0b3IpIHx8IHNlY3Rpb24ucXVlcnlTZWxlY3RvcihzZWxlY3RvcilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgdG9DaGFuZ2VzZXQ6IGZ1bmN0aW9uKENoYW5nZXNldCkge1xuICAgICAgICB2YXIgY3MgPSBDaGFuZ2VzZXQuY3JlYXRlKCk7XG4gICAgICAgIHZhciB3YXNMYXN0T3BUeXBlUmV0YWluID0gZmFsc2UsIGxhc3RPcHRUeXBlTGVuZ3RoID0gMDtcblxuICAgICAgICB0aGlzLmxvZy5mb3JFYWNoKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICBpZihlbnRyeS50eXBlID09PSAncmV0YWluJykge1xuICAgICAgICAgICAgICAgIHdhc0xhc3RPcFR5cGVSZXRhaW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGxhc3RPcHRUeXBlTGVuZ3RoICs9IGVudHJ5LnNlY3Rpb25IVE1MLmxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAod2FzTGFzdE9wVHlwZVJldGFpbikge1xuICAgICAgICAgICAgICAgIGNzLnJldGFpbihsYXN0T3B0VHlwZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgd2FzTGFzdE9wVHlwZVJldGFpbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxhc3RPcHRUeXBlTGVuZ3RoID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVudHJ5LnR5cGUgPT09ICdkZWxldGUnKSB7XG4gICAgICAgICAgICAgICAgY3MuZGVsZXRlKGVudHJ5LnNlY3Rpb25IVE1MKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZW50cnkudHlwZSA9PT0gJ2luc2VydCcpIHtcbiAgICAgICAgICAgICAgICBjcy5pbnNlcnQoZW50cnkuc2VjdGlvbkhUTUwpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlbnRyeS50eXBlID09PSAncmVwbGFjZScpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlmZiA9IGRpZmZFbmdpbmUuZGlmZl9tYWluKGVudHJ5Lm9sZFNlY3Rpb25IVE1MLCBlbnRyeS5uZXdTZWN0aW9uSFRNTCk7XG5cbiAgICAgICAgICAgICAgICBkaWZmLmZvckVhY2goZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoRElGRl9ERUxFVEUgPT0gZFswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3MuZGVsZXRlKGRbMV0pXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoRElGRl9JTlNFUlQgPT0gZFswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3MuaW5zZXJ0KGRbMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoRElGRl9FUVVBTCA9PSBkWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY3MucmV0YWluKGRbMV0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAod2FzTGFzdE9wVHlwZVJldGFpbikge1xuICAgICAgICAgICAgY3MucmV0YWluKGxhc3RPcHRUeXBlTGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjcy5lbmQoKTtcbiAgICB9LFxuXG4gICAgYWZ0ZXJTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgICAgdGhpcy5sb2cuZm9yRWFjaChmdW5jdGlvbihsb2cpIHtcbiAgICAgICAgICAgIGlmKGxvZy50eXBlID09PSAncmV0YWluJyB8fCBsb2cudHlwZSA9PT0gJ2luc2VydCcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gbG9nLnNlY3Rpb25IVE1MO1xuICAgICAgICAgICAgfSBlbHNlIGlmKGxvZy50eXBlID09PSAncmVwbGFjZScpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gbG9nLm5ld1NlY3Rpb25IVE1MO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBiZWZvcmVTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgICAgdGhpcy5sb2cuZm9yRWFjaChmdW5jdGlvbihsb2cpIHtcbiAgICAgICAgICAgIGlmKGxvZy50eXBlID09PSAncmV0YWluJyB8fCBsb2cudHlwZSA9PT0gJ2RlbGV0ZScpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gbG9nLnNlY3Rpb25IVE1MO1xuICAgICAgICAgICAgfSBlbHNlIGlmKGxvZy50eXBlID09PSAncmVwbGFjZScpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gbG9nLm9sZFNlY3Rpb25IVE1MO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICByZXRhaW5TZWN0aW9uOiBmdW5jdGlvbihzZWN0aW9uKSB7XG4gICAgICAgIHRoaXMubG9nLnB1c2goe3R5cGU6ICdyZXRhaW4nLCBzZWN0aW9uSFRNTDogc2VjdGlvbi5vcmlnaW5hbEhUTUx9KTtcbiAgICB9LFxuXG4gICAgZGVsZXRlU2VjdGlvbjogZnVuY3Rpb24oc2VjdGlvbikge1xuICAgICAgICB0aGlzLmxvZy5wdXNoKHt0eXBlOiAnZGVsZXRlJywgc2VjdGlvbkhUTUw6IHNlY3Rpb24ub3JpZ2luYWxIVE1MfSk7XG4gICAgICAgIHRoaXMuc2V0RmxhZ3NGb3Ioc2VjdGlvbik7XG4gICAgfSxcblxuICAgIHJlcGxhY2VTZWN0aW9uOiBmdW5jdGlvbihvbGRTZWMsIG5ld1NlYykge1xuICAgICAgICB0aGlzLmxvZy5wdXNoKHt0eXBlOiAncmVwbGFjZScsIG9sZFNlY3Rpb25IVE1MOiBvbGRTZWMub3JpZ2luYWxIVE1MLCBuZXdTZWN0aW9uSFRNTDogbmV3U2VjLm9yaWdpbmFsSFRNTH0pO1xuICAgICAgICB0aGlzLnNldEZsYWdzRm9yKG5ld1NlYyk7XG4gICAgICAgIHRoaXMuc2V0RmxhZ3NGb3Iob2xkU2VjKTtcbiAgICB9LFxuXG4gICAgaW5zZXJ0U2VjdGlvbjogZnVuY3Rpb24oc2VjdGlvbikge1xuICAgICAgICB0aGlzLmxvZy5wdXNoKHt0eXBlOiAnaW5zZXJ0Jywgc2VjdGlvbkhUTUw6IHNlY3Rpb24ub3JpZ2luYWxIVE1MfSlcbiAgICAgICAgdGhpcy5zZXRGbGFnc0ZvcihzZWN0aW9uKTtcbiAgICB9LFxuXG4gICAgZGVsZXRlU2VjdGlvbkF0OiBmdW5jdGlvbihpbmRleCwgc2VjdGlvbikge1xuICAgICAgICB2YXIgb2xkTG9nO1xuXG4gICAgICAgIGlmKHRoaXMubG9nW2luZGV4XSAmJiB0aGlzLmxvZ1tpbmRleF0udHlwZSAhPT0gJ2luc2VydCcpIHtcbiAgICAgICAgICAgIG9sZExvZyA9IHRoaXMubG9nW2luZGV4XTtcbiAgICAgICAgICAgIHRoaXMubG9nW2luZGV4XSA9IHsgdHlwZTogJ2RlbGV0ZScsIHNlY3Rpb25IVE1MOiB0aGlzLmxvZ1tpbmRleF0ub2xkU2VjdGlvbkhUTUwgfHwgdGhpcy5sb2dbaW5kZXhdLnNlY3Rpb25IVE1MIH07XG4gICAgICAgIH0gZWxzZSBpZih0aGlzLmxvZ1tpbmRleF0gJiYgdGhpcy5sb2dbaW5kZXhdLnR5cGUgPT09ICdpbnNlcnQnKSB7XG4gICAgICAgICAgICBvbGRMb2cgPSB0aGlzLmxvZy5zcGxpY2UoaW5kZXgsIDEpWzBdOyAvL3JlbW92ZSBhcnJheSBlbGVtZW50IHdpdGggaW5kZXggXCJpbmRleFwiXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldEZsYWdzRm9yKHNlY3Rpb24pO1xuXG4gICAgICAgIHJldHVybiBvbGRMb2c7XG4gICAgfSxcblxuICAgIHJldGFpbkFsbFNlY3Rpb25zQmVmb3JlOiBmdW5jdGlvbihzZWN0aW9uKSB7XG4gICAgICAgIGlmKCFzZWN0aW9uKSByZXR1cm47XG4gICAgICAgIHZhciB0bXBTZWMgPSBzZWN0aW9uLnBhcmVudEVsZW1lbnQuY2hpbGRyZW5bMF07XG4gICAgICAgIHdoaWxlKHRtcFNlYyAhPT0gc2VjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5yZXRhaW5TZWN0aW9uKHRtcFNlYyk7XG4gICAgICAgICAgICB0bXBTZWMgPSB0bXBTZWMubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmV0YWluQWxsU2VjdGlvbnNBZnRlcjogZnVuY3Rpb24oc2VjdGlvbikge1xuICAgICAgICBpZighc2VjdGlvbikgcmV0dXJuO1xuICAgICAgICB2YXIgdG1wU2VjID0gc2VjdGlvbi5uZXh0U2libGluZztcbiAgICAgICAgd2hpbGUodG1wU2VjKSB7XG4gICAgICAgICAgICB0aGlzLnJldGFpblNlY3Rpb24odG1wU2VjKTtcbiAgICAgICAgICAgIHRtcFNlYyA9IHRtcFNlYy5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBpbmNsdWRlc0hlYWRpbmdVcGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmluY2x1ZGVzSGVhZGluZ1VwZGF0ZXM7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNb2RpZmljYXRpb25Mb2dFbnRyeTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgIHZhciBuZXh0VmFsdWUgPSBzdHJlYW0ubmV4dCgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjb25zdCB0aGlzUm91bmQgPSBuZXh0VmFsdWU7XG4gICAgICAgICAgICBuZXh0VmFsdWUgPSBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNSb3VuZDtcbiAgICAgICAgfSxcbiAgICAgICAgbG9va2FoZWFkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0VmFsdWVcbiAgICAgICAgfVxuICAgIH07XG59IiwidmFyIFN0YXRlTWFjaGluZSA9IHJlcXVpcmUoJy4vc3RhdGVfbWFjaGluZS5qcycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vcGl4ZWxzY2h1YnNlci91dGlscycpO1xudmFyIG5hbWVkRW5jb2RpbmdzID0ge3F1b3Q6IDM0LCBhbXA6IDM4LCBsdDogNjAsIGd0OiA2MiwgbmJzcDogMTYwLCBjb3B5OiAxNjksIHJlZzogMTc0LCBkZWc6IDE3NiwgZnJhc2w6IDQ3LCB0cmFkZTogODQ4MiwgZXVybzogODM2NCwgQWdyYXZlOiAxOTIsIEFhY3V0ZTogMTkzLCBBY2lyYzogMTk0LCBBdGlsZGU6IDE5NSwgQXVtbDogMTk2LCBBcmluZzogMTk3LCBBRWxpZzogMTk4LCBDY2VkaWw6IDE5OSwgRWdyYXZlOiAyMDAsIEVhY3V0ZTogMjAxLCBFY2lyYzogMjAyLCBFdW1sOiAyMDMsIElncmF2ZTogMjA0LCBJYWN1dGU6IDIwNSwgSWNpcmM6IDIwNiwgSXVtbDogMjA3LCBFVEg6IDIwOCwgTnRpbGRlOiAyMDksIE9ncmF2ZTogMjEwLCBPYWN1dGU6IDIxMSwgT2NpcmM6IDIxMiwgT3RpbGRlOiAyMTMsIE91bWw6IDIxNCwgdGltZXM6IDIxNSwgT3NsYXNoOiAyMTYsIFVncmF2ZTogMjE3LCBVYWN1dGU6IDIxOCwgVWNpcmM6IDIxOSwgVXVtbDogMjIwLCBZYWN1dGU6IDIyMSwgVEhPUk46IDIyMiwgc3psaWc6IDIyMywgYWdyYXZlOiAyMjQsIGFhY3V0ZTogMjI1LCBhY2lyYzogMjI2LCBhdGlsZGU6IDIyNywgYXVtbDogMjI4LCBhcmluZzogMjI5LCBhZWxpZzogMjMwLCBjY2VkaWw6IDIzMSwgZWdyYXZlOiAyMzIsIGVhY3V0ZTogMjMzLCBlY2lyYzogMjM0LCBldW1sOiAyMzUsIGlncmF2ZTogMjM2LCBpYWN1dGU6IDIzNywgaWNpcmM6IDIzOCwgaXVtbDogMjM5LCBldGg6IDI0MCwgbnRpbGRlOiAyNDEsIG9ncmF2ZTogMjQyLCBvYWN1dGU6IDI0Mywgb2NpcmM6IDI0NCwgb3RpbGRlOiAyNDUsIG91bWw6IDI0NiwgZGl2aWRlOiAyNDcsIG9zbGFzaDogMjQ4LCB1Z3JhdmU6IDI0OSwgdWFjdXRlOiAyNTAsIHVjaXJjOiAyNTEsIHV1bWw6IDI1MiwgeWFjdXRlOiAyNTMsIHRob3JuOiAyNTQsIHl1bWw6IDI1NSwgbHNxdW86IDgyMTYsIHJzcXVvOiA4MjE3LCBzYnF1bzogODIxOCwgbGRxdW86IDgyMjAsIHJkcXVvOiA4MjIxLCBiZHF1bzogODIyMiwgZGFnZ2VyOiA4MjI0LCBEYWdnZXI6IDgyMjUsIHBlcm1pbDogODI0MCwgbHNhcXVvOiA4MjQ5LCByc2FxdW86IDgyNTAsIHNwYWRlczogOTgyNCwgY2x1YnM6IDk4MjcsIGhlYXJ0czogOTgyOSwgZGlhbXM6IDk4MzAsIG9saW5lOiA4MjU0LCBsYXJyOiA4NTkyLCB1YXJyOiA4NTkzLCByYXJyOiA4NTk0LCBkYXJyOiA4NTk1LCBoZWxsaXA6IDEzMywgbmRhc2g6IDE1MCwgbWRhc2g6IDE1MSwgaWV4Y2w6IDE2MSwgY2VudDogMTYyLCBwb3VuZDogMTYzLCBjdXJyZW46IDE2NCwgeWVuOiAxNjUsIGJydmJhcjogMTY2LCBicmtiYXI6IDE2Niwgc2VjdDogMTY3LCB1bWw6IDE2OCwgZGllOiAxNjgsIG9yZGY6IDE3MCwgbGFxdW86IDE3MSwgbm90OiAxNzIsIHNoeTogMTczLCBtYWNyOiAxNzUsIGhpYmFyOiAxNzUsIHBsdXNtbjogMTc3LCBzdXAyOiAxNzgsIHN1cDM6IDE3OSwgYWN1dGU6IDE4MCwgbWljcm86IDE4MSwgcGFyYTogMTgyLCBtaWRkb3Q6IDE4MywgY2VkaWw6IDE4NCwgc3VwMTogMTg1LCBvcmRtOiAxODYsIHJhcXVvOiAxODcsIGZyYWMxNDogMTg4LCBmcmFjMTI6IDE4OSwgZnJhYzM0OiAxOTAsIGlxdWVzdDogMTkxLCBBbHBoYTogOTEzLCBhbHBoYTogOTQ1LCBCZXRhOiA5MTQsIGJldGE6IDk0NiwgR2FtbWE6IDkxNSwgZ2FtbWE6IDk0NywgRGVsdGE6IDkxNiwgZGVsdGE6IDk0OCwgRXBzaWxvbjogOTE3LCBlcHNpbG9uOiA5NDksIFpldGE6IDkxOCwgemV0YTogOTUwLCBFdGE6IDkxOSwgZXRhOiA5NTEsIFRoZXRhOiA5MjAsIHRoZXRhOiA5NTIsIElvdGE6IDkyMSwgaW90YTogOTUzLCBLYXBwYTogOTIyLCBrYXBwYTogOTU0LCBMYW1iZGE6IDkyMywgbGFtYmRhOiA5NTUsIE11OiA5MjQsIG11OiA5NTYsIE51OiA5MjUsIG51OiA5NTcsIFhpOiA5MjYsIHhpOiA5NTgsIE9taWNyb246IDkyNywgb21pY3JvbjogOTU5LCBQaTogOTI4LCBwaTogOTYwLCBSaG86IDkyOSwgcmhvOiA5NjEsIFNpZ21hOiA5MzEsIHNpZ21hOiA5NjMsIFRhdTogOTMyLCB0YXU6IDk2NCwgVXBzaWxvbjogOTMzLCB1cHNpbG9uOiA5NjUsIFBoaTogOTM0LCBwaGk6IDk2NiwgQ2hpOiA5MzUsIGNoaTogOTY3LCBQc2k6IDkzNiwgcHNpOiA5NjgsIE9tZWdhOiA5MzcsIG9tZWdhOiA5Njl9O1xuXG5mdW5jdGlvbiBIVE1MUmF6b3IodGFnVHJhbnNmb3JtYXRpb25zLCBydWxlcykge1xuICAgIHRoaXMudGFnVHJhbnNmb3JtYXRpb25zID0gdGFnVHJhbnNmb3JtYXRpb25zICB8fCB7fTtcbiAgICB0aGlzLnJ1bGVzID0gcnVsZXM7XG4gICAgdGhpcy5ydWxlTmFtZUJ5RWxlbWVudENhY2hlID0ge307XG4gICAgdGhpcy5ydWxlTmFtZUJ5VG9rZW5DYWNoZSA9IHt9O1xuICAgIHRoaXMudGFnVHJhbnNmb3JtYXRpb25CeU5vZGVDYWNoZSA9IHt9O1xuICAgIHRoaXMuc3RhdGVNYWNoaW5lID0gbmV3IFN0YXRlTWFjaGluZSgpO1xuICAgIHRoaXMudGVtcHJvYXJ5UHJ1bmVQcm90ZWN0ZWRXaGl0ZXNwYWNlID0gJ1xcdTI1ODgnO1xufVxuXG5IVE1MUmF6b3IucHJvdG90eXBlID0ge1xuXG4gICAgZ2V0UnVsZU5hbWVzQnlUYWc6IGZ1bmN0aW9uKHRhZ05hbWUpIHtcbiAgICAgICAgdGhpcy5ydWxlRW50cmllcyA9IHRoaXMucnVsZUVudHJpZXMgfHwgT2JqZWN0LmVudHJpZXModGhpcy5ydWxlcyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucnVsZUVudHJpZXMuZmlsdGVyKGZ1bmN0aW9uKHJ1bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBydWxlWzFdLnRhZ05hbWUgPT09IHRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSkubWFwKGZ1bmN0aW9uKHJ1bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBydWxlWzBdO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgZG9lc0VsZW1lbnRNYXRjaFJ1bGU6IGZ1bmN0aW9uKGVsZW1lbnQsIHJ1bGUpIHtcbiAgICAgICAgaWYoIWVsZW1lbnQgfHwgIXJ1bGUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYocnVsZS50YWdOYW1lICE9PSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYocnVsZS5jbGFzc05hbWUgJiYgIWVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKHJ1bGUuY2xhc3NOYW1lKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICBkb2VzRWxlbWVudE1hdGNoT25lUnVsZTogZnVuY3Rpb24oZWxlbWVudCwgcnVsZU5hbWVzKSB7XG4gICAgICAgIGZvcihsZXQgaT0wOyBpPHJ1bGVOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYodGhpcy5kb2VzRWxlbWVudE1hdGNoUnVsZShlbGVtZW50LCB0aGlzLnJ1bGVzW3J1bGVOYW1lc1tpXV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBsb29rdXBSdWxlTmFtZUNhY2hlRm9yOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIGlmKHQubm9kZU5hbWUgJiYgdGhpcy5ydWxlTmFtZUJ5RWxlbWVudENhY2hlW3Qubm9kZU5hbWVdICYmIHRoaXMucnVsZU5hbWVCeUVsZW1lbnRDYWNoZVt0Lm5vZGVOYW1lXVt0LmNsYXNzTmFtZV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1bGVOYW1lQnlFbGVtZW50Q2FjaGVbdC5ub2RlTmFtZV1bdC5jbGFzc05hbWVdO1xuICAgICAgICB9IGVsc2UgaWYodGhpcy5ydWxlTmFtZUJ5VG9rZW5DYWNoZVt0LnZhbHVlXSAmJiB0aGlzLnJ1bGVOYW1lQnlUb2tlbkNhY2hlW3QudmFsdWVdKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1bGVOYW1lQnlUb2tlbkNhY2hlW3QudmFsdWVdW3QuY2xhc3NOYW1lc107XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY2FjaGVSdWxlTmFtZUZvcjogZnVuY3Rpb24odCwgcmVzdWx0KSB7XG5cbiAgICAgICAgaWYoIXJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodC5ub2RlTmFtZSkge1xuICAgICAgICAgICAgaWYoIXRoaXMucnVsZU5hbWVCeUVsZW1lbnRDYWNoZVt0Lm5vZGVOYW1lXSkge1xuICAgICAgICAgICAgICAgIHRoaXMucnVsZU5hbWVCeUVsZW1lbnRDYWNoZVt0Lm5vZGVOYW1lXSA9IHt9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucnVsZU5hbWVCeUVsZW1lbnRDYWNoZVt0Lm5vZGVOYW1lXVt0LmNsYXNzTmFtZV0gPSByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZighdGhpcy5ydWxlTmFtZUJ5VG9rZW5DYWNoZVt0LnZhbHVlXSkge1xuICAgICAgICAgICAgICAgIHRoaXMucnVsZU5hbWVCeVRva2VuQ2FjaGVbdC52YWx1ZV0gPSB7fVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnJ1bGVOYW1lQnlUb2tlbkNhY2hlW3QudmFsdWVdW3QuY2xhc3NOYW1lc10gPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0UnVsZU5hbWVCeUVsZW1lbnQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdmFyIHJ1bGVzID0gdGhpcy5ydWxlcyxcbiAgICAgICAgICAgIHJlc3VsdCwgdG9rZW5DbGFzc05hbWVzLCByZXN1bHRDYW5kaWRhdGVzLCB0bXBSZXN1bHQ7XG5cbiAgICAgICAgaWYoIXQpIHJldHVybjtcbiAgICAgICAgaWYodC5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHJldHVybiAnI3RleHQnO1xuXG4gICAgICAgIHJlc3VsdCA9IHRoaXMubG9va3VwUnVsZU5hbWVDYWNoZUZvcih0KTtcbiAgICAgICAgaWYocmVzdWx0ID09PSAtMSkgcmV0dXJuO1xuICAgICAgICBpZihyZXN1bHQpIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgdG9rZW5DbGFzc05hbWVzID0gKHQgJiYgdC5hdHRyaWJ1dGVzICYmIHQuYXR0cmlidXRlc1snY2xhc3NOYW1lcyddKSB8fCB0LmNsYXNzTGlzdCB8fCBbXTtcbiAgICAgICAgcmVzdWx0Q2FuZGlkYXRlcyA9IHRoaXMuZ2V0UnVsZU5hbWVzQnlUYWcodC52YWx1ZSB8fCB0Lm5vZGVOYW1lKTtcblxuICAgICAgICBpZih0b2tlbkNsYXNzTmFtZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB0bXBSZXN1bHQgPSByZXN1bHRDYW5kaWRhdGVzLmZpbmQoZnVuY3Rpb24ocmMpIHtcbiAgICAgICAgICAgICAgICBpZighcnVsZXNbcmNdLmNsYXNzTmFtZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpPTA7IGk8dG9rZW5DbGFzc05hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHJ1bGVzW3JjXS5jbGFzc05hbWUgPT09IHRva2VuQ2xhc3NOYW1lc1tpXSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSB0bXBSZXN1bHQgfHwgcmVzdWx0Q2FuZGlkYXRlcy5maW5kKGZ1bmN0aW9uKHJjKSB7XG4gICAgICAgICAgICByZXR1cm4gIXJ1bGVzW3JjXS5jbGFzc05hbWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuY2FjaGVSdWxlTmFtZUZvcih0LCByZXN1bHQpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGdldFJ1bGVCeUVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucnVsZXNbdGhpcy5nZXRSdWxlTmFtZUJ5RWxlbWVudChlbGVtZW50KV07XG4gICAgfSxcblxuICAgIGlzVG9rZW5BbGxvd2VkVG9CZVJvb3RFbGVtZW50OiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHZhciBydWxlID0gdGhpcy5ydWxlcyAmJiB0aGlzLnJ1bGVzW3RoaXMuZ2V0UnVsZU5hbWVCeUVsZW1lbnQodCldO1xuICAgICAgICByZXR1cm4gcnVsZSAmJiBydWxlLmFsbG93ZWRUb0JlUm9vdDtcbiAgICB9LFxuXG4gICAgaXNUb2tlbkFsbG93ZWRUb0NvbnRhaW5JdHNlbGY6IGZ1bmN0aW9uKHQpIHtcbiAgICAgIHZhciBydWxlTmFtZSA9IHRoaXMuZ2V0UnVsZU5hbWVCeUVsZW1lbnQodCksXG4gICAgICAgICAgcnVsZSA9IHRoaXMucnVsZXMgJiYgdGhpcy5ydWxlc1tydWxlTmFtZV07XG5cbiAgICAgICAgaWYoIXJ1bGUuYWxsb3dlZENoaWxkcmVuKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBydWxlLmFsbG93ZWRDaGlsZHJlbi5pbmRleE9mKHJ1bGVOYW1lKSAhPT0gLTE7XG4gICAgfSxcblxuICAgIHJvb3RFbGVtZW50c1Nob3VsZE5vdEJyZWFrT3V0RnJvbTogZnVuY3Rpb24ocGFyZW50Tm9kZSkge1xuICAgICAgICB2YXIgcnVsZSA9IHRoaXMuZ2V0UnVsZUJ5RWxlbWVudChwYXJlbnROb2RlKTtcbiAgICAgICAgaWYoIXJ1bGUpIHsgcmV0dXJuIGZhbHNlIH1cblxuICAgICAgICByZXR1cm4gISFydWxlLmRvTm90QnJlYWtPdXRSb290RWxlbWVudHM7XG4gICAgfSxcblxuICAgIGNhY2hlVGFnVHJhbnNmb3JtYXRpb25Gb3I6IGZ1bmN0aW9uKHRva2VuUGF0aEluUGFyc2VkVHJlZSwgcmVzdWx0KSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCB8fCAtMTtcbiAgICAgICAgdGhpcy50YWdUcmFuc2Zvcm1hdGlvbkJ5Tm9kZUNhY2hlW3Rva2VuUGF0aEluUGFyc2VkVHJlZV0gPSByZXN1bHQ7XG4gICAgICAgIHJldHVybiByZXN1bHQgPT0gLTEgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGxvb2NrdXBUYWdUcmFuc2Zvcm1hdGlvbkNhY2hlRm9yOiBmdW5jdGlvbih0b2tlblBhdGhJblBhcnNlZFRyZWUsIGNsYXNzTGlzdCkge1xuICAgICAgICBpZihjbGFzc0xpc3QgJiYgY2xhc3NMaXN0Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy50YWdUcmFuc2Zvcm1hdGlvbkJ5Tm9kZUNhY2hlW3Rva2VuUGF0aEluUGFyc2VkVHJlZV0gPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLnRhZ1RyYW5zZm9ybWF0aW9uQnlOb2RlQ2FjaGVbdG9rZW5QYXRoSW5QYXJzZWRUcmVlXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFnVHJhbnNmb3JtYXRpb25CeU5vZGVDYWNoZVt0b2tlblBhdGhJblBhcnNlZFRyZWVdO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHRhZ1RyYW5zZm9ybWF0aW9uQnlOb2RlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIGNsYXNzTGlzdCA9IG5vZGUuY2xhc3NMaXN0LFxuICAgICAgICAgICAgb3JpTm9kZSA9IG5vZGUsXG4gICAgICAgICAgICB0b2tlblBhdGhJblBhcnNlZFRyZWUgPSAnJyxcbiAgICAgICAgICAgIG1hdGNoZXNCeVBhdGggPSBbXSxcbiAgICAgICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLnRhZ1RyYW5zZm9ybWF0aW9ucyksXG4gICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICB0aywgc3BsaXQ7XG5cbiAgICAgICAgaWYoIW9yaU5vZGUuY2xhc3NMaXN0KSB7IG9yaU5vZGUuY2xhc3NMaXN0ID0gW10gfVxuXG4gICAgICAgIHdoaWxlKG5vZGUpIHtcbiAgICAgICAgICAgIGlmKG5vZGUudGFnTmFtZSkge1xuICAgICAgICAgICAgICAgIHRva2VuUGF0aEluUGFyc2VkVHJlZSA9ICcvJyArIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpICsgdG9rZW5QYXRoSW5QYXJzZWRUcmVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKXtcbiAgICAgICAgICAgICAgICB0b2tlblBhdGhJblBhcnNlZFRyZWUgPSAnLyN0ZXh0JyArIHRva2VuUGF0aEluUGFyc2VkVHJlZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IHRoaXMubG9vY2t1cFRhZ1RyYW5zZm9ybWF0aW9uQ2FjaGVGb3IodG9rZW5QYXRoSW5QYXJzZWRUcmVlLCBjbGFzc0xpc3QpXG5cbiAgICAgICAgaWYocmVzdWx0ID09PSAtMSkge3JldHVybn1cbiAgICAgICAgaWYocmVzdWx0KSB7cmV0dXJuIHJlc3VsdH1cblxuICAgICAgICBmb3IodmFyIGk9MDsgaTxrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0ayA9IGtleXNbaV07XG4gICAgICAgICAgICBzcGxpdCA9IHRrLnNwbGl0KCcuJyk7XG5cbiAgICAgICAgICAgIGlmKHNwbGl0WzBdID09PSB0b2tlblBhdGhJblBhcnNlZFRyZWUpIHtcbiAgICAgICAgICAgICAgICBpZighc3BsaXRbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlc0J5UGF0aC5wdXNoKHRrKVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZihvcmlOb2RlLmNsYXNzTGlzdC5jb250YWlucyhzcGxpdFsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFnVHJhbnNmb3JtYXRpb25zW3RrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZi5jYWNoZVRhZ1RyYW5zZm9ybWF0aW9uRm9yKFxuICAgICAgICAgICAgICAgICAgICB0b2tlblBhdGhJblBhcnNlZFRyZWUsXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXNCeVBhdGhbMF0gPyB0aGlzLnRhZ1RyYW5zZm9ybWF0aW9uc1ttYXRjaGVzQnlQYXRoWzBdXSA6IC0xKTtcbiAgICB9LFxuXG4gICAgaXNOb2RlQWxsb3dlZFRvQmVSb290RWxlbWVudDogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB2YXIgcnVsZSA9IHRoaXMucnVsZXNbdGhpcy5nZXRSdWxlTmFtZUJ5RWxlbWVudChub2RlKV07XG4gICAgICAgIHJldHVybiBydWxlICYmIHJ1bGUuYWxsb3dlZFRvQmVSb290O1xuICAgIH0sXG5cbiAgICBpc05vZGVGb3JiaWRkZW5CeUFsbG93ZWRDaGlsZHJlbkRlZmluaXRpb246IGZ1bmN0aW9uKHJvb3RFbGVtZW50LCBjaGlsZE5vZGVSdWxlTmFtZSwgcGFyZW50RWxlbWVudFJ1bGUpIHtcbiAgICAgICAgcGFyZW50RWxlbWVudFJ1bGUgPSBwYXJlbnRFbGVtZW50UnVsZSB8fCB0aGlzLmdldFJ1bGVCeUVsZW1lbnQocm9vdEVsZW1lbnQpO1xuICAgICAgICBpZighY2hpbGROb2RlUnVsZU5hbWUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYoIXBhcmVudEVsZW1lbnRSdWxlLmFsbG93ZWRDaGlsZHJlbikgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHJldHVybiBwYXJlbnRFbGVtZW50UnVsZS5hbGxvd2VkQ2hpbGRyZW4uaW5kZXhPZihjaGlsZE5vZGVSdWxlTmFtZSkgPT09IC0xXG4gICAgfSxcblxuICAgIGlzTm9kZUZvcmJpZGRlbkJ5Q2FyZGluYWxpdHlEZWZpbml0aW9uOiBmdW5jdGlvbihjYXJkaW5hbGl0aWVzLCBjaGlsZE5vZGVSdWxlTmFtZSwgcGFyZW50RWxlbWVudFJ1bGUpIHtcbiAgICAgICAgdmFyIG1heEFsbG93ZWQ7XG5cbiAgICAgICAgY2FyZGluYWxpdGllc1tjaGlsZE5vZGVSdWxlTmFtZV0gPSBjYXJkaW5hbGl0aWVzW2NoaWxkTm9kZVJ1bGVOYW1lXSB8fCAwO1xuXG4gICAgICAgIG1heEFsbG93ZWQgPSBwYXJlbnRFbGVtZW50UnVsZSAmJlxuICAgICAgICAgICAgICAgICAgICAgcGFyZW50RWxlbWVudFJ1bGUuY2hpbGRyZW5DYXJkaW5hbGl0eSAmJlxuICAgICAgICAgICAgICAgICAgICAgcGFyZW50RWxlbWVudFJ1bGUuY2hpbGRyZW5DYXJkaW5hbGl0eVtjaGlsZE5vZGVSdWxlTmFtZV0gJiZcbiAgICAgICAgICAgICAgICAgICAgIHBhcmVudEVsZW1lbnRSdWxlLmNoaWxkcmVuQ2FyZGluYWxpdHlbY2hpbGROb2RlUnVsZU5hbWVdLm1heDtcblxuICAgICAgICBpZighbWF4QWxsb3dlZCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHJldHVybiBtYXhBbGxvd2VkIDw9IGNhcmRpbmFsaXRpZXNbY2hpbGROb2RlUnVsZU5hbWVdO1xuICAgIH0sXG5cbiAgICBnZXRSb290Tm9kZU9mOiBmdW5jdGlvbihub2RlKSAge1xuICAgICAgICB2YXIgcm9vdCA9IG5vZGU7XG5cbiAgICAgICAgd2hpbGUocm9vdCAmJiByb290LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHJvb3QgPSByb290LnBhcmVudE5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcm9vdDtcbiAgICB9LFxuXG4gICAgY3JlYXRlRE9NRWxlbWVudEZyb21Ub2tlbjogZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0b2tlbi52YWx1ZSk7XG4gICAgICAgIE9iamVjdC5rZXlzKHRva2VuLmF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBpZihrZXkgPT09ICdjbGFzc05hbWVzJykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsIHRva2VuLmF0dHJpYnV0ZXNba2V5XS5qb2luKCcgJykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIHNlbGYuc3RyaXAodG9rZW4uYXR0cmlidXRlc1trZXldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0sXG5cbiAgICBjbG9uZURPTUVsZW1lbnRBbmRDaGFuZ2VUYWdOYW1lOiBmdW5jdGlvbihub2RlLCB0YWdOYW1lKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuXG4gICAgICAgIHJlc3VsdC5hdHRyaWJ1dGVzID0gbm9kZS5hdHRyaWJ1dGVzO1xuXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPG5vZGUuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnNldEF0dHJpYnV0ZShub2RlLmF0dHJpYnV0ZXNbaV0ubmFtZSwgbm9kZS5hdHRyaWJ1dGVzW2ldLnZhbHVlKVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LmlubmVySFRNTCA9IG5vZGUuaW5uZXJIVE1MO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIHN0cmlwOiBmdW5jdGlvbihodG1sKSB7XG4gICAgICAgIGlmKCFodG1sLnJlcGxhY2UpIHsgcmV0dXJuIGh0bWwgfVxuXG4gICAgICAgIHJldHVybiBodG1sLnJlcGxhY2UoLyYjPyhcXHcrKTsvZywgZnVuY3Rpb24obWF0Y2gsIGRlYykge1xuICAgICAgICAgICAgaWYoaXNOYU4oZGVjKSAmJiBuYW1lZEVuY29kaW5nc1tkZWNdKSB7XG4gICAgICAgICAgICAgICAgZGVjID0gbmFtZWRFbmNvZGluZ3NbZGVjXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoZGVjKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHRva2VuaXplSFRNTDogZnVuY3Rpb24qKGh0bWwpIHtcbiAgICAgICAgdmFyIHRva2VuID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0ZU1hY2hpbmUucmVzZXRTdGF0ZU1hY2hpbmUoKTtcbiAgICAgICAgZm9yKGxldCBpPTA7IGk8PWh0bWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRva2VuID0gdGhpcy5zdGF0ZU1hY2hpbmUucHJvY2VzcyhodG1sW2ldIHx8ICdFT0YnKTtcbiAgICAgICAgICAgIGlmKHRva2VuKSB7IHlpZWxkIHRva2VuOyB0b2tlbiA9IG51bGwgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBidWlsZFRyZWVzOiBmdW5jdGlvbiooaHRtbCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICB0b2tlblN0cmVhbSA9IHRoaXMudG9rZW5pemVIVE1MKGh0bWwpLFxuICAgICAgICAgICAgdG9rZW4gPSBudWxsLFxuICAgICAgICAgICAgbmV3Q2hpbGQgPSBudWxsLFxuICAgICAgICAgICAgY3VycmVudE5vZGVJblRyZWUgPSBudWxsLFxuICAgICAgICAgICAgdG1wSGFuZGxlclJlc3VsdCA9IG51bGw7XG5cbiAgICAgICAgdmFyIHRva2VuSGFuZGxlciA9ICB7XG4gICAgICAgICAgICBPUEVOX1RBRzogZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgICAgICAgICAgaWYoWydicicsICdpbWcnLCAnaW5wdXQnXS5pbmRleE9mKHRva2VuLnZhbHVlLnRvTG93ZXJDYXNlKCkpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5IYW5kbGVyWydFTVBUWV9UQUcnXSh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbmV3Q2hpbGQgPSBzZWxmLmNyZWF0ZURPTUVsZW1lbnRGcm9tVG9rZW4odG9rZW4pO1xuXG4gICAgICAgICAgICAgICAgaWYoY3VycmVudE5vZGVJblRyZWUgJiZcbiAgICAgICAgICAgICAgICAgICBzZWxmLmlzVG9rZW5BbGxvd2VkVG9CZVJvb3RFbGVtZW50KHRva2VuKSAmJlxuICAgICAgICAgICAgICAgICAgICFzZWxmLmlzVG9rZW5BbGxvd2VkVG9Db250YWluSXRzZWxmKHRva2VuKSAmJlxuICAgICAgICAgICAgICAgICAgICFzZWxmLnJvb3RFbGVtZW50c1Nob3VsZE5vdEJyZWFrT3V0RnJvbShjdXJyZW50Tm9kZUluVHJlZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gc2VsZi5nZXRSb290Tm9kZU9mKGN1cnJlbnROb2RlSW5UcmVlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGVJblRyZWUgPSBuZXdDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoY3VycmVudE5vZGVJblRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGVJblRyZWUuYXBwZW5kQ2hpbGQobmV3Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZUluVHJlZSA9IG5ld0NoaWxkO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlSW5UcmVlID0gbmV3Q2hpbGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgQ0xPU0VfVEFHOiBmdW5jdGlvbih0b2tlbikge1xuICAgICAgICAgICAgICAgIGlmKCFjdXJyZW50Tm9kZUluVHJlZSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgdmFyIHRtcEN1cnJlbnROb2RlSW5UcmVlO1xuXG4gICAgICAgICAgICAgICAgaWYoY3VycmVudE5vZGVJblRyZWUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZUluVHJlZSA9IGN1cnJlbnROb2RlSW5UcmVlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wQ3VycmVudE5vZGVJblRyZWUgPSBjdXJyZW50Tm9kZUluVHJlZTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGVJblRyZWUgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKHRtcEN1cnJlbnROb2RlSW5UcmVlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPT0gdG9rZW4udmFsdWUgJiYgdG9rZW4udmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bXBDdXJyZW50Tm9kZUluVHJlZSA9IHNlbGYuY2xvbmVET01FbGVtZW50QW5kQ2hhbmdlVGFnTmFtZSh0bXBDdXJyZW50Tm9kZUluVHJlZSwgdG9rZW4udmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRtcEN1cnJlbnROb2RlSW5UcmVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIEVNUFRZX1RBRzogZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgICAgICAgICBuZXdDaGlsZCA9IHNlbGYuY3JlYXRlRE9NRWxlbWVudEZyb21Ub2tlbih0b2tlbik7XG5cbiAgICAgICAgICAgICAgICBpZihjdXJyZW50Tm9kZUluVHJlZSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZUluVHJlZS5hcHBlbmRDaGlsZChuZXdDaGlsZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld0NoaWxkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIFRFWFQ6IGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgbmV3Q2hpbGQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzZWxmLnN0cmlwKHRva2VuLnZhbHVlKSk7XG5cbiAgICAgICAgICAgICAgICBpZighY3VycmVudE5vZGVJblRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYodG9rZW4udmFsdWUudHJpbSgpLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZUluVHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGVJblRyZWUuYXBwZW5kQ2hpbGQobmV3Q2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUodG9rZW4gPSB0b2tlblN0cmVhbS5uZXh0KCkudmFsdWUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdG1wSGFuZGxlclJlc3VsdCA9IHRva2VuSGFuZGxlclt0b2tlbi50eXBlXSh0b2tlbik7XG4gICAgICAgICAgICB9IGNhdGNoKGV4KSB7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0b2tlblN0cmVhbS5uZXh0KCkudmFsdWU7XG4gICAgICAgICAgICAgICAgdG1wSGFuZGxlclJlc3VsdCA9IHRva2VuSGFuZGxlclt0b2tlbi50eXBlXSh0b2tlbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHRtcEhhbmRsZXJSZXN1bHQpIHlpZWxkIHRtcEhhbmRsZXJSZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZihjdXJyZW50Tm9kZUluVHJlZSkge1xuICAgICAgICAgICAgeWllbGQgc2VsZi5nZXRSb290Tm9kZU9mKGN1cnJlbnROb2RlSW5UcmVlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB0cmFuc2Zvcm1UcmVlV2l0aFJlcnVuczogZnVuY3Rpb24ocm9vdEVsZW1lbnQsIHRyYW5zUnVsZSwgY2xhc3NOYW1lLCBtb2RMb2cpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgcmVzID0gdGhpcy50cmFuc2Zvcm1UcmVlKHJvb3RFbGVtZW50LCB0cmFuc1J1bGUsIGNsYXNzTmFtZSwgbW9kTG9nKTtcblxuICAgICAgICBpZihBcnJheS5pc0FycmF5KHJlcykpIHtcbiAgICAgICAgICAgIHJlcyA9IHJlcy5tYXAoZnVuY3Rpb24ocikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnRyYW5zZm9ybVRyZWVXaXRoUmVydW5zKHIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBtb2RMb2cpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJlcyA9IHJlcy5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MuY29uY2F0KHZhbCksIFtdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSxcblxuICAgIC8vIHJldHVybnMgYW4gYXJyYXkgb2YgRE9NIGVsZW1lbnRzIHdoaWNoIHNob3VsZCByZXBsYWNlIHRoZSBwYXNzZWQgZWxlbWVudFxuICAgIHRyYW5zZm9ybVRyZWU6IGZ1bmN0aW9uKHJvb3RFbGVtZW50LCB0cmFuc1J1bGUsIGNsYXNzTmFtZSwgbW9kTG9nKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIHRyYW5zUnVsZVdpdGhDbGFzcyA9IHRoaXMudGFnVHJhbnNmb3JtYXRpb25CeU5vZGUocm9vdEVsZW1lbnQpLFxuICAgICAgICAgICAgdHJhbnNSdWxlQXIsIHRvUnVsZUNvbmRpZGF0ZXMsIG5ld0NvbnRlbnQsXG4gICAgICAgICAgICBub3JtYWxpemVkSW5uZXJUZXh0LCBwcmFlZml4VG9CZVJlcGxhY2VkLCBwcmFlZml4TWF0Y2gsIGRpcmVjdGl2ZVBhcmFtcyxcbiAgICAgICAgICAgIHRvVHJhbnNmb3JtYXRpb24sIHRtcERpcmVjdGl2ZVBhcmFtcztcblxuICAgICAgICBtb2RMb2cgPSBtb2RMb2cgfHwge307XG4gICAgICAgIG1vZExvZy5kZWxldGVkQ2hhcnNCeU1hcmt1cFRyYW5zZm9ybWF0aW9ucyA9IG1vZExvZy5kZWxldGVkQ2hhcnNCeU1hcmt1cFRyYW5zZm9ybWF0aW9ucyB8fCAwO1xuXG4gICAgICAgIGlmKCFBcnJheS5pc0FycmF5KHRyYW5zUnVsZVdpdGhDbGFzcykpIHtcbiAgICAgICAgICAgIHRyYW5zUnVsZUFyID0gdHJhbnNSdWxlV2l0aENsYXNzID8gdHJhbnNSdWxlV2l0aENsYXNzLnNwbGl0KCcuJykgOiBbXTtcbiAgICAgICAgICAgIHRyYW5zUnVsZSA9IHRyYW5zUnVsZSB8fCB0cmFuc1J1bGVBclswXTtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZSB8fCB0cmFuc1J1bGVBclsxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyYW5zUnVsZSA9IHRyYW5zUnVsZSB8fCB0cmFuc1J1bGVXaXRoQ2xhc3M7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHJhbnNSdWxlID09PSAnI2NvbnRlbnQnKSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShyb290RWxlbWVudC5jaGlsZE5vZGVzKVxuICAgICAgICB9IGVsc2UgaWYgKHRyYW5zUnVsZSA9PT0gJyNuby1jb250ZW50Jykge1xuICAgICAgICAgICAgcm9vdEVsZW1lbnQuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgICAgICByZXR1cm4gcm9vdEVsZW1lbnQ7XG4gICAgICAgIH0gZWxzZSBpZiAodHJhbnNSdWxlID09PSAnI3RleHQtY29udGVudCcpIHtcbiAgICAgICAgICAgIHJvb3RFbGVtZW50LmlubmVySFRNTCA9IHJvb3RFbGVtZW50LmlubmVyVGV4dC5yZXBsYWNlKC88L2csICcmbHQ7JykucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3RFbGVtZW50O1xuICAgICAgICB9IGVsc2UgaWYgKHRyYW5zUnVsZSAmJiByb290RWxlbWVudC5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgICAgIC8vdGV4dCBub2RlIGluIHRoZSBsZWZ0IHBhcnQgb2YgdGhlIHJ1bGUgaXMgbm90IHN1cHBvcnRlZFxuICAgICAgICB9IGVsc2UgaWYoQXJyYXkuaXNBcnJheSh0cmFuc1J1bGUpKSB7XG4gICAgICAgICAgICBmb3IobGV0IGk9MDsgaTx0cmFuc1J1bGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkSW5uZXJUZXh0ID0gcm9vdEVsZW1lbnQuaW5uZXJUZXh0LnJlcGxhY2UobmV3IFJlZ0V4cChTdHJpbmcuZnJvbUNoYXJDb2RlKDE2MCksXCJnXCIpLCAnICcpO1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRJbm5lclRleHQgPSBub3JtYWxpemVkSW5uZXJUZXh0LnJlcGxhY2UodGhpcy50ZW1wcm9hcnlQcnVuZVByb3RlY3RlZFdoaXRlc3BhY2UsICcgJyk7XG4gICAgICAgICAgICAgICAgcHJhZWZpeE1hdGNoID0gbm9ybWFsaXplZElubmVyVGV4dC5tYXRjaChuZXcgUmVnRXhwKCdeJyArIHRyYW5zUnVsZVtpXS5wcmFlZml4ICsgJyhcXFxcKCguKj8pXFxcXCkpP1xcXFxzJykpO1xuXG4gICAgICAgICAgICAgICAgaWYocHJhZWZpeE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHByYWVmaXhUb0JlUmVwbGFjZWQgPSBwcmFlZml4TWF0Y2hbMF07XG4gICAgICAgICAgICAgICAgICAgIGlmKHByYWVmaXhNYXRjaFsyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlUGFyYW1zID0gcHJhZWZpeE1hdGNoWzJdLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGUudHJpbSgpIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlUGFyYW1zID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0b1RyYW5zZm9ybWF0aW9uID0gdHJhbnNSdWxlW2ldLnRvLnNwbGl0KC9cXCh8XFwpLylbMF07XG4gICAgICAgICAgICAgICAgICAgIHRtcERpcmVjdGl2ZVBhcmFtcyA9IHRyYW5zUnVsZVtpXS50by5zcGxpdCgvXFwofFxcKS8pWzFdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKHRtcERpcmVjdGl2ZVBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG1wRGlyZWN0aXZlUGFyYW1zID0gdG1wRGlyZWN0aXZlUGFyYW1zLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGUudHJpbSgpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlUGFyYW1zID0gZGlyZWN0aXZlUGFyYW1zLmNvbmNhdCh0bXBEaXJlY3RpdmVQYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdG9SdWxlQ29uZGlkYXRlcyA9IHRoaXMuZ2V0UnVsZU5hbWVzQnlUYWcodG9UcmFuc2Zvcm1hdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKHJ1bGVOYW1lKSB7IHJldHVybiBzZWxmLnJ1bGVzW3J1bGVOYW1lXSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24ocnVsZSkgeyByZXR1cm4gcnVsZS5hbGxvd2VkVG9CZVJvb3QgJiYgcnVsZS5idWlsZEVtcHR5RWxlbWVudCB9KTtcblxuICAgICAgICAgICAgICAgICAgICBuZXdDb250ZW50ID0gcm9vdEVsZW1lbnQuaW5uZXJIVE1MLnJlcGxhY2UoJyZuYnNwOycsICcgJykucmVwbGFjZSh0aGlzLnRlbXByb2FyeVBydW5lUHJvdGVjdGVkV2hpdGVzcGFjZSwgJyAnKS5yZXBsYWNlKHByYWVmaXhUb0JlUmVwbGFjZWQsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgbW9kTG9nLmRlbGV0ZWRDaGFyc0J5TWFya3VwVHJhbnNmb3JtYXRpb25zICs9IHByYWVmaXhUb0JlUmVwbGFjZWQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBtb2RMb2cuY2hhbmdlU2VjdGlvblR5cGUgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKHRvUnVsZUNvbmRpZGF0ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb290RWxlbWVudCA9IHRvUnVsZUNvbmRpZGF0ZXNbMF0uYnVpbGRFbXB0eUVsZW1lbnQobmV3Q29udGVudCwgZGlyZWN0aXZlUGFyYW1zLCB0b1J1bGVDb25kaWRhdGVzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RFbGVtZW50ID0gdGhpcy5jbG9uZURPTUVsZW1lbnRBbmRDaGFuZ2VUYWdOYW1lKHJvb3RFbGVtZW50LCB0b1RyYW5zZm9ybWF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RFbGVtZW50LmlubmVySFRNTCA9IG5ld0NvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZih0cmFuc1J1bGUpIHtcbiAgICAgICAgICAgIHJvb3RFbGVtZW50ID0gdGhpcy5jbG9uZURPTUVsZW1lbnRBbmRDaGFuZ2VUYWdOYW1lKHJvb3RFbGVtZW50LCB0cmFuc1J1bGUpO1xuICAgICAgICAgICAgaWYoY2xhc3NOYW1lKSByb290RWxlbWVudC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHJvb3RFbGVtZW50LmNoaWxkTm9kZXMpIHtcbiAgICAgICAgICAgIGZvcihsZXQgaT0wOyBpPHJvb3RFbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAgICAgICAgIHRyYW5zUnVsZVdpdGhDbGFzcyA9IHRoaXMudGFnVHJhbnNmb3JtYXRpb25CeU5vZGUocm9vdEVsZW1lbnQuY2hpbGROb2Rlc1tpXSk7XG4gICAgICAgICAgICAgICAgdHJhbnNSdWxlQXIgPSB0cmFuc1J1bGVXaXRoQ2xhc3MgPyB0cmFuc1J1bGVXaXRoQ2xhc3Muc3BsaXQoJy4nKSA6IFtdO1xuICAgICAgICAgICAgICAgIHRyYW5zUnVsZSA9IHRyYW5zUnVsZUFyWzBdO1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9IHRyYW5zUnVsZUFyWzFdO1xuXG4gICAgICAgICAgICAgICAgaWYodHJhbnNSdWxlID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlcyA9IFtyb290RWxlbWVudCwgcm9vdEVsZW1lbnQucmVtb3ZlQ2hpbGQocm9vdEVsZW1lbnQuY2hpbGROb2Rlc1tpXSldXG5cbiAgICAgICAgICAgICAgICAgICAgaWYocm9vdEVsZW1lbnQuY2hpbGROb2Rlc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChyb290RWxlbWVudC50YWdOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKHJvb3RFbGVtZW50LmNoaWxkTm9kZXNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdFbC5hcHBlbmRDaGlsZChyb290RWxlbWVudC5yZW1vdmVDaGlsZChyb290RWxlbWVudC5jaGlsZE5vZGVzW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2gobmV3RWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYocm9vdEVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYodHJhbnNSdWxlICYmIHRyYW5zUnVsZVswXSA9PT0gJz0nKSAge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzID0gW3Jvb3RFbGVtZW50LCByb290RWxlbWVudC5yZW1vdmVDaGlsZChyb290RWxlbWVudC5jaGlsZE5vZGVzW2ldKV07XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdFbGVtZW50VGFnTmFtZSA9IHRyYW5zUnVsZS5zdWJzdHJpbmcoMSwgdHJhbnNSdWxlLmxlbmd0aCk7XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuZXdFbGVtZW50VGFnTmFtZSA9PT0gJycgPyByb290RWxlbWVudC50YWdOYW1lIDogbmV3RWxlbWVudFRhZ05hbWUpO1xuICAgICAgICAgICAgICAgICAgICB1dGlscy5jb3B5Tm9kZUF0dHJpYnV0ZXMocm9vdEVsZW1lbnQsIG5ld0VsLCBbJ2NsYXNzJ10pO1xuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKHJvb3RFbGVtZW50LmNoaWxkTm9kZXNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0VsLmFwcGVuZENoaWxkKHJvb3RFbGVtZW50LnJlbW92ZUNoaWxkKHJvb3RFbGVtZW50LmNoaWxkTm9kZXNbaV0pKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2gobmV3RWwpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXMgPSB0aGlzLnRyYW5zZm9ybVRyZWUocm9vdEVsZW1lbnQuY2hpbGROb2Rlc1tpXSwgdHJhbnNSdWxlLCBjbGFzc05hbWUsIG1vZExvZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmKHJlcyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb290RWxlbWVudC5jaGlsZE5vZGVzW2ldLnJlcGxhY2VXaXRoKC4uLnJlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RFbGVtZW50LmNoaWxkTm9kZXNbaV0ucmVwbGFjZVdpdGgocmVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByb290RWxlbWVudDtcbiAgICB9LFxuXG4gICAgY2xlYW51cENsYXNzQXR0cmlidGU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIHJ1bGUgPSB0aGlzLmdldFJ1bGVCeUVsZW1lbnQobm9kZSksXG4gICAgICAgICAgICBjbGFzc05hbWVzVG9SZW1vdmUgPSBbXTtcblxuICAgICAgICBpZihydWxlICYmIHJ1bGUuYWxsb3dlZENsYXNzTmFtZXMpIHtcbiAgICAgICAgICAgIGZvcihsZXQgaT0wOyBpPG5vZGUuY2xhc3NMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYocnVsZS5hbGxvd2VkQ2xhc3NOYW1lcy5pbmRleE9mKG5vZGUuY2xhc3NMaXN0W2ldKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lc1RvUmVtb3ZlLnB1c2gobm9kZS5jbGFzc0xpc3RbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsYXNzTmFtZXNUb1JlbW92ZS5mb3JFYWNoKGZ1bmN0aW9uKGNuKSB7bm9kZS5jbGFzc0xpc3QucmVtb3ZlKGNuKTt9KVxuICAgICAgICB9IGVsc2UgaWYgKHJ1bGUgJiYgbm9kZS5hdHRyaWJ1dGVzICYmIG5vZGUuYXR0cmlidXRlcy5jbGFzcykge1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY2xlYW51cE5vZGVBdHRyaWJ1dGVzOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIC8vIGZpcnN0IGNoZWNrIHdoZXRoZXIgdGhlIGNsZWFuaW5nIHByb2Nlc3Mgd2lsbCByZW1vdmUgdGhlIGNsYXNzIGF0dHJpYnV0ZVxuICAgICAgICB2YXIgcnVsZSA9IHRoaXMuZ2V0UnVsZUJ5RWxlbWVudChub2RlKSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNUb1JlbW92ZSA9IFtdO1xuXG4gICAgICAgIGlmKCFydWxlKSByZXR1cm47XG5cbiAgICAgICAgaWYobm9kZS5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBmb3IobGV0IGk9MDsgaTxub2RlLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZighcnVsZS5hbGxvd2VkQXR0cmlidXRlcyB8fFxuICAgICAgICAgICAgICAgICAgIHJ1bGUuYWxsb3dlZEF0dHJpYnV0ZXMuaW5kZXhPZihub2RlLmF0dHJpYnV0ZXNbaV0ubmFtZSkgPT09IC0xIHx8XG4gICAgICAgICAgICAgICAgICBub2RlLmF0dHJpYnV0ZXNbaV0udmFsdWUgPT09ICcnXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc1RvUmVtb3ZlLnB1c2gobm9kZS5hdHRyaWJ1dGVzW2ldLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGF0dHJpYnV0ZXNUb1JlbW92ZS5mb3JFYWNoKGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgYnVpbGRFbXB0eUVsZW1lbnRCeVJ1bGVOYW1lOiBmdW5jdGlvbihydWxlTmFtZSkge1xuICAgICAgICB2YXIgZWwsIHJ1bGUgPSB0aGlzLnJ1bGVzW3J1bGVOYW1lXTtcblxuICAgICAgICBpZihydWxlLmJ1aWxkRW1wdHlFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gcnVsZS5idWlsZEVtcHR5RWxlbWVudChudWxsLCBudWxsLCBydWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChydWxlLnRhZ05hbWUpO1xuICAgICAgICBpZihydWxlLmNsYXNzTmFtZSkge1xuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChydWxlLmNsYXNzTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH0sXG5cbiAgICBjbGVhbnVwVHJlZTogZnVuY3Rpb24ocm9vdEVsZW1lbnQsIG1vZGlmaWNhdGlvbkxvZ0VudHJ5LCBwcmV2aW91c0RPTVRyZWUsIG5leHRET01UcmVlKSB7XG4gICAgICAgIHRoaXMuY2xlYW51cENsYXNzQXR0cmlidGUocm9vdEVsZW1lbnQpO1xuICAgICAgICB0aGlzLmNsZWFudXBOb2RlQXR0cmlidXRlcyhyb290RWxlbWVudCk7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgcnVsZU5hbWUgPSB0aGlzLmdldFJ1bGVOYW1lQnlFbGVtZW50KHJvb3RFbGVtZW50KSxcbiAgICAgICAgICAgIHJ1bGUgPSB0aGlzLnJ1bGVzW3J1bGVOYW1lXSxcbiAgICAgICAgICAgIGNoaWxkTm9kZVJ1bGVOYW1lLFxuICAgICAgICAgICAgY2FyZGluYWxpdHlNYXAgPSB7fSxcbiAgICAgICAgICAgIHJlc3VsdCA9IHt9LFxuICAgICAgICAgICAgZGVsZXRlZENoYXJzQnlNYXJrdXBUcmFuc2Zvcm1hdGlvbnNDYWx1bGF0aW9uSGVscGVyLFxuICAgICAgICAgICAgY1RSZXN1bHQ7XG5cbiAgICAgICAgaWYoIXJ1bGVOYW1lIHx8IChydWxlICYmIHJ1bGUuZGVsZXRlSWZFbXB0eSAmJiByb290RWxlbWVudC5pbm5lclRleHQubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgcmVtb3ZlVGhpc05vZGU6IHRydWUgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHJ1bGUgJiYgcnVsZS5idWlsZEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIHJ1bGUuYnVpbGRBdHRyaWJ1dGVzLmZvckVhY2goZnVuY3Rpb24oYmEpIHtcbiAgICAgICAgICAgICAgICBpZighcm9vdEVsZW1lbnQuaGFzQXR0cmlidXRlKGJhLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RFbGVtZW50LnNldEF0dHJpYnV0ZShiYS5uYW1lLCBiYS5idWlsZCgpKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBmb3IobGV0IGk9MDsgaTxyb290RWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjaGlsZE5vZGVSdWxlTmFtZSA9IHRoaXMuZ2V0UnVsZU5hbWVCeUVsZW1lbnQocm9vdEVsZW1lbnQuY2hpbGROb2Rlc1tpXSk7XG5cbiAgICAgICAgICAgIGlmKHRoaXMuaXNOb2RlRm9yYmlkZGVuQnlBbGxvd2VkQ2hpbGRyZW5EZWZpbml0aW9uKHJvb3RFbGVtZW50LCBjaGlsZE5vZGVSdWxlTmFtZSwgcnVsZSkgfHxcbiAgICAgICAgICAgICAgIHRoaXMuaXNOb2RlRm9yYmlkZGVuQnlDYXJkaW5hbGl0eURlZmluaXRpb24oY2FyZGluYWxpdHlNYXAsIGNoaWxkTm9kZVJ1bGVOYW1lLCBydWxlKSkge1xuICAgICAgICAgICAgICAgIHJvb3RFbGVtZW50LnJlbW92ZUNoaWxkKHJvb3RFbGVtZW50LmNoaWxkTm9kZXNbaS0tXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhcmRpbmFsaXR5TWFwW2NoaWxkTm9kZVJ1bGVOYW1lXSsrO1xuXG4gICAgICAgICAgICAgICAgaWYocnVsZS5wcnVuZVNwYWNlcyAmJiByb290RWxlbWVudC5jaGlsZE5vZGVzW2ldLm5vZGVUeXBlID09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZWRDaGFyc0J5TWFya3VwVHJhbnNmb3JtYXRpb25zQ2FsdWxhdGlvbkhlbHBlciA9IHJvb3RFbGVtZW50LmNoaWxkTm9kZXNbaV0ubm9kZVZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgcm9vdEVsZW1lbnQuY2hpbGROb2Rlc1tpXS5ub2RlVmFsdWUgPSByb290RWxlbWVudC5jaGlsZE5vZGVzW2ldLm5vZGVWYWx1ZS5yZXBsYWNlKC8oXFxzfFxcdTAwQTApKy9nLCAnICcpLnJlcGxhY2UoL1xccyQvLCAnXFx1MDBBMCcpO1xuICAgICAgICAgICAgICAgICAgICBtb2RpZmljYXRpb25Mb2dFbnRyeS5kZWxldGVkQ2hhcnNCeU1hcmt1cFRyYW5zZm9ybWF0aW9ucyArPSAoZGVsZXRlZENoYXJzQnlNYXJrdXBUcmFuc2Zvcm1hdGlvbnNDYWx1bGF0aW9uSGVscGVyIC0gcm9vdEVsZW1lbnQuY2hpbGROb2Rlc1tpXS5ub2RlVmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZihyb290RWxlbWVudC5jaGlsZE5vZGVzW2ldLm5vZGVUeXBlID09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RFbGVtZW50LmNoaWxkTm9kZXNbaV0ubm9kZVZhbHVlID0gcm9vdEVsZW1lbnQuY2hpbGROb2Rlc1tpXS5ub2RlVmFsdWUucmVwbGFjZSh0aGlzLnRlbXByb2FyeVBydW5lUHJvdGVjdGVkV2hpdGVzcGFjZSwgJ1xcdTAwQTAnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjVFJlc3VsdCA9IHRoaXMuY2xlYW51cFRyZWUocm9vdEVsZW1lbnQuY2hpbGROb2Rlc1tpXSwgbW9kaWZpY2F0aW9uTG9nRW50cnkpO1xuXG4gICAgICAgICAgICAgICAgaWYoY1RSZXN1bHQucmVtb3ZlVGhpc05vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdEVsZW1lbnQucmVtb3ZlQ2hpbGQocm9vdEVsZW1lbnQuY2hpbGROb2Rlc1tpLS1dKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZihjVFJlc3VsdC5pbnNlcnROb2RlQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdEVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNUUmVzdWx0Lmluc2VydE5vZGVBZnRlciwgcm9vdEVsZW1lbnQuY2hpbGROb2Rlc1tpXS5uZXh0U2libGluZyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYoY1RSZXN1bHQuaW5zZXJ0Tm9kZUJlZm9yZSkge1xuICAgICAgICAgICAgICAgICAgICByb290RWxlbWVudC5pbnNlcnRCZWZvcmUoY1RSZXN1bHQuaW5zZXJ0Tm9kZUJlZm9yZSwgcm9vdEVsZW1lbnQuY2hpbGROb2Rlc1tpKytdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZihydWxlICYmIHJ1bGUuYWxsb3dlZFN1Y2Nlc3NvcnMgJiYgcnVsZS5hbGxvd2VkU3VjY2Vzc29ycy5sZW5ndGggIT09IDAgJiYgIXRoaXMuZG9lc0VsZW1lbnRNYXRjaE9uZVJ1bGUobmV4dERPTVRyZWUgfHwgcm9vdEVsZW1lbnQubmV4dFNpYmxpbmcsIHJ1bGUuYWxsb3dlZFN1Y2Nlc3NvcnMpKSB7XG4gICAgICAgICAgICByZXN1bHQuaW5zZXJ0Tm9kZUFmdGVyID0gdGhpcy5idWlsZEVtcHR5RWxlbWVudEJ5UnVsZU5hbWUocnVsZS5hbGxvd2VkU3VjY2Vzc29yc1swXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihydWxlICYmIHJ1bGUuYWxsb3dlZFByZWRlY2Vzc29ycyAmJiBydWxlLmFsbG93ZWRQcmVkZWNlc3NvcnMubGVuZ3RoICE9PSAwICYmICF0aGlzLmRvZXNFbGVtZW50TWF0Y2hPbmVSdWxlKHByZXZpb3VzRE9NVHJlZSB8fCByb290RWxlbWVudC5wcmV2aW91c1NpYmxpbmcsIHJ1bGUuYWxsb3dlZFByZWRlY2Vzc29ycykpIHtcbiAgICAgICAgICAgIHJlc3VsdC5pbnNlcnROb2RlQmVmb3JlID0gdGhpcy5idWlsZEVtcHR5RWxlbWVudEJ5UnVsZU5hbWUocnVsZS5hbGxvd2VkUHJlZGVjZXNzb3JzWzBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIEhUTUxUb1RyYW5zZm9ybWVkVHJlZVN0cmVhbTogZnVuY3Rpb24qKGh0bWwsIG1vZGlmaWNhdGlvbkxvZ0VudHJ5KSB7XG4gICAgICAgIHZhciBET01UcmVlU3RyZWFtID0gdGhpcy5idWlsZFRyZWVzKGh0bWwpLFxuICAgICAgICAgICAgRE9NVHJlZSA9IERPTVRyZWVTdHJlYW0ubmV4dCgpLnZhbHVlO1xuXG4gICAgICAgIHdoaWxlKERPTVRyZWUpIHtcbiAgICAgICAgICAgIERPTVRyZWUgPSB0aGlzLnRyYW5zZm9ybVRyZWVXaXRoUmVydW5zKERPTVRyZWUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBtb2RpZmljYXRpb25Mb2dFbnRyeSk7XG5cbiAgICAgICAgICAgIGlmKEFycmF5LmlzQXJyYXkoRE9NVHJlZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IobGV0IGk9MDsgaTxET01UcmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIERPTVRyZWVbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBET01UcmVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBET01UcmVlID0gRE9NVHJlZVN0cmVhbS5uZXh0KCkudmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY2xlYW51cEhUTUw6IGZ1bmN0aW9uKihodG1sLCBtb2RpZmljYXRpb25Mb2dFbnRyeSkgIHtcbiAgICAgICAgaWYoIWh0bWwgfHwgaHRtbCA9PT0gJycpIHsgaHRtbCA9ICc8cD48L3A+JyB9XG5cbiAgICAgICAgbW9kaWZpY2F0aW9uTG9nRW50cnkgPSBtb2RpZmljYXRpb25Mb2dFbnRyeSB8fCB7fVxuICAgICAgICBtb2RpZmljYXRpb25Mb2dFbnRyeS5kZWxldGVkQ2hhcnNCeU1hcmt1cFRyYW5zZm9ybWF0aW9ucyA9IDA7XG5cbiAgICAgICAgdmFyIERPTVRyZWVTdHJlYW0gPSB0aGlzLkhUTUxUb1RyYW5zZm9ybWVkVHJlZVN0cmVhbShodG1sLCBtb2RpZmljYXRpb25Mb2dFbnRyeSksXG4gICAgICAgICAgICBjVFJlc3VsdCxcbiAgICAgICAgICAgIHByZXZpb3VzRE9NVHJlZSxcbiAgICAgICAgICAgIERPTVRyZWUgPSBET01UcmVlU3RyZWFtLm5leHQoKS52YWx1ZSxcbiAgICAgICAgICAgIG5leHRET01UcmVlID0gRE9NVHJlZVN0cmVhbS5uZXh0KCkudmFsdWU7XG5cbiAgICAgICAgd2hpbGUoRE9NVHJlZSkge1xuICAgICAgICAgICAgaWYodGhpcy5pc05vZGVBbGxvd2VkVG9CZVJvb3RFbGVtZW50KERPTVRyZWUpKSB7XG4gICAgICAgICAgICAgICAgY1RSZXN1bHQgPSB0aGlzLmNsZWFudXBUcmVlKERPTVRyZWUsIG1vZGlmaWNhdGlvbkxvZ0VudHJ5LCBwcmV2aW91c0RPTVRyZWUsIG5leHRET01UcmVlKTtcbiAgICAgICAgICAgICAgICBpZihjVFJlc3VsdC5pbnNlcnROb2RlQmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMubWVtb3JpemVkTm9kZShjVFJlc3VsdC5pbnNlcnROb2RlQmVmb3JlLCBtb2RpZmljYXRpb25Mb2dFbnRyeS5tb2RMb2dGbGFncyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYoIWNUUmVzdWx0LnJlbW92ZVRoaXNOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMubWVtb3JpemVkTm9kZShET01UcmVlLCBtb2RpZmljYXRpb25Mb2dFbnRyeS5tb2RMb2dGbGFncyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYoY1RSZXN1bHQuaW5zZXJ0Tm9kZUFmdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMubWVtb3JpemVkTm9kZShjVFJlc3VsdC5pbnNlcnROb2RlQWZ0ZXIsIG1vZGlmaWNhdGlvbkxvZ0VudHJ5Lm1vZExvZ0ZsYWdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZXZpb3VzRE9NVHJlZSA9IERPTVRyZWU7XG4gICAgICAgICAgICBET01UcmVlID0gbmV4dERPTVRyZWU7XG4gICAgICAgICAgICBuZXh0RE9NVHJlZSA9IERPTVRyZWVTdHJlYW0ubmV4dCgpLnZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1lbW9yaXplZE5vZGU6IGZ1bmN0aW9uKG5vZGUsIG1vZExvZ0ZsYWdzKSB7XG5cbiAgICAgICAgbW9kTG9nRmxhZ3MgPSBtb2RMb2dGbGFncyB8fCB7fTtcbiAgICAgICAgbm9kZS5vcmlnaW5hbEhUTUwgPSBub2RlLm91dGVySFRNTDtcblxuICAgICAgICBPYmplY3Qua2V5cyhtb2RMb2dGbGFncykuZm9yRWFjaChmdW5jdGlvbihmbGFnKSB7XG4gICAgICAgICAgICBub2RlWydvcmlnaW5hbEhUTUxDb250YWlucycgKyBmbGFnXSA9IG1vZExvZ0ZsYWdzW2ZsYWddLnNvbWUoZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5tYXRjaGVzKHNlbGVjdG9yKSB8fCBub2RlLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcblxuICAgIGNsZWFudXBIVE1MQW5kQXR0YWNoRXZlbnRIYW5kbGVyczogZnVuY3Rpb24qKGh0bWwsIG1vZGlmaWNhdGlvbkxvZ0VudHJ5KSB7XG4gICAgICAgICAgdmFyIERPTVRyZWVTdHJlYW0gPSB0aGlzLmNsZWFudXBIVE1MKGh0bWwsIG1vZGlmaWNhdGlvbkxvZ0VudHJ5KSxcbiAgICAgICAgICAgIERPTVRyZWUgPSBET01UcmVlU3RyZWFtLm5leHQoKS52YWx1ZSxcbiAgICAgICAgICAgIGR1bW15RWxlbWVudCwgcnVsZTtcblxuICAgICAgICB3aGlsZShET01UcmVlKSB7XG4gICAgICAgICAgICBydWxlID0gdGhpcy5nZXRSdWxlQnlFbGVtZW50KERPTVRyZWUpO1xuICAgICAgICAgICAgaWYocnVsZS5idWlsZEVtcHR5RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGR1bW15RWxlbWVudCA9IHJ1bGUuYnVpbGRFbXB0eUVsZW1lbnQobnVsbCwgbnVsbCwgcnVsZSk7XG4gICAgICAgICAgICAgICAgdXRpbHMuY29weUV2ZW50TGlzdGVuZXJzUmVjdXJzaXZlbHkoZHVtbXlFbGVtZW50LCBET01UcmVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeWllbGQgRE9NVHJlZTtcbiAgICAgICAgICAgIERPTVRyZWUgPSBET01UcmVlU3RyZWFtLm5leHQoKS52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBIVE1MUmF6b3I7XG4iLCJ2YXIgaT0wLFxuICAgIFdBSVRfRk9SX05FWFRfVE9LRU5fVE9fU1RBUlQgPSBpKyssXG4gICAgUkVBRElOR19UQUdfTkFNRSA9IGkrKyxcbiAgICBERVRFUk1JTklOR19UQUdfVFlQRSA9IGkrKyxcbiAgICBSRUFESU5HX0FUVFJJQlVURV9OQU1FID0gaSsrLFxuICAgIEVYUEVDVElOR19RVU9URV9UT19TVEFSVF9BVFRSSUJVVEVfVkFMVUUgPSBpKyssXG4gICAgUkVBRElOR19BVFRSSUJVVEVfVkFMVUUgPSBpKyssXG4gICAgV0FJVF9GT1JfTkVYVF9BVFRSSUJVVEVfVE9fU1RBUlQgPSBpKyssXG4gICAgUkVBRElOR19URVhUID0gaSsrLFxuICAgIFdBSVRJTkdfRk9SX0VNUFRZX1RBR19UT19CRV9DTE9TRUQgPSBpKys7XG5cbmZ1bmN0aW9uIGFkZENoYXJSYW5nZVRvVHJhbnNpdGlvbih0cmFuc2l0aW9uLCBDaGFyUmFuZ2VTdGFydCwgQ2hhclJhbmdlRW5kLCBUcmFuc2l0aW9uQWN0aW9uKSB7XG4gICAgZm9yKGxldCBhc2NpQ29kZT1DaGFyUmFuZ2VTdGFydC5jaGFyQ29kZUF0KDApOyBhc2NpQ29kZTw9Q2hhclJhbmdlRW5kLmNoYXJDb2RlQXQoMCk7IGFzY2lDb2RlKyspIHtcbiAgICAgICAgdHJhbnNpdGlvbltTdHJpbmcuZnJvbUNoYXJDb2RlKGFzY2lDb2RlKV0gPSBUcmFuc2l0aW9uQWN0aW9uO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2xvYkNoYXJSYW5nZXNJblRyYW5zdGlvbih0cmFuc2l0aW9uKSB7XG4gICAgT2JqZWN0LmtleXModHJhbnNpdGlvbikuZmlsdGVyKGZ1bmN0aW9uKHRrKSB7XG4gICAgICAgIHJldHVybiB0ay5tYXRjaCgvXlxcWygufFxccykqXFxdJC8pO1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24odGspIHtcbiAgICAgICAgdmFyIHRmID0gdHJhbnNpdGlvblt0a107XG5cbiAgICAgICAgaWYodGsuaW5kZXhPZignQS1aJykgIT09IC0xKSB7YWRkQ2hhclJhbmdlVG9UcmFuc2l0aW9uKHRyYW5zaXRpb24sICdBJywgJ1onLCB0Zik7fVxuICAgICAgICBpZih0ay5pbmRleE9mKCdhLXonKSAhPT0gLTEpIHthZGRDaGFyUmFuZ2VUb1RyYW5zaXRpb24odHJhbnNpdGlvbiwgJ2EnLCAneicsIHRmKTt9XG4gICAgICAgIGlmKHRrLmluZGV4T2YoJzAtOScpICE9PSAtMSkge2FkZENoYXJSYW5nZVRvVHJhbnNpdGlvbih0cmFuc2l0aW9uLCAnMCcsICc5JywgdGYpO31cblxuICAgICAgICBpZih0ay5pbmRleE9mKCcgXFxuJykgIT09IC0xKSB7XG4gICAgICAgICAgIHRyYW5zaXRpb25bJyAnXSA9IHRmO1xuICAgICAgICAgICB0cmFuc2l0aW9uWydcXG4nXSA9IHRmO1xuICAgICAgICB9XG5cbiAgICAgICAgLy90ay5yZXBsYWNlKC9cXFt8XFxdfEFcXC1afGFcXC16fDBcXC05L2csICcnKSAtPiBcIltBLVphLXotJ11cIiBpcyByZXBsYWNlZCB0byBcIi0nXCIsIGFuZCB0aGVuIFwiLVwiIGFuZCBcIidcIiBhcmUgYWRkZWQgdG8gdGhlIHRyYW5zaXRpb25cbiAgICAgICAgdGsucmVwbGFjZSgvXFxbfFxcXXxBXFwtWnxhXFwtenwwXFwtOS9nLCAnJykuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgdHJhbnNpdGlvbltjXSA9IHRmO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuXG5mdW5jdGlvbiBTdGF0ZU1hY2hpbmUoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy50cmFuc2lzdGlvbnMgPSBbXTtcbiAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgIHRoaXMuc3RhdGUgPSBXQUlUX0ZPUl9ORVhUX1RPS0VOX1RPX1NUQVJUO1xuXG4gICAgdGhpcy5yZXNldFN0YXRlKCk7XG5cbiAgICB0aGlzLnRyYW5zaXN0aW9uc1tXQUlUX0ZPUl9ORVhUX1RPS0VOX1RPX1NUQVJUXSA9IHtcbiAgICAgICAgJzwnOiAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKSAgICAgeyBzZWxmLnN0YXRlID0gREVURVJNSU5JTkdfVEFHX1RZUEU7IH0sXG4gICAgICAgICdlbHNlJzogICAgICAgICAgICAgIGZ1bmN0aW9uKGNoYXIpIHsgc2VsZi5zdGF0ZSA9IFJFQURJTkdfVEVYVDsgc2VsZi5jdXJyZW50VG9rZW4udHlwZSA9ICdURVhUJzsgc2VsZi5jdXJyZW50VG9rZW4udmFsdWUgKz0gY2hhcjsgfVxuICAgIH07XG5cbiAgICB0aGlzLnRyYW5zaXN0aW9uc1tERVRFUk1JTklOR19UQUdfVFlQRV0gPSB7XG4gICAgICAgICdbYS16QS1aXSc6ICAgICAgICAgIGZ1bmN0aW9uKGNoYXIpICB7IHNlbGYuc3RhdGUgPSBSRUFESU5HX1RBR19OQU1FOyBzZWxmLmN1cnJlbnRUb2tlbi50eXBlID0gJ09QRU5fVEFHJzsgc2VsZi5jdXJyZW50VG9rZW4udmFsdWUgKz0gY2hhcjsgfSxcbiAgICAgICAgJy8nOiAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKSAgICAgIHsgc2VsZi5zdGF0ZSA9IFJFQURJTkdfVEFHX05BTUU7IHNlbGYuY3VycmVudFRva2VuLnR5cGUgPSAnQ0xPU0VfVEFHJzsgfSxcbiAgICB9O1xuXG4gICAgdGhpcy50cmFuc2lzdGlvbnNbUkVBRElOR19UQUdfTkFNRV0gPSB7XG4gICAgICAgICdbYS16QS1aMC05XSc6ICAgICAgIGZ1bmN0aW9uKGNoYXIpIHsgc2VsZi5jdXJyZW50VG9rZW4udmFsdWUgKz0gY2hhciB9LFxuICAgICAgICAnWyBcXG5dJzogICAgICAgICAgICAgZnVuY3Rpb24oKSAgICAgeyBzZWxmLmN1cnJlbnRUb2tlbi50eXBlID09PSAnQ0xPU0VfVEFHJyA/IHNlbGYudHJhbnNpc3Rpb25zW1JFQURJTkdfVEFHX05BTUVdWyc+J10oKSA6IHNlbGYuc3RhdGUgPSBXQUlUX0ZPUl9ORVhUX0FUVFJJQlVURV9UT19TVEFSVCB9LFxuICAgICAgICAnPic6ICAgICAgICAgICAgICAgICBmdW5jdGlvbigpICAgICB7IHNlbGYuc3RhdGUgPSBXQUlUX0ZPUl9ORVhUX1RPS0VOX1RPX1NUQVJULCBzZWxmLmZpbmlzaFRva2VuKCkgfSxcbiAgICAgICAgJy8nOiAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKSAgICAgeyBzZWxmLnN0YXRlID0gV0FJVElOR19GT1JfRU1QVFlfVEFHX1RPX0JFX0NMT1NFRCwgc2VsZi5jdXJyZW50VG9rZW4udHlwZSA9ICdFTVBUWV9UQUcnOyB9XG4gICAgfTtcblxuICAgIHRoaXMudHJhbnNpc3Rpb25zW1JFQURJTkdfQVRUUklCVVRFX05BTUVdID0ge1xuICAgICAgICAnW2EtekEtWi1dJzogICAgICAgICBmdW5jdGlvbihjaGFyKSB7IHNlbGYuY3VycmVudEF0dHJpYnV0ZS5uYW1lICs9IGNoYXIgfSxcbiAgICAgICAgJyAnOiAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKSAgICAgeyBzZWxmLnN0YXRlID0gV0FJVF9GT1JfTkVYVF9BVFRSSUJVVEVfVE9fU1RBUlQ7IHNlbGYuZmluaXNoQXR0cmlidXRlKCkgfSxcbiAgICAgICAgJ1xcbic6ICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkgICAgIHt9LFxuICAgICAgICAnPSc6ICAgICAgICAgICAgICAgICBmdW5jdGlvbigpICAgICB7IHNlbGYuc3RhdGUgPSBFWFBFQ1RJTkdfUVVPVEVfVE9fU1RBUlRfQVRUUklCVVRFX1ZBTFVFIH0sXG4gICAgICAgICc+JzogICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkgICAgIHsgc2VsZi5zdGF0ZSA9IFdBSVRfRk9SX05FWFRfVE9LRU5fVE9fU1RBUlQ7IHNlbGYuZmluaXNoQXR0cmlidXRlKCk7IHNlbGYuZmluaXNoVG9rZW4oKSAgfSxcbiAgICAgICAgJzwnOiAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKSAgICAgeyBzZWxmLnN0YXRlID0gREVURVJNSU5JTkdfVEFHX1RZUEU7IHNlbGYuaGFuZGxlQnJva2VuT3BlblRhZyhSRUFESU5HX0FUVFJJQlVURV9OQU1FKTsgfSxcbiAgICAgICAgJy8nOiAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKSAgICAgeyBzZWxmLnN0YXRlID0gV0FJVElOR19GT1JfRU1QVFlfVEFHX1RPX0JFX0NMT1NFRCwgc2VsZi5jdXJyZW50VG9rZW4udHlwZSA9ICdFTVBUWV9UQUcnOyBzZWxmLmZpbmlzaEF0dHJpYnV0ZSgpIH1cbiAgICB9O1xuXG4gICAgdGhpcy50cmFuc2lzdGlvbnNbRVhQRUNUSU5HX1FVT1RFX1RPX1NUQVJUX0FUVFJJQlVURV9WQUxVRV0gPSB7XG4gICAgICAgICdbXCJcXCddJzogICAgICAgICAgICAgZnVuY3Rpb24oKSAgICAgeyBzZWxmLnN0YXRlID0gUkVBRElOR19BVFRSSUJVVEVfVkFMVUUgfVxuICAgIH07XG5cbiAgICB0aGlzLnRyYW5zaXN0aW9uc1tSRUFESU5HX0FUVFJJQlVURV9WQUxVRV0gPSB7XG4gICAgICAgICdbXCJcXCddJzogICAgICAgICAgICAgZnVuY3Rpb24oKSAgICAgeyBzZWxmLnN0YXRlID0gV0FJVF9GT1JfTkVYVF9BVFRSSUJVVEVfVE9fU1RBUlQ7IHNlbGYuZmluaXNoQXR0cmlidXRlKCkgfSxcbiAgICAgICAgJzwnOiAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKSAgICAgeyBzZWxmLnN0YXRlID0gREVURVJNSU5JTkdfVEFHX1RZUEU7IHNlbGYuaGFuZGxlQnJva2VuT3BlblRhZyhSRUFESU5HX0FUVFJJQlVURV9WQUxVRSk7IH0sXG4gICAgICAgICdlbHNlJzogICAgICAgICAgICAgIGZ1bmN0aW9uKGNoYXIpIHsgc2VsZi5jdXJyZW50QXR0cmlidXRlLnZhbHVlICs9IGNoYXIgfVxuICAgIH07XG5cbiAgICB0aGlzLnRyYW5zaXN0aW9uc1tXQUlUX0ZPUl9ORVhUX0FUVFJJQlVURV9UT19TVEFSVF0gPSB7XG4gICAgICAgICdbIFxcbl0nOiAgICAgICAgICAgICBmdW5jdGlvbigpICAgICB7IH0sXG4gICAgICAgICdbYS16QS1aXSc6ICAgICAgICAgIGZ1bmN0aW9uKGNoYXIpIHsgc2VsZi5zdGF0ZSA9IFJFQURJTkdfQVRUUklCVVRFX05BTUU7IHNlbGYuY3VycmVudEF0dHJpYnV0ZS5uYW1lICs9IGNoYXIgfSxcbiAgICAgICAgJz4nOiAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKSAgICAgeyBzZWxmLnN0YXRlID0gV0FJVF9GT1JfTkVYVF9UT0tFTl9UT19TVEFSVCwgc2VsZi5maW5pc2hUb2tlbigpIH0sXG4gICAgICAgICcvJzogICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkgICAgIHsgc2VsZi5zdGF0ZSA9IFdBSVRJTkdfRk9SX0VNUFRZX1RBR19UT19CRV9DTE9TRUQsIHNlbGYuY3VycmVudFRva2VuLnR5cGUgPSAnRU1QVFlfVEFHJzsgfVxuICAgIH07XG5cbiAgICB0aGlzLnRyYW5zaXN0aW9uc1tXQUlUSU5HX0ZPUl9FTVBUWV9UQUdfVE9fQkVfQ0xPU0VEXSA9IHtcbiAgICAgICAgJ1xcbic6ICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkgICAgIHt9LFxuICAgICAgICAnPic6ICAgICAgICAgICAgICAgICBmdW5jdGlvbigpICAgICB7IHNlbGYuc3RhdGUgPSBXQUlUX0ZPUl9ORVhUX1RPS0VOX1RPX1NUQVJULCBzZWxmLmZpbmlzaFRva2VuKCkgfSxcbiAgICB9O1xuXG4gICAgdGhpcy50cmFuc2lzdGlvbnNbUkVBRElOR19URVhUXSA9IHtcbiAgICAgICAgJzwnOiAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKSAgICAgeyBzZWxmLnN0YXRlID0gREVURVJNSU5JTkdfVEFHX1RZUEU7IHNlbGYuZmluaXNoVG9rZW4oKTsgfSxcbiAgICAgICAgJ2Vsc2UnOiAgICAgICAgICAgICAgZnVuY3Rpb24oY2hhcikgeyBzZWxmLmN1cnJlbnRUb2tlbi52YWx1ZSArPSBjaGFyOyB9LFxuICAgICAgICAnRU9GJzogICAgICAgICAgICAgICBmdW5jdGlvbigpICAgICB7IHNlbGYuZmluaXNoVG9rZW4oKTsgfVxuICAgIH07XG5cbiAgICB0aGlzLnRyYW5zaXN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZ2xvYkNoYXJSYW5nZXNJblRyYW5zdGlvbih0KTtcbiAgICB9KVxufTtcblxuU3RhdGVNYWNoaW5lLnByb3RvdHlwZS5maW5pc2hBdHRyaWJ1dGUgPSBmdW5jdGlvbigpIHtcblxuICAgIGlmKHRoaXMuY3VycmVudEF0dHJpYnV0ZS5uYW1lID09PSAnY2xhc3MnKSB7XG4gICAgICAgIHRoaXMuY3VycmVudEF0dHJpYnV0ZS5uYW1lID0gJ2NsYXNzTmFtZXMnO1xuICAgICAgICB0aGlzLmN1cnJlbnRBdHRyaWJ1dGUudmFsdWUgPSB0aGlzLmN1cnJlbnRBdHRyaWJ1dGUudmFsdWUuc3BsaXQoJyAnKTtcbiAgICAgICAgdGhpcy5jdXJyZW50QXR0cmlidXRlLnZhbHVlID0gdGhpcy5jdXJyZW50QXR0cmlidXRlLnZhbHVlLm1hcChmdW5jdGlvbihjKSB7IHJldHVybiBjLnRyaW0oKSB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRUb2tlbi5hdHRyaWJ1dGVzW3RoaXMuY3VycmVudEF0dHJpYnV0ZS5uYW1lXSA9IHRoaXMuY3VycmVudEF0dHJpYnV0ZS52YWx1ZSB8fCB0cnVlO1xuICAgIHRoaXMuY3VycmVudEF0dHJpYnV0ZSA9IHtuYW1lOiAnJywgdmFsdWU6ICcnfTtcbn07XG5cblN0YXRlTWFjaGluZS5wcm90b3R5cGUuZmluaXNoVG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRva2Vucy5wdXNoKHRoaXMuY3VycmVudFRva2VuKTtcbiAgICB0aGlzLnJlc2V0U3RhdGUoKTtcbn07XG5cblN0YXRlTWFjaGluZS5wcm90b3R5cGUucmVzZXRTdGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY3VycmVudFRva2VuID0ge3ZhbHVlOiAnJywgdHlwZTogJ1VOS05PV04nLCBhdHRyaWJ1dGVzOiB7fX07XG4gICAgdGhpcy5jdXJyZW50QXR0cmlidXRlID0ge25hbWU6ICcnLCB2YWx1ZTogJyd9O1xufTtcblxuU3RhdGVNYWNoaW5lLnByb3RvdHlwZS5yZXNldFN0YXRlTWFjaGluZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVzZXRTdGF0ZSgpO1xuICAgIHRoaXMudG9rZW5zID0gW107XG4gICAgdGhpcy5zdGF0ZSA9IFdBSVRfRk9SX05FWFRfVE9LRU5fVE9fU1RBUlQ7XG59XG5cbi8vIFN0YXRlIFBhcmFtOiB0aGUgU3RhdGVNYWNoaW5lIHN0YXRlIGluIHdoaWNoIHRoZSBicm9rZW4gb3BlbiB0YWcgaGFzIGJlZW4gZGV0ZWN0ZWRcblN0YXRlTWFjaGluZS5wcm90b3R5cGUuaGFuZGxlQnJva2VuT3BlblRhZyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYoc3RhdGUgPT09IFJFQURJTkdfQVRUUklCVVRFX05BTUUgfHwgc3RhdGUgPT09IFJFQURJTkdfQVRUUklCVVRFX1ZBTFVFKSB7XG4gICAgICAgIHRoaXMuZmluaXNoVG9rZW4oKTtcbiAgICAgICAgdGhpcy5jdXJyZW50VG9rZW4gPSB7dmFsdWU6ICcnLCB0eXBlOiAnVEVYVCcsIGF0dHJpYnV0ZXM6IHt9fTtcbiAgICAgICAgdGhpcy5maW5pc2hUb2tlbigpO1xuICAgIH1cbn1cblxuU3RhdGVNYWNoaW5lLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24oY2hhcikge1xuXG4gICAgaWYodGhpcy50cmFuc2lzdGlvbnNbdGhpcy5zdGF0ZV1bY2hhcl0pIHtcbiAgICAgICAgdGhpcy50cmFuc2lzdGlvbnNbdGhpcy5zdGF0ZV1bY2hhcl0oY2hhcik7XG4gICAgfSBlbHNlIGlmICh0aGlzLnRyYW5zaXN0aW9uc1t0aGlzLnN0YXRlXVsnZWxzZSddKSAge1xuICAgICAgICB0aGlzLnRyYW5zaXN0aW9uc1t0aGlzLnN0YXRlXVsnZWxzZSddKGNoYXIpXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2Vycm9yIHBhcnNpbmcgY29udGVudCcpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRva2Vucy5wb3AoKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZU1hY2hpbmVcbiIsInZhciBUYWdUcmFuc2Zvcm1hdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgICBPYmplY3QuY2FsbCh0aGlzKTtcbn1cblxuVGFnVHJhbnNmb3JtYXRpb25zLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LnByb3RvdHlwZSk7XG5cblRhZ1RyYW5zZm9ybWF0aW9ucy5wcm90b3R5cGUuYWxsb3dPbmx5VGV4dEluID0gZnVuY3Rpb24ocGF0aCwgYXJncykge1xuICAgIHZhciB0ID0gdGhpcyxcbiAgICAgICAgcCA9IHBhdGgsXG4gICAgICAgIGMgPSAnI2NvbnRlbnQnO1xuXG4gICAgYXJncyA9IGFyZ3MgfHwge307XG5cbiAgICB0W3ArJy9zcGFuJ10gPVxuICAgIHRbcCsnL3VsJ10gPVxuICAgIHRbcCsnL2xpJ10gPVxuICAgIHRbcCsnL3VsL2xpJ10gPVxuICAgIHRbcCsnL29sJ10gPVxuICAgIHRbcCsnL29sL2xpJ10gPVxuICAgIHRbcCsnL3N0cm9uZyddID1cbiAgICB0W3ArJy9lbSddID1cbiAgICB0W3ArJy9hL3NwYW4nXSA9XG4gICAgdFtwKycvYi9iJ10gPVxuICAgIHRbcCsnL3UvdSddID1cbiAgICB0W3ArJy9pL2knXSA9XG4gICAgdFtwKycvZm9udCddID0gYztcblxuICAgIGlmKCFhcmdzLmFsbG93Qm9sZEl0YWxpY1VuZGVybGluZSkge1xuICAgICAgICB0W3ArJy9iJ10gPVxuICAgICAgICB0W3ArJy91J10gPVxuICAgICAgICB0W3ArJy9pJ10gPVxuICAgICAgICB0W3ArJy9jb2RlJ10gPSBjO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRbcCsnL2lubGluZWNvZGUvYiddID1cbiAgICAgICAgdFtwKycvaW5saW5lY29kZS9pJ10gPVxuICAgICAgICB0W3ArJy9pbmxpbmVjb2RlL3UnXSA9XG4gICAgICAgIHRbcCsnL2lubGluZWNvZGUvYSddID0gYztcbiAgICAgICAgdFtwKycvY29kZSddID0gJ2lubGluZWNvZGUnO1xuICAgICAgICB0W3ArJy9pbmxpbmVjb2RlL2lubGluZWNvZGUnXSA9ICcjY29udGVudCc7XG4gICAgICAgIHRbcCsnL2IvaW5saW5lY29kZSddID0gJy0nO1xuICAgICAgICB0W3ArJy91L2lubGluZWNvZGUnXSA9ICctJztcbiAgICAgICAgdFtwKycvaS9pbmxpbmVjb2RlJ10gPSAnLSc7XG4gICAgICAgIHRbcCsnL2EvY29kZSddID0gJ2lubGluZWNvZGUnO1xuICAgIH1cblxuICAgIGlmKCFhcmdzLmFsbG93TGlua3MpIHtcbiAgICAgIHRbcCsnL2EnXSA9IGM7XG4gICAgICB0W3ArJy9jb2RlJ10gPSBjO1xuICAgICAgdFtwKycvaW5saW5lY29kZSddID0gYztcbiAgICB9XG5cbiAgICBpZighYXJncy5hbGxvd1Jvb3RFbGVtZW50cykge1xuICAgICAgICB0W3ArJy9oMSddID1cbiAgICAgICAgdFtwKycvaDInXSA9XG4gICAgICAgIHRbcCsnL2gzJ10gPVxuICAgICAgICB0W3ArJy9oNCddID1cbiAgICAgICAgdFtwKycvaDUnXSA9XG4gICAgICAgIHRbcCsnL2g2J10gPVxuICAgICAgICB0W3ArJy9oNyddID1cbiAgICAgICAgdFtwKycvZGl2J10gPVxuICAgICAgICB0W3ArJy9wJ10gPSBjO1xuICAgIH1cblxuICAgIGlmKGFyZ3MuYWxsb3dFcXVhdGlvbnMpIHtcbiAgICAgICAgdC5hbGxvd0lubGluZWVxdWF0aW9uc0luKHApXG4gICAgfVxuXG4gICAgaWYoYXJncy5hbGxvd1JlZnMpIHtcbiAgICAgICAgdC5hbGxvd1JlZnNJbihwKTtcblxuICAgICAgICBpZihhcmdzLmFsbG93Qm9sZEl0YWxpY1VuZGVybGluZSkge1xuICAgICAgICAgICAgdC5hbGxvd1JlZnNJbihwICsgJy9iJyk7XG4gICAgICAgICAgICB0LmFsbG93UmVmc0luKHAgKyAnL3UnKTtcbiAgICAgICAgICAgIHQuYWxsb3dSZWZzSW4ocCArICcvaScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoYXJncy5hbGxvd0xpbmtzKSB7XG4gICAgICAgICAgICB0LmFsbG93UmVmc0luKHAgKyAnL2EnKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblRhZ1RyYW5zZm9ybWF0aW9ucy5wcm90b3R5cGUuYWxsb3dJbmxpbmVlcXVhdGlvbnNJbiA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICB2YXIgdCA9IHRoaXMsXG4gICAgICAgIHAgPSBwYXRoO1xuXG4gICAgdFtwKycvaW5saW5lZXF1YXRpb24nXSA9ICcjbm8tY29udGVudCc7XG4gICAgdFtwKycvYi9pbmxpbmVlcXVhdGlvbiddID1cbiAgICB0W3ArJy91L2lubGluZWVxdWF0aW9uJ10gPVxuICAgIHRbcCsnL2kvaW5saW5lZXF1YXRpb24nXSA9XG4gICAgdFtwKycvYS9pbmxpbmVlcXVhdGlvbiddID1cbiAgICB0W3ArJy9iL2kvaW5saW5lZXF1YXRpb24nXSA9XG4gICAgdFtwKycvaS9iL2lubGluZWVxdWF0aW9uJ10gPVxuICAgIHRbcCsnL2IvdS9pbmxpbmVlcXVhdGlvbiddID1cbiAgICB0W3ArJy91L2IvaW5saW5lZXF1YXRpb24nXSA9XG4gICAgdFtwKycvaS91L2lubGluZWVxdWF0aW9uJ10gPVxuICAgIHRbcCsnL3UvaS9pbmxpbmVlcXVhdGlvbiddID1cbiAgICB0W3ArJy9hL2kvaW5saW5lZXF1YXRpb24nXSA9XG4gICAgdFtwKycvaS9hL2lubGluZWVxdWF0aW9uJ10gPVxuICAgIHRbcCsnL2EvdS9pbmxpbmVlcXVhdGlvbiddID1cbiAgICB0W3ArJy91L2EvaW5saW5lZXF1YXRpb24nXSA9XG4gICAgdFtwKycvYS9iL2lubGluZWVxdWF0aW9uJ10gPVxuICAgIHRbcCsnL2IvYS9pbmxpbmVlcXVhdGlvbiddID0gJy0nXG59O1xuXG5cblxuVGFnVHJhbnNmb3JtYXRpb25zLnByb3RvdHlwZS5hbGxvd1JlZnNJbiA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICB0aGlzW3BhdGgrJy9zcGFuJ10gPSAnI2NvbnRlbnQnO1xuICAgIHRoaXNbcGF0aCsnL3NwYW4uZm9vdG5vdGUnXSA9ICdzcGFuLmZvb3Rub3RlJztcbiAgICB0aGlzW3BhdGgrJy9zcGFuLnJlZmVyZW5jZSddID0gJ3NwYW4ucmVmZXJlbmNlJztcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBUYWdUcmFuc2Zvcm1hdGlvbnNcbiIsImNsYXNzIE5vdEZvdW5kIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGxvb2t1cElEKSB7XG4gICAgICAgIHN1cGVyKGBObyByZWNvcmQgZm91bmQgZm9yICR7bG9va3VwSUR9YClcbiAgICB9XG59XG5cbmNsYXNzIEludmFsaWRJRCBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihsb29rdXBJRCkge1xuICAgICAgICBzdXBlcihgSUQgaXMgaW52YWxpZDogJHtsb29rdXBJRH1gKVxuICAgIH1cbn1cblxuY2xhc3MgRW1wdHlJRCBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ0lEIGFyZ3VtZW50IHNob3VsZCBub3QgYmUgbnVsbCBmb3IgZmV0Y2hpbmcgcmVmZXJlbmNlIGRhdGEuIE5lZWRzIHRvIGJlIGEgRE9JL0lTQk4nKVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgTm90Rm91bmQsXG4gICAgSW52YWxpZElELFxuICAgIEVtcHR5SURcbn07IiwidmFyIGxvb2t1cEJ5RE9JID0gcmVxdWlyZSgnLi9sb29rdXBfYnlfZG9pJyk7XG52YXIgbG9va3VwQnlJU0JOID0gcmVxdWlyZSgnLi9sb29rdXBfYnlfaXNibicpO1xudmFyIGxvb2t1cEJ5VVJMID0gcmVxdWlyZSgnLi9sb29rdXBfYnlfdXJsJyk7XG52YXIgbG9va3VwQnlBcnhpdiA9IHJlcXVpcmUoJy4vbG9va3VwX2J5X2FyeGl2Jyk7XG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZmV0Y2hKU09OOiBmdW5jdGlvbihpZCkge1xuICAgICAgICBpZighaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoXywgcmVqKSA9PiByZWoobmV3IGVycm9ycy5FbXB0eUlEKCkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlkID0gaWQudHJpbSgpO1xuXG4gICAgICAgIGlmKGxvb2t1cEJ5RE9JLmlzVmFsaWRJRChpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBsb29rdXBCeURPSS5mZXRjaEpTT04oaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYobG9va3VwQnlJU0JOLmlzVmFsaWRJRChpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBsb29rdXBCeUlTQk4uZmV0Y2hKU09OKGlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGxvb2t1cEJ5VVJMLmlzVmFsaWRJRChpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBsb29rdXBCeVVSTC5mZXRjaEpTT04oaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYobG9va3VwQnlBcnhpdi5pc1ZhbGlkSUQoaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9va3VwQnlBcnhpdi5mZXRjaEpTT04oaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChfLCByZWopID0+IHJlaihuZXcgZXJyb3JzLkludmFsaWRJRChpZCkpKTtcbiAgICB9LFxuXG4gICAgbG9va3VwQnlET0k6IGxvb2t1cEJ5RE9JLmZldGNoSlNPTixcbiAgICBsb29rdXBCeUlTQk46IGxvb2t1cEJ5SVNCTi5mZXRjaEpTT04sXG4gICAgbG9va3VwQnlVUkw6IGxvb2t1cEJ5VVJMLmZldGNoSlNPTixcbiAgICBlcnJvcnM6IGVycm9ycyxcbn0iLCIvLyBmZXRjaCgnaHR0cDovL2V4cG9ydC5hcnhpdi5vcmcvYXBpL3F1ZXJ5P2lkX2xpc3Q9MTkwNi4wMTczOCcpLnRoZW4ociA9PiByLnRleHQoKSkudGhlbih0ZXh0ID0+IClcblxudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG52YXIgbW9udGhzID0gWydKYW4uJywgJ0ZlYi4nLCAnTWFyLicsICdBcHIuJywgJ01heS4nLCAnSnVuLicsICdKdWwuJywgJ0F1Zy4nLCAnU2VwLicsICdPY3QuJywgJ05vdi4nLCAnRGVjJ107XG52YXIgbG9va3VwQ2FjaGUgPSB7fVxuXG5mdW5jdGlvbiBnZXRQdWJsaXNoZWRNb250aChlbnRyeSkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoZW50cnkucXVlcnlTZWxlY3RvcigncHVibGlzaGVkJykuaW5uZXJIVE1MKVxuXG4gICAgICAgIGlmKCFkYXRlIHx8IGRhdGUgPT0gJ0ludmFsaWQgRGF0ZScpIHtcbiAgICAgICAgICAgIHRocm93ICdpbnZhbGlkIHB1YmxpY2F0aW9uIGRhdGUnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1vbnRoc1tkYXRlLmdldE1vbnRoKCldXG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ2Vycm9yIHBhcnNpbmcgcHVibGljYXRpb24gZGF0ZScsIGV4KVxuICAgICAgICByZXR1cm4gJydcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldFB1Ymxpc2hlZFllYXIoZW50cnkpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKGVudHJ5LnF1ZXJ5U2VsZWN0b3IoJ3B1Ymxpc2hlZCcpLmlubmVySFRNTClcblxuICAgICAgICBpZighZGF0ZSB8fCBkYXRlID09ICdJbnZhbGlkIERhdGUnKSB7XG4gICAgICAgICAgICB0aHJvdyAnaW52YWxpZCBwdWJsaWNhdGlvbiBkYXRlJ1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGUuZ2V0RnVsbFllYXIoKVxuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdlcnJvciBwYXJzaW5nIHB1YmxpY2F0aW9uIGRhdGUnLCBleClcbiAgICAgICAgcmV0dXJuICcnXG4gICAgfVxufVxuXG5mdW5jdGlvbiByZXN1bHRGcm9tUmVzcG5vc2UoeG1sRG9jKSB7XG4gICAgdmFyIGVudHJ5ID0geG1sRG9jLnF1ZXJ5U2VsZWN0b3IoJ2VudHJ5JylcbiAgICB2YXIgdGl0bGVFbCA9IGVudHJ5LnF1ZXJ5U2VsZWN0b3IoJ3RpdGxlJylcbiAgICB2YXIgYXV0aG9ycyA9IGVudHJ5LnF1ZXJ5U2VsZWN0b3JBbGwoJ2F1dGhvcicpLm1hcChhdXRob3IgPT4ge1xuICAgICAgICBhdXRob3IgPSBhdXRob3IgJiYgYXV0aG9yLnF1ZXJ5U2VsZWN0b3IoJ25hbWUnKVxuICAgICAgICBpZihhdXRob3IgJiYgYXV0aG9yLmlubmVySFRNTCkge1xuICAgICAgICAgICAgcmV0dXJuIGF1dGhvci5pbm5lckhUTUxcbiAgICAgICAgfVxuICAgIH0pLmpvaW4oJyBhbmQgJylcblxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdBcnRpY2xlJyxcbiAgICAgICAgdGl0bGU6ICh0aXRsZUVsICYmIHRpdGxlRWwuaW5uZXJIVE1MKSB8fCAnJyxcbiAgICAgICAgYXV0aG9yOiBhdXRob3JzLFxuICAgICAgICB5ZWFyOiBnZXRQdWJsaXNoZWRZZWFyKGVudHJ5KSxcbiAgICAgICAgbW9udGg6IGdldFB1Ymxpc2hlZE1vbnRoKGVudHJ5KVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICBpc1ZhbGlkSUQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHJldHVybiBpZCAmJiBpZC50cmltKCkubWF0Y2goL14oYXJYaXY6KT9bMC05XXs0fVxcLlswLTldKyh2Lik/JC8pXG4gICAgfSxcblxuICAgIGZldGNoSlNPTjogYXN5bmMgZnVuY3Rpb24oaWQpIHtcblxuICAgICAgICBpZighdGhpcy5pc1ZhbGlkSUQoaWQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkludmFsaWRJRChpZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihpZC50cmltKCkubWF0Y2goL15hclhpdjovKSkge1xuICAgICAgICAgICAgaWQgPSBpZC50cmltKCkucmVwbGFjZSgvXmFyWGl2Oi8sICcnKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYobG9va3VwQ2FjaGVbaWRdKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9va3VwQ2FjaGVbaWRdXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzID0gYXdhaXQgZmV0Y2goYGh0dHA6Ly9leHBvcnQuYXJ4aXYub3JnL2FwaS9xdWVyeT9pZF9saXN0PSR7aWR9YClcblxuICAgICAgICBpZighcmVzLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcnMuTm90Rm91bmRcbiAgICAgICAgfVxuXG4gICAgICAgIGxvb2t1cENhY2hlW2lkXSA9IHJlc3VsdEZyb21SZXNwbm9zZShcbiAgICAgICAgICAgIG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKGF3YWl0IHJlcy50ZXh0KCksIFwidGV4dC94bWxcIilcbiAgICAgICAgKVxuXG4gICAgICAgIHJldHVybiBsb29rdXBDYWNoZVtpZF1cbiAgICB9XG59IiwidmFyIGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG52YXIgZG9pTG9va3VwQ2FjaGUgPSB7fVxuXG52YXIgbW9udGhzID0gWydKYW4uJywgJ0ZlYi4nLCAnTWFyLicsICdBcHIuJywgJ01heS4nLCAnSnVuLicsICdKdWwuJywgJ0F1Zy4nLCAnU2VwLicsICdPY3QuJywgJ05vdi4nLCAnRGVjJ107XG5cbnZhciBkb2lUeXBlMmJpYlRlWFR5cGUgPSB7XG4gICAgJ2pvdXJuYWwtYXJ0aWNsZSc6ICdBcnRpY2xlJyxcbiAgICAncHJvY2VlZGluZ3MtYXJ0aWNsZSc6ICdDb25mZXJlbmNlL0lucHJvY2VlZGluZ3MnLFxuICAgICdkaXNzZXJ0YXRpb24nOiAnUGhkdGhlc2lzJyxcblxuICAgICdib29rJzogJ0Jvb2snLFxuICAgICdib29rLXNlcmllcyc6ICdCb29rJyxcbiAgICAnYm9vay1zZXQnOiAnQm9vaycsXG4gICAgJ2Jvb2stdHJhY2snOiAnQm9vaycsXG4gICAgJ21vbm9ncmFwaCc6ICdCb29rJyxcbiAgICAncmVmZXJlbmNlLWJvb2snOiAnQm9vaycsXG5cbiAgICAnYm9vay1jaGFwdGVyJzogJ0luYm9vaycsXG4gICAgJ2Jvb2stcGFydCc6ICdJbmJvb2snLFxuICAgICdib29rLXNlY3Rpb24nOiAnSW5ib29rJyxcbiAgICAncmVmZXJlbmNlLWVudHJ5JzogJ0luYm9vaycsXG5cbiAgICAnZGF0YXNldCc6ICdUZWNocmVwb3J0JyxcbiAgICAncG9zdGVkLWNvbnRlbnQnOiAnVGVjaHJlcG9ydCcsXG4gICAgJ3JlcG9ydCc6ICdUZWNocmVwb3J0JyxcbiAgICAncmVwb3J0LXNlcmllcyc6ICdUZWNocmVwb3J0JyxcbiAgICAnc3RhbmRhcmQnOiAnVGVjaHJlcG9ydCcsXG59O1xuXG52YXIgc2VsZWN0ZWRGaWVsZHMgPSBbXG4gICAgJ3R5cGUnLFxuICAgICdjb250YWluZXItdGl0bGUnLCAvLyAtPiBqb3VybmFsLCBib29rdGl0bGUsIGV2ZW50dGl0bGVcbiAgICAndm9sdW1lJyxcbiAgICAnaXNzdWUnLFxuICAgICdwdWJsaXNoZXInLFxuICAgICdpc3N1ZWQnLCAvLyAtPiB5ZWFyLCBtb250aFxuICAgICd0aXRsZScsXG4gICAgJ3N1YnRpdGxlJyxcbiAgICAnYXV0aG9yJyxcbiAgICAnZWRpdG9yJyxcbl07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybURvaUF1dGhvcnMoZG9pRGF0YSwgZmllbGQpIHtcbiAgICByZXR1cm4gKGRvaURhdGFbKGZpZWxkKV0gfHwgW10pXG4gICAgICAgIC5tYXAoYSA9PiBgJHthLmZhbWlseX0sICR7YS5naXZlbn1gKVxuICAgICAgICAuam9pbignIGFuZCAnKVxufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Eb2lNb250aChkb2lEYXRhKSB7XG4gICAgaWYoZG9pRGF0YSAmJiBkb2lEYXRhLmlzc3VlZCAmJiBkb2lEYXRhLmlzc3VlZFsnZGF0ZS1wYXJ0cyddICYmIGRvaURhdGEuaXNzdWVkWydkYXRlLXBhcnRzJ11bMF0gJiYgZG9pRGF0YS5pc3N1ZWRbJ2RhdGUtcGFydHMnXVswXVsxXSkge1xuICAgICAgICByZXR1cm4gbW9udGhzW2RvaURhdGEuaXNzdWVkWydkYXRlLXBhcnRzJ11bMF1bMV0tMV07XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Eb2lZZWFyKGRvaURhdGEpIHtcbiAgICBpZihkb2lEYXRhICYmIGRvaURhdGEuaXNzdWVkICYmIGRvaURhdGEuaXNzdWVkWydkYXRlLXBhcnRzJ10gJiYgZG9pRGF0YS5pc3N1ZWRbJ2RhdGUtcGFydHMnXVswXSAmJiBkb2lEYXRhLmlzc3VlZFsnZGF0ZS1wYXJ0cyddWzBdWzBdKSB7XG4gICAgICAgIHJldHVybiBkb2lEYXRhLmlzc3VlZFsnZGF0ZS1wYXJ0cyddWzBdWzBdO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtRG9pUHVibGlzaGVyKGRvaURhdGEpIHtcbiAgICBpZihbJ2Jvb2stY2hhcHRlcicsXG4gICAgICAnYm9vay1wYXJ0JyxcbiAgICAgICdib29rLXNlY3Rpb24nLFxuICAgICAgJ3JlZmVyZW5jZS1lbnRyeScsXG4gICAgICAncHJvY2VlZGluZ3MtYXJ0aWNsZScsXG4gICAgICAnYm9vaycsXG4gICAgICAnYm9vay1zZXJpZXMnLFxuICAgICAgJ2Jvb2stc2V0JyxcbiAgICAgICdib29rLXRyYWNrJyxcbiAgICAgICdtb25vZ3JhcGgnLFxuICAgICAgJ3JlZmVyZW5jZS1ib29rJ10uaW5jbHVkZXMoZG9pRGF0YS50eXBlKSkge1xuICAgICAgICByZXR1cm4gZG9pRGF0YS5wdWJsaXNoZXIgfHwgJyc7XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtRG9pT3JnYW5pemF0aW9uKGRvaURhdGEpIHtcbiAgICBpZihbJ3Byb2NlZWRpbmdzLWFydGljbGUnXS5pbmNsdWRlcyhkb2lEYXRhLnR5cGUpKSB7XG4gICAgICAgIHJldHVybiBkb2lEYXRhLnB1Ymxpc2hlciB8fCAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybURvaVNjaG9vbChkb2lEYXRhKSB7XG4gICAgaWYoWydkaXNzZXJ0YXRpb24nXS5pbmNsdWRlcyhkb2lEYXRhLnR5cGUpKSB7XG4gICAgICAgIHJldHVybiBkb2lEYXRhLnB1Ymxpc2hlciB8fCAnJztcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBkZWNvZGUoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKCcmYW1wOycsICcmJylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICBpc1ZhbGlkSUQ6IGZ1bmN0aW9uKGRvaSkge1xuICAgICAgICByZXR1cm4gZG9pLm1hdGNoKC9eMTAuXFxkezQsOX1cXC8uKyQvaSk7XG4gICAgfSxcblxuICAgIGZldGNoSlNPTjogZnVuY3Rpb24oZG9pKSB7XG4gICAgICAgIHJldHVybiBtb2R1bGUuZXhwb3J0cy5xdWVyeUNyb3NzcmVmKGRvaSkudGhlbihyZXN1bHREYXRhID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogcmVzdWx0RGF0YS50eXBlID8gZG9pVHlwZTJiaWJUZVhUeXBlW3Jlc3VsdERhdGEudHlwZV0gOiAnQXJ0aWNsZScsXG4gICAgICAgICAgICAgICAgYXV0aG9yOiB0cmFuc2Zvcm1Eb2lBdXRob3JzKHJlc3VsdERhdGEsICdhdXRob3InKSxcbiAgICAgICAgICAgICAgICBlZGl0b3I6IHRyYW5zZm9ybURvaUF1dGhvcnMocmVzdWx0RGF0YSwgJ2VkaXRvcicpLFxuICAgICAgICAgICAgICAgIHRpdGxlOiBkZWNvZGUocmVzdWx0RGF0YS50aXRsZSA/IHJlc3VsdERhdGEudGl0bGUuam9pbignIC0gJykgOiAnJyksXG4gICAgICAgICAgICAgICAgc3VidGl0bGU6IGRlY29kZShyZXN1bHREYXRhLnN1YnRpdGxlID8gcmVzdWx0RGF0YS5zdWJ0aXRsZS5qb2luKCcgLSAnKSA6ICcnKSxcbiAgICAgICAgICAgICAgICBqb3VybmFsOiBkZWNvZGUocmVzdWx0RGF0YVsnY29udGFpbmVyLXRpdGxlJ10gPyByZXN1bHREYXRhWydjb250YWluZXItdGl0bGUnXS5qb2luKCcgLSAnKSA6ICcnKSxcbiAgICAgICAgICAgICAgICBudW1iZXI6IHJlc3VsdERhdGEuaXNzdWUgfHwgJycsXG4gICAgICAgICAgICAgICAgdm9sdW1lOiByZXN1bHREYXRhLnZvbHVtZSB8fCAnJyxcbiAgICAgICAgICAgICAgICBwdWJsaXNoZXI6IGRlY29kZSh0cmFuc2Zvcm1Eb2lQdWJsaXNoZXIocmVzdWx0RGF0YSkpLFxuICAgICAgICAgICAgICAgIG9yZ2FuaXphdGlvbjogZGVjb2RlKHRyYW5zZm9ybURvaU9yZ2FuaXphdGlvbihyZXN1bHREYXRhKSksXG4gICAgICAgICAgICAgICAgeWVhcjogdHJhbnNmb3JtRG9pWWVhcihyZXN1bHREYXRhKSxcbiAgICAgICAgICAgICAgICBtb250aDogdHJhbnNmb3JtRG9pTW9udGgocmVzdWx0RGF0YSksXG4gICAgICAgICAgICAgICAgc2Nob29sOiB0cmFuc2Zvcm1Eb2lTY2hvb2wocmVzdWx0RGF0YSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHF1ZXJ5Q3Jvc3NyZWY6IGZ1bmN0aW9uKGRvaSkge1xuICAgICAgICBpZighZG9pIHx8ICF0aGlzLmlzVmFsaWRJRChkb2kpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiByZWooJ2ludmFsaWQgRE9JJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoZG9pTG9va3VwQ2FjaGVbZG9pXSkge1xuICAgICAgICAgICAgcmV0dXJuIGRvaUxvb2t1cENhY2hlW2RvaV1cbiAgICAgICAgfVxuXG4gICAgICAgIGRvaUxvb2t1cENhY2hlW2RvaV0gPSBmZXRjaChgaHR0cHM6Ly9hcGkuY3Jvc3NyZWYub3JnL3dvcmtzLz9maWx0ZXI9ZG9pOiR7ZW5jb2RlVVJJQ29tcG9uZW50KGRvaSl9JnNlbGVjdD0ke2VuY29kZVVSSUNvbXBvbmVudChzZWxlY3RlZEZpZWxkcy5qb2luKCcsJykpfWApXG4gICAgICAgICAgICAudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5qc29uKCkpXG4gICAgICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgICAgICBpZihkYXRhICYmIGRhdGEubWVzc2FnZSAmJiBkYXRhLm1lc3NhZ2UuaXRlbXMsIGRhdGEubWVzc2FnZS5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEubWVzc2FnZS5pdGVtc1swXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKF8sIHJlaikgPT4gcmVqKG5ldyBlcnJvcnMuTm90Rm91bmQoZG9pKSkpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGRvaUxvb2t1cENhY2hlW2RvaV07XG4gICAgfVxufSIsInZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xudmFyIGZldGNoQ2FjaGUgPSB7fVxudmFyIG1vbnRocyA9IFsnSmFuLicsICdGZWIuJywgJ01hci4nLCAnQXByLicsICdNYXkuJywgJ0p1bi4nLCAnSnVsLicsICdBdWcuJywgJ1NlcC4nLCAnT2N0LicsICdOb3YuJywgJ0RlYyddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBpc1ZhbGlkSUQ6IGZ1bmN0aW9uKGlzYm4pIHtcbiAgICAgICAgcmV0dXJuIGlzYm4ubWF0Y2goL14oPz0oPzpcXEQqXFxkKXsxMH0oPzooPzpcXEQqXFxkKXszfSk/JClbXFxkLV0rJC8pO1xuICAgIH0sXG5cbiAgICBmZXRjaEpTT046IGFzeW5jIGZ1bmN0aW9uKGlzYm4pIHtcbiAgICAgICAgaWYoIXRoaXMuaXNWYWxpZElEKGlzYm4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkludmFsaWRJRChpc2JuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGZldGNoQ2FjaGVbaXNibl0pIHtcbiAgICAgICAgICAgIHJldHVybiBmZXRjaENhY2hlW2lzYm5dO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJhd0RhdGEgPSBhd2FpdCBmZXRjaChgaHR0cHM6Ly9vcGVubGlicmFyeS5vcmcvaXNibi8ke2lzYm59Lmpzb25gKTtcblxuICAgICAgICBpZihyYXdEYXRhLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gd2luZG93LnNldFRpbWVvdXQocmVzLCAxMDAwKSk7XG4gICAgICAgICAgICByYXdEYXRhID0gYXdhaXQgZmV0Y2goYGh0dHBzOi8vb3BlbmxpYnJhcnkub3JnL2lzYm4vJHtpc2JufS5qc29uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihyYXdEYXRhLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLk5vdEZvdW5kKGlzYm4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmF3RGF0YSA9IGF3YWl0IHJhd0RhdGEuanNvbigpO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgcmVzdWx0LmF1dGhvciA9IChhd2FpdCB0aGlzLmdldEF1dGhvcnMocmF3RGF0YSkpLmpvaW4oJyBhbmQgJyk7XG4gICAgICAgIHJlc3VsdC50eXBlID0gJ0Jvb2snO1xuXG4gICAgICAgIGlmKHJhd0RhdGEudGl0bGUpIHtcbiAgICAgICAgICAgIHJlc3VsdC50aXRsZSA9IHJhd0RhdGEudGl0bGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZihyYXdEYXRhLnN1YnRpdGxlKSB7XG4gICAgICAgICAgICByZXN1bHQuc3VidGl0bGUgPSByYXdEYXRhLnN1YnRpdGxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYocmF3RGF0YS5wdWJsaXNoZXJzICYmIHJhd0RhdGEucHVibGlzaGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdWJsaXNoZXIgPSByYXdEYXRhLnB1Ymxpc2hlcnNbMF07XG4gICAgICAgIH1cblxuICAgICAgICBpZihyYXdEYXRhLnB1Ymxpc2hfZGF0ZSkge1xuICAgICAgICAgICAgdmFyIHB1Ymxpc2hEYXRlID0gbmV3IERhdGUocmF3RGF0YS5wdWJsaXNoX2RhdGUpO1xuICAgICAgICAgICAgaWYocHVibGlzaERhdGUgaW5zdGFuY2VvZiBEYXRlICYmICFpc05hTihwdWJsaXNoRGF0ZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQueWVhciA9IHB1Ymxpc2hEYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0Lm1vbnRoID0gbW9udGhzW3B1Ymxpc2hEYXRlLmdldE1vbnRoKCldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYocmF3RGF0YS5pc2JuXzEzICYmIHJhd0RhdGEuaXNibl8xMy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdC5pc2JuID0gcmF3RGF0YS5pc2JuXzEzWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgZmV0Y2hDYWNoZVtpc2JuXSA9IHJlc3VsdDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgZ2V0QXV0aG9yczogYXN5bmMgZnVuY3Rpb24ocGF5bG9hZCkge1xuICAgICAgICB2YXIgYXV0aG9ycyA9IFtdO1xuXG4gICAgICAgIGlmKHBheWxvYWQuYXV0aG9ycyAmJiBwYXlsb2FkLmF1dGhvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaTxwYXlsb2FkLmF1dGhvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYXV0aG9yRGF0YSA9IGF3YWl0IGZldGNoKGBodHRwczovL29wZW5saWJyYXJ5Lm9yZyR7cGF5bG9hZC5hdXRob3JzW2ldLmtleX0uanNvbmApO1xuXG4gICAgICAgICAgICAgICAgaWYoIWF1dGhvckRhdGEub2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3JzLk5vdEZvdW5kXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXV0aG9yRGF0YSA9IGF3YWl0IGF1dGhvckRhdGEuanNvbigpO1xuICAgICAgICAgICAgICAgIGlmKGF1dGhvckRhdGEgJiYgYXV0aG9yRGF0YS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGF1dGhvcnMucHVzaChhdXRob3JEYXRhLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHBheWxvYWQuY29udHJpYnV0b3JzICYmIHBheWxvYWQuY29udHJpYnV0b3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGk8cGF5bG9hZC5jb250cmlidXRvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZihwYXlsb2FkLmNvbnRyaWJ1dG9yc1tpXS5yb2xlID09PSAnQXV0aG9yJykge1xuICAgICAgICAgICAgICAgICAgICBhdXRob3JzLnB1c2gocGF5bG9hZC5jb250cmlidXRvcnNbaV0ubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF1dGhvcnMubWFwKHRoaXMuYXV0aG9yTmFtZVRvQmliVGVYRm9ybWF0KTtcbiAgICB9LFxuXG4gICAgYXV0aG9yTmFtZVRvQmliVGVYRm9ybWF0OiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHZhciBuYW1lcyA9IG5hbWUuc3BsaXQoJyAnKTtcbiAgICAgICAgdmFyIGxhc3ROYW1lID0gbmFtZXMucG9wKCk7XG5cbiAgICAgICAgaWYoIW5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGxhc3ROYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGAke2xhc3ROYW1lfSwgJHtuYW1lcy5qb2luKCcgJyl9YDtcbiAgICB9LFxufSIsInZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xudmFyIGxvb2t1cENhY2hlID0ge31cbnZhciBtb250aHMgPSBbJ0phbi4nLCAnRmViLicsICdNYXIuJywgJ0Fwci4nLCAnTWF5LicsICdKdW4uJywgJ0p1bC4nLCAnQXVnLicsICdTZXAuJywgJ09jdC4nLCAnTm92LicsICdEZWMnXTtcbnZhciBhcGlFbmRwb2ludCA9ICdodHRwczovL2RqYXBpLmV1LWdiLm15Ymx1ZW1peC5uZXQnXG4vLyB2YXIgYXBpRW5kcG9pbnQgPSAnaHR0cDovL2xvY2FsaG9zdDo4MDgwJ1xuXG5mdW5jdGlvbiBnZXRQdWJsaXNoZWRNb250aCh1cmxNZXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh1cmxNZXRhWydhcnRpY2xlOnB1Ymxpc2hlZF90aW1lJ10pXG5cbiAgICAgICAgaWYoIWRhdGUgfHwgZGF0ZSA9PSAnSW52YWxpZCBEYXRlJykge1xuICAgICAgICAgICAgdGhyb3cgJ2ludmFsaWQgcHVibGljYXRpb24gZGF0ZSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbW9udGhzW2RhdGUuZ2V0TW9udGgoKV1cbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBjb25zb2xlLmxvZygnZXJyb3IgcGFyc2luZyBwdWJsaWNhdGlvbiBkYXRlJywgZXgpXG4gICAgICAgIHJldHVybiAnJ1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0UHVibGlzaGVkWWVhcih1cmxNZXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh1cmxNZXRhWydhcnRpY2xlOnB1Ymxpc2hlZF90aW1lJ10pXG5cbiAgICAgICAgaWYoIWRhdGUgfHwgZGF0ZSA9PSAnSW52YWxpZCBEYXRlJykge1xuICAgICAgICAgICAgdGhyb3cgJ2ludmFsaWQgcHVibGljYXRpb24gZGF0ZSdcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRlLmdldEZ1bGxZZWFyKClcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBjb25zb2xlLmxvZygnZXJyb3IgcGFyc2luZyBwdWJsaWNhdGlvbiBkYXRlJywgZXgpXG4gICAgICAgIHJldHVybiAnJ1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVzdWx0RnJvbVJlc3Bub3NlKHVybE1ldGEsIHVybCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdXZWJzaXRlJyxcbiAgICAgICAgdGl0bGU6ICh1cmxNZXRhLnRpdGxlICYmIHVybE1ldGEudGl0bGUudHJpbSgpICE9PSAnJyA/IHVybE1ldGEudGl0bGUgOiB1cmxNZXRhLmRlc2NyaXB0aW9uKSB8fCAnJyxcbiAgICAgICAgYXV0aG9yOiB1cmxNZXRhLmF1dGhvciB8fCAnJyxcbiAgICAgICAgdXJsOiB1cmwgfHwgdXJsTWV0YS51cmwgfHwgJycsXG4gICAgICAgIHllYXI6IGdldFB1Ymxpc2hlZFllYXIodXJsTWV0YSksXG4gICAgICAgIG1vbnRoOiBnZXRQdWJsaXNoZWRNb250aCh1cmxNZXRhKVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICBpc1ZhbGlkSUQ6IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICByZXR1cm4gdXJsICYmIHVybC50cmltKCkubWF0Y2goL15odHRwcz86XFwvXFwvLylcbiAgICB9LFxuXG4gICAgZmV0Y2hKU09OOiBhc3luYyBmdW5jdGlvbih1cmwpIHtcblxuICAgICAgICBpZighdGhpcy5pc1ZhbGlkSUQodXJsKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5JbnZhbGlkSUQodXJsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGxvb2t1cENhY2hlW3VybF0pIHtcbiAgICAgICAgICAgIHJldHVybiBsb29rdXBDYWNoZVt1cmxdXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdXJsTWV0YSA9IGF3YWl0IGZldGNoKGAke2FwaUVuZHBvaW50fS9hcGkvdjIvc3luY2pvYnMvZ2V0dXJsbWV0YWRhdGE/dXJsPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHVybCl9YClcblxuICAgICAgICBpZighdXJsTWV0YS5vaykge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3JzLk5vdEZvdW5kXG4gICAgICAgIH1cblxuICAgICAgICBsb29rdXBDYWNoZVt1cmxdID0gcmVzdWx0RnJvbVJlc3Bub3NlKGF3YWl0IHVybE1ldGEuanNvbigpLCB1cmwpXG5cbiAgICAgICAgcmV0dXJuIGxvb2t1cENhY2hlW3VybF1cbiAgICB9XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBnZXRFbGVtZW50UG9zaXRpb246IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIHZhciB4UG9zID0gMCxcbiAgICAgICAgICAgIHlQb3MgPSAwO1xuXG4gICAgICAgIHdoaWxlIChlbCkge1xuICAgICAgICAgICAgeFBvcyArPSBlbC5vZmZzZXRMZWZ0ICsgZWwuY2xpZW50TGVmdDtcbiAgICAgICAgICAgIHlQb3MgKz0gZWwub2Zmc2V0VG9wICArIGVsLmNsaWVudFRvcDtcblxuICAgICAgICAgICAgZWwgPSBlbC5vZmZzZXRQYXJlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogeFBvcyxcbiAgICAgICAgICAgIHk6IHlQb3NcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgZ2V0RGlzdGFuY2VUb1JpZ2h0V2luZG93Qm9yZGVyOiBmdW5jdGlvbihlbCkge1xuICAgICAgICB2YXIgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZighcmVjdCkgcmV0dXJuO1xuICAgICAgICByZXR1cm4gd2luZG93LmlubmVyV2lkdGggLSByZWN0LnggLSByZWN0LndpZHRoO1xuICAgIH0sXG5cbiAgICBjb3B5Tm9kZUF0dHJpYnV0ZXM6IGZ1bmN0aW9uKHNyY05vZGUsIHRhcmdldE5vZGUsIHNraXBBdHRyaWJ1dGVzKSB7XG4gICAgICAgIHNraXBBdHRyaWJ1dGVzID0gc2tpcEF0dHJpYnV0ZXMgfHwgW107XG5cbiAgICAgICAgZm9yKHZhciBpPTA7IGk8c3JjTm9kZS5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZihza2lwQXR0cmlidXRlcy5pbmRleE9mKHNyY05vZGUuYXR0cmlidXRlc1tpXS5uYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXROb2RlLnNldEF0dHJpYnV0ZShzcmNOb2RlLmF0dHJpYnV0ZXNbaV0ubmFtZSwgc3JjTm9kZS5hdHRyaWJ1dGVzW2ldLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRGaXJzdFBhcmVudFdpdGhUYWdOYW1lOiBmdW5jdGlvbihlbCwgdGFnTmFtZSkge1xuICAgICAgICB3aGlsZShlbCAmJiAhZWwudGFnTmFtZSA9PT0gdGFnTmFtZSkge1xuICAgICAgICAgICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxcbiAgICB9LFxuXG4gICAgZ2V0QWxsVGV4dE5vZGVzT2ZFbGVtZW50OiBmdW5jdGlvbihlbCkge1xuICAgICAgdmFyIG4sIGE9W10sIHdhbGsgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGVsLCBOb2RlRmlsdGVyLlNIT1dfVEVYVCwgbnVsbCwgZmFsc2UpO1xuXG4gICAgICB3aGlsZShuID0gd2Fsay5uZXh0Tm9kZSgpKSB7IGEucHVzaChuKTsgfVxuICAgICAgcmV0dXJuIGE7XG4gICAgfSxcblxuICAgIGdldExhc3RWaXNpYmxlQ2hpbGRPZkVsZW1lbnQ6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIHZhciB3YWxrID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihlbCwgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQgfCBOb2RlRmlsdGVyLlNIT1dfVEVYVCwgbnVsbCwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gd2Fsay5sYXN0Q2hpbGQoKTtcbiAgICB9LFxuXG4gICAgZ2V0Rmlyc3RWaXNpYmxlQ2hpbGRPZkVsZW1lbnQ6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIHZhciB3YWxrID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihlbCwgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQgfCBOb2RlRmlsdGVyLlNIT1dfVEVYVCwgbnVsbCwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gd2Fsay5uZXh0Tm9kZSgpO1xuICAgIH0sXG5cbiAgICBjb3B5RXZlbnRMaXN0ZW5lcnNSZWN1cnNpdmVseTogZnVuY3Rpb24oc3JjTm9kZSwgdGFyZ2V0Tm9kZSkge1xuICAgICAgICBpZihzcmNOb2RlICYmIHRhcmdldE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuY29weUV2ZW50TGlzdGVuZXJzKHNyY05vZGUsIHRhcmdldE5vZGUpO1xuICAgICAgICAgICAgZm9yKGxldCBpPTA7IGk8c3JjTm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3B5RXZlbnRMaXN0ZW5lcnNSZWN1cnNpdmVseShzcmNOb2RlLmNoaWxkTm9kZXNbaV0sIHRhcmdldE5vZGUuY2hpbGROb2Rlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY29weUV2ZW50TGlzdGVuZXJzOiBmdW5jdGlvbihzcmNOb2RlLCB0YXJnZXROb2RlKSB7XG4gICAgICAgIHRhcmdldE5vZGUub25jbGljayA9IHRhcmdldE5vZGUub25jbGljayB8fCBzcmNOb2RlLm9uY2xpY2s7XG4gICAgICAgIHRhcmdldE5vZGUub25kcmFnb3ZlciA9IHRhcmdldE5vZGUub25kcmFnb3ZlciB8fCBzcmNOb2RlLm9uZHJhZ292ZXI7XG4gICAgICAgIHRhcmdldE5vZGUub25kcmFnbGVhdmUgPSB0YXJnZXROb2RlLm9uZHJhZ2xlYXZlIHx8IHNyY05vZGUub25kcmFnbGVhdmU7XG4gICAgICAgIHRhcmdldE5vZGUub25kcm9wID0gdGFyZ2V0Tm9kZS5vbmRyb3AgfHwgc3JjTm9kZS5vbmRyb3A7XG4gICAgICAgIHRhcmdldE5vZGUub25jaGFuZ2UgPSB0YXJnZXROb2RlLm9uY2hhbmdlIHx8IHNyY05vZGUub25jaGFuZ2U7XG4gICAgICAgIHRhcmdldE5vZGUub25LZXlVcCA9IHRhcmdldE5vZGUub25LZXlVcCB8fCBzcmNOb2RlLm9uS2V5VXA7XG4gICAgICAgIHRhcmdldE5vZGUub25LZXlEb3duID0gdGFyZ2V0Tm9kZS5vbktleURvd24gfHwgc3JjTm9kZS5vbktleURvd247XG4gICAgICAgIHRhcmdldE5vZGUub25LZXlFbnRlciA9IHRhcmdldE5vZGUub25LZXlFbnRlciB8fCBzcmNOb2RlLm9uS2V5RW50ZXI7XG4gICAgICAgIHRhcmdldE5vZGUub25LZXlUYWIgPSB0YXJnZXROb2RlLm9uS2V5VGFiIHx8IHNyY05vZGUub25LZXlUYWI7XG4gICAgICAgIHRhcmdldE5vZGUub25LZXlCYWNrc3BhY2UgPSB0YXJnZXROb2RlLm9uS2V5QmFja3NwYWNlIHx8IHNyY05vZGUub25LZXlCYWNrc3BhY2U7XG4gICAgICAgIHRhcmdldE5vZGUub25LZXlDb21iaW5hdGlvbiA9IHRhcmdldE5vZGUub25LZXlDb21iaW5hdGlvbiB8fCBzcmNOb2RlLm9uS2V5Q29tYmluYXRpb247XG4gICAgICAgIHRhcmdldE5vZGUub25NYXJrdXBDbGVhbmluZ0ZpbnNoZWQgPSB0YXJnZXROb2RlLm9uTWFya3VwQ2xlYW5pbmdGaW5zaGVkIHx8IHNyY05vZGUub25NYXJrdXBDbGVhbmluZ0ZpbnNoZWQ7XG4gICAgICAgIHRhcmdldE5vZGUuc2V0Q29udGVudGVkaXRhYmxlID0gdGFyZ2V0Tm9kZS5zZXRDb250ZW50ZWRpdGFibGUgfHwgc3JjTm9kZS5zZXRDb250ZW50ZWRpdGFibGU7XG4gICAgICAgIHRhcmdldE5vZGUub25TZWxlY3Rpb25DaGFuZ2UgPSB0YXJnZXROb2RlLm9uU2VsZWN0aW9uQ2hhbmdlIHx8IHNyY05vZGUub25TZWxlY3Rpb25DaGFuZ2U7XG4gICAgICAgIHRhcmdldE5vZGUub25VbmZvY3VzID0gdGFyZ2V0Tm9kZS5vblVuZm9jdXMgfHwgc3JjTm9kZS5vblVuZm9jdXM7XG4gICAgICAgIHRhcmdldE5vZGUub25XaW5kb3dSZXNpemUgPSB0YXJnZXROb2RlLm9uV2luZG93UmVzaXplIHx8IHNyY05vZGUub25XaW5kb3dSZXNpemU7XG5cbiAgICAgICAgdGFyZ2V0Tm9kZS5zZWN0aW9uVHlwZSA9IHRhcmdldE5vZGUuc2VjdGlvblR5cGUgfHwgc3JjTm9kZS5zZWN0aW9uVHlwZTtcbiAgICB9LFxuXG4gICAgZ2V0Tm9kZUl0ZXJhdG9yUG9pbnRpbmdUbzogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBpZighbm9kZSkgeyByZXR1cm47IH1cbiAgICAgICAgdmFyIG5vZGVJdGVyYXRvciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoXG4gICAgICAgICAgICAgIGRvY3VtZW50LmJvZHksXG4gICAgICAgICAgICAgIE5vZGVGaWx0ZXIuU0hPV19URVhUIHwgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQsXG4gICAgICAgICAgICAgIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAobm9kZS5sZW5ndGggPT09IDAgfHwgbm9kZS5pbm5lckhUTUwgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBOb2RlRmlsdGVyLkZJTFRFUl9SRUpFQ1QgOlxuICAgICAgICAgICAgICAgICAgICAgICAgTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgbm9kZUl0ZXJhdG9yLmN1cnJlbnROb2RlID0gbm9kZTtcblxuICAgICAgICByZXR1cm4gbm9kZUl0ZXJhdG9yO1xuICAgIH0sXG5cbiAgICByZXNjdWVMYVRlWENoYXJzRnJvbUVzY2FwZTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIHZhciBtYXBwaW5nID0ge1xuICAgICAgICAgICAgJ1xcXFwnOiAnbGF0ZXhzbGFzaCcsXG4gICAgICAgICAgICAneyc6ICdsYXRleGNtZHN0YXJ0JyxcbiAgICAgICAgICAgICd9JzogJ2xhdGV4Y21kZW5kJyxcbiAgICAgICAgICAgICckJzogJ2xhdGV4Y2RvbGxhcicsXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bXFxcXHt9JF0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiAgbWFwcGluZ1ttYXRjaF0gPyAoJy0tJyttYXBwaW5nW21hdGNoXSsnLS0nKSA6ICcnO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgcmVzdG9yZVJlc2N1ZWRMYVRlWENoYXJzOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSB7XG4gICAgICAgICAgICAnbGF0ZXhzbGFzaCc6ICdcXFxcJyxcbiAgICAgICAgICAgICdsYXRleGNtZHN0YXJ0JzogJ3snLFxuICAgICAgICAgICAgJ2xhdGV4Y21kZW5kJzogJ30nLFxuICAgICAgICAgICAgJ2xhdGV4Y2RvbGxhcic6ICckJ1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvLS0obGF0ZXguezUsOH0/KS0tL2csIGZ1bmN0aW9uKG1hdGNoLCBjb2RlbmFtZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coY29kZW5hbWUsIG1hcHBpbmdbY29kZW5hbWVdKVxuICAgICAgICAgICAgcmV0dXJuICBtYXBwaW5nW2NvZGVuYW1lXSA/IG1hcHBpbmdbY29kZW5hbWVdIDogJyc7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBzdHJpbmdUb0F0dHJpYnV0ZVNhdmVTdHJpbmc6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICB2YXIgbWFwcGluZyA9IHtcbiAgICAgICAgICAgICc8JzogJ2x0JyxcbiAgICAgICAgICAgICc+JzogJ2d0JyxcbiAgICAgICAgICAgICdcXCcnOiAnYXBvcycsXG4gICAgICAgICAgICAnXCInOiAncXVvdCdcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1s8PidcIl0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiAgbWFwcGluZ1ttYXRjaF0gPyAoJy0tJyttYXBwaW5nW21hdGNoXSsnLS0nKSA6ICcnO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgYXR0cmlidXRlU2F2ZVN0cmluZ1RvU3RyaW5nOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSB7XG4gICAgICAgICAgICAnbHQnOiAnPCcsXG4gICAgICAgICAgICAnZ3QnOiAnPicsXG4gICAgICAgICAgICAnYXBvcyc6ICdcXCcnLFxuICAgICAgICAgICAgJ3F1b3QnOiAnXCInXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8tLSguezIsNH0/KS0tL2csIGZ1bmN0aW9uKG1hdGNoLCBjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFwcGluZ1tjb2RlXSB8fCAnJztcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGF0dHJpYnV0ZVNhdmVTdHJpbmdUb0hUTUxFbmNvZGVkOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8tLSguezIsNH0/KS0tL2csIGZ1bmN0aW9uKG1hdGNoLCBjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gICcmJyArIGNvZGUgKyAnOyc7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBnZXRTdWJ0cmVlQnlDaGlsZE5vZGU6IGZ1bmN0aW9uKGNvbnRhaW5lciwgY2hpbGQpIHtcbiAgICAgICAgd2hpbGUoY2hpbGQpIHtcbiAgICAgICAgICAgIGlmKGNoaWxkICYmIGNoaWxkLnBhcmVudEVsZW1lbnQgPT09IGNvbnRhaW5lciAmJiBjaGlsZC5ub2RlVHlwZSAhPT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZCA9IGNoaWxkLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICB9XG59O1xuIiwiLy9zZWU6IGh0dHBzOi8vY29kZWJ1cnN0LmlvL3Rocm90dGxpbmctYW5kLWRlYm91bmNpbmctaW4tamF2YXNjcmlwdC1iMDFjYWQ1YzhlZGZcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGltaXQsIGZ1bmMpIHtcbiAgbGV0IGxhc3RGdW5jO1xuICBsZXQgbGFzdFJhbjtcbiAgbGV0IGxhc3RSZWplY3Q7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgY29udGV4dCA9IHRoaXM7XG4gICAgICBjb25zdCBhcmdzID0gYXJndW1lbnRzO1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGlmICghbGFzdFJhbikge1xuICAgICAgICAgICAgICByZXNvbHZlKGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncykpO1xuICAgICAgICAgICAgICBsYXN0UmFuID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQobGFzdEZ1bmMpO1xuXG4gICAgICAgICAgICAgIGlmKGxhc3RSZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgIGxhc3RSZWplY3QoJ2NhbmNlbGVkIGJ5IHRocm90dGxlJylcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGxhc3RSZWplY3QgPSByZWplY3RcblxuICAgICAgICAgICAgICBsYXN0RnVuYyA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChEYXRlLm5vdygpIC0gbGFzdFJhbiA+PSBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RSYW4gPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sIGxpbWl0IC0gKERhdGUubm93KCkgLSBsYXN0UmFuKSk7XG4gICAgICAgICAgfVxuICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGVycilcblxuICAgICAgICAgIGlmKGVyciAhPT0gJ2NhbmNlbGVkIGJ5IHRocm90dGxlJykge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4gcmVqZWN0KGVycikpXG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gIH07XG59O1xuIiwiZnVuY3Rpb24gZ2V0TnVtYmVyUHJlYWZpeEhUTUwobnVtYmVyaW5nKSB7XG4gICAgaWYoIW51bWJlcmluZyB8fCBudW1iZXJpbmcubGVuZ3RoID09PSAwKSB7IHJldHVybiAnJyB9XG5cbiAgICByZXR1cm4gJzxzcGFuIGNsYXNzPVwiaW5kZXgtcHJlYWZpeFwiPicgKyBudW1iZXJpbmcgKyAnLiA8L3NwYW4+J1xufVxuXG5mdW5jdGlvbiBUT0NFbnRyeUZyb21FbGVtZW50KGgsIGFyZ3MpIHtcbiAgICB2YXIgbGluaywgcmVzdWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKVxuXG4gICAgaWYoaC5lbC5oYXNBdHRyaWJ1dGUoJ2lkJykgJiYgYXJncy53aXRoTGlua3MpIHtcbiAgICAgICAgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKVxuICAgICAgICBsaW5rLnNldEF0dHJpYnV0ZSgnaHJlZicsICcjJyArIGguZWwuZ2V0QXR0cmlidXRlKCdpZCcpKVxuICAgICAgICBsaW5rLmlubmVySFRNTCA9IGguY29udGVudFxuICAgICAgICByZXN1bHQuYXBwZW5kQ2hpbGQobGluaylcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQuaW5uZXJIVE1MID0gaC5jb250ZW50XG4gICAgfVxuXG4gICAgaWYoaC5udW1iZXJpbmcpIHtcbiAgICAgICAgcmVzdWx0LmlubmVySFRNTCA9IGdldE51bWJlclByZWFmaXhIVE1MKGgubnVtYmVyaW5nKSArIHJlc3VsdC5pbm5lckhUTUxcbiAgICB9XG5cbiAgICBpZihoLmVsLmNsYXNzTGlzdC5jb250YWlucygnbWlzc2luZ0xldmVsSGludCcpKSB7XG4gICAgICAgIHJlc3VsdC5jbGFzc0xpc3QgPSBoLmVsLmNsYXNzTGlzdFxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIG1pc3NpbmdMZXZlbFdhcmluZyhsZXZlbCkge1xuICB2YXIgcmVzdWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnSCcgKyBsZXZlbClcbiAgcmVzdWx0LmNsYXNzTGlzdC5hZGQoJ21pc3NpbmdMZXZlbEhpbnQnKVxuICByZXN1bHQuY2xhc3NMaXN0LmFkZCgnbGV2ZWwtJyArIGxldmVsKVxuXG4gIHJldHVybiB7XG4gICAgICBsZXZlbDogbGV2ZWwsXG4gICAgICBjb250ZW50OiAnJyxcbiAgICAgIGVsOiByZXN1bHRcbiAgfVxufVxuXG5mdW5jdGlvbiBhbm5vdGF0ZUhlYWRpbmdOdW1iZXJpbmcoRE9NRWxlbWVudCwgYXJncykge1xuICAgIHZhciBjMSA9IGMyID0gYzMgPSBjNCA9IGM1ID0gYzYgPSAwO1xuXG4gICAgaWYoIU51bWJlci5pc0ludGVnZXIoYXJncy5zdGFydE51bWJlcmluZ0F0TGV2ZWwpIHx8XG4gICAgICAgYXJncy5zdGFydE51bWJlcmluZ0F0TGV2ZWwgPCAxIHx8XG4gICAgICAgYXJncy5zdGFydE51bWJlcmluZ0F0TGV2ZWwgPiA2KSB7XG4gICAgICAgIHJldHVybiBET01FbGVtZW50O1xuICAgIH1cblxuICAgIERPTUVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaDEsIGgyLCBoMywgaDQsIGg1LCBoNicpLmZvckVhY2goZnVuY3Rpb24oaGVhZGluZykge1xuICAgICAgICB2YXIgbnVtYmVyaW5nXG5cbiAgICAgICAgaWYoaGVhZGluZy5nZXRBdHRyaWJ1dGUoJ3VubnVtYmVyZWQtaGVhZGluZycpID09PSAnWWVzJykge1xuICAgICAgICAgICAgaGVhZGluZy5udW1iZXJpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZihoZWFkaW5nLnRhZ05hbWUgPT09ICdIMScpIHtcbiAgICAgICAgICAgIGMyID0gYzMgPSBjNCA9IGM1ID0gYzYgPSAwXG4gICAgICAgICAgICBjMSsrXG4gICAgICAgICAgICBoZWFkaW5nLm51bWJlcmluZyA9IGMxXG4gICAgICAgICAgICBudW1iZXJpbmcgPSBbYzFdXG4gICAgICAgIH0gZWxzZSBpZihoZWFkaW5nLnRhZ05hbWUgPT09ICdIMicpIHtcbiAgICAgICAgICAgIGMzID0gYzQgPSBjNSA9IGM2ID0gMFxuICAgICAgICAgICAgYzIrK1xuICAgICAgICAgICAgaGVhZGluZy5udW1iZXJpbmcgPSBjMlxuICAgICAgICAgICAgbnVtYmVyaW5nID0gW2MxLCBjMl1cbiAgICAgICAgfSBlbHNlIGlmKGhlYWRpbmcudGFnTmFtZSA9PT0gJ0gzJykge1xuICAgICAgICAgICAgYzQgPSBjNSA9IGM2ID0gMFxuICAgICAgICAgICAgYzMrK1xuICAgICAgICAgICAgbnVtYmVyaW5nID0gW2MxLCBjMiwgYzNdXG4gICAgICAgIH0gZWxzZSBpZihoZWFkaW5nLnRhZ05hbWUgPT09ICdINCcpIHtcbiAgICAgICAgICAgIGM1ID0gYzYgPSAwXG4gICAgICAgICAgICBjNCsrXG4gICAgICAgICAgICBudW1iZXJpbmcgPSBbYzEsIGMyLCBjMywgYzRdXG4gICAgICAgIH0gZWxzZSBpZihoZWFkaW5nLnRhZ05hbWUgPT09ICdINScpIHtcbiAgICAgICAgICAgIGM2ID0gMFxuICAgICAgICAgICAgYzUrK1xuICAgICAgICAgICAgbnVtYmVyaW5nID0gW2MxLCBjMiwgYzMsIGM0LCBjNV1cbiAgICAgICAgfSBlbHNlIGlmKGhlYWRpbmcudGFnTmFtZSA9PT0gJ0g2Jykge1xuICAgICAgICAgICAgYzYrK1xuICAgICAgICAgICAgbnVtYmVyaW5nID0gW2MxLCBjMiwgYzMsIGM0LCBjNSwgYzZdXG4gICAgICAgIH1cblxuICAgICAgICBpZihudW1iZXJpbmcpIHtcbiAgICAgICAgICAgIG51bWJlcmluZy5zcGxpY2UoMCwgYXJncy5zdGFydE51bWJlcmluZ0F0TGV2ZWwtMSlcbiAgICAgICAgICAgIGhlYWRpbmcubnVtYmVyaW5nID0gbnVtYmVyaW5nLmpvaW4oJy4nKVxuICAgICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiBET01FbGVtZW50XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RIZWFkaW5ncyhET01FbGVtZW50KSB7XG4gICAgdmFyIHRtcE1hdGNoLCBoZWFkaW5ncyA9IFtdO1xuXG4gICAgRE9NRWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdoMSwgaDIsIGgzLCBoNCwgaDUsIGg2JykuZm9yRWFjaChmdW5jdGlvbihoZWFkaW5nKSB7XG4gICAgICAgIGlmKCh0bXBNYXRjaCA9IGhlYWRpbmcudGFnTmFtZS5tYXRjaCgvXkgoXFxkKykkLykpICYmICFoZWFkaW5nLmNsYXNzTGlzdC5jb250YWlucygnbm8tdG9jLWxpc3RpbmcnKSkge1xuICAgICAgICAgICAgaGVhZGluZ3MucHVzaCh7XG4gICAgICAgICAgICAgICAgbGV2ZWw6IHBhcnNlSW50KHRtcE1hdGNoWzFdKSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiBoZWFkaW5nLmlubmVyVGV4dCxcbiAgICAgICAgICAgICAgICBlbDogaGVhZGluZyxcbiAgICAgICAgICAgICAgICBudW1iZXJpbmc6IGhlYWRpbmcubnVtYmVyaW5nXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gaGVhZGluZ3M7XG59XG5cbmZ1bmN0aW9uIHJlcGFpckhpZXJhcmNoeShoZWFkaW5ncykge1xuICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgY3VycmVudExldmVsID0gMVxuXG4gICAgaGVhZGluZ3MuZm9yRWFjaCgoaGVhZGluZykgPT4ge1xuICAgICAgICBsZXQgbWlzc2luZ0xldmVscyA9IChoZWFkaW5nLmxldmVsIC0gY3VycmVudExldmVsKVxuXG4gICAgICAgIGZvcihsZXQgaT0wOyBtaXNzaW5nTGV2ZWxzPjE7IG1pc3NpbmdMZXZlbHMtLSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobWlzc2luZ0xldmVsV2FyaW5nKCsrY3VycmVudExldmVsKSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5wdXNoKGhlYWRpbmcpXG5cbiAgICAgICAgaWYobWlzc2luZ0xldmVscyA+IDApIHtcbiAgICAgICAgICAgIGN1cnJlbnRMZXZlbCsrXG4gICAgICAgIH0gZWxzZSBpZihtaXNzaW5nTGV2ZWxzIDwgMCkge1xuICAgICAgICAgICAgY3VycmVudExldmVsLS1cbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIFRPQ0Zyb21ET01FbGVtZW50KERPTUVsZW1lbnQsIGFyZ3MpIHtcbiAgICBhcmdzID0gYXJncyB8fCB7fVxuICAgIHZhciBoZWFkaW5ncyA9IHJlcGFpckhpZXJhcmNoeShleHRyYWN0SGVhZGluZ3MoYW5ub3RhdGVIZWFkaW5nTnVtYmVyaW5nKERPTUVsZW1lbnQsIGFyZ3MpKSksXG4gICAgICAgIHJlc3VsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29sJyksXG4gICAgICAgIGN1cnJlbnRMaXN0ID0gcmVzdWx0LFxuICAgICAgICBjdXJyZW50TGV2ZWwgPSAxXG5cbiAgICBoZWFkaW5ncy5mb3JFYWNoKChoZWFkaW5nKSA9PiB7XG4gICAgICAgIGlmKGN1cnJlbnRMZXZlbCA8IGhlYWRpbmcubGV2ZWwpIHtcbiAgICAgICAgICAgIGxldCB0bXBMaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb2wnKVxuICAgICAgICAgICAgY3VycmVudExpc3QuYXBwZW5kQ2hpbGQodG1wTGlzdClcbiAgICAgICAgICAgIGN1cnJlbnRMaXN0ID0gdG1wTGlzdFxuICAgICAgICAgICAgY3VycmVudExldmVsID0gY3VycmVudExldmVsKzFcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlKGN1cnJlbnRMZXZlbCA+IGhlYWRpbmcubGV2ZWwpIHtcbiAgICAgICAgICAgIGN1cnJlbnRMaXN0ID0gY3VycmVudExpc3QucGFyZW50Tm9kZVxuICAgICAgICAgICAgY3VycmVudExldmVsID0gY3VycmVudExldmVsLTFcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRMaXN0LmFwcGVuZENoaWxkKFRPQ0VudHJ5RnJvbUVsZW1lbnQoaGVhZGluZywgYXJncykpXG4gICAgfSlcblxuICAgIHJldHVybiByZXN1bHRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUT0NGcm9tRE9NRWxlbWVudFxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgWm90ZXJvT25saW5lOiByZXF1aXJlKCcuL29ubGluZScpXG59IiwidmFyIG1vbnRocyA9IFsnSmFuLicsICdGZWIuJywgJ01hci4nLCAnQXByLicsICdNYXkuJywgJ0p1bi4nLCAnSnVsLicsICdBdWcuJywgJ1NlcC4nLCAnT2N0LicsICdOb3YuJywgJ0RlYyddXG5cbmZ1bmN0aW9uIGdldE5leHRMaW5rKHJlc3VsdCkge1xuICAgIGNvbnN0IGxpbmtIZWFkZXIgPSByZXN1bHQuaGVhZGVycy5nZXQoJ0xpbmsnKVxuICAgIGNvbnN0IG5leHRNYXRjaCA9IGxpbmtIZWFkZXIuc3BsaXQoJywnKS5tYXAoeCA9PiB4Lm1hdGNoKC88KC4rPyk+OyByZWw9XCIoLis/KVwiLykpLmZpbmQoeCA9PiB4WzBdICYmIHhbMV0gJiYgeFsyXSA9PT0gJ25leHQnKVxuXG4gICAgaWYobmV4dE1hdGNoICYmIG5leHRNYXRjaFsxXSkge1xuICAgICAgICByZXR1cm4gbmV4dE1hdGNoWzFdXG4gICAgfVxufVxuXG5jbGFzcyBab3Rlcm9PbmxpbmUge1xuXG4gICAgc3RhdGljIHRyYW5zZm9ybVJlc3BvbnNlSXRlbShpdGVtLCBsYXN0TW9kVmVyc2lvbikge1xuICAgICAgICBjb25zdCB0eXBlTWFwID0ge1xuICAgICAgICAgICAgJ2Jvb2snOiAnQm9vaycsXG4gICAgICAgICAgICAnd2VicGFnZSc6ICdXZWJzaXRlJyxcbiAgICAgICAgICAgICdlbmN5Y2xvcGVkaWFBcnRpY2xlJzogJ1dlYnNpdGUnLFxuICAgICAgICAgICAgJ2Jsb2dQb3N0JzogJ1dlYnNpdGUnLFxuICAgICAgICAgICAgJ3RoZXNpcyc6ICdNYXN0ZXJzdGhlc2lzJyxcbiAgICAgICAgICAgICdjb25mZXJlbmNlUGFwZXInOiAnQ29uZmVyZW5jZScsXG4gICAgICAgICAgICAnam91cm5hbEFydGljbGUnOiAnQXJ0aWNsZScsXG4gICAgICAgICAgICAnYm9va1NlY3Rpb24nOiAnSW5ib29rJ1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZ2V0Q3JlYXRvcnNCeVR5cGV0ID0gdHlwZSA9PiB7XG4gICAgICAgICAgICBpZighaXRlbSB8fCAhaXRlbS5kYXRhIHx8ICFpdGVtLmRhdGEuY3JlYXRvcnMgfHwgIWl0ZW0uZGF0YS5jcmVhdG9ycy5maWx0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJydcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uZGF0YS5jcmVhdG9yc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoYyA9PiBjKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoYyA9PiBjLmNyZWF0b3JUeXBlID09PSB0eXBlKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoYyA9PiBjLmxhc3ROYW1lICYmIGMuZmlyc3ROYW1lKVxuICAgICAgICAgICAgICAgIC5tYXAoYyA9PiBgJHtjLmxhc3ROYW1lfSwgJHtjLmZpcnN0TmFtZX1gKVxuICAgICAgICAgICAgICAgIC5qb2luKCcgYW5kICcpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0cnlUb1BhcnNlWWVhciA9IGRhdGUgPT4ge1xuICAgICAgICAgICAgaWYoIWRhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJydcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKG5ldyBEYXRlKGRhdGUpKS5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKClcbiAgICAgICAgICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJydcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRyeVRvUGFyc2VNb250aCA9IGRhdGUgPT4ge1xuICAgICAgICAgICAgaWYoIWRhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJydcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9udGhzWyhuZXcgRGF0ZShkYXRlKSkuZ2V0TW9udGgoKV1cbiAgICAgICAgICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJydcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRyeVRvUGFyc2VEYXRlID0gZGF0ZSA9PiB7XG4gICAgICAgICAgICBpZighZGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJ1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRlLnNwbGl0KCdUJylbMF1cbiAgICAgICAgICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJydcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGl0ZW0uZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsb29rdXBJZDogaXRlbS5kYXRhLklTQk4gfHwgaXRlbS5kYXRhLkRPSSxcbiAgICAgICAgICAgICAgICBpZDogaXRlbS5rZXksXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZU1hcFtpdGVtLmRhdGEuaXRlbVR5cGVdIHx8ICdBcnRpY2xlJyxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VTb3VyY2U6IGB6b3Rlcm8tb25saW5lLSR7aXRlbS5saWJyYXJ5LnR5cGV9LSR7aXRlbS5saWJyYXJ5LmlkfWAsXG4gICAgICAgICAgICAgICAgdGl0bGU6IGl0ZW0uZGF0YS50aXRsZSxcbiAgICAgICAgICAgICAgICBhdXRob3I6IGdldENyZWF0b3JzQnlUeXBldCgnYXV0aG9yJyksXG4gICAgICAgICAgICAgICAgcGFnZXM6IGl0ZW0uZGF0YS5udW1QYWdlcyxcbiAgICAgICAgICAgICAgICB2b2x1bWU6IGl0ZW0uZGF0YS52YWx1bWUsXG4gICAgICAgICAgICAgICAgdXJsOiBpdGVtLmRhdGEudXJsLFxuICAgICAgICAgICAgICAgIHNlcmllczogaXRlbS5kYXRhLnNlcmllcyxcbiAgICAgICAgICAgICAgICBwdWJsaXNoZXI6IGl0ZW0uZGF0YS5wdWJsaXNoZXIsXG4gICAgICAgICAgICAgICAgZWRpdGlvbjogaXRlbS5kYXRhLmVkaXRpb24sXG4gICAgICAgICAgICAgICAgZGF0ZTogdHJ5VG9QYXJzZURhdGUoaXRlbS5kYXRhLmFjY2Vzc0RhdGUpLFxuICAgICAgICAgICAgICAgIHNlcmllczogaXRlbS5kYXRhLnNlcmllc051bWJlcixcbiAgICAgICAgICAgICAgICBib29rdGl0bGU6IGl0ZW0uZGF0YS5ib29rVGl0bGUsXG4gICAgICAgICAgICAgICAgeWVhcjogdHJ5VG9QYXJzZVllYXIoaXRlbS5kYXRhLmRhdGUpLFxuICAgICAgICAgICAgICAgIG1vbnRoOiB0cnlUb1BhcnNlTW9udGgoaXRlbS5kYXRhLmRhdGUpLFxuICAgICAgICAgICAgICAgIGVkaXRvcjogZ2V0Q3JlYXRvcnNCeVR5cGV0KCdlZGl0b3InKSxcbiAgICAgICAgICAgICAgICB6b3Rlcm9MYXN0TW9kVmVyc2lvbjogbGFzdE1vZFZlcnNpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKGFwaUtleSwgc3RvcmUpIHtcbiAgICAgICAgdGhpcy5hcGlLZXkgPSBhcGlLZXlcbiAgICAgICAgdGhpcy5zdG9yZSA9IHN0b3JlIHx8IG5ldyBNYXAoKVxuICAgICAgICB0aGlzLmF1dGhIZWFkZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0aGlzLmFwaUtleX1gXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBnZXRMYXN0TW9kaWZpZWRWZXJzaW9uKHNjb3BlLCBzY29wZUlEKSB7XG4gICAgICAgIHNjb3BlID0gc2NvcGUgPT09ICd1c2VycycgPyAndXNlcicgOiAnZ3JvdXAnXG5cbiAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5zdG9yZS5hbGwodHJ1ZSkpXG4gICAgICAgICAgICAuZmlsdGVyKGl0ZW0gPT4gaXRlbS5pZC5zdGFydHNXaXRoKGB6b3Rlcm8tb25saW5lLWl0ZW0tJHtzY29wZUlEfWApKVxuICAgICAgICAgICAgLm1hcChpdGVtID0+IGl0ZW0uem90ZXJvTGFzdE1vZFZlcnNpb24gfHwgMClcbiAgICAgICAgICAgIC5yZWR1Y2UoKGEsIGIpID0+IE1hdGgubWF4KGEsIGIpLCAwKVxuICAgIH1cblxuICAgIGFzeW5jIHNhdmVJdGVtKGl0ZW0sIHNjb3BlSUQpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKHRoaXMuc3RvcmUuc2V0KGB6b3Rlcm8tb25saW5lLWl0ZW0tJHtzY29wZUlEfS0ke2l0ZW0uaWR9YCwgaXRlbSkpXG4gICAgICAgIHJldHVybiBpdGVtXG4gICAgfVxuXG4gICAgc2F2ZUFsbEl0ZW0oaXRlbXMsIGxhc3RNb2RWZXJzaW9uLCBzY29wZUlEKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChpdGVtcy5tYXAoaXRlbSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zYXZlSXRlbShab3Rlcm9PbmxpbmUudHJhbnNmb3JtUmVzcG9uc2VJdGVtKGl0ZW0sIGxhc3RNb2RWZXJzaW9uKSwgc2NvcGVJRClcbiAgICAgICAgfSkpXG4gICAgfVxuXG4gICAgYXN5bmMgbG9hZFVzZXJJbmZvKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmZXRjaChgaHR0cHM6Ly9hcGkuem90ZXJvLm9yZy9rZXlzLyR7dGhpcy5hcGlLZXl9YClcbiAgICAgICAgY29uc3QgYm9keSA9IGF3YWl0IHJlc3VsdC5qc29uKClcbiAgICAgICAgdGhpcy51c2VySUQgPSBib2R5LnVzZXJJRFxuICAgICAgICB0aGlzLnVzZXJOYW1lID0gYm9keS51c2VybmFtZVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIGFzeW5jIGdyb3VwcygpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZmV0Y2goYGh0dHBzOi8vYXBpLnpvdGVyby5vcmcvdXNlcnMvJHt0aGlzLnVzZXJJRH0vZ3JvdXBzYCwgdGhpcy5hdXRoSGVhZGVyT3B0aW9ucylcbiAgICAgICAgY29uc3QgYm9keSA9IGF3YWl0IHJlc3VsdC5qc29uKClcbiAgICAgICAgdGhpcy5fZ3JvdXBzID0gYm9keS5tYXAociA9PiByLmRhdGEpXG4gICAgICAgIHJldHVybiB0aGlzLl9ncm91cHNcbiAgICB9XG5cbiAgICBhc3luYyBpdGVtcygpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5yZXF1ZXN0SXRlbXMoJ3VzZXJzJywgdGhpcy51c2VySUQpXG5cbiAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5zdG9yZS5hbGwodHJ1ZSkpXG4gICAgICAgICAgICAuZmlsdGVyKGl0ZW0gPT4gaXRlbS5pZC5zdGFydHNXaXRoKGB6b3Rlcm8tb25saW5lLWl0ZW0tJHt0aGlzLnVzZXJJRH1gKSlcbiAgICB9XG5cbiAgICBhc3luYyBpdGVtc0J5R3JvdXBJRChncm91cElEKSB7XG4gICAgICAgIGF3YWl0IHRoaXMucmVxdWVzdEl0ZW1zKCdncm91cHMnLCBncm91cElEKVxuXG4gICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuc3RvcmUuYWxsKHRydWUpKVxuICAgICAgICAgICAgLmZpbHRlcihpdGVtID0+IGl0ZW0uaWQuc3RhcnRzV2l0aChgem90ZXJvLW9ubGluZS1pdGVtLSR7Z3JvdXBJRH1gKSlcbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0SXRlbXMoc2NvcGUsIHNjb3BlSUQpIHtcbiAgICAgICAgdmFyIFsgYm9keSwgbmV4dExpbmssIGxhc3RNb2RWZXJzaW9uXSA9IGF3YWl0IHRoaXMucmVxdWVzdEpzb24oYGh0dHBzOi8vYXBpLnpvdGVyby5vcmcvJHtzY29wZX0vJHtzY29wZUlEfS9pdGVtcz9zaW5jZT0ke2F3YWl0IHRoaXMuZ2V0TGFzdE1vZGlmaWVkVmVyc2lvbihzY29wZSwgc2NvcGVJRCl9YClcbiAgICAgICAgdmFyIG5leHRMaW5rO1xuXG4gICAgICAgIHZhciBzdG9yZWRWYWx1ZXMgPSBhd2FpdCB0aGlzLnNhdmVBbGxJdGVtKGJvZHksIGxhc3RNb2RWZXJzaW9uLCBzY29wZUlEKVxuXG4gICAgICAgIHdoaWxlKG5leHRMaW5rKSB7XG4gICAgICAgICAgICBbIGJvZHksIG5leHRMaW5rIF0gPSBhd2FpdCB0aGlzLnJlcXVlc3RKc29uKG5leHRMaW5rKVxuICAgICAgICAgICAgc3RvcmVkVmFsdWVzLnB1c2goLi4uKGF3YWl0IHRoaXMuc2F2ZUFsbEl0ZW0oYm9keSwgbGFzdE1vZFZlcnNpb24sIHNjb3BlSUQpKSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHN0b3JlZFZhbHVlcylcbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0SnNvbih1cmwpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZmV0Y2godXJsLCB0aGlzLmF1dGhIZWFkZXJPcHRpb25zKVxuXG4gICAgICAgIGlmKHJlc3VsdC5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgdGhyb3cgJ0Vycm9yIHdoaWxlIGNvbm5lY3RpbmcgdG8gWm90ZXJvIEFQSSdcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBhd2FpdCByZXN1bHQuanNvbigpLFxuICAgICAgICAgICAgZ2V0TmV4dExpbmsocmVzdWx0KSxcbiAgICAgICAgICAgIHJlc3VsdC5oZWFkZXJzLmdldCgnTGFzdC1Nb2RpZmllZC1WZXJzaW9uJylcbiAgICAgICAgXVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBab3Rlcm9PbmxpbmUiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb250YWlucyhwYXJlbnQsIGNoaWxkKSB7XG4gIC8vICRGbG93Rml4TWU6IGhhc093blByb3BlcnR5IGRvZXNuJ3Qgc2VlbSB0byB3b3JrIGluIHRlc3RzXG4gIHZhciBpc1NoYWRvdyA9IEJvb2xlYW4oY2hpbGQuZ2V0Um9vdE5vZGUgJiYgY2hpbGQuZ2V0Um9vdE5vZGUoKS5ob3N0KTsgLy8gRmlyc3QsIGF0dGVtcHQgd2l0aCBmYXN0ZXIgbmF0aXZlIG1ldGhvZFxuXG4gIGlmIChwYXJlbnQuY29udGFpbnMoY2hpbGQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gdGhlbiBmYWxsYmFjayB0byBjdXN0b20gaW1wbGVtZW50YXRpb24gd2l0aCBTaGFkb3cgRE9NIHN1cHBvcnRcbiAgZWxzZSBpZiAoaXNTaGFkb3cpIHtcbiAgICAgIHZhciBuZXh0ID0gY2hpbGQ7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKG5leHQgJiYgcGFyZW50LmlzU2FtZU5vZGUobmV4dCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSAvLyAkRmxvd0ZpeE1lOiBuZWVkIGEgYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpcy4uLlxuXG5cbiAgICAgICAgbmV4dCA9IG5leHQucGFyZW50Tm9kZSB8fCBuZXh0Lmhvc3Q7XG4gICAgICB9IHdoaWxlIChuZXh0KTtcbiAgICB9IC8vIEdpdmUgdXAsIHRoZSByZXN1bHQgaXMgZmFsc2VcblxuXG4gIHJldHVybiBmYWxzZTtcbn0iLCJpbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuXG5mdW5jdGlvbiB0b051bWJlcihjc3NWYWx1ZSkge1xuICByZXR1cm4gcGFyc2VGbG9hdChjc3NWYWx1ZSkgfHwgMDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Qm9yZGVycyhlbGVtZW50KSB7XG4gIHZhciBjb21wdXRlZFN0eWxlID0gaXNIVE1MRWxlbWVudChlbGVtZW50KSA/IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkgOiB7fTtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IHRvTnVtYmVyKGNvbXB1dGVkU3R5bGUuYm9yZGVyVG9wV2lkdGgpLFxuICAgIHJpZ2h0OiB0b051bWJlcihjb21wdXRlZFN0eWxlLmJvcmRlclJpZ2h0V2lkdGgpLFxuICAgIGJvdHRvbTogdG9OdW1iZXIoY29tcHV0ZWRTdHlsZS5ib3JkZXJCb3R0b21XaWR0aCksXG4gICAgbGVmdDogdG9OdW1iZXIoY29tcHV0ZWRTdHlsZS5ib3JkZXJMZWZ0V2lkdGgpXG4gIH07XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHQsXG4gICAgdG9wOiByZWN0LnRvcCxcbiAgICByaWdodDogcmVjdC5yaWdodCxcbiAgICBib3R0b206IHJlY3QuYm90dG9tLFxuICAgIGxlZnQ6IHJlY3QubGVmdCxcbiAgICB4OiByZWN0LmxlZnQsXG4gICAgeTogcmVjdC50b3BcbiAgfTtcbn0iLCJpbXBvcnQgeyB2aWV3cG9ydCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGdldFZpZXdwb3J0UmVjdCBmcm9tIFwiLi9nZXRWaWV3cG9ydFJlY3QuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudFJlY3QgZnJvbSBcIi4vZ2V0RG9jdW1lbnRSZWN0LmpzXCI7XG5pbXBvcnQgbGlzdFNjcm9sbFBhcmVudHMgZnJvbSBcIi4vbGlzdFNjcm9sbFBhcmVudHMuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4vZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IHsgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBnZXREZWNvcmF0aW9ucyBmcm9tIFwiLi9nZXREZWNvcmF0aW9ucy5qc1wiO1xuaW1wb3J0IGNvbnRhaW5zIGZyb20gXCIuL2NvbnRhaW5zLmpzXCI7XG5pbXBvcnQgcmVjdFRvQ2xpZW50UmVjdCBmcm9tIFwiLi4vdXRpbHMvcmVjdFRvQ2xpZW50UmVjdC5qc1wiO1xuXG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBjbGlwcGluZ1BhcmVudCkge1xuICByZXR1cm4gY2xpcHBpbmdQYXJlbnQgPT09IHZpZXdwb3J0ID8gcmVjdFRvQ2xpZW50UmVjdChnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCkpIDogaXNIVE1MRWxlbWVudChjbGlwcGluZ1BhcmVudCkgPyBnZXRCb3VuZGluZ0NsaWVudFJlY3QoY2xpcHBpbmdQYXJlbnQpIDogcmVjdFRvQ2xpZW50UmVjdChnZXREb2N1bWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKSk7XG59IC8vIEEgXCJjbGlwcGluZyBwYXJlbnRcIiBpcyBhbiBvdmVyZmxvd2FibGUgY29udGFpbmVyIHdpdGggdGhlIGNoYXJhY3RlcmlzdGljIG9mXG4vLyBjbGlwcGluZyAob3IgaGlkaW5nKSBvdmVyZmxvd2luZyBlbGVtZW50cyB3aXRoIGEgcG9zaXRpb24gZGlmZmVyZW50IGZyb21cbi8vIGBpbml0aWFsYFxuXG5cbmZ1bmN0aW9uIGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50KSB7XG4gIHZhciBjbGlwcGluZ1BhcmVudHMgPSBsaXN0U2Nyb2xsUGFyZW50cyhlbGVtZW50KTtcbiAgdmFyIGNhbkVzY2FwZUNsaXBwaW5nID0gWydhYnNvbHV0ZScsICdmaXhlZCddLmluZGV4T2YoZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbikgPj0gMDtcbiAgdmFyIGNsaXBwZXJFbGVtZW50ID0gY2FuRXNjYXBlQ2xpcHBpbmcgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSA/IGdldE9mZnNldFBhcmVudChlbGVtZW50KSA6IGVsZW1lbnQ7XG5cbiAgaWYgKCFpc0VsZW1lbnQoY2xpcHBlckVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9IC8vICRGbG93Rml4TWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8xNDE0XG5cblxuICByZXR1cm4gY2xpcHBpbmdQYXJlbnRzLmZpbHRlcihmdW5jdGlvbiAoY2xpcHBpbmdQYXJlbnQpIHtcbiAgICByZXR1cm4gaXNFbGVtZW50KGNsaXBwaW5nUGFyZW50KSAmJiBjb250YWlucyhjbGlwcGluZ1BhcmVudCwgY2xpcHBlckVsZW1lbnQpO1xuICB9KTtcbn0gLy8gR2V0cyB0aGUgbWF4aW11bSBhcmVhIHRoYXQgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBpbiBkdWUgdG8gYW55IG51bWJlciBvZlxuLy8gY2xpcHBpbmcgcGFyZW50c1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENsaXBwaW5nUmVjdChlbGVtZW50LCBib3VuZGFyeSwgcm9vdEJvdW5kYXJ5KSB7XG4gIHZhciBtYWluQ2xpcHBpbmdQYXJlbnRzID0gYm91bmRhcnkgPT09ICdjbGlwcGluZ1BhcmVudHMnID8gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsZW1lbnQpIDogW10uY29uY2F0KGJvdW5kYXJ5KTtcbiAgdmFyIGNsaXBwaW5nUGFyZW50cyA9IFtdLmNvbmNhdChtYWluQ2xpcHBpbmdQYXJlbnRzLCBbcm9vdEJvdW5kYXJ5XSk7XG4gIHZhciBmaXJzdENsaXBwaW5nUGFyZW50ID0gY2xpcHBpbmdQYXJlbnRzWzBdO1xuICB2YXIgY2xpcHBpbmdSZWN0ID0gY2xpcHBpbmdQYXJlbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjUmVjdCwgY2xpcHBpbmdQYXJlbnQpIHtcbiAgICB2YXIgcmVjdCA9IGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50KTtcbiAgICB2YXIgZGVjb3JhdGlvbnMgPSBnZXREZWNvcmF0aW9ucyhpc0hUTUxFbGVtZW50KGNsaXBwaW5nUGFyZW50KSA/IGNsaXBwaW5nUGFyZW50IDogZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKTtcbiAgICBhY2NSZWN0LnRvcCA9IE1hdGgubWF4KHJlY3QudG9wICsgZGVjb3JhdGlvbnMudG9wLCBhY2NSZWN0LnRvcCk7XG4gICAgYWNjUmVjdC5yaWdodCA9IE1hdGgubWluKHJlY3QucmlnaHQgLSBkZWNvcmF0aW9ucy5yaWdodCwgYWNjUmVjdC5yaWdodCk7XG4gICAgYWNjUmVjdC5ib3R0b20gPSBNYXRoLm1pbihyZWN0LmJvdHRvbSAtIGRlY29yYXRpb25zLmJvdHRvbSwgYWNjUmVjdC5ib3R0b20pO1xuICAgIGFjY1JlY3QubGVmdCA9IE1hdGgubWF4KHJlY3QubGVmdCArIGRlY29yYXRpb25zLmxlZnQsIGFjY1JlY3QubGVmdCk7XG4gICAgcmV0dXJuIGFjY1JlY3Q7XG4gIH0sIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGZpcnN0Q2xpcHBpbmdQYXJlbnQpKTtcbiAgY2xpcHBpbmdSZWN0LndpZHRoID0gY2xpcHBpbmdSZWN0LnJpZ2h0IC0gY2xpcHBpbmdSZWN0LmxlZnQ7XG4gIGNsaXBwaW5nUmVjdC5oZWlnaHQgPSBjbGlwcGluZ1JlY3QuYm90dG9tIC0gY2xpcHBpbmdSZWN0LnRvcDtcbiAgY2xpcHBpbmdSZWN0LnggPSBjbGlwcGluZ1JlY3QubGVmdDtcbiAgY2xpcHBpbmdSZWN0LnkgPSBjbGlwcGluZ1JlY3QudG9wO1xuICByZXR1cm4gY2xpcHBpbmdSZWN0O1xufSIsImltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZVNjcm9sbCBmcm9tIFwiLi9nZXROb2RlU2Nyb2xsLmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGlzU2Nyb2xsUGFyZW50IGZyb20gXCIuL2lzU2Nyb2xsUGFyZW50LmpzXCI7IC8vIFJldHVybnMgdGhlIGNvbXBvc2l0ZSByZWN0IG9mIGFuIGVsZW1lbnQgcmVsYXRpdmUgdG8gaXRzIG9mZnNldFBhcmVudC5cbi8vIENvbXBvc2l0ZSBtZWFucyBpdCB0YWtlcyBpbnRvIGFjY291bnQgdHJhbnNmb3JtcyBhcyB3ZWxsIGFzIGxheW91dC5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Q29tcG9zaXRlUmVjdChlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCwgb2Zmc2V0UGFyZW50LCBpc0ZpeGVkKSB7XG4gIGlmIChpc0ZpeGVkID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkID0gZmFsc2U7XG4gIH1cblxuICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIHZhciByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnRPclZpcnR1YWxFbGVtZW50KTtcbiAgdmFyIHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICB2YXIgb2Zmc2V0cyA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcblxuICBpZiAoIWlzRml4ZWQpIHtcbiAgICBpZiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSAhPT0gJ2JvZHknIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTA3OFxuICAgIGlzU2Nyb2xsUGFyZW50KGRvY3VtZW50RWxlbWVudCkpIHtcbiAgICAgIHNjcm9sbCA9IGdldE5vZGVTY3JvbGwob2Zmc2V0UGFyZW50KTtcbiAgICB9XG5cbiAgICBpZiAoaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICBvZmZzZXRzID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCk7XG4gICAgICBvZmZzZXRzLnggKz0gb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XG4gICAgICBvZmZzZXRzLnkgKz0gb2Zmc2V0UGFyZW50LmNsaWVudFRvcDtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50RWxlbWVudCkge1xuICAgICAgb2Zmc2V0cy54ID0gZ2V0V2luZG93U2Nyb2xsQmFyWChkb2N1bWVudEVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogcmVjdC5sZWZ0ICsgc2Nyb2xsLnNjcm9sbExlZnQgLSBvZmZzZXRzLngsXG4gICAgeTogcmVjdC50b3AgKyBzY3JvbGwuc2Nyb2xsVG9wIC0gb2Zmc2V0cy55LFxuICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgfTtcbn0iLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSB7XG4gIHJldHVybiBnZXRXaW5kb3coZWxlbWVudCkuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn0iLCJpbXBvcnQgZ2V0Qm9yZGVycyBmcm9tIFwiLi9nZXRCb3JkZXJzLmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzXCI7IC8vIEJvcmRlcnMgKyBzY3JvbGxiYXJzXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldERlY29yYXRpb25zKGVsZW1lbnQpIHtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgdmFyIGJvcmRlcnMgPSBnZXRCb3JkZXJzKGVsZW1lbnQpO1xuICB2YXIgaXNIVE1MID0gZ2V0Tm9kZU5hbWUoZWxlbWVudCkgPT09ICdodG1sJztcbiAgdmFyIHdpblNjcm9sbEJhclggPSBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpO1xuICB2YXIgeCA9IGVsZW1lbnQuY2xpZW50V2lkdGggKyBib3JkZXJzLnJpZ2h0O1xuICB2YXIgeSA9IGVsZW1lbnQuY2xpZW50SGVpZ2h0ICsgYm9yZGVycy5ib3R0b207IC8vIEhBQ0s6XG4gIC8vIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgb24gaU9TIHJlcG9ydHMgdGhlIGhlaWdodCBvZiB0aGVcbiAgLy8gdmlld3BvcnQgaW5jbHVkaW5nIHRoZSBib3R0b20gYmFyLCBldmVuIGlmIHRoZSBib3R0b20gYmFyIGlzbid0IHZpc2libGUuXG4gIC8vIElmIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gd2luZG93IGlubmVySGVpZ2h0IGFuZCBodG1sIGNsaWVudEhlaWdodCBpcyBtb3JlXG4gIC8vIHRoYW4gNTAsIHdlIGFzc3VtZSBpdCdzIGEgbW9iaWxlIGJvdHRvbSBiYXIgYW5kIGlnbm9yZSBzY3JvbGxiYXJzLlxuICAvLyAqIEEgNTBweCB0aGljayBzY3JvbGxiYXIgaXMgbGlrZWx5IG5vbi1leGlzdGVudCAobWFjT1MgaXMgMTVweCBhbmQgV2luZG93c1xuICAvLyAgIGlzIGFib3V0IDE3cHgpXG4gIC8vICogVGhlIG1vYmlsZSBiYXIgaXMgMTE0cHggdGFsbFxuXG4gIGlmIChpc0hUTUwgJiYgd2luLmlubmVySGVpZ2h0IC0gZWxlbWVudC5jbGllbnRIZWlnaHQgPiA1MCkge1xuICAgIHkgPSB3aW4uaW5uZXJIZWlnaHQgLSBib3JkZXJzLmJvdHRvbTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG9wOiBpc0hUTUwgPyAwIDogZWxlbWVudC5jbGllbnRUb3AsXG4gICAgcmlnaHQ6IC8vIFJUTCBzY3JvbGxiYXIgKHNjcm9sbGluZyBjb250YWluZXJzIG9ubHkpXG4gICAgZWxlbWVudC5jbGllbnRMZWZ0ID4gYm9yZGVycy5sZWZ0ID8gYm9yZGVycy5yaWdodCA6IC8vIExUUiBzY3JvbGxiYXJcbiAgICBpc0hUTUwgPyB3aW4uaW5uZXJXaWR0aCAtIHggLSB3aW5TY3JvbGxCYXJYIDogZWxlbWVudC5vZmZzZXRXaWR0aCAtIHgsXG4gICAgYm90dG9tOiBpc0hUTUwgPyB3aW4uaW5uZXJIZWlnaHQgLSB5IDogZWxlbWVudC5vZmZzZXRIZWlnaHQgLSB5LFxuICAgIGxlZnQ6IGlzSFRNTCA/IHdpblNjcm9sbEJhclggOiBlbGVtZW50LmNsaWVudExlZnRcbiAgfTtcbn0iLCJpbXBvcnQgeyBpc0VsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkge1xuICAvLyAkRmxvd0ZpeE1lOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gIHJldHVybiAoaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudC5vd25lckRvY3VtZW50IDogZWxlbWVudC5kb2N1bWVudCkuZG9jdW1lbnRFbGVtZW50O1xufSIsImltcG9ydCBnZXRDb21wb3NpdGVSZWN0IGZyb20gXCIuL2dldENvbXBvc2l0ZVJlY3QuanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGwuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldERvY3VtZW50UmVjdChlbGVtZW50KSB7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIHZhciB3aW5TY3JvbGwgPSBnZXRXaW5kb3dTY3JvbGwoZWxlbWVudCk7XG4gIHZhciBkb2N1bWVudFJlY3QgPSBnZXRDb21wb3NpdGVSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSwgd2luKTtcbiAgZG9jdW1lbnRSZWN0LmhlaWdodCA9IE1hdGgubWF4KGRvY3VtZW50UmVjdC5oZWlnaHQsIHdpbi5pbm5lckhlaWdodCk7XG4gIGRvY3VtZW50UmVjdC53aWR0aCA9IE1hdGgubWF4KGRvY3VtZW50UmVjdC53aWR0aCwgd2luLmlubmVyV2lkdGgpO1xuICBkb2N1bWVudFJlY3QueCA9IC13aW5TY3JvbGwuc2Nyb2xsTGVmdDtcbiAgZG9jdW1lbnRSZWN0LnkgPSAtd2luU2Nyb2xsLnNjcm9sbFRvcDtcbiAgcmV0dXJuIGRvY3VtZW50UmVjdDtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRIVE1MRWxlbWVudFNjcm9sbChlbGVtZW50KSB7XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogZWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgIHNjcm9sbFRvcDogZWxlbWVudC5zY3JvbGxUb3BcbiAgfTtcbn0iLCIvLyBSZXR1cm5zIHRoZSBsYXlvdXQgcmVjdCBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIGl0cyBvZmZzZXRQYXJlbnQuIExheW91dFxuLy8gbWVhbnMgaXQgZG9lc24ndCB0YWtlIGludG8gYWNjb3VudCB0cmFuc2Zvcm1zLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0TGF5b3V0UmVjdChlbGVtZW50KSB7XG4gIHJldHVybiB7XG4gICAgeDogZWxlbWVudC5vZmZzZXRMZWZ0LFxuICAgIHk6IGVsZW1lbnQub2Zmc2V0VG9wLFxuICAgIHdpZHRoOiBlbGVtZW50Lm9mZnNldFdpZHRoLFxuICAgIGhlaWdodDogZWxlbWVudC5vZmZzZXRIZWlnaHRcbiAgfTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXROb2RlTmFtZShlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50ID8gKGVsZW1lbnQubm9kZU5hbWUgfHwgJycpLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xufSIsImltcG9ydCBnZXRXaW5kb3dTY3JvbGwgZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBnZXRIVE1MRWxlbWVudFNjcm9sbCBmcm9tIFwiLi9nZXRIVE1MRWxlbWVudFNjcm9sbC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Tm9kZVNjcm9sbChub2RlKSB7XG4gIGlmIChub2RlID09PSBnZXRXaW5kb3cobm9kZSkgfHwgIWlzSFRNTEVsZW1lbnQobm9kZSkpIHtcbiAgICByZXR1cm4gZ2V0V2luZG93U2Nyb2xsKG5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZXRIVE1MRWxlbWVudFNjcm9sbChub2RlKTtcbiAgfVxufSIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgaXNUYWJsZUVsZW1lbnQgZnJvbSBcIi4vaXNUYWJsZUVsZW1lbnQuanNcIjtcblxuZnVuY3Rpb24gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzgzN1xuICBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIHZhciB3aW5kb3cgPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQpOyAvLyBGaW5kIHRoZSBuZWFyZXN0IG5vbi10YWJsZSBvZmZzZXRQYXJlbnRcblxuICB3aGlsZSAob2Zmc2V0UGFyZW50ICYmIGlzVGFibGVFbGVtZW50KG9mZnNldFBhcmVudCkpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCk7XG4gIH1cblxuICBpZiAob2Zmc2V0UGFyZW50ICYmIGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdib2R5JyAmJiBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRQYXJlbnQgfHwgd2luZG93O1xufSIsImltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFBhcmVudE5vZGUoZWxlbWVudCkge1xuICBpZiAoZ2V0Tm9kZU5hbWUoZWxlbWVudCkgPT09ICdodG1sJykge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgcmV0dXJuICgvLyAkRmxvd0ZpeE1lOiB0aGlzIGlzIGEgcXVpY2tlciAoYnV0IGxlc3MgdHlwZSBzYWZlKSB3YXkgdG8gc2F2ZSBxdWl0ZSBzb21lIGJ5dGVzIGZyb20gdGhlIGJ1bmRsZVxuICAgIGVsZW1lbnQuYXNzaWduZWRTbG90IHx8IC8vIHN0ZXAgaW50byB0aGUgc2hhZG93IERPTSBvZiB0aGUgcGFyZW50IG9mIGEgc2xvdHRlZCBub2RlXG4gICAgZWxlbWVudC5wYXJlbnROb2RlIHx8IC8vIERPTSBFbGVtZW50IGRldGVjdGVkXG4gICAgLy8gJEZsb3dGaXhNZTogbmVlZCBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXMuLi5cbiAgICBlbGVtZW50Lmhvc3QgfHwgLy8gU2hhZG93Um9vdCBkZXRlY3RlZFxuICAgIC8vICRGbG93Rml4TWU6IEhUTUxFbGVtZW50IGlzIGEgTm9kZVxuICAgIGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSAvLyBmYWxsYmFja1xuXG4gICk7XG59IiwiaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSBcIi4vZ2V0UGFyZW50Tm9kZS5qc1wiO1xuaW1wb3J0IGlzU2Nyb2xsUGFyZW50IGZyb20gXCIuL2lzU2Nyb2xsUGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRTY3JvbGxQYXJlbnQobm9kZSkge1xuICBpZiAoWydodG1sJywgJ2JvZHknLCAnI2RvY3VtZW50J10uaW5kZXhPZihnZXROb2RlTmFtZShub2RlKSkgPj0gMCkge1xuICAgIC8vICRGbG93Rml4TWU6IGFzc3VtZSBib2R5IGlzIGFsd2F5cyBhdmFpbGFibGVcbiAgICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50LmJvZHk7XG4gIH1cblxuICBpZiAoaXNIVE1MRWxlbWVudChub2RlKSAmJiBpc1Njcm9sbFBhcmVudChub2RlKSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcmV0dXJuIGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKG5vZGUpKTtcbn0iLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgdmFyIHZpc3VhbFZpZXdwb3J0ID0gd2luLnZpc3VhbFZpZXdwb3J0O1xuICB2YXIgd2lkdGggPSB3aW4uaW5uZXJXaWR0aDtcbiAgdmFyIGhlaWdodCA9IHdpbi5pbm5lckhlaWdodDsgLy8gV2UgZG9uJ3Qga25vdyB3aGljaCBicm93c2VycyBoYXZlIGJ1Z2d5IG9yIG9kZCBpbXBsZW1lbnRhdGlvbnMgb2YgdGhpcywgc29cbiAgLy8gZm9yIG5vdyB3ZSdyZSBvbmx5IGFwcGx5aW5nIGl0IHRvIGlPUyB0byBmaXggdGhlIGtleWJvYXJkIGlzc3VlLlxuICAvLyBJbnZlc3RpZ2F0aW9uIHJlcXVpcmVkXG5cbiAgaWYgKHZpc3VhbFZpZXdwb3J0ICYmIC9pUGhvbmV8aVBvZHxpUGFkLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSkpIHtcbiAgICB3aWR0aCA9IHZpc3VhbFZpZXdwb3J0LndpZHRoO1xuICAgIGhlaWdodCA9IHZpc3VhbFZpZXdwb3J0LmhlaWdodDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xufSIsIi8qOjogaW1wb3J0IHR5cGUgeyBXaW5kb3cgfSBmcm9tICcuLi90eXBlcyc7ICovXG5cbi8qOjogZGVjbGFyZSBmdW5jdGlvbiBnZXRXaW5kb3cobm9kZTogTm9kZSB8IFdpbmRvdyk6IFdpbmRvdzsgKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFdpbmRvdyhub2RlKSB7XG4gIGlmIChub2RlLnRvU3RyaW5nKCkgIT09ICdbb2JqZWN0IFdpbmRvd10nKSB7XG4gICAgdmFyIG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgcmV0dXJuIG93bmVyRG9jdW1lbnQgPyBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IDogd2luZG93O1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59IiwiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbChub2RlKSB7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3cobm9kZSk7XG4gIHZhciBzY3JvbGxMZWZ0ID0gd2luLnBhZ2VYT2Zmc2V0O1xuICB2YXIgc2Nyb2xsVG9wID0gd2luLnBhZ2VZT2Zmc2V0O1xuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IHNjcm9sbExlZnQsXG4gICAgc2Nyb2xsVG9wOiBzY3JvbGxUb3BcbiAgfTtcbn0iLCJpbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGwgZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpIHtcbiAgLy8gSWYgPGh0bWw+IGhhcyBhIENTUyB3aWR0aCBncmVhdGVyIHRoYW4gdGhlIHZpZXdwb3J0LCB0aGVuIHRoaXMgd2lsbCBiZVxuICAvLyBpbmNvcnJlY3QgZm9yIFJUTC5cbiAgLy8gUG9wcGVyIDEgaXMgYnJva2VuIGluIHRoaXMgY2FzZSBhbmQgbmV2ZXIgaGFkIGEgYnVnIHJlcG9ydCBzbyBsZXQncyBhc3N1bWVcbiAgLy8gaXQncyBub3QgYW4gaXNzdWUuIEkgZG9uJ3QgdGhpbmsgYW55b25lIGV2ZXIgc3BlY2lmaWVzIHdpZHRoIG9uIDxodG1sPlxuICAvLyBhbnl3YXkuXG4gIC8vIEJyb3dzZXJzIHdoZXJlIHRoZSBsZWZ0IHNjcm9sbGJhciBkb2Vzbid0IGNhdXNlIGFuIGlzc3VlIHJlcG9ydCBgMGAgZm9yXG4gIC8vIHRoaXMgKGUuZy4gRWRnZSAyMDE5LCBJRTExLCBTYWZhcmkpXG4gIHJldHVybiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKS5sZWZ0ICsgZ2V0V2luZG93U2Nyb2xsKGVsZW1lbnQpLnNjcm9sbExlZnQ7XG59IiwiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbi8qOjogZGVjbGFyZSBmdW5jdGlvbiBpc0VsZW1lbnQobm9kZTogbWl4ZWQpOiBib29sZWFuICVjaGVja3Mobm9kZSBpbnN0YW5jZW9mXG4gIEVsZW1lbnQpOyAqL1xuXG5mdW5jdGlvbiBpc0VsZW1lbnQobm9kZSkge1xuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5FbGVtZW50O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQ7XG59XG4vKjo6IGRlY2xhcmUgZnVuY3Rpb24gaXNIVE1MRWxlbWVudChub2RlOiBtaXhlZCk6IGJvb2xlYW4gJWNoZWNrcyhub2RlIGluc3RhbmNlb2ZcbiAgSFRNTEVsZW1lbnQpOyAqL1xuXG5cbmZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQobm9kZSkge1xuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5IVE1MRWxlbWVudDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbn1cblxuZXhwb3J0IHsgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50IH07IiwiaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNTY3JvbGxQYXJlbnQoZWxlbWVudCkge1xuICAvLyBGaXJlZm94IHdhbnRzIHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG4gIHZhciBfZ2V0Q29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCksXG4gICAgICBvdmVyZmxvdyA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93LFxuICAgICAgb3ZlcmZsb3dYID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dYLFxuICAgICAgb3ZlcmZsb3dZID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dZO1xuXG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW4vLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpO1xufSIsImltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNUYWJsZUVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gWyd0YWJsZScsICd0ZCcsICd0aCddLmluZGV4T2YoZ2V0Tm9kZU5hbWUoZWxlbWVudCkpID49IDA7XG59IiwiaW1wb3J0IGdldFNjcm9sbFBhcmVudCBmcm9tIFwiLi9nZXRTY3JvbGxQYXJlbnQuanNcIjtcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCBpc1Njcm9sbFBhcmVudCBmcm9tIFwiLi9pc1Njcm9sbFBhcmVudC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGlzdFNjcm9sbFBhcmVudHMoZWxlbWVudCwgbGlzdCkge1xuICBpZiAobGlzdCA9PT0gdm9pZCAwKSB7XG4gICAgbGlzdCA9IFtdO1xuICB9XG5cbiAgdmFyIHNjcm9sbFBhcmVudCA9IGdldFNjcm9sbFBhcmVudChlbGVtZW50KTtcbiAgdmFyIGlzQm9keSA9IGdldE5vZGVOYW1lKHNjcm9sbFBhcmVudCkgPT09ICdib2R5JztcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhzY3JvbGxQYXJlbnQpO1xuICB2YXIgdGFyZ2V0ID0gaXNCb2R5ID8gW3dpbl0uY29uY2F0KHdpbi52aXN1YWxWaWV3cG9ydCB8fCBbXSwgaXNTY3JvbGxQYXJlbnQoc2Nyb2xsUGFyZW50KSA/IHNjcm9sbFBhcmVudCA6IFtdKSA6IHNjcm9sbFBhcmVudDtcbiAgdmFyIHVwZGF0ZWRMaXN0ID0gbGlzdC5jb25jYXQodGFyZ2V0KTtcbiAgcmV0dXJuIGlzQm9keSA/IHVwZGF0ZWRMaXN0IDogLy8gJEZsb3dGaXhNZTogaXNCb2R5IHRlbGxzIHVzIHRhcmdldCB3aWxsIGJlIGFuIEhUTUxFbGVtZW50IGhlcmVcbiAgdXBkYXRlZExpc3QuY29uY2F0KGxpc3RTY3JvbGxQYXJlbnRzKGdldFBhcmVudE5vZGUodGFyZ2V0KSkpO1xufSIsImV4cG9ydCB2YXIgdG9wID0gJ3RvcCc7XG5leHBvcnQgdmFyIGJvdHRvbSA9ICdib3R0b20nO1xuZXhwb3J0IHZhciByaWdodCA9ICdyaWdodCc7XG5leHBvcnQgdmFyIGxlZnQgPSAnbGVmdCc7XG5leHBvcnQgdmFyIGF1dG8gPSAnYXV0byc7XG5leHBvcnQgdmFyIGJhc2VQbGFjZW1lbnRzID0gW3RvcCwgYm90dG9tLCByaWdodCwgbGVmdF07XG5leHBvcnQgdmFyIHN0YXJ0ID0gJ3N0YXJ0JztcbmV4cG9ydCB2YXIgZW5kID0gJ2VuZCc7XG5leHBvcnQgdmFyIGNsaXBwaW5nUGFyZW50cyA9ICdjbGlwcGluZ1BhcmVudHMnO1xuZXhwb3J0IHZhciB2aWV3cG9ydCA9ICd2aWV3cG9ydCc7XG5leHBvcnQgdmFyIHBvcHBlciA9ICdwb3BwZXInO1xuZXhwb3J0IHZhciByZWZlcmVuY2UgPSAncmVmZXJlbmNlJztcbmV4cG9ydCB2YXIgdmFyaWF0aW9uUGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9iYXNlUGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gIHJldHVybiBhY2MuY29uY2F0KFtwbGFjZW1lbnQgKyBcIi1cIiArIHN0YXJ0LCBwbGFjZW1lbnQgKyBcIi1cIiArIGVuZF0pO1xufSwgW10pO1xuZXhwb3J0IHZhciBwbGFjZW1lbnRzID0gLyojX19QVVJFX18qL1tdLmNvbmNhdChiYXNlUGxhY2VtZW50cywgW2F1dG9dKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gIHJldHVybiBhY2MuY29uY2F0KFtwbGFjZW1lbnQsIHBsYWNlbWVudCArIFwiLVwiICsgc3RhcnQsIHBsYWNlbWVudCArIFwiLVwiICsgZW5kXSk7XG59LCBbXSk7IC8vIG1vZGlmaWVycyB0aGF0IG5lZWQgdG8gcmVhZCB0aGUgRE9NXG5cbmV4cG9ydCB2YXIgYmVmb3JlUmVhZCA9ICdiZWZvcmVSZWFkJztcbmV4cG9ydCB2YXIgcmVhZCA9ICdyZWFkJztcbmV4cG9ydCB2YXIgYWZ0ZXJSZWFkID0gJ2FmdGVyUmVhZCc7IC8vIHB1cmUtbG9naWMgbW9kaWZpZXJzXG5cbmV4cG9ydCB2YXIgYmVmb3JlTWFpbiA9ICdiZWZvcmVNYWluJztcbmV4cG9ydCB2YXIgbWFpbiA9ICdtYWluJztcbmV4cG9ydCB2YXIgYWZ0ZXJNYWluID0gJ2FmdGVyTWFpbic7IC8vIG1vZGlmaWVyIHdpdGggdGhlIHB1cnBvc2UgdG8gd3JpdGUgdG8gdGhlIERPTSAob3Igd3JpdGUgaW50byBhIGZyYW1ld29yayBzdGF0ZSlcblxuZXhwb3J0IHZhciBiZWZvcmVXcml0ZSA9ICdiZWZvcmVXcml0ZSc7XG5leHBvcnQgdmFyIHdyaXRlID0gJ3dyaXRlJztcbmV4cG9ydCB2YXIgYWZ0ZXJXcml0ZSA9ICdhZnRlcldyaXRlJztcbmV4cG9ydCB2YXIgbW9kaWZpZXJQaGFzZXMgPSBbYmVmb3JlUmVhZCwgcmVhZCwgYWZ0ZXJSZWFkLCBiZWZvcmVNYWluLCBtYWluLCBhZnRlck1haW4sIGJlZm9yZVdyaXRlLCB3cml0ZSwgYWZ0ZXJXcml0ZV07IiwiaW1wb3J0IGdldENvbXBvc2l0ZVJlY3QgZnJvbSBcIi4vZG9tLXV0aWxzL2dldENvbXBvc2l0ZVJlY3QuanNcIjtcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gXCIuL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzXCI7XG5pbXBvcnQgbGlzdFNjcm9sbFBhcmVudHMgZnJvbSBcIi4vZG9tLXV0aWxzL2xpc3RTY3JvbGxQYXJlbnRzLmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2RvbS11dGlscy9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgb3JkZXJNb2RpZmllcnMgZnJvbSBcIi4vdXRpbHMvb3JkZXJNb2RpZmllcnMuanNcIjtcbmltcG9ydCBkZWJvdW5jZSBmcm9tIFwiLi91dGlscy9kZWJvdW5jZS5qc1wiO1xuaW1wb3J0IHZhbGlkYXRlTW9kaWZpZXJzIGZyb20gXCIuL3V0aWxzL3ZhbGlkYXRlTW9kaWZpZXJzLmpzXCI7XG5pbXBvcnQgdW5pcXVlQnkgZnJvbSBcIi4vdXRpbHMvdW5pcXVlQnkuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBtZXJnZUJ5TmFtZSBmcm9tIFwiLi91dGlscy9tZXJnZUJ5TmFtZS5qc1wiO1xuaW1wb3J0IHsgaXNFbGVtZW50IH0gZnJvbSBcIi4vZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCB7IGF1dG8gfSBmcm9tIFwiLi9lbnVtcy5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vZW51bXMuanNcIjtcbnZhciBJTlZBTElEX0VMRU1FTlRfRVJST1IgPSAnUG9wcGVyOiBJbnZhbGlkIHJlZmVyZW5jZSBvciBwb3BwZXIgYXJndW1lbnQgcHJvdmlkZWQuIFRoZXkgbXVzdCBiZSBlaXRoZXIgYSBET00gZWxlbWVudCBvciB2aXJ0dWFsIGVsZW1lbnQuJztcbnZhciBJTkZJTklURV9MT09QX0VSUk9SID0gJ1BvcHBlcjogQW4gaW5maW5pdGUgbG9vcCBpbiB0aGUgbW9kaWZpZXJzIGN5Y2xlIGhhcyBiZWVuIGRldGVjdGVkISBUaGUgY3ljbGUgaGFzIGJlZW4gaW50ZXJydXB0ZWQgdG8gcHJldmVudCBhIGJyb3dzZXIgY3Jhc2guJztcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gIG1vZGlmaWVyczogW10sXG4gIHN0cmF0ZWd5OiAnYWJzb2x1dGUnXG59O1xuXG5mdW5jdGlvbiBhcmVWYWxpZEVsZW1lbnRzKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuICFhcmdzLnNvbWUoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gIShlbGVtZW50ICYmIHR5cGVvZiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCA9PT0gJ2Z1bmN0aW9uJyk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9wcGVyR2VuZXJhdG9yKGdlbmVyYXRvck9wdGlvbnMpIHtcbiAgaWYgKGdlbmVyYXRvck9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIGdlbmVyYXRvck9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfZ2VuZXJhdG9yT3B0aW9ucyA9IGdlbmVyYXRvck9wdGlvbnMsXG4gICAgICBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYgPSBfZ2VuZXJhdG9yT3B0aW9ucy5kZWZhdWx0TW9kaWZpZXJzLFxuICAgICAgZGVmYXVsdE1vZGlmaWVycyA9IF9nZW5lcmF0b3JPcHRpb25zJGRlZiA9PT0gdm9pZCAwID8gW10gOiBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYsXG4gICAgICBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyID0gX2dlbmVyYXRvck9wdGlvbnMuZGVmYXVsdE9wdGlvbnMsXG4gICAgICBkZWZhdWx0T3B0aW9ucyA9IF9nZW5lcmF0b3JPcHRpb25zJGRlZjIgPT09IHZvaWQgMCA/IERFRkFVTFRfT1BUSU9OUyA6IF9nZW5lcmF0b3JPcHRpb25zJGRlZjI7XG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVQb3BwZXIocmVmZXJlbmNlLCBwb3BwZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgcGxhY2VtZW50OiAnYm90dG9tJyxcbiAgICAgIG9yZGVyZWRNb2RpZmllcnM6IFtdLFxuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCB7fSwgZGVmYXVsdE9wdGlvbnMpLFxuICAgICAgbW9kaWZpZXJzRGF0YToge30sXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICByZWZlcmVuY2U6IHJlZmVyZW5jZSxcbiAgICAgICAgcG9wcGVyOiBwb3BwZXJcbiAgICAgIH0sXG4gICAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICAgIHN0eWxlczoge31cbiAgICB9O1xuICAgIHZhciBlZmZlY3RDbGVhbnVwRm5zID0gW107XG4gICAgdmFyIGlzRGVzdHJveWVkID0gZmFsc2U7XG4gICAgdmFyIGluc3RhbmNlID0ge1xuICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgc2V0T3B0aW9uczogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgc3RhdGUub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCB7fSwgc3RhdGUub3B0aW9ucywge30sIG9wdGlvbnMpO1xuICAgICAgICBzdGF0ZS5zY3JvbGxQYXJlbnRzID0ge1xuICAgICAgICAgIHJlZmVyZW5jZTogaXNFbGVtZW50KHJlZmVyZW5jZSkgPyBsaXN0U2Nyb2xsUGFyZW50cyhyZWZlcmVuY2UpIDogcmVmZXJlbmNlLmNvbnRleHRFbGVtZW50ID8gbGlzdFNjcm9sbFBhcmVudHMocmVmZXJlbmNlLmNvbnRleHRFbGVtZW50KSA6IFtdLFxuICAgICAgICAgIHBvcHBlcjogbGlzdFNjcm9sbFBhcmVudHMocG9wcGVyKVxuICAgICAgICB9OyAvLyBPcmRlcnMgdGhlIG1vZGlmaWVycyBiYXNlZCBvbiB0aGVpciBkZXBlbmRlbmNpZXMgYW5kIGBwaGFzZWBcbiAgICAgICAgLy8gcHJvcGVydGllc1xuXG4gICAgICAgIHZhciBvcmRlcmVkTW9kaWZpZXJzID0gb3JkZXJNb2RpZmllcnMobWVyZ2VCeU5hbWUoW10uY29uY2F0KGRlZmF1bHRNb2RpZmllcnMsIHN0YXRlLm9wdGlvbnMubW9kaWZpZXJzKSkpOyAvLyBTdHJpcCBvdXQgZGlzYWJsZWQgbW9kaWZpZXJzXG5cbiAgICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyZWRNb2RpZmllcnMuZmlsdGVyKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgcmV0dXJuIG0uZW5hYmxlZDtcbiAgICAgICAgfSk7IC8vIFZhbGlkYXRlIHRoZSBwcm92aWRlZCBtb2RpZmllcnMgc28gdGhhdCB0aGUgY29uc3VtZXIgd2lsbCBnZXQgd2FybmVkXG4gICAgICAgIC8vIGlmIG9uZSBvZiB0aGUgbW9kaWZpZXJzIGlzIGludmFsaWQgZm9yIGFueSByZWFzb25cblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgdmFyIG1vZGlmaWVycyA9IHVuaXF1ZUJ5KFtdLmNvbmNhdChvcmRlcmVkTW9kaWZpZXJzLCBzdGF0ZS5vcHRpb25zLm1vZGlmaWVycyksIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IF9yZWYubmFtZTtcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhbGlkYXRlTW9kaWZpZXJzKG1vZGlmaWVycyk7XG5cbiAgICAgICAgICBpZiAoZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5vcHRpb25zLnBsYWNlbWVudCkgPT09IGF1dG8pIHtcbiAgICAgICAgICAgIHZhciBmbGlwTW9kaWZpZXIgPSBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZpbmQoZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgICAgICAgIHZhciBuYW1lID0gX3JlZjIubmFtZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5hbWUgPT09ICdmbGlwJztcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIWZsaXBNb2RpZmllcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFsnUG9wcGVyOiBcImF1dG9cIiBwbGFjZW1lbnRzIHJlcXVpcmUgdGhlIFwiZmxpcFwiIG1vZGlmaWVyIGJlJywgJ3ByZXNlbnQgYW5kIGVuYWJsZWQgdG8gd29yay4nXS5qb2luKCcgJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfZ2V0Q29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUocG9wcGVyKSxcbiAgICAgICAgICAgICAgbWFyZ2luVG9wID0gX2dldENvbXB1dGVkU3R5bGUubWFyZ2luVG9wLFxuICAgICAgICAgICAgICBtYXJnaW5SaWdodCA9IF9nZXRDb21wdXRlZFN0eWxlLm1hcmdpblJpZ2h0LFxuICAgICAgICAgICAgICBtYXJnaW5Cb3R0b20gPSBfZ2V0Q29tcHV0ZWRTdHlsZS5tYXJnaW5Cb3R0b20sXG4gICAgICAgICAgICAgIG1hcmdpbkxlZnQgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5tYXJnaW5MZWZ0OyAvLyBXZSBubyBsb25nZXIgdGFrZSBpbnRvIGFjY291bnQgYG1hcmdpbnNgIG9uIHRoZSBwb3BwZXIsIGFuZCBpdCBjYW5cbiAgICAgICAgICAvLyBjYXVzZSBidWdzIHdpdGggcG9zaXRpb25pbmcsIHNvIHdlJ2xsIHdhcm4gdGhlIGNvbnN1bWVyXG5cblxuICAgICAgICAgIGlmIChbbWFyZ2luVG9wLCBtYXJnaW5SaWdodCwgbWFyZ2luQm90dG9tLCBtYXJnaW5MZWZ0XS5zb21lKGZ1bmN0aW9uIChtYXJnaW4pIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KG1hcmdpbik7XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihbJ1BvcHBlcjogQ1NTIFwibWFyZ2luXCIgc3R5bGVzIGNhbm5vdCBiZSB1c2VkIHRvIGFwcGx5IHBhZGRpbmcnLCAnYmV0d2VlbiB0aGUgcG9wcGVyIGFuZCBpdHMgcmVmZXJlbmNlIGVsZW1lbnQgb3IgYm91bmRhcnkuJywgJ1RvIHJlcGxpY2F0ZSBtYXJnaW4sIHVzZSB0aGUgYG9mZnNldGAgbW9kaWZpZXIsIGFzIHdlbGwgYXMnLCAndGhlIGBwYWRkaW5nYCBvcHRpb24gaW4gdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIGFuZCBgZmxpcGAnLCAnbW9kaWZpZXJzLiddLmpvaW4oJyAnKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcnVuTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgIH0sXG4gICAgICAvLyBTeW5jIHVwZGF0ZSDigJMgaXQgd2lsbCBhbHdheXMgYmUgZXhlY3V0ZWQsIGV2ZW4gaWYgbm90IG5lY2Vzc2FyeS4gVGhpc1xuICAgICAgLy8gaXMgdXNlZnVsIGZvciBsb3cgZnJlcXVlbmN5IHVwZGF0ZXMgd2hlcmUgc3luYyBiZWhhdmlvciBzaW1wbGlmaWVzIHRoZVxuICAgICAgLy8gbG9naWMuXG4gICAgICAvLyBGb3IgaGlnaCBmcmVxdWVuY3kgdXBkYXRlcyAoZS5nLiBgcmVzaXplYCBhbmQgYHNjcm9sbGAgZXZlbnRzKSwgYWx3YXlzXG4gICAgICAvLyBwcmVmZXIgdGhlIGFzeW5jIFBvcHBlciN1cGRhdGUgbWV0aG9kXG4gICAgICBmb3JjZVVwZGF0ZTogZnVuY3Rpb24gZm9yY2VVcGRhdGUoKSB7XG4gICAgICAgIGlmIChpc0Rlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfc3RhdGUkZWxlbWVudHMgPSBzdGF0ZS5lbGVtZW50cyxcbiAgICAgICAgICAgIHJlZmVyZW5jZSA9IF9zdGF0ZSRlbGVtZW50cy5yZWZlcmVuY2UsXG4gICAgICAgICAgICBwb3BwZXIgPSBfc3RhdGUkZWxlbWVudHMucG9wcGVyOyAvLyBEb24ndCBwcm9jZWVkIGlmIGByZWZlcmVuY2VgIG9yIGBwb3BwZXJgIGFyZSBub3QgdmFsaWQgZWxlbWVudHNcbiAgICAgICAgLy8gYW55bW9yZVxuXG4gICAgICAgIGlmICghYXJlVmFsaWRFbGVtZW50cyhyZWZlcmVuY2UsIHBvcHBlcikpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKElOVkFMSURfRUxFTUVOVF9FUlJPUik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIFN0b3JlIHRoZSByZWZlcmVuY2UgYW5kIHBvcHBlciByZWN0cyB0byBiZSByZWFkIGJ5IG1vZGlmaWVyc1xuXG5cbiAgICAgICAgc3RhdGUucmVjdHMgPSB7XG4gICAgICAgICAgcmVmZXJlbmNlOiBnZXRDb21wb3NpdGVSZWN0KHJlZmVyZW5jZSwgZ2V0T2Zmc2V0UGFyZW50KHBvcHBlciksIHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3kgPT09ICdmaXhlZCcpLFxuICAgICAgICAgIHBvcHBlcjogZ2V0TGF5b3V0UmVjdChwb3BwZXIpXG4gICAgICAgIH07IC8vIE1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIHJlc2V0IHRoZSBjdXJyZW50IHVwZGF0ZSBjeWNsZS4gVGhlXG4gICAgICAgIC8vIG1vc3QgY29tbW9uIHVzZSBjYXNlIGZvciB0aGlzIGlzIHRoZSBgZmxpcGAgbW9kaWZpZXIgY2hhbmdpbmcgdGhlXG4gICAgICAgIC8vIHBsYWNlbWVudCwgd2hpY2ggdGhlbiBuZWVkcyB0byByZS1ydW4gYWxsIHRoZSBtb2RpZmllcnMsIGJlY2F1c2UgdGhlXG4gICAgICAgIC8vIGxvZ2ljIHdhcyBwcmV2aW91c2x5IHJhbiBmb3IgdGhlIHByZXZpb3VzIHBsYWNlbWVudCBhbmQgaXMgdGhlcmVmb3JlXG4gICAgICAgIC8vIHN0YWxlL2luY29ycmVjdFxuXG4gICAgICAgIHN0YXRlLnJlc2V0ID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLnBsYWNlbWVudCA9IHN0YXRlLm9wdGlvbnMucGxhY2VtZW50OyAvLyBPbiBlYWNoIHVwZGF0ZSBjeWNsZSwgdGhlIGBtb2RpZmllcnNEYXRhYCBwcm9wZXJ0eSBmb3IgZWFjaCBtb2RpZmllclxuICAgICAgICAvLyBpcyBmaWxsZWQgd2l0aCB0aGUgaW5pdGlhbCBkYXRhIHNwZWNpZmllZCBieSB0aGUgbW9kaWZpZXIuIFRoaXMgbWVhbnNcbiAgICAgICAgLy8gaXQgZG9lc24ndCBwZXJzaXN0IGFuZCBpcyBmcmVzaCBvbiBlYWNoIHVwZGF0ZS5cbiAgICAgICAgLy8gVG8gZW5zdXJlIHBlcnNpc3RlbnQgZGF0YSwgdXNlIGAke25hbWV9I3BlcnNpc3RlbnRgXG5cbiAgICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgICAgICAgIHJldHVybiBzdGF0ZS5tb2RpZmllcnNEYXRhW21vZGlmaWVyLm5hbWVdID0gT2JqZWN0LmFzc2lnbih7fSwgbW9kaWZpZXIuZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgX19kZWJ1Z19sb29wc19fID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBfX2RlYnVnX2xvb3BzX18gKz0gMTtcblxuICAgICAgICAgICAgaWYgKF9fZGVidWdfbG9vcHNfXyA+IDEwMCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKElORklOSVRFX0xPT1BfRVJST1IpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3RhdGUucmVzZXQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHN0YXRlLnJlc2V0ID0gZmFsc2U7XG4gICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9zdGF0ZSRvcmRlcmVkTW9kaWZpZSA9IHN0YXRlLm9yZGVyZWRNb2RpZmllcnNbaW5kZXhdLFxuICAgICAgICAgICAgICBmbiA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5mbixcbiAgICAgICAgICAgICAgX3N0YXRlJG9yZGVyZWRNb2RpZmllMiA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5vcHRpb25zLFxuICAgICAgICAgICAgICBfb3B0aW9ucyA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIgPT09IHZvaWQgMCA/IHt9IDogX3N0YXRlJG9yZGVyZWRNb2RpZmllMixcbiAgICAgICAgICAgICAgbmFtZSA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5uYW1lO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc3RhdGUgPSBmbih7XG4gICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgICAgb3B0aW9uczogX29wdGlvbnMsXG4gICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZVxuICAgICAgICAgICAgfSkgfHwgc3RhdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gQXN5bmMgYW5kIG9wdGltaXN0aWNhbGx5IG9wdGltaXplZCB1cGRhdGUg4oCTIGl0IHdpbGwgbm90IGJlIGV4ZWN1dGVkIGlmXG4gICAgICAvLyBub3QgbmVjZXNzYXJ5IChkZWJvdW5jZWQgdG8gcnVuIGF0IG1vc3Qgb25jZS1wZXItdGljaylcbiAgICAgIHVwZGF0ZTogZGVib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICBpbnN0YW5jZS5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgIHJlc29sdmUoc3RhdGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pLFxuICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpO1xuICAgICAgICBpc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmICghYXJlVmFsaWRFbGVtZW50cyhyZWZlcmVuY2UsIHBvcHBlcikpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihJTlZBTElEX0VMRU1FTlRfRVJST1IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgaWYgKCFpc0Rlc3Ryb3llZCAmJiBvcHRpb25zLm9uRmlyc3RVcGRhdGUpIHtcbiAgICAgICAgb3B0aW9ucy5vbkZpcnN0VXBkYXRlKHN0YXRlKTtcbiAgICAgIH1cbiAgICB9KTsgLy8gTW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gZXhlY3V0ZSBhcmJpdHJhcnkgY29kZSBiZWZvcmUgdGhlIGZpcnN0XG4gICAgLy8gdXBkYXRlIGN5Y2xlIHJ1bnMuIFRoZXkgd2lsbCBiZSBleGVjdXRlZCBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgdXBkYXRlXG4gICAgLy8gY3ljbGUuIFRoaXMgaXMgdXNlZnVsIHdoZW4gYSBtb2RpZmllciBhZGRzIHNvbWUgcGVyc2lzdGVudCBkYXRhIHRoYXRcbiAgICAvLyBvdGhlciBtb2RpZmllcnMgbmVlZCB0byB1c2UsIGJ1dCB0aGUgbW9kaWZpZXIgaXMgcnVuIGFmdGVyIHRoZSBkZXBlbmRlbnRcbiAgICAvLyBvbmUuXG5cbiAgICBmdW5jdGlvbiBydW5Nb2RpZmllckVmZmVjdHMoKSB7XG4gICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICAgIHZhciBuYW1lID0gX3JlZjMubmFtZSxcbiAgICAgICAgICAgIF9yZWYzJG9wdGlvbnMgPSBfcmVmMy5vcHRpb25zLFxuICAgICAgICAgICAgb3B0aW9ucyA9IF9yZWYzJG9wdGlvbnMgPT09IHZvaWQgMCA/IHt9IDogX3JlZjMkb3B0aW9ucyxcbiAgICAgICAgICAgIGVmZmVjdCA9IF9yZWYzLmVmZmVjdDtcblxuICAgICAgICBpZiAodHlwZW9mIGVmZmVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBjbGVhbnVwRm4gPSBlZmZlY3Qoe1xuICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBub29wRm4gPSBmdW5jdGlvbiBub29wRm4oKSB7fTtcblxuICAgICAgICAgIGVmZmVjdENsZWFudXBGbnMucHVzaChjbGVhbnVwRm4gfHwgbm9vcEZuKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpIHtcbiAgICAgIGVmZmVjdENsZWFudXBGbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICB9KTtcbiAgICAgIGVmZmVjdENsZWFudXBGbnMgPSBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG59XG5leHBvcnQgdmFyIGNyZWF0ZVBvcHBlciA9IC8qI19fUFVSRV9fKi9wb3BwZXJHZW5lcmF0b3IoKTsiLCJpbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4uL2RvbS11dGlscy9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiOyAvLyBUaGlzIG1vZGlmaWVyIHRha2VzIHRoZSBzdHlsZXMgcHJlcGFyZWQgYnkgdGhlIGBjb21wdXRlU3R5bGVzYCBtb2RpZmllclxuLy8gYW5kIGFwcGxpZXMgdGhlbSB0byB0aGUgSFRNTEVsZW1lbnRzIHN1Y2ggYXMgcG9wcGVyIGFuZCBhcnJvd1xuXG5mdW5jdGlvbiBhcHBseVN0eWxlcyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGU7XG4gIE9iamVjdC5rZXlzKHN0YXRlLmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHN0eWxlID0gc3RhdGUuc3R5bGVzW25hbWVdIHx8IHt9O1xuICAgIHZhciBhdHRyaWJ1dGVzID0gc3RhdGUuYXR0cmlidXRlc1tuYW1lXSB8fCB7fTtcbiAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdOyAvLyBhcnJvdyBpcyBvcHRpb25hbCArIHZpcnR1YWwgZWxlbWVudHNcblxuICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAhZ2V0Tm9kZU5hbWUoZWxlbWVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEZsb3cgZG9lc24ndCBzdXBwb3J0IHRvIGV4dGVuZCB0aGlzIHByb3BlcnR5LCBidXQgaXQncyB0aGUgbW9zdFxuICAgIC8vIGVmZmVjdGl2ZSB3YXkgdG8gYXBwbHkgc3R5bGVzIHRvIGFuIEhUTUxFbGVtZW50XG4gICAgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcbiAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuXG4gICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUgPT09IHRydWUgPyAnJyA6IHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGVmZmVjdChfcmVmMikge1xuICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZTtcbiAgdmFyIGluaXRpYWxTdHlsZXMgPSB7XG4gICAgcG9wcGVyOiB7XG4gICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcbiAgICAgIGxlZnQ6ICcwJyxcbiAgICAgIHRvcDogJzAnLFxuICAgICAgbWFyZ2luOiAnMCdcbiAgICB9LFxuICAgIGFycm93OiB7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICAgIH0sXG4gICAgcmVmZXJlbmNlOiB7fVxuICB9O1xuICBPYmplY3QuYXNzaWduKHN0YXRlLmVsZW1lbnRzLnBvcHBlci5zdHlsZSwgaW5pdGlhbFN0eWxlcy5wb3BwZXIpO1xuXG4gIGlmIChzdGF0ZS5lbGVtZW50cy5hcnJvdykge1xuICAgIE9iamVjdC5hc3NpZ24oc3RhdGUuZWxlbWVudHMuYXJyb3cuc3R5bGUsIGluaXRpYWxTdHlsZXMuYXJyb3cpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBPYmplY3Qua2V5cyhzdGF0ZS5lbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1tuYW1lXTtcbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gc3RhdGUuYXR0cmlidXRlc1tuYW1lXSB8fCB7fTtcbiAgICAgIHZhciBzdHlsZVByb3BlcnRpZXMgPSBPYmplY3Qua2V5cyhzdGF0ZS5zdHlsZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBzdGF0ZS5zdHlsZXNbbmFtZV0gOiBpbml0aWFsU3R5bGVzW25hbWVdKTsgLy8gU2V0IGFsbCB2YWx1ZXMgdG8gYW4gZW1wdHkgc3RyaW5nIHRvIHVuc2V0IHRoZW1cblxuICAgICAgdmFyIHN0eWxlID0gc3R5bGVQcm9wZXJ0aWVzLnJlZHVjZShmdW5jdGlvbiAoc3R5bGUsIHByb3BlcnR5KSB7XG4gICAgICAgIHN0eWxlW3Byb3BlcnR5XSA9ICcnO1xuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICB9LCB7fSk7IC8vIGFycm93IGlzIG9wdGlvbmFsICsgdmlydHVhbCBlbGVtZW50c1xuXG4gICAgICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgIWdldE5vZGVOYW1lKGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gRmxvdyBkb2Vzbid0IHN1cHBvcnQgdG8gZXh0ZW5kIHRoaXMgcHJvcGVydHksIGJ1dCBpdCdzIHRoZSBtb3N0XG4gICAgICAvLyBlZmZlY3RpdmUgd2F5IHRvIGFwcGx5IHN0eWxlcyB0byBhbiBIVE1MRWxlbWVudFxuICAgICAgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2FwcGx5U3R5bGVzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICd3cml0ZScsXG4gIGZuOiBhcHBseVN0eWxlcyxcbiAgZWZmZWN0OiBlZmZlY3QsXG4gIHJlcXVpcmVzOiBbJ2NvbXB1dGVTdHlsZXMnXVxufTsiLCJpbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldExheW91dFJlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzXCI7XG5pbXBvcnQgY29udGFpbnMgZnJvbSBcIi4uL2RvbS11dGlscy9jb250YWlucy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgd2l0aGluIGZyb20gXCIuLi91dGlscy93aXRoaW4uanNcIjtcbmltcG9ydCBtZXJnZVBhZGRpbmdPYmplY3QgZnJvbSBcIi4uL3V0aWxzL21lcmdlUGFkZGluZ09iamVjdC5qc1wiO1xuaW1wb3J0IGV4cGFuZFRvSGFzaE1hcCBmcm9tIFwiLi4vdXRpbHMvZXhwYW5kVG9IYXNoTWFwLmpzXCI7XG5pbXBvcnQgeyBsZWZ0LCByaWdodCwgYmFzZVBsYWNlbWVudHMsIHRvcCwgYm90dG9tIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4uL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZnVuY3Rpb24gYXJyb3coX3JlZikge1xuICB2YXIgX3N0YXRlJG1vZGlmaWVyc0RhdGEkO1xuXG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICB2YXIgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3c7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzO1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIGF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCk7XG4gIHZhciBpc1ZlcnRpY2FsID0gW2xlZnQsIHJpZ2h0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDA7XG4gIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gIGlmICghYXJyb3dFbGVtZW50IHx8ICFwb3BwZXJPZmZzZXRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBhZGRpbmdPYmplY3QgPSBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWUgKyBcIiNwZXJzaXN0ZW50XCJdLnBhZGRpbmc7XG4gIHZhciBhcnJvd1JlY3QgPSBnZXRMYXlvdXRSZWN0KGFycm93RWxlbWVudCk7XG4gIHZhciBtaW5Qcm9wID0gYXhpcyA9PT0gJ3knID8gdG9wIDogbGVmdDtcbiAgdmFyIG1heFByb3AgPSBheGlzID09PSAneScgPyBib3R0b20gOiByaWdodDtcbiAgdmFyIGVuZERpZmYgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbbGVuXSArIHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtheGlzXSAtIHBvcHBlck9mZnNldHNbYXhpc10gLSBzdGF0ZS5yZWN0cy5wb3BwZXJbbGVuXTtcbiAgdmFyIHN0YXJ0RGlmZiA9IHBvcHBlck9mZnNldHNbYXhpc10gLSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbYXhpc107XG4gIHZhciBhcnJvd09mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChhcnJvd0VsZW1lbnQpO1xuICB2YXIgY2xpZW50U2l6ZSA9IGFycm93T2Zmc2V0UGFyZW50ID8gYXhpcyA9PT0gJ3knID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50SGVpZ2h0IHx8IDAgOiBhcnJvd09mZnNldFBhcmVudC5jbGllbnRXaWR0aCB8fCAwIDogMDtcbiAgdmFyIGNlbnRlclRvUmVmZXJlbmNlID0gZW5kRGlmZiAvIDIgLSBzdGFydERpZmYgLyAyOyAvLyBNYWtlIHN1cmUgdGhlIGFycm93IGRvZXNuJ3Qgb3ZlcmZsb3cgdGhlIHBvcHBlciBpZiB0aGUgY2VudGVyIHBvaW50IGlzXG4gIC8vIG91dHNpZGUgb2YgdGhlIHBvcHBlciBib3VuZHNcblxuICB2YXIgbWluID0gcGFkZGluZ09iamVjdFttaW5Qcm9wXTtcbiAgdmFyIG1heCA9IGNsaWVudFNpemUgLSBhcnJvd1JlY3RbbGVuXSAtIHBhZGRpbmdPYmplY3RbbWF4UHJvcF07XG4gIHZhciBjZW50ZXIgPSBjbGllbnRTaXplIC8gMiAtIGFycm93UmVjdFtsZW5dIC8gMiArIGNlbnRlclRvUmVmZXJlbmNlO1xuICB2YXIgb2Zmc2V0ID0gd2l0aGluKG1pbiwgY2VudGVyLCBtYXgpOyAvLyBQcmV2ZW50cyBicmVha2luZyBzeW50YXggaGlnaGxpZ2h0aW5nLi4uXG5cbiAgdmFyIGF4aXNQcm9wID0gYXhpcztcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IChfc3RhdGUkbW9kaWZpZXJzRGF0YSQgPSB7fSwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkW2F4aXNQcm9wXSA9IG9mZnNldCwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkLmNlbnRlck9mZnNldCA9IG9mZnNldCAtIGNlbnRlciwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkKTtcbn1cblxuZnVuY3Rpb24gZWZmZWN0KF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYyLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZjIubmFtZTtcbiAgdmFyIF9vcHRpb25zJGVsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQsXG4gICAgICBhcnJvd0VsZW1lbnQgPSBfb3B0aW9ucyRlbGVtZW50ID09PSB2b2lkIDAgPyAnW2RhdGEtcG9wcGVyLWFycm93XScgOiBfb3B0aW9ucyRlbGVtZW50LFxuICAgICAgX29wdGlvbnMkcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgIHBhZGRpbmcgPSBfb3B0aW9ucyRwYWRkaW5nID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkcGFkZGluZztcblxuICBpZiAoYXJyb3dFbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gQ1NTIHNlbGVjdG9yXG5cblxuICBpZiAodHlwZW9mIGFycm93RWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5wb3BwZXIucXVlcnlTZWxlY3RvcihhcnJvd0VsZW1lbnQpO1xuXG4gICAgaWYgKCFhcnJvd0VsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKCFpc0hUTUxFbGVtZW50KGFycm93RWxlbWVudCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFwiYXJyb3dcIiBlbGVtZW50IG11c3QgYmUgYW4gSFRNTEVsZW1lbnQgKG5vdCBhbiBTVkdFbGVtZW50KS4nLCAnVG8gdXNlIGFuIFNWRyBhcnJvdywgd3JhcCBpdCBpbiBhbiBIVE1MRWxlbWVudCB0aGF0IHdpbGwgYmUgdXNlZCBhcycsICd0aGUgYXJyb3cuJ10uam9pbignICcpKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbnRhaW5zKHN0YXRlLmVsZW1lbnRzLnBvcHBlciwgYXJyb3dFbGVtZW50KSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFwiYXJyb3dcIiBtb2RpZmllclxcJ3MgYGVsZW1lbnRgIG11c3QgYmUgYSBjaGlsZCBvZiB0aGUgcG9wcGVyJywgJ2VsZW1lbnQuJ10uam9pbignICcpKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBzdGF0ZS5lbGVtZW50cy5hcnJvdyA9IGFycm93RWxlbWVudDtcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lICsgXCIjcGVyc2lzdGVudFwiXSA9IHtcbiAgICBwYWRkaW5nOiBtZXJnZVBhZGRpbmdPYmplY3QodHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gcGFkZGluZyA6IGV4cGFuZFRvSGFzaE1hcChwYWRkaW5nLCBiYXNlUGxhY2VtZW50cykpXG4gIH07XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdhcnJvdycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBhcnJvdyxcbiAgZWZmZWN0OiBlZmZlY3QsXG4gIHJlcXVpcmVzOiBbJ3BvcHBlck9mZnNldHMnXSxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydwcmV2ZW50T3ZlcmZsb3cnXVxufTsiLCJpbXBvcnQgeyB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20gfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG52YXIgdW5zZXRTaWRlcyA9IHtcbiAgdG9wOiAnYXV0bycsXG4gIHJpZ2h0OiAnYXV0bycsXG4gIGJvdHRvbTogJ2F1dG8nLFxuICBsZWZ0OiAnYXV0bydcbn07IC8vIFJvdW5kIHRoZSBvZmZzZXRzIHRvIHRoZSBuZWFyZXN0IHN1aXRhYmxlIHN1YnBpeGVsIGJhc2VkIG9uIHRoZSBEUFIuXG4vLyBab29taW5nIGNhbiBjaGFuZ2UgdGhlIERQUiwgYnV0IGl0IHNlZW1zIHRvIHJlcG9ydCBhIHZhbHVlIHRoYXQgd2lsbFxuLy8gY2xlYW5seSBkaXZpZGUgdGhlIHZhbHVlcyBpbnRvIHRoZSBhcHByb3ByaWF0ZSBzdWJwaXhlbHMuXG5cbmZ1bmN0aW9uIHJvdW5kT2Zmc2V0cyhfcmVmKSB7XG4gIHZhciB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueTtcbiAgdmFyIHdpbiA9IHdpbmRvdztcbiAgdmFyIGRwciA9IHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gIHJldHVybiB7XG4gICAgeDogTWF0aC5yb3VuZCh4ICogZHByKSAvIGRwciB8fCAwLFxuICAgIHk6IE1hdGgucm91bmQoeSAqIGRwcikgLyBkcHIgfHwgMFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFwVG9TdHlsZXMoX3JlZjIpIHtcbiAgdmFyIF9PYmplY3QkYXNzaWduMjtcblxuICB2YXIgcG9wcGVyID0gX3JlZjIucG9wcGVyLFxuICAgICAgcG9wcGVyUmVjdCA9IF9yZWYyLnBvcHBlclJlY3QsXG4gICAgICBwbGFjZW1lbnQgPSBfcmVmMi5wbGFjZW1lbnQsXG4gICAgICBvZmZzZXRzID0gX3JlZjIub2Zmc2V0cyxcbiAgICAgIHBvc2l0aW9uID0gX3JlZjIucG9zaXRpb24sXG4gICAgICBncHVBY2NlbGVyYXRpb24gPSBfcmVmMi5ncHVBY2NlbGVyYXRpb24sXG4gICAgICBhZGFwdGl2ZSA9IF9yZWYyLmFkYXB0aXZlO1xuXG4gIHZhciBfcm91bmRPZmZzZXRzID0gcm91bmRPZmZzZXRzKG9mZnNldHMpLFxuICAgICAgeCA9IF9yb3VuZE9mZnNldHMueCxcbiAgICAgIHkgPSBfcm91bmRPZmZzZXRzLnk7XG5cbiAgdmFyIGhhc1ggPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd4Jyk7XG4gIHZhciBoYXNZID0gb2Zmc2V0cy5oYXNPd25Qcm9wZXJ0eSgneScpO1xuICB2YXIgc2lkZVggPSBsZWZ0O1xuICB2YXIgc2lkZVkgPSB0b3A7XG4gIHZhciB3aW4gPSB3aW5kb3c7XG5cbiAgaWYgKGFkYXB0aXZlKSB7XG4gICAgdmFyIG9mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChwb3BwZXIpO1xuXG4gICAgaWYgKG9mZnNldFBhcmVudCA9PT0gZ2V0V2luZG93KHBvcHBlcikpIHtcbiAgICAgIG9mZnNldFBhcmVudCA9IGdldERvY3VtZW50RWxlbWVudChwb3BwZXIpO1xuICAgIH0gLy8gJEZsb3dGaXhNZTogZm9yY2UgdHlwZSByZWZpbmVtZW50LCB3ZSBjb21wYXJlIG9mZnNldFBhcmVudCB3aXRoIHdpbmRvdyBhYm92ZSwgYnV0IEZsb3cgZG9lc24ndCBkZXRlY3QgaXRcblxuICAgIC8qOjogb2Zmc2V0UGFyZW50ID0gKG9mZnNldFBhcmVudDogRWxlbWVudCk7ICovXG5cblxuICAgIGlmIChwbGFjZW1lbnQgPT09IHRvcCkge1xuICAgICAgc2lkZVkgPSBib3R0b207XG4gICAgICB5IC09IG9mZnNldFBhcmVudC5jbGllbnRIZWlnaHQgLSBwb3BwZXJSZWN0LmhlaWdodDtcbiAgICAgIHkgKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgIH1cblxuICAgIGlmIChwbGFjZW1lbnQgPT09IGxlZnQpIHtcbiAgICAgIHNpZGVYID0gcmlnaHQ7XG4gICAgICB4IC09IG9mZnNldFBhcmVudC5jbGllbnRXaWR0aCAtIHBvcHBlclJlY3Qud2lkdGg7XG4gICAgICB4ICo9IGdwdUFjY2VsZXJhdGlvbiA/IDEgOiAtMTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29tbW9uU3R5bGVzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgcG9zaXRpb246IHBvc2l0aW9uXG4gIH0sIGFkYXB0aXZlICYmIHVuc2V0U2lkZXMpO1xuXG4gIGlmIChncHVBY2NlbGVyYXRpb24pIHtcbiAgICB2YXIgX09iamVjdCRhc3NpZ247XG5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCAoX09iamVjdCRhc3NpZ24gPSB7fSwgX09iamVjdCRhc3NpZ25bc2lkZVldID0gaGFzWSA/ICcwJyA6ICcnLCBfT2JqZWN0JGFzc2lnbltzaWRlWF0gPSBoYXNYID8gJzAnIDogJycsIF9PYmplY3QkYXNzaWduLnRyYW5zZm9ybSA9ICh3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSA8IDIgPyBcInRyYW5zbGF0ZShcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4KVwiIDogXCJ0cmFuc2xhdGUzZChcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4LCAwKVwiLCBfT2JqZWN0JGFzc2lnbikpO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywgKF9PYmplY3QkYXNzaWduMiA9IHt9LCBfT2JqZWN0JGFzc2lnbjJbc2lkZVldID0gaGFzWSA/IHkgKyBcInB4XCIgOiAnJywgX09iamVjdCRhc3NpZ24yW3NpZGVYXSA9IGhhc1ggPyB4ICsgXCJweFwiIDogJycsIF9PYmplY3QkYXNzaWduMi50cmFuc2Zvcm0gPSAnJywgX09iamVjdCRhc3NpZ24yKSk7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVTdHlsZXMoX3JlZjMpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjMuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjMub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJGdwdUFjY2VsZXJhdCA9IG9wdGlvbnMuZ3B1QWNjZWxlcmF0aW9uLFxuICAgICAgZ3B1QWNjZWxlcmF0aW9uID0gX29wdGlvbnMkZ3B1QWNjZWxlcmF0ID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkZ3B1QWNjZWxlcmF0LFxuICAgICAgX29wdGlvbnMkYWRhcHRpdmUgPSBvcHRpb25zLmFkYXB0aXZlLFxuICAgICAgYWRhcHRpdmUgPSBfb3B0aW9ucyRhZGFwdGl2ZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGFkYXB0aXZlO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YXIgdHJhbnNpdGlvblByb3BlcnR5ID0gZ2V0Q29tcHV0ZWRTdHlsZShzdGF0ZS5lbGVtZW50cy5wb3BwZXIpLnRyYW5zaXRpb25Qcm9wZXJ0eSB8fCAnJztcblxuICAgIGlmIChhZGFwdGl2ZSAmJiBbJ3RyYW5zZm9ybScsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXS5zb21lKGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHRyYW5zaXRpb25Qcm9wZXJ0eS5pbmRleE9mKHByb3BlcnR5KSA+PSAwO1xuICAgIH0pKSB7XG4gICAgICBjb25zb2xlLndhcm4oWydQb3BwZXI6IERldGVjdGVkIENTUyB0cmFuc2l0aW9ucyBvbiBhdCBsZWFzdCBvbmUgb2YgdGhlIGZvbGxvd2luZycsICdDU1MgcHJvcGVydGllczogXCJ0cmFuc2Zvcm1cIiwgXCJ0b3BcIiwgXCJyaWdodFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIi4nLCAnXFxuXFxuJywgJ0Rpc2FibGUgdGhlIFwiY29tcHV0ZVN0eWxlc1wiIG1vZGlmaWVyXFwncyBgYWRhcHRpdmVgIG9wdGlvbiB0byBhbGxvdycsICdmb3Igc21vb3RoIHRyYW5zaXRpb25zLCBvciByZW1vdmUgdGhlc2UgcHJvcGVydGllcyBmcm9tIHRoZSBDU1MnLCAndHJhbnNpdGlvbiBkZWNsYXJhdGlvbiBvbiB0aGUgcG9wcGVyIGVsZW1lbnQgaWYgb25seSB0cmFuc2l0aW9uaW5nJywgJ29wYWNpdHkgb3IgYmFja2dyb3VuZC1jb2xvciBmb3IgZXhhbXBsZS4nLCAnXFxuXFxuJywgJ1dlIHJlY29tbWVuZCB1c2luZyB0aGUgcG9wcGVyIGVsZW1lbnQgYXMgYSB3cmFwcGVyIGFyb3VuZCBhbiBpbm5lcicsICdlbGVtZW50IHRoYXQgY2FuIGhhdmUgYW55IENTUyBwcm9wZXJ0eSB0cmFuc2l0aW9uZWQgZm9yIGFuaW1hdGlvbnMuJ10uam9pbignICcpKTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29tbW9uU3R5bGVzID0ge1xuICAgIHBsYWNlbWVudDogZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpLFxuICAgIHBvcHBlcjogc3RhdGUuZWxlbWVudHMucG9wcGVyLFxuICAgIHBvcHBlclJlY3Q6IHN0YXRlLnJlY3RzLnBvcHBlcixcbiAgICBncHVBY2NlbGVyYXRpb246IGdwdUFjY2VsZXJhdGlvblxuICB9O1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xuICAgIHN0YXRlLnN0eWxlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zdHlsZXMucG9wcGVyLCB7fSwgbWFwVG9TdHlsZXMoT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCB7XG4gICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMsXG4gICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcbiAgICAgIGFkYXB0aXZlOiBhZGFwdGl2ZVxuICAgIH0pKSk7XG4gIH1cblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5hcnJvdyAhPSBudWxsKSB7XG4gICAgc3RhdGUuc3R5bGVzLmFycm93ID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuc3R5bGVzLmFycm93LCB7fSwgbWFwVG9TdHlsZXMoT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCB7XG4gICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93LFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICBhZGFwdGl2ZTogZmFsc2VcbiAgICB9KSkpO1xuICB9XG5cbiAgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgICdkYXRhLXBvcHBlci1wbGFjZW1lbnQnOiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdjb21wdXRlU3R5bGVzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdiZWZvcmVXcml0ZScsXG4gIGZuOiBjb21wdXRlU3R5bGVzLFxuICBkYXRhOiB7fVxufTsiLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0V2luZG93LmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxudmFyIHBhc3NpdmUgPSB7XG4gIHBhc3NpdmU6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGVmZmVjdChfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBpbnN0YW5jZSA9IF9yZWYuaW5zdGFuY2UsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zO1xuICB2YXIgX29wdGlvbnMkc2Nyb2xsID0gb3B0aW9ucy5zY3JvbGwsXG4gICAgICBzY3JvbGwgPSBfb3B0aW9ucyRzY3JvbGwgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRzY3JvbGwsXG4gICAgICBfb3B0aW9ucyRyZXNpemUgPSBvcHRpb25zLnJlc2l6ZSxcbiAgICAgIHJlc2l6ZSA9IF9vcHRpb25zJHJlc2l6ZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHJlc2l6ZTtcbiAgdmFyIHdpbmRvdyA9IGdldFdpbmRvdyhzdGF0ZS5lbGVtZW50cy5wb3BwZXIpO1xuICB2YXIgc2Nyb2xsUGFyZW50cyA9IFtdLmNvbmNhdChzdGF0ZS5zY3JvbGxQYXJlbnRzLnJlZmVyZW5jZSwgc3RhdGUuc2Nyb2xsUGFyZW50cy5wb3BwZXIpO1xuXG4gIGlmIChzY3JvbGwpIHtcbiAgICBzY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbFBhcmVudCkge1xuICAgICAgc2Nyb2xsUGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAocmVzaXplKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChzY3JvbGwpIHtcbiAgICAgIHNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAoc2Nyb2xsUGFyZW50KSB7XG4gICAgICAgIHNjcm9sbFBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHJlc2l6ZSkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgfVxuICB9O1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnZXZlbnRMaXN0ZW5lcnMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ3dyaXRlJyxcbiAgZm46IGZ1bmN0aW9uIGZuKCkge30sXG4gIGVmZmVjdDogZWZmZWN0LFxuICBkYXRhOiB7fVxufTsiLCJpbXBvcnQgZ2V0T3Bwb3NpdGVQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldE9wcG9zaXRlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGNvbXB1dGVBdXRvUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9jb21wdXRlQXV0b1BsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgYm90dG9tLCB0b3AsIHN0YXJ0LCByaWdodCwgbGVmdCwgYXV0byB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi4vdXRpbHMvZ2V0VmFyaWF0aW9uLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZnVuY3Rpb24gZ2V0RXhwYW5kZWRGYWxsYmFja1BsYWNlbWVudHMocGxhY2VtZW50KSB7XG4gIGlmIChnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgPT09IGF1dG8pIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgb3Bwb3NpdGVQbGFjZW1lbnQgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICByZXR1cm4gW2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KHBsYWNlbWVudCksIG9wcG9zaXRlUGxhY2VtZW50LCBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChvcHBvc2l0ZVBsYWNlbWVudCldO1xufVxuXG5mdW5jdGlvbiBmbGlwKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdLl9za2lwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIF9vcHRpb25zJG1haW5BeGlzID0gb3B0aW9ucy5tYWluQXhpcyxcbiAgICAgIGNoZWNrTWFpbkF4aXMgPSBfb3B0aW9ucyRtYWluQXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJG1haW5BeGlzLFxuICAgICAgX29wdGlvbnMkYWx0QXhpcyA9IG9wdGlvbnMuYWx0QXhpcyxcbiAgICAgIGNoZWNrQWx0QXhpcyA9IF9vcHRpb25zJGFsdEF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRhbHRBeGlzLFxuICAgICAgc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzID0gb3B0aW9ucy5mYWxsYmFja1BsYWNlbWVudHMsXG4gICAgICBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgYm91bmRhcnkgPSBvcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IG9wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRmbGlwVmFyaWF0aW8gPSBvcHRpb25zLmZsaXBWYXJpYXRpb25zLFxuICAgICAgZmxpcFZhcmlhdGlvbnMgPSBfb3B0aW9ucyRmbGlwVmFyaWF0aW8gPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRmbGlwVmFyaWF0aW8sXG4gICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHMgPSBvcHRpb25zLmFsbG93ZWRBdXRvUGxhY2VtZW50cztcbiAgdmFyIHByZWZlcnJlZFBsYWNlbWVudCA9IHN0YXRlLm9wdGlvbnMucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocHJlZmVycmVkUGxhY2VtZW50KTtcbiAgdmFyIGlzQmFzZVBsYWNlbWVudCA9IGJhc2VQbGFjZW1lbnQgPT09IHByZWZlcnJlZFBsYWNlbWVudDtcbiAgdmFyIGZhbGxiYWNrUGxhY2VtZW50cyA9IHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyB8fCAoaXNCYXNlUGxhY2VtZW50IHx8ICFmbGlwVmFyaWF0aW9ucyA/IFtnZXRPcHBvc2l0ZVBsYWNlbWVudChwcmVmZXJyZWRQbGFjZW1lbnQpXSA6IGdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzKHByZWZlcnJlZFBsYWNlbWVudCkpO1xuICB2YXIgcGxhY2VtZW50cyA9IFtwcmVmZXJyZWRQbGFjZW1lbnRdLmNvbmNhdChmYWxsYmFja1BsYWNlbWVudHMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gYWNjLmNvbmNhdChnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgPT09IGF1dG8gPyBjb21wdXRlQXV0b1BsYWNlbWVudChzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgICBmbGlwVmFyaWF0aW9uczogZmxpcFZhcmlhdGlvbnMsXG4gICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHM6IGFsbG93ZWRBdXRvUGxhY2VtZW50c1xuICAgIH0pIDogcGxhY2VtZW50KTtcbiAgfSwgW10pO1xuICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciBjaGVja3NNYXAgPSBuZXcgTWFwKCk7XG4gIHZhciBtYWtlRmFsbGJhY2tDaGVja3MgPSB0cnVlO1xuICB2YXIgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50c1swXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBsYWNlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGxhY2VtZW50ID0gcGxhY2VtZW50c1tpXTtcblxuICAgIHZhciBfYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KTtcblxuICAgIHZhciBpc1N0YXJ0VmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgPT09IHN0YXJ0O1xuICAgIHZhciBpc1ZlcnRpY2FsID0gW3RvcCwgYm90dG9tXS5pbmRleE9mKF9iYXNlUGxhY2VtZW50KSA+PSAwO1xuICAgIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgIHZhciBvdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnk6IGFsdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgIH0pO1xuICAgIHZhciBtYWluVmFyaWF0aW9uU2lkZSA9IGlzVmVydGljYWwgPyBpc1N0YXJ0VmFyaWF0aW9uID8gcmlnaHQgOiBsZWZ0IDogaXNTdGFydFZhcmlhdGlvbiA/IGJvdHRvbSA6IHRvcDtcblxuICAgIGlmIChyZWZlcmVuY2VSZWN0W2xlbl0gPiBwb3BwZXJSZWN0W2xlbl0pIHtcbiAgICAgIG1haW5WYXJpYXRpb25TaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpblZhcmlhdGlvblNpZGUpO1xuICAgIH1cblxuICAgIHZhciBhbHRWYXJpYXRpb25TaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpblZhcmlhdGlvblNpZGUpO1xuICAgIHZhciBjaGVja3MgPSBbXTtcblxuICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICBjaGVja3MucHVzaChvdmVyZmxvd1tfYmFzZVBsYWNlbWVudF0gPD0gMCk7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrQWx0QXhpcykge1xuICAgICAgY2hlY2tzLnB1c2gob3ZlcmZsb3dbbWFpblZhcmlhdGlvblNpZGVdIDw9IDAsIG92ZXJmbG93W2FsdFZhcmlhdGlvblNpZGVdIDw9IDApO1xuICAgIH1cblxuICAgIGlmIChjaGVja3MuZXZlcnkoZnVuY3Rpb24gKGNoZWNrKSB7XG4gICAgICByZXR1cm4gY2hlY2s7XG4gICAgfSkpIHtcbiAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudDtcbiAgICAgIG1ha2VGYWxsYmFja0NoZWNrcyA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2hlY2tzTWFwLnNldChwbGFjZW1lbnQsIGNoZWNrcyk7XG4gIH1cblxuICBpZiAobWFrZUZhbGxiYWNrQ2hlY2tzKSB7XG4gICAgLy8gYDJgIG1heSBiZSBkZXNpcmVkIGluIHNvbWUgY2FzZXMg4oCTIHJlc2VhcmNoIGxhdGVyXG4gICAgdmFyIG51bWJlck9mQ2hlY2tzID0gZmxpcFZhcmlhdGlvbnMgPyAzIDogMTtcblxuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKF9pKSB7XG4gICAgICB2YXIgZml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudHMuZmluZChmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgICAgIHZhciBjaGVja3MgPSBjaGVja3NNYXAuZ2V0KHBsYWNlbWVudCk7XG5cbiAgICAgICAgaWYgKGNoZWNrcykge1xuICAgICAgICAgIHJldHVybiBjaGVja3Muc2xpY2UoMCwgX2kpLmV2ZXJ5KGZ1bmN0aW9uIChjaGVjaykge1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKGZpdHRpbmdQbGFjZW1lbnQpIHtcbiAgICAgICAgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gZml0dGluZ1BsYWNlbWVudDtcbiAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yICh2YXIgX2kgPSBudW1iZXJPZkNoZWNrczsgX2kgPiAwOyBfaS0tKSB7XG4gICAgICB2YXIgX3JldCA9IF9sb29wKF9pKTtcblxuICAgICAgaWYgKF9yZXQgPT09IFwiYnJlYWtcIikgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRlLnBsYWNlbWVudCAhPT0gZmlyc3RGaXR0aW5nUGxhY2VtZW50KSB7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCA9IHRydWU7XG4gICAgc3RhdGUucGxhY2VtZW50ID0gZmlyc3RGaXR0aW5nUGxhY2VtZW50O1xuICAgIHN0YXRlLnJlc2V0ID0gdHJ1ZTtcbiAgfVxufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnZmxpcCcsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBmbGlwLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ29mZnNldCddLFxuICBkYXRhOiB7XG4gICAgX3NraXA6IGZhbHNlXG4gIH1cbn07IiwiaW1wb3J0IHsgdG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4uL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5cbmZ1bmN0aW9uIGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0LCBwcmV2ZW50ZWRPZmZzZXRzKSB7XG4gIGlmIChwcmV2ZW50ZWRPZmZzZXRzID09PSB2b2lkIDApIHtcbiAgICBwcmV2ZW50ZWRPZmZzZXRzID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b3A6IG92ZXJmbG93LnRvcCAtIHJlY3QuaGVpZ2h0IC0gcHJldmVudGVkT2Zmc2V0cy55LFxuICAgIHJpZ2h0OiBvdmVyZmxvdy5yaWdodCAtIHJlY3Qud2lkdGggKyBwcmV2ZW50ZWRPZmZzZXRzLngsXG4gICAgYm90dG9tOiBvdmVyZmxvdy5ib3R0b20gLSByZWN0LmhlaWdodCArIHByZXZlbnRlZE9mZnNldHMueSxcbiAgICBsZWZ0OiBvdmVyZmxvdy5sZWZ0IC0gcmVjdC53aWR0aCAtIHByZXZlbnRlZE9mZnNldHMueFxuICB9O1xufVxuXG5mdW5jdGlvbiBpc0FueVNpZGVGdWxseUNsaXBwZWQob3ZlcmZsb3cpIHtcbiAgcmV0dXJuIFt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRdLnNvbWUoZnVuY3Rpb24gKHNpZGUpIHtcbiAgICByZXR1cm4gb3ZlcmZsb3dbc2lkZV0gPj0gMDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGhpZGUoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgcHJldmVudGVkT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucHJldmVudE92ZXJmbG93O1xuICB2YXIgcmVmZXJlbmNlT3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGVsZW1lbnRDb250ZXh0OiAncmVmZXJlbmNlJ1xuICB9KTtcbiAgdmFyIHBvcHBlckFsdE92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBhbHRCb3VuZGFyeTogdHJ1ZVxuICB9KTtcbiAgdmFyIHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKHJlZmVyZW5jZU92ZXJmbG93LCByZWZlcmVuY2VSZWN0KTtcbiAgdmFyIHBvcHBlckVzY2FwZU9mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhwb3BwZXJBbHRPdmVyZmxvdywgcG9wcGVyUmVjdCwgcHJldmVudGVkT2Zmc2V0cyk7XG4gIHZhciBpc1JlZmVyZW5jZUhpZGRlbiA9IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChyZWZlcmVuY2VDbGlwcGluZ09mZnNldHMpO1xuICB2YXIgaGFzUG9wcGVyRXNjYXBlZCA9IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChwb3BwZXJFc2NhcGVPZmZzZXRzKTtcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IHtcbiAgICByZWZlcmVuY2VDbGlwcGluZ09mZnNldHM6IHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyxcbiAgICBwb3BwZXJFc2NhcGVPZmZzZXRzOiBwb3BwZXJFc2NhcGVPZmZzZXRzLFxuICAgIGlzUmVmZXJlbmNlSGlkZGVuOiBpc1JlZmVyZW5jZUhpZGRlbixcbiAgICBoYXNQb3BwZXJFc2NhcGVkOiBoYXNQb3BwZXJFc2NhcGVkXG4gIH07XG4gIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIsIHtcbiAgICAnZGF0YS1wb3BwZXItcmVmZXJlbmNlLWhpZGRlbic6IGlzUmVmZXJlbmNlSGlkZGVuLFxuICAgICdkYXRhLXBvcHBlci1lc2NhcGVkJzogaGFzUG9wcGVyRXNjYXBlZFxuICB9KTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2hpZGUnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddLFxuICBmbjogaGlkZVxufTsiLCJpbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgdG9wLCBsZWZ0LCByaWdodCwgcGxhY2VtZW50cyB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZKHBsYWNlbWVudCwgcmVjdHMsIG9mZnNldCkge1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgdmFyIGludmVydERpc3RhbmNlID0gW2xlZnQsIHRvcF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwID8gLTEgOiAxO1xuXG4gIHZhciBfcmVmID0gdHlwZW9mIG9mZnNldCA9PT0gJ2Z1bmN0aW9uJyA/IG9mZnNldChPYmplY3QuYXNzaWduKHt9LCByZWN0cywge1xuICAgIHBsYWNlbWVudDogcGxhY2VtZW50XG4gIH0pKSA6IG9mZnNldCxcbiAgICAgIHNraWRkaW5nID0gX3JlZlswXSxcbiAgICAgIGRpc3RhbmNlID0gX3JlZlsxXTtcblxuICBza2lkZGluZyA9IHNraWRkaW5nIHx8IDA7XG4gIGRpc3RhbmNlID0gKGRpc3RhbmNlIHx8IDApICogaW52ZXJ0RGlzdGFuY2U7XG4gIHJldHVybiBbbGVmdCwgcmlnaHRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMCA/IHtcbiAgICB4OiBkaXN0YW5jZSxcbiAgICB5OiBza2lkZGluZ1xuICB9IDoge1xuICAgIHg6IHNraWRkaW5nLFxuICAgIHk6IGRpc3RhbmNlXG4gIH07XG59XG5cbmZ1bmN0aW9uIG9mZnNldChfcmVmMikge1xuICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmMi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYyLm5hbWU7XG4gIHZhciBfb3B0aW9ucyRvZmZzZXQgPSBvcHRpb25zLm9mZnNldCxcbiAgICAgIG9mZnNldCA9IF9vcHRpb25zJG9mZnNldCA9PT0gdm9pZCAwID8gWzAsIDBdIDogX29wdGlvbnMkb2Zmc2V0O1xuICB2YXIgZGF0YSA9IHBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgIGFjY1twbGFjZW1lbnRdID0gZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFkocGxhY2VtZW50LCBzdGF0ZS5yZWN0cywgb2Zmc2V0KTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIHZhciBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQgPSBkYXRhW3N0YXRlLnBsYWNlbWVudF0sXG4gICAgICB4ID0gX2RhdGEkc3RhdGUkcGxhY2VtZW50LngsXG4gICAgICB5ID0gX2RhdGEkc3RhdGUkcGxhY2VtZW50Lnk7XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyAhPSBudWxsKSB7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnggKz0geDtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueSArPSB5O1xuICB9XG5cbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGRhdGE7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdvZmZzZXQnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICByZXF1aXJlczogWydwb3BwZXJPZmZzZXRzJ10sXG4gIGZuOiBvZmZzZXRcbn07IiwiaW1wb3J0IGNvbXB1dGVPZmZzZXRzIGZyb20gXCIuLi91dGlscy9jb21wdXRlT2Zmc2V0cy5qc1wiO1xuXG5mdW5jdGlvbiBwb3BwZXJPZmZzZXRzKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG4gIC8vIE9mZnNldHMgYXJlIHRoZSBhY3R1YWwgcG9zaXRpb24gdGhlIHBvcHBlciBuZWVkcyB0byBoYXZlIHRvIGJlXG4gIC8vIHByb3Blcmx5IHBvc2l0aW9uZWQgbmVhciBpdHMgcmVmZXJlbmNlIGVsZW1lbnRcbiAgLy8gVGhpcyBpcyB0aGUgbW9zdCBiYXNpYyBwbGFjZW1lbnQsIGFuZCB3aWxsIGJlIGFkanVzdGVkIGJ5XG4gIC8vIHRoZSBtb2RpZmllcnMgaW4gdGhlIG5leHQgc3RlcFxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gY29tcHV0ZU9mZnNldHMoe1xuICAgIHJlZmVyZW5jZTogc3RhdGUucmVjdHMucmVmZXJlbmNlLFxuICAgIGVsZW1lbnQ6IHN0YXRlLnJlY3RzLnBvcHBlcixcbiAgICBzdHJhdGVneTogJ2Fic29sdXRlJyxcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ3BvcHBlck9mZnNldHMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ3JlYWQnLFxuICBmbjogcG9wcGVyT2Zmc2V0cyxcbiAgZGF0YToge31cbn07IiwiaW1wb3J0IHsgdG9wLCBsZWZ0LCByaWdodCwgYm90dG9tLCBzdGFydCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldEFsdEF4aXMgZnJvbSBcIi4uL3V0aWxzL2dldEFsdEF4aXMuanNcIjtcbmltcG9ydCB3aXRoaW4gZnJvbSBcIi4uL3V0aWxzL3dpdGhpbi5qc1wiO1xuaW1wb3J0IGdldExheW91dFJlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4uL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuLi91dGlscy9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCBnZXRGcmVzaFNpZGVPYmplY3QgZnJvbSBcIi4uL3V0aWxzL2dldEZyZXNoU2lkZU9iamVjdC5qc1wiO1xuXG5mdW5jdGlvbiBwcmV2ZW50T3ZlcmZsb3coX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG4gIHZhciBfb3B0aW9ucyRtYWluQXhpcyA9IG9wdGlvbnMubWFpbkF4aXMsXG4gICAgICBjaGVja01haW5BeGlzID0gX29wdGlvbnMkbWFpbkF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRtYWluQXhpcyxcbiAgICAgIF9vcHRpb25zJGFsdEF4aXMgPSBvcHRpb25zLmFsdEF4aXMsXG4gICAgICBjaGVja0FsdEF4aXMgPSBfb3B0aW9ucyRhbHRBeGlzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGFsdEF4aXMsXG4gICAgICBib3VuZGFyeSA9IG9wdGlvbnMuYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBvcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5ID0gb3B0aW9ucy5hbHRCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmcsXG4gICAgICBfb3B0aW9ucyR0ZXRoZXIgPSBvcHRpb25zLnRldGhlcixcbiAgICAgIHRldGhlciA9IF9vcHRpb25zJHRldGhlciA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHRldGhlcixcbiAgICAgIF9vcHRpb25zJHRldGhlck9mZnNldCA9IG9wdGlvbnMudGV0aGVyT2Zmc2V0LFxuICAgICAgdGV0aGVyT2Zmc2V0ID0gX29wdGlvbnMkdGV0aGVyT2Zmc2V0ID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkdGV0aGVyT2Zmc2V0O1xuICB2YXIgb3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgIGFsdEJvdW5kYXJ5OiBhbHRCb3VuZGFyeVxuICB9KTtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCk7XG4gIHZhciB2YXJpYXRpb24gPSBnZXRWYXJpYXRpb24oc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIGlzQmFzZVBsYWNlbWVudCA9ICF2YXJpYXRpb247XG4gIHZhciBtYWluQXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KTtcbiAgdmFyIGFsdEF4aXMgPSBnZXRBbHRBeGlzKG1haW5BeGlzKTtcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHM7XG4gIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIHRldGhlck9mZnNldFZhbHVlID0gdHlwZW9mIHRldGhlck9mZnNldCA9PT0gJ2Z1bmN0aW9uJyA/IHRldGhlck9mZnNldChPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5yZWN0cywge1xuICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gIH0pKSA6IHRldGhlck9mZnNldDtcbiAgdmFyIGRhdGEgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG5cbiAgaWYgKCFwb3BwZXJPZmZzZXRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICB2YXIgbWFpblNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gdG9wIDogbGVmdDtcbiAgICB2YXIgYWx0U2lkZSA9IG1haW5BeGlzID09PSAneScgPyBib3R0b20gOiByaWdodDtcbiAgICB2YXIgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICB2YXIgb2Zmc2V0ID0gcG9wcGVyT2Zmc2V0c1ttYWluQXhpc107XG4gICAgdmFyIG1pbiA9IHBvcHBlck9mZnNldHNbbWFpbkF4aXNdICsgb3ZlcmZsb3dbbWFpblNpZGVdO1xuICAgIHZhciBtYXggPSBwb3BwZXJPZmZzZXRzW21haW5BeGlzXSAtIG92ZXJmbG93W2FsdFNpZGVdO1xuICAgIHZhciBhZGRpdGl2ZSA9IHRldGhlciA/IC1wb3BwZXJSZWN0W2xlbl0gLyAyIDogMDtcbiAgICB2YXIgbWluTGVuID0gdmFyaWF0aW9uID09PSBzdGFydCA/IHJlZmVyZW5jZVJlY3RbbGVuXSA6IHBvcHBlclJlY3RbbGVuXTtcbiAgICB2YXIgbWF4TGVuID0gdmFyaWF0aW9uID09PSBzdGFydCA/IC1wb3BwZXJSZWN0W2xlbl0gOiAtcmVmZXJlbmNlUmVjdFtsZW5dOyAvLyBXZSBuZWVkIHRvIGluY2x1ZGUgdGhlIGFycm93IGluIHRoZSBjYWxjdWxhdGlvbiBzbyB0aGUgYXJyb3cgZG9lc24ndCBnb1xuICAgIC8vIG91dHNpZGUgdGhlIHJlZmVyZW5jZSBib3VuZHNcblxuICAgIHZhciBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdztcbiAgICB2YXIgYXJyb3dSZWN0ID0gdGV0aGVyICYmIGFycm93RWxlbWVudCA/IGdldExheW91dFJlY3QoYXJyb3dFbGVtZW50KSA6IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfTtcbiAgICB2YXIgYXJyb3dQYWRkaW5nT2JqZWN0ID0gc3RhdGUubW9kaWZpZXJzRGF0YVsnYXJyb3cjcGVyc2lzdGVudCddID8gc3RhdGUubW9kaWZpZXJzRGF0YVsnYXJyb3cjcGVyc2lzdGVudCddLnBhZGRpbmcgOiBnZXRGcmVzaFNpZGVPYmplY3QoKTtcbiAgICB2YXIgYXJyb3dQYWRkaW5nTWluID0gYXJyb3dQYWRkaW5nT2JqZWN0W21haW5TaWRlXTtcbiAgICB2YXIgYXJyb3dQYWRkaW5nTWF4ID0gYXJyb3dQYWRkaW5nT2JqZWN0W2FsdFNpZGVdOyAvLyBJZiB0aGUgcmVmZXJlbmNlIGxlbmd0aCBpcyBzbWFsbGVyIHRoYW4gdGhlIGFycm93IGxlbmd0aCwgd2UgZG9uJ3Qgd2FudFxuICAgIC8vIHRvIGluY2x1ZGUgaXRzIGZ1bGwgc2l6ZSBpbiB0aGUgY2FsY3VsYXRpb24uIElmIHRoZSByZWZlcmVuY2UgaXMgc21hbGxcbiAgICAvLyBhbmQgbmVhciB0aGUgZWRnZSBvZiBhIGJvdW5kYXJ5LCB0aGUgcG9wcGVyIGNhbiBvdmVyZmxvdyBldmVuIGlmIHRoZVxuICAgIC8vIHJlZmVyZW5jZSBpcyBub3Qgb3ZlcmZsb3dpbmcgYXMgd2VsbCAoZS5nLiB2aXJ0dWFsIGVsZW1lbnRzIHdpdGggbm9cbiAgICAvLyB3aWR0aCBvciBoZWlnaHQpXG5cbiAgICB2YXIgYXJyb3dMZW4gPSB3aXRoaW4oMCwgcmVmZXJlbmNlUmVjdFtsZW5dLCBhcnJvd1JlY3RbbGVuXSk7XG4gICAgdmFyIG1pbk9mZnNldCA9IGlzQmFzZVBsYWNlbWVudCA/IHJlZmVyZW5jZVJlY3RbbGVuXSAvIDIgLSBhZGRpdGl2ZSAtIGFycm93TGVuIC0gYXJyb3dQYWRkaW5nTWluIC0gdGV0aGVyT2Zmc2V0VmFsdWUgOiBtaW5MZW4gLSBhcnJvd0xlbiAtIGFycm93UGFkZGluZ01pbiAtIHRldGhlck9mZnNldFZhbHVlO1xuICAgIHZhciBtYXhPZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnQgPyAtcmVmZXJlbmNlUmVjdFtsZW5dIC8gMiArIGFkZGl0aXZlICsgYXJyb3dMZW4gKyBhcnJvd1BhZGRpbmdNYXggKyB0ZXRoZXJPZmZzZXRWYWx1ZSA6IG1heExlbiArIGFycm93TGVuICsgYXJyb3dQYWRkaW5nTWF4ICsgdGV0aGVyT2Zmc2V0VmFsdWU7XG4gICAgdmFyIGFycm93T2Zmc2V0UGFyZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3cgJiYgZ2V0T2Zmc2V0UGFyZW50KHN0YXRlLmVsZW1lbnRzLmFycm93KTtcbiAgICB2YXIgY2xpZW50T2Zmc2V0ID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBtYWluQXhpcyA9PT0gJ3knID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50VG9wIHx8IDAgOiBhcnJvd09mZnNldFBhcmVudC5jbGllbnRMZWZ0IHx8IDAgOiAwO1xuICAgIHZhciBvZmZzZXRNb2RpZmllclZhbHVlID0gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXQgPyBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldFtzdGF0ZS5wbGFjZW1lbnRdW21haW5BeGlzXSA6IDA7XG4gICAgdmFyIHRldGhlck1pbiA9IHBvcHBlck9mZnNldHNbbWFpbkF4aXNdICsgbWluT2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZSAtIGNsaWVudE9mZnNldDtcbiAgICB2YXIgdGV0aGVyTWF4ID0gcG9wcGVyT2Zmc2V0c1ttYWluQXhpc10gKyBtYXhPZmZzZXQgLSBvZmZzZXRNb2RpZmllclZhbHVlO1xuICAgIHZhciBwcmV2ZW50ZWRPZmZzZXQgPSB3aXRoaW4odGV0aGVyID8gTWF0aC5taW4obWluLCB0ZXRoZXJNaW4pIDogbWluLCBvZmZzZXQsIHRldGhlciA/IE1hdGgubWF4KG1heCwgdGV0aGVyTWF4KSA6IG1heCk7XG4gICAgcG9wcGVyT2Zmc2V0c1ttYWluQXhpc10gPSBwcmV2ZW50ZWRPZmZzZXQ7XG4gICAgZGF0YVttYWluQXhpc10gPSBwcmV2ZW50ZWRPZmZzZXQgLSBvZmZzZXQ7XG4gIH1cblxuICBpZiAoY2hlY2tBbHRBeGlzKSB7XG4gICAgdmFyIF9tYWluU2lkZSA9IG1haW5BeGlzID09PSAneCcgPyB0b3AgOiBsZWZ0O1xuXG4gICAgdmFyIF9hbHRTaWRlID0gbWFpbkF4aXMgPT09ICd4JyA/IGJvdHRvbSA6IHJpZ2h0O1xuXG4gICAgdmFyIF9vZmZzZXQgPSBwb3BwZXJPZmZzZXRzW2FsdEF4aXNdO1xuXG4gICAgdmFyIF9taW4gPSBfb2Zmc2V0ICsgb3ZlcmZsb3dbX21haW5TaWRlXTtcblxuICAgIHZhciBfbWF4ID0gX29mZnNldCAtIG92ZXJmbG93W19hbHRTaWRlXTtcblxuICAgIHZhciBfcHJldmVudGVkT2Zmc2V0ID0gd2l0aGluKF9taW4sIF9vZmZzZXQsIF9tYXgpO1xuXG4gICAgcG9wcGVyT2Zmc2V0c1thbHRBeGlzXSA9IF9wcmV2ZW50ZWRPZmZzZXQ7XG4gICAgZGF0YVthbHRBeGlzXSA9IF9wcmV2ZW50ZWRPZmZzZXQgLSBfb2Zmc2V0O1xuICB9XG5cbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGRhdGE7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdwcmV2ZW50T3ZlcmZsb3cnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogcHJldmVudE92ZXJmbG93LFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ29mZnNldCddXG59OyIsImltcG9ydCB7IHBvcHBlckdlbmVyYXRvciB9IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQgZXZlbnRMaXN0ZW5lcnMgZnJvbSBcIi4vbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzXCI7XG5pbXBvcnQgcG9wcGVyT2Zmc2V0cyBmcm9tIFwiLi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qc1wiO1xuaW1wb3J0IGNvbXB1dGVTdHlsZXMgZnJvbSBcIi4vbW9kaWZpZXJzL2NvbXB1dGVTdHlsZXMuanNcIjtcbmltcG9ydCBhcHBseVN0eWxlcyBmcm9tIFwiLi9tb2RpZmllcnMvYXBwbHlTdHlsZXMuanNcIjtcbmltcG9ydCBvZmZzZXQgZnJvbSBcIi4vbW9kaWZpZXJzL29mZnNldC5qc1wiO1xuaW1wb3J0IGZsaXAgZnJvbSBcIi4vbW9kaWZpZXJzL2ZsaXAuanNcIjtcbmltcG9ydCBwcmV2ZW50T3ZlcmZsb3cgZnJvbSBcIi4vbW9kaWZpZXJzL3ByZXZlbnRPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGFycm93IGZyb20gXCIuL21vZGlmaWVycy9hcnJvdy5qc1wiO1xuaW1wb3J0IGhpZGUgZnJvbSBcIi4vbW9kaWZpZXJzL2hpZGUuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xudmFyIGRlZmF1bHRNb2RpZmllcnMgPSBbZXZlbnRMaXN0ZW5lcnMsIHBvcHBlck9mZnNldHMsIGNvbXB1dGVTdHlsZXMsIGFwcGx5U3R5bGVzLCBvZmZzZXQsIGZsaXAsIHByZXZlbnRPdmVyZmxvdywgYXJyb3csIGhpZGVdO1xudmFyIGNyZWF0ZVBvcHBlciA9IC8qI19fUFVSRV9fKi9wb3BwZXJHZW5lcmF0b3Ioe1xuICBkZWZhdWx0TW9kaWZpZXJzOiBkZWZhdWx0TW9kaWZpZXJzXG59KTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgeyBjcmVhdGVQb3BwZXIsIHBvcHBlckdlbmVyYXRvciwgZGVmYXVsdE1vZGlmaWVycywgZGV0ZWN0T3ZlcmZsb3cgfTsiLCJpbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuL2dldFZhcmlhdGlvbi5qc1wiO1xuaW1wb3J0IHsgdmFyaWF0aW9uUGxhY2VtZW50cywgYmFzZVBsYWNlbWVudHMsIHBsYWNlbWVudHMgYXMgYWxsUGxhY2VtZW50cyB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuL2RldGVjdE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5cbi8qOjogdHlwZSBPdmVyZmxvd3NNYXAgPSB7IFtDb21wdXRlZFBsYWNlbWVudF06IG51bWJlciB9OyAqL1xuXG4vKjs7IHR5cGUgT3ZlcmZsb3dzTWFwID0geyBba2V5IGluIENvbXB1dGVkUGxhY2VtZW50XTogbnVtYmVyIH07ICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wdXRlQXV0b1BsYWNlbWVudChzdGF0ZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgIHBsYWNlbWVudCA9IF9vcHRpb25zLnBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5ID0gX29wdGlvbnMuYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBfb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nID0gX29wdGlvbnMucGFkZGluZyxcbiAgICAgIGZsaXBWYXJpYXRpb25zID0gX29wdGlvbnMuZmxpcFZhcmlhdGlvbnMsXG4gICAgICBfb3B0aW9ucyRhbGxvd2VkQXV0b1AgPSBfb3B0aW9ucy5hbGxvd2VkQXV0b1BsYWNlbWVudHMsXG4gICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHMgPSBfb3B0aW9ucyRhbGxvd2VkQXV0b1AgPT09IHZvaWQgMCA/IGFsbFBsYWNlbWVudHMgOiBfb3B0aW9ucyRhbGxvd2VkQXV0b1A7XG4gIHZhciB2YXJpYXRpb24gPSBnZXRWYXJpYXRpb24ocGxhY2VtZW50KTtcbiAgdmFyIHBsYWNlbWVudHMgPSAodmFyaWF0aW9uID8gZmxpcFZhcmlhdGlvbnMgPyB2YXJpYXRpb25QbGFjZW1lbnRzIDogdmFyaWF0aW9uUGxhY2VtZW50cy5maWx0ZXIoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHJldHVybiBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA9PT0gdmFyaWF0aW9uO1xuICB9KSA6IGJhc2VQbGFjZW1lbnRzKS5maWx0ZXIoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHJldHVybiBhbGxvd2VkQXV0b1BsYWNlbWVudHMuaW5kZXhPZihwbGFjZW1lbnQpID49IDA7XG4gIH0pOyAvLyAkRmxvd0ZpeE1lOiBGbG93IHNlZW1zIHRvIGhhdmUgcHJvYmxlbXMgd2l0aCB0d28gYXJyYXkgdW5pb25zLi4uXG5cbiAgdmFyIG92ZXJmbG93cyA9IHBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgIGFjY1twbGFjZW1lbnRdID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nXG4gICAgfSlbZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpXTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvdmVyZmxvd3MpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gb3ZlcmZsb3dzW2FdIC0gb3ZlcmZsb3dzW2JdO1xuICB9KTtcbn0iLCJpbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuL2dldFZhcmlhdGlvbi5qc1wiO1xuaW1wb3J0IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudCBmcm9tIFwiLi9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCwgc3RhcnQsIGVuZCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcHV0ZU9mZnNldHMoX3JlZikge1xuICB2YXIgcmVmZXJlbmNlID0gX3JlZi5yZWZlcmVuY2UsXG4gICAgICBlbGVtZW50ID0gX3JlZi5lbGVtZW50LFxuICAgICAgcGxhY2VtZW50ID0gX3JlZi5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50ID8gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpIDogbnVsbDtcbiAgdmFyIHZhcmlhdGlvbiA9IHBsYWNlbWVudCA/IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpIDogbnVsbDtcbiAgdmFyIGNvbW1vblggPSByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCAvIDIgLSBlbGVtZW50LndpZHRoIC8gMjtcbiAgdmFyIGNvbW1vblkgPSByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHQgLyAyIC0gZWxlbWVudC5oZWlnaHQgLyAyO1xuICB2YXIgb2Zmc2V0cztcblxuICBzd2l0Y2ggKGJhc2VQbGFjZW1lbnQpIHtcbiAgICBjYXNlIHRvcDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55IC0gZWxlbWVudC5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgYm90dG9tOlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHJpZ2h0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgbGVmdDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54IC0gZWxlbWVudC53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54LFxuICAgICAgICB5OiByZWZlcmVuY2UueVxuICAgICAgfTtcbiAgfVxuXG4gIHZhciBtYWluQXhpcyA9IGJhc2VQbGFjZW1lbnQgPyBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCkgOiBudWxsO1xuXG4gIGlmIChtYWluQXhpcyAhPSBudWxsKSB7XG4gICAgdmFyIGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgICBzd2l0Y2ggKHZhcmlhdGlvbikge1xuICAgICAgY2FzZSBzdGFydDpcbiAgICAgICAgb2Zmc2V0c1ttYWluQXhpc10gPSBNYXRoLmZsb29yKG9mZnNldHNbbWFpbkF4aXNdKSAtIE1hdGguZmxvb3IocmVmZXJlbmNlW2xlbl0gLyAyIC0gZWxlbWVudFtsZW5dIC8gMik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIGVuZDpcbiAgICAgICAgb2Zmc2V0c1ttYWluQXhpc10gPSBNYXRoLmZsb29yKG9mZnNldHNbbWFpbkF4aXNdKSArIE1hdGguY2VpbChyZWZlcmVuY2VbbGVuXSAvIDIgLSBlbGVtZW50W2xlbl0gLyAyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9mZnNldHM7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVib3VuY2UoZm4pIHtcbiAgdmFyIHBlbmRpbmc7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFwZW5kaW5nKSB7XG4gICAgICBwZW5kaW5nID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcGVuZGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICByZXNvbHZlKGZuKCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwZW5kaW5nO1xuICB9O1xufSIsImltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBnZXRDbGlwcGluZ1JlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRDbGlwcGluZ1JlY3QuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBjb21wdXRlT2Zmc2V0cyBmcm9tIFwiLi9jb21wdXRlT2Zmc2V0cy5qc1wiO1xuaW1wb3J0IHJlY3RUb0NsaWVudFJlY3QgZnJvbSBcIi4vcmVjdFRvQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IHsgY2xpcHBpbmdQYXJlbnRzLCByZWZlcmVuY2UsIHBvcHBlciwgYm90dG9tLCB0b3AsIHJpZ2h0LCBiYXNlUGxhY2VtZW50cywgdmlld3BvcnQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gXCIuLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IG1lcmdlUGFkZGluZ09iamVjdCBmcm9tIFwiLi9tZXJnZVBhZGRpbmdPYmplY3QuanNcIjtcbmltcG9ydCBleHBhbmRUb0hhc2hNYXAgZnJvbSBcIi4vZXhwYW5kVG9IYXNoTWFwLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBfb3B0aW9ucyRwbGFjZW1lbnQgPSBfb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucyRwbGFjZW1lbnQgPT09IHZvaWQgMCA/IHN0YXRlLnBsYWNlbWVudCA6IF9vcHRpb25zJHBsYWNlbWVudCxcbiAgICAgIF9vcHRpb25zJGJvdW5kYXJ5ID0gX29wdGlvbnMuYm91bmRhcnksXG4gICAgICBib3VuZGFyeSA9IF9vcHRpb25zJGJvdW5kYXJ5ID09PSB2b2lkIDAgPyBjbGlwcGluZ1BhcmVudHMgOiBfb3B0aW9ucyRib3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zJHJvb3RCb3VuZGFyeSA9PT0gdm9pZCAwID8gdmlld3BvcnQgOiBfb3B0aW9ucyRyb290Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRlbGVtZW50Q29udGUgPSBfb3B0aW9ucy5lbGVtZW50Q29udGV4dCxcbiAgICAgIGVsZW1lbnRDb250ZXh0ID0gX29wdGlvbnMkZWxlbWVudENvbnRlID09PSB2b2lkIDAgPyBwb3BwZXIgOiBfb3B0aW9ucyRlbGVtZW50Q29udGUsXG4gICAgICBfb3B0aW9ucyRhbHRCb3VuZGFyeSA9IF9vcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBfb3B0aW9ucyRhbHRCb3VuZGFyeSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRhbHRCb3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJHBhZGRpbmcgPSBfb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgcGFkZGluZyA9IF9vcHRpb25zJHBhZGRpbmcgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyRwYWRkaW5nO1xuICB2YXIgcGFkZGluZ09iamVjdCA9IG1lcmdlUGFkZGluZ09iamVjdCh0eXBlb2YgcGFkZGluZyAhPT0gJ251bWJlcicgPyBwYWRkaW5nIDogZXhwYW5kVG9IYXNoTWFwKHBhZGRpbmcsIGJhc2VQbGFjZW1lbnRzKSk7XG4gIHZhciBhbHRDb250ZXh0ID0gZWxlbWVudENvbnRleHQgPT09IHBvcHBlciA/IHJlZmVyZW5jZSA6IHBvcHBlcjtcbiAgdmFyIHJlZmVyZW5jZUVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW2FsdEJvdW5kYXJ5ID8gYWx0Q29udGV4dCA6IGVsZW1lbnRDb250ZXh0XTtcbiAgdmFyIGNsaXBwaW5nQ2xpZW50UmVjdCA9IGdldENsaXBwaW5nUmVjdChpc0VsZW1lbnQoZWxlbWVudCkgPyBlbGVtZW50IDogZWxlbWVudC5jb250ZXh0RWxlbWVudCB8fCBnZXREb2N1bWVudEVsZW1lbnQoc3RhdGUuZWxlbWVudHMucG9wcGVyKSwgYm91bmRhcnksIHJvb3RCb3VuZGFyeSk7XG4gIHZhciByZWZlcmVuY2VDbGllbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHJlZmVyZW5jZUVsZW1lbnQpO1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IGNvbXB1dGVPZmZzZXRzKHtcbiAgICByZWZlcmVuY2U6IHJlZmVyZW5jZUNsaWVudFJlY3QsXG4gICAgZWxlbWVudDogcG9wcGVyUmVjdCxcbiAgICBzdHJhdGVneTogJ2Fic29sdXRlJyxcbiAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudFxuICB9KTtcbiAgdmFyIHBvcHBlckNsaWVudFJlY3QgPSByZWN0VG9DbGllbnRSZWN0KE9iamVjdC5hc3NpZ24oe30sIHBvcHBlclJlY3QsIHt9LCBwb3BwZXJPZmZzZXRzKSk7XG4gIHZhciBlbGVtZW50Q2xpZW50UmVjdCA9IGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgPyBwb3BwZXJDbGllbnRSZWN0IDogcmVmZXJlbmNlQ2xpZW50UmVjdDsgLy8gcG9zaXRpdmUgPSBvdmVyZmxvd2luZyB0aGUgY2xpcHBpbmcgcmVjdFxuICAvLyAwIG9yIG5lZ2F0aXZlID0gd2l0aGluIHRoZSBjbGlwcGluZyByZWN0XG5cbiAgdmFyIG92ZXJmbG93T2Zmc2V0cyA9IHtcbiAgICB0b3A6IGNsaXBwaW5nQ2xpZW50UmVjdC50b3AgLSBlbGVtZW50Q2xpZW50UmVjdC50b3AgKyBwYWRkaW5nT2JqZWN0LnRvcCxcbiAgICBib3R0b206IGVsZW1lbnRDbGllbnRSZWN0LmJvdHRvbSAtIGNsaXBwaW5nQ2xpZW50UmVjdC5ib3R0b20gKyBwYWRkaW5nT2JqZWN0LmJvdHRvbSxcbiAgICBsZWZ0OiBjbGlwcGluZ0NsaWVudFJlY3QubGVmdCAtIGVsZW1lbnRDbGllbnRSZWN0LmxlZnQgKyBwYWRkaW5nT2JqZWN0LmxlZnQsXG4gICAgcmlnaHQ6IGVsZW1lbnRDbGllbnRSZWN0LnJpZ2h0IC0gY2xpcHBpbmdDbGllbnRSZWN0LnJpZ2h0ICsgcGFkZGluZ09iamVjdC5yaWdodFxuICB9O1xuICB2YXIgb2Zmc2V0RGF0YSA9IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0OyAvLyBPZmZzZXRzIGNhbiBiZSBhcHBsaWVkIG9ubHkgdG8gdGhlIHBvcHBlciBlbGVtZW50XG5cbiAgaWYgKGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgJiYgb2Zmc2V0RGF0YSkge1xuICAgIHZhciBvZmZzZXQgPSBvZmZzZXREYXRhW3BsYWNlbWVudF07XG4gICAgT2JqZWN0LmtleXMob3ZlcmZsb3dPZmZzZXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBtdWx0aXBseSA9IFtyaWdodCwgYm90dG9tXS5pbmRleE9mKGtleSkgPj0gMCA/IDEgOiAtMTtcbiAgICAgIHZhciBheGlzID0gW3RvcCwgYm90dG9tXS5pbmRleE9mKGtleSkgPj0gMCA/ICd5JyA6ICd4JztcbiAgICAgIG92ZXJmbG93T2Zmc2V0c1trZXldICs9IG9mZnNldFtheGlzXSAqIG11bHRpcGx5O1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG92ZXJmbG93T2Zmc2V0cztcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBleHBhbmRUb0hhc2hNYXAodmFsdWUsIGtleXMpIHtcbiAgcmV0dXJuIGtleXMucmVkdWNlKGZ1bmN0aW9uIChoYXNoTWFwLCBrZXkpIHtcbiAgICBoYXNoTWFwW2tleV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gaGFzaE1hcDtcbiAgfSwge30pO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZvcm1hdChzdHIpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIFtdLmNvbmNhdChhcmdzKS5yZWR1Y2UoZnVuY3Rpb24gKHAsIGMpIHtcbiAgICByZXR1cm4gcC5yZXBsYWNlKC8lcy8sIGMpO1xuICB9LCBzdHIpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEFsdEF4aXMoYXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xufSIsImltcG9ydCB7IGF1dG8gfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRGcmVzaFNpZGVPYmplY3QoKSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwXG4gIH07XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpID49IDAgPyAneCcgOiAneSc7XG59IiwidmFyIGhhc2ggPSB7XG4gIGxlZnQ6ICdyaWdodCcsXG4gIHJpZ2h0OiAnbGVmdCcsXG4gIGJvdHRvbTogJ3RvcCcsXG4gIHRvcDogJ2JvdHRvbSdcbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcbiAgfSk7XG59IiwidmFyIGhhc2ggPSB7XG4gIHN0YXJ0OiAnZW5kJyxcbiAgZW5kOiAnc3RhcnQnXG59O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvc3RhcnR8ZW5kL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGhhc2hbbWF0Y2hlZF07XG4gIH0pO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFZhcmlhdGlvbihwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlQnlOYW1lKG1vZGlmaWVycykge1xuICB2YXIgbWVyZ2VkID0gbW9kaWZpZXJzLnJlZHVjZShmdW5jdGlvbiAobWVyZ2VkLCBjdXJyZW50KSB7XG4gICAgdmFyIGV4aXN0aW5nID0gbWVyZ2VkW2N1cnJlbnQubmFtZV07XG4gICAgbWVyZ2VkW2N1cnJlbnQubmFtZV0gPSBleGlzdGluZyA/IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLCB7fSwgY3VycmVudCwge1xuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgZXhpc3Rpbmcub3B0aW9ucywge30sIGN1cnJlbnQub3B0aW9ucyksXG4gICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZy5kYXRhLCB7fSwgY3VycmVudC5kYXRhKVxuICAgIH0pIDogY3VycmVudDtcbiAgICByZXR1cm4gbWVyZ2VkO1xuICB9LCB7fSk7IC8vIElFMTEgZG9lcyBub3Qgc3VwcG9ydCBPYmplY3QudmFsdWVzXG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1lcmdlZCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gbWVyZ2VkW2tleV07XG4gIH0pO1xufSIsImltcG9ydCBnZXRGcmVzaFNpZGVPYmplY3QgZnJvbSBcIi4vZ2V0RnJlc2hTaWRlT2JqZWN0LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZXJnZVBhZGRpbmdPYmplY3QocGFkZGluZ09iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZ2V0RnJlc2hTaWRlT2JqZWN0KCksIHt9LCBwYWRkaW5nT2JqZWN0KTtcbn0iLCJpbXBvcnQgeyBtb2RpZmllclBoYXNlcyB9IGZyb20gXCIuLi9lbnVtcy5qc1wiOyAvLyBzb3VyY2U6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ5ODc1MjU1XG5cbmZ1bmN0aW9uIG9yZGVyKG1vZGlmaWVycykge1xuICB2YXIgbWFwID0gbmV3IE1hcCgpO1xuICB2YXIgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICBtYXAuc2V0KG1vZGlmaWVyLm5hbWUsIG1vZGlmaWVyKTtcbiAgfSk7IC8vIE9uIHZpc2l0aW5nIG9iamVjdCwgY2hlY2sgZm9yIGl0cyBkZXBlbmRlbmNpZXMgYW5kIHZpc2l0IHRoZW0gcmVjdXJzaXZlbHlcblxuICBmdW5jdGlvbiBzb3J0KG1vZGlmaWVyKSB7XG4gICAgdmlzaXRlZC5hZGQobW9kaWZpZXIubmFtZSk7XG4gICAgdmFyIHJlcXVpcmVzID0gW10uY29uY2F0KG1vZGlmaWVyLnJlcXVpcmVzIHx8IFtdLCBtb2RpZmllci5yZXF1aXJlc0lmRXhpc3RzIHx8IFtdKTtcbiAgICByZXF1aXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXApIHtcbiAgICAgIGlmICghdmlzaXRlZC5oYXMoZGVwKSkge1xuICAgICAgICB2YXIgZGVwTW9kaWZpZXIgPSBtYXAuZ2V0KGRlcCk7XG5cbiAgICAgICAgaWYgKGRlcE1vZGlmaWVyKSB7XG4gICAgICAgICAgc29ydChkZXBNb2RpZmllcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXN1bHQucHVzaChtb2RpZmllcik7XG4gIH1cblxuICBtb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICBpZiAoIXZpc2l0ZWQuaGFzKG1vZGlmaWVyLm5hbWUpKSB7XG4gICAgICAvLyBjaGVjayBmb3IgdmlzaXRlZCBvYmplY3RcbiAgICAgIHNvcnQobW9kaWZpZXIpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG9yZGVyTW9kaWZpZXJzKG1vZGlmaWVycykge1xuICAvLyBvcmRlciBiYXNlZCBvbiBkZXBlbmRlbmNpZXNcbiAgdmFyIG9yZGVyZWRNb2RpZmllcnMgPSBvcmRlcihtb2RpZmllcnMpOyAvLyBvcmRlciBiYXNlZCBvbiBwaGFzZVxuXG4gIHJldHVybiBtb2RpZmllclBoYXNlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGhhc2UpIHtcbiAgICByZXR1cm4gYWNjLmNvbmNhdChvcmRlcmVkTW9kaWZpZXJzLmZpbHRlcihmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICAgIHJldHVybiBtb2RpZmllci5waGFzZSA9PT0gcGhhc2U7XG4gICAgfSkpO1xuICB9LCBbXSk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVjdFRvQ2xpZW50UmVjdChyZWN0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCByZWN0LCB7XG4gICAgbGVmdDogcmVjdC54LFxuICAgIHRvcDogcmVjdC55LFxuICAgIHJpZ2h0OiByZWN0LnggKyByZWN0LndpZHRoLFxuICAgIGJvdHRvbTogcmVjdC55ICsgcmVjdC5oZWlnaHRcbiAgfSk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdW5pcXVlQnkoYXJyLCBmbikge1xuICB2YXIgaWRlbnRpZmllcnMgPSBuZXcgU2V0KCk7XG4gIHJldHVybiBhcnIuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgdmFyIGlkZW50aWZpZXIgPSBmbihpdGVtKTtcblxuICAgIGlmICghaWRlbnRpZmllcnMuaGFzKGlkZW50aWZpZXIpKSB7XG4gICAgICBpZGVudGlmaWVycy5hZGQoaWRlbnRpZmllcik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xufSIsImltcG9ydCBmb3JtYXQgZnJvbSBcIi4vZm9ybWF0LmpzXCI7XG5pbXBvcnQgeyBtb2RpZmllclBoYXNlcyB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xudmFyIElOVkFMSURfTU9ESUZJRVJfRVJST1IgPSAnUG9wcGVyOiBtb2RpZmllciBcIiVzXCIgcHJvdmlkZWQgYW4gaW52YWxpZCAlcyBwcm9wZXJ0eSwgZXhwZWN0ZWQgJXMgYnV0IGdvdCAlcyc7XG52YXIgTUlTU0lOR19ERVBFTkRFTkNZX0VSUk9SID0gJ1BvcHBlcjogbW9kaWZpZXIgXCIlc1wiIHJlcXVpcmVzIFwiJXNcIiwgYnV0IFwiJXNcIiBtb2RpZmllciBpcyBub3QgYXZhaWxhYmxlJztcbnZhciBWQUxJRF9QUk9QRVJUSUVTID0gWyduYW1lJywgJ2VuYWJsZWQnLCAncGhhc2UnLCAnZm4nLCAnZWZmZWN0JywgJ3JlcXVpcmVzJywgJ29wdGlvbnMnXTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHZhbGlkYXRlTW9kaWZpZXJzKG1vZGlmaWVycykge1xuICBtb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICBPYmplY3Qua2V5cyhtb2RpZmllcikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICBjYXNlICduYW1lJzpcbiAgICAgICAgICBpZiAodHlwZW9mIG1vZGlmaWVyLm5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGZvcm1hdChJTlZBTElEX01PRElGSUVSX0VSUk9SLCBTdHJpbmcobW9kaWZpZXIubmFtZSksICdcIm5hbWVcIicsICdcInN0cmluZ1wiJywgXCJcXFwiXCIgKyBTdHJpbmcobW9kaWZpZXIubmFtZSkgKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2VuYWJsZWQnOlxuICAgICAgICAgIGlmICh0eXBlb2YgbW9kaWZpZXIuZW5hYmxlZCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGZvcm1hdChJTlZBTElEX01PRElGSUVSX0VSUk9SLCBtb2RpZmllci5uYW1lLCAnXCJlbmFibGVkXCInLCAnXCJib29sZWFuXCInLCBcIlxcXCJcIiArIFN0cmluZyhtb2RpZmllci5lbmFibGVkKSArIFwiXFxcIlwiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3BoYXNlJzpcbiAgICAgICAgICBpZiAobW9kaWZpZXJQaGFzZXMuaW5kZXhPZihtb2RpZmllci5waGFzZSkgPCAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGZvcm1hdChJTlZBTElEX01PRElGSUVSX0VSUk9SLCBtb2RpZmllci5uYW1lLCAnXCJwaGFzZVwiJywgXCJlaXRoZXIgXCIgKyBtb2RpZmllclBoYXNlcy5qb2luKCcsICcpLCBcIlxcXCJcIiArIFN0cmluZyhtb2RpZmllci5waGFzZSkgKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2ZuJzpcbiAgICAgICAgICBpZiAodHlwZW9mIG1vZGlmaWVyLmZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGZvcm1hdChJTlZBTElEX01PRElGSUVSX0VSUk9SLCBtb2RpZmllci5uYW1lLCAnXCJmblwiJywgJ1wiZnVuY3Rpb25cIicsIFwiXFxcIlwiICsgU3RyaW5nKG1vZGlmaWVyLmZuKSArIFwiXFxcIlwiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZWZmZWN0JzpcbiAgICAgICAgICBpZiAodHlwZW9mIG1vZGlmaWVyLmVmZmVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihmb3JtYXQoSU5WQUxJRF9NT0RJRklFUl9FUlJPUiwgbW9kaWZpZXIubmFtZSwgJ1wiZWZmZWN0XCInLCAnXCJmdW5jdGlvblwiJywgXCJcXFwiXCIgKyBTdHJpbmcobW9kaWZpZXIuZm4pICsgXCJcXFwiXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdyZXF1aXJlcyc6XG4gICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1vZGlmaWVyLnJlcXVpcmVzKSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihmb3JtYXQoSU5WQUxJRF9NT0RJRklFUl9FUlJPUiwgbW9kaWZpZXIubmFtZSwgJ1wicmVxdWlyZXNcIicsICdcImFycmF5XCInLCBcIlxcXCJcIiArIFN0cmluZyhtb2RpZmllci5yZXF1aXJlcykgKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3JlcXVpcmVzSWZFeGlzdHMnOlxuICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtb2RpZmllci5yZXF1aXJlc0lmRXhpc3RzKSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihmb3JtYXQoSU5WQUxJRF9NT0RJRklFUl9FUlJPUiwgbW9kaWZpZXIubmFtZSwgJ1wicmVxdWlyZXNJZkV4aXN0c1wiJywgJ1wiYXJyYXlcIicsIFwiXFxcIlwiICsgU3RyaW5nKG1vZGlmaWVyLnJlcXVpcmVzSWZFeGlzdHMpICsgXCJcXFwiXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdvcHRpb25zJzpcbiAgICAgICAgY2FzZSAnZGF0YSc6XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiUG9wcGVySlM6IGFuIGludmFsaWQgcHJvcGVydHkgaGFzIGJlZW4gcHJvdmlkZWQgdG8gdGhlIFxcXCJcIiArIG1vZGlmaWVyLm5hbWUgKyBcIlxcXCIgbW9kaWZpZXIsIHZhbGlkIHByb3BlcnRpZXMgYXJlIFwiICsgVkFMSURfUFJPUEVSVElFUy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlxcXCJcIiArIHMgKyBcIlxcXCJcIjtcbiAgICAgICAgICB9KS5qb2luKCcsICcpICsgXCI7IGJ1dCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgd2FzIHByb3ZpZGVkLlwiKTtcbiAgICAgIH1cblxuICAgICAgbW9kaWZpZXIucmVxdWlyZXMgJiYgbW9kaWZpZXIucmVxdWlyZXMuZm9yRWFjaChmdW5jdGlvbiAocmVxdWlyZW1lbnQpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVycy5maW5kKGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgICByZXR1cm4gbW9kLm5hbWUgPT09IHJlcXVpcmVtZW50O1xuICAgICAgICB9KSA9PSBudWxsKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihmb3JtYXQoTUlTU0lOR19ERVBFTkRFTkNZX0VSUk9SLCBTdHJpbmcobW9kaWZpZXIubmFtZSksIHJlcXVpcmVtZW50LCByZXF1aXJlbWVudCkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gd2l0aGluKG1pbiwgdmFsdWUsIG1heCkge1xuICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbih2YWx1ZSwgbWF4KSk7XG59IiwidmFyIENoYW5nZXNldCA9IHJlcXVpcmUoJy4vQ2hhbmdlc2V0JylcbiAgLCBSZXRhaW4gPSByZXF1aXJlKCcuL29wZXJhdGlvbnMvUmV0YWluJylcbiAgLCBTa2lwID0gcmVxdWlyZSgnLi9vcGVyYXRpb25zL1NraXAnKVxuICAsIEluc2VydCA9IHJlcXVpcmUoJy4vb3BlcmF0aW9ucy9JbnNlcnQnKVxuXG5mdW5jdGlvbiBCdWlsZGVyKCkge1xuICB0aGlzLm9wcyA9IFtdXG4gIHRoaXMuYWRkZW5kdW0gPSAnJ1xuICB0aGlzLnJlbW92ZW5kdW0gPSAnJ1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1aWxkZXJcblxuQnVpbGRlci5wcm90b3R5cGUua2VlcCA9XG5CdWlsZGVyLnByb3RvdHlwZS5yZXRhaW4gPSBmdW5jdGlvbihsZW4pIHtcbiAgdGhpcy5vcHMucHVzaChuZXcgUmV0YWluKGxlbikpXG4gIHJldHVybiB0aGlzXG59XG5cbkJ1aWxkZXIucHJvdG90eXBlLmRlbGV0ZSA9XG5CdWlsZGVyLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24oc3RyKSB7XG4gIHRoaXMucmVtb3ZlbmR1bSArPSBzdHJcbiAgdGhpcy5vcHMucHVzaChuZXcgU2tpcChzdHIubGVuZ3RoKSlcbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVpbGRlci5wcm90b3R5cGUuYWRkID1cbkJ1aWxkZXIucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKHN0cikge1xuICB0aGlzLmFkZGVuZHVtICs9IHN0clxuICB0aGlzLm9wcy5wdXNoKG5ldyBJbnNlcnQoc3RyLmxlbmd0aCkpXG4gIHJldHVybiB0aGlzXG59XG5cbkJ1aWxkZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY3MgPSBuZXcgQ2hhbmdlc2V0KHRoaXMub3BzKVxuICBjcy5hZGRlbmR1bSA9IHRoaXMuYWRkZW5kdW1cbiAgY3MucmVtb3ZlbmR1bSA9IHRoaXMucmVtb3ZlbmR1bVxuICByZXR1cm4gY3Ncbn1cbiIsIi8qIVxuICogY2hhbmdlc2V0c1xuICogQSBDaGFuZ2VzZXQgbGlicmFyeSBpbmNvcnBvcmF0aW5nIG9wZXJhdGlvbmFsIHRyYW5zZm9ybWF0aW9uIChPVClcbiAqIENvcHlyaWdodCAyMDEyIGJ5IE1hcmNlbCBLbGVociA8bWtsZWhyQGdteC5uZXQ+XG4gKlxuICogKE1JVCBMSUNFTlNFKVxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKipcbiAqIEEgc2VxdWVuY2Ugb2YgY29uc2VjdXRpdmUgb3BlcmF0aW9uc1xuICpcbiAqIEBwYXJhbSBvcHMuLiA8T3BlcmF0aW9uPiBhbGwgcGFzc2VkIG9wZXJhdGlvbnMgd2lsbCBiZSBhZGRlZCB0byB0aGUgY2hhbmdlc2V0XG4gKi9cbmZ1bmN0aW9uIENoYW5nZXNldChvcHMvKm9yIG9wcy4uKi8pIHtcbiAgdGhpcy5hZGRlbmR1bSA9IFwiXCJcbiAgdGhpcy5yZW1vdmVuZHVtID0gXCJcIlxuICB0aGlzLmlucHV0TGVuZ3RoID0gMFxuICB0aGlzLm91dHB1dExlbmd0aCA9IDBcblxuICBpZighQXJyYXkuaXNBcnJheShvcHMpKSBvcHMgPSBhcmd1bWVudHNcbiAgZm9yKHZhciBpPTA7IGk8b3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5wdXNoKG9wc1tpXSlcbiAgICB0aGlzLmlucHV0TGVuZ3RoICs9IG9wc1tpXS5pbnB1dFxuICAgIHRoaXMub3V0cHV0TGVuZ3RoICs9IG9wc1tpXS5vdXRwdXRcbiAgfVxufVxuXG4vLyBUcnVlIGluaGVyaXRhbmNlXG5DaGFuZ2VzZXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBcnJheS5wcm90b3R5cGUsIHtcbiAgY29uc3RydWN0b3I6IHtcbiAgICB2YWx1ZTogQ2hhbmdlc2V0LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9XG59KTtcbm1vZHVsZS5leHBvcnRzID0gQ2hhbmdlc2V0XG5cbnZhciBUZXh0VHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UZXh0VHJhbnNmb3JtJylcbiAgLCBDaGFuZ2VzZXRUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL0NoYW5nZXNldFRyYW5zZm9ybScpXG5cbnZhciBSZXRhaW4gPSByZXF1aXJlKCcuL29wZXJhdGlvbnMvUmV0YWluJylcbiAgLCBTa2lwID0gcmVxdWlyZSgnLi9vcGVyYXRpb25zL1NraXAnKVxuICAsIEluc2VydCA9IHJlcXVpcmUoJy4vb3BlcmF0aW9ucy9JbnNlcnQnKVxuXG52YXIgQnVpbGRlciA9IHJlcXVpcmUoJy4vQnVpbGRlcicpXG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBvcHMgdGhhdCBhcmUgd2l0aGluIHRoZSBwYXNzZWQgcmFuZ2VcbiAqIChvbmx5IG9wLmlucHV0IGlzIGNvdW50ZWQ7IHRodXMgbm90IGNvdW50aW5nIGluc2VydHMgdG8gdGhlIHJhbmdlIGxlbmd0aCwgeWV0IHRoZXkgYXJlIHBhcnQgb2YgdGhlIHJhbmdlKVxuICovXG5DaGFuZ2VzZXQucHJvdG90eXBlLnN1YnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIGxlbikge1xuICB2YXIgcmFuZ2UgPSBbXVxuICAgICwgb3AsIG9wbGVuXG4gICAgLCBsPTBcbiAgZm9yKHZhciBpPTAsIHBvcz0wOyBpPHRoaXMubGVuZ3RoICYmIGwgPCBsZW47IGkrKykge1xuICAgIG9wID0gdGhpc1tpXVxuICAgIGlmKG9wLmlucHV0K3BvcyA+PSBzdGFydCkge1xuICAgICAgaWYob3AuaW5wdXQpIHtcbiAgICAgICAgaWYob3AubGVuZ3RoICE9IEluZmluaXR5KSBvcGxlbiA9IG9wLmxlbmd0aCAtTWF0aC5tYXgoMCwgc3RhcnQtcG9zKSAtTWF0aC5tYXgoMCwgKG9wLmxlbmd0aCtwb3MpLShzdGFydCtsZW4pKVxuICAgICAgICBlbHNlIG9wbGVuID0gbGVuXG4gICAgICAgIGlmIChvcGxlbiAhPT0gMCkgcmFuZ2UucHVzaCggb3AuZGVyaXZlKG9wbGVuKSApIC8vIChEb24ndCBjb3B5IG92ZXIgbW9yZSB0aGFuIGxlbiBwYXJhbSBhbGxvd3MpXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmFuZ2UucHVzaCggb3AuZGVyaXZlKG9wLmxlbmd0aCkgKVxuICAgICAgICBvcGxlbiA9IDBcbiAgICAgIH1cbiAgICAgIGwgKz0gb3BsZW5cbiAgICB9XG4gICAgcG9zICs9IG9wLmlucHV0XG4gIH1cbiAgcmV0dXJuIHJhbmdlXG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIGNoYW5nZXNldHMgKHRoYXQgYXJlIGJhc2VkIG9uIHRoZSBzYW1lIHN0YXRlISkgc28gdGhhdCB0aGUgcmVzdWx0aW5nIGNoYW5nc2VzZXRcbiAqIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXMgYm90aCBvcmlnbmFsIG9uZXMgYXBwbGllZCBvbmUgYWZ0ZXIgdGhlIG90aGVyXG4gKlxuICogQHBhcmFtIG90aGVyQ3MgPENoYW5nZXNldD5cbiAqIEBwYXJhbSBsZWZ0IDxib29sZWFuPiBXaGljaCBvcCB0byBjaG9vc2UgaWYgdGhlcmUncyBhbiBpbnNlcnQgdGllIChJZiB5b3UgdXNlIHRoaXMgZnVuY3Rpb24gaW4gYSBkaXN0cmlidXRlZCwgc3luY2hyb25vdXMgZW52aXJvbm1lbnQsIGJlIHN1cmUgdG8gaW52ZXJ0IHRoaXMgcGFyYW0gb24gdGhlIG90aGVyIHNpdGUsIG90aGVyd2lzZSBpdCBjYW4gYmUgb21pdHRlZCBzYWZlbHkpKVxuICogQHJldHVybnMgPENoYW5nZXNldD5cbiAqL1xuQ2hhbmdlc2V0LnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uKG90aGVyQ3MsIGxlZnQpIHtcbiAgaWYoIShvdGhlckNzIGluc3RhbmNlb2YgQ2hhbmdlc2V0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhICM8Q2hhbmdlc2V0PiwgYnV0IHJlY2VpdmVkICcrb3RoZXJDcy5fX3Byb3RvX18uY29uc3RydWN0b3IubmFtZSlcbiAgfVxuXG4gIGlmKG90aGVyQ3MuaW5wdXRMZW5ndGggIT09IHRoaXMub3V0cHV0TGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2hhbmdlc2V0IGxlbmd0aHMgZm9yIG1lcmdpbmcgZG9uJ3QgbWF0Y2ghIElucHV0IGxlbmd0aCBvZiB5b3VuZ2VyIGNzOiBcIitvdGhlckNzLmlucHV0TGVuZ3RoKycsIG91dHB1dCBsZW5ndGggb2Ygb2xkZXIgY3M6Jyt0aGlzLm91dHB1dExlbmd0aClcbiAgfVxuXG4gIHZhciBuZXdvcHMgPSBbXVxuICAgICwgYWRkUHRyMSA9IDBcbiAgICAsIHJlbVB0cjEgPSAwXG4gICAgLCBhZGRQdHIyID0gMFxuICAgICwgcmVtUHRyMiA9IDBcbiAgICAsIG5ld2FkZGVuZHVtID0gJydcbiAgICAsIG5ld3JlbW92ZW5kdW0gPSAnJ1xuXG4gIHppcCh0aGlzLCBvdGhlckNzLCBmdW5jdGlvbihvcDEsIG9wMikge1xuICAgIC8vIGNvbnNvbGUubG9nKG5ld29wcylcbiAgICAvLyBjb25zb2xlLmxvZyhvcDEsIG9wMilcblxuICAgIC8vIEknbSBkZWxldGluZyBzb21ldGhpbmcgLS0gdGhlIG90aGVyIGNzIGNhbid0IGtub3cgdGhhdCwgc28ganVzdCBvdmVydGFrZSBteSBvcFxuICAgIGlmKG9wMSAmJiAhb3AxLm91dHB1dCkge1xuICAgICAgbmV3b3BzLnB1c2gob3AxLm1lcmdlKCkuY2xvbmUoKSlcbiAgICAgIG5ld3JlbW92ZW5kdW0gKz0gdGhpcy5yZW1vdmVuZHVtLnN1YnN0cihyZW1QdHIxLCBvcDEubGVuZ3RoKSAvLyBvdmVydGFrZSBhZGRlZCBjaGFyc1xuICAgICAgcmVtUHRyMSArPSBvcDEubGVuZ3RoXG4gICAgICBvcDEubGVuZ3RoID0gMCAvLyBkb24ndCBnaW1tZSB0aGF0IG9uZSBhZ2Fpbi5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIG9wMiBpcyBhbiBpbnNlcnRcbiAgICBpZihvcDIgJiYgIW9wMi5pbnB1dCkge1xuICAgICAgbmV3b3BzLnB1c2gob3AyLm1lcmdlKCkuY2xvbmUoKSlcbiAgICAgIG5ld2FkZGVuZHVtICs9IG90aGVyQ3MuYWRkZW5kdW0uc3Vic3RyKGFkZFB0cjIsIG9wMi5sZW5ndGgpIC8vIG92ZXJ0YWtlIGFkZGVkIGNoYXJzXG4gICAgICBhZGRQdHIyICs9IG9wMi5sZW5ndGhcbiAgICAgIG9wMi5sZW5ndGggPSAwIC8vIGRvbid0IGdpbW1lIHRoYXQgb25lIGFnYWluLlxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gb3AyIGlzIGVpdGhlciBhIHJldGFpbiBvciBhIHNraXBcbiAgICBpZihvcDIgJiYgb3AyLmlucHV0ICYmIG9wMSkge1xuICAgICAgLy8gb3AyIHJldGFpbnMgd2hhdGV2ZXIgd2UgZG8gaGVyZSAocmV0YWluIG9yIGluc2VydCksIHNvIGp1c3QgY2xvbmUgbXkgb3BcbiAgICAgIGlmKG9wMi5vdXRwdXQpIHtcbiAgICAgICAgbmV3b3BzLnB1c2gob3AxLm1lcmdlKG9wMikuY2xvbmUoKSlcbiAgICAgICAgaWYoIW9wMS5pbnB1dCkgeyAvLyBvdmVydGFrZSBhZGRlbmR1bVxuICAgICAgICAgIG5ld2FkZGVuZHVtICs9IHRoaXMuYWRkZW5kdW0uc3Vic3RyKGFkZFB0cjEsIG9wMS5sZW5ndGgpXG4gICAgICAgICAgYWRkUHRyMSArPSBvcDEubGVuZ3RoXG4gICAgICAgIH1cbiAgICAgICAgb3AxLmxlbmd0aCA9IDAgLy8gZG9uJ3QgZ2ltbWUgdGhlc2UgYWdhaW5cbiAgICAgICAgb3AyLmxlbmd0aCA9IDBcbiAgICAgIH1lbHNlXG5cbiAgICAgIC8vIG9wMiBkZWxldGVzIG15IHJldGFpbiBoZXJlLCBzbyBqdXN0IGNsb25lIHRoZSBkZWxldGVcbiAgICAgIC8vIChvcDEgY2FuIG9ubHkgYmUgYSByZXRhaW4gYW5kIG5vIHNraXAgaGVyZSwgY2F1c2Ugd2UndmUgaGFuZGxlZCBza2lwcyBhYm92ZSBhbHJlYWR5KVxuICAgICAgaWYoIW9wMi5vdXRwdXQgJiYgb3AxLmlucHV0KSB7XG4gICAgICAgIG5ld29wcy5wdXNoKG9wMi5tZXJnZShvcDEpLmNsb25lKCkpXG4gICAgICAgIG5ld3JlbW92ZW5kdW0gKz0gb3RoZXJDcy5yZW1vdmVuZHVtLnN1YnN0cihyZW1QdHIyLCBvcDIubGVuZ3RoKSAvLyBvdmVydGFrZSBhZGRlZCBjaGFyc1xuICAgICAgICByZW1QdHIyICs9IG9wMi5sZW5ndGhcbiAgICAgICAgb3AxLmxlbmd0aCA9IDAgLy8gZG9uJ3QgZ2ltbWUgdGhlc2UgYWdhaW5cbiAgICAgICAgb3AyLmxlbmd0aCA9IDBcbiAgICAgIH1lbHNlXG5cbiAgICAgIC8vb3RoZXJDcyBkZWxldGVzIHNvbWV0aGluZyBJIGFkZGVkICgtMSkgKzEgPSAwXG4gICAgICB7XG4gICAgICAgIGFkZFB0cjEgKz0gb3AxLmxlbmd0aFxuICAgICAgICBvcDEubGVuZ3RoID0gMCAvLyBkb24ndCBnaW1tZSB0aGVzZSBhZ2FpblxuICAgICAgICBvcDIubGVuZ3RoID0gMFxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ29vcHMnLCBhcmd1bWVudHMpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdvb3BzLiBUaGlzIGNhc2UgaGFzblxcJ3QgYmVlbiBjb25zaWRlcmVkIGJ5IHRoZSBkZXZlbG9wZXIgKGVycm9yIGNvZGU6IFBCQ0FDKScpXG4gIH0uYmluZCh0aGlzKSlcblxuICB2YXIgbmV3Q3MgPSBuZXcgQ2hhbmdlc2V0KG5ld29wcylcbiAgbmV3Q3MuYWRkZW5kdW0gPSBuZXdhZGRlbmR1bVxuICBuZXdDcy5yZW1vdmVuZHVtID0gbmV3cmVtb3ZlbmR1bVxuXG4gIHJldHVybiBuZXdDc1xufVxuXG4vKipcbiAqIEEgcHJpdmF0ZSBhbmQgcXVpdGUgaGFuZHkgZnVuY3Rpb24gdGhhdCBzbGljZXMgb3BzIGludG8gZXF1YWxseSBsb25nIHBpZWNlcyBhbmQgYXBwbGllcyB0aGVtIG9uIGEgbWFwcGluZyBmdW5jdGlvblxuICogdGhhdCBjYW4gZGV0ZXJtaW5lIHRoZSBpdGVyYXRpb24gc3RlcHMgYnkgc2V0dGluZyBvcC5sZW5ndGggdG8gMCBvbiBhbiBvcCAoZXF1YWxzIHVzaW5nIC5uZXh0KCkgaW4gYSB1c3VhbCBpdGVyYXRvcilcbiAqL1xuZnVuY3Rpb24gemlwKGNzMSwgY3MyLCBmdW5jKSB7XG4gIHZhciBvcHN0YWNrMSA9IGNzMS5tYXAoZnVuY3Rpb24ob3ApIHtyZXR1cm4gb3AuY2xvbmUoKX0pIC8vIGNvcHkgb3BzXG4gICAgLCBvcHN0YWNrMiA9IGNzMi5tYXAoZnVuY3Rpb24ob3ApIHtyZXR1cm4gb3AuY2xvbmUoKX0pXG5cbiAgdmFyIG9wMiwgb3AxXG4gIHdoaWxlKG9wc3RhY2sxLmxlbmd0aCB8fCBvcHN0YWNrMi5sZW5ndGgpIHsvLyBpdGVyYXRlIHRocm91Z2ggYWxsIG91dHN0YW5kaW5nIG9wcyBvZiB0aGlzIGNzXG4gICAgb3AxID0gb3BzdGFjazFbMF0/IG9wc3RhY2sxWzBdLmNsb25lKCkgOiBudWxsXG4gICAgb3AyID0gb3BzdGFjazJbMF0/IG9wc3RhY2syWzBdLmNsb25lKCkgOiBudWxsXG5cbiAgICBpZihvcDEpIHtcbiAgICAgIGlmKG9wMikgb3AxID0gb3AxLmRlcml2ZShNYXRoLm1pbihvcDEubGVuZ3RoLCBvcDIubGVuZ3RoKSkgLy8gc2xpY2UgJ2VtIGludG8gZXF1YWxseSBsb25nIHBpZWNlc1xuICAgICAgaWYob3BzdGFjazFbMF0ubGVuZ3RoID4gb3AxLmxlbmd0aCkgb3BzdGFjazFbMF0gPSBvcHN0YWNrMVswXS5kZXJpdmUob3BzdGFjazFbMF0ubGVuZ3RoLW9wMS5sZW5ndGgpXG4gICAgICBlbHNlIG9wc3RhY2sxLnNoaWZ0KClcbiAgICB9XG5cbiAgICBpZihvcDIpIHtcbiAgICAgIGlmKG9wMSkgb3AyID0gb3AyLmRlcml2ZShNYXRoLm1pbihvcDEubGVuZ3RoLCBvcDIubGVuZ3RoKSkgLy8gc2xpY2UgJ2VtIGludG8gZXF1YWxseSBsb25nIHBpZWNlc1xuICAgICAgaWYob3BzdGFjazJbMF0ubGVuZ3RoID4gb3AyLmxlbmd0aCkgb3BzdGFjazJbMF0gPSBvcHN0YWNrMlswXS5kZXJpdmUob3BzdGFjazJbMF0ubGVuZ3RoLW9wMi5sZW5ndGgpXG4gICAgICBlbHNlIG9wc3RhY2syLnNoaWZ0KClcbiAgICB9XG5cbiAgICBmdW5jKG9wMSwgb3AyKVxuXG4gICAgaWYob3AxICYmIG9wMS5sZW5ndGgpIG9wc3RhY2sxLnVuc2hpZnQob3AxKVxuICAgIGlmKG9wMiAmJiBvcDIubGVuZ3RoKSBvcHN0YWNrMi51bnNoaWZ0KG9wMilcbiAgfVxufVxuXG4vKipcbiAqIEluY2x1c2lvbiBUcmFuc2Zvcm1hdGlvbiAoSVQpIG9yIEZvcndhcmQgVHJhbnNmb3JtYXRpb25cbiAqXG4gKiB0cmFuc2Zvcm1zIHRoZSBvcGVyYXRpb25zIG9mIHRoZSBjdXJyZW50IGNoYW5nZXNldCBhZ2FpbnN0IHRoZVxuICogYWxsIG9wZXJhdGlvbnMgaW4gYW5vdGhlciBjaGFuZ2VzZXQgaW4gc3VjaCBhIHdheSB0aGF0IHRoZVxuICogZWZmZWN0cyBvZiB0aGUgbGF0dGVyIGFyZSBlZmZlY3RpdmVseSBpbmNsdWRlZC5cbiAqIFRoaXMgaXMgYmFzaWNhbGx5IGxpa2UgYSBhcHBseWluZyB0aGUgb3RoZXIgY3Mgb24gdGhpcyBvbmUuXG4gKlxuICogQHBhcmFtIG90aGVyQ3MgPENoYW5nZXNldD5cbiAqIEBwYXJhbSBsZWZ0IDxib29sZWFuPiBXaGljaCBvcCB0byBjaG9vc2UgaWYgdGhlcmUncyBhbiBpbnNlcnQgdGllIChJZiB5b3UgdXNlIHRoaXMgZnVuY3Rpb24gaW4gYSBkaXN0cmlidXRlZCwgc3luY2hyb25vdXMgZW52aXJvbm1lbnQsIGJlIHN1cmUgdG8gaW52ZXJ0IHRoaXMgcGFyYW0gb24gdGhlIG90aGVyIHNpdGUsIG90aGVyd2lzZSBpdCBjYW4gYmUgb21pdHRlZCBzYWZlbHkpXG4gKlxuICogQHJldHVybnMgPENoYW5nZXNldD5cbiAqL1xuQ2hhbmdlc2V0LnByb3RvdHlwZS50cmFuc2Zvcm1BZ2FpbnN0ID0gZnVuY3Rpb24ob3RoZXJDcywgbGVmdCkge1xuICBpZighKG90aGVyQ3MgaW5zdGFuY2VvZiBDaGFuZ2VzZXQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBcmd1bWVudCB0byBDaGFuZ2VzZXQjdHJhbnNmb3JtQWdhaW5zdCBtdXN0IGJlIGEgIzxDaGFuZ2VzZXQ+LCBidXQgcmVjZWl2ZWQgJytvdGhlckNzLl9fcHJvdG9fXy5jb25zdHJ1Y3Rvci5uYW1lKVxuICB9XG5cbiAgaWYodGhpcy5pbnB1dExlbmd0aCAhPSBvdGhlckNzLmlucHV0TGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IHRyYW5zZm9ybSBjaGFuZ2VzZXRzIHdpdGggZGlmZmVyaW5nIGlucHV0TGVuZ3RoOiAnK3RoaXMuaW5wdXRMZW5ndGgrJyBhbmQgJytvdGhlckNzLmlucHV0TGVuZ3RoKVxuICB9XG5cbiAgdmFyIHRyYW5zZm9ybWF0aW9uID0gbmV3IENoYW5nZXNldFRyYW5zZm9ybSh0aGlzLCBbbmV3IFJldGFpbihJbmZpbml0eSldKVxuICBvdGhlckNzLmZvckVhY2goZnVuY3Rpb24ob3ApIHtcbiAgICB2YXIgbmV4dE9wID0gdGhpcy5zdWJyYW5nZSh0cmFuc2Zvcm1hdGlvbi5wb3MsIEluZmluaXR5KVswXSAvLyBuZXh0IG9wIG9mIHRoaXMgY3NcbiAgICBpZihuZXh0T3AgJiYgIW5leHRPcC5pbnB1dCAmJiAhb3AuaW5wdXQpIHsgLy8gdHdvIGluc2VydHMgdGllZDsgbGVmdCBicmVha3MgaXRcbiAgICAgIGlmIChsZWZ0KSB0cmFuc2Zvcm1hdGlvbi53cml0ZU91dHB1dCh0cmFuc2Zvcm1hdGlvbi5yZWFkSW5wdXQobmV4dE9wLmxlbmd0aCkpXG4gICAgfVxuICAgIG9wLmFwcGx5KHRyYW5zZm9ybWF0aW9uKVxuICB9LmJpbmQodGhpcykpXG5cbiAgcmV0dXJuIHRyYW5zZm9ybWF0aW9uLnJlc3VsdCgpXG59XG5cbi8qKlxuICogRXhjbHVzaW9uIFRyYW5zZm9ybWF0aW9uIChFVCkgb3IgQmFja3dhcmRzIFRyYW5zZm9ybWF0aW9uXG4gKlxuICogdHJhbnNmb3JtcyBhbGwgb3BlcmF0aW9ucyBpbiB0aGUgY3VycmVudCBjaGFuZ2VzZXQgYWdhaW5zdCB0aGUgb3BlcmF0aW9uc1xuICogaW4gYW5vdGhlciBjaGFuZ2VzZXQgaW4gc3VjaCBhIHdheSB0aGF0IHRoZSBpbXBhY3Qgb2YgdGhlIGxhdHRlciBhcmUgZWZmZWN0aXZlbHkgZXhjbHVkZWRcbiAqXG4gKiBAcGFyYW0gY2hhbmdlc2V0IDxDaGFuZ2VzZXQ+IHRoZSBjaGFuZ2VzZXQgdG8gc3Vic3RyYWN0IGZyb20gdGhpcyBvbmVcbiAqIEBwYXJhbSBsZWZ0IDxib29sZWFuPiBXaGljaCBvcCB0byBjaG9vc2UgaWYgdGhlcmUncyBhbiBpbnNlcnQgdGllIChJZiB5b3UgdXNlIHRoaXMgZnVuY3Rpb24gaW4gYSBkaXN0cmlidXRlZCwgc3luY2hyb25vdXMgZW52aXJvbm1lbnQsIGJlIHN1cmUgdG8gaW52ZXJ0IHRoaXMgcGFyYW0gb24gdGhlIG90aGVyIHNpdGUsIG90aGVyd2lzZSBpdCBjYW4gYmUgb21pdHRlZCBzYWZlbHkpXG4gKiBAcmV0dXJucyA8Q2hhbmdlc2V0PlxuICovXG5DaGFuZ2VzZXQucHJvdG90eXBlLnN1YnN0cmFjdCA9IGZ1bmN0aW9uKGNoYW5nZXNldCwgbGVmdCkge1xuICAvLyBUaGUgY3VycmVudCBvcGVyYXRpb25zIGFzc3VtZSB0aGF0IHRoZSBjaGFuZ2VzIGluXG4gIC8vIGBjaGFuZ2VzZXRgIGhhcHBlbmVkIGJlZm9yZSwgc28gZm9yIGVhY2ggb2YgdGhvc2Ugb3BzXG4gIC8vIHdlIGNyZWF0ZSBhbiBvcGVyYXRpb24gdGhhdCB1bmRvZXMgaXRzIGVmZmVjdCBhbmRcbiAgLy8gdHJhbnNmb3JtIGFsbCBvdXIgb3BlcmF0aW9ucyBvbiB0b3Agb2YgdGhlIGludmVyc2UgY2hhbmdlc1xuICByZXR1cm4gdGhpcy50cmFuc2Zvcm1BZ2FpbnN0KGNoYW5nZXNldC5pbnZlcnQoKSwgbGVmdClcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnZlcnNlIENoYW5nZXNldCBvZiB0aGUgY3VycmVudCBvbmVcbiAqXG4gKiBDaGFuZ2VzZXQuaW52ZXJ0KCkuYXBwbHkoQ2hhbmdlc2V0LmFwcGx5KGRvY3VtZW50KSkgPT0gZG9jdW1lbnRcbiAqL1xuQ2hhbmdlc2V0LnByb3RvdHlwZS5pbnZlcnQgPSBmdW5jdGlvbigpIHtcbiAgLy8gaW52ZXJ0IGFsbCBvcHNcbiAgdmFyIG5ld0NzID0gbmV3IENoYW5nZXNldCh0aGlzLm1hcChmdW5jdGlvbihvcCkge1xuICAgIHJldHVybiBvcC5pbnZlcnQoKVxuICB9KSlcblxuICAvLyByZW1vdmVuZHVtIGJlY29tZXMgYWRkZW5kdW0gYW5kIHZpY2UgdmVyc2FcbiAgbmV3Q3MuYWRkZW5kdW0gPSB0aGlzLnJlbW92ZW5kdW1cbiAgbmV3Q3MucmVtb3ZlbmR1bSA9IHRoaXMuYWRkZW5kdW1cblxuICByZXR1cm4gbmV3Q3Ncbn1cblxuLyoqXG4gKiBBcHBsaWVzIHRoaXMgY2hhbmdlc2V0IG9uIGEgdGV4dFxuICovXG5DaGFuZ2VzZXQucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgLy8gcHJlLXJlcXVpc2l0ZXNcbiAgaWYoaW5wdXQubGVuZ3RoICE9IHRoaXMuaW5wdXRMZW5ndGgpIHRocm93IG5ldyBFcnJvcignSW5wdXQgbGVuZ3RoIGRvZXNuXFwndCBtYXRjaCBleHBlY3RlZCBsZW5ndGguIGV4cGVjdGVkOiAnK3RoaXMuaW5wdXRMZW5ndGgrJzsgYWN0dWFsOiAnK2lucHV0Lmxlbmd0aClcblxuICB2YXIgb3BlcmF0aW9uID0gbmV3IFRleHRUcmFuc2Zvcm0oaW5wdXQsIHRoaXMuYWRkZW5kdW0sIHRoaXMucmVtb3ZlbmR1bSlcblxuICB0aGlzLmZvckVhY2goZnVuY3Rpb24ob3ApIHtcbiAgICAvLyBlYWNoIE9wZXJhdGlvbiBoYXMgYWNjZXNzIHRvIGFsbCBwb2ludGVycyBhcyB3ZWxsIGFzIHRoZSBpbnB1dCwgYWRkZW5kdW0gYW5kIHJlbW92ZW5kdW0gKHRoZSBsYXR0ZXIgYXJlIGltbXV0YWJsZSlcbiAgICBvcC5hcHBseShvcGVyYXRpb24pXG4gIH0uYmluZCh0aGlzKSlcblxuICByZXR1cm4gb3BlcmF0aW9uLnJlc3VsdCgpXG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiBzdHJpbmdzIGRlc2NyaWJpbmcgdGhpcyBjaGFuZ2VzZXQncyBvcGVyYXRpb25zXG4gKi9cbkNoYW5nZXNldC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaiA9IDBcbiAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKG9wKSB7XG4gICAgdmFyIHN0cmluZyA9ICcnXG5cbiAgICBpZighb3AuaW5wdXQpIHsgLy8gaWYgSW5zZXJ0XG4gICAgICBzdHJpbmcgPSB0aGlzLmFkZGVuZHVtLnN1YnN0cihqLG9wLmxlbmd0aClcbiAgICAgIGogKz0gb3AubGVuZ3RoXG4gICAgICByZXR1cm4gc3RyaW5nXG4gICAgfVxuXG4gICAgZm9yKHZhciBpPTA7IGk8b3AubGVuZ3RoOyBpKyspIHN0cmluZyArPSBvcC5zeW1ib2xcbiAgICByZXR1cm4gc3RyaW5nXG4gIH0uYmluZCh0aGlzKSkuam9pbignJylcbn1cblxuLyoqXG4gKiBTZXJpYWxpemVzIHRoZSBnaXZlbiBjaGFuZ2VzZXQgaW4gb3JkZXIgdG8gcmV0dXJuIGEgKGhvcGVmdWxseSkgbW9yZSBjb21wYWN0IHJlcHJlc2VudGF0aW9uXG4gKiB0aGFuIGpzb24gdGhhdCBjYW4gYmUgc2VudCB0aHJvdWdoIGEgbmV0d29yayBvciBzdG9yZWQgaW4gYSBkYXRhYmFzZVxuICpcbiAqIE51bWJlcnMgYXJlIGNvbnZlcnRlZCB0byB0aGUgYmFzZSAzNiwgdW5zYWZlIGNoYXJzIGluIHRoZSB0ZXh0IGFyZSB1cmxlbmNvZGVkXG4gKlxuICogQHBhcmFtIGNzIDxDaGFuZ2VzZXQ+IFRoZSBjaGFuZ2VzZXQgdG8gYmUgc2VyaWFsaXplZFxuICogQHJldHVybnMgPFN0cmluZz4gVGhlIHNlcmlhbGl6ZWQgY2hhbmdlc2V0XG4gKi9cbkNoYW5nZXNldC5wcm90b3R5cGUucGFjayA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGFja2VkID0gdGhpcy5tYXAoZnVuY3Rpb24ob3ApIHtcbiAgICByZXR1cm4gb3AucGFjaygpXG4gIH0pLmpvaW4oJycpXG5cbiAgdmFyIGFkZGVuZHVtID0gdGhpcy5hZGRlbmR1bS5yZXBsYWNlKC8lL2csICclMjUnKS5yZXBsYWNlKC9cXHwvZywgJyU3QycpXG4gICAgLCByZW1vdmVuZHVtID0gdGhpcy5yZW1vdmVuZHVtLnJlcGxhY2UoLyUvZywgJyUyNScpLnJlcGxhY2UoL1xcfC9nLCAnJTdDJylcbiAgcmV0dXJuIHBhY2tlZCsnfCcrYWRkZW5kdW0rJ3wnK3JlbW92ZW5kdW1cbn1cbkNoYW5nZXNldC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMucGFjaygpXG59XG5cbi8qKlxuICogVW5zZXJpYWxpemVzIHRoZSBvdXRwdXQgb2YgY3MudGV4dC5DaGFuZ2VzZXQjdG9TdHJpbmcoKVxuICpcbiAqIEBwYXJhbSBwYWNrZWQgPFN0cmluZz4gVGhlIHNlcmlhbGl6ZWQgY2hhbmdlc2V0XG4gKiBAcGFyYW0gPGNzLkNoYW5nZXNldD5cbiAqL1xuQ2hhbmdlc2V0LnVucGFjayA9IGZ1bmN0aW9uKHBhY2tlZCkge1xuICBpZihwYWNrZWQgPT0gJycpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVucGFjayBmcm9tIGVtcHR5IHN0cmluZycpXG4gIHZhciBjb21wb25lbnRzID0gcGFja2VkLnNwbGl0KCd8JylcbiAgICAsIG9wc3RyaW5nID0gY29tcG9uZW50c1swXVxuICAgICwgYWRkZW5kdW0gPSBjb21wb25lbnRzWzFdLnJlcGxhY2UoLyU3Yy9naSwgJ3wnKS5yZXBsYWNlKC8lMjUvZywgJyUnKVxuICAgICwgcmVtb3ZlbmR1bSA9IGNvbXBvbmVudHNbMl0ucmVwbGFjZSgvJTdjL2dpLCAnfCcpLnJlcGxhY2UoLyUyNS9nLCAnJScpXG5cbiAgdmFyIG1hdGNoZXMgPSBvcHN0cmluZy5tYXRjaCgvWz0rLV0oW149Ky1dKSsvZylcbiAgaWYoIW1hdGNoZXMpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVucGFjayBpbnZhbGlkbHkgc2VyaWFsaXplZCBvcCBzdHJpbmcnKVxuXG4gIHZhciBvcHMgPSBbXVxuICBtYXRjaGVzLmZvckVhY2goZnVuY3Rpb24ocykge1xuICAgIHZhciBzeW1ib2wgPSBzLnN1YnN0cigwLDEpXG4gICAgICAsIGRhdGEgPSBzLnN1YnN0cigxKVxuICAgIGlmKFNraXAucHJvdG90eXBlLnN5bWJvbCA9PSBzeW1ib2wpIHJldHVybiBvcHMucHVzaChTa2lwLnVucGFjayhkYXRhKSlcbiAgICBpZihJbnNlcnQucHJvdG90eXBlLnN5bWJvbCA9PSBzeW1ib2wpIHJldHVybiBvcHMucHVzaChJbnNlcnQudW5wYWNrKGRhdGEpKVxuICAgIGlmKFJldGFpbi5wcm90b3R5cGUuc3ltYm9sID09IHN5bWJvbCkgcmV0dXJuIG9wcy5wdXNoKFJldGFpbi51bnBhY2soZGF0YSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNoYW5nZXNldCByZXByZXNlbnRhdGlvbiBwYXNzZWQgdG8gQ2hhbmdlc2V0LnVucGFjaycpXG4gIH0pXG5cbiAgdmFyIGNzID0gbmV3IENoYW5nZXNldChvcHMpXG4gIGNzLmFkZGVuZHVtID0gYWRkZW5kdW1cbiAgY3MucmVtb3ZlbmR1bSA9IHJlbW92ZW5kdW1cblxuICByZXR1cm4gY3Ncbn1cblxuQ2hhbmdlc2V0LmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IEJ1aWxkZXJcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgQ2hhbmdlc2V0IGNvbnRhaW5pbmcgdGhlIG9wZXJhdGlvbnMgbmVlZGVkIHRvIHRyYW5zZm9ybSB0ZXh0MSBpbnRvIHRleHQyXG4gKlxuICogQHBhcmFtIHRleHQxIDxTdHJpbmc+XG4gKiBAcGFyYW0gdGV4dDIgPFN0cmluZz5cbiAqL1xuQ2hhbmdlc2V0LmZyb21EaWZmID0gZnVuY3Rpb24oZGlmZikge1xuICAvKipcbiAgICogVGhlIGRhdGEgc3RydWN0dXJlIHJlcHJlc2VudGluZyBhIGRpZmYgaXMgYW4gYXJyYXkgb2YgdHVwbGVzOlxuICAgKiBbW0RJRkZfREVMRVRFLCAnSGVsbG8nXSwgW0RJRkZfSU5TRVJULCAnR29vZGJ5ZSddLCBbRElGRl9FUVVBTCwgJyB3b3JsZC4nXV1cbiAgICogd2hpY2ggbWVhbnM6IGRlbGV0ZSAnSGVsbG8nLCBhZGQgJ0dvb2RieWUnIGFuZCBrZWVwICcgd29ybGQuJ1xuICAgKi9cbiAgdmFyIERJRkZfREVMRVRFID0gLTE7XG4gIHZhciBESUZGX0lOU0VSVCA9IDE7XG4gIHZhciBESUZGX0VRVUFMID0gMDtcblxuICB2YXIgb3BzID0gW11cbiAgICAsIHJlbW92ZW5kdW0gPSAnJ1xuICAgICwgYWRkZW5kdW0gPSAnJ1xuXG4gIGRpZmYuZm9yRWFjaChmdW5jdGlvbihkKSB7XG4gICAgaWYgKERJRkZfREVMRVRFID09IGRbMF0pIHtcbiAgICAgIG9wcy5wdXNoKG5ldyBTa2lwKGRbMV0ubGVuZ3RoKSlcbiAgICAgIHJlbW92ZW5kdW0gKz0gZFsxXVxuICAgIH1cblxuICAgIGlmIChESUZGX0lOU0VSVCA9PSBkWzBdKSB7XG4gICAgICBvcHMucHVzaChuZXcgSW5zZXJ0KGRbMV0ubGVuZ3RoKSlcbiAgICAgIGFkZGVuZHVtICs9IGRbMV1cbiAgICB9XG5cbiAgICBpZihESUZGX0VRVUFMID09IGRbMF0pIHtcbiAgICAgIG9wcy5wdXNoKG5ldyBSZXRhaW4oZFsxXS5sZW5ndGgpKVxuICAgIH1cbiAgfSlcblxuICB2YXIgY3MgPSBuZXcgQ2hhbmdlc2V0KG9wcylcbiAgY3MuYWRkZW5kdW0gPSBhZGRlbmR1bVxuICBjcy5yZW1vdmVuZHVtID0gcmVtb3ZlbmR1bVxuICByZXR1cm4gY3Ncbn1cbiIsIi8qIVxuICogY2hhbmdlc2V0c1xuICogQSBDaGFuZ2VzZXQgbGlicmFyeSBpbmNvcnBvcmF0aW5nIG9wZXJhdGlvbmFsIENoYW5nZXNldFRyYW5zZm9ybSAoT1QpXG4gKiBDb3B5cmlnaHQgMjAxMiBieSBNYXJjZWwgS2xlaHIgPG1rbGVockBnbXgubmV0PlxuICpcbiAqIChNSVQgTElDRU5TRSlcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxudmFyIFJldGFpbiA9IHJlcXVpcmUoJy4vb3BlcmF0aW9ucy9SZXRhaW4nKVxuICAsIFNraXAgPSByZXF1aXJlKCcuL29wZXJhdGlvbnMvU2tpcCcpXG4gICwgSW5zZXJ0ID0gcmVxdWlyZSgnLi9vcGVyYXRpb25zL0luc2VydCcpXG4gICwgQ2hhbmdlc2V0ID0gcmVxdWlyZSgnLi9DaGFuZ2VzZXQnKVxuXG5cbmZ1bmN0aW9uIENoYW5nZXNldFRyYW5zZm9ybShpbnB1dENzLCBhZGRlbmR1bSkge1xuICB0aGlzLm91dHB1dCA9IFtdXG4gIHRoaXMuYWRkZW5kdW0gPSBhZGRlbmR1bVxuICB0aGlzLm5ld1JlbW92ZW5kdW0gPSAnJ1xuICB0aGlzLm5ld0FkZGVuZHVtID0gJydcblxuICB0aGlzLmNzID0gaW5wdXRDc1xuICB0aGlzLnBvcyA9IDBcbiAgdGhpcy5hZGRlbmR1bVBvaW50ZXIgPSAwXG4gIHRoaXMucmVtb3ZlbmR1bVBvaW50ZXIgPSAwXG59XG5tb2R1bGUuZXhwb3J0cyA9IENoYW5nZXNldFRyYW5zZm9ybVxuXG5DaGFuZ2VzZXRUcmFuc2Zvcm0ucHJvdG90eXBlLnJlYWRJbnB1dCA9IGZ1bmN0aW9uIChsZW4pIHtcbiAgdmFyIHJldCA9IHRoaXMuY3Muc3VicmFuZ2UodGhpcy5wb3MsIGxlbilcbiAgdGhpcy5wb3MgKz0gbGVuXG4gIHJldHVybiByZXRcbn1cblxuQ2hhbmdlc2V0VHJhbnNmb3JtLnByb3RvdHlwZS5yZWFkQWRkZW5kdW0gPSBmdW5jdGlvbiAobGVuKSB7XG4gIC8vcmV0dXJuIFtuZXcgUmV0YWluKGxlbildXG4gIHZhciByZXQgPSB0aGlzLnN1YnJhbmdlKHRoaXMuYWRkZW5kdW0sIHRoaXMuYWRkZW5kdW1Qb2ludGVyLCBsZW4pXG4gIHRoaXMuYWRkZW5kdW1Qb2ludGVyICs9IGxlblxuICByZXR1cm4gcmV0XG59XG5cbkNoYW5nZXNldFRyYW5zZm9ybS5wcm90b3R5cGUud3JpdGVSZW1vdmVuZHVtID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gIHJhbmdlXG4gICAgLmZpbHRlcihmdW5jdGlvbihvcCkge3JldHVybiAhb3Aub3V0cHV0fSlcbiAgICAuZm9yRWFjaChmdW5jdGlvbihvcCkge1xuICAgICAgdGhpcy5yZW1vdmVuZHVtUG9pbnRlciArPSBvcC5sZW5ndGhcbiAgICB9LmJpbmQodGhpcykpXG59XG5cbkNoYW5nZXNldFRyYW5zZm9ybS5wcm90b3R5cGUud3JpdGVPdXRwdXQgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgdGhpcy5vdXRwdXQgPSB0aGlzLm91dHB1dC5jb25jYXQocmFuZ2UpXG4gIHJhbmdlXG4gICAgLmZpbHRlcihmdW5jdGlvbihvcCkge3JldHVybiAhb3Aub3V0cHV0fSlcbiAgICAuZm9yRWFjaChmdW5jdGlvbihvcCkge1xuICAgICAgdGhpcy5uZXdSZW1vdmVuZHVtICs9IHRoaXMuY3MucmVtb3ZlbmR1bS5zdWJzdHIodGhpcy5yZW1vdmVuZHVtUG9pbnRlciwgb3AubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVuZHVtUG9pbnRlciArPSBvcC5sZW5ndGhcbiAgICB9LmJpbmQodGhpcykpXG59XG5cbkNoYW5nZXNldFRyYW5zZm9ybS5wcm90b3R5cGUuc3VicmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2UsIHN0YXJ0LCBsZW4pIHtcbiAgaWYobGVuKSByZXR1cm4gdGhpcy5jcy5zdWJyYW5nZS5jYWxsKHJhbmdlLCBzdGFydCwgbGVuKVxuICBlbHNlIHJldHVybiByYW5nZS5maWx0ZXIoZnVuY3Rpb24ob3ApeyByZXR1cm4gIW9wLmlucHV0fSlcbn1cblxuQ2hhbmdlc2V0VHJhbnNmb3JtLnByb3RvdHlwZS5yZXN1bHQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy53cml0ZU91dHB1dCh0aGlzLnJlYWRJbnB1dChJbmZpbml0eSkpXG4gIHZhciBuZXdDcyA9IG5ldyBDaGFuZ2VzZXQodGhpcy5vdXRwdXQpXG4gIG5ld0NzLmFkZGVuZHVtID0gdGhpcy5jcy5hZGRlbmR1bVxuICBuZXdDcy5yZW1vdmVuZHVtID0gdGhpcy5uZXdSZW1vdmVuZHVtXG4gIHJldHVybiBuZXdDc1xufVxuIiwiZnVuY3Rpb24gT3BlcmF0b3IoKSB7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gT3BlcmF0b3JcblxuT3BlcmF0b3IucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmRlcml2ZSh0aGlzLmxlbmd0aClcbn1cblxuT3BlcmF0b3IucHJvdG90eXBlLmRlcml2ZSA9IGZ1bmN0aW9uKGxlbikge1xuICByZXR1cm4gbmV3ICh0aGlzLmNvbnN0cnVjdG9yKShsZW4pXG59XG5cbk9wZXJhdG9yLnByb3RvdHlwZS5wYWNrID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnN5bWJvbCArICh0aGlzLmxlbmd0aCkudG9TdHJpbmcoMzYpXG59XG4iLCIvKiFcbiAqIGNoYW5nZXNldHNcbiAqIEEgQ2hhbmdlc2V0IGxpYnJhcnkgaW5jb3Jwb3JhdGluZyBvcGVyYXRpb25hbCBBcHBseSAoT1QpXG4gKiBDb3B5cmlnaHQgMjAxMiBieSBNYXJjZWwgS2xlaHIgPG1rbGVockBnbXgubmV0PlxuICpcbiAqIChNSVQgTElDRU5TRSlcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxudmFyIFJldGFpbiA9IHJlcXVpcmUoJy4vb3BlcmF0aW9ucy9SZXRhaW4nKVxuICAsIFNraXAgPSByZXF1aXJlKCcuL29wZXJhdGlvbnMvU2tpcCcpXG4gICwgSW5zZXJ0ID0gcmVxdWlyZSgnLi9vcGVyYXRpb25zL0luc2VydCcpXG4gICwgSW5zZXJ0ID0gcmVxdWlyZSgnLi9DaGFuZ2VzZXQnKVxuXG5cbmZ1bmN0aW9uIFRleHRUcmFuc2Zvcm0oaW5wdXQsIGFkZGVuZHVtLCByZW1vdmVuZHVtKSB7XG4gIHRoaXMub3V0cHV0ID0gJydcblxuICB0aGlzLmlucHV0ID0gaW5wdXRcbiAgdGhpcy5hZGRlbmR1bSA9IGFkZGVuZHVtXG4gIHRoaXMucmVtb3ZlbmR1bSA9IHJlbW92ZW5kdW1cbiAgdGhpcy5wb3MgPSAwXG4gIHRoaXMuYWRkUG9zID0gMFxuICB0aGlzLnJlbVBvcyA9IDBcbn1cbm1vZHVsZS5leHBvcnRzID0gVGV4dFRyYW5zZm9ybVxuXG5UZXh0VHJhbnNmb3JtLnByb3RvdHlwZS5yZWFkSW5wdXQgPSBmdW5jdGlvbiAobGVuKSB7XG4gIHZhciByZXQgPSB0aGlzLmlucHV0LnN1YnN0cih0aGlzLnBvcywgbGVuKVxuICB0aGlzLnBvcyArPSBsZW5cbiAgcmV0dXJuIHJldFxufVxuXG5UZXh0VHJhbnNmb3JtLnByb3RvdHlwZS5yZWFkQWRkZW5kdW0gPSBmdW5jdGlvbiAobGVuKSB7XG4gIHZhciByZXQgPSB0aGlzLmFkZGVuZHVtLnN1YnN0cih0aGlzLmFkZFBvcywgbGVuKVxuICB0aGlzLmFkZFBvcyArPSBsZW5cbiAgcmV0dXJuIHJldFxufVxuXG5UZXh0VHJhbnNmb3JtLnByb3RvdHlwZS53cml0ZVJlbW92ZW5kdW0gPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgLy92YXIgZXhwZWN0ZWQgPSB0aGlzLnJlbW92ZW5kdW0uc3Vic3RyKHRoaXMucmVtUG9zLCByYW5nZS5sZW5ndGgpXG4gIC8vaWYocmFuZ2UgIT0gZXhwZWN0ZWQpIHRocm93IG5ldyBFcnJvcignUmVtb3ZlZCBjaGFycyBkb25cXCd0IG1hdGNoIHJlbW92ZW5kdW0uIGV4cGVjdGVkOiAnK2V4cGVjdGVkKyc7IGFjdHVhbDogJytyYW5nZSlcbiAgdGhpcy5yZW1Qb3MgKz0gcmFuZ2UubGVuZ3RoXG59XG5cblRleHRUcmFuc2Zvcm0ucHJvdG90eXBlLndyaXRlT3V0cHV0ID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gIHRoaXMub3V0cHV0ICs9IHJhbmdlXG59XG5cblRleHRUcmFuc2Zvcm0ucHJvdG90eXBlLnN1YnJhbmdlID0gZnVuY3Rpb24gKHJhbmdlLCBzdGFydCwgbGVuKSB7XG4gIHJldHVybiByYW5nZS5zdWJzdHIoc3RhcnQsIGxlbilcbn1cblxuVGV4dFRyYW5zZm9ybS5wcm90b3R5cGUucmVzdWx0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMud3JpdGVPdXRwdXQodGhpcy5yZWFkSW5wdXQoSW5maW5pdHkpKVxuICByZXR1cm4gdGhpcy5vdXRwdXRcbn1cbiIsIi8qIVxuICogY2hhbmdlc2V0c1xuICogQSBDaGFuZ2VzZXQgbGlicmFyeSBpbmNvcnBvcmF0aW5nIG9wZXJhdGlvbmFsIHRyYW5zZm9ybWF0aW9uIChPVClcbiAqIENvcHlyaWdodCAyMDEyIGJ5IE1hcmNlbCBLbGVociA8bWtsZWhyQGdteC5uZXQ+XG4gKlxuICogKE1JVCBMSUNFTlNFKVxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG52YXIgQ2hhbmdlc2V0ID0gcmVxdWlyZSgnLi9DaGFuZ2VzZXQnKVxuICAsIFJldGFpbiA9IHJlcXVpcmUoJy4vb3BlcmF0aW9ucy9SZXRhaW4nKVxuICAsIFNraXAgPSByZXF1aXJlKCcuL29wZXJhdGlvbnMvU2tpcCcpXG4gICwgSW5zZXJ0ID0gcmVxdWlyZSgnLi9vcGVyYXRpb25zL0luc2VydCcpXG5cbmV4cG9ydHMuT3BlcmF0b3IgPSByZXF1aXJlKCcuL09wZXJhdG9yJylcbmV4cG9ydHMuQ2hhbmdlc2V0ID0gQ2hhbmdlc2V0XG5leHBvcnRzLkluc2VydCA9IEluc2VydFxuZXhwb3J0cy5SZXRhaW4gPSBSZXRhaW5cbmV4cG9ydHMuU2tpcCA9IFNraXBcblxuaWYoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIHdpbmRvdykgd2luZG93LmNoYW5nZXNldHMgPSBleHBvcnRzXG5cbi8qKlxuICogU2VyaWFsaXplcyB0aGUgZ2l2ZW4gY2hhbmdlc2V0IGluIG9yZGVyIHRvIHJldHVybiBhIChob3BlZnVsbHkpIG1vcmUgY29tcGFjdCByZXByZXNlbnRhdGlvblxuICogdGhhdCBjYW4gYmUgc2VudCB0aHJvdWdoIGEgbmV0d29yayBvciBzdG9yZWQgaW4gYSBkYXRhYmFzZVxuICogQGFsaWFzIGNzLnRleHQuQ2hhbmdlc2V0I3BhY2tcbiAqL1xuZXhwb3J0cy5wYWNrID0gZnVuY3Rpb24oY3MpIHtcbiAgcmV0dXJuIGNzLnBhY2soKVxufVxuXG4vKipcbiAqIFVuc2VyaWFsaXplcyB0aGUgb3V0cHV0IG9mIGNzLnRleHQucGFja1xuICogQGFsaWFzIGNzLnRleHQuQ2hhbmdlc2V0LnVucGFja1xuICovXG5leHBvcnRzLnVucGFjayA9IGZ1bmN0aW9uKHBhY2tlZCkge1xuICByZXR1cm4gQ2hhbmdlc2V0LnVucGFjayhwYWNrZWQpXG59XG5cblxuXG5cbi8qKlxuICogc2hhcmVKUyBvdCB0eXBlIEFQSSBzZXBjIHN1cHBvcnRcbiAqL1xuXG5leHBvcnRzLm5hbWUgPSAnY2hhbmdlc2V0cydcbmV4cG9ydHMudXJsID0gJ2h0dHBzOi8vZ2l0aHViLmNvbS9tYXJjZWxrbGVoci9jaGFuZ2VzZXRzJ1xuXG4vKipcbiAqIGNyZWF0ZShbaW5pdGlhbFRleHRdKVxuICpcbiAqIGNyZWF0ZXMgYSBzbmFwc2hvdCAob3B0aW9uYWxseSB3aXRoIHN1cHBsaWVkIGludGlhbCB0ZXh0KVxuICovXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uKGluaXRUZXh0KSB7XG4gIHJldHVybiBpbml0VGV4dCB8fCAnJ1xufVxuXG4vKipcbiAqIEFwcGx5IGEgY2hhbmdlc2V0IG9uIGEgc25hcHNob3QgY3JlYXRpbmcgYSBuZXcgb25lXG4gKlxuICogVGhlIG9sZCBzbmFwc2hvdCBvYmplY3QgbXVzdG4ndCBiZSB1c2VkIGFmdGVyIGNhbGxpbmcgYXBwbHkgb24gaXRcbiAqIHJldHVybnMgdGhlIHJlc3VsdGluZ1xuICovXG5leHBvcnRzLmFwcGx5ID0gZnVuY3Rpb24oc25hcHNob3QsIG9wKSB7XG4gIG9wID0gZXhwb3J0cy51bnBhY2sob3ApXG4gIHJldHVybiBvcC5hcHBseShzbmFwc2hvdClcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gY2hhbmdlc2V0MSBhZ2FpbnN0IGNoYW5nZXNldDJcbiAqL1xuZXhwb3J0cy50cmFuc2Zvcm0gPSBmdW5jdGlvbiAob3AxLCBvcDIsIHNpZGUpIHtcbiAgb3AxID0gZXhwb3J0cy51bnBhY2sob3AxKVxuICBvcDIgPSBleHBvcnRzLnVucGFjayhvcDIpXG4gIHJldHVybiBleHBvcnRzLnBhY2sob3AxLnRyYW5zZm9ybUFnYWluc3Qob3AyLCAoJ2xlZnQnPT1zaWRlKSkpXG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIGNoYW5nZXNldHMgaW50byBvbmVcbiAqL1xuZXhwb3J0cy5jb21wb3NlID0gZnVuY3Rpb24gKG9wMSwgb3AyKSB7XG4gIG9wMSA9IGV4cG9ydHMudW5wYWNrKG9wMSlcbiAgb3AyID0gZXhwb3J0cy51bnBhY2sob3AyKVxuICByZXR1cm4gZXhwb3J0cy5wYWNrKG9wMS5tZXJnZShvcDIpKVxufVxuXG4vKipcbiAqIEludmVydCBhIGNoYW5nZXNldFxuICovXG5leHBvcnRzLmludmVydCA9IGZ1bmN0aW9uKG9wKSB7XG4gIHJldHVybiBleHBvcnRzLnBhY2soZXhwb3J0cy51bnBhY2sob3ApLmludmVydCgpKVxufVxuIiwiLyohXG4gKiBjaGFuZ2VzZXRzXG4gKiBBIENoYW5nZXNldCBsaWJyYXJ5IGluY29ycG9yYXRpbmcgb3BlcmF0aW9uYWwgdHJhbnNmb3JtYXRpb24gKE9UKVxuICogQ29weXJpZ2h0IDIwMTIgYnkgTWFyY2VsIEtsZWhyIDxta2xlaHJAZ214Lm5ldD5cbiAqXG4gKiAoTUlUIExJQ0VOU0UpXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbnZhciBPcGVyYXRvciA9IHJlcXVpcmUoJy4uL09wZXJhdG9yJylcblxuLyoqXG4gKiBJbnNlcnQgT3BlcmF0b3JcbiAqIERlZmluZWQgYnk6XG4gKiAtIGxlbmd0aFxuICogLSBpbnB1dD0wXG4gKiAtIG91dHB1dD1sZW5ndGhcbiAqXG4gKiBAcGFyYW0gbGVuZ3RoIDxOdW1iZXI+IEhvdyBtYW55IGNoYXJzIHRvIGJlIGluc2VydGVkXG4gKi9cbmZ1bmN0aW9uIEluc2VydChsZW5ndGgpIHtcbiAgdGhpcy5sZW5ndGggPSBsZW5ndGhcbiAgdGhpcy5pbnB1dCA9IDBcbiAgdGhpcy5vdXRwdXQgPSBsZW5ndGhcbn1cblxuLy8gVHJ1ZSBpbmhlcml0YW5jZVxuSW5zZXJ0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoT3BlcmF0b3IucHJvdG90eXBlLCB7XG4gIGNvbnN0cnVjdG9yOiB7XG4gICAgdmFsdWU6IEluc2VydCxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IEluc2VydFxuSW5zZXJ0LnByb3RvdHlwZS5zeW1ib2wgPSAnKydcblxudmFyIFNraXAgPSByZXF1aXJlKCcuL1NraXAnKVxuICAsIFJldGFpbiA9IHJlcXVpcmUoJy4vUmV0YWluJylcblxuSW5zZXJ0LnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKHQpIHtcbiAgdC53cml0ZU91dHB1dCh0LnJlYWRBZGRlbmR1bSh0aGlzLm91dHB1dCkpXG59XG5cbkluc2VydC5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXNcbn1cblxuSW5zZXJ0LnByb3RvdHlwZS5pbnZlcnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBTa2lwKHRoaXMubGVuZ3RoKVxufVxuXG5JbnNlcnQudW5wYWNrID0gZnVuY3Rpb24oZGF0YSkge1xuICByZXR1cm4gbmV3IEluc2VydChwYXJzZUludChkYXRhLCAzNikpXG59XG4iLCIvKiFcbiAqIGNoYW5nZXNldHNcbiAqIEEgQ2hhbmdlc2V0IGxpYnJhcnkgaW5jb3Jwb3JhdGluZyBvcGVyYXRpb25hbCB0cmFuc2Zvcm1hdGlvbiAoT1QpXG4gKiBDb3B5cmlnaHQgMjAxMiBieSBNYXJjZWwgS2xlaHIgPG1rbGVockBnbXgubmV0PlxuICpcbiAqIChNSVQgTElDRU5TRSlcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxudmFyIE9wZXJhdG9yID0gcmVxdWlyZSgnLi4vT3BlcmF0b3InKVxuXG4vKipcbiAqIFJldGFpbiBPcGVyYXRvclxuICogRGVmaW5lZCBieTpcbiAqIC0gbGVuZ3RoXG4gKiAtIGlucHV0PW91dHB1dD1sZW5ndGhcbiAqXG4gKiBAcGFyYW0gbGVuZ3RoIDxOdW1iZXI+IEhvdyBtYW55IGNoYXJzIHRvIHJldGFpblxuICovXG5mdW5jdGlvbiBSZXRhaW4obGVuZ3RoKSB7XG4gIHRoaXMubGVuZ3RoID0gbGVuZ3RoXG4gIHRoaXMuaW5wdXQgPSBsZW5ndGhcbiAgdGhpcy5vdXRwdXQgPSBsZW5ndGhcbn1cblxuLy8gVHJ1ZSBpbmhlcml0YW5jZVxuUmV0YWluLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoT3BlcmF0b3IucHJvdG90eXBlLCB7XG4gIGNvbnN0cnVjdG9yOiB7XG4gICAgdmFsdWU6IFJldGFpbixcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IFJldGFpblxuUmV0YWluLnByb3RvdHlwZS5zeW1ib2wgPSAnPSdcblxuUmV0YWluLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKHQpIHtcbiAgdC53cml0ZU91dHB1dCh0LnJlYWRJbnB1dCh0aGlzLmlucHV0KSlcbn1cblxuUmV0YWluLnByb3RvdHlwZS5pbnZlcnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXNcbn1cblxuUmV0YWluLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uKG9wMikge1xuICByZXR1cm4gdGhpc1xufVxuXG5SZXRhaW4udW5wYWNrID0gZnVuY3Rpb24oZGF0YSkge1xuICByZXR1cm4gbmV3IFJldGFpbihwYXJzZUludChkYXRhLCAzNikpXG59XG4iLCIvKiFcbiAqIGNoYW5nZXNldHNcbiAqIEEgQ2hhbmdlc2V0IGxpYnJhcnkgaW5jb3Jwb3JhdGluZyBvcGVyYXRpb25hbCB0cmFuc2Zvcm1hdGlvbiAoT1QpXG4gKiBDb3B5cmlnaHQgMjAxMiBieSBNYXJjZWwgS2xlaHIgPG1rbGVockBnbXgubmV0PlxuICpcbiAqIChNSVQgTElDRU5TRSlcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxudmFyIE9wZXJhdG9yID0gcmVxdWlyZSgnLi4vT3BlcmF0b3InKVxuXG4vKipcbiAqIFNraXAgT3BlcmF0b3JcbiAqIERlZmluZWQgYnk6XG4gKiAtIGxlbmd0aFxuICogLSBpbnB1dD1sZW5ndGhcbiAqIC0gb3V0cHV0PTBcbiAqXG4gKiBAcGFyYW0gbGVuZ3RoIDxOdW1iZXI+IEhvdyBtYW55IGNoYXJzIHRvIGJlIFNraXBcbiAqL1xuZnVuY3Rpb24gU2tpcChsZW5ndGgpIHtcbiAgdGhpcy5sZW5ndGggPSBsZW5ndGhcbiAgdGhpcy5pbnB1dCA9IGxlbmd0aFxuICB0aGlzLm91dHB1dCA9IDBcbn1cblxuLy8gVHJ1ZSBpbmhlcml0YW5jZVxuU2tpcC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE9wZXJhdG9yLnByb3RvdHlwZSwge1xuICBjb25zdHJ1Y3Rvcjoge1xuICAgIHZhbHVlOiBTa2lwLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9XG59KTtcbm1vZHVsZS5leHBvcnRzID0gU2tpcFxuU2tpcC5wcm90b3R5cGUuc3ltYm9sID0gJy0nXG5cbnZhciBJbnNlcnQgPSByZXF1aXJlKCcuL0luc2VydCcpXG4gICwgUmV0YWluID0gcmVxdWlyZSgnLi9SZXRhaW4nKVxuICAsIENoYW5nZXNldCA9IHJlcXVpcmUoJy4uL0NoYW5nZXNldCcpXG5cblNraXAucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24odCkge1xuICB2YXIgaW5wdXQgPSB0LnJlYWRJbnB1dCh0aGlzLmlucHV0KVxuICB0LndyaXRlUmVtb3ZlbmR1bShpbnB1dClcbiAgdC53cml0ZU91dHB1dCh0LnN1YnJhbmdlKGlucHV0LCAwLCB0aGlzLm91dHB1dCkpIC8vIHJldGFpbiBJbnNlcnRzIGluIG15IHJhbmdlXG59XG5cblNraXAucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24ob3AyKSB7XG4gIHJldHVybiB0aGlzXG59XG5cblNraXAucHJvdG90eXBlLmludmVydCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IEluc2VydCh0aGlzLmxlbmd0aClcbn1cblxuU2tpcC51bnBhY2sgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHJldHVybiBuZXcgU2tpcChwYXJzZUludChkYXRhLCAzNikpXG59XG4iLCIvKipcbiAqIERpZmYgTWF0Y2ggYW5kIFBhdGNoXG4gKlxuICogQ29weXJpZ2h0IDIwMDYgR29vZ2xlIEluYy5cbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9nb29nbGUtZGlmZi1tYXRjaC1wYXRjaC9cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBDb21wdXRlcyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byB0ZXh0cyB0byBjcmVhdGUgYSBwYXRjaC5cbiAqIEFwcGxpZXMgdGhlIHBhdGNoIG9udG8gYW5vdGhlciB0ZXh0LCBhbGxvd2luZyBmb3IgZXJyb3JzLlxuICogQGF1dGhvciBmcmFzZXJAZ29vZ2xlLmNvbSAoTmVpbCBGcmFzZXIpXG4gKi9cblxuLyoqXG4gKiBDbGFzcyBjb250YWluaW5nIHRoZSBkaWZmLCBtYXRjaCBhbmQgcGF0Y2ggbWV0aG9kcy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBkaWZmX21hdGNoX3BhdGNoKCkge1xuXG4gIC8vIERlZmF1bHRzLlxuICAvLyBSZWRlZmluZSB0aGVzZSBpbiB5b3VyIHByb2dyYW0gdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzLlxuXG4gIC8vIE51bWJlciBvZiBzZWNvbmRzIHRvIG1hcCBhIGRpZmYgYmVmb3JlIGdpdmluZyB1cCAoMCBmb3IgaW5maW5pdHkpLlxuICB0aGlzLkRpZmZfVGltZW91dCA9IDEuMDtcbiAgLy8gQ29zdCBvZiBhbiBlbXB0eSBlZGl0IG9wZXJhdGlvbiBpbiB0ZXJtcyBvZiBlZGl0IGNoYXJhY3RlcnMuXG4gIHRoaXMuRGlmZl9FZGl0Q29zdCA9IDQ7XG4gIC8vIFRoZSBzaXplIGJleW9uZCB3aGljaCB0aGUgZG91YmxlLWVuZGVkIGRpZmYgYWN0aXZhdGVzLlxuICAvLyBEb3VibGUtZW5kaW5nIGlzIHR3aWNlIGFzIGZhc3QsIGJ1dCBsZXNzIGFjY3VyYXRlLlxuICB0aGlzLkRpZmZfRHVhbFRocmVzaG9sZCA9IDMyO1xuICAvLyBBdCB3aGF0IHBvaW50IGlzIG5vIG1hdGNoIGRlY2xhcmVkICgwLjAgPSBwZXJmZWN0aW9uLCAxLjAgPSB2ZXJ5IGxvb3NlKS5cbiAgdGhpcy5NYXRjaF9UaHJlc2hvbGQgPSAwLjU7XG4gIC8vIEhvdyBmYXIgdG8gc2VhcmNoIGZvciBhIG1hdGNoICgwID0gZXhhY3QgbG9jYXRpb24sIDEwMDArID0gYnJvYWQgbWF0Y2gpLlxuICAvLyBBIG1hdGNoIHRoaXMgbWFueSBjaGFyYWN0ZXJzIGF3YXkgZnJvbSB0aGUgZXhwZWN0ZWQgbG9jYXRpb24gd2lsbCBhZGRcbiAgLy8gMS4wIHRvIHRoZSBzY29yZSAoMC4wIGlzIGEgcGVyZmVjdCBtYXRjaCkuXG4gIHRoaXMuTWF0Y2hfRGlzdGFuY2UgPSAxMDAwO1xuICAvLyBXaGVuIGRlbGV0aW5nIGEgbGFyZ2UgYmxvY2sgb2YgdGV4dCAob3ZlciB+NjQgY2hhcmFjdGVycyksIGhvdyBjbG9zZSBkb2VzXG4gIC8vIHRoZSBjb250ZW50cyBoYXZlIHRvIG1hdGNoIHRoZSBleHBlY3RlZCBjb250ZW50cy4gKDAuMCA9IHBlcmZlY3Rpb24sXG4gIC8vIDEuMCA9IHZlcnkgbG9vc2UpLiAgTm90ZSB0aGF0IE1hdGNoX1RocmVzaG9sZCBjb250cm9scyBob3cgY2xvc2VseSB0aGVcbiAgLy8gZW5kIHBvaW50cyBvZiBhIGRlbGV0ZSBuZWVkIHRvIG1hdGNoLlxuICB0aGlzLlBhdGNoX0RlbGV0ZVRocmVzaG9sZCA9IDAuNTtcbiAgLy8gQ2h1bmsgc2l6ZSBmb3IgY29udGV4dCBsZW5ndGguXG4gIHRoaXMuUGF0Y2hfTWFyZ2luID0gNDtcblxuICAvKipcbiAgICogQ29tcHV0ZSB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gYW4gaW50LlxuICAgKiBUaGUgbm9ybWFsIGFuc3dlciBmb3IgSmF2YVNjcmlwdCBpcyAzMi5cbiAgICogQHJldHVybiB7bnVtYmVyfSBNYXggYml0c1xuICAgKi9cbiAgZnVuY3Rpb24gZ2V0TWF4Qml0cygpIHtcbiAgICB2YXIgbWF4Yml0cyA9IDA7XG4gICAgdmFyIG9sZGkgPSAxO1xuICAgIHZhciBuZXdpID0gMjtcbiAgICB3aGlsZSAob2xkaSAhPSBuZXdpKSB7XG4gICAgICBtYXhiaXRzKys7XG4gICAgICBvbGRpID0gbmV3aTtcbiAgICAgIG5ld2kgPSBuZXdpIDw8IDE7XG4gICAgfVxuICAgIHJldHVybiBtYXhiaXRzO1xuICB9XG4gIC8vIEhvdyBtYW55IGJpdHMgaW4gYSBudW1iZXI/XG4gIHRoaXMuTWF0Y2hfTWF4Qml0cyA9IGdldE1heEJpdHMoKTtcbn1cblxuXG4vLyAgRElGRiBGVU5DVElPTlNcblxuXG4vKipcbiAqIFRoZSBkYXRhIHN0cnVjdHVyZSByZXByZXNlbnRpbmcgYSBkaWZmIGlzIGFuIGFycmF5IG9mIHR1cGxlczpcbiAqIFtbRElGRl9ERUxFVEUsICdIZWxsbyddLCBbRElGRl9JTlNFUlQsICdHb29kYnllJ10sIFtESUZGX0VRVUFMLCAnIHdvcmxkLiddXVxuICogd2hpY2ggbWVhbnM6IGRlbGV0ZSAnSGVsbG8nLCBhZGQgJ0dvb2RieWUnIGFuZCBrZWVwICcgd29ybGQuJ1xuICovXG52YXIgRElGRl9ERUxFVEUgPSAtMTtcbnZhciBESUZGX0lOU0VSVCA9IDE7XG52YXIgRElGRl9FUVVBTCA9IDA7XG5cblxuLyoqXG4gKiBGaW5kIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHR3byB0ZXh0cy4gIFNpbXBsaWZpZXMgdGhlIHByb2JsZW0gYnkgc3RyaXBwaW5nXG4gKiBhbnkgY29tbW9uIHByZWZpeCBvciBzdWZmaXggb2ZmIHRoZSB0ZXh0cyBiZWZvcmUgZGlmZmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBPbGQgc3RyaW5nIHRvIGJlIGRpZmZlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBOZXcgc3RyaW5nIHRvIGJlIGRpZmZlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0X2NoZWNrbGluZXMgT3B0aW9uYWwgc3BlZWR1cCBmbGFnLiAgSWYgcHJlc2VudCBhbmQgZmFsc2UsXG4gKiAgICAgdGhlbiBkb24ndCBydW4gYSBsaW5lLWxldmVsIGRpZmYgZmlyc3QgdG8gaWRlbnRpZnkgdGhlIGNoYW5nZWQgYXJlYXMuXG4gKiAgICAgRGVmYXVsdHMgdG8gdHJ1ZSwgd2hpY2ggZG9lcyBhIGZhc3Rlciwgc2xpZ2h0bHkgbGVzcyBvcHRpbWFsIGRpZmZcbiAqIEByZXR1cm4ge0FycmF5LjxBcnJheS48bnVtYmVyfHN0cmluZz4+fSBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9tYWluID0gZnVuY3Rpb24odGV4dDEsIHRleHQyLCBvcHRfY2hlY2tsaW5lcykge1xuICAvLyBDaGVjayBmb3IgbnVsbCBpbnB1dHMuXG4gIGlmICh0ZXh0MSA9PSBudWxsIHx8IHRleHQyID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ051bGwgaW5wdXQuIChkaWZmX21haW4pJyk7XG4gIH1cblxuICAvLyBDaGVjayBmb3IgZXF1YWxpdHkgKHNwZWVkdXApLlxuICBpZiAodGV4dDEgPT0gdGV4dDIpIHtcbiAgICByZXR1cm4gW1tESUZGX0VRVUFMLCB0ZXh0MV1dO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRfY2hlY2tsaW5lcyA9PSAndW5kZWZpbmVkJykge1xuICAgIG9wdF9jaGVja2xpbmVzID0gdHJ1ZTtcbiAgfVxuICB2YXIgY2hlY2tsaW5lcyA9IG9wdF9jaGVja2xpbmVzO1xuXG4gIC8vIFRyaW0gb2ZmIGNvbW1vbiBwcmVmaXggKHNwZWVkdXApLlxuICB2YXIgY29tbW9ubGVuZ3RoID0gdGhpcy5kaWZmX2NvbW1vblByZWZpeCh0ZXh0MSwgdGV4dDIpO1xuICB2YXIgY29tbW9ucHJlZml4ID0gdGV4dDEuc3Vic3RyaW5nKDAsIGNvbW1vbmxlbmd0aCk7XG4gIHRleHQxID0gdGV4dDEuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCk7XG4gIHRleHQyID0gdGV4dDIuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCk7XG5cbiAgLy8gVHJpbSBvZmYgY29tbW9uIHN1ZmZpeCAoc3BlZWR1cCkuXG4gIGNvbW1vbmxlbmd0aCA9IHRoaXMuZGlmZl9jb21tb25TdWZmaXgodGV4dDEsIHRleHQyKTtcbiAgdmFyIGNvbW1vbnN1ZmZpeCA9IHRleHQxLnN1YnN0cmluZyh0ZXh0MS5sZW5ndGggLSBjb21tb25sZW5ndGgpO1xuICB0ZXh0MSA9IHRleHQxLnN1YnN0cmluZygwLCB0ZXh0MS5sZW5ndGggLSBjb21tb25sZW5ndGgpO1xuICB0ZXh0MiA9IHRleHQyLnN1YnN0cmluZygwLCB0ZXh0Mi5sZW5ndGggLSBjb21tb25sZW5ndGgpO1xuXG4gIC8vIENvbXB1dGUgdGhlIGRpZmYgb24gdGhlIG1pZGRsZSBibG9jay5cbiAgdmFyIGRpZmZzID0gdGhpcy5kaWZmX2NvbXB1dGUodGV4dDEsIHRleHQyLCBjaGVja2xpbmVzKTtcblxuICAvLyBSZXN0b3JlIHRoZSBwcmVmaXggYW5kIHN1ZmZpeC5cbiAgaWYgKGNvbW1vbnByZWZpeCkge1xuICAgIGRpZmZzLnVuc2hpZnQoW0RJRkZfRVFVQUwsIGNvbW1vbnByZWZpeF0pO1xuICB9XG4gIGlmIChjb21tb25zdWZmaXgpIHtcbiAgICBkaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBjb21tb25zdWZmaXhdKTtcbiAgfVxuICB0aGlzLmRpZmZfY2xlYW51cE1lcmdlKGRpZmZzKTtcbiAgcmV0dXJuIGRpZmZzO1xufTtcblxuXG4vKipcbiAqIEZpbmQgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gdHdvIHRleHRzLiAgQXNzdW1lcyB0aGF0IHRoZSB0ZXh0cyBkbyBub3RcbiAqIGhhdmUgYW55IGNvbW1vbiBwcmVmaXggb3Igc3VmZml4LlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIE9sZCBzdHJpbmcgdG8gYmUgZGlmZmVkLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIE5ldyBzdHJpbmcgdG8gYmUgZGlmZmVkLlxuICogQHBhcmFtIHtib29sZWFufSBjaGVja2xpbmVzIFNwZWVkdXAgZmxhZy4gIElmIGZhbHNlLCB0aGVuIGRvbid0IHJ1biBhXG4gKiAgICAgbGluZS1sZXZlbCBkaWZmIGZpcnN0IHRvIGlkZW50aWZ5IHRoZSBjaGFuZ2VkIGFyZWFzLlxuICogICAgIElmIHRydWUsIHRoZW4gcnVuIGEgZmFzdGVyLCBzbGlnaHRseSBsZXNzIG9wdGltYWwgZGlmZlxuICogQHJldHVybiB7QXJyYXkuPEFycmF5LjxudW1iZXJ8c3RyaW5nPj59IEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICogQHByaXZhdGVcbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jb21wdXRlID0gZnVuY3Rpb24odGV4dDEsIHRleHQyLCBjaGVja2xpbmVzKSB7XG4gIHZhciBkaWZmcztcblxuICBpZiAoIXRleHQxKSB7XG4gICAgLy8gSnVzdCBhZGQgc29tZSB0ZXh0IChzcGVlZHVwKS5cbiAgICByZXR1cm4gW1tESUZGX0lOU0VSVCwgdGV4dDJdXTtcbiAgfVxuXG4gIGlmICghdGV4dDIpIHtcbiAgICAvLyBKdXN0IGRlbGV0ZSBzb21lIHRleHQgKHNwZWVkdXApLlxuICAgIHJldHVybiBbW0RJRkZfREVMRVRFLCB0ZXh0MV1dO1xuICB9XG5cbiAgdmFyIGxvbmd0ZXh0ID0gdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gdGV4dDEgOiB0ZXh0MjtcbiAgdmFyIHNob3J0dGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQyIDogdGV4dDE7XG4gIHZhciBpID0gbG9uZ3RleHQuaW5kZXhPZihzaG9ydHRleHQpO1xuICBpZiAoaSAhPSAtMSkge1xuICAgIC8vIFNob3J0ZXIgdGV4dCBpcyBpbnNpZGUgdGhlIGxvbmdlciB0ZXh0IChzcGVlZHVwKS5cbiAgICBkaWZmcyA9IFtbRElGRl9JTlNFUlQsIGxvbmd0ZXh0LnN1YnN0cmluZygwLCBpKV0sXG4gICAgICAgICAgICAgW0RJRkZfRVFVQUwsIHNob3J0dGV4dF0sXG4gICAgICAgICAgICAgW0RJRkZfSU5TRVJULCBsb25ndGV4dC5zdWJzdHJpbmcoaSArIHNob3J0dGV4dC5sZW5ndGgpXV07XG4gICAgLy8gU3dhcCBpbnNlcnRpb25zIGZvciBkZWxldGlvbnMgaWYgZGlmZiBpcyByZXZlcnNlZC5cbiAgICBpZiAodGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoKSB7XG4gICAgICBkaWZmc1swXVswXSA9IGRpZmZzWzJdWzBdID0gRElGRl9ERUxFVEU7XG4gICAgfVxuICAgIHJldHVybiBkaWZmcztcbiAgfVxuICBsb25ndGV4dCA9IHNob3J0dGV4dCA9IG51bGw7ICAvLyBHYXJiYWdlIGNvbGxlY3QuXG5cbiAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZSBwcm9ibGVtIGNhbiBiZSBzcGxpdCBpbiB0d28uXG4gIHZhciBobSA9IHRoaXMuZGlmZl9oYWxmTWF0Y2godGV4dDEsIHRleHQyKTtcbiAgaWYgKGhtKSB7XG4gICAgLy8gQSBoYWxmLW1hdGNoIHdhcyBmb3VuZCwgc29ydCBvdXQgdGhlIHJldHVybiBkYXRhLlxuICAgIHZhciB0ZXh0MV9hID0gaG1bMF07XG4gICAgdmFyIHRleHQxX2IgPSBobVsxXTtcbiAgICB2YXIgdGV4dDJfYSA9IGhtWzJdO1xuICAgIHZhciB0ZXh0Ml9iID0gaG1bM107XG4gICAgdmFyIG1pZF9jb21tb24gPSBobVs0XTtcbiAgICAvLyBTZW5kIGJvdGggcGFpcnMgb2ZmIGZvciBzZXBhcmF0ZSBwcm9jZXNzaW5nLlxuICAgIHZhciBkaWZmc19hID0gdGhpcy5kaWZmX21haW4odGV4dDFfYSwgdGV4dDJfYSwgY2hlY2tsaW5lcyk7XG4gICAgdmFyIGRpZmZzX2IgPSB0aGlzLmRpZmZfbWFpbih0ZXh0MV9iLCB0ZXh0Ml9iLCBjaGVja2xpbmVzKTtcbiAgICAvLyBNZXJnZSB0aGUgcmVzdWx0cy5cbiAgICByZXR1cm4gZGlmZnNfYS5jb25jYXQoW1tESUZGX0VRVUFMLCBtaWRfY29tbW9uXV0sIGRpZmZzX2IpO1xuICB9XG5cbiAgLy8gUGVyZm9ybSBhIHJlYWwgZGlmZi5cbiAgaWYgKGNoZWNrbGluZXMgJiYgKHRleHQxLmxlbmd0aCA8IDEwMCB8fCB0ZXh0Mi5sZW5ndGggPCAxMDApKSB7XG4gICAgLy8gVG9vIHRyaXZpYWwgZm9yIHRoZSBvdmVyaGVhZC5cbiAgICBjaGVja2xpbmVzID0gZmFsc2U7XG4gIH1cbiAgdmFyIGxpbmVhcnJheTtcbiAgaWYgKGNoZWNrbGluZXMpIHtcbiAgICAvLyBTY2FuIHRoZSB0ZXh0IG9uIGEgbGluZS1ieS1saW5lIGJhc2lzIGZpcnN0LlxuICAgIHZhciBhID0gdGhpcy5kaWZmX2xpbmVzVG9DaGFycyh0ZXh0MSwgdGV4dDIpO1xuICAgIHRleHQxID0gYVswXTtcbiAgICB0ZXh0MiA9IGFbMV07XG4gICAgbGluZWFycmF5ID0gYVsyXTtcbiAgfVxuICBkaWZmcyA9IHRoaXMuZGlmZl9tYXAodGV4dDEsIHRleHQyKTtcbiAgaWYgKCFkaWZmcykge1xuICAgIC8vIE5vIGFjY2VwdGFibGUgcmVzdWx0LlxuICAgIGRpZmZzID0gW1tESUZGX0RFTEVURSwgdGV4dDFdLCBbRElGRl9JTlNFUlQsIHRleHQyXV07XG4gIH1cbiAgaWYgKGNoZWNrbGluZXMpIHtcbiAgICAvLyBDb252ZXJ0IHRoZSBkaWZmIGJhY2sgdG8gb3JpZ2luYWwgdGV4dC5cbiAgICB0aGlzLmRpZmZfY2hhcnNUb0xpbmVzKGRpZmZzLCBsaW5lYXJyYXkpO1xuICAgIC8vIEVsaW1pbmF0ZSBmcmVhayBtYXRjaGVzIChlLmcuIGJsYW5rIGxpbmVzKVxuICAgIHRoaXMuZGlmZl9jbGVhbnVwU2VtYW50aWMoZGlmZnMpO1xuXG4gICAgLy8gUmVkaWZmIGFueSByZXBsYWNlbWVudCBibG9ja3MsIHRoaXMgdGltZSBjaGFyYWN0ZXItYnktY2hhcmFjdGVyLlxuICAgIC8vIEFkZCBhIGR1bW15IGVudHJ5IGF0IHRoZSBlbmQuXG4gICAgZGlmZnMucHVzaChbRElGRl9FUVVBTCwgJyddKTtcbiAgICB2YXIgcG9pbnRlciA9IDA7XG4gICAgdmFyIGNvdW50X2RlbGV0ZSA9IDA7XG4gICAgdmFyIGNvdW50X2luc2VydCA9IDA7XG4gICAgdmFyIHRleHRfZGVsZXRlID0gJyc7XG4gICAgdmFyIHRleHRfaW5zZXJ0ID0gJyc7XG4gICAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGgpIHtcbiAgICAgIHN3aXRjaCAoZGlmZnNbcG9pbnRlcl1bMF0pIHtcbiAgICAgICAgY2FzZSBESUZGX0lOU0VSVDpcbiAgICAgICAgICBjb3VudF9pbnNlcnQrKztcbiAgICAgICAgICB0ZXh0X2luc2VydCArPSBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBESUZGX0RFTEVURTpcbiAgICAgICAgICBjb3VudF9kZWxldGUrKztcbiAgICAgICAgICB0ZXh0X2RlbGV0ZSArPSBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgICAgIC8vIFVwb24gcmVhY2hpbmcgYW4gZXF1YWxpdHksIGNoZWNrIGZvciBwcmlvciByZWR1bmRhbmNpZXMuXG4gICAgICAgICAgaWYgKGNvdW50X2RlbGV0ZSA+PSAxICYmIGNvdW50X2luc2VydCA+PSAxKSB7XG4gICAgICAgICAgICAvLyBEZWxldGUgdGhlIG9mZmVuZGluZyByZWNvcmRzIGFuZCBhZGQgdGhlIG1lcmdlZCBvbmVzLlxuICAgICAgICAgICAgdmFyIGEgPSB0aGlzLmRpZmZfbWFpbih0ZXh0X2RlbGV0ZSwgdGV4dF9pbnNlcnQsIGZhbHNlKTtcbiAgICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50X2RlbGV0ZSArIGNvdW50X2luc2VydCk7XG4gICAgICAgICAgICBwb2ludGVyID0gcG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydDtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBhLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyLCAwLCBhW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvaW50ZXIgPSBwb2ludGVyICsgYS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvdW50X2luc2VydCA9IDA7XG4gICAgICAgICAgY291bnRfZGVsZXRlID0gMDtcbiAgICAgICAgICB0ZXh0X2RlbGV0ZSA9ICcnO1xuICAgICAgICAgIHRleHRfaW5zZXJ0ID0gJyc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgIHBvaW50ZXIrKztcbiAgICB9XG4gICAgZGlmZnMucG9wKCk7ICAvLyBSZW1vdmUgdGhlIGR1bW15IGVudHJ5IGF0IHRoZSBlbmQuXG4gIH1cbiAgcmV0dXJuIGRpZmZzO1xufTtcblxuXG4vKipcbiAqIFNwbGl0IHR3byB0ZXh0cyBpbnRvIGFuIGFycmF5IG9mIHN0cmluZ3MuICBSZWR1Y2UgdGhlIHRleHRzIHRvIGEgc3RyaW5nIG9mXG4gKiBoYXNoZXMgd2hlcmUgZWFjaCBVbmljb2RlIGNoYXJhY3RlciByZXByZXNlbnRzIG9uZSBsaW5lLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIEZpcnN0IHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBTZWNvbmQgc3RyaW5nLlxuICogQHJldHVybiB7QXJyYXkuPHN0cmluZ3xBcnJheS48c3RyaW5nPj59IFRocmVlIGVsZW1lbnQgQXJyYXksIGNvbnRhaW5pbmcgdGhlXG4gKiAgICAgZW5jb2RlZCB0ZXh0MSwgdGhlIGVuY29kZWQgdGV4dDIgYW5kIHRoZSBhcnJheSBvZiB1bmlxdWUgc3RyaW5ncy4gIFRoZVxuICogICAgIHplcm90aCBlbGVtZW50IG9mIHRoZSBhcnJheSBvZiB1bmlxdWUgc3RyaW5ncyBpcyBpbnRlbnRpb25hbGx5IGJsYW5rLlxuICogQHByaXZhdGVcbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9saW5lc1RvQ2hhcnMgPSBmdW5jdGlvbih0ZXh0MSwgdGV4dDIpIHtcbiAgdmFyIGxpbmVBcnJheSA9IFtdOyAgLy8gZS5nLiBsaW5lQXJyYXlbNF0gPT0gJ0hlbGxvXFxuJ1xuICB2YXIgbGluZUhhc2ggPSB7fTsgICAvLyBlLmcuIGxpbmVIYXNoWydIZWxsb1xcbiddID09IDRcblxuICAvLyAnXFx4MDAnIGlzIGEgdmFsaWQgY2hhcmFjdGVyLCBidXQgdmFyaW91cyBkZWJ1Z2dlcnMgZG9uJ3QgbGlrZSBpdC5cbiAgLy8gU28gd2UnbGwgaW5zZXJ0IGEganVuayBlbnRyeSB0byBhdm9pZCBnZW5lcmF0aW5nIGEgbnVsbCBjaGFyYWN0ZXIuXG4gIGxpbmVBcnJheVswXSA9ICcnO1xuXG4gIC8qKlxuICAgKiBTcGxpdCBhIHRleHQgaW50byBhbiBhcnJheSBvZiBzdHJpbmdzLiAgUmVkdWNlIHRoZSB0ZXh0cyB0byBhIHN0cmluZyBvZlxuICAgKiBoYXNoZXMgd2hlcmUgZWFjaCBVbmljb2RlIGNoYXJhY3RlciByZXByZXNlbnRzIG9uZSBsaW5lLlxuICAgKiBNb2RpZmllcyBsaW5lYXJyYXkgYW5kIGxpbmVoYXNoIHRocm91Z2ggYmVpbmcgYSBjbG9zdXJlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBTdHJpbmcgdG8gZW5jb2RlLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEVuY29kZWQgc3RyaW5nLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZGlmZl9saW5lc1RvQ2hhcnNNdW5nZSh0ZXh0KSB7XG4gICAgdmFyIGNoYXJzID0gJyc7XG4gICAgLy8gV2FsayB0aGUgdGV4dCwgcHVsbGluZyBvdXQgYSBzdWJzdHJpbmcgZm9yIGVhY2ggbGluZS5cbiAgICAvLyB0ZXh0LnNwbGl0KCdcXG4nKSB3b3VsZCB3b3VsZCB0ZW1wb3JhcmlseSBkb3VibGUgb3VyIG1lbW9yeSBmb290cHJpbnQuXG4gICAgLy8gTW9kaWZ5aW5nIHRleHQgd291bGQgY3JlYXRlIG1hbnkgbGFyZ2Ugc3RyaW5ncyB0byBnYXJiYWdlIGNvbGxlY3QuXG4gICAgdmFyIGxpbmVTdGFydCA9IDA7XG4gICAgdmFyIGxpbmVFbmQgPSAtMTtcbiAgICAvLyBLZWVwaW5nIG91ciBvd24gbGVuZ3RoIHZhcmlhYmxlIGlzIGZhc3RlciB0aGFuIGxvb2tpbmcgaXQgdXAuXG4gICAgdmFyIGxpbmVBcnJheUxlbmd0aCA9IGxpbmVBcnJheS5sZW5ndGg7XG4gICAgd2hpbGUgKGxpbmVFbmQgPCB0ZXh0Lmxlbmd0aCAtIDEpIHtcbiAgICAgIGxpbmVFbmQgPSB0ZXh0LmluZGV4T2YoJ1xcbicsIGxpbmVTdGFydCk7XG4gICAgICBpZiAobGluZUVuZCA9PSAtMSkge1xuICAgICAgICBsaW5lRW5kID0gdGV4dC5sZW5ndGggLSAxO1xuICAgICAgfVxuICAgICAgdmFyIGxpbmUgPSB0ZXh0LnN1YnN0cmluZyhsaW5lU3RhcnQsIGxpbmVFbmQgKyAxKTtcbiAgICAgIGxpbmVTdGFydCA9IGxpbmVFbmQgKyAxO1xuXG4gICAgICBpZiAobGluZUhhc2guaGFzT3duUHJvcGVydHkgPyBsaW5lSGFzaC5oYXNPd25Qcm9wZXJ0eShsaW5lKSA6XG4gICAgICAgICAgKGxpbmVIYXNoW2xpbmVdICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIGNoYXJzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGluZUhhc2hbbGluZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hhcnMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsaW5lQXJyYXlMZW5ndGgpO1xuICAgICAgICBsaW5lSGFzaFtsaW5lXSA9IGxpbmVBcnJheUxlbmd0aDtcbiAgICAgICAgbGluZUFycmF5W2xpbmVBcnJheUxlbmd0aCsrXSA9IGxpbmU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGFycztcbiAgfVxuXG4gIHZhciBjaGFyczEgPSBkaWZmX2xpbmVzVG9DaGFyc011bmdlKHRleHQxKTtcbiAgdmFyIGNoYXJzMiA9IGRpZmZfbGluZXNUb0NoYXJzTXVuZ2UodGV4dDIpO1xuICByZXR1cm4gW2NoYXJzMSwgY2hhcnMyLCBsaW5lQXJyYXldO1xufTtcblxuXG4vKipcbiAqIFJlaHlkcmF0ZSB0aGUgdGV4dCBpbiBhIGRpZmYgZnJvbSBhIHN0cmluZyBvZiBsaW5lIGhhc2hlcyB0byByZWFsIGxpbmVzIG9mXG4gKiB0ZXh0LlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcnxzdHJpbmc+Pn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBsaW5lQXJyYXkgQXJyYXkgb2YgdW5pcXVlIHN0cmluZ3MuXG4gKiBAcHJpdmF0ZVxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2NoYXJzVG9MaW5lcyA9IGZ1bmN0aW9uKGRpZmZzLCBsaW5lQXJyYXkpIHtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xuICAgIHZhciBjaGFycyA9IGRpZmZzW3hdWzFdO1xuICAgIHZhciB0ZXh0ID0gW107XG4gICAgZm9yICh2YXIgeSA9IDA7IHkgPCBjaGFycy5sZW5ndGg7IHkrKykge1xuICAgICAgdGV4dFt5XSA9IGxpbmVBcnJheVtjaGFycy5jaGFyQ29kZUF0KHkpXTtcbiAgICB9XG4gICAgZGlmZnNbeF1bMV0gPSB0ZXh0LmpvaW4oJycpO1xuICB9XG59O1xuXG5cbi8qKlxuICogRXhwbG9yZSB0aGUgaW50ZXJzZWN0aW9uIHBvaW50cyBiZXR3ZWVuIHRoZSB0d28gdGV4dHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgT2xkIHN0cmluZyB0byBiZSBkaWZmZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgTmV3IHN0cmluZyB0byBiZSBkaWZmZWQuXG4gKiBAcmV0dXJuIHs/QXJyYXkuPEFycmF5LjxudW1iZXJ8c3RyaW5nPj59IEFycmF5IG9mIGRpZmYgdHVwbGVzIG9yIG51bGwgaWYgbm9cbiAqICAgICBkaWZmIGF2YWlsYWJsZS5cbiAqIEBwcml2YXRlXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfbWFwID0gZnVuY3Rpb24odGV4dDEsIHRleHQyKSB7XG4gIC8vIERvbid0IHJ1biBmb3IgdG9vIGxvbmcuXG4gIHZhciBtc19lbmQgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpICsgdGhpcy5EaWZmX1RpbWVvdXQgKiAxMDAwO1xuICAvLyBDYWNoZSB0aGUgdGV4dCBsZW5ndGhzIHRvIHByZXZlbnQgbXVsdGlwbGUgY2FsbHMuXG4gIHZhciB0ZXh0MV9sZW5ndGggPSB0ZXh0MS5sZW5ndGg7XG4gIHZhciB0ZXh0Ml9sZW5ndGggPSB0ZXh0Mi5sZW5ndGg7XG4gIHZhciBtYXhfZCA9IHRleHQxX2xlbmd0aCArIHRleHQyX2xlbmd0aCAtIDE7XG4gIHZhciBkb3VibGVFbmQgPSB0aGlzLkRpZmZfRHVhbFRocmVzaG9sZCAqIDIgPCBtYXhfZDtcbiAgLy8gSmF2YVNjcmlwdCBlZmZpY2llbmN5IG5vdGU6ICh4IDw8IDMyKSArIHkgZG9lc24ndCB3b3JrIHNpbmNlIG51bWJlcnMgYXJlXG4gIC8vIG9ubHkgMzIgYml0LiAgVXNlIHggKyAnLCcgKyB5IHRvIGNyZWF0ZSBhIGhhc2ggaW5zdGVhZC5cbiAgdmFyIHZfbWFwMSA9IFtdO1xuICB2YXIgdl9tYXAyID0gW107XG4gIHZhciB2MSA9IHt9O1xuICB2YXIgdjIgPSB7fTtcbiAgdjFbMV0gPSAwO1xuICB2MlsxXSA9IDA7XG4gIHZhciB4LCB5O1xuICB2YXIgZm9vdHN0ZXA7ICAvLyBVc2VkIHRvIHRyYWNrIG92ZXJsYXBwaW5nIHBhdGhzLlxuICB2YXIgZm9vdHN0ZXBzID0ge307XG4gIHZhciBkb25lID0gZmFsc2U7XG4gIC8vIElmIHRoZSB0b3RhbCBudW1iZXIgb2YgY2hhcmFjdGVycyBpcyBvZGQsIHRoZW4gdGhlIGZyb250IHBhdGggd2lsbCBjb2xsaWRlXG4gIC8vIHdpdGggdGhlIHJldmVyc2UgcGF0aC5cbiAgdmFyIGZyb250ID0gKHRleHQxX2xlbmd0aCArIHRleHQyX2xlbmd0aCkgJSAyO1xuICBmb3IgKHZhciBkID0gMDsgZCA8IG1heF9kOyBkKyspIHtcbiAgICAvLyBCYWlsIG91dCBpZiB0aW1lb3V0IHJlYWNoZWQuXG4gICAgaWYgKHRoaXMuRGlmZl9UaW1lb3V0ID4gMCAmJiAobmV3IERhdGUoKSkuZ2V0VGltZSgpID4gbXNfZW5kKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBXYWxrIHRoZSBmcm9udCBwYXRoIG9uZSBzdGVwLlxuICAgIHZfbWFwMVtkXSA9IHt9O1xuICAgIGZvciAodmFyIGsgPSAtZDsgayA8PSBkOyBrICs9IDIpIHtcbiAgICAgIGlmIChrID09IC1kIHx8IGsgIT0gZCAmJiB2MVtrIC0gMV0gPCB2MVtrICsgMV0pIHtcbiAgICAgICAgeCA9IHYxW2sgKyAxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSB2MVtrIC0gMV0gKyAxO1xuICAgICAgfVxuICAgICAgeSA9IHggLSBrO1xuICAgICAgaWYgKGRvdWJsZUVuZCkge1xuICAgICAgICBmb290c3RlcCA9IHggKyAnLCcgKyB5O1xuICAgICAgICBpZiAoZnJvbnQgJiYgZm9vdHN0ZXBzW2Zvb3RzdGVwXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmcm9udCkge1xuICAgICAgICAgIGZvb3RzdGVwc1tmb290c3RlcF0gPSBkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAoIWRvbmUgJiYgeCA8IHRleHQxX2xlbmd0aCAmJiB5IDwgdGV4dDJfbGVuZ3RoICYmXG4gICAgICAgICAgICAgdGV4dDEuY2hhckF0KHgpID09IHRleHQyLmNoYXJBdCh5KSkge1xuICAgICAgICB4Kys7XG4gICAgICAgIHkrKztcbiAgICAgICAgaWYgKGRvdWJsZUVuZCkge1xuICAgICAgICAgIGZvb3RzdGVwID0geCArICcsJyArIHk7XG4gICAgICAgICAgaWYgKGZyb250ICYmIGZvb3RzdGVwc1tmb290c3RlcF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZnJvbnQpIHtcbiAgICAgICAgICAgIGZvb3RzdGVwc1tmb290c3RlcF0gPSBkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdjFba10gPSB4O1xuICAgICAgdl9tYXAxW2RdW3ggKyAnLCcgKyB5XSA9IHRydWU7XG4gICAgICBpZiAoeCA9PSB0ZXh0MV9sZW5ndGggJiYgeSA9PSB0ZXh0Ml9sZW5ndGgpIHtcbiAgICAgICAgLy8gUmVhY2hlZCB0aGUgZW5kIGluIHNpbmdsZS1wYXRoIG1vZGUuXG4gICAgICAgIHJldHVybiB0aGlzLmRpZmZfcGF0aDEodl9tYXAxLCB0ZXh0MSwgdGV4dDIpO1xuICAgICAgfSBlbHNlIGlmIChkb25lKSB7XG4gICAgICAgIC8vIEZyb250IHBhdGggcmFuIG92ZXIgcmV2ZXJzZSBwYXRoLlxuICAgICAgICB2X21hcDIgPSB2X21hcDIuc2xpY2UoMCwgZm9vdHN0ZXBzW2Zvb3RzdGVwXSArIDEpO1xuICAgICAgICB2YXIgYSA9IHRoaXMuZGlmZl9wYXRoMSh2X21hcDEsIHRleHQxLnN1YnN0cmluZygwLCB4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDIuc3Vic3RyaW5nKDAsIHkpKTtcbiAgICAgICAgcmV0dXJuIGEuY29uY2F0KHRoaXMuZGlmZl9wYXRoMih2X21hcDIsIHRleHQxLnN1YnN0cmluZyh4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Mi5zdWJzdHJpbmcoeSkpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZG91YmxlRW5kKSB7XG4gICAgICAvLyBXYWxrIHRoZSByZXZlcnNlIHBhdGggb25lIHN0ZXAuXG4gICAgICB2X21hcDJbZF0gPSB7fTtcbiAgICAgIGZvciAodmFyIGsgPSAtZDsgayA8PSBkOyBrICs9IDIpIHtcbiAgICAgICAgaWYgKGsgPT0gLWQgfHwgayAhPSBkICYmIHYyW2sgLSAxXSA8IHYyW2sgKyAxXSkge1xuICAgICAgICAgIHggPSB2MltrICsgMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeCA9IHYyW2sgLSAxXSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgeSA9IHggLSBrO1xuICAgICAgICBmb290c3RlcCA9ICh0ZXh0MV9sZW5ndGggLSB4KSArICcsJyArICh0ZXh0Ml9sZW5ndGggLSB5KTtcbiAgICAgICAgaWYgKCFmcm9udCAmJiBmb290c3RlcHNbZm9vdHN0ZXBdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbnQpIHtcbiAgICAgICAgICBmb290c3RlcHNbZm9vdHN0ZXBdID0gZDtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoIWRvbmUgJiYgeCA8IHRleHQxX2xlbmd0aCAmJiB5IDwgdGV4dDJfbGVuZ3RoICYmXG4gICAgICAgICAgICAgICB0ZXh0MS5jaGFyQXQodGV4dDFfbGVuZ3RoIC0geCAtIDEpID09XG4gICAgICAgICAgICAgICB0ZXh0Mi5jaGFyQXQodGV4dDJfbGVuZ3RoIC0geSAtIDEpKSB7XG4gICAgICAgICAgeCsrO1xuICAgICAgICAgIHkrKztcbiAgICAgICAgICBmb290c3RlcCA9ICh0ZXh0MV9sZW5ndGggLSB4KSArICcsJyArICh0ZXh0Ml9sZW5ndGggLSB5KTtcbiAgICAgICAgICBpZiAoIWZyb250ICYmIGZvb3RzdGVwc1tmb290c3RlcF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmcm9udCkge1xuICAgICAgICAgICAgZm9vdHN0ZXBzW2Zvb3RzdGVwXSA9IGQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHYyW2tdID0geDtcbiAgICAgICAgdl9tYXAyW2RdW3ggKyAnLCcgKyB5XSA9IHRydWU7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgLy8gUmV2ZXJzZSBwYXRoIHJhbiBvdmVyIGZyb250IHBhdGguXG4gICAgICAgICAgdl9tYXAxID0gdl9tYXAxLnNsaWNlKDAsIGZvb3RzdGVwc1tmb290c3RlcF0gKyAxKTtcbiAgICAgICAgICB2YXIgYSA9IHRoaXMuZGlmZl9wYXRoMSh2X21hcDEsIHRleHQxLnN1YnN0cmluZygwLCB0ZXh0MV9sZW5ndGggLSB4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Mi5zdWJzdHJpbmcoMCwgdGV4dDJfbGVuZ3RoIC0geSkpO1xuICAgICAgICAgIHJldHVybiBhLmNvbmNhdCh0aGlzLmRpZmZfcGF0aDIodl9tYXAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0MS5zdWJzdHJpbmcodGV4dDFfbGVuZ3RoIC0geCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQyLnN1YnN0cmluZyh0ZXh0Ml9sZW5ndGggLSB5KSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIE51bWJlciBvZiBkaWZmcyBlcXVhbHMgbnVtYmVyIG9mIGNoYXJhY3RlcnMsIG5vIGNvbW1vbmFsaXR5IGF0IGFsbC5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5cbi8qKlxuICogV29yayBmcm9tIHRoZSBtaWRkbGUgYmFjayB0byB0aGUgc3RhcnQgdG8gZGV0ZXJtaW5lIHRoZSBwYXRoLlxuICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gdl9tYXAgQXJyYXkgb2YgcGF0aHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgT2xkIHN0cmluZyBmcmFnbWVudCB0byBiZSBkaWZmZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgTmV3IHN0cmluZyBmcmFnbWVudCB0byBiZSBkaWZmZWQuXG4gKiBAcmV0dXJuIHtBcnJheS48QXJyYXkuPG51bWJlcnxzdHJpbmc+Pn0gQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX3BhdGgxID0gZnVuY3Rpb24odl9tYXAsIHRleHQxLCB0ZXh0Mikge1xuICB2YXIgcGF0aCA9IFtdO1xuICB2YXIgeCA9IHRleHQxLmxlbmd0aDtcbiAgdmFyIHkgPSB0ZXh0Mi5sZW5ndGg7XG4gIC8qKiBAdHlwZSB7P251bWJlcn0gKi9cbiAgdmFyIGxhc3Rfb3AgPSBudWxsO1xuICBmb3IgKHZhciBkID0gdl9tYXAubGVuZ3RoIC0gMjsgZCA+PSAwOyBkLS0pIHtcbiAgICB3aGlsZSAoMSkge1xuICAgICAgaWYgKHZfbWFwW2RdWyh4IC0gMSkgKyAnLCcgKyB5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHgtLTtcbiAgICAgICAgaWYgKGxhc3Rfb3AgPT09IERJRkZfREVMRVRFKSB7XG4gICAgICAgICAgcGF0aFswXVsxXSA9IHRleHQxLmNoYXJBdCh4KSArIHBhdGhbMF1bMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aC51bnNoaWZ0KFtESUZGX0RFTEVURSwgdGV4dDEuY2hhckF0KHgpXSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdF9vcCA9IERJRkZfREVMRVRFO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAodl9tYXBbZF1beCArICcsJyArICh5IC0gMSldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgeS0tO1xuICAgICAgICBpZiAobGFzdF9vcCA9PT0gRElGRl9JTlNFUlQpIHtcbiAgICAgICAgICBwYXRoWzBdWzFdID0gdGV4dDIuY2hhckF0KHkpICsgcGF0aFswXVsxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRoLnVuc2hpZnQoW0RJRkZfSU5TRVJULCB0ZXh0Mi5jaGFyQXQoeSldKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0X29wID0gRElGRl9JTlNFUlQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeC0tO1xuICAgICAgICB5LS07XG4gICAgICAgIGlmICh0ZXh0MS5jaGFyQXQoeCkgIT0gdGV4dDIuY2hhckF0KHkpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBkaWFnb25hbC4gIENhblxcJ3QgaGFwcGVuLiAoZGlmZl9wYXRoMSknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdF9vcCA9PT0gRElGRl9FUVVBTCkge1xuICAgICAgICAgIHBhdGhbMF1bMV0gPSB0ZXh0MS5jaGFyQXQoeCkgKyBwYXRoWzBdWzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGgudW5zaGlmdChbRElGRl9FUVVBTCwgdGV4dDEuY2hhckF0KHgpXSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdF9vcCA9IERJRkZfRVFVQUw7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXRoO1xufTtcblxuXG4vKipcbiAqIFdvcmsgZnJvbSB0aGUgbWlkZGxlIGJhY2sgdG8gdGhlIGVuZCB0byBkZXRlcm1pbmUgdGhlIHBhdGguXG4gKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSB2X21hcCBBcnJheSBvZiBwYXRocy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBPbGQgc3RyaW5nIGZyYWdtZW50IHRvIGJlIGRpZmZlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBOZXcgc3RyaW5nIGZyYWdtZW50IHRvIGJlIGRpZmZlZC5cbiAqIEByZXR1cm4ge0FycmF5LjxBcnJheS48bnVtYmVyfHN0cmluZz4+fSBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqIEBwcml2YXRlXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfcGF0aDIgPSBmdW5jdGlvbih2X21hcCwgdGV4dDEsIHRleHQyKSB7XG4gIHZhciBwYXRoID0gW107XG4gIHZhciBwYXRoTGVuZ3RoID0gMDtcbiAgdmFyIHggPSB0ZXh0MS5sZW5ndGg7XG4gIHZhciB5ID0gdGV4dDIubGVuZ3RoO1xuICAvKiogQHR5cGUgez9udW1iZXJ9ICovXG4gIHZhciBsYXN0X29wID0gbnVsbDtcbiAgZm9yICh2YXIgZCA9IHZfbWFwLmxlbmd0aCAtIDI7IGQgPj0gMDsgZC0tKSB7XG4gICAgd2hpbGUgKDEpIHtcbiAgICAgIGlmICh2X21hcFtkXVsoeCAtIDEpICsgJywnICsgeV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB4LS07XG4gICAgICAgIGlmIChsYXN0X29wID09PSBESUZGX0RFTEVURSkge1xuICAgICAgICAgIHBhdGhbcGF0aExlbmd0aCAtIDFdWzFdICs9IHRleHQxLmNoYXJBdCh0ZXh0MS5sZW5ndGggLSB4IC0gMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aFtwYXRoTGVuZ3RoKytdID1cbiAgICAgICAgICAgICAgW0RJRkZfREVMRVRFLCB0ZXh0MS5jaGFyQXQodGV4dDEubGVuZ3RoIC0geCAtIDEpXTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0X29wID0gRElGRl9ERUxFVEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmICh2X21hcFtkXVt4ICsgJywnICsgKHkgLSAxKV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB5LS07XG4gICAgICAgIGlmIChsYXN0X29wID09PSBESUZGX0lOU0VSVCkge1xuICAgICAgICAgIHBhdGhbcGF0aExlbmd0aCAtIDFdWzFdICs9IHRleHQyLmNoYXJBdCh0ZXh0Mi5sZW5ndGggLSB5IC0gMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aFtwYXRoTGVuZ3RoKytdID1cbiAgICAgICAgICAgICAgW0RJRkZfSU5TRVJULCB0ZXh0Mi5jaGFyQXQodGV4dDIubGVuZ3RoIC0geSAtIDEpXTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0X29wID0gRElGRl9JTlNFUlQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeC0tO1xuICAgICAgICB5LS07XG4gICAgICAgIGlmICh0ZXh0MS5jaGFyQXQodGV4dDEubGVuZ3RoIC0geCAtIDEpICE9XG4gICAgICAgICAgICB0ZXh0Mi5jaGFyQXQodGV4dDIubGVuZ3RoIC0geSAtIDEpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBkaWFnb25hbC4gIENhblxcJ3QgaGFwcGVuLiAoZGlmZl9wYXRoMiknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdF9vcCA9PT0gRElGRl9FUVVBTCkge1xuICAgICAgICAgIHBhdGhbcGF0aExlbmd0aCAtIDFdWzFdICs9IHRleHQxLmNoYXJBdCh0ZXh0MS5sZW5ndGggLSB4IC0gMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aFtwYXRoTGVuZ3RoKytdID1cbiAgICAgICAgICAgICAgW0RJRkZfRVFVQUwsIHRleHQxLmNoYXJBdCh0ZXh0MS5sZW5ndGggLSB4IC0gMSldO1xuICAgICAgICB9XG4gICAgICAgIGxhc3Rfb3AgPSBESUZGX0VRVUFMO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcGF0aDtcbn07XG5cblxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIGNvbW1vbiBwcmVmaXggb2YgdHdvIHN0cmluZ3NcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBGaXJzdCBzdHJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgU2Vjb25kIHN0cmluZy5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGNvbW1vbiB0byB0aGUgc3RhcnQgb2YgZWFjaFxuICogICAgIHN0cmluZy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jb21tb25QcmVmaXggPSBmdW5jdGlvbih0ZXh0MSwgdGV4dDIpIHtcbiAgLy8gUXVpY2sgY2hlY2sgZm9yIGNvbW1vbiBudWxsIGNhc2VzLlxuICBpZiAoIXRleHQxIHx8ICF0ZXh0MiB8fCB0ZXh0MS5jaGFyQXQoMCkgIT0gdGV4dDIuY2hhckF0KDApKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgLy8gQmluYXJ5IHNlYXJjaC5cbiAgLy8gUGVyZm9ybWFuY2UgYW5hbHlzaXM6IGh0dHA6Ly9uZWlsLmZyYXNlci5uYW1lL25ld3MvMjAwNy8xMC8wOS9cbiAgdmFyIHBvaW50ZXJtaW4gPSAwO1xuICB2YXIgcG9pbnRlcm1heCA9IE1hdGgubWluKHRleHQxLmxlbmd0aCwgdGV4dDIubGVuZ3RoKTtcbiAgdmFyIHBvaW50ZXJtaWQgPSBwb2ludGVybWF4O1xuICB2YXIgcG9pbnRlcnN0YXJ0ID0gMDtcbiAgd2hpbGUgKHBvaW50ZXJtaW4gPCBwb2ludGVybWlkKSB7XG4gICAgaWYgKHRleHQxLnN1YnN0cmluZyhwb2ludGVyc3RhcnQsIHBvaW50ZXJtaWQpID09XG4gICAgICAgIHRleHQyLnN1YnN0cmluZyhwb2ludGVyc3RhcnQsIHBvaW50ZXJtaWQpKSB7XG4gICAgICBwb2ludGVybWluID0gcG9pbnRlcm1pZDtcbiAgICAgIHBvaW50ZXJzdGFydCA9IHBvaW50ZXJtaW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50ZXJtYXggPSBwb2ludGVybWlkO1xuICAgIH1cbiAgICBwb2ludGVybWlkID0gTWF0aC5mbG9vcigocG9pbnRlcm1heCAtIHBvaW50ZXJtaW4pIC8gMiArIHBvaW50ZXJtaW4pO1xuICB9XG4gIHJldHVybiBwb2ludGVybWlkO1xufTtcblxuXG4vKipcbiAqIERldGVybWluZSB0aGUgY29tbW9uIHN1ZmZpeCBvZiB0d28gc3RyaW5nc1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIEZpcnN0IHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBTZWNvbmQgc3RyaW5nLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgY29tbW9uIHRvIHRoZSBlbmQgb2YgZWFjaCBzdHJpbmcuXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfY29tbW9uU3VmZml4ID0gZnVuY3Rpb24odGV4dDEsIHRleHQyKSB7XG4gIC8vIFF1aWNrIGNoZWNrIGZvciBjb21tb24gbnVsbCBjYXNlcy5cbiAgaWYgKCF0ZXh0MSB8fCAhdGV4dDIgfHwgdGV4dDEuY2hhckF0KHRleHQxLmxlbmd0aCAtIDEpICE9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQyLmNoYXJBdCh0ZXh0Mi5sZW5ndGggLSAxKSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIC8vIEJpbmFyeSBzZWFyY2guXG4gIC8vIFBlcmZvcm1hbmNlIGFuYWx5c2lzOiBodHRwOi8vbmVpbC5mcmFzZXIubmFtZS9uZXdzLzIwMDcvMTAvMDkvXG4gIHZhciBwb2ludGVybWluID0gMDtcbiAgdmFyIHBvaW50ZXJtYXggPSBNYXRoLm1pbih0ZXh0MS5sZW5ndGgsIHRleHQyLmxlbmd0aCk7XG4gIHZhciBwb2ludGVybWlkID0gcG9pbnRlcm1heDtcbiAgdmFyIHBvaW50ZXJlbmQgPSAwO1xuICB3aGlsZSAocG9pbnRlcm1pbiA8IHBvaW50ZXJtaWQpIHtcbiAgICBpZiAodGV4dDEuc3Vic3RyaW5nKHRleHQxLmxlbmd0aCAtIHBvaW50ZXJtaWQsIHRleHQxLmxlbmd0aCAtIHBvaW50ZXJlbmQpID09XG4gICAgICAgIHRleHQyLnN1YnN0cmluZyh0ZXh0Mi5sZW5ndGggLSBwb2ludGVybWlkLCB0ZXh0Mi5sZW5ndGggLSBwb2ludGVyZW5kKSkge1xuICAgICAgcG9pbnRlcm1pbiA9IHBvaW50ZXJtaWQ7XG4gICAgICBwb2ludGVyZW5kID0gcG9pbnRlcm1pbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRlcm1heCA9IHBvaW50ZXJtaWQ7XG4gICAgfVxuICAgIHBvaW50ZXJtaWQgPSBNYXRoLmZsb29yKChwb2ludGVybWF4IC0gcG9pbnRlcm1pbikgLyAyICsgcG9pbnRlcm1pbik7XG4gIH1cbiAgcmV0dXJuIHBvaW50ZXJtaWQ7XG59O1xuXG5cbi8qKlxuICogRG8gdGhlIHR3byB0ZXh0cyBzaGFyZSBhIHN1YnN0cmluZyB3aGljaCBpcyBhdCBsZWFzdCBoYWxmIHRoZSBsZW5ndGggb2YgdGhlXG4gKiBsb25nZXIgdGV4dD9cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBGaXJzdCBzdHJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgU2Vjb25kIHN0cmluZy5cbiAqIEByZXR1cm4gez9BcnJheS48c3RyaW5nPn0gRml2ZSBlbGVtZW50IEFycmF5LCBjb250YWluaW5nIHRoZSBwcmVmaXggb2ZcbiAqICAgICB0ZXh0MSwgdGhlIHN1ZmZpeCBvZiB0ZXh0MSwgdGhlIHByZWZpeCBvZiB0ZXh0MiwgdGhlIHN1ZmZpeCBvZlxuICogICAgIHRleHQyIGFuZCB0aGUgY29tbW9uIG1pZGRsZS4gIE9yIG51bGwgaWYgdGhlcmUgd2FzIG5vIG1hdGNoLlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2hhbGZNYXRjaCA9IGZ1bmN0aW9uKHRleHQxLCB0ZXh0Mikge1xuICB2YXIgbG9uZ3RleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MSA6IHRleHQyO1xuICB2YXIgc2hvcnR0ZXh0ID0gdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gdGV4dDIgOiB0ZXh0MTtcbiAgaWYgKGxvbmd0ZXh0Lmxlbmd0aCA8IDEwIHx8IHNob3J0dGV4dC5sZW5ndGggPCAxKSB7XG4gICAgcmV0dXJuIG51bGw7ICAvLyBQb2ludGxlc3MuXG4gIH1cbiAgdmFyIGRtcCA9IHRoaXM7ICAvLyAndGhpcycgYmVjb21lcyAnd2luZG93JyBpbiBhIGNsb3N1cmUuXG5cbiAgLyoqXG4gICAqIERvZXMgYSBzdWJzdHJpbmcgb2Ygc2hvcnR0ZXh0IGV4aXN0IHdpdGhpbiBsb25ndGV4dCBzdWNoIHRoYXQgdGhlIHN1YnN0cmluZ1xuICAgKiBpcyBhdCBsZWFzdCBoYWxmIHRoZSBsZW5ndGggb2YgbG9uZ3RleHQ/XG4gICAqIENsb3N1cmUsIGJ1dCBkb2VzIG5vdCByZWZlcmVuY2UgYW55IGV4dGVybmFsIHZhcmlhYmxlcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxvbmd0ZXh0IExvbmdlciBzdHJpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzaG9ydHRleHQgU2hvcnRlciBzdHJpbmcuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpIFN0YXJ0IGluZGV4IG9mIHF1YXJ0ZXIgbGVuZ3RoIHN1YnN0cmluZyB3aXRoaW4gbG9uZ3RleHRcbiAgICogQHJldHVybiB7P0FycmF5LjxzdHJpbmc+fSBGaXZlIGVsZW1lbnQgQXJyYXksIGNvbnRhaW5pbmcgdGhlIHByZWZpeCBvZlxuICAgKiAgICAgbG9uZ3RleHQsIHRoZSBzdWZmaXggb2YgbG9uZ3RleHQsIHRoZSBwcmVmaXggb2Ygc2hvcnR0ZXh0LCB0aGUgc3VmZml4XG4gICAqICAgICBvZiBzaG9ydHRleHQgYW5kIHRoZSBjb21tb24gbWlkZGxlLiAgT3IgbnVsbCBpZiB0aGVyZSB3YXMgbm8gbWF0Y2guXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBkaWZmX2hhbGZNYXRjaEkobG9uZ3RleHQsIHNob3J0dGV4dCwgaSkge1xuICAgIC8vIFN0YXJ0IHdpdGggYSAxLzQgbGVuZ3RoIHN1YnN0cmluZyBhdCBwb3NpdGlvbiBpIGFzIGEgc2VlZC5cbiAgICB2YXIgc2VlZCA9IGxvbmd0ZXh0LnN1YnN0cmluZyhpLCBpICsgTWF0aC5mbG9vcihsb25ndGV4dC5sZW5ndGggLyA0KSk7XG4gICAgdmFyIGogPSAtMTtcbiAgICB2YXIgYmVzdF9jb21tb24gPSAnJztcbiAgICB2YXIgYmVzdF9sb25ndGV4dF9hLCBiZXN0X2xvbmd0ZXh0X2IsIGJlc3Rfc2hvcnR0ZXh0X2EsIGJlc3Rfc2hvcnR0ZXh0X2I7XG4gICAgd2hpbGUgKChqID0gc2hvcnR0ZXh0LmluZGV4T2Yoc2VlZCwgaiArIDEpKSAhPSAtMSkge1xuICAgICAgdmFyIHByZWZpeExlbmd0aCA9IGRtcC5kaWZmX2NvbW1vblByZWZpeChsb25ndGV4dC5zdWJzdHJpbmcoaSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3J0dGV4dC5zdWJzdHJpbmcoaikpO1xuICAgICAgdmFyIHN1ZmZpeExlbmd0aCA9IGRtcC5kaWZmX2NvbW1vblN1ZmZpeChsb25ndGV4dC5zdWJzdHJpbmcoMCwgaSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3J0dGV4dC5zdWJzdHJpbmcoMCwgaikpO1xuICAgICAgaWYgKGJlc3RfY29tbW9uLmxlbmd0aCA8IHN1ZmZpeExlbmd0aCArIHByZWZpeExlbmd0aCkge1xuICAgICAgICBiZXN0X2NvbW1vbiA9IHNob3J0dGV4dC5zdWJzdHJpbmcoaiAtIHN1ZmZpeExlbmd0aCwgaikgK1xuICAgICAgICAgICAgc2hvcnR0ZXh0LnN1YnN0cmluZyhqLCBqICsgcHJlZml4TGVuZ3RoKTtcbiAgICAgICAgYmVzdF9sb25ndGV4dF9hID0gbG9uZ3RleHQuc3Vic3RyaW5nKDAsIGkgLSBzdWZmaXhMZW5ndGgpO1xuICAgICAgICBiZXN0X2xvbmd0ZXh0X2IgPSBsb25ndGV4dC5zdWJzdHJpbmcoaSArIHByZWZpeExlbmd0aCk7XG4gICAgICAgIGJlc3Rfc2hvcnR0ZXh0X2EgPSBzaG9ydHRleHQuc3Vic3RyaW5nKDAsIGogLSBzdWZmaXhMZW5ndGgpO1xuICAgICAgICBiZXN0X3Nob3J0dGV4dF9iID0gc2hvcnR0ZXh0LnN1YnN0cmluZyhqICsgcHJlZml4TGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJlc3RfY29tbW9uLmxlbmd0aCA+PSBsb25ndGV4dC5sZW5ndGggLyAyKSB7XG4gICAgICByZXR1cm4gW2Jlc3RfbG9uZ3RleHRfYSwgYmVzdF9sb25ndGV4dF9iLFxuICAgICAgICAgICAgICBiZXN0X3Nob3J0dGV4dF9hLCBiZXN0X3Nob3J0dGV4dF9iLCBiZXN0X2NvbW1vbl07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZpcnN0IGNoZWNrIGlmIHRoZSBzZWNvbmQgcXVhcnRlciBpcyB0aGUgc2VlZCBmb3IgYSBoYWxmLW1hdGNoLlxuICB2YXIgaG0xID0gZGlmZl9oYWxmTWF0Y2hJKGxvbmd0ZXh0LCBzaG9ydHRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5jZWlsKGxvbmd0ZXh0Lmxlbmd0aCAvIDQpKTtcbiAgLy8gQ2hlY2sgYWdhaW4gYmFzZWQgb24gdGhlIHRoaXJkIHF1YXJ0ZXIuXG4gIHZhciBobTIgPSBkaWZmX2hhbGZNYXRjaEkobG9uZ3RleHQsIHNob3J0dGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmNlaWwobG9uZ3RleHQubGVuZ3RoIC8gMikpO1xuICB2YXIgaG07XG4gIGlmICghaG0xICYmICFobTIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmICghaG0yKSB7XG4gICAgaG0gPSBobTE7XG4gIH0gZWxzZSBpZiAoIWhtMSkge1xuICAgIGhtID0gaG0yO1xuICB9IGVsc2Uge1xuICAgIC8vIEJvdGggbWF0Y2hlZC4gIFNlbGVjdCB0aGUgbG9uZ2VzdC5cbiAgICBobSA9IGhtMVs0XS5sZW5ndGggPiBobTJbNF0ubGVuZ3RoID8gaG0xIDogaG0yO1xuICB9XG5cbiAgLy8gQSBoYWxmLW1hdGNoIHdhcyBmb3VuZCwgc29ydCBvdXQgdGhlIHJldHVybiBkYXRhLlxuICB2YXIgdGV4dDFfYSwgdGV4dDFfYiwgdGV4dDJfYSwgdGV4dDJfYjtcbiAgaWYgKHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCkge1xuICAgIHRleHQxX2EgPSBobVswXTtcbiAgICB0ZXh0MV9iID0gaG1bMV07XG4gICAgdGV4dDJfYSA9IGhtWzJdO1xuICAgIHRleHQyX2IgPSBobVszXTtcbiAgfSBlbHNlIHtcbiAgICB0ZXh0Ml9hID0gaG1bMF07XG4gICAgdGV4dDJfYiA9IGhtWzFdO1xuICAgIHRleHQxX2EgPSBobVsyXTtcbiAgICB0ZXh0MV9iID0gaG1bM107XG4gIH1cbiAgdmFyIG1pZF9jb21tb24gPSBobVs0XTtcbiAgcmV0dXJuIFt0ZXh0MV9hLCB0ZXh0MV9iLCB0ZXh0Ml9hLCB0ZXh0Ml9iLCBtaWRfY29tbW9uXTtcbn07XG5cblxuLyoqXG4gKiBSZWR1Y2UgdGhlIG51bWJlciBvZiBlZGl0cyBieSBlbGltaW5hdGluZyBzZW1hbnRpY2FsbHkgdHJpdmlhbCBlcXVhbGl0aWVzLlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcnxzdHJpbmc+Pn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfY2xlYW51cFNlbWFudGljID0gZnVuY3Rpb24oZGlmZnMpIHtcbiAgdmFyIGNoYW5nZXMgPSBmYWxzZTtcbiAgdmFyIGVxdWFsaXRpZXMgPSBbXTsgIC8vIFN0YWNrIG9mIGluZGljZXMgd2hlcmUgZXF1YWxpdGllcyBhcmUgZm91bmQuXG4gIHZhciBlcXVhbGl0aWVzTGVuZ3RoID0gMDsgIC8vIEtlZXBpbmcgb3VyIG93biBsZW5ndGggdmFyIGlzIGZhc3RlciBpbiBKUy5cbiAgdmFyIGxhc3RlcXVhbGl0eSA9IG51bGw7ICAvLyBBbHdheXMgZXF1YWwgdG8gZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoLTFdWzFdXG4gIHZhciBwb2ludGVyID0gMDsgIC8vIEluZGV4IG9mIGN1cnJlbnQgcG9zaXRpb24uXG4gIC8vIE51bWJlciBvZiBjaGFyYWN0ZXJzIHRoYXQgY2hhbmdlZCBwcmlvciB0byB0aGUgZXF1YWxpdHkuXG4gIHZhciBsZW5ndGhfY2hhbmdlczEgPSAwO1xuICAvLyBOdW1iZXIgb2YgY2hhcmFjdGVycyB0aGF0IGNoYW5nZWQgYWZ0ZXIgdGhlIGVxdWFsaXR5LlxuICB2YXIgbGVuZ3RoX2NoYW5nZXMyID0gMDtcbiAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGgpIHtcbiAgICBpZiAoZGlmZnNbcG9pbnRlcl1bMF0gPT0gRElGRl9FUVVBTCkgeyAgLy8gZXF1YWxpdHkgZm91bmRcbiAgICAgIGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCsrXSA9IHBvaW50ZXI7XG4gICAgICBsZW5ndGhfY2hhbmdlczEgPSBsZW5ndGhfY2hhbmdlczI7XG4gICAgICBsZW5ndGhfY2hhbmdlczIgPSAwO1xuICAgICAgbGFzdGVxdWFsaXR5ID0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgfSBlbHNlIHsgIC8vIGFuIGluc2VydGlvbiBvciBkZWxldGlvblxuICAgICAgbGVuZ3RoX2NoYW5nZXMyICs9IGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aDtcbiAgICAgIGlmIChsYXN0ZXF1YWxpdHkgIT09IG51bGwgJiYgKGxhc3RlcXVhbGl0eS5sZW5ndGggPD0gbGVuZ3RoX2NoYW5nZXMxKSAmJlxuICAgICAgICAgIChsYXN0ZXF1YWxpdHkubGVuZ3RoIDw9IGxlbmd0aF9jaGFuZ2VzMikpIHtcbiAgICAgICAgLy8gRHVwbGljYXRlIHJlY29yZFxuICAgICAgICBkaWZmcy5zcGxpY2UoZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0sIDAsXG4gICAgICAgICAgICAgICAgICAgICBbRElGRl9ERUxFVEUsIGxhc3RlcXVhbGl0eV0pO1xuICAgICAgICAvLyBDaGFuZ2Ugc2Vjb25kIGNvcHkgdG8gaW5zZXJ0LlxuICAgICAgICBkaWZmc1tlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSArIDFdWzBdID0gRElGRl9JTlNFUlQ7XG4gICAgICAgIC8vIFRocm93IGF3YXkgdGhlIGVxdWFsaXR5IHdlIGp1c3QgZGVsZXRlZC5cbiAgICAgICAgZXF1YWxpdGllc0xlbmd0aC0tO1xuICAgICAgICAvLyBUaHJvdyBhd2F5IHRoZSBwcmV2aW91cyBlcXVhbGl0eSAoaXQgbmVlZHMgdG8gYmUgcmVldmFsdWF0ZWQpLlxuICAgICAgICBlcXVhbGl0aWVzTGVuZ3RoLS07XG4gICAgICAgIHBvaW50ZXIgPSBlcXVhbGl0aWVzTGVuZ3RoID4gMCA/IGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdIDogLTE7XG4gICAgICAgIGxlbmd0aF9jaGFuZ2VzMSA9IDA7ICAvLyBSZXNldCB0aGUgY291bnRlcnMuXG4gICAgICAgIGxlbmd0aF9jaGFuZ2VzMiA9IDA7XG4gICAgICAgIGxhc3RlcXVhbGl0eSA9IG51bGw7XG4gICAgICAgIGNoYW5nZXMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBwb2ludGVyKys7XG4gIH1cbiAgaWYgKGNoYW5nZXMpIHtcbiAgICB0aGlzLmRpZmZfY2xlYW51cE1lcmdlKGRpZmZzKTtcbiAgfVxuICB0aGlzLmRpZmZfY2xlYW51cFNlbWFudGljTG9zc2xlc3MoZGlmZnMpO1xufTtcblxuXG4vKipcbiAqIExvb2sgZm9yIHNpbmdsZSBlZGl0cyBzdXJyb3VuZGVkIG9uIGJvdGggc2lkZXMgYnkgZXF1YWxpdGllc1xuICogd2hpY2ggY2FuIGJlIHNoaWZ0ZWQgc2lkZXdheXMgdG8gYWxpZ24gdGhlIGVkaXQgdG8gYSB3b3JkIGJvdW5kYXJ5LlxuICogZS5nOiBUaGUgYzxpbnM+YXQgYzwvaW5zPmFtZS4gLT4gVGhlIDxpbnM+Y2F0IDwvaW5zPmNhbWUuXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyfHN0cmluZz4+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jbGVhbnVwU2VtYW50aWNMb3NzbGVzcyA9IGZ1bmN0aW9uKGRpZmZzKSB7XG4gIC8vIERlZmluZSBzb21lIHJlZ2V4IHBhdHRlcm5zIGZvciBtYXRjaGluZyBib3VuZGFyaWVzLlxuICB2YXIgcHVuY3R1YXRpb24gPSAvW15hLXpBLVowLTldLztcbiAgdmFyIHdoaXRlc3BhY2UgPSAvXFxzLztcbiAgdmFyIGxpbmVicmVhayA9IC9bXFxyXFxuXS87XG4gIHZhciBibGFua2xpbmVFbmQgPSAvXFxuXFxyP1xcbiQvO1xuICB2YXIgYmxhbmtsaW5lU3RhcnQgPSAvXlxccj9cXG5cXHI/XFxuLztcblxuICAvKipcbiAgICogR2l2ZW4gdHdvIHN0cmluZ3MsIGNvbXB1dGUgYSBzY29yZSByZXByZXNlbnRpbmcgd2hldGhlciB0aGUgaW50ZXJuYWxcbiAgICogYm91bmRhcnkgZmFsbHMgb24gbG9naWNhbCBib3VuZGFyaWVzLlxuICAgKiBTY29yZXMgcmFuZ2UgZnJvbSA1IChiZXN0KSB0byAwICh3b3JzdCkuXG4gICAqIENsb3N1cmUsIG1ha2VzIHJlZmVyZW5jZSB0byByZWdleCBwYXR0ZXJucyBkZWZpbmVkIGFib3ZlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb25lIEZpcnN0IHN0cmluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR3byBTZWNvbmQgc3RyaW5nLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzY29yZS5cbiAgICovXG4gIGZ1bmN0aW9uIGRpZmZfY2xlYW51cFNlbWFudGljU2NvcmUob25lLCB0d28pIHtcbiAgICBpZiAoIW9uZSB8fCAhdHdvKSB7XG4gICAgICAvLyBFZGdlcyBhcmUgdGhlIGJlc3QuXG4gICAgICByZXR1cm4gNTtcbiAgICB9XG5cbiAgICAvLyBFYWNoIHBvcnQgb2YgdGhpcyBmdW5jdGlvbiBiZWhhdmVzIHNsaWdodGx5IGRpZmZlcmVudGx5IGR1ZSB0b1xuICAgIC8vIHN1YnRsZSBkaWZmZXJlbmNlcyBpbiBlYWNoIGxhbmd1YWdlJ3MgZGVmaW5pdGlvbiBvZiB0aGluZ3MgbGlrZVxuICAgIC8vICd3aGl0ZXNwYWNlJy4gIFNpbmNlIHRoaXMgZnVuY3Rpb24ncyBwdXJwb3NlIGlzIGxhcmdlbHkgY29zbWV0aWMsXG4gICAgLy8gdGhlIGNob2ljZSBoYXMgYmVlbiBtYWRlIHRvIHVzZSBlYWNoIGxhbmd1YWdlJ3MgbmF0aXZlIGZlYXR1cmVzXG4gICAgLy8gcmF0aGVyIHRoYW4gZm9yY2UgdG90YWwgY29uZm9ybWl0eS5cbiAgICB2YXIgc2NvcmUgPSAwO1xuICAgIC8vIE9uZSBwb2ludCBmb3Igbm9uLWFscGhhbnVtZXJpYy5cbiAgICBpZiAob25lLmNoYXJBdChvbmUubGVuZ3RoIC0gMSkubWF0Y2gocHVuY3R1YXRpb24pIHx8XG4gICAgICAgIHR3by5jaGFyQXQoMCkubWF0Y2gocHVuY3R1YXRpb24pKSB7XG4gICAgICBzY29yZSsrO1xuICAgICAgLy8gVHdvIHBvaW50cyBmb3Igd2hpdGVzcGFjZS5cbiAgICAgIGlmIChvbmUuY2hhckF0KG9uZS5sZW5ndGggLSAxKS5tYXRjaCh3aGl0ZXNwYWNlKSB8fFxuICAgICAgICAgIHR3by5jaGFyQXQoMCkubWF0Y2god2hpdGVzcGFjZSkpIHtcbiAgICAgICAgc2NvcmUrKztcbiAgICAgICAgLy8gVGhyZWUgcG9pbnRzIGZvciBsaW5lIGJyZWFrcy5cbiAgICAgICAgaWYgKG9uZS5jaGFyQXQob25lLmxlbmd0aCAtIDEpLm1hdGNoKGxpbmVicmVhaykgfHxcbiAgICAgICAgICAgIHR3by5jaGFyQXQoMCkubWF0Y2gobGluZWJyZWFrKSkge1xuICAgICAgICAgIHNjb3JlKys7XG4gICAgICAgICAgLy8gRm91ciBwb2ludHMgZm9yIGJsYW5rIGxpbmVzLlxuICAgICAgICAgIGlmIChvbmUubWF0Y2goYmxhbmtsaW5lRW5kKSB8fCB0d28ubWF0Y2goYmxhbmtsaW5lU3RhcnQpKSB7XG4gICAgICAgICAgICBzY29yZSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2NvcmU7XG4gIH1cblxuICB2YXIgcG9pbnRlciA9IDE7XG4gIC8vIEludGVudGlvbmFsbHkgaWdub3JlIHRoZSBmaXJzdCBhbmQgbGFzdCBlbGVtZW50IChkb24ndCBuZWVkIGNoZWNraW5nKS5cbiAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGggLSAxKSB7XG4gICAgaWYgKGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PSBESUZGX0VRVUFMICYmXG4gICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVswXSA9PSBESUZGX0VRVUFMKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgc2luZ2xlIGVkaXQgc3Vycm91bmRlZCBieSBlcXVhbGl0aWVzLlxuICAgICAgdmFyIGVxdWFsaXR5MSA9IGRpZmZzW3BvaW50ZXIgLSAxXVsxXTtcbiAgICAgIHZhciBlZGl0ID0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICB2YXIgZXF1YWxpdHkyID0gZGlmZnNbcG9pbnRlciArIDFdWzFdO1xuXG4gICAgICAvLyBGaXJzdCwgc2hpZnQgdGhlIGVkaXQgYXMgZmFyIGxlZnQgYXMgcG9zc2libGUuXG4gICAgICB2YXIgY29tbW9uT2Zmc2V0ID0gdGhpcy5kaWZmX2NvbW1vblN1ZmZpeChlcXVhbGl0eTEsIGVkaXQpO1xuICAgICAgaWYgKGNvbW1vbk9mZnNldCkge1xuICAgICAgICB2YXIgY29tbW9uU3RyaW5nID0gZWRpdC5zdWJzdHJpbmcoZWRpdC5sZW5ndGggLSBjb21tb25PZmZzZXQpO1xuICAgICAgICBlcXVhbGl0eTEgPSBlcXVhbGl0eTEuc3Vic3RyaW5nKDAsIGVxdWFsaXR5MS5sZW5ndGggLSBjb21tb25PZmZzZXQpO1xuICAgICAgICBlZGl0ID0gY29tbW9uU3RyaW5nICsgZWRpdC5zdWJzdHJpbmcoMCwgZWRpdC5sZW5ndGggLSBjb21tb25PZmZzZXQpO1xuICAgICAgICBlcXVhbGl0eTIgPSBjb21tb25TdHJpbmcgKyBlcXVhbGl0eTI7XG4gICAgICB9XG5cbiAgICAgIC8vIFNlY29uZCwgc3RlcCBjaGFyYWN0ZXIgYnkgY2hhcmFjdGVyIHJpZ2h0LCBsb29raW5nIGZvciB0aGUgYmVzdCBmaXQuXG4gICAgICB2YXIgYmVzdEVxdWFsaXR5MSA9IGVxdWFsaXR5MTtcbiAgICAgIHZhciBiZXN0RWRpdCA9IGVkaXQ7XG4gICAgICB2YXIgYmVzdEVxdWFsaXR5MiA9IGVxdWFsaXR5MjtcbiAgICAgIHZhciBiZXN0U2NvcmUgPSBkaWZmX2NsZWFudXBTZW1hbnRpY1Njb3JlKGVxdWFsaXR5MSwgZWRpdCkgK1xuICAgICAgICAgIGRpZmZfY2xlYW51cFNlbWFudGljU2NvcmUoZWRpdCwgZXF1YWxpdHkyKTtcbiAgICAgIHdoaWxlIChlZGl0LmNoYXJBdCgwKSA9PT0gZXF1YWxpdHkyLmNoYXJBdCgwKSkge1xuICAgICAgICBlcXVhbGl0eTEgKz0gZWRpdC5jaGFyQXQoMCk7XG4gICAgICAgIGVkaXQgPSBlZGl0LnN1YnN0cmluZygxKSArIGVxdWFsaXR5Mi5jaGFyQXQoMCk7XG4gICAgICAgIGVxdWFsaXR5MiA9IGVxdWFsaXR5Mi5zdWJzdHJpbmcoMSk7XG4gICAgICAgIHZhciBzY29yZSA9IGRpZmZfY2xlYW51cFNlbWFudGljU2NvcmUoZXF1YWxpdHkxLCBlZGl0KSArXG4gICAgICAgICAgICBkaWZmX2NsZWFudXBTZW1hbnRpY1Njb3JlKGVkaXQsIGVxdWFsaXR5Mik7XG4gICAgICAgIC8vIFRoZSA+PSBlbmNvdXJhZ2VzIHRyYWlsaW5nIHJhdGhlciB0aGFuIGxlYWRpbmcgd2hpdGVzcGFjZSBvbiBlZGl0cy5cbiAgICAgICAgaWYgKHNjb3JlID49IGJlc3RTY29yZSkge1xuICAgICAgICAgIGJlc3RTY29yZSA9IHNjb3JlO1xuICAgICAgICAgIGJlc3RFcXVhbGl0eTEgPSBlcXVhbGl0eTE7XG4gICAgICAgICAgYmVzdEVkaXQgPSBlZGl0O1xuICAgICAgICAgIGJlc3RFcXVhbGl0eTIgPSBlcXVhbGl0eTI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGRpZmZzW3BvaW50ZXIgLSAxXVsxXSAhPSBiZXN0RXF1YWxpdHkxKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgYW4gaW1wcm92ZW1lbnQsIHNhdmUgaXQgYmFjayB0byB0aGUgZGlmZi5cbiAgICAgICAgaWYgKGJlc3RFcXVhbGl0eTEpIHtcbiAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0gPSBiZXN0RXF1YWxpdHkxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gMSwgMSk7XG4gICAgICAgICAgcG9pbnRlci0tO1xuICAgICAgICB9XG4gICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdID0gYmVzdEVkaXQ7XG4gICAgICAgIGlmIChiZXN0RXF1YWxpdHkyKSB7XG4gICAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzFdID0gYmVzdEVxdWFsaXR5MjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciArIDEsIDEpO1xuICAgICAgICAgIHBvaW50ZXItLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBwb2ludGVyKys7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBSZWR1Y2UgdGhlIG51bWJlciBvZiBlZGl0cyBieSBlbGltaW5hdGluZyBvcGVyYXRpb25hbGx5IHRyaXZpYWwgZXF1YWxpdGllcy5cbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXJ8c3RyaW5nPj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2NsZWFudXBFZmZpY2llbmN5ID0gZnVuY3Rpb24oZGlmZnMpIHtcbiAgdmFyIGNoYW5nZXMgPSBmYWxzZTtcbiAgdmFyIGVxdWFsaXRpZXMgPSBbXTsgIC8vIFN0YWNrIG9mIGluZGljZXMgd2hlcmUgZXF1YWxpdGllcyBhcmUgZm91bmQuXG4gIHZhciBlcXVhbGl0aWVzTGVuZ3RoID0gMDsgIC8vIEtlZXBpbmcgb3VyIG93biBsZW5ndGggdmFyIGlzIGZhc3RlciBpbiBKUy5cbiAgdmFyIGxhc3RlcXVhbGl0eSA9ICcnOyAgLy8gQWx3YXlzIGVxdWFsIHRvIGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aC0xXVsxXVxuICB2YXIgcG9pbnRlciA9IDA7ICAvLyBJbmRleCBvZiBjdXJyZW50IHBvc2l0aW9uLlxuICAvLyBJcyB0aGVyZSBhbiBpbnNlcnRpb24gb3BlcmF0aW9uIGJlZm9yZSB0aGUgbGFzdCBlcXVhbGl0eS5cbiAgdmFyIHByZV9pbnMgPSBmYWxzZTtcbiAgLy8gSXMgdGhlcmUgYSBkZWxldGlvbiBvcGVyYXRpb24gYmVmb3JlIHRoZSBsYXN0IGVxdWFsaXR5LlxuICB2YXIgcHJlX2RlbCA9IGZhbHNlO1xuICAvLyBJcyB0aGVyZSBhbiBpbnNlcnRpb24gb3BlcmF0aW9uIGFmdGVyIHRoZSBsYXN0IGVxdWFsaXR5LlxuICB2YXIgcG9zdF9pbnMgPSBmYWxzZTtcbiAgLy8gSXMgdGhlcmUgYSBkZWxldGlvbiBvcGVyYXRpb24gYWZ0ZXIgdGhlIGxhc3QgZXF1YWxpdHkuXG4gIHZhciBwb3N0X2RlbCA9IGZhbHNlO1xuICB3aGlsZSAocG9pbnRlciA8IGRpZmZzLmxlbmd0aCkge1xuICAgIGlmIChkaWZmc1twb2ludGVyXVswXSA9PSBESUZGX0VRVUFMKSB7ICAvLyBlcXVhbGl0eSBmb3VuZFxuICAgICAgaWYgKGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aCA8IHRoaXMuRGlmZl9FZGl0Q29zdCAmJlxuICAgICAgICAgIChwb3N0X2lucyB8fCBwb3N0X2RlbCkpIHtcbiAgICAgICAgLy8gQ2FuZGlkYXRlIGZvdW5kLlxuICAgICAgICBlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGgrK10gPSBwb2ludGVyO1xuICAgICAgICBwcmVfaW5zID0gcG9zdF9pbnM7XG4gICAgICAgIHByZV9kZWwgPSBwb3N0X2RlbDtcbiAgICAgICAgbGFzdGVxdWFsaXR5ID0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb3QgYSBjYW5kaWRhdGUsIGFuZCBjYW4gbmV2ZXIgYmVjb21lIG9uZS5cbiAgICAgICAgZXF1YWxpdGllc0xlbmd0aCA9IDA7XG4gICAgICAgIGxhc3RlcXVhbGl0eSA9ICcnO1xuICAgICAgfVxuICAgICAgcG9zdF9pbnMgPSBwb3N0X2RlbCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7ICAvLyBhbiBpbnNlcnRpb24gb3IgZGVsZXRpb25cbiAgICAgIGlmIChkaWZmc1twb2ludGVyXVswXSA9PSBESUZGX0RFTEVURSkge1xuICAgICAgICBwb3N0X2RlbCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3N0X2lucyA9IHRydWU7XG4gICAgICB9XG4gICAgICAvKlxuICAgICAgICogRml2ZSB0eXBlcyB0byBiZSBzcGxpdDpcbiAgICAgICAqIDxpbnM+QTwvaW5zPjxkZWw+QjwvZGVsPlhZPGlucz5DPC9pbnM+PGRlbD5EPC9kZWw+XG4gICAgICAgKiA8aW5zPkE8L2lucz5YPGlucz5DPC9pbnM+PGRlbD5EPC9kZWw+XG4gICAgICAgKiA8aW5zPkE8L2lucz48ZGVsPkI8L2RlbD5YPGlucz5DPC9pbnM+XG4gICAgICAgKiA8aW5zPkE8L2RlbD5YPGlucz5DPC9pbnM+PGRlbD5EPC9kZWw+XG4gICAgICAgKiA8aW5zPkE8L2lucz48ZGVsPkI8L2RlbD5YPGRlbD5DPC9kZWw+XG4gICAgICAgKi9cbiAgICAgIGlmIChsYXN0ZXF1YWxpdHkgJiYgKChwcmVfaW5zICYmIHByZV9kZWwgJiYgcG9zdF9pbnMgJiYgcG9zdF9kZWwpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoKGxhc3RlcXVhbGl0eS5sZW5ndGggPCB0aGlzLkRpZmZfRWRpdENvc3QgLyAyKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwcmVfaW5zICsgcHJlX2RlbCArIHBvc3RfaW5zICsgcG9zdF9kZWwpID09IDMpKSkge1xuICAgICAgICAvLyBEdXBsaWNhdGUgcmVjb3JkXG4gICAgICAgIGRpZmZzLnNwbGljZShlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSwgMCxcbiAgICAgICAgICAgICAgICAgICAgIFtESUZGX0RFTEVURSwgbGFzdGVxdWFsaXR5XSk7XG4gICAgICAgIC8vIENoYW5nZSBzZWNvbmQgY29weSB0byBpbnNlcnQuXG4gICAgICAgIGRpZmZzW2VxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdICsgMV1bMF0gPSBESUZGX0lOU0VSVDtcbiAgICAgICAgZXF1YWxpdGllc0xlbmd0aC0tOyAgLy8gVGhyb3cgYXdheSB0aGUgZXF1YWxpdHkgd2UganVzdCBkZWxldGVkO1xuICAgICAgICBsYXN0ZXF1YWxpdHkgPSAnJztcbiAgICAgICAgaWYgKHByZV9pbnMgJiYgcHJlX2RlbCkge1xuICAgICAgICAgIC8vIE5vIGNoYW5nZXMgbWFkZSB3aGljaCBjb3VsZCBhZmZlY3QgcHJldmlvdXMgZW50cnksIGtlZXAgZ29pbmcuXG4gICAgICAgICAgcG9zdF9pbnMgPSBwb3N0X2RlbCA9IHRydWU7XG4gICAgICAgICAgZXF1YWxpdGllc0xlbmd0aCA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXF1YWxpdGllc0xlbmd0aC0tOyAgLy8gVGhyb3cgYXdheSB0aGUgcHJldmlvdXMgZXF1YWxpdHk7XG4gICAgICAgICAgcG9pbnRlciA9IGVxdWFsaXRpZXNMZW5ndGggPiAwID9cbiAgICAgICAgICAgICAgZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0gOiAtMTtcbiAgICAgICAgICBwb3N0X2lucyA9IHBvc3RfZGVsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY2hhbmdlcyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHBvaW50ZXIrKztcbiAgfVxuXG4gIGlmIChjaGFuZ2VzKSB7XG4gICAgdGhpcy5kaWZmX2NsZWFudXBNZXJnZShkaWZmcyk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBSZW9yZGVyIGFuZCBtZXJnZSBsaWtlIGVkaXQgc2VjdGlvbnMuICBNZXJnZSBlcXVhbGl0aWVzLlxuICogQW55IGVkaXQgc2VjdGlvbiBjYW4gbW92ZSBhcyBsb25nIGFzIGl0IGRvZXNuJ3QgY3Jvc3MgYW4gZXF1YWxpdHkuXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyfHN0cmluZz4+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jbGVhbnVwTWVyZ2UgPSBmdW5jdGlvbihkaWZmcykge1xuICBkaWZmcy5wdXNoKFtESUZGX0VRVUFMLCAnJ10pOyAgLy8gQWRkIGEgZHVtbXkgZW50cnkgYXQgdGhlIGVuZC5cbiAgdmFyIHBvaW50ZXIgPSAwO1xuICB2YXIgY291bnRfZGVsZXRlID0gMDtcbiAgdmFyIGNvdW50X2luc2VydCA9IDA7XG4gIHZhciB0ZXh0X2RlbGV0ZSA9ICcnO1xuICB2YXIgdGV4dF9pbnNlcnQgPSAnJztcbiAgdmFyIGNvbW1vbmxlbmd0aDtcbiAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGgpIHtcbiAgICBzd2l0Y2ggKGRpZmZzW3BvaW50ZXJdWzBdKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICBjb3VudF9pbnNlcnQrKztcbiAgICAgICAgdGV4dF9pbnNlcnQgKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxuICAgICAgICBjb3VudF9kZWxldGUrKztcbiAgICAgICAgdGV4dF9kZWxldGUgKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgIC8vIFVwb24gcmVhY2hpbmcgYW4gZXF1YWxpdHksIGNoZWNrIGZvciBwcmlvciByZWR1bmRhbmNpZXMuXG4gICAgICAgIGlmIChjb3VudF9kZWxldGUgIT09IDAgfHwgY291bnRfaW5zZXJ0ICE9PSAwKSB7XG4gICAgICAgICAgaWYgKGNvdW50X2RlbGV0ZSAhPT0gMCAmJiBjb3VudF9pbnNlcnQgIT09IDApIHtcbiAgICAgICAgICAgIC8vIEZhY3RvciBvdXQgYW55IGNvbW1vbiBwcmVmaXhpZXMuXG4gICAgICAgICAgICBjb21tb25sZW5ndGggPSB0aGlzLmRpZmZfY29tbW9uUHJlZml4KHRleHRfaW5zZXJ0LCB0ZXh0X2RlbGV0ZSk7XG4gICAgICAgICAgICBpZiAoY29tbW9ubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgIGlmICgocG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCkgPiAwICYmXG4gICAgICAgICAgICAgICAgICBkaWZmc1twb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0IC0gMV1bMF0gPT1cbiAgICAgICAgICAgICAgICAgIERJRkZfRVFVQUwpIHtcbiAgICAgICAgICAgICAgICBkaWZmc1twb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0IC0gMV1bMV0gKz1cbiAgICAgICAgICAgICAgICAgICAgdGV4dF9pbnNlcnQuc3Vic3RyaW5nKDAsIGNvbW1vbmxlbmd0aCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlmZnMuc3BsaWNlKDAsIDAsIFtESUZGX0VRVUFMLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0X2luc2VydC5zdWJzdHJpbmcoMCwgY29tbW9ubGVuZ3RoKV0pO1xuICAgICAgICAgICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0ZXh0X2luc2VydCA9IHRleHRfaW5zZXJ0LnN1YnN0cmluZyhjb21tb25sZW5ndGgpO1xuICAgICAgICAgICAgICB0ZXh0X2RlbGV0ZSA9IHRleHRfZGVsZXRlLnN1YnN0cmluZyhjb21tb25sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmFjdG9yIG91dCBhbnkgY29tbW9uIHN1ZmZpeGllcy5cbiAgICAgICAgICAgIGNvbW1vbmxlbmd0aCA9IHRoaXMuZGlmZl9jb21tb25TdWZmaXgodGV4dF9pbnNlcnQsIHRleHRfZGVsZXRlKTtcbiAgICAgICAgICAgIGlmIChjb21tb25sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0gPSB0ZXh0X2luc2VydC5zdWJzdHJpbmcodGV4dF9pbnNlcnQubGVuZ3RoIC1cbiAgICAgICAgICAgICAgICAgIGNvbW1vbmxlbmd0aCkgKyBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgICAgICAgICAgdGV4dF9pbnNlcnQgPSB0ZXh0X2luc2VydC5zdWJzdHJpbmcoMCwgdGV4dF9pbnNlcnQubGVuZ3RoIC1cbiAgICAgICAgICAgICAgICAgIGNvbW1vbmxlbmd0aCk7XG4gICAgICAgICAgICAgIHRleHRfZGVsZXRlID0gdGV4dF9kZWxldGUuc3Vic3RyaW5nKDAsIHRleHRfZGVsZXRlLmxlbmd0aCAtXG4gICAgICAgICAgICAgICAgICBjb21tb25sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBEZWxldGUgdGhlIG9mZmVuZGluZyByZWNvcmRzIGFuZCBhZGQgdGhlIG1lcmdlZCBvbmVzLlxuICAgICAgICAgIGlmIChjb3VudF9kZWxldGUgPT09IDApIHtcbiAgICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0LFxuICAgICAgICAgICAgICAgIGNvdW50X2RlbGV0ZSArIGNvdW50X2luc2VydCwgW0RJRkZfSU5TRVJULCB0ZXh0X2luc2VydF0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY291bnRfaW5zZXJ0ID09PSAwKSB7XG4gICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCxcbiAgICAgICAgICAgICAgICBjb3VudF9kZWxldGUgKyBjb3VudF9pbnNlcnQsIFtESUZGX0RFTEVURSwgdGV4dF9kZWxldGVdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSBjb3VudF9kZWxldGUgLSBjb3VudF9pbnNlcnQsXG4gICAgICAgICAgICAgICAgY291bnRfZGVsZXRlICsgY291bnRfaW5zZXJ0LCBbRElGRl9ERUxFVEUsIHRleHRfZGVsZXRlXSxcbiAgICAgICAgICAgICAgICBbRElGRl9JTlNFUlQsIHRleHRfaW5zZXJ0XSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvaW50ZXIgPSBwb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0ICtcbiAgICAgICAgICAgICAgICAgICAgKGNvdW50X2RlbGV0ZSA/IDEgOiAwKSArIChjb3VudF9pbnNlcnQgPyAxIDogMCkgKyAxO1xuICAgICAgICB9IGVsc2UgaWYgKHBvaW50ZXIgIT09IDAgJiYgZGlmZnNbcG9pbnRlciAtIDFdWzBdID09IERJRkZfRVFVQUwpIHtcbiAgICAgICAgICAvLyBNZXJnZSB0aGlzIGVxdWFsaXR5IHdpdGggdGhlIHByZXZpb3VzIG9uZS5cbiAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0gKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIsIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgfVxuICAgICAgICBjb3VudF9pbnNlcnQgPSAwO1xuICAgICAgICBjb3VudF9kZWxldGUgPSAwO1xuICAgICAgICB0ZXh0X2RlbGV0ZSA9ICcnO1xuICAgICAgICB0ZXh0X2luc2VydCA9ICcnO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzFdID09PSAnJykge1xuICAgIGRpZmZzLnBvcCgpOyAgLy8gUmVtb3ZlIHRoZSBkdW1teSBlbnRyeSBhdCB0aGUgZW5kLlxuICB9XG5cbiAgLy8gU2Vjb25kIHBhc3M6IGxvb2sgZm9yIHNpbmdsZSBlZGl0cyBzdXJyb3VuZGVkIG9uIGJvdGggc2lkZXMgYnkgZXF1YWxpdGllc1xuICAvLyB3aGljaCBjYW4gYmUgc2hpZnRlZCBzaWRld2F5cyB0byBlbGltaW5hdGUgYW4gZXF1YWxpdHkuXG4gIC8vIGUuZzogQTxpbnM+QkE8L2lucz5DIC0+IDxpbnM+QUI8L2lucz5BQ1xuICB2YXIgY2hhbmdlcyA9IGZhbHNlO1xuICBwb2ludGVyID0gMTtcbiAgLy8gSW50ZW50aW9uYWxseSBpZ25vcmUgdGhlIGZpcnN0IGFuZCBsYXN0IGVsZW1lbnQgKGRvbid0IG5lZWQgY2hlY2tpbmcpLlxuICB3aGlsZSAocG9pbnRlciA8IGRpZmZzLmxlbmd0aCAtIDEpIHtcbiAgICBpZiAoZGlmZnNbcG9pbnRlciAtIDFdWzBdID09IERJRkZfRVFVQUwgJiZcbiAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzBdID09IERJRkZfRVFVQUwpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBzaW5nbGUgZWRpdCBzdXJyb3VuZGVkIGJ5IGVxdWFsaXRpZXMuXG4gICAgICBpZiAoZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aCAtXG4gICAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdLmxlbmd0aCkgPT0gZGlmZnNbcG9pbnRlciAtIDFdWzFdKSB7XG4gICAgICAgIC8vIFNoaWZ0IHRoZSBlZGl0IG92ZXIgdGhlIHByZXZpb3VzIGVxdWFsaXR5LlxuICAgICAgICBkaWZmc1twb2ludGVyXVsxXSA9IGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArXG4gICAgICAgICAgICBkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoMCwgZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0ubGVuZ3RoKTtcbiAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzFdID0gZGlmZnNbcG9pbnRlciAtIDFdWzFdICsgZGlmZnNbcG9pbnRlciArIDFdWzFdO1xuICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciAtIDEsIDEpO1xuICAgICAgICBjaGFuZ2VzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKDAsIGRpZmZzW3BvaW50ZXIgKyAxXVsxXS5sZW5ndGgpID09XG4gICAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzFdKSB7XG4gICAgICAgIC8vIFNoaWZ0IHRoZSBlZGl0IG92ZXIgdGhlIG5leHQgZXF1YWxpdHkuXG4gICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArPSBkaWZmc1twb2ludGVyICsgMV1bMV07XG4gICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdID1cbiAgICAgICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZyhkaWZmc1twb2ludGVyICsgMV1bMV0ubGVuZ3RoKSArXG4gICAgICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMV07XG4gICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyICsgMSwgMSk7XG4gICAgICAgIGNoYW5nZXMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBwb2ludGVyKys7XG4gIH1cbiAgLy8gSWYgc2hpZnRzIHdlcmUgbWFkZSwgdGhlIGRpZmYgbmVlZHMgcmVvcmRlcmluZyBhbmQgYW5vdGhlciBzaGlmdCBzd2VlcC5cbiAgaWYgKGNoYW5nZXMpIHtcbiAgICB0aGlzLmRpZmZfY2xlYW51cE1lcmdlKGRpZmZzKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIGxvYyBpcyBhIGxvY2F0aW9uIGluIHRleHQxLCBjb21wdXRlIGFuZCByZXR1cm4gdGhlIGVxdWl2YWxlbnQgbG9jYXRpb24gaW5cbiAqIHRleHQyLlxuICogZS5nLiAnVGhlIGNhdCcgdnMgJ1RoZSBiaWcgY2F0JywgMS0+MSwgNS0+OFxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcnxzdHJpbmc+Pn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gbG9jIExvY2F0aW9uIHdpdGhpbiB0ZXh0MS5cbiAqIEByZXR1cm4ge251bWJlcn0gTG9jYXRpb24gd2l0aGluIHRleHQyLlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX3hJbmRleCA9IGZ1bmN0aW9uKGRpZmZzLCBsb2MpIHtcbiAgdmFyIGNoYXJzMSA9IDA7XG4gIHZhciBjaGFyczIgPSAwO1xuICB2YXIgbGFzdF9jaGFyczEgPSAwO1xuICB2YXIgbGFzdF9jaGFyczIgPSAwO1xuICB2YXIgeDtcbiAgZm9yICh4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgaWYgKGRpZmZzW3hdWzBdICE9PSBESUZGX0lOU0VSVCkgeyAgLy8gRXF1YWxpdHkgb3IgZGVsZXRpb24uXG4gICAgICBjaGFyczEgKz0gZGlmZnNbeF1bMV0ubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAoZGlmZnNbeF1bMF0gIT09IERJRkZfREVMRVRFKSB7ICAvLyBFcXVhbGl0eSBvciBpbnNlcnRpb24uXG4gICAgICBjaGFyczIgKz0gZGlmZnNbeF1bMV0ubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAoY2hhcnMxID4gbG9jKSB7ICAvLyBPdmVyc2hvdCB0aGUgbG9jYXRpb24uXG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbGFzdF9jaGFyczEgPSBjaGFyczE7XG4gICAgbGFzdF9jaGFyczIgPSBjaGFyczI7XG4gIH1cbiAgLy8gV2FzIHRoZSBsb2NhdGlvbiB3YXMgZGVsZXRlZD9cbiAgaWYgKGRpZmZzLmxlbmd0aCAhPSB4ICYmIGRpZmZzW3hdWzBdID09PSBESUZGX0RFTEVURSkge1xuICAgIHJldHVybiBsYXN0X2NoYXJzMjtcbiAgfVxuICAvLyBBZGQgdGhlIHJlbWFpbmluZyBjaGFyYWN0ZXIgbGVuZ3RoLlxuICByZXR1cm4gbGFzdF9jaGFyczIgKyAobG9jIC0gbGFzdF9jaGFyczEpO1xufTtcblxuXG4vKipcbiAqIENvbnZlcnQgYSBkaWZmIGFycmF5IGludG8gYSBwcmV0dHkgSFRNTCByZXBvcnQuXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyfHN0cmluZz4+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqIEByZXR1cm4ge3N0cmluZ30gSFRNTCByZXByZXNlbnRhdGlvbi5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9wcmV0dHlIdG1sID0gZnVuY3Rpb24oZGlmZnMpIHtcbiAgdmFyIGh0bWwgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICBmb3IgKHZhciB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgdmFyIG9wID0gZGlmZnNbeF1bMF07ICAgIC8vIE9wZXJhdGlvbiAoaW5zZXJ0LCBkZWxldGUsIGVxdWFsKVxuICAgIHZhciBkYXRhID0gZGlmZnNbeF1bMV07ICAvLyBUZXh0IG9mIGNoYW5nZS5cbiAgICB2YXIgdGV4dCA9IGRhdGEucmVwbGFjZSgvJi9nLCAnJmFtcDsnKS5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAgICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKS5yZXBsYWNlKC9cXG4vZywgJyZwYXJhOzxCUj4nKTtcbiAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICBodG1sW3hdID0gJzxJTlMgU1RZTEU9XCJiYWNrZ3JvdW5kOiNFNkZGRTY7XCIgVElUTEU9XCJpPScgKyBpICsgJ1wiPicgK1xuICAgICAgICAgICAgICAgIHRleHQgKyAnPC9JTlM+JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxuICAgICAgICBodG1sW3hdID0gJzxERUwgU1RZTEU9XCJiYWNrZ3JvdW5kOiNGRkU2RTY7XCIgVElUTEU9XCJpPScgKyBpICsgJ1wiPicgK1xuICAgICAgICAgICAgICAgIHRleHQgKyAnPC9ERUw+JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgIGh0bWxbeF0gPSAnPFNQQU4gVElUTEU9XCJpPScgKyBpICsgJ1wiPicgKyB0ZXh0ICsgJzwvU1BBTj4nO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKG9wICE9PSBESUZGX0RFTEVURSkge1xuICAgICAgaSArPSBkYXRhLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGh0bWwuam9pbignJyk7XG59O1xuXG5cbi8qKlxuICogQ29tcHV0ZSBhbmQgcmV0dXJuIHRoZSBzb3VyY2UgdGV4dCAoYWxsIGVxdWFsaXRpZXMgYW5kIGRlbGV0aW9ucykuXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyfHN0cmluZz4+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqIEByZXR1cm4ge3N0cmluZ30gU291cmNlIHRleHQuXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfdGV4dDEgPSBmdW5jdGlvbihkaWZmcykge1xuICB2YXIgdGV4dCA9IFtdO1xuICBmb3IgKHZhciB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgaWYgKGRpZmZzW3hdWzBdICE9PSBESUZGX0lOU0VSVCkge1xuICAgICAgdGV4dFt4XSA9IGRpZmZzW3hdWzFdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGV4dC5qb2luKCcnKTtcbn07XG5cblxuLyoqXG4gKiBDb21wdXRlIGFuZCByZXR1cm4gdGhlIGRlc3RpbmF0aW9uIHRleHQgKGFsbCBlcXVhbGl0aWVzIGFuZCBpbnNlcnRpb25zKS5cbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXJ8c3RyaW5nPj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICogQHJldHVybiB7c3RyaW5nfSBEZXN0aW5hdGlvbiB0ZXh0LlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX3RleHQyID0gZnVuY3Rpb24oZGlmZnMpIHtcbiAgdmFyIHRleHQgPSBbXTtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xuICAgIGlmIChkaWZmc1t4XVswXSAhPT0gRElGRl9ERUxFVEUpIHtcbiAgICAgIHRleHRbeF0gPSBkaWZmc1t4XVsxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRleHQuam9pbignJyk7XG59O1xuXG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgTGV2ZW5zaHRlaW4gZGlzdGFuY2U7IHRoZSBudW1iZXIgb2YgaW5zZXJ0ZWQsIGRlbGV0ZWQgb3JcbiAqIHN1YnN0aXR1dGVkIGNoYXJhY3RlcnMuXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyfHN0cmluZz4+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqIEByZXR1cm4ge251bWJlcn0gTnVtYmVyIG9mIGNoYW5nZXMuXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfbGV2ZW5zaHRlaW4gPSBmdW5jdGlvbihkaWZmcykge1xuICB2YXIgbGV2ZW5zaHRlaW4gPSAwO1xuICB2YXIgaW5zZXJ0aW9ucyA9IDA7XG4gIHZhciBkZWxldGlvbnMgPSAwO1xuICBmb3IgKHZhciB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgdmFyIG9wID0gZGlmZnNbeF1bMF07XG4gICAgdmFyIGRhdGEgPSBkaWZmc1t4XVsxXTtcbiAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICBpbnNlcnRpb25zICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XG4gICAgICAgIGRlbGV0aW9ucyArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgIC8vIEEgZGVsZXRpb24gYW5kIGFuIGluc2VydGlvbiBpcyBvbmUgc3Vic3RpdHV0aW9uLlxuICAgICAgICBsZXZlbnNodGVpbiArPSBNYXRoLm1heChpbnNlcnRpb25zLCBkZWxldGlvbnMpO1xuICAgICAgICBpbnNlcnRpb25zID0gMDtcbiAgICAgICAgZGVsZXRpb25zID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGxldmVuc2h0ZWluICs9IE1hdGgubWF4KGluc2VydGlvbnMsIGRlbGV0aW9ucyk7XG4gIHJldHVybiBsZXZlbnNodGVpbjtcbn07XG5cblxuLyoqXG4gKiBDcnVzaCB0aGUgZGlmZiBpbnRvIGFuIGVuY29kZWQgc3RyaW5nIHdoaWNoIGRlc2NyaWJlcyB0aGUgb3BlcmF0aW9uc1xuICogcmVxdWlyZWQgdG8gdHJhbnNmb3JtIHRleHQxIGludG8gdGV4dDIuXG4gKiBFLmcuID0zXFx0LTJcXHQraW5nICAtPiBLZWVwIDMgY2hhcnMsIGRlbGV0ZSAyIGNoYXJzLCBpbnNlcnQgJ2luZycuXG4gKiBPcGVyYXRpb25zIGFyZSB0YWItc2VwYXJhdGVkLiAgSW5zZXJ0ZWQgdGV4dCBpcyBlc2NhcGVkIHVzaW5nICV4eCBub3RhdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXJ8c3RyaW5nPj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICogQHJldHVybiB7c3RyaW5nfSBEZWx0YSB0ZXh0LlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX3RvRGVsdGEgPSBmdW5jdGlvbihkaWZmcykge1xuICB2YXIgdGV4dCA9IFtdO1xuICBmb3IgKHZhciB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgc3dpdGNoIChkaWZmc1t4XVswXSkge1xuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcbiAgICAgICAgdGV4dFt4XSA9ICcrJyArIGVuY29kZVVSSShkaWZmc1t4XVsxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0RFTEVURTpcbiAgICAgICAgdGV4dFt4XSA9ICctJyArIGRpZmZzW3hdWzFdLmxlbmd0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgIHRleHRbeF0gPSAnPScgKyBkaWZmc1t4XVsxXS5sZW5ndGg7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICAvLyBPcGVyYSBkb2Vzbid0IGtub3cgaG93IHRvIGVuY29kZSBjaGFyIDAuXG4gIHJldHVybiB0ZXh0LmpvaW4oJ1xcdCcpLnJlcGxhY2UoL1xceDAwL2csICclMDAnKS5yZXBsYWNlKC8lMjAvZywgJyAnKTtcbn07XG5cblxuLyoqXG4gKiBHaXZlbiB0aGUgb3JpZ2luYWwgdGV4dDEsIGFuZCBhbiBlbmNvZGVkIHN0cmluZyB3aGljaCBkZXNjcmliZXMgdGhlXG4gKiBvcGVyYXRpb25zIHJlcXVpcmVkIHRvIHRyYW5zZm9ybSB0ZXh0MSBpbnRvIHRleHQyLCBjb21wdXRlIHRoZSBmdWxsIGRpZmYuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgU291cmNlIHN0cmluZyBmb3IgdGhlIGRpZmYuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVsdGEgRGVsdGEgdGV4dC5cbiAqIEByZXR1cm4ge0FycmF5LjxBcnJheS48bnVtYmVyfHN0cmluZz4+fSBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBpbnZhbGlkIGlucHV0LlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2Zyb21EZWx0YSA9IGZ1bmN0aW9uKHRleHQxLCBkZWx0YSkge1xuICB2YXIgZGlmZnMgPSBbXTtcbiAgdmFyIGRpZmZzTGVuZ3RoID0gMDsgIC8vIEtlZXBpbmcgb3VyIG93biBsZW5ndGggdmFyIGlzIGZhc3RlciBpbiBKUy5cbiAgdmFyIHBvaW50ZXIgPSAwOyAgLy8gQ3Vyc29yIGluIHRleHQxXG4gIC8vIE9wZXJhIGRvZXNuJ3Qga25vdyBob3cgdG8gZGVjb2RlIGNoYXIgMC5cbiAgZGVsdGEgPSBkZWx0YS5yZXBsYWNlKC8lMDAvZywgJ1xcMCcpO1xuICB2YXIgdG9rZW5zID0gZGVsdGEuc3BsaXQoL1xcdC9nKTtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCB0b2tlbnMubGVuZ3RoOyB4KyspIHtcbiAgICAvLyBFYWNoIHRva2VuIGJlZ2lucyB3aXRoIGEgb25lIGNoYXJhY3RlciBwYXJhbWV0ZXIgd2hpY2ggc3BlY2lmaWVzIHRoZVxuICAgIC8vIG9wZXJhdGlvbiBvZiB0aGlzIHRva2VuIChkZWxldGUsIGluc2VydCwgZXF1YWxpdHkpLlxuICAgIHZhciBwYXJhbSA9IHRva2Vuc1t4XS5zdWJzdHJpbmcoMSk7XG4gICAgc3dpdGNoICh0b2tlbnNbeF0uY2hhckF0KDApKSB7XG4gICAgICBjYXNlICcrJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkaWZmc1tkaWZmc0xlbmd0aCsrXSA9IFtESUZGX0lOU0VSVCwgZGVjb2RlVVJJKHBhcmFtKV07XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgLy8gTWFsZm9ybWVkIFVSSSBzZXF1ZW5jZS5cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgZXNjYXBlIGluIGRpZmZfZnJvbURlbHRhOiAnICsgcGFyYW0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnLSc6XG4gICAgICAgIC8vIEZhbGwgdGhyb3VnaC5cbiAgICAgIGNhc2UgJz0nOlxuICAgICAgICB2YXIgbiA9IHBhcnNlSW50KHBhcmFtLCAxMCk7XG4gICAgICAgIGlmIChpc05hTihuKSB8fCBuIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBudW1iZXIgaW4gZGlmZl9mcm9tRGVsdGE6ICcgKyBwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRleHQgPSB0ZXh0MS5zdWJzdHJpbmcocG9pbnRlciwgcG9pbnRlciArPSBuKTtcbiAgICAgICAgaWYgKHRva2Vuc1t4XS5jaGFyQXQoMCkgPT0gJz0nKSB7XG4gICAgICAgICAgZGlmZnNbZGlmZnNMZW5ndGgrK10gPSBbRElGRl9FUVVBTCwgdGV4dF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGlmZnNbZGlmZnNMZW5ndGgrK10gPSBbRElGRl9ERUxFVEUsIHRleHRdO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gQmxhbmsgdG9rZW5zIGFyZSBvayAoZnJvbSBhIHRyYWlsaW5nIFxcdCkuXG4gICAgICAgIC8vIEFueXRoaW5nIGVsc2UgaXMgYW4gZXJyb3IuXG4gICAgICAgIGlmICh0b2tlbnNbeF0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGlmZiBvcGVyYXRpb24gaW4gZGlmZl9mcm9tRGVsdGE6ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnNbeF0pO1xuICAgICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChwb2ludGVyICE9IHRleHQxLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRGVsdGEgbGVuZ3RoICgnICsgcG9pbnRlciArXG4gICAgICAgICcpIGRvZXMgbm90IGVxdWFsIHNvdXJjZSB0ZXh0IGxlbmd0aCAoJyArIHRleHQxLmxlbmd0aCArICcpLicpO1xuICB9XG4gIHJldHVybiBkaWZmcztcbn07XG5cblxuLy8gIE1BVENIIEZVTkNUSU9OU1xuXG5cbi8qKlxuICogTG9jYXRlIHRoZSBiZXN0IGluc3RhbmNlIG9mICdwYXR0ZXJuJyBpbiAndGV4dCcgbmVhciAnbG9jJy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIHNlYXJjaC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gbG9jIFRoZSBsb2NhdGlvbiB0byBzZWFyY2ggYXJvdW5kLlxuICogQHJldHVybiB7bnVtYmVyfSBCZXN0IG1hdGNoIGluZGV4IG9yIC0xLlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5tYXRjaF9tYWluID0gZnVuY3Rpb24odGV4dCwgcGF0dGVybiwgbG9jKSB7XG4gIC8vIENoZWNrIGZvciBudWxsIGlucHV0cy5cbiAgaWYgKHRleHQgPT0gbnVsbCB8fCBwYXR0ZXJuID09IG51bGwgfHwgbG9jID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ051bGwgaW5wdXQuIChtYXRjaF9tYWluKScpO1xuICB9XG5cbiAgbG9jID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obG9jLCB0ZXh0Lmxlbmd0aCkpO1xuICBpZiAodGV4dCA9PSBwYXR0ZXJuKSB7XG4gICAgLy8gU2hvcnRjdXQgKHBvdGVudGlhbGx5IG5vdCBndWFyYW50ZWVkIGJ5IHRoZSBhbGdvcml0aG0pXG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSBpZiAoIXRleHQubGVuZ3RoKSB7XG4gICAgLy8gTm90aGluZyB0byBtYXRjaC5cbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAodGV4dC5zdWJzdHJpbmcobG9jLCBsb2MgKyBwYXR0ZXJuLmxlbmd0aCkgPT0gcGF0dGVybikge1xuICAgIC8vIFBlcmZlY3QgbWF0Y2ggYXQgdGhlIHBlcmZlY3Qgc3BvdCEgIChJbmNsdWRlcyBjYXNlIG9mIG51bGwgcGF0dGVybilcbiAgICByZXR1cm4gbG9jO1xuICB9IGVsc2Uge1xuICAgIC8vIERvIGEgZnV6enkgY29tcGFyZS5cbiAgICByZXR1cm4gdGhpcy5tYXRjaF9iaXRhcCh0ZXh0LCBwYXR0ZXJuLCBsb2MpO1xuICB9XG59O1xuXG5cbi8qKlxuICogTG9jYXRlIHRoZSBiZXN0IGluc3RhbmNlIG9mICdwYXR0ZXJuJyBpbiAndGV4dCcgbmVhciAnbG9jJyB1c2luZyB0aGVcbiAqIEJpdGFwIGFsZ29yaXRobS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIHNlYXJjaC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gbG9jIFRoZSBsb2NhdGlvbiB0byBzZWFyY2ggYXJvdW5kLlxuICogQHJldHVybiB7bnVtYmVyfSBCZXN0IG1hdGNoIGluZGV4IG9yIC0xLlxuICogQHByaXZhdGVcbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUubWF0Y2hfYml0YXAgPSBmdW5jdGlvbih0ZXh0LCBwYXR0ZXJuLCBsb2MpIHtcbiAgaWYgKHBhdHRlcm4ubGVuZ3RoID4gdGhpcy5NYXRjaF9NYXhCaXRzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYXR0ZXJuIHRvbyBsb25nIGZvciB0aGlzIGJyb3dzZXIuJyk7XG4gIH1cblxuICAvLyBJbml0aWFsaXNlIHRoZSBhbHBoYWJldC5cbiAgdmFyIHMgPSB0aGlzLm1hdGNoX2FscGhhYmV0KHBhdHRlcm4pO1xuXG4gIHZhciBkbXAgPSB0aGlzOyAgLy8gJ3RoaXMnIGJlY29tZXMgJ3dpbmRvdycgaW4gYSBjbG9zdXJlLlxuXG4gIC8qKlxuICAgKiBDb21wdXRlIGFuZCByZXR1cm4gdGhlIHNjb3JlIGZvciBhIG1hdGNoIHdpdGggZSBlcnJvcnMgYW5kIHggbG9jYXRpb24uXG4gICAqIEFjY2Vzc2VzIGxvYyBhbmQgcGF0dGVybiB0aHJvdWdoIGJlaW5nIGEgY2xvc3VyZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGUgTnVtYmVyIG9mIGVycm9ycyBpbiBtYXRjaC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggTG9jYXRpb24gb2YgbWF0Y2guXG4gICAqIEByZXR1cm4ge251bWJlcn0gT3ZlcmFsbCBzY29yZSBmb3IgbWF0Y2ggKDAuMCA9IGdvb2QsIDEuMCA9IGJhZCkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBtYXRjaF9iaXRhcFNjb3JlKGUsIHgpIHtcbiAgICB2YXIgYWNjdXJhY3kgPSBlIC8gcGF0dGVybi5sZW5ndGg7XG4gICAgdmFyIHByb3hpbWl0eSA9IE1hdGguYWJzKGxvYyAtIHgpO1xuICAgIGlmICghZG1wLk1hdGNoX0Rpc3RhbmNlKSB7XG4gICAgICAvLyBEb2RnZSBkaXZpZGUgYnkgemVybyBlcnJvci5cbiAgICAgIHJldHVybiBwcm94aW1pdHkgPyAxLjAgOiBhY2N1cmFjeTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY3VyYWN5ICsgKHByb3hpbWl0eSAvIGRtcC5NYXRjaF9EaXN0YW5jZSk7XG4gIH1cblxuICAvLyBIaWdoZXN0IHNjb3JlIGJleW9uZCB3aGljaCB3ZSBnaXZlIHVwLlxuICB2YXIgc2NvcmVfdGhyZXNob2xkID0gdGhpcy5NYXRjaF9UaHJlc2hvbGQ7XG4gIC8vIElzIHRoZXJlIGEgbmVhcmJ5IGV4YWN0IG1hdGNoPyAoc3BlZWR1cClcbiAgdmFyIGJlc3RfbG9jID0gdGV4dC5pbmRleE9mKHBhdHRlcm4sIGxvYyk7XG4gIGlmIChiZXN0X2xvYyAhPSAtMSkge1xuICAgIHNjb3JlX3RocmVzaG9sZCA9IE1hdGgubWluKG1hdGNoX2JpdGFwU2NvcmUoMCwgYmVzdF9sb2MpLCBzY29yZV90aHJlc2hvbGQpO1xuICAgIC8vIFdoYXQgYWJvdXQgaW4gdGhlIG90aGVyIGRpcmVjdGlvbj8gKHNwZWVkdXApXG4gICAgYmVzdF9sb2MgPSB0ZXh0Lmxhc3RJbmRleE9mKHBhdHRlcm4sIGxvYyArIHBhdHRlcm4ubGVuZ3RoKTtcbiAgICBpZiAoYmVzdF9sb2MgIT0gLTEpIHtcbiAgICAgIHNjb3JlX3RocmVzaG9sZCA9XG4gICAgICAgICAgTWF0aC5taW4obWF0Y2hfYml0YXBTY29yZSgwLCBiZXN0X2xvYyksIHNjb3JlX3RocmVzaG9sZCk7XG4gICAgfVxuICB9XG5cbiAgLy8gSW5pdGlhbGlzZSB0aGUgYml0IGFycmF5cy5cbiAgdmFyIG1hdGNobWFzayA9IDEgPDwgKHBhdHRlcm4ubGVuZ3RoIC0gMSk7XG4gIGJlc3RfbG9jID0gLTE7XG5cbiAgdmFyIGJpbl9taW4sIGJpbl9taWQ7XG4gIHZhciBiaW5fbWF4ID0gcGF0dGVybi5sZW5ndGggKyB0ZXh0Lmxlbmd0aDtcbiAgdmFyIGxhc3RfcmQ7XG4gIGZvciAodmFyIGQgPSAwOyBkIDwgcGF0dGVybi5sZW5ndGg7IGQrKykge1xuICAgIC8vIFNjYW4gZm9yIHRoZSBiZXN0IG1hdGNoOyBlYWNoIGl0ZXJhdGlvbiBhbGxvd3MgZm9yIG9uZSBtb3JlIGVycm9yLlxuICAgIC8vIFJ1biBhIGJpbmFyeSBzZWFyY2ggdG8gZGV0ZXJtaW5lIGhvdyBmYXIgZnJvbSAnbG9jJyB3ZSBjYW4gc3RyYXkgYXQgdGhpc1xuICAgIC8vIGVycm9yIGxldmVsLlxuICAgIGJpbl9taW4gPSAwO1xuICAgIGJpbl9taWQgPSBiaW5fbWF4O1xuICAgIHdoaWxlIChiaW5fbWluIDwgYmluX21pZCkge1xuICAgICAgaWYgKG1hdGNoX2JpdGFwU2NvcmUoZCwgbG9jICsgYmluX21pZCkgPD0gc2NvcmVfdGhyZXNob2xkKSB7XG4gICAgICAgIGJpbl9taW4gPSBiaW5fbWlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmluX21heCA9IGJpbl9taWQ7XG4gICAgICB9XG4gICAgICBiaW5fbWlkID0gTWF0aC5mbG9vcigoYmluX21heCAtIGJpbl9taW4pIC8gMiArIGJpbl9taW4pO1xuICAgIH1cbiAgICAvLyBVc2UgdGhlIHJlc3VsdCBmcm9tIHRoaXMgaXRlcmF0aW9uIGFzIHRoZSBtYXhpbXVtIGZvciB0aGUgbmV4dC5cbiAgICBiaW5fbWF4ID0gYmluX21pZDtcbiAgICB2YXIgc3RhcnQgPSBNYXRoLm1heCgxLCBsb2MgLSBiaW5fbWlkICsgMSk7XG4gICAgdmFyIGZpbmlzaCA9IE1hdGgubWluKGxvYyArIGJpbl9taWQsIHRleHQubGVuZ3RoKSArIHBhdHRlcm4ubGVuZ3RoO1xuXG4gICAgdmFyIHJkID0gQXJyYXkoZmluaXNoICsgMik7XG4gICAgcmRbZmluaXNoICsgMV0gPSAoMSA8PCBkKSAtIDE7XG4gICAgZm9yICh2YXIgaiA9IGZpbmlzaDsgaiA+PSBzdGFydDsgai0tKSB7XG4gICAgICAvLyBUaGUgYWxwaGFiZXQgKHMpIGlzIGEgc3BhcnNlIGhhc2gsIHNvIHRoZSBmb2xsb3dpbmcgbGluZSBnZW5lcmF0ZXNcbiAgICAgIC8vIHdhcm5pbmdzLlxuICAgICAgdmFyIGNoYXJNYXRjaCA9IHNbdGV4dC5jaGFyQXQoaiAtIDEpXTtcbiAgICAgIGlmIChkID09PSAwKSB7ICAvLyBGaXJzdCBwYXNzOiBleGFjdCBtYXRjaC5cbiAgICAgICAgcmRbal0gPSAoKHJkW2ogKyAxXSA8PCAxKSB8IDEpICYgY2hhck1hdGNoO1xuICAgICAgfSBlbHNlIHsgIC8vIFN1YnNlcXVlbnQgcGFzc2VzOiBmdXp6eSBtYXRjaC5cbiAgICAgICAgcmRbal0gPSAoKHJkW2ogKyAxXSA8PCAxKSB8IDEpICYgY2hhck1hdGNoIHxcbiAgICAgICAgICAgICAgICAoKChsYXN0X3JkW2ogKyAxXSB8IGxhc3RfcmRbal0pIDw8IDEpIHwgMSkgfFxuICAgICAgICAgICAgICAgIGxhc3RfcmRbaiArIDFdO1xuICAgICAgfVxuICAgICAgaWYgKHJkW2pdICYgbWF0Y2htYXNrKSB7XG4gICAgICAgIHZhciBzY29yZSA9IG1hdGNoX2JpdGFwU2NvcmUoZCwgaiAtIDEpO1xuICAgICAgICAvLyBUaGlzIG1hdGNoIHdpbGwgYWxtb3N0IGNlcnRhaW5seSBiZSBiZXR0ZXIgdGhhbiBhbnkgZXhpc3RpbmcgbWF0Y2guXG4gICAgICAgIC8vIEJ1dCBjaGVjayBhbnl3YXkuXG4gICAgICAgIGlmIChzY29yZSA8PSBzY29yZV90aHJlc2hvbGQpIHtcbiAgICAgICAgICAvLyBUb2xkIHlvdSBzby5cbiAgICAgICAgICBzY29yZV90aHJlc2hvbGQgPSBzY29yZTtcbiAgICAgICAgICBiZXN0X2xvYyA9IGogLSAxO1xuICAgICAgICAgIGlmIChiZXN0X2xvYyA+IGxvYykge1xuICAgICAgICAgICAgLy8gV2hlbiBwYXNzaW5nIGxvYywgZG9uJ3QgZXhjZWVkIG91ciBjdXJyZW50IGRpc3RhbmNlIGZyb20gbG9jLlxuICAgICAgICAgICAgc3RhcnQgPSBNYXRoLm1heCgxLCAyICogbG9jIC0gYmVzdF9sb2MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBBbHJlYWR5IHBhc3NlZCBsb2MsIGRvd25oaWxsIGZyb20gaGVyZSBvbiBpbi5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBObyBob3BlIGZvciBhIChiZXR0ZXIpIG1hdGNoIGF0IGdyZWF0ZXIgZXJyb3IgbGV2ZWxzLlxuICAgIGlmIChtYXRjaF9iaXRhcFNjb3JlKGQgKyAxLCBsb2MpID4gc2NvcmVfdGhyZXNob2xkKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbGFzdF9yZCA9IHJkO1xuICB9XG4gIHJldHVybiBiZXN0X2xvYztcbn07XG5cblxuLyoqXG4gKiBJbml0aWFsaXNlIHRoZSBhbHBoYWJldCBmb3IgdGhlIEJpdGFwIGFsZ29yaXRobS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuIFRoZSB0ZXh0IHRvIGVuY29kZS5cbiAqIEByZXR1cm4ge09iamVjdH0gSGFzaCBvZiBjaGFyYWN0ZXIgbG9jYXRpb25zLlxuICogQHByaXZhdGVcbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUubWF0Y2hfYWxwaGFiZXQgPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIHZhciBzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0dGVybi5sZW5ndGg7IGkrKykge1xuICAgIHNbcGF0dGVybi5jaGFyQXQoaSldID0gMDtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdHRlcm4ubGVuZ3RoOyBpKyspIHtcbiAgICBzW3BhdHRlcm4uY2hhckF0KGkpXSB8PSAxIDw8IChwYXR0ZXJuLmxlbmd0aCAtIGkgLSAxKTtcbiAgfVxuICByZXR1cm4gcztcbn07XG5cblxuLy8gIFBBVENIIEZVTkNUSU9OU1xuXG5cbi8qKlxuICogSW5jcmVhc2UgdGhlIGNvbnRleHQgdW50aWwgaXQgaXMgdW5pcXVlLFxuICogYnV0IGRvbid0IGxldCB0aGUgcGF0dGVybiBleHBhbmQgYmV5b25kIE1hdGNoX01heEJpdHMuXG4gKiBAcGFyYW0ge3BhdGNoX29ian0gcGF0Y2ggVGhlIHBhdGNoIHRvIGdyb3cuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBTb3VyY2UgdGV4dC5cbiAqIEBwcml2YXRlXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLnBhdGNoX2FkZENvbnRleHQgPSBmdW5jdGlvbihwYXRjaCwgdGV4dCkge1xuICBpZiAodGV4dC5sZW5ndGggPT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcGF0dGVybiA9IHRleHQuc3Vic3RyaW5nKHBhdGNoLnN0YXJ0MiwgcGF0Y2guc3RhcnQyICsgcGF0Y2gubGVuZ3RoMSk7XG4gIHZhciBwYWRkaW5nID0gMDtcblxuICAvLyBMb29rIGZvciB0aGUgZmlyc3QgYW5kIGxhc3QgbWF0Y2hlcyBvZiBwYXR0ZXJuIGluIHRleHQuICBJZiB0d28gZGlmZmVyZW50XG4gIC8vIG1hdGNoZXMgYXJlIGZvdW5kLCBpbmNyZWFzZSB0aGUgcGF0dGVybiBsZW5ndGguXG4gIHdoaWxlICh0ZXh0LmluZGV4T2YocGF0dGVybikgIT0gdGV4dC5sYXN0SW5kZXhPZihwYXR0ZXJuKSAmJlxuICAgICAgICAgcGF0dGVybi5sZW5ndGggPCB0aGlzLk1hdGNoX01heEJpdHMgLSB0aGlzLlBhdGNoX01hcmdpbiAtXG4gICAgICAgICB0aGlzLlBhdGNoX01hcmdpbikge1xuICAgIHBhZGRpbmcgKz0gdGhpcy5QYXRjaF9NYXJnaW47XG4gICAgcGF0dGVybiA9IHRleHQuc3Vic3RyaW5nKHBhdGNoLnN0YXJ0MiAtIHBhZGRpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoLnN0YXJ0MiArIHBhdGNoLmxlbmd0aDEgKyBwYWRkaW5nKTtcbiAgfVxuICAvLyBBZGQgb25lIGNodW5rIGZvciBnb29kIGx1Y2suXG4gIHBhZGRpbmcgKz0gdGhpcy5QYXRjaF9NYXJnaW47XG5cbiAgLy8gQWRkIHRoZSBwcmVmaXguXG4gIHZhciBwcmVmaXggPSB0ZXh0LnN1YnN0cmluZyhwYXRjaC5zdGFydDIgLSBwYWRkaW5nLCBwYXRjaC5zdGFydDIpO1xuICBpZiAocHJlZml4KSB7XG4gICAgcGF0Y2guZGlmZnMudW5zaGlmdChbRElGRl9FUVVBTCwgcHJlZml4XSk7XG4gIH1cbiAgLy8gQWRkIHRoZSBzdWZmaXguXG4gIHZhciBzdWZmaXggPSB0ZXh0LnN1YnN0cmluZyhwYXRjaC5zdGFydDIgKyBwYXRjaC5sZW5ndGgxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2guc3RhcnQyICsgcGF0Y2gubGVuZ3RoMSArIHBhZGRpbmcpO1xuICBpZiAoc3VmZml4KSB7XG4gICAgcGF0Y2guZGlmZnMucHVzaChbRElGRl9FUVVBTCwgc3VmZml4XSk7XG4gIH1cblxuICAvLyBSb2xsIGJhY2sgdGhlIHN0YXJ0IHBvaW50cy5cbiAgcGF0Y2guc3RhcnQxIC09IHByZWZpeC5sZW5ndGg7XG4gIHBhdGNoLnN0YXJ0MiAtPSBwcmVmaXgubGVuZ3RoO1xuICAvLyBFeHRlbmQgdGhlIGxlbmd0aHMuXG4gIHBhdGNoLmxlbmd0aDEgKz0gcHJlZml4Lmxlbmd0aCArIHN1ZmZpeC5sZW5ndGg7XG4gIHBhdGNoLmxlbmd0aDIgKz0gcHJlZml4Lmxlbmd0aCArIHN1ZmZpeC5sZW5ndGg7XG59O1xuXG5cbi8qKlxuICogQ29tcHV0ZSBhIGxpc3Qgb2YgcGF0Y2hlcyB0byB0dXJuIHRleHQxIGludG8gdGV4dDIuXG4gKiBVc2UgZGlmZnMgaWYgcHJvdmlkZWQsIG90aGVyd2lzZSBjb21wdXRlIGl0IG91cnNlbHZlcy5cbiAqIFRoZXJlIGFyZSBmb3VyIHdheXMgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uLCBkZXBlbmRpbmcgb24gd2hhdCBkYXRhIGlzXG4gKiBhdmFpbGFibGUgdG8gdGhlIGNhbGxlcjpcbiAqIE1ldGhvZCAxOlxuICogYSA9IHRleHQxLCBiID0gdGV4dDJcbiAqIE1ldGhvZCAyOlxuICogYSA9IGRpZmZzXG4gKiBNZXRob2QgMyAob3B0aW1hbCk6XG4gKiBhID0gdGV4dDEsIGIgPSBkaWZmc1xuICogTWV0aG9kIDQgKGRlcHJlY2F0ZWQsIHVzZSBtZXRob2QgMyk6XG4gKiBhID0gdGV4dDEsIGIgPSB0ZXh0MiwgYyA9IGRpZmZzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPEFycmF5LjxudW1iZXJ8c3RyaW5nPj59IGEgdGV4dDEgKG1ldGhvZHMgMSwzLDQpIG9yXG4gKiBBcnJheSBvZiBkaWZmIHR1cGxlcyBmb3IgdGV4dDEgdG8gdGV4dDIgKG1ldGhvZCAyKS5cbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxBcnJheS48bnVtYmVyfHN0cmluZz4+fSBvcHRfYiB0ZXh0MiAobWV0aG9kcyAxLDQpIG9yXG4gKiBBcnJheSBvZiBkaWZmIHR1cGxlcyBmb3IgdGV4dDEgdG8gdGV4dDIgKG1ldGhvZCAzKSBvciB1bmRlZmluZWQgKG1ldGhvZCAyKS5cbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxBcnJheS48bnVtYmVyfHN0cmluZz4+fSBvcHRfYyBBcnJheSBvZiBkaWZmIHR1cGxlcyBmb3JcbiAqIHRleHQxIHRvIHRleHQyIChtZXRob2QgNCkgb3IgdW5kZWZpbmVkIChtZXRob2RzIDEsMiwzKS5cbiAqIEByZXR1cm4ge0FycmF5LjxwYXRjaF9vYmo+fSBBcnJheSBvZiBwYXRjaCBvYmplY3RzLlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5wYXRjaF9tYWtlID0gZnVuY3Rpb24oYSwgb3B0X2IsIG9wdF9jKSB7XG4gIHZhciB0ZXh0MSwgZGlmZnM7XG4gIGlmICh0eXBlb2YgYSA9PSAnc3RyaW5nJyAmJiB0eXBlb2Ygb3B0X2IgPT0gJ3N0cmluZycgJiZcbiAgICAgIHR5cGVvZiBvcHRfYyA9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIE1ldGhvZCAxOiB0ZXh0MSwgdGV4dDJcbiAgICAvLyBDb21wdXRlIGRpZmZzIGZyb20gdGV4dDEgYW5kIHRleHQyLlxuICAgIHRleHQxID0gYTtcbiAgICBkaWZmcyA9IHRoaXMuZGlmZl9tYWluKHRleHQxLCBvcHRfYiwgdHJ1ZSk7XG4gICAgaWYgKGRpZmZzLmxlbmd0aCA+IDIpIHtcbiAgICAgIHRoaXMuZGlmZl9jbGVhbnVwU2VtYW50aWMoZGlmZnMpO1xuICAgICAgdGhpcy5kaWZmX2NsZWFudXBFZmZpY2llbmN5KGRpZmZzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYSAmJiB0eXBlb2YgYSA9PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb3B0X2IgPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIHR5cGVvZiBvcHRfYyA9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIE1ldGhvZCAyOiBkaWZmc1xuICAgIC8vIENvbXB1dGUgdGV4dDEgZnJvbSBkaWZmcy5cbiAgICBkaWZmcyA9IGE7XG4gICAgdGV4dDEgPSB0aGlzLmRpZmZfdGV4dDEoZGlmZnMpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhID09ICdzdHJpbmcnICYmIG9wdF9iICYmIHR5cGVvZiBvcHRfYiA9PSAnb2JqZWN0JyAmJlxuICAgICAgdHlwZW9mIG9wdF9jID09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gTWV0aG9kIDM6IHRleHQxLCBkaWZmc1xuICAgIHRleHQxID0gYTtcbiAgICBkaWZmcyA9IG9wdF9iO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhID09ICdzdHJpbmcnICYmIHR5cGVvZiBvcHRfYiA9PSAnc3RyaW5nJyAmJlxuICAgICAgb3B0X2MgJiYgdHlwZW9mIG9wdF9jID09ICdvYmplY3QnKSB7XG4gICAgLy8gTWV0aG9kIDQ6IHRleHQxLCB0ZXh0MiwgZGlmZnNcbiAgICAvLyB0ZXh0MiBpcyBub3QgdXNlZC5cbiAgICB0ZXh0MSA9IGE7XG4gICAgZGlmZnMgPSBvcHRfYztcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gY2FsbCBmb3JtYXQgdG8gcGF0Y2hfbWFrZS4nKTtcbiAgfVxuXG4gIGlmIChkaWZmcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107ICAvLyBHZXQgcmlkIG9mIHRoZSBudWxsIGNhc2UuXG4gIH1cbiAgdmFyIHBhdGNoZXMgPSBbXTtcbiAgdmFyIHBhdGNoID0gbmV3IHBhdGNoX29iaigpO1xuICB2YXIgcGF0Y2hEaWZmTGVuZ3RoID0gMDsgIC8vIEtlZXBpbmcgb3VyIG93biBsZW5ndGggdmFyIGlzIGZhc3RlciBpbiBKUy5cbiAgdmFyIGNoYXJfY291bnQxID0gMDsgIC8vIE51bWJlciBvZiBjaGFyYWN0ZXJzIGludG8gdGhlIHRleHQxIHN0cmluZy5cbiAgdmFyIGNoYXJfY291bnQyID0gMDsgIC8vIE51bWJlciBvZiBjaGFyYWN0ZXJzIGludG8gdGhlIHRleHQyIHN0cmluZy5cbiAgLy8gU3RhcnQgd2l0aCB0ZXh0MSAocHJlcGF0Y2hfdGV4dCkgYW5kIGFwcGx5IHRoZSBkaWZmcyB1bnRpbCB3ZSBhcnJpdmUgYXRcbiAgLy8gdGV4dDIgKHBvc3RwYXRjaF90ZXh0KS4gIFdlIHJlY3JlYXRlIHRoZSBwYXRjaGVzIG9uZSBieSBvbmUgdG8gZGV0ZXJtaW5lXG4gIC8vIGNvbnRleHQgaW5mby5cbiAgdmFyIHByZXBhdGNoX3RleHQgPSB0ZXh0MTtcbiAgdmFyIHBvc3RwYXRjaF90ZXh0ID0gdGV4dDE7XG4gIGZvciAodmFyIHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICB2YXIgZGlmZl90eXBlID0gZGlmZnNbeF1bMF07XG4gICAgdmFyIGRpZmZfdGV4dCA9IGRpZmZzW3hdWzFdO1xuXG4gICAgaWYgKCFwYXRjaERpZmZMZW5ndGggJiYgZGlmZl90eXBlICE9PSBESUZGX0VRVUFMKSB7XG4gICAgICAvLyBBIG5ldyBwYXRjaCBzdGFydHMgaGVyZS5cbiAgICAgIHBhdGNoLnN0YXJ0MSA9IGNoYXJfY291bnQxO1xuICAgICAgcGF0Y2guc3RhcnQyID0gY2hhcl9jb3VudDI7XG4gICAgfVxuXG4gICAgc3dpdGNoIChkaWZmX3R5cGUpIHtcbiAgICAgIGNhc2UgRElGRl9JTlNFUlQ6XG4gICAgICAgIHBhdGNoLmRpZmZzW3BhdGNoRGlmZkxlbmd0aCsrXSA9IGRpZmZzW3hdO1xuICAgICAgICBwYXRjaC5sZW5ndGgyICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgIHBvc3RwYXRjaF90ZXh0ID0gcG9zdHBhdGNoX3RleHQuc3Vic3RyaW5nKDAsIGNoYXJfY291bnQyKSArIGRpZmZfdGV4dCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgcG9zdHBhdGNoX3RleHQuc3Vic3RyaW5nKGNoYXJfY291bnQyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxuICAgICAgICBwYXRjaC5sZW5ndGgxICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgIHBhdGNoLmRpZmZzW3BhdGNoRGlmZkxlbmd0aCsrXSA9IGRpZmZzW3hdO1xuICAgICAgICBwb3N0cGF0Y2hfdGV4dCA9IHBvc3RwYXRjaF90ZXh0LnN1YnN0cmluZygwLCBjaGFyX2NvdW50MikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RwYXRjaF90ZXh0LnN1YnN0cmluZyhjaGFyX2NvdW50MiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZfdGV4dC5sZW5ndGgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9FUVVBTDpcbiAgICAgICAgaWYgKGRpZmZfdGV4dC5sZW5ndGggPD0gMiAqIHRoaXMuUGF0Y2hfTWFyZ2luICYmXG4gICAgICAgICAgICBwYXRjaERpZmZMZW5ndGggJiYgZGlmZnMubGVuZ3RoICE9IHggKyAxKSB7XG4gICAgICAgICAgLy8gU21hbGwgZXF1YWxpdHkgaW5zaWRlIGEgcGF0Y2guXG4gICAgICAgICAgcGF0Y2guZGlmZnNbcGF0Y2hEaWZmTGVuZ3RoKytdID0gZGlmZnNbeF07XG4gICAgICAgICAgcGF0Y2gubGVuZ3RoMSArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgICAgICAgIHBhdGNoLmxlbmd0aDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIGlmIChkaWZmX3RleHQubGVuZ3RoID49IDIgKiB0aGlzLlBhdGNoX01hcmdpbikge1xuICAgICAgICAgIC8vIFRpbWUgZm9yIGEgbmV3IHBhdGNoLlxuICAgICAgICAgIGlmIChwYXRjaERpZmZMZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucGF0Y2hfYWRkQ29udGV4dChwYXRjaCwgcHJlcGF0Y2hfdGV4dCk7XG4gICAgICAgICAgICBwYXRjaGVzLnB1c2gocGF0Y2gpO1xuICAgICAgICAgICAgcGF0Y2ggPSBuZXcgcGF0Y2hfb2JqKCk7XG4gICAgICAgICAgICBwYXRjaERpZmZMZW5ndGggPSAwO1xuICAgICAgICAgICAgLy8gVW5saWtlIFVuaWRpZmYsIG91ciBwYXRjaCBsaXN0cyBoYXZlIGEgcm9sbGluZyBjb250ZXh0LlxuICAgICAgICAgICAgLy8gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2dvb2dsZS1kaWZmLW1hdGNoLXBhdGNoL3dpa2kvVW5pZGlmZlxuICAgICAgICAgICAgLy8gVXBkYXRlIHByZXBhdGNoIHRleHQgJiBwb3MgdG8gcmVmbGVjdCB0aGUgYXBwbGljYXRpb24gb2YgdGhlXG4gICAgICAgICAgICAvLyBqdXN0IGNvbXBsZXRlZCBwYXRjaC5cbiAgICAgICAgICAgIHByZXBhdGNoX3RleHQgPSBwb3N0cGF0Y2hfdGV4dDtcbiAgICAgICAgICAgIGNoYXJfY291bnQxID0gY2hhcl9jb3VudDI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB0aGUgY3VycmVudCBjaGFyYWN0ZXIgY291bnQuXG4gICAgaWYgKGRpZmZfdHlwZSAhPT0gRElGRl9JTlNFUlQpIHtcbiAgICAgIGNoYXJfY291bnQxICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgfVxuICAgIGlmIChkaWZmX3R5cGUgIT09IERJRkZfREVMRVRFKSB7XG4gICAgICBjaGFyX2NvdW50MiArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgIH1cbiAgfVxuICAvLyBQaWNrIHVwIHRoZSBsZWZ0b3ZlciBwYXRjaCBpZiBub3QgZW1wdHkuXG4gIGlmIChwYXRjaERpZmZMZW5ndGgpIHtcbiAgICB0aGlzLnBhdGNoX2FkZENvbnRleHQocGF0Y2gsIHByZXBhdGNoX3RleHQpO1xuICAgIHBhdGNoZXMucHVzaChwYXRjaCk7XG4gIH1cblxuICByZXR1cm4gcGF0Y2hlcztcbn07XG5cblxuLyoqXG4gKiBHaXZlbiBhbiBhcnJheSBvZiBwYXRjaGVzLCByZXR1cm4gYW5vdGhlciBhcnJheSB0aGF0IGlzIGlkZW50aWNhbC5cbiAqIEBwYXJhbSB7QXJyYXkuPHBhdGNoX29iaj59IHBhdGNoZXMgQXJyYXkgb2YgcGF0Y2ggb2JqZWN0cy5cbiAqIEByZXR1cm4ge0FycmF5LjxwYXRjaF9vYmo+fSBBcnJheSBvZiBwYXRjaCBvYmplY3RzLlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5wYXRjaF9kZWVwQ29weSA9IGZ1bmN0aW9uKHBhdGNoZXMpIHtcbiAgLy8gTWFraW5nIGRlZXAgY29waWVzIGlzIGhhcmQgaW4gSmF2YVNjcmlwdC5cbiAgdmFyIHBhdGNoZXNDb3B5ID0gW107XG4gIGZvciAodmFyIHggPSAwOyB4IDwgcGF0Y2hlcy5sZW5ndGg7IHgrKykge1xuICAgIHZhciBwYXRjaCA9IHBhdGNoZXNbeF07XG4gICAgdmFyIHBhdGNoQ29weSA9IG5ldyBwYXRjaF9vYmooKTtcbiAgICBwYXRjaENvcHkuZGlmZnMgPSBbXTtcbiAgICBmb3IgKHZhciB5ID0gMDsgeSA8IHBhdGNoLmRpZmZzLmxlbmd0aDsgeSsrKSB7XG4gICAgICBwYXRjaENvcHkuZGlmZnNbeV0gPSBwYXRjaC5kaWZmc1t5XS5zbGljZSgpO1xuICAgIH1cbiAgICBwYXRjaENvcHkuc3RhcnQxID0gcGF0Y2guc3RhcnQxO1xuICAgIHBhdGNoQ29weS5zdGFydDIgPSBwYXRjaC5zdGFydDI7XG4gICAgcGF0Y2hDb3B5Lmxlbmd0aDEgPSBwYXRjaC5sZW5ndGgxO1xuICAgIHBhdGNoQ29weS5sZW5ndGgyID0gcGF0Y2gubGVuZ3RoMjtcbiAgICBwYXRjaGVzQ29weVt4XSA9IHBhdGNoQ29weTtcbiAgfVxuICByZXR1cm4gcGF0Y2hlc0NvcHk7XG59O1xuXG5cbi8qKlxuICogTWVyZ2UgYSBzZXQgb2YgcGF0Y2hlcyBvbnRvIHRoZSB0ZXh0LiAgUmV0dXJuIGEgcGF0Y2hlZCB0ZXh0LCBhcyB3ZWxsXG4gKiBhcyBhIGxpc3Qgb2YgdHJ1ZS9mYWxzZSB2YWx1ZXMgaW5kaWNhdGluZyB3aGljaCBwYXRjaGVzIHdlcmUgYXBwbGllZC5cbiAqIEBwYXJhbSB7QXJyYXkuPHBhdGNoX29iaj59IHBhdGNoZXMgQXJyYXkgb2YgcGF0Y2ggb2JqZWN0cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IE9sZCB0ZXh0LlxuICogQHJldHVybiB7QXJyYXkuPHN0cmluZ3xBcnJheS48Ym9vbGVhbj4+fSBUd28gZWxlbWVudCBBcnJheSwgY29udGFpbmluZyB0aGVcbiAqICAgICAgbmV3IHRleHQgYW5kIGFuIGFycmF5IG9mIGJvb2xlYW4gdmFsdWVzLlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5wYXRjaF9hcHBseSA9IGZ1bmN0aW9uKHBhdGNoZXMsIHRleHQpIHtcbiAgaWYgKHBhdGNoZXMubGVuZ3RoID09IDApIHtcbiAgICByZXR1cm4gW3RleHQsIFtdXTtcbiAgfVxuXG4gIC8vIERlZXAgY29weSB0aGUgcGF0Y2hlcyBzbyB0aGF0IG5vIGNoYW5nZXMgYXJlIG1hZGUgdG8gb3JpZ2luYWxzLlxuICBwYXRjaGVzID0gdGhpcy5wYXRjaF9kZWVwQ29weShwYXRjaGVzKTtcblxuICB2YXIgbnVsbFBhZGRpbmcgPSB0aGlzLnBhdGNoX2FkZFBhZGRpbmcocGF0Y2hlcyk7XG4gIHRleHQgPSBudWxsUGFkZGluZyArIHRleHQgKyBudWxsUGFkZGluZztcblxuICB0aGlzLnBhdGNoX3NwbGl0TWF4KHBhdGNoZXMpO1xuICAvLyBkZWx0YSBrZWVwcyB0cmFjayBvZiB0aGUgb2Zmc2V0IGJldHdlZW4gdGhlIGV4cGVjdGVkIGFuZCBhY3R1YWwgbG9jYXRpb25cbiAgLy8gb2YgdGhlIHByZXZpb3VzIHBhdGNoLiAgSWYgdGhlcmUgYXJlIHBhdGNoZXMgZXhwZWN0ZWQgYXQgcG9zaXRpb25zIDEwIGFuZFxuICAvLyAyMCwgYnV0IHRoZSBmaXJzdCBwYXRjaCB3YXMgZm91bmQgYXQgMTIsIGRlbHRhIGlzIDIgYW5kIHRoZSBzZWNvbmQgcGF0Y2hcbiAgLy8gaGFzIGFuIGVmZmVjdGl2ZSBleHBlY3RlZCBwb3NpdGlvbiBvZiAyMi5cbiAgdmFyIGRlbHRhID0gMDtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBwYXRjaGVzLmxlbmd0aDsgeCsrKSB7XG4gICAgdmFyIGV4cGVjdGVkX2xvYyA9IHBhdGNoZXNbeF0uc3RhcnQyICsgZGVsdGE7XG4gICAgdmFyIHRleHQxID0gdGhpcy5kaWZmX3RleHQxKHBhdGNoZXNbeF0uZGlmZnMpO1xuICAgIHZhciBzdGFydF9sb2M7XG4gICAgdmFyIGVuZF9sb2MgPSAtMTtcbiAgICBpZiAodGV4dDEubGVuZ3RoID4gdGhpcy5NYXRjaF9NYXhCaXRzKSB7XG4gICAgICAvLyBwYXRjaF9zcGxpdE1heCB3aWxsIG9ubHkgcHJvdmlkZSBhbiBvdmVyc2l6ZWQgcGF0dGVybiBpbiB0aGUgY2FzZSBvZlxuICAgICAgLy8gYSBtb25zdGVyIGRlbGV0ZS5cbiAgICAgIHN0YXJ0X2xvYyA9IHRoaXMubWF0Y2hfbWFpbih0ZXh0LCB0ZXh0MS5zdWJzdHJpbmcoMCwgdGhpcy5NYXRjaF9NYXhCaXRzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZF9sb2MpO1xuICAgICAgaWYgKHN0YXJ0X2xvYyAhPSAtMSkge1xuICAgICAgICBlbmRfbG9jID0gdGhpcy5tYXRjaF9tYWluKHRleHQsXG4gICAgICAgICAgICB0ZXh0MS5zdWJzdHJpbmcodGV4dDEubGVuZ3RoIC0gdGhpcy5NYXRjaF9NYXhCaXRzKSxcbiAgICAgICAgICAgIGV4cGVjdGVkX2xvYyArIHRleHQxLmxlbmd0aCAtIHRoaXMuTWF0Y2hfTWF4Qml0cyk7XG4gICAgICAgIGlmIChlbmRfbG9jID09IC0xIHx8IHN0YXJ0X2xvYyA+PSBlbmRfbG9jKSB7XG4gICAgICAgICAgLy8gQ2FuJ3QgZmluZCB2YWxpZCB0cmFpbGluZyBjb250ZXh0LiAgRHJvcCB0aGlzIHBhdGNoLlxuICAgICAgICAgIHN0YXJ0X2xvYyA9IC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0X2xvYyA9IHRoaXMubWF0Y2hfbWFpbih0ZXh0LCB0ZXh0MSwgZXhwZWN0ZWRfbG9jKTtcbiAgICB9XG4gICAgaWYgKHN0YXJ0X2xvYyA9PSAtMSkge1xuICAgICAgLy8gTm8gbWF0Y2ggZm91bmQuICA6KFxuICAgICAgcmVzdWx0c1t4XSA9IGZhbHNlO1xuICAgICAgLy8gU3VidHJhY3QgdGhlIGRlbHRhIGZvciB0aGlzIGZhaWxlZCBwYXRjaCBmcm9tIHN1YnNlcXVlbnQgcGF0Y2hlcy5cbiAgICAgIGRlbHRhIC09IHBhdGNoZXNbeF0ubGVuZ3RoMiAtIHBhdGNoZXNbeF0ubGVuZ3RoMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm91bmQgYSBtYXRjaC4gIDopXG4gICAgICByZXN1bHRzW3hdID0gdHJ1ZTtcbiAgICAgIGRlbHRhID0gc3RhcnRfbG9jIC0gZXhwZWN0ZWRfbG9jO1xuICAgICAgdmFyIHRleHQyO1xuICAgICAgaWYgKGVuZF9sb2MgPT0gLTEpIHtcbiAgICAgICAgdGV4dDIgPSB0ZXh0LnN1YnN0cmluZyhzdGFydF9sb2MsIHN0YXJ0X2xvYyArIHRleHQxLmxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0MiA9IHRleHQuc3Vic3RyaW5nKHN0YXJ0X2xvYywgZW5kX2xvYyArIHRoaXMuTWF0Y2hfTWF4Qml0cyk7XG4gICAgICB9XG4gICAgICBpZiAodGV4dDEgPT0gdGV4dDIpIHtcbiAgICAgICAgLy8gUGVyZmVjdCBtYXRjaCwganVzdCBzaG92ZSB0aGUgcmVwbGFjZW1lbnQgdGV4dCBpbi5cbiAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHN0YXJ0X2xvYykgK1xuICAgICAgICAgICAgICAgdGhpcy5kaWZmX3RleHQyKHBhdGNoZXNbeF0uZGlmZnMpICtcbiAgICAgICAgICAgICAgIHRleHQuc3Vic3RyaW5nKHN0YXJ0X2xvYyArIHRleHQxLmxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJbXBlcmZlY3QgbWF0Y2guICBSdW4gYSBkaWZmIHRvIGdldCBhIGZyYW1ld29yayBvZiBlcXVpdmFsZW50XG4gICAgICAgIC8vIGluZGljZXMuXG4gICAgICAgIHZhciBkaWZmcyA9IHRoaXMuZGlmZl9tYWluKHRleHQxLCB0ZXh0MiwgZmFsc2UpO1xuICAgICAgICBpZiAodGV4dDEubGVuZ3RoID4gdGhpcy5NYXRjaF9NYXhCaXRzICYmXG4gICAgICAgICAgICB0aGlzLmRpZmZfbGV2ZW5zaHRlaW4oZGlmZnMpIC8gdGV4dDEubGVuZ3RoID5cbiAgICAgICAgICAgIHRoaXMuUGF0Y2hfRGVsZXRlVGhyZXNob2xkKSB7XG4gICAgICAgICAgLy8gVGhlIGVuZCBwb2ludHMgbWF0Y2gsIGJ1dCB0aGUgY29udGVudCBpcyB1bmFjY2VwdGFibHkgYmFkLlxuICAgICAgICAgIHJlc3VsdHNbeF0gPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRpZmZfY2xlYW51cFNlbWFudGljTG9zc2xlc3MoZGlmZnMpO1xuICAgICAgICAgIHZhciBpbmRleDEgPSAwO1xuICAgICAgICAgIHZhciBpbmRleDI7XG4gICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBwYXRjaGVzW3hdLmRpZmZzLmxlbmd0aDsgeSsrKSB7XG4gICAgICAgICAgICB2YXIgbW9kID0gcGF0Y2hlc1t4XS5kaWZmc1t5XTtcbiAgICAgICAgICAgIGlmIChtb2RbMF0gIT09IERJRkZfRVFVQUwpIHtcbiAgICAgICAgICAgICAgaW5kZXgyID0gdGhpcy5kaWZmX3hJbmRleChkaWZmcywgaW5kZXgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb2RbMF0gPT09IERJRkZfSU5TRVJUKSB7ICAvLyBJbnNlcnRpb25cbiAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHN0YXJ0X2xvYyArIGluZGV4MikgKyBtb2RbMV0gK1xuICAgICAgICAgICAgICAgICAgICAgdGV4dC5zdWJzdHJpbmcoc3RhcnRfbG9jICsgaW5kZXgyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobW9kWzBdID09PSBESUZGX0RFTEVURSkgeyAgLy8gRGVsZXRpb25cbiAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHN0YXJ0X2xvYyArIGluZGV4MikgK1xuICAgICAgICAgICAgICAgICAgICAgdGV4dC5zdWJzdHJpbmcoc3RhcnRfbG9jICsgdGhpcy5kaWZmX3hJbmRleChkaWZmcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDEgKyBtb2RbMV0ubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW9kWzBdICE9PSBESUZGX0RFTEVURSkge1xuICAgICAgICAgICAgICBpbmRleDEgKz0gbW9kWzFdLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gU3RyaXAgdGhlIHBhZGRpbmcgb2ZmLlxuICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcobnVsbFBhZGRpbmcubGVuZ3RoLCB0ZXh0Lmxlbmd0aCAtIG51bGxQYWRkaW5nLmxlbmd0aCk7XG4gIHJldHVybiBbdGV4dCwgcmVzdWx0c107XG59O1xuXG5cbi8qKlxuICogQWRkIHNvbWUgcGFkZGluZyBvbiB0ZXh0IHN0YXJ0IGFuZCBlbmQgc28gdGhhdCBlZGdlcyBjYW4gbWF0Y2ggc29tZXRoaW5nLlxuICogSW50ZW5kZWQgdG8gYmUgY2FsbGVkIG9ubHkgZnJvbSB3aXRoaW4gcGF0Y2hfYXBwbHkuXG4gKiBAcGFyYW0ge0FycmF5LjxwYXRjaF9vYmo+fSBwYXRjaGVzIEFycmF5IG9mIHBhdGNoIG9iamVjdHMuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBwYWRkaW5nIHN0cmluZyBhZGRlZCB0byBlYWNoIHNpZGUuXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLnBhdGNoX2FkZFBhZGRpbmcgPSBmdW5jdGlvbihwYXRjaGVzKSB7XG4gIHZhciBwYWRkaW5nTGVuZ3RoID0gdGhpcy5QYXRjaF9NYXJnaW47XG4gIHZhciBudWxsUGFkZGluZyA9ICcnO1xuICBmb3IgKHZhciB4ID0gMTsgeCA8PSBwYWRkaW5nTGVuZ3RoOyB4KyspIHtcbiAgICBudWxsUGFkZGluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHgpO1xuICB9XG5cbiAgLy8gQnVtcCBhbGwgdGhlIHBhdGNoZXMgZm9yd2FyZC5cbiAgZm9yICh2YXIgeCA9IDA7IHggPCBwYXRjaGVzLmxlbmd0aDsgeCsrKSB7XG4gICAgcGF0Y2hlc1t4XS5zdGFydDEgKz0gcGFkZGluZ0xlbmd0aDtcbiAgICBwYXRjaGVzW3hdLnN0YXJ0MiArPSBwYWRkaW5nTGVuZ3RoO1xuICB9XG5cbiAgLy8gQWRkIHNvbWUgcGFkZGluZyBvbiBzdGFydCBvZiBmaXJzdCBkaWZmLlxuICB2YXIgcGF0Y2ggPSBwYXRjaGVzWzBdO1xuICB2YXIgZGlmZnMgPSBwYXRjaC5kaWZmcztcbiAgaWYgKGRpZmZzLmxlbmd0aCA9PSAwIHx8IGRpZmZzWzBdWzBdICE9IERJRkZfRVFVQUwpIHtcbiAgICAvLyBBZGQgbnVsbFBhZGRpbmcgZXF1YWxpdHkuXG4gICAgZGlmZnMudW5zaGlmdChbRElGRl9FUVVBTCwgbnVsbFBhZGRpbmddKTtcbiAgICBwYXRjaC5zdGFydDEgLT0gcGFkZGluZ0xlbmd0aDsgIC8vIFNob3VsZCBiZSAwLlxuICAgIHBhdGNoLnN0YXJ0MiAtPSBwYWRkaW5nTGVuZ3RoOyAgLy8gU2hvdWxkIGJlIDAuXG4gICAgcGF0Y2gubGVuZ3RoMSArPSBwYWRkaW5nTGVuZ3RoO1xuICAgIHBhdGNoLmxlbmd0aDIgKz0gcGFkZGluZ0xlbmd0aDtcbiAgfSBlbHNlIGlmIChwYWRkaW5nTGVuZ3RoID4gZGlmZnNbMF1bMV0ubGVuZ3RoKSB7XG4gICAgLy8gR3JvdyBmaXJzdCBlcXVhbGl0eS5cbiAgICB2YXIgZXh0cmFMZW5ndGggPSBwYWRkaW5nTGVuZ3RoIC0gZGlmZnNbMF1bMV0ubGVuZ3RoO1xuICAgIGRpZmZzWzBdWzFdID0gbnVsbFBhZGRpbmcuc3Vic3RyaW5nKGRpZmZzWzBdWzFdLmxlbmd0aCkgKyBkaWZmc1swXVsxXTtcbiAgICBwYXRjaC5zdGFydDEgLT0gZXh0cmFMZW5ndGg7XG4gICAgcGF0Y2guc3RhcnQyIC09IGV4dHJhTGVuZ3RoO1xuICAgIHBhdGNoLmxlbmd0aDEgKz0gZXh0cmFMZW5ndGg7XG4gICAgcGF0Y2gubGVuZ3RoMiArPSBleHRyYUxlbmd0aDtcbiAgfVxuXG4gIC8vIEFkZCBzb21lIHBhZGRpbmcgb24gZW5kIG9mIGxhc3QgZGlmZi5cbiAgcGF0Y2ggPSBwYXRjaGVzW3BhdGNoZXMubGVuZ3RoIC0gMV07XG4gIGRpZmZzID0gcGF0Y2guZGlmZnM7XG4gIGlmIChkaWZmcy5sZW5ndGggPT0gMCB8fCBkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVswXSAhPSBESUZGX0VRVUFMKSB7XG4gICAgLy8gQWRkIG51bGxQYWRkaW5nIGVxdWFsaXR5LlxuICAgIGRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIG51bGxQYWRkaW5nXSk7XG4gICAgcGF0Y2gubGVuZ3RoMSArPSBwYWRkaW5nTGVuZ3RoO1xuICAgIHBhdGNoLmxlbmd0aDIgKz0gcGFkZGluZ0xlbmd0aDtcbiAgfSBlbHNlIGlmIChwYWRkaW5nTGVuZ3RoID4gZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0ubGVuZ3RoKSB7XG4gICAgLy8gR3JvdyBsYXN0IGVxdWFsaXR5LlxuICAgIHZhciBleHRyYUxlbmd0aCA9IHBhZGRpbmdMZW5ndGggLSBkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVsxXS5sZW5ndGg7XG4gICAgZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0gKz0gbnVsbFBhZGRpbmcuc3Vic3RyaW5nKDAsIGV4dHJhTGVuZ3RoKTtcbiAgICBwYXRjaC5sZW5ndGgxICs9IGV4dHJhTGVuZ3RoO1xuICAgIHBhdGNoLmxlbmd0aDIgKz0gZXh0cmFMZW5ndGg7XG4gIH1cblxuICByZXR1cm4gbnVsbFBhZGRpbmc7XG59O1xuXG5cbi8qKlxuICogTG9vayB0aHJvdWdoIHRoZSBwYXRjaGVzIGFuZCBicmVhayB1cCBhbnkgd2hpY2ggYXJlIGxvbmdlciB0aGFuIHRoZSBtYXhpbXVtXG4gKiBsaW1pdCBvZiB0aGUgbWF0Y2ggYWxnb3JpdGhtLlxuICogQHBhcmFtIHtBcnJheS48cGF0Y2hfb2JqPn0gcGF0Y2hlcyBBcnJheSBvZiBwYXRjaCBvYmplY3RzLlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5wYXRjaF9zcGxpdE1heCA9IGZ1bmN0aW9uKHBhdGNoZXMpIHtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBwYXRjaGVzLmxlbmd0aDsgeCsrKSB7XG4gICAgaWYgKHBhdGNoZXNbeF0ubGVuZ3RoMSA+IHRoaXMuTWF0Y2hfTWF4Qml0cykge1xuICAgICAgdmFyIGJpZ3BhdGNoID0gcGF0Y2hlc1t4XTtcbiAgICAgIC8vIFJlbW92ZSB0aGUgYmlnIG9sZCBwYXRjaC5cbiAgICAgIHBhdGNoZXMuc3BsaWNlKHgtLSwgMSk7XG4gICAgICB2YXIgcGF0Y2hfc2l6ZSA9IHRoaXMuTWF0Y2hfTWF4Qml0cztcbiAgICAgIHZhciBzdGFydDEgPSBiaWdwYXRjaC5zdGFydDE7XG4gICAgICB2YXIgc3RhcnQyID0gYmlncGF0Y2guc3RhcnQyO1xuICAgICAgdmFyIHByZWNvbnRleHQgPSAnJztcbiAgICAgIHdoaWxlIChiaWdwYXRjaC5kaWZmcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgLy8gQ3JlYXRlIG9uZSBvZiBzZXZlcmFsIHNtYWxsZXIgcGF0Y2hlcy5cbiAgICAgICAgdmFyIHBhdGNoID0gbmV3IHBhdGNoX29iaigpO1xuICAgICAgICB2YXIgZW1wdHkgPSB0cnVlO1xuICAgICAgICBwYXRjaC5zdGFydDEgPSBzdGFydDEgLSBwcmVjb250ZXh0Lmxlbmd0aDtcbiAgICAgICAgcGF0Y2guc3RhcnQyID0gc3RhcnQyIC0gcHJlY29udGV4dC5sZW5ndGg7XG4gICAgICAgIGlmIChwcmVjb250ZXh0ICE9PSAnJykge1xuICAgICAgICAgIHBhdGNoLmxlbmd0aDEgPSBwYXRjaC5sZW5ndGgyID0gcHJlY29udGV4dC5sZW5ndGg7XG4gICAgICAgICAgcGF0Y2guZGlmZnMucHVzaChbRElGRl9FUVVBTCwgcHJlY29udGV4dF0pO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChiaWdwYXRjaC5kaWZmcy5sZW5ndGggIT09IDAgJiZcbiAgICAgICAgICAgICAgIHBhdGNoLmxlbmd0aDEgPCBwYXRjaF9zaXplIC0gdGhpcy5QYXRjaF9NYXJnaW4pIHtcbiAgICAgICAgICB2YXIgZGlmZl90eXBlID0gYmlncGF0Y2guZGlmZnNbMF1bMF07XG4gICAgICAgICAgdmFyIGRpZmZfdGV4dCA9IGJpZ3BhdGNoLmRpZmZzWzBdWzFdO1xuICAgICAgICAgIGlmIChkaWZmX3R5cGUgPT09IERJRkZfSU5TRVJUKSB7XG4gICAgICAgICAgICAvLyBJbnNlcnRpb25zIGFyZSBoYXJtbGVzcy5cbiAgICAgICAgICAgIHBhdGNoLmxlbmd0aDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIHN0YXJ0MiArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgICAgICAgICAgcGF0Y2guZGlmZnMucHVzaChiaWdwYXRjaC5kaWZmcy5zaGlmdCgpKTtcbiAgICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChkaWZmX3R5cGUgPT09IERJRkZfREVMRVRFICYmIHBhdGNoLmRpZmZzLmxlbmd0aCA9PSAxICYmXG4gICAgICAgICAgICAgICAgICAgICBwYXRjaC5kaWZmc1swXVswXSA9PSBESUZGX0VRVUFMICYmXG4gICAgICAgICAgICAgICAgICAgICBkaWZmX3RleHQubGVuZ3RoID4gMiAqIHBhdGNoX3NpemUpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBsYXJnZSBkZWxldGlvbi4gIExldCBpdCBwYXNzIGluIG9uZSBjaHVuay5cbiAgICAgICAgICAgIHBhdGNoLmxlbmd0aDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIHN0YXJ0MSArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgICAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgIHBhdGNoLmRpZmZzLnB1c2goW2RpZmZfdHlwZSwgZGlmZl90ZXh0XSk7XG4gICAgICAgICAgICBiaWdwYXRjaC5kaWZmcy5zaGlmdCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBEZWxldGlvbiBvciBlcXVhbGl0eS4gIE9ubHkgdGFrZSBhcyBtdWNoIGFzIHdlIGNhbiBzdG9tYWNoLlxuICAgICAgICAgICAgZGlmZl90ZXh0ID0gZGlmZl90ZXh0LnN1YnN0cmluZygwLCBwYXRjaF9zaXplIC0gcGF0Y2gubGVuZ3RoMSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuUGF0Y2hfTWFyZ2luKTtcbiAgICAgICAgICAgIHBhdGNoLmxlbmd0aDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIHN0YXJ0MSArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGRpZmZfdHlwZSA9PT0gRElGRl9FUVVBTCkge1xuICAgICAgICAgICAgICBwYXRjaC5sZW5ndGgyICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgIHN0YXJ0MiArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhdGNoLmRpZmZzLnB1c2goW2RpZmZfdHlwZSwgZGlmZl90ZXh0XSk7XG4gICAgICAgICAgICBpZiAoZGlmZl90ZXh0ID09IGJpZ3BhdGNoLmRpZmZzWzBdWzFdKSB7XG4gICAgICAgICAgICAgIGJpZ3BhdGNoLmRpZmZzLnNoaWZ0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBiaWdwYXRjaC5kaWZmc1swXVsxXSA9XG4gICAgICAgICAgICAgICAgICBiaWdwYXRjaC5kaWZmc1swXVsxXS5zdWJzdHJpbmcoZGlmZl90ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGhlYWQgY29udGV4dCBmb3IgdGhlIG5leHQgcGF0Y2guXG4gICAgICAgIHByZWNvbnRleHQgPSB0aGlzLmRpZmZfdGV4dDIocGF0Y2guZGlmZnMpO1xuICAgICAgICBwcmVjb250ZXh0ID1cbiAgICAgICAgICAgIHByZWNvbnRleHQuc3Vic3RyaW5nKHByZWNvbnRleHQubGVuZ3RoIC0gdGhpcy5QYXRjaF9NYXJnaW4pO1xuICAgICAgICAvLyBBcHBlbmQgdGhlIGVuZCBjb250ZXh0IGZvciB0aGlzIHBhdGNoLlxuICAgICAgICB2YXIgcG9zdGNvbnRleHQgPSB0aGlzLmRpZmZfdGV4dDEoYmlncGF0Y2guZGlmZnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3Vic3RyaW5nKDAsIHRoaXMuUGF0Y2hfTWFyZ2luKTtcbiAgICAgICAgaWYgKHBvc3Rjb250ZXh0ICE9PSAnJykge1xuICAgICAgICAgIHBhdGNoLmxlbmd0aDEgKz0gcG9zdGNvbnRleHQubGVuZ3RoO1xuICAgICAgICAgIHBhdGNoLmxlbmd0aDIgKz0gcG9zdGNvbnRleHQubGVuZ3RoO1xuICAgICAgICAgIGlmIChwYXRjaC5kaWZmcy5sZW5ndGggIT09IDAgJiZcbiAgICAgICAgICAgICAgcGF0Y2guZGlmZnNbcGF0Y2guZGlmZnMubGVuZ3RoIC0gMV1bMF0gPT09IERJRkZfRVFVQUwpIHtcbiAgICAgICAgICAgIHBhdGNoLmRpZmZzW3BhdGNoLmRpZmZzLmxlbmd0aCAtIDFdWzFdICs9IHBvc3Rjb250ZXh0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBwb3N0Y29udGV4dF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVtcHR5KSB7XG4gICAgICAgICAgcGF0Y2hlcy5zcGxpY2UoKyt4LCAwLCBwYXRjaCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBUYWtlIGEgbGlzdCBvZiBwYXRjaGVzIGFuZCByZXR1cm4gYSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uLlxuICogQHBhcmFtIHtBcnJheS48cGF0Y2hfb2JqPn0gcGF0Y2hlcyBBcnJheSBvZiBwYXRjaCBvYmplY3RzLlxuICogQHJldHVybiB7c3RyaW5nfSBUZXh0IHJlcHJlc2VudGF0aW9uIG9mIHBhdGNoZXMuXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLnBhdGNoX3RvVGV4dCA9IGZ1bmN0aW9uKHBhdGNoZXMpIHtcbiAgdmFyIHRleHQgPSBbXTtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBwYXRjaGVzLmxlbmd0aDsgeCsrKSB7XG4gICAgdGV4dFt4XSA9IHBhdGNoZXNbeF07XG4gIH1cbiAgcmV0dXJuIHRleHQuam9pbignJyk7XG59O1xuXG5cbi8qKlxuICogUGFyc2UgYSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHBhdGNoZXMgYW5kIHJldHVybiBhIGxpc3Qgb2YgcGF0Y2ggb2JqZWN0cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0bGluZSBUZXh0IHJlcHJlc2VudGF0aW9uIG9mIHBhdGNoZXMuXG4gKiBAcmV0dXJuIHtBcnJheS48cGF0Y2hfb2JqPn0gQXJyYXkgb2YgcGF0Y2ggb2JqZWN0cy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBpbnZhbGlkIGlucHV0LlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5wYXRjaF9mcm9tVGV4dCA9IGZ1bmN0aW9uKHRleHRsaW5lKSB7XG4gIHZhciBwYXRjaGVzID0gW107XG4gIGlmICghdGV4dGxpbmUpIHtcbiAgICByZXR1cm4gcGF0Y2hlcztcbiAgfVxuICAvLyBPcGVyYSBkb2Vzbid0IGtub3cgaG93IHRvIGRlY29kZSBjaGFyIDAuXG4gIHRleHRsaW5lID0gdGV4dGxpbmUucmVwbGFjZSgvJTAwL2csICdcXDAnKTtcbiAgdmFyIHRleHQgPSB0ZXh0bGluZS5zcGxpdCgnXFxuJyk7XG4gIHZhciB0ZXh0UG9pbnRlciA9IDA7XG4gIHdoaWxlICh0ZXh0UG9pbnRlciA8IHRleHQubGVuZ3RoKSB7XG4gICAgdmFyIG0gPSB0ZXh0W3RleHRQb2ludGVyXS5tYXRjaCgvXkBAIC0oXFxkKyksPyhcXGQqKSBcXCsoXFxkKyksPyhcXGQqKSBAQCQvKTtcbiAgICBpZiAoIW0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYXRjaCBzdHJpbmc6ICcgKyB0ZXh0W3RleHRQb2ludGVyXSk7XG4gICAgfVxuICAgIHZhciBwYXRjaCA9IG5ldyBwYXRjaF9vYmooKTtcbiAgICBwYXRjaGVzLnB1c2gocGF0Y2gpO1xuICAgIHBhdGNoLnN0YXJ0MSA9IHBhcnNlSW50KG1bMV0sIDEwKTtcbiAgICBpZiAobVsyXSA9PT0gJycpIHtcbiAgICAgIHBhdGNoLnN0YXJ0MS0tO1xuICAgICAgcGF0Y2gubGVuZ3RoMSA9IDE7XG4gICAgfSBlbHNlIGlmIChtWzJdID09ICcwJykge1xuICAgICAgcGF0Y2gubGVuZ3RoMSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGNoLnN0YXJ0MS0tO1xuICAgICAgcGF0Y2gubGVuZ3RoMSA9IHBhcnNlSW50KG1bMl0sIDEwKTtcbiAgICB9XG5cbiAgICBwYXRjaC5zdGFydDIgPSBwYXJzZUludChtWzNdLCAxMCk7XG4gICAgaWYgKG1bNF0gPT09ICcnKSB7XG4gICAgICBwYXRjaC5zdGFydDItLTtcbiAgICAgIHBhdGNoLmxlbmd0aDIgPSAxO1xuICAgIH0gZWxzZSBpZiAobVs0XSA9PSAnMCcpIHtcbiAgICAgIHBhdGNoLmxlbmd0aDIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRjaC5zdGFydDItLTtcbiAgICAgIHBhdGNoLmxlbmd0aDIgPSBwYXJzZUludChtWzRdLCAxMCk7XG4gICAgfVxuICAgIHRleHRQb2ludGVyKys7XG5cbiAgICB3aGlsZSAodGV4dFBvaW50ZXIgPCB0ZXh0Lmxlbmd0aCkge1xuICAgICAgdmFyIHNpZ24gPSB0ZXh0W3RleHRQb2ludGVyXS5jaGFyQXQoMCk7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbGluZSA9IGRlY29kZVVSSSh0ZXh0W3RleHRQb2ludGVyXS5zdWJzdHJpbmcoMSkpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgLy8gTWFsZm9ybWVkIFVSSSBzZXF1ZW5jZS5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGVzY2FwZSBpbiBwYXRjaF9mcm9tVGV4dDogJyArIGxpbmUpO1xuICAgICAgfVxuICAgICAgaWYgKHNpZ24gPT0gJy0nKSB7XG4gICAgICAgIC8vIERlbGV0aW9uLlxuICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0RFTEVURSwgbGluZV0pO1xuICAgICAgfSBlbHNlIGlmIChzaWduID09ICcrJykge1xuICAgICAgICAvLyBJbnNlcnRpb24uXG4gICAgICAgIHBhdGNoLmRpZmZzLnB1c2goW0RJRkZfSU5TRVJULCBsaW5lXSk7XG4gICAgICB9IGVsc2UgaWYgKHNpZ24gPT0gJyAnKSB7XG4gICAgICAgIC8vIE1pbm9yIGVxdWFsaXR5LlxuICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBsaW5lXSk7XG4gICAgICB9IGVsc2UgaWYgKHNpZ24gPT0gJ0AnKSB7XG4gICAgICAgIC8vIFN0YXJ0IG9mIG5leHQgcGF0Y2guXG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChzaWduID09PSAnJykge1xuICAgICAgICAvLyBCbGFuayBsaW5lPyAgV2hhdGV2ZXIuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXVEY/XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYXRjaCBtb2RlIFwiJyArIHNpZ24gKyAnXCIgaW46ICcgKyBsaW5lKTtcbiAgICAgIH1cbiAgICAgIHRleHRQb2ludGVyKys7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXRjaGVzO1xufTtcblxuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBvbmUgcGF0Y2ggb3BlcmF0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIHBhdGNoX29iaigpIHtcbiAgLyoqIEB0eXBlIHtBcnJheS48QXJyYXkuPG51bWJlcnxzdHJpbmc+Pn0gKi9cbiAgdGhpcy5kaWZmcyA9IFtdO1xuICAvKiogQHR5cGUgez9udW1iZXJ9ICovXG4gIHRoaXMuc3RhcnQxID0gbnVsbDtcbiAgLyoqIEB0eXBlIHs/bnVtYmVyfSAqL1xuICB0aGlzLnN0YXJ0MiA9IG51bGw7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB0aGlzLmxlbmd0aDEgPSAwO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdGhpcy5sZW5ndGgyID0gMDtcbn1cblxuXG4vKipcbiAqIEVtbXVsYXRlIEdOVSBkaWZmJ3MgZm9ybWF0LlxuICogSGVhZGVyOiBAQCAtMzgyLDggKzQ4MSw5IEBAXG4gKiBJbmRpY2llcyBhcmUgcHJpbnRlZCBhcyAxLWJhc2VkLCBub3QgMC1iYXNlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIEdOVSBkaWZmIHN0cmluZy5cbiAqL1xucGF0Y2hfb2JqLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY29vcmRzMSwgY29vcmRzMjtcbiAgaWYgKHRoaXMubGVuZ3RoMSA9PT0gMCkge1xuICAgIGNvb3JkczEgPSB0aGlzLnN0YXJ0MSArICcsMCc7XG4gIH0gZWxzZSBpZiAodGhpcy5sZW5ndGgxID09IDEpIHtcbiAgICBjb29yZHMxID0gdGhpcy5zdGFydDEgKyAxO1xuICB9IGVsc2Uge1xuICAgIGNvb3JkczEgPSAodGhpcy5zdGFydDEgKyAxKSArICcsJyArIHRoaXMubGVuZ3RoMTtcbiAgfVxuICBpZiAodGhpcy5sZW5ndGgyID09PSAwKSB7XG4gICAgY29vcmRzMiA9IHRoaXMuc3RhcnQyICsgJywwJztcbiAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aDIgPT0gMSkge1xuICAgIGNvb3JkczIgPSB0aGlzLnN0YXJ0MiArIDE7XG4gIH0gZWxzZSB7XG4gICAgY29vcmRzMiA9ICh0aGlzLnN0YXJ0MiArIDEpICsgJywnICsgdGhpcy5sZW5ndGgyO1xuICB9XG4gIHZhciB0ZXh0ID0gWydAQCAtJyArIGNvb3JkczEgKyAnICsnICsgY29vcmRzMiArICcgQEBcXG4nXTtcbiAgdmFyIG9wO1xuICAvLyBFc2NhcGUgdGhlIGJvZHkgb2YgdGhlIHBhdGNoIHdpdGggJXh4IG5vdGF0aW9uLlxuICBmb3IgKHZhciB4ID0gMDsgeCA8IHRoaXMuZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICBzd2l0Y2ggKHRoaXMuZGlmZnNbeF1bMF0pIHtcbiAgICAgIGNhc2UgRElGRl9JTlNFUlQ6XG4gICAgICAgIG9wID0gJysnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XG4gICAgICAgIG9wID0gJy0nO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9FUVVBTDpcbiAgICAgICAgb3AgPSAnICc7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0ZXh0W3ggKyAxXSA9IG9wICsgZW5jb2RlVVJJKHRoaXMuZGlmZnNbeF1bMV0pICsgJ1xcbic7XG4gIH1cbiAgLy8gT3BlcmEgZG9lc24ndCBrbm93IGhvdyB0byBlbmNvZGUgY2hhciAwLlxuICByZXR1cm4gdGV4dC5qb2luKCcnKS5yZXBsYWNlKC9cXHgwMC9nLCAnJTAwJykucmVwbGFjZSgvJTIwL2csICcgJyk7XG59O1xuXG5cbi8vIEV4cG9ydCB0aGVzZSBnbG9iYWwgdmFyaWFibGVzIHNvIHRoYXQgdGhleSBzdXJ2aXZlIEdvb2dsZSdzIEpTIGNvbXBpbGVyLlxuLypjaGFuZ2VkIGJ5IGxmYm9yamFzOiBjaGFuZ2VkIGB3aW5kb3dgIGZvciBgZXhwb3J0c2AgdG8gbWFrZSBpdCBzdWl0YWJsZSBmb3IgdGhlIG5vZGUuanMgbW9kdWxlIGNvbnZlbnRpb25zKi9cbmV4cG9ydHNbJ2RpZmZfbWF0Y2hfcGF0Y2gnXSA9IGRpZmZfbWF0Y2hfcGF0Y2g7XG5leHBvcnRzWydwYXRjaF9vYmonXSA9IHBhdGNoX29iajtcbmV4cG9ydHNbJ0RJRkZfREVMRVRFJ10gPSBESUZGX0RFTEVURTtcbmV4cG9ydHNbJ0RJRkZfSU5TRVJUJ10gPSBESUZGX0lOU0VSVDtcbmV4cG9ydHNbJ0RJRkZfRVFVQUwnXSA9IERJRkZfRVFVQUw7XG4iLCIoZnVuY3Rpb24gKFByaXNtKSB7XG5cdHZhciBmdW5jUGF0dGVybiA9IC9cXFxcKD86W15hLXooKVtcXF1dfFthLXoqXSspL2k7XG5cdHZhciBpbnNpZGVFcXUgPSB7XG5cdFx0J2VxdWF0aW9uLWNvbW1hbmQnOiB7XG5cdFx0XHRwYXR0ZXJuOiBmdW5jUGF0dGVybixcblx0XHRcdGFsaWFzOiAncmVnZXgnXG5cdFx0fVxuXHR9O1xuXG5cdFByaXNtLmxhbmd1YWdlcy5sYXRleCA9IHtcblx0XHQnY29tbWVudCc6IC8lLiovLFxuXHRcdC8vIHRoZSB2ZXJiYXRpbSBlbnZpcm9ubWVudCBwcmludHMgd2hpdGVzcGFjZSB0byB0aGUgZG9jdW1lbnRcblx0XHQnY2RhdGEnOiB7XG5cdFx0XHRwYXR0ZXJuOiAvKFxcXFxiZWdpblxceygoPzpsc3RsaXN0aW5nfHZlcmJhdGltKVxcKj8pXFx9KVtcXHNcXFNdKj8oPz1cXFxcZW5kXFx7XFwyXFx9KS8sXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdFx0fSxcblx0XHQvKlxuXHRcdCAqIGVxdWF0aW9ucyBjYW4gYmUgYmV0d2VlbiAkJCAkJCBvciAkICQgb3IgXFwoIFxcKSBvciBcXFsgXFxdXG5cdFx0ICogKGFsbCBhcmUgbXVsdGlsaW5lKVxuXHRcdCAqL1xuXHRcdCdlcXVhdGlvbic6IFtcblx0XHRcdHtcblx0XHRcdFx0cGF0dGVybjogL1xcJFxcJCg/OlxcXFxbXFxzXFxTXXxbXlxcXFwkXSkrXFwkXFwkfFxcJCg/OlxcXFxbXFxzXFxTXXxbXlxcXFwkXSkrXFwkfFxcXFxcXChbXFxzXFxTXSo/XFxcXFxcKXxcXFxcXFxbW1xcc1xcU10qP1xcXFxcXF0vLFxuXHRcdFx0XHRpbnNpZGU6IGluc2lkZUVxdSxcblx0XHRcdFx0YWxpYXM6ICdzdHJpbmcnXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRwYXR0ZXJuOiAvKFxcXFxiZWdpblxceygoPzphbGlnbnxlcW5hcnJheXxlcXVhdGlvbnxnYXRoZXJ8bWF0aHxtdWx0bGluZSlcXCo/KVxcfSlbXFxzXFxTXSo/KD89XFxcXGVuZFxce1xcMlxcfSkvLFxuXHRcdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0XHRpbnNpZGU6IGluc2lkZUVxdSxcblx0XHRcdFx0YWxpYXM6ICdzdHJpbmcnXG5cdFx0XHR9XG5cdFx0XSxcblx0XHQvKlxuXHRcdCAqIGFyZ3VtZW50cyB3aGljaCBhcmUga2V5d29yZHMgb3IgcmVmZXJlbmNlcyBhcmUgaGlnaGxpZ2h0ZWRcblx0XHQgKiBhcyBrZXl3b3Jkc1xuXHRcdCAqL1xuXHRcdCdrZXl3b3JkJzoge1xuXHRcdFx0cGF0dGVybjogLyhcXFxcKD86YmVnaW58Y2l0ZXxkb2N1bWVudGNsYXNzfGVuZHxsYWJlbHxyZWZ8dXNlcGFja2FnZSkoPzpcXFtbXlxcXV0rXFxdKT9cXHspW159XSsoPz1cXH0pLyxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWVcblx0XHR9LFxuXHRcdCd1cmwnOiB7XG5cdFx0XHRwYXR0ZXJuOiAvKFxcXFx1cmxcXHspW159XSsoPz1cXH0pLyxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWVcblx0XHR9LFxuXHRcdC8qXG5cdFx0ICogc2VjdGlvbiBvciBjaGFwdGVyIGhlYWRsaW5lcyBhcmUgaGlnaGxpZ2h0ZWQgYXMgYm9sZCBzbyB0aGF0XG5cdFx0ICogdGhleSBzdGFuZCBvdXQgbW9yZVxuXHRcdCAqL1xuXHRcdCdoZWFkbGluZSc6IHtcblx0XHRcdHBhdHRlcm46IC8oXFxcXCg/OmNoYXB0ZXJ8ZnJhbWV0aXRsZXxwYXJhZ3JhcGh8cGFydHxzZWN0aW9ufHN1YnBhcmFncmFwaHxzdWJzZWN0aW9ufHN1YnN1YnBhcmFncmFwaHxzdWJzdWJzZWN0aW9ufHN1YnN1YnN1YnBhcmFncmFwaClcXCo/KD86XFxbW15cXF1dK1xcXSk/XFx7KVtefV0rKD89XFx9KS8sXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0YWxpYXM6ICdjbGFzcy1uYW1lJ1xuXHRcdH0sXG5cdFx0J2Z1bmN0aW9uJzoge1xuXHRcdFx0cGF0dGVybjogZnVuY1BhdHRlcm4sXG5cdFx0XHRhbGlhczogJ3NlbGVjdG9yJ1xuXHRcdH0sXG5cdFx0J3B1bmN0dWF0aW9uJzogL1tbXFxde30mXS9cblx0fTtcblxuXHRQcmlzbS5sYW5ndWFnZXMudGV4ID0gUHJpc20ubGFuZ3VhZ2VzLmxhdGV4O1xuXHRQcmlzbS5sYW5ndWFnZXMuY29udGV4dCA9IFByaXNtLmxhbmd1YWdlcy5sYXRleDtcbn0oUHJpc20pKTtcbiIsIlxuLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICBCZWdpbiBwcmlzbS1jb3JlLmpzXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbi8vLyA8cmVmZXJlbmNlIGxpYj1cIldlYldvcmtlclwiLz5cblxudmFyIF9zZWxmID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKVxuXHQ/IHdpbmRvdyAgIC8vIGlmIGluIGJyb3dzZXJcblx0OiAoXG5cdFx0KHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlKVxuXHRcdFx0PyBzZWxmIC8vIGlmIGluIHdvcmtlclxuXHRcdFx0OiB7fSAgIC8vIGlmIGluIG5vZGUganNcblx0KTtcblxuLyoqXG4gKiBQcmlzbTogTGlnaHR3ZWlnaHQsIHJvYnVzdCwgZWxlZ2FudCBzeW50YXggaGlnaGxpZ2h0aW5nXG4gKlxuICogQGxpY2Vuc2UgTUlUIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD5cbiAqIEBhdXRob3IgTGVhIFZlcm91IDxodHRwczovL2xlYS52ZXJvdS5tZT5cbiAqIEBuYW1lc3BhY2VcbiAqIEBwdWJsaWNcbiAqL1xudmFyIFByaXNtID0gKGZ1bmN0aW9uIChfc2VsZikge1xuXG5cdC8vIFByaXZhdGUgaGVscGVyIHZhcnNcblx0dmFyIGxhbmcgPSAvKD86XnxcXHMpbGFuZyg/OnVhZ2UpPy0oW1xcdy1dKykoPz1cXHN8JCkvaTtcblx0dmFyIHVuaXF1ZUlkID0gMDtcblxuXHQvLyBUaGUgZ3JhbW1hciBvYmplY3QgZm9yIHBsYWludGV4dFxuXHR2YXIgcGxhaW5UZXh0R3JhbW1hciA9IHt9O1xuXG5cblx0dmFyIF8gPSB7XG5cdFx0LyoqXG5cdFx0ICogQnkgZGVmYXVsdCwgUHJpc20gd2lsbCBhdHRlbXB0IHRvIGhpZ2hsaWdodCBhbGwgY29kZSBlbGVtZW50cyAoYnkgY2FsbGluZyB7QGxpbmsgUHJpc20uaGlnaGxpZ2h0QWxsfSkgb24gdGhlXG5cdFx0ICogY3VycmVudCBwYWdlIGFmdGVyIHRoZSBwYWdlIGZpbmlzaGVkIGxvYWRpbmcuIFRoaXMgbWlnaHQgYmUgYSBwcm9ibGVtIGlmIGUuZy4geW91IHdhbnRlZCB0byBhc3luY2hyb25vdXNseSBsb2FkXG5cdFx0ICogYWRkaXRpb25hbCBsYW5ndWFnZXMgb3IgcGx1Z2lucyB5b3Vyc2VsZi5cblx0XHQgKlxuXHRcdCAqIEJ5IHNldHRpbmcgdGhpcyB2YWx1ZSB0byBgdHJ1ZWAsIFByaXNtIHdpbGwgbm90IGF1dG9tYXRpY2FsbHkgaGlnaGxpZ2h0IGFsbCBjb2RlIGVsZW1lbnRzIG9uIHRoZSBwYWdlLlxuXHRcdCAqXG5cdFx0ICogWW91IG9idmlvdXNseSBoYXZlIHRvIGNoYW5nZSB0aGlzIHZhbHVlIGJlZm9yZSB0aGUgYXV0b21hdGljIGhpZ2hsaWdodGluZyBzdGFydGVkLiBUbyBkbyB0aGlzLCB5b3UgY2FuIGFkZCBhblxuXHRcdCAqIGVtcHR5IFByaXNtIG9iamVjdCBpbnRvIHRoZSBnbG9iYWwgc2NvcGUgYmVmb3JlIGxvYWRpbmcgdGhlIFByaXNtIHNjcmlwdCBsaWtlIHRoaXM6XG5cdFx0ICpcblx0XHQgKiBgYGBqc1xuXHRcdCAqIHdpbmRvdy5QcmlzbSA9IHdpbmRvdy5QcmlzbSB8fCB7fTtcblx0XHQgKiBQcmlzbS5tYW51YWwgPSB0cnVlO1xuXHRcdCAqIC8vIGFkZCBhIG5ldyA8c2NyaXB0PiB0byBsb2FkIFByaXNtJ3Mgc2NyaXB0XG5cdFx0ICogYGBgXG5cdFx0ICpcblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBtZW1iZXJvZiBQcmlzbVxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKi9cblx0XHRtYW51YWw6IF9zZWxmLlByaXNtICYmIF9zZWxmLlByaXNtLm1hbnVhbCxcblx0XHQvKipcblx0XHQgKiBCeSBkZWZhdWx0LCBpZiBQcmlzbSBpcyBpbiBhIHdlYiB3b3JrZXIsIGl0IGFzc3VtZXMgdGhhdCBpdCBpcyBpbiBhIHdvcmtlciBpdCBjcmVhdGVkIGl0c2VsZiwgc28gaXQgdXNlc1xuXHRcdCAqIGBhZGRFdmVudExpc3RlbmVyYCB0byBjb21tdW5pY2F0ZSB3aXRoIGl0cyBwYXJlbnQgaW5zdGFuY2UuIEhvd2V2ZXIsIGlmIHlvdSdyZSB1c2luZyBQcmlzbSBtYW51YWxseSBpbiB5b3VyXG5cdFx0ICogb3duIHdvcmtlciwgeW91IGRvbid0IHdhbnQgaXQgdG8gZG8gdGhpcy5cblx0XHQgKlxuXHRcdCAqIEJ5IHNldHRpbmcgdGhpcyB2YWx1ZSB0byBgdHJ1ZWAsIFByaXNtIHdpbGwgbm90IGFkZCBpdHMgb3duIGxpc3RlbmVycyB0byB0aGUgd29ya2VyLlxuXHRcdCAqXG5cdFx0ICogWW91IG9idmlvdXNseSBoYXZlIHRvIGNoYW5nZSB0aGlzIHZhbHVlIGJlZm9yZSBQcmlzbSBleGVjdXRlcy4gVG8gZG8gdGhpcywgeW91IGNhbiBhZGQgYW5cblx0XHQgKiBlbXB0eSBQcmlzbSBvYmplY3QgaW50byB0aGUgZ2xvYmFsIHNjb3BlIGJlZm9yZSBsb2FkaW5nIHRoZSBQcmlzbSBzY3JpcHQgbGlrZSB0aGlzOlxuXHRcdCAqXG5cdFx0ICogYGBganNcblx0XHQgKiB3aW5kb3cuUHJpc20gPSB3aW5kb3cuUHJpc20gfHwge307XG5cdFx0ICogUHJpc20uZGlzYWJsZVdvcmtlck1lc3NhZ2VIYW5kbGVyID0gdHJ1ZTtcblx0XHQgKiAvLyBMb2FkIFByaXNtJ3Mgc2NyaXB0XG5cdFx0ICogYGBgXG5cdFx0ICpcblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBtZW1iZXJvZiBQcmlzbVxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKi9cblx0XHRkaXNhYmxlV29ya2VyTWVzc2FnZUhhbmRsZXI6IF9zZWxmLlByaXNtICYmIF9zZWxmLlByaXNtLmRpc2FibGVXb3JrZXJNZXNzYWdlSGFuZGxlcixcblxuXHRcdC8qKlxuXHRcdCAqIEEgbmFtZXNwYWNlIGZvciB1dGlsaXR5IG1ldGhvZHMuXG5cdFx0ICpcblx0XHQgKiBBbGwgZnVuY3Rpb24gaW4gdGhpcyBuYW1lc3BhY2UgdGhhdCBhcmUgbm90IGV4cGxpY2l0bHkgbWFya2VkIGFzIF9wdWJsaWNfIGFyZSBmb3IgX19pbnRlcm5hbCB1c2Ugb25seV9fIGFuZCBtYXlcblx0XHQgKiBjaGFuZ2Ugb3IgZGlzYXBwZWFyIGF0IGFueSB0aW1lLlxuXHRcdCAqXG5cdFx0ICogQG5hbWVzcGFjZVxuXHRcdCAqIEBtZW1iZXJvZiBQcmlzbVxuXHRcdCAqL1xuXHRcdHV0aWw6IHtcblx0XHRcdGVuY29kZTogZnVuY3Rpb24gZW5jb2RlKHRva2Vucykge1xuXHRcdFx0XHRpZiAodG9rZW5zIGluc3RhbmNlb2YgVG9rZW4pIHtcblx0XHRcdFx0XHRyZXR1cm4gbmV3IFRva2VuKHRva2Vucy50eXBlLCBlbmNvZGUodG9rZW5zLmNvbnRlbnQpLCB0b2tlbnMuYWxpYXMpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodG9rZW5zKSkge1xuXHRcdFx0XHRcdHJldHVybiB0b2tlbnMubWFwKGVuY29kZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRva2Vucy5yZXBsYWNlKC8mL2csICcmYW1wOycpLnJlcGxhY2UoLzwvZywgJyZsdDsnKS5yZXBsYWNlKC9cXHUwMGEwL2csICcgJyk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgdHlwZSBvZiB0aGUgZ2l2ZW4gdmFsdWUuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHthbnl9IG9cblx0XHRcdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogdHlwZShudWxsKSAgICAgID09PSAnTnVsbCdcblx0XHRcdCAqIHR5cGUodW5kZWZpbmVkKSA9PT0gJ1VuZGVmaW5lZCdcblx0XHRcdCAqIHR5cGUoMTIzKSAgICAgICA9PT0gJ051bWJlcidcblx0XHRcdCAqIHR5cGUoJ2ZvbycpICAgICA9PT0gJ1N0cmluZydcblx0XHRcdCAqIHR5cGUodHJ1ZSkgICAgICA9PT0gJ0Jvb2xlYW4nXG5cdFx0XHQgKiB0eXBlKFsxLCAyXSkgICAgPT09ICdBcnJheSdcblx0XHRcdCAqIHR5cGUoe30pICAgICAgICA9PT0gJ09iamVjdCdcblx0XHRcdCAqIHR5cGUoU3RyaW5nKSAgICA9PT0gJ0Z1bmN0aW9uJ1xuXHRcdFx0ICogdHlwZSgvYWJjKy8pICAgID09PSAnUmVnRXhwJ1xuXHRcdFx0ICovXG5cdFx0XHR0eXBlOiBmdW5jdGlvbiAobykge1xuXHRcdFx0XHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogUmV0dXJucyBhIHVuaXF1ZSBudW1iZXIgZm9yIHRoZSBnaXZlbiBvYmplY3QuIExhdGVyIGNhbGxzIHdpbGwgc3RpbGwgcmV0dXJuIHRoZSBzYW1lIG51bWJlci5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gb2JqXG5cdFx0XHQgKiBAcmV0dXJucyB7bnVtYmVyfVxuXHRcdFx0ICovXG5cdFx0XHRvYmpJZDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0XHRpZiAoIW9ialsnX19pZCddKSB7XG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgJ19faWQnLCB7IHZhbHVlOiArK3VuaXF1ZUlkIH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBvYmpbJ19faWQnXTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQ3JlYXRlcyBhIGRlZXAgY2xvbmUgb2YgdGhlIGdpdmVuIG9iamVjdC5cblx0XHRcdCAqXG5cdFx0XHQgKiBUaGUgbWFpbiBpbnRlbmRlZCB1c2Ugb2YgdGhpcyBmdW5jdGlvbiBpcyB0byBjbG9uZSBsYW5ndWFnZSBkZWZpbml0aW9ucy5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge1R9IG9cblx0XHRcdCAqIEBwYXJhbSB7UmVjb3JkPG51bWJlciwgYW55Pn0gW3Zpc2l0ZWRdXG5cdFx0XHQgKiBAcmV0dXJucyB7VH1cblx0XHRcdCAqIEB0ZW1wbGF0ZSBUXG5cdFx0XHQgKi9cblx0XHRcdGNsb25lOiBmdW5jdGlvbiBkZWVwQ2xvbmUobywgdmlzaXRlZCkge1xuXHRcdFx0XHR2aXNpdGVkID0gdmlzaXRlZCB8fCB7fTtcblxuXHRcdFx0XHR2YXIgY2xvbmU7IHZhciBpZDtcblx0XHRcdFx0c3dpdGNoIChfLnV0aWwudHlwZShvKSkge1xuXHRcdFx0XHRcdGNhc2UgJ09iamVjdCc6XG5cdFx0XHRcdFx0XHRpZCA9IF8udXRpbC5vYmpJZChvKTtcblx0XHRcdFx0XHRcdGlmICh2aXNpdGVkW2lkXSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmlzaXRlZFtpZF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjbG9uZSA9IC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gKi8gKHt9KTtcblx0XHRcdFx0XHRcdHZpc2l0ZWRbaWRdID0gY2xvbmU7XG5cblx0XHRcdFx0XHRcdGZvciAodmFyIGtleSBpbiBvKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChvLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0XHRcdFx0XHRjbG9uZVtrZXldID0gZGVlcENsb25lKG9ba2V5XSwgdmlzaXRlZCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmV0dXJuIC8qKiBAdHlwZSB7YW55fSAqLyAoY2xvbmUpO1xuXG5cdFx0XHRcdFx0Y2FzZSAnQXJyYXknOlxuXHRcdFx0XHRcdFx0aWQgPSBfLnV0aWwub2JqSWQobyk7XG5cdFx0XHRcdFx0XHRpZiAodmlzaXRlZFtpZF0pIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZpc2l0ZWRbaWRdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y2xvbmUgPSBbXTtcblx0XHRcdFx0XHRcdHZpc2l0ZWRbaWRdID0gY2xvbmU7XG5cblx0XHRcdFx0XHRcdCgvKiogQHR5cGUge0FycmF5fSAqLygvKiogQHR5cGUge2FueX0gKi8obykpKS5mb3JFYWNoKGZ1bmN0aW9uICh2LCBpKSB7XG5cdFx0XHRcdFx0XHRcdGNsb25lW2ldID0gZGVlcENsb25lKHYsIHZpc2l0ZWQpO1xuXHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdHJldHVybiAvKiogQHR5cGUge2FueX0gKi8gKGNsb25lKTtcblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRyZXR1cm4gbztcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBSZXR1cm5zIHRoZSBQcmlzbSBsYW5ndWFnZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudCBzZXQgYnkgYSBgbGFuZ3VhZ2UteHh4eGAgb3IgYGxhbmcteHh4eGAgY2xhc3MuXG5cdFx0XHQgKlxuXHRcdFx0ICogSWYgbm8gbGFuZ3VhZ2UgaXMgc2V0IGZvciB0aGUgZWxlbWVudCBvciB0aGUgZWxlbWVudCBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAsIGBub25lYCB3aWxsIGJlIHJldHVybmVkLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuXHRcdFx0ICogQHJldHVybnMge3N0cmluZ31cblx0XHRcdCAqL1xuXHRcdFx0Z2V0TGFuZ3VhZ2U6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cdFx0XHRcdHdoaWxlIChlbGVtZW50KSB7XG5cdFx0XHRcdFx0dmFyIG0gPSBsYW5nLmV4ZWMoZWxlbWVudC5jbGFzc05hbWUpO1xuXHRcdFx0XHRcdGlmIChtKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbVsxXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbGVtZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAnbm9uZSc7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldHMgdGhlIFByaXNtIGBsYW5ndWFnZS14eHh4YCBjbGFzcyBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZVxuXHRcdFx0ICogQHJldHVybnMge3ZvaWR9XG5cdFx0XHQgKi9cblx0XHRcdHNldExhbmd1YWdlOiBmdW5jdGlvbiAoZWxlbWVudCwgbGFuZ3VhZ2UpIHtcblx0XHRcdFx0Ly8gcmVtb3ZlIGFsbCBgbGFuZ3VhZ2UteHh4eGAgY2xhc3Nlc1xuXHRcdFx0XHQvLyAodGhpcyBtaWdodCBsZWF2ZSBiZWhpbmQgYSBsZWFkaW5nIHNwYWNlKVxuXHRcdFx0XHRlbGVtZW50LmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lLnJlcGxhY2UoUmVnRXhwKGxhbmcsICdnaScpLCAnJyk7XG5cblx0XHRcdFx0Ly8gYWRkIHRoZSBuZXcgYGxhbmd1YWdlLXh4eHhgIGNsYXNzXG5cdFx0XHRcdC8vICh1c2luZyBgY2xhc3NMaXN0YCB3aWxsIGF1dG9tYXRpY2FsbHkgY2xlYW4gdXAgc3BhY2VzIGZvciB1cylcblx0XHRcdFx0ZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdsYW5ndWFnZS0nICsgbGFuZ3VhZ2UpO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBSZXR1cm5zIHRoZSBzY3JpcHQgZWxlbWVudCB0aGF0IGlzIGN1cnJlbnRseSBleGVjdXRpbmcuXG5cdFx0XHQgKlxuXHRcdFx0ICogVGhpcyBkb2VzIF9fbm90X18gd29yayBmb3IgbGluZSBzY3JpcHQgZWxlbWVudC5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcmV0dXJucyB7SFRNTFNjcmlwdEVsZW1lbnQgfCBudWxsfVxuXHRcdFx0ICovXG5cdFx0XHRjdXJyZW50U2NyaXB0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCdjdXJyZW50U2NyaXB0JyBpbiBkb2N1bWVudCAmJiAxIDwgMiAvKiBoYWNrIHRvIHRyaXAgVFMnIGZsb3cgYW5hbHlzaXMgKi8pIHtcblx0XHRcdFx0XHRyZXR1cm4gLyoqIEB0eXBlIHthbnl9ICovIChkb2N1bWVudC5jdXJyZW50U2NyaXB0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElFMTEgd29ya2Fyb3VuZFxuXHRcdFx0XHQvLyB3ZSdsbCBnZXQgdGhlIHNyYyBvZiB0aGUgY3VycmVudCBzY3JpcHQgYnkgcGFyc2luZyBJRTExJ3MgZXJyb3Igc3RhY2sgdHJhY2Vcblx0XHRcdFx0Ly8gdGhpcyB3aWxsIG5vdCB3b3JrIGZvciBpbmxpbmUgc2NyaXB0c1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdC8vIEdldCBmaWxlIHNyYyB1cmwgZnJvbSBzdGFjay4gU3BlY2lmaWNhbGx5IHdvcmtzIHdpdGggdGhlIGZvcm1hdCBvZiBzdGFjayB0cmFjZXMgaW4gSUUuXG5cdFx0XHRcdFx0Ly8gQSBzdGFjayB3aWxsIGxvb2sgbGlrZSB0aGlzOlxuXHRcdFx0XHRcdC8vXG5cdFx0XHRcdFx0Ly8gRXJyb3Jcblx0XHRcdFx0XHQvLyAgICBhdCBfLnV0aWwuY3VycmVudFNjcmlwdCAoaHR0cDovL2xvY2FsaG9zdC9jb21wb25lbnRzL3ByaXNtLWNvcmUuanM6MTE5OjUpXG5cdFx0XHRcdFx0Ly8gICAgYXQgR2xvYmFsIGNvZGUgKGh0dHA6Ly9sb2NhbGhvc3QvY29tcG9uZW50cy9wcmlzbS1jb3JlLmpzOjYwNjoxKVxuXG5cdFx0XHRcdFx0dmFyIHNyYyA9ICgvYXQgW14oXFxyXFxuXSpcXCgoLiopOlteOl0rOlteOl0rXFwpJC9pLmV4ZWMoZXJyLnN0YWNrKSB8fCBbXSlbMV07XG5cdFx0XHRcdFx0aWYgKHNyYykge1xuXHRcdFx0XHRcdFx0dmFyIHNjcmlwdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0Jyk7XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpIGluIHNjcmlwdHMpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHNjcmlwdHNbaV0uc3JjID09IHNyYykge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBzY3JpcHRzW2ldO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFJldHVybnMgd2hldGhlciBhIGdpdmVuIGNsYXNzIGlzIGFjdGl2ZSBmb3IgYGVsZW1lbnRgLlxuXHRcdFx0ICpcblx0XHRcdCAqIFRoZSBjbGFzcyBjYW4gYmUgYWN0aXZhdGVkIGlmIGBlbGVtZW50YCBvciBvbmUgb2YgaXRzIGFuY2VzdG9ycyBoYXMgdGhlIGdpdmVuIGNsYXNzIGFuZCBpdCBjYW4gYmUgZGVhY3RpdmF0ZWRcblx0XHRcdCAqIGlmIGBlbGVtZW50YCBvciBvbmUgb2YgaXRzIGFuY2VzdG9ycyBoYXMgdGhlIG5lZ2F0ZWQgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gY2xhc3MuIFRoZSBfbmVnYXRlZCB2ZXJzaW9uXyBvZiB0aGVcblx0XHRcdCAqIGdpdmVuIGNsYXNzIGlzIGp1c3QgdGhlIGdpdmVuIGNsYXNzIHdpdGggYSBgbm8tYCBwcmVmaXguXG5cdFx0XHQgKlxuXHRcdFx0ICogV2hldGhlciB0aGUgY2xhc3MgaXMgYWN0aXZlIGlzIGRldGVybWluZWQgYnkgdGhlIGNsb3Nlc3QgYW5jZXN0b3Igb2YgYGVsZW1lbnRgICh3aGVyZSBgZWxlbWVudGAgaXRzZWxmIGlzXG5cdFx0XHQgKiBjbG9zZXN0IGFuY2VzdG9yKSB0aGF0IGhhcyB0aGUgZ2l2ZW4gY2xhc3Mgb3IgdGhlIG5lZ2F0ZWQgdmVyc2lvbiBvZiBpdC4gSWYgbmVpdGhlciBgZWxlbWVudGAgbm9yIGFueSBvZiBpdHNcblx0XHRcdCAqIGFuY2VzdG9ycyBoYXZlIHRoZSBnaXZlbiBjbGFzcyBvciB0aGUgbmVnYXRlZCB2ZXJzaW9uIG9mIGl0LCB0aGVuIHRoZSBkZWZhdWx0IGFjdGl2YXRpb24gd2lsbCBiZSByZXR1cm5lZC5cblx0XHRcdCAqXG5cdFx0XHQgKiBJbiB0aGUgcGFyYWRveGljYWwgc2l0dWF0aW9uIHdoZXJlIHRoZSBjbG9zZXN0IGFuY2VzdG9yIGNvbnRhaW5zIF9fYm90aF9fIHRoZSBnaXZlbiBjbGFzcyBhbmQgdGhlIG5lZ2F0ZWRcblx0XHRcdCAqIHZlcnNpb24gb2YgaXQsIHRoZSBjbGFzcyBpcyBjb25zaWRlcmVkIGFjdGl2ZS5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcblx0XHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RlZmF1bHRBY3RpdmF0aW9uPWZhbHNlXVxuXHRcdFx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdFx0XHQgKi9cblx0XHRcdGlzQWN0aXZlOiBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOYW1lLCBkZWZhdWx0QWN0aXZhdGlvbikge1xuXHRcdFx0XHR2YXIgbm8gPSAnbm8tJyArIGNsYXNzTmFtZTtcblxuXHRcdFx0XHR3aGlsZSAoZWxlbWVudCkge1xuXHRcdFx0XHRcdHZhciBjbGFzc0xpc3QgPSBlbGVtZW50LmNsYXNzTGlzdDtcblx0XHRcdFx0XHRpZiAoY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSkpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoY2xhc3NMaXN0LmNvbnRhaW5zKG5vKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbGVtZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAhIWRlZmF1bHRBY3RpdmF0aW9uO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBUaGlzIG5hbWVzcGFjZSBjb250YWlucyBhbGwgY3VycmVudGx5IGxvYWRlZCBsYW5ndWFnZXMgYW5kIHRoZSBzb21lIGhlbHBlciBmdW5jdGlvbnMgdG8gY3JlYXRlIGFuZCBtb2RpZnkgbGFuZ3VhZ2VzLlxuXHRcdCAqXG5cdFx0ICogQG5hbWVzcGFjZVxuXHRcdCAqIEBtZW1iZXJvZiBQcmlzbVxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKi9cblx0XHRsYW5ndWFnZXM6IHtcblx0XHRcdC8qKlxuXHRcdFx0ICogVGhlIGdyYW1tYXIgZm9yIHBsYWluLCB1bmZvcm1hdHRlZCB0ZXh0LlxuXHRcdFx0ICovXG5cdFx0XHRwbGFpbjogcGxhaW5UZXh0R3JhbW1hcixcblx0XHRcdHBsYWludGV4dDogcGxhaW5UZXh0R3JhbW1hcixcblx0XHRcdHRleHQ6IHBsYWluVGV4dEdyYW1tYXIsXG5cdFx0XHR0eHQ6IHBsYWluVGV4dEdyYW1tYXIsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQ3JlYXRlcyBhIGRlZXAgY29weSBvZiB0aGUgbGFuZ3VhZ2Ugd2l0aCB0aGUgZ2l2ZW4gaWQgYW5kIGFwcGVuZHMgdGhlIGdpdmVuIHRva2Vucy5cblx0XHRcdCAqXG5cdFx0XHQgKiBJZiBhIHRva2VuIGluIGByZWRlZmAgYWxzbyBhcHBlYXJzIGluIHRoZSBjb3BpZWQgbGFuZ3VhZ2UsIHRoZW4gdGhlIGV4aXN0aW5nIHRva2VuIGluIHRoZSBjb3BpZWQgbGFuZ3VhZ2Vcblx0XHRcdCAqIHdpbGwgYmUgb3ZlcndyaXR0ZW4gYXQgaXRzIG9yaWdpbmFsIHBvc2l0aW9uLlxuXHRcdFx0ICpcblx0XHRcdCAqICMjIEJlc3QgcHJhY3RpY2VzXG5cdFx0XHQgKlxuXHRcdFx0ICogU2luY2UgdGhlIHBvc2l0aW9uIG9mIG92ZXJ3cml0aW5nIHRva2VucyAodG9rZW4gaW4gYHJlZGVmYCB0aGF0IG92ZXJ3cml0ZSB0b2tlbnMgaW4gdGhlIGNvcGllZCBsYW5ndWFnZSlcblx0XHRcdCAqIGRvZXNuJ3QgbWF0dGVyLCB0aGV5IGNhbiB0ZWNobmljYWxseSBiZSBpbiBhbnkgb3JkZXIuIEhvd2V2ZXIsIHRoaXMgY2FuIGJlIGNvbmZ1c2luZyB0byBvdGhlcnMgdGhhdCB0cnlpbmcgdG9cblx0XHRcdCAqIHVuZGVyc3RhbmQgdGhlIGxhbmd1YWdlIGRlZmluaXRpb24gYmVjYXVzZSwgbm9ybWFsbHksIHRoZSBvcmRlciBvZiB0b2tlbnMgbWF0dGVycyBpbiBQcmlzbSBncmFtbWFycy5cblx0XHRcdCAqXG5cdFx0XHQgKiBUaGVyZWZvcmUsIGl0IGlzIGVuY291cmFnZWQgdG8gb3JkZXIgb3ZlcndyaXRpbmcgdG9rZW5zIGFjY29yZGluZyB0byB0aGUgcG9zaXRpb25zIG9mIHRoZSBvdmVyd3JpdHRlbiB0b2tlbnMuXG5cdFx0XHQgKiBGdXJ0aGVybW9yZSwgYWxsIG5vbi1vdmVyd3JpdGluZyB0b2tlbnMgc2hvdWxkIGJlIHBsYWNlZCBhZnRlciB0aGUgb3ZlcndyaXRpbmcgb25lcy5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIGlkIG9mIHRoZSBsYW5ndWFnZSB0byBleHRlbmQuIFRoaXMgaGFzIHRvIGJlIGEga2V5IGluIGBQcmlzbS5sYW5ndWFnZXNgLlxuXHRcdFx0ICogQHBhcmFtIHtHcmFtbWFyfSByZWRlZiBUaGUgbmV3IHRva2VucyB0byBhcHBlbmQuXG5cdFx0XHQgKiBAcmV0dXJucyB7R3JhbW1hcn0gVGhlIG5ldyBsYW5ndWFnZSBjcmVhdGVkLlxuXHRcdFx0ICogQHB1YmxpY1xuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIFByaXNtLmxhbmd1YWdlc1snY3NzLXdpdGgtY29sb3JzJ10gPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjc3MnLCB7XG5cdFx0XHQgKiAgICAgLy8gUHJpc20ubGFuZ3VhZ2VzLmNzcyBhbHJlYWR5IGhhcyBhICdjb21tZW50JyB0b2tlbiwgc28gdGhpcyB0b2tlbiB3aWxsIG92ZXJ3cml0ZSBDU1MnICdjb21tZW50JyB0b2tlblxuXHRcdFx0ICogICAgIC8vIGF0IGl0cyBvcmlnaW5hbCBwb3NpdGlvblxuXHRcdFx0ICogICAgICdjb21tZW50JzogeyAuLi4gfSxcblx0XHRcdCAqICAgICAvLyBDU1MgZG9lc24ndCBoYXZlIGEgJ2NvbG9yJyB0b2tlbiwgc28gdGhpcyB0b2tlbiB3aWxsIGJlIGFwcGVuZGVkXG5cdFx0XHQgKiAgICAgJ2NvbG9yJzogL1xcYig/OnJlZHxncmVlbnxibHVlKVxcYi9cblx0XHRcdCAqIH0pO1xuXHRcdFx0ICovXG5cdFx0XHRleHRlbmQ6IGZ1bmN0aW9uIChpZCwgcmVkZWYpIHtcblx0XHRcdFx0dmFyIGxhbmcgPSBfLnV0aWwuY2xvbmUoXy5sYW5ndWFnZXNbaWRdKTtcblxuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gcmVkZWYpIHtcblx0XHRcdFx0XHRsYW5nW2tleV0gPSByZWRlZltrZXldO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGxhbmc7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEluc2VydHMgdG9rZW5zIF9iZWZvcmVfIGFub3RoZXIgdG9rZW4gaW4gYSBsYW5ndWFnZSBkZWZpbml0aW9uIG9yIGFueSBvdGhlciBncmFtbWFyLlxuXHRcdFx0ICpcblx0XHRcdCAqICMjIFVzYWdlXG5cdFx0XHQgKlxuXHRcdFx0ICogVGhpcyBoZWxwZXIgbWV0aG9kIG1ha2VzIGl0IGVhc3kgdG8gbW9kaWZ5IGV4aXN0aW5nIGxhbmd1YWdlcy4gRm9yIGV4YW1wbGUsIHRoZSBDU1MgbGFuZ3VhZ2UgZGVmaW5pdGlvblxuXHRcdFx0ICogbm90IG9ubHkgZGVmaW5lcyBDU1MgaGlnaGxpZ2h0aW5nIGZvciBDU1MgZG9jdW1lbnRzLCBidXQgYWxzbyBuZWVkcyB0byBkZWZpbmUgaGlnaGxpZ2h0aW5nIGZvciBDU1MgZW1iZWRkZWRcblx0XHRcdCAqIGluIEhUTUwgdGhyb3VnaCBgPHN0eWxlPmAgZWxlbWVudHMuIFRvIGRvIHRoaXMsIGl0IG5lZWRzIHRvIG1vZGlmeSBgUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cGAgYW5kIGFkZCB0aGVcblx0XHRcdCAqIGFwcHJvcHJpYXRlIHRva2Vucy4gSG93ZXZlciwgYFByaXNtLmxhbmd1YWdlcy5tYXJrdXBgIGlzIGEgcmVndWxhciBKYXZhU2NyaXB0IG9iamVjdCBsaXRlcmFsLCBzbyBpZiB5b3UgZG9cblx0XHRcdCAqIHRoaXM6XG5cdFx0XHQgKlxuXHRcdFx0ICogYGBganNcblx0XHRcdCAqIFByaXNtLmxhbmd1YWdlcy5tYXJrdXAuc3R5bGUgPSB7XG5cdFx0XHQgKiAgICAgLy8gdG9rZW5cblx0XHRcdCAqIH07XG5cdFx0XHQgKiBgYGBcblx0XHRcdCAqXG5cdFx0XHQgKiB0aGVuIHRoZSBgc3R5bGVgIHRva2VuIHdpbGwgYmUgYWRkZWQgKGFuZCBwcm9jZXNzZWQpIGF0IHRoZSBlbmQuIGBpbnNlcnRCZWZvcmVgIGFsbG93cyB5b3UgdG8gaW5zZXJ0IHRva2Vuc1xuXHRcdFx0ICogYmVmb3JlIGV4aXN0aW5nIHRva2Vucy4gRm9yIHRoZSBDU1MgZXhhbXBsZSBhYm92ZSwgeW91IHdvdWxkIHVzZSBpdCBsaWtlIHRoaXM6XG5cdFx0XHQgKlxuXHRcdFx0ICogYGBganNcblx0XHRcdCAqIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ21hcmt1cCcsICdjZGF0YScsIHtcblx0XHRcdCAqICAgICAnc3R5bGUnOiB7XG5cdFx0XHQgKiAgICAgICAgIC8vIHRva2VuXG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogfSk7XG5cdFx0XHQgKiBgYGBcblx0XHRcdCAqXG5cdFx0XHQgKiAjIyBTcGVjaWFsIGNhc2VzXG5cdFx0XHQgKlxuXHRcdFx0ICogSWYgdGhlIGdyYW1tYXJzIG9mIGBpbnNpZGVgIGFuZCBgaW5zZXJ0YCBoYXZlIHRva2VucyB3aXRoIHRoZSBzYW1lIG5hbWUsIHRoZSB0b2tlbnMgaW4gYGluc2lkZWAncyBncmFtbWFyXG5cdFx0XHQgKiB3aWxsIGJlIGlnbm9yZWQuXG5cdFx0XHQgKlxuXHRcdFx0ICogVGhpcyBiZWhhdmlvciBjYW4gYmUgdXNlZCB0byBpbnNlcnQgdG9rZW5zIGFmdGVyIGBiZWZvcmVgOlxuXHRcdFx0ICpcblx0XHRcdCAqIGBgYGpzXG5cdFx0XHQgKiBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdtYXJrdXAnLCAnY29tbWVudCcsIHtcblx0XHRcdCAqICAgICAnY29tbWVudCc6IFByaXNtLmxhbmd1YWdlcy5tYXJrdXAuY29tbWVudCxcblx0XHRcdCAqICAgICAvLyB0b2tlbnMgYWZ0ZXIgJ2NvbW1lbnQnXG5cdFx0XHQgKiB9KTtcblx0XHRcdCAqIGBgYFxuXHRcdFx0ICpcblx0XHRcdCAqICMjIExpbWl0YXRpb25zXG5cdFx0XHQgKlxuXHRcdFx0ICogVGhlIG1haW4gcHJvYmxlbSBgaW5zZXJ0QmVmb3JlYCBoYXMgdG8gc29sdmUgaXMgaXRlcmF0aW9uIG9yZGVyLiBTaW5jZSBFUzIwMTUsIHRoZSBpdGVyYXRpb24gb3JkZXIgZm9yIG9iamVjdFxuXHRcdFx0ICogcHJvcGVydGllcyBpcyBndWFyYW50ZWVkIHRvIGJlIHRoZSBpbnNlcnRpb24gb3JkZXIgKGV4Y2VwdCBmb3IgaW50ZWdlciBrZXlzKSBidXQgc29tZSBicm93c2VycyBiZWhhdmVcblx0XHRcdCAqIGRpZmZlcmVudGx5IHdoZW4ga2V5cyBhcmUgZGVsZXRlZCBhbmQgcmUtaW5zZXJ0ZWQuIFNvIGBpbnNlcnRCZWZvcmVgIGNhbid0IGJlIGltcGxlbWVudGVkIGJ5IHRlbXBvcmFyaWx5XG5cdFx0XHQgKiBkZWxldGluZyBwcm9wZXJ0aWVzIHdoaWNoIGlzIG5lY2Vzc2FyeSB0byBpbnNlcnQgYXQgYXJiaXRyYXJ5IHBvc2l0aW9ucy5cblx0XHRcdCAqXG5cdFx0XHQgKiBUbyBzb2x2ZSB0aGlzIHByb2JsZW0sIGBpbnNlcnRCZWZvcmVgIGRvZXNuJ3QgYWN0dWFsbHkgaW5zZXJ0IHRoZSBnaXZlbiB0b2tlbnMgaW50byB0aGUgdGFyZ2V0IG9iamVjdC5cblx0XHRcdCAqIEluc3RlYWQsIGl0IHdpbGwgY3JlYXRlIGEgbmV3IG9iamVjdCBhbmQgcmVwbGFjZSBhbGwgcmVmZXJlbmNlcyB0byB0aGUgdGFyZ2V0IG9iamVjdCB3aXRoIHRoZSBuZXcgb25lLiBUaGlzXG5cdFx0XHQgKiBjYW4gYmUgZG9uZSB3aXRob3V0IHRlbXBvcmFyaWx5IGRlbGV0aW5nIHByb3BlcnRpZXMsIHNvIHRoZSBpdGVyYXRpb24gb3JkZXIgaXMgd2VsbC1kZWZpbmVkLlxuXHRcdFx0ICpcblx0XHRcdCAqIEhvd2V2ZXIsIG9ubHkgcmVmZXJlbmNlcyB0aGF0IGNhbiBiZSByZWFjaGVkIGZyb20gYFByaXNtLmxhbmd1YWdlc2Agb3IgYGluc2VydGAgd2lsbCBiZSByZXBsYWNlZC4gSS5lLiBpZlxuXHRcdFx0ICogeW91IGhvbGQgdGhlIHRhcmdldCBvYmplY3QgaW4gYSB2YXJpYWJsZSwgdGhlbiB0aGUgdmFsdWUgb2YgdGhlIHZhcmlhYmxlIHdpbGwgbm90IGNoYW5nZS5cblx0XHRcdCAqXG5cdFx0XHQgKiBgYGBqc1xuXHRcdFx0ICogdmFyIG9sZE1hcmt1cCA9IFByaXNtLmxhbmd1YWdlcy5tYXJrdXA7XG5cdFx0XHQgKiB2YXIgbmV3TWFya3VwID0gUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnbWFya3VwJywgJ2NvbW1lbnQnLCB7IC4uLiB9KTtcblx0XHRcdCAqXG5cdFx0XHQgKiBhc3NlcnQob2xkTWFya3VwICE9PSBQcmlzbS5sYW5ndWFnZXMubWFya3VwKTtcblx0XHRcdCAqIGFzc2VydChuZXdNYXJrdXAgPT09IFByaXNtLmxhbmd1YWdlcy5tYXJrdXApO1xuXHRcdFx0ICogYGBgXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IGluc2lkZSBUaGUgcHJvcGVydHkgb2YgYHJvb3RgIChlLmcuIGEgbGFuZ3VhZ2UgaWQgaW4gYFByaXNtLmxhbmd1YWdlc2ApIHRoYXQgY29udGFpbnMgdGhlXG5cdFx0XHQgKiBvYmplY3QgdG8gYmUgbW9kaWZpZWQuXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gYmVmb3JlIFRoZSBrZXkgdG8gaW5zZXJ0IGJlZm9yZS5cblx0XHRcdCAqIEBwYXJhbSB7R3JhbW1hcn0gaW5zZXJ0IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBrZXktdmFsdWUgcGFpcnMgdG8gYmUgaW5zZXJ0ZWQuXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IFtyb290XSBUaGUgb2JqZWN0IGNvbnRhaW5pbmcgYGluc2lkZWAsIGkuZS4gdGhlIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZVxuXHRcdFx0ICogb2JqZWN0IHRvIGJlIG1vZGlmaWVkLlxuXHRcdFx0ICpcblx0XHRcdCAqIERlZmF1bHRzIHRvIGBQcmlzbS5sYW5ndWFnZXNgLlxuXHRcdFx0ICogQHJldHVybnMge0dyYW1tYXJ9IFRoZSBuZXcgZ3JhbW1hciBvYmplY3QuXG5cdFx0XHQgKiBAcHVibGljXG5cdFx0XHQgKi9cblx0XHRcdGluc2VydEJlZm9yZTogZnVuY3Rpb24gKGluc2lkZSwgYmVmb3JlLCBpbnNlcnQsIHJvb3QpIHtcblx0XHRcdFx0cm9vdCA9IHJvb3QgfHwgLyoqIEB0eXBlIHthbnl9ICovIChfLmxhbmd1YWdlcyk7XG5cdFx0XHRcdHZhciBncmFtbWFyID0gcm9vdFtpbnNpZGVdO1xuXHRcdFx0XHQvKiogQHR5cGUge0dyYW1tYXJ9ICovXG5cdFx0XHRcdHZhciByZXQgPSB7fTtcblxuXHRcdFx0XHRmb3IgKHZhciB0b2tlbiBpbiBncmFtbWFyKSB7XG5cdFx0XHRcdFx0aWYgKGdyYW1tYXIuaGFzT3duUHJvcGVydHkodG9rZW4pKSB7XG5cblx0XHRcdFx0XHRcdGlmICh0b2tlbiA9PSBiZWZvcmUpIHtcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgbmV3VG9rZW4gaW4gaW5zZXJ0KSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGluc2VydC5oYXNPd25Qcm9wZXJ0eShuZXdUb2tlbikpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldFtuZXdUb2tlbl0gPSBpbnNlcnRbbmV3VG9rZW5dO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBEbyBub3QgaW5zZXJ0IHRva2VuIHdoaWNoIGFsc28gb2NjdXIgaW4gaW5zZXJ0LiBTZWUgIzE1MjVcblx0XHRcdFx0XHRcdGlmICghaW5zZXJ0Lmhhc093blByb3BlcnR5KHRva2VuKSkge1xuXHRcdFx0XHRcdFx0XHRyZXRbdG9rZW5dID0gZ3JhbW1hclt0b2tlbl07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIG9sZCA9IHJvb3RbaW5zaWRlXTtcblx0XHRcdFx0cm9vdFtpbnNpZGVdID0gcmV0O1xuXG5cdFx0XHRcdC8vIFVwZGF0ZSByZWZlcmVuY2VzIGluIG90aGVyIGxhbmd1YWdlIGRlZmluaXRpb25zXG5cdFx0XHRcdF8ubGFuZ3VhZ2VzLkRGUyhfLmxhbmd1YWdlcywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblx0XHRcdFx0XHRpZiAodmFsdWUgPT09IG9sZCAmJiBrZXkgIT0gaW5zaWRlKSB7XG5cdFx0XHRcdFx0XHR0aGlzW2tleV0gPSByZXQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gVHJhdmVyc2UgYSBsYW5ndWFnZSBkZWZpbml0aW9uIHdpdGggRGVwdGggRmlyc3QgU2VhcmNoXG5cdFx0XHRERlM6IGZ1bmN0aW9uIERGUyhvLCBjYWxsYmFjaywgdHlwZSwgdmlzaXRlZCkge1xuXHRcdFx0XHR2aXNpdGVkID0gdmlzaXRlZCB8fCB7fTtcblxuXHRcdFx0XHR2YXIgb2JqSWQgPSBfLnV0aWwub2JqSWQ7XG5cblx0XHRcdFx0Zm9yICh2YXIgaSBpbiBvKSB7XG5cdFx0XHRcdFx0aWYgKG8uaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwobywgaSwgb1tpXSwgdHlwZSB8fCBpKTtcblxuXHRcdFx0XHRcdFx0dmFyIHByb3BlcnR5ID0gb1tpXTtcblx0XHRcdFx0XHRcdHZhciBwcm9wZXJ0eVR5cGUgPSBfLnV0aWwudHlwZShwcm9wZXJ0eSk7XG5cblx0XHRcdFx0XHRcdGlmIChwcm9wZXJ0eVR5cGUgPT09ICdPYmplY3QnICYmICF2aXNpdGVkW29iaklkKHByb3BlcnR5KV0pIHtcblx0XHRcdFx0XHRcdFx0dmlzaXRlZFtvYmpJZChwcm9wZXJ0eSldID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0REZTKHByb3BlcnR5LCBjYWxsYmFjaywgbnVsbCwgdmlzaXRlZCk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHByb3BlcnR5VHlwZSA9PT0gJ0FycmF5JyAmJiAhdmlzaXRlZFtvYmpJZChwcm9wZXJ0eSldKSB7XG5cdFx0XHRcdFx0XHRcdHZpc2l0ZWRbb2JqSWQocHJvcGVydHkpXSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdERGUyhwcm9wZXJ0eSwgY2FsbGJhY2ssIGksIHZpc2l0ZWQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRwbHVnaW5zOiB7fSxcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgaXMgdGhlIG1vc3QgaGlnaC1sZXZlbCBmdW5jdGlvbiBpbiBQcmlzbeKAmXMgQVBJLlxuXHRcdCAqIEl0IGZldGNoZXMgYWxsIHRoZSBlbGVtZW50cyB0aGF0IGhhdmUgYSBgLmxhbmd1YWdlLXh4eHhgIGNsYXNzIGFuZCB0aGVuIGNhbGxzIHtAbGluayBQcmlzbS5oaWdobGlnaHRFbGVtZW50fSBvblxuXHRcdCAqIGVhY2ggb25lIG9mIHRoZW0uXG5cdFx0ICpcblx0XHQgKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gYFByaXNtLmhpZ2hsaWdodEFsbFVuZGVyKGRvY3VtZW50LCBhc3luYywgY2FsbGJhY2spYC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FzeW5jPWZhbHNlXSBTYW1lIGFzIGluIHtAbGluayBQcmlzbS5oaWdobGlnaHRBbGxVbmRlcn0uXG5cdFx0ICogQHBhcmFtIHtIaWdobGlnaHRDYWxsYmFja30gW2NhbGxiYWNrXSBTYW1lIGFzIGluIHtAbGluayBQcmlzbS5oaWdobGlnaHRBbGxVbmRlcn0uXG5cdFx0ICogQG1lbWJlcm9mIFByaXNtXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqL1xuXHRcdGhpZ2hsaWdodEFsbDogZnVuY3Rpb24gKGFzeW5jLCBjYWxsYmFjaykge1xuXHRcdFx0Xy5oaWdobGlnaHRBbGxVbmRlcihkb2N1bWVudCwgYXN5bmMsIGNhbGxiYWNrKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRmV0Y2hlcyBhbGwgdGhlIGRlc2NlbmRhbnRzIG9mIGBjb250YWluZXJgIHRoYXQgaGF2ZSBhIGAubGFuZ3VhZ2UteHh4eGAgY2xhc3MgYW5kIHRoZW4gY2FsbHNcblx0XHQgKiB7QGxpbmsgUHJpc20uaGlnaGxpZ2h0RWxlbWVudH0gb24gZWFjaCBvbmUgb2YgdGhlbS5cblx0XHQgKlxuXHRcdCAqIFRoZSBmb2xsb3dpbmcgaG9va3Mgd2lsbCBiZSBydW46XG5cdFx0ICogMS4gYGJlZm9yZS1oaWdobGlnaHRhbGxgXG5cdFx0ICogMi4gYGJlZm9yZS1hbGwtZWxlbWVudHMtaGlnaGxpZ2h0YFxuXHRcdCAqIDMuIEFsbCBob29rcyBvZiB7QGxpbmsgUHJpc20uaGlnaGxpZ2h0RWxlbWVudH0gZm9yIGVhY2ggZWxlbWVudC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7UGFyZW50Tm9kZX0gY29udGFpbmVyIFRoZSByb290IGVsZW1lbnQsIHdob3NlIGRlc2NlbmRhbnRzIHRoYXQgaGF2ZSBhIGAubGFuZ3VhZ2UteHh4eGAgY2xhc3Mgd2lsbCBiZSBoaWdobGlnaHRlZC5cblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFthc3luYz1mYWxzZV0gV2hldGhlciBlYWNoIGVsZW1lbnQgaXMgdG8gYmUgaGlnaGxpZ2h0ZWQgYXN5bmNocm9ub3VzbHkgdXNpbmcgV2ViIFdvcmtlcnMuXG5cdFx0ICogQHBhcmFtIHtIaWdobGlnaHRDYWxsYmFja30gW2NhbGxiYWNrXSBBbiBvcHRpb25hbCBjYWxsYmFjayB0byBiZSBpbnZva2VkIG9uIGVhY2ggZWxlbWVudCBhZnRlciBpdHMgaGlnaGxpZ2h0aW5nIGlzIGRvbmUuXG5cdFx0ICogQG1lbWJlcm9mIFByaXNtXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqL1xuXHRcdGhpZ2hsaWdodEFsbFVuZGVyOiBmdW5jdGlvbiAoY29udGFpbmVyLCBhc3luYywgY2FsbGJhY2spIHtcblx0XHRcdHZhciBlbnYgPSB7XG5cdFx0XHRcdGNhbGxiYWNrOiBjYWxsYmFjayxcblx0XHRcdFx0Y29udGFpbmVyOiBjb250YWluZXIsXG5cdFx0XHRcdHNlbGVjdG9yOiAnY29kZVtjbGFzcyo9XCJsYW5ndWFnZS1cIl0sIFtjbGFzcyo9XCJsYW5ndWFnZS1cIl0gY29kZSwgY29kZVtjbGFzcyo9XCJsYW5nLVwiXSwgW2NsYXNzKj1cImxhbmctXCJdIGNvZGUnXG5cdFx0XHR9O1xuXG5cdFx0XHRfLmhvb2tzLnJ1bignYmVmb3JlLWhpZ2hsaWdodGFsbCcsIGVudik7XG5cblx0XHRcdGVudi5lbGVtZW50cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShlbnYuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoZW52LnNlbGVjdG9yKSk7XG5cblx0XHRcdF8uaG9va3MucnVuKCdiZWZvcmUtYWxsLWVsZW1lbnRzLWhpZ2hsaWdodCcsIGVudik7XG5cblx0XHRcdGZvciAodmFyIGkgPSAwLCBlbGVtZW50OyAoZWxlbWVudCA9IGVudi5lbGVtZW50c1tpKytdKTspIHtcblx0XHRcdFx0Xy5oaWdobGlnaHRFbGVtZW50KGVsZW1lbnQsIGFzeW5jID09PSB0cnVlLCBlbnYuY2FsbGJhY2spO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBIaWdobGlnaHRzIHRoZSBjb2RlIGluc2lkZSBhIHNpbmdsZSBlbGVtZW50LlxuXHRcdCAqXG5cdFx0ICogVGhlIGZvbGxvd2luZyBob29rcyB3aWxsIGJlIHJ1bjpcblx0XHQgKiAxLiBgYmVmb3JlLXNhbml0eS1jaGVja2Bcblx0XHQgKiAyLiBgYmVmb3JlLWhpZ2hsaWdodGBcblx0XHQgKiAzLiBBbGwgaG9va3Mgb2Yge0BsaW5rIFByaXNtLmhpZ2hsaWdodH0uIFRoZXNlIGhvb2tzIHdpbGwgYmUgcnVuIGJ5IGFuIGFzeW5jaHJvbm91cyB3b3JrZXIgaWYgYGFzeW5jYCBpcyBgdHJ1ZWAuXG5cdFx0ICogNC4gYGJlZm9yZS1pbnNlcnRgXG5cdFx0ICogNS4gYGFmdGVyLWhpZ2hsaWdodGBcblx0XHQgKiA2LiBgY29tcGxldGVgXG5cdFx0ICpcblx0XHQgKiBTb21lIHRoZSBhYm92ZSBob29rcyB3aWxsIGJlIHNraXBwZWQgaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBjb250YWluIGFueSB0ZXh0IG9yIHRoZXJlIGlzIG5vIGdyYW1tYXIgbG9hZGVkIGZvclxuXHRcdCAqIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgY29udGFpbmluZyB0aGUgY29kZS5cblx0XHQgKiBJdCBtdXN0IGhhdmUgYSBjbGFzcyBvZiBgbGFuZ3VhZ2UteHh4eGAgdG8gYmUgcHJvY2Vzc2VkLCB3aGVyZSBgeHh4eGAgaXMgYSB2YWxpZCBsYW5ndWFnZSBpZGVudGlmaWVyLlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FzeW5jPWZhbHNlXSBXaGV0aGVyIHRoZSBlbGVtZW50IGlzIHRvIGJlIGhpZ2hsaWdodGVkIGFzeW5jaHJvbm91c2x5IHVzaW5nIFdlYiBXb3JrZXJzXG5cdFx0ICogdG8gaW1wcm92ZSBwZXJmb3JtYW5jZSBhbmQgYXZvaWQgYmxvY2tpbmcgdGhlIFVJIHdoZW4gaGlnaGxpZ2h0aW5nIHZlcnkgbGFyZ2UgY2h1bmtzIG9mIGNvZGUuIFRoaXMgb3B0aW9uIGlzXG5cdFx0ICogW2Rpc2FibGVkIGJ5IGRlZmF1bHRdKGh0dHBzOi8vcHJpc21qcy5jb20vZmFxLmh0bWwjd2h5LWlzLWFzeW5jaHJvbm91cy1oaWdobGlnaHRpbmctZGlzYWJsZWQtYnktZGVmYXVsdCkuXG5cdFx0ICpcblx0XHQgKiBOb3RlOiBBbGwgbGFuZ3VhZ2UgZGVmaW5pdGlvbnMgcmVxdWlyZWQgdG8gaGlnaGxpZ2h0IHRoZSBjb2RlIG11c3QgYmUgaW5jbHVkZWQgaW4gdGhlIG1haW4gYHByaXNtLmpzYCBmaWxlIGZvclxuXHRcdCAqIGFzeW5jaHJvbm91cyBoaWdobGlnaHRpbmcgdG8gd29yay4gWW91IGNhbiBidWlsZCB5b3VyIG93biBidW5kbGUgb24gdGhlXG5cdFx0ICogW0Rvd25sb2FkIHBhZ2VdKGh0dHBzOi8vcHJpc21qcy5jb20vZG93bmxvYWQuaHRtbCkuXG5cdFx0ICogQHBhcmFtIHtIaWdobGlnaHRDYWxsYmFja30gW2NhbGxiYWNrXSBBbiBvcHRpb25hbCBjYWxsYmFjayB0byBiZSBpbnZva2VkIGFmdGVyIHRoZSBoaWdobGlnaHRpbmcgaXMgZG9uZS5cblx0XHQgKiBNb3N0bHkgdXNlZnVsIHdoZW4gYGFzeW5jYCBpcyBgdHJ1ZWAsIHNpbmNlIGluIHRoYXQgY2FzZSwgdGhlIGhpZ2hsaWdodGluZyBpcyBkb25lIGFzeW5jaHJvbm91c2x5LlxuXHRcdCAqIEBtZW1iZXJvZiBQcmlzbVxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKi9cblx0XHRoaWdobGlnaHRFbGVtZW50OiBmdW5jdGlvbiAoZWxlbWVudCwgYXN5bmMsIGNhbGxiYWNrKSB7XG5cdFx0XHQvLyBGaW5kIGxhbmd1YWdlXG5cdFx0XHR2YXIgbGFuZ3VhZ2UgPSBfLnV0aWwuZ2V0TGFuZ3VhZ2UoZWxlbWVudCk7XG5cdFx0XHR2YXIgZ3JhbW1hciA9IF8ubGFuZ3VhZ2VzW2xhbmd1YWdlXTtcblxuXHRcdFx0Ly8gU2V0IGxhbmd1YWdlIG9uIHRoZSBlbGVtZW50LCBpZiBub3QgcHJlc2VudFxuXHRcdFx0Xy51dGlsLnNldExhbmd1YWdlKGVsZW1lbnQsIGxhbmd1YWdlKTtcblxuXHRcdFx0Ly8gU2V0IGxhbmd1YWdlIG9uIHRoZSBwYXJlbnQsIGZvciBzdHlsaW5nXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuXHRcdFx0aWYgKHBhcmVudCAmJiBwYXJlbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3ByZScpIHtcblx0XHRcdFx0Xy51dGlsLnNldExhbmd1YWdlKHBhcmVudCwgbGFuZ3VhZ2UpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgY29kZSA9IGVsZW1lbnQudGV4dENvbnRlbnQ7XG5cblx0XHRcdHZhciBlbnYgPSB7XG5cdFx0XHRcdGVsZW1lbnQ6IGVsZW1lbnQsXG5cdFx0XHRcdGxhbmd1YWdlOiBsYW5ndWFnZSxcblx0XHRcdFx0Z3JhbW1hcjogZ3JhbW1hcixcblx0XHRcdFx0Y29kZTogY29kZVxuXHRcdFx0fTtcblxuXHRcdFx0ZnVuY3Rpb24gaW5zZXJ0SGlnaGxpZ2h0ZWRDb2RlKGhpZ2hsaWdodGVkQ29kZSkge1xuXHRcdFx0XHRlbnYuaGlnaGxpZ2h0ZWRDb2RlID0gaGlnaGxpZ2h0ZWRDb2RlO1xuXG5cdFx0XHRcdF8uaG9va3MucnVuKCdiZWZvcmUtaW5zZXJ0JywgZW52KTtcblxuXHRcdFx0XHRlbnYuZWxlbWVudC5pbm5lckhUTUwgPSBlbnYuaGlnaGxpZ2h0ZWRDb2RlO1xuXG5cdFx0XHRcdF8uaG9va3MucnVuKCdhZnRlci1oaWdobGlnaHQnLCBlbnYpO1xuXHRcdFx0XHRfLmhvb2tzLnJ1bignY29tcGxldGUnLCBlbnYpO1xuXHRcdFx0XHRjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKGVudi5lbGVtZW50KTtcblx0XHRcdH1cblxuXHRcdFx0Xy5ob29rcy5ydW4oJ2JlZm9yZS1zYW5pdHktY2hlY2snLCBlbnYpO1xuXG5cdFx0XHQvLyBwbHVnaW5zIG1heSBjaGFuZ2UvYWRkIHRoZSBwYXJlbnQvZWxlbWVudFxuXHRcdFx0cGFyZW50ID0gZW52LmVsZW1lbnQucGFyZW50RWxlbWVudDtcblx0XHRcdGlmIChwYXJlbnQgJiYgcGFyZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdwcmUnICYmICFwYXJlbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG5cdFx0XHRcdHBhcmVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJzAnKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFlbnYuY29kZSkge1xuXHRcdFx0XHRfLmhvb2tzLnJ1bignY29tcGxldGUnLCBlbnYpO1xuXHRcdFx0XHRjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKGVudi5lbGVtZW50KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRfLmhvb2tzLnJ1bignYmVmb3JlLWhpZ2hsaWdodCcsIGVudik7XG5cblx0XHRcdGlmICghZW52LmdyYW1tYXIpIHtcblx0XHRcdFx0aW5zZXJ0SGlnaGxpZ2h0ZWRDb2RlKF8udXRpbC5lbmNvZGUoZW52LmNvZGUpKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoYXN5bmMgJiYgX3NlbGYuV29ya2VyKSB7XG5cdFx0XHRcdHZhciB3b3JrZXIgPSBuZXcgV29ya2VyKF8uZmlsZW5hbWUpO1xuXG5cdFx0XHRcdHdvcmtlci5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZ0KSB7XG5cdFx0XHRcdFx0aW5zZXJ0SGlnaGxpZ2h0ZWRDb2RlKGV2dC5kYXRhKTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHR3b3JrZXIucG9zdE1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkoe1xuXHRcdFx0XHRcdGxhbmd1YWdlOiBlbnYubGFuZ3VhZ2UsXG5cdFx0XHRcdFx0Y29kZTogZW52LmNvZGUsXG5cdFx0XHRcdFx0aW1tZWRpYXRlQ2xvc2U6IHRydWVcblx0XHRcdFx0fSkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aW5zZXJ0SGlnaGxpZ2h0ZWRDb2RlKF8uaGlnaGxpZ2h0KGVudi5jb2RlLCBlbnYuZ3JhbW1hciwgZW52Lmxhbmd1YWdlKSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIExvdy1sZXZlbCBmdW5jdGlvbiwgb25seSB1c2UgaWYgeW91IGtub3cgd2hhdCB5b3XigJlyZSBkb2luZy4gSXQgYWNjZXB0cyBhIHN0cmluZyBvZiB0ZXh0IGFzIGlucHV0XG5cdFx0ICogYW5kIHRoZSBsYW5ndWFnZSBkZWZpbml0aW9ucyB0byB1c2UsIGFuZCByZXR1cm5zIGEgc3RyaW5nIHdpdGggdGhlIEhUTUwgcHJvZHVjZWQuXG5cdFx0ICpcblx0XHQgKiBUaGUgZm9sbG93aW5nIGhvb2tzIHdpbGwgYmUgcnVuOlxuXHRcdCAqIDEuIGBiZWZvcmUtdG9rZW5pemVgXG5cdFx0ICogMi4gYGFmdGVyLXRva2VuaXplYFxuXHRcdCAqIDMuIGB3cmFwYDogT24gZWFjaCB7QGxpbmsgVG9rZW59LlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHRleHQgQSBzdHJpbmcgd2l0aCB0aGUgY29kZSB0byBiZSBoaWdobGlnaHRlZC5cblx0XHQgKiBAcGFyYW0ge0dyYW1tYXJ9IGdyYW1tYXIgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHRva2VucyB0byB1c2UuXG5cdFx0ICpcblx0XHQgKiBVc3VhbGx5IGEgbGFuZ3VhZ2UgZGVmaW5pdGlvbiBsaWtlIGBQcmlzbS5sYW5ndWFnZXMubWFya3VwYC5cblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2UgVGhlIG5hbWUgb2YgdGhlIGxhbmd1YWdlIGRlZmluaXRpb24gcGFzc2VkIHRvIGBncmFtbWFyYC5cblx0XHQgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgaGlnaGxpZ2h0ZWQgSFRNTC5cblx0XHQgKiBAbWVtYmVyb2YgUHJpc21cblx0XHQgKiBAcHVibGljXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBQcmlzbS5oaWdobGlnaHQoJ3ZhciBmb28gPSB0cnVlOycsIFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0LCAnamF2YXNjcmlwdCcpO1xuXHRcdCAqL1xuXHRcdGhpZ2hsaWdodDogZnVuY3Rpb24gKHRleHQsIGdyYW1tYXIsIGxhbmd1YWdlKSB7XG5cdFx0XHR2YXIgZW52ID0ge1xuXHRcdFx0XHRjb2RlOiB0ZXh0LFxuXHRcdFx0XHRncmFtbWFyOiBncmFtbWFyLFxuXHRcdFx0XHRsYW5ndWFnZTogbGFuZ3VhZ2Vcblx0XHRcdH07XG5cdFx0XHRfLmhvb2tzLnJ1bignYmVmb3JlLXRva2VuaXplJywgZW52KTtcblx0XHRcdGlmICghZW52LmdyYW1tYXIpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdUaGUgbGFuZ3VhZ2UgXCInICsgZW52Lmxhbmd1YWdlICsgJ1wiIGhhcyBubyBncmFtbWFyLicpO1xuXHRcdFx0fVxuXHRcdFx0ZW52LnRva2VucyA9IF8udG9rZW5pemUoZW52LmNvZGUsIGVudi5ncmFtbWFyKTtcblx0XHRcdF8uaG9va3MucnVuKCdhZnRlci10b2tlbml6ZScsIGVudik7XG5cdFx0XHRyZXR1cm4gVG9rZW4uc3RyaW5naWZ5KF8udXRpbC5lbmNvZGUoZW52LnRva2VucyksIGVudi5sYW5ndWFnZSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgaXMgdGhlIGhlYXJ0IG9mIFByaXNtLCBhbmQgdGhlIG1vc3QgbG93LWxldmVsIGZ1bmN0aW9uIHlvdSBjYW4gdXNlLiBJdCBhY2NlcHRzIGEgc3RyaW5nIG9mIHRleHQgYXMgaW5wdXRcblx0XHQgKiBhbmQgdGhlIGxhbmd1YWdlIGRlZmluaXRpb25zIHRvIHVzZSwgYW5kIHJldHVybnMgYW4gYXJyYXkgd2l0aCB0aGUgdG9rZW5pemVkIGNvZGUuXG5cdFx0ICpcblx0XHQgKiBXaGVuIHRoZSBsYW5ndWFnZSBkZWZpbml0aW9uIGluY2x1ZGVzIG5lc3RlZCB0b2tlbnMsIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgcmVjdXJzaXZlbHkgb24gZWFjaCBvZiB0aGVzZSB0b2tlbnMuXG5cdFx0ICpcblx0XHQgKiBUaGlzIG1ldGhvZCBjb3VsZCBiZSB1c2VmdWwgaW4gb3RoZXIgY29udGV4dHMgYXMgd2VsbCwgYXMgYSB2ZXJ5IGNydWRlIHBhcnNlci5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IEEgc3RyaW5nIHdpdGggdGhlIGNvZGUgdG8gYmUgaGlnaGxpZ2h0ZWQuXG5cdFx0ICogQHBhcmFtIHtHcmFtbWFyfSBncmFtbWFyIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSB0b2tlbnMgdG8gdXNlLlxuXHRcdCAqXG5cdFx0ICogVXN1YWxseSBhIGxhbmd1YWdlIGRlZmluaXRpb24gbGlrZSBgUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cGAuXG5cdFx0ICogQHJldHVybnMge1Rva2VuU3RyZWFtfSBBbiBhcnJheSBvZiBzdHJpbmdzIGFuZCB0b2tlbnMsIGEgdG9rZW4gc3RyZWFtLlxuXHRcdCAqIEBtZW1iZXJvZiBQcmlzbVxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIGxldCBjb2RlID0gYHZhciBmb28gPSAwO2A7XG5cdFx0ICogbGV0IHRva2VucyA9IFByaXNtLnRva2VuaXplKGNvZGUsIFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0KTtcblx0XHQgKiB0b2tlbnMuZm9yRWFjaCh0b2tlbiA9PiB7XG5cdFx0ICogICAgIGlmICh0b2tlbiBpbnN0YW5jZW9mIFByaXNtLlRva2VuICYmIHRva2VuLnR5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0ICogICAgICAgICBjb25zb2xlLmxvZyhgRm91bmQgbnVtZXJpYyBsaXRlcmFsOiAke3Rva2VuLmNvbnRlbnR9YCk7XG5cdFx0ICogICAgIH1cblx0XHQgKiB9KTtcblx0XHQgKi9cblx0XHR0b2tlbml6ZTogZnVuY3Rpb24gKHRleHQsIGdyYW1tYXIpIHtcblx0XHRcdHZhciByZXN0ID0gZ3JhbW1hci5yZXN0O1xuXHRcdFx0aWYgKHJlc3QpIHtcblx0XHRcdFx0Zm9yICh2YXIgdG9rZW4gaW4gcmVzdCkge1xuXHRcdFx0XHRcdGdyYW1tYXJbdG9rZW5dID0gcmVzdFt0b2tlbl07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgZ3JhbW1hci5yZXN0O1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdG9rZW5MaXN0ID0gbmV3IExpbmtlZExpc3QoKTtcblx0XHRcdGFkZEFmdGVyKHRva2VuTGlzdCwgdG9rZW5MaXN0LmhlYWQsIHRleHQpO1xuXG5cdFx0XHRtYXRjaEdyYW1tYXIodGV4dCwgdG9rZW5MaXN0LCBncmFtbWFyLCB0b2tlbkxpc3QuaGVhZCwgMCk7XG5cblx0XHRcdHJldHVybiB0b0FycmF5KHRva2VuTGlzdCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBuYW1lc3BhY2Vcblx0XHQgKiBAbWVtYmVyb2YgUHJpc21cblx0XHQgKiBAcHVibGljXG5cdFx0ICovXG5cdFx0aG9va3M6IHtcblx0XHRcdGFsbDoge30sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQWRkcyB0aGUgZ2l2ZW4gY2FsbGJhY2sgdG8gdGhlIGxpc3Qgb2YgY2FsbGJhY2tzIGZvciB0aGUgZ2l2ZW4gaG9vay5cblx0XHRcdCAqXG5cdFx0XHQgKiBUaGUgY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkIHdoZW4gdGhlIGhvb2sgaXQgaXMgcmVnaXN0ZXJlZCBmb3IgaXMgcnVuLlxuXHRcdFx0ICogSG9va3MgYXJlIHVzdWFsbHkgZGlyZWN0bHkgcnVuIGJ5IGEgaGlnaGxpZ2h0IGZ1bmN0aW9uIGJ1dCB5b3UgY2FuIGFsc28gcnVuIGhvb2tzIHlvdXJzZWxmLlxuXHRcdFx0ICpcblx0XHRcdCAqIE9uZSBjYWxsYmFjayBmdW5jdGlvbiBjYW4gYmUgcmVnaXN0ZXJlZCB0byBtdWx0aXBsZSBob29rcyBhbmQgdGhlIHNhbWUgaG9vayBtdWx0aXBsZSB0aW1lcy5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgaG9vay5cblx0XHRcdCAqIEBwYXJhbSB7SG9va0NhbGxiYWNrfSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggaXMgZ2l2ZW4gZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuXHRcdFx0ICogQHB1YmxpY1xuXHRcdFx0ICovXG5cdFx0XHRhZGQ6IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaykge1xuXHRcdFx0XHR2YXIgaG9va3MgPSBfLmhvb2tzLmFsbDtcblxuXHRcdFx0XHRob29rc1tuYW1lXSA9IGhvb2tzW25hbWVdIHx8IFtdO1xuXG5cdFx0XHRcdGhvb2tzW25hbWVdLnB1c2goY2FsbGJhY2spO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBSdW5zIGEgaG9vayBpbnZva2luZyBhbGwgcmVnaXN0ZXJlZCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuXHRcdFx0ICpcblx0XHRcdCAqIENhbGxiYWNrcyB3aWxsIGJlIGludm9rZWQgc3luY2hyb25vdXNseSBhbmQgaW4gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgd2VyZSByZWdpc3RlcmVkLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBob29rLlxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBlbnYgVGhlIGVudmlyb25tZW50IHZhcmlhYmxlcyBvZiB0aGUgaG9vayBwYXNzZWQgdG8gYWxsIGNhbGxiYWNrcyByZWdpc3RlcmVkLlxuXHRcdFx0ICogQHB1YmxpY1xuXHRcdFx0ICovXG5cdFx0XHRydW46IGZ1bmN0aW9uIChuYW1lLCBlbnYpIHtcblx0XHRcdFx0dmFyIGNhbGxiYWNrcyA9IF8uaG9va3MuYWxsW25hbWVdO1xuXG5cdFx0XHRcdGlmICghY2FsbGJhY2tzIHx8ICFjYWxsYmFja3MubGVuZ3RoKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGNhbGxiYWNrOyAoY2FsbGJhY2sgPSBjYWxsYmFja3NbaSsrXSk7KSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soZW52KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRUb2tlbjogVG9rZW5cblx0fTtcblx0X3NlbGYuUHJpc20gPSBfO1xuXG5cblx0Ly8gVHlwZXNjcmlwdCBub3RlOlxuXHQvLyBUaGUgZm9sbG93aW5nIGNhbiBiZSB1c2VkIHRvIGltcG9ydCB0aGUgVG9rZW4gdHlwZSBpbiBKU0RvYzpcblx0Ly9cblx0Ly8gICBAdHlwZWRlZiB7SW5zdGFuY2VUeXBlPGltcG9ydChcIi4vcHJpc20tY29yZVwiKVtcIlRva2VuXCJdPn0gVG9rZW5cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyB0b2tlbi5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgU2VlIHtAbGluayBUb2tlbiN0eXBlIHR5cGV9XG5cdCAqIEBwYXJhbSB7c3RyaW5nIHwgVG9rZW5TdHJlYW19IGNvbnRlbnQgU2VlIHtAbGluayBUb2tlbiNjb250ZW50IGNvbnRlbnR9XG5cdCAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBbYWxpYXNdIFRoZSBhbGlhcyhlcykgb2YgdGhlIHRva2VuLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW21hdGNoZWRTdHI9XCJcIl0gQSBjb3B5IG9mIHRoZSBmdWxsIHN0cmluZyB0aGlzIHRva2VuIHdhcyBjcmVhdGVkIGZyb20uXG5cdCAqIEBjbGFzc1xuXHQgKiBAZ2xvYmFsXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdGZ1bmN0aW9uIFRva2VuKHR5cGUsIGNvbnRlbnQsIGFsaWFzLCBtYXRjaGVkU3RyKSB7XG5cdFx0LyoqXG5cdFx0ICogVGhlIHR5cGUgb2YgdGhlIHRva2VuLlxuXHRcdCAqXG5cdFx0ICogVGhpcyBpcyB1c3VhbGx5IHRoZSBrZXkgb2YgYSBwYXR0ZXJuIGluIGEge0BsaW5rIEdyYW1tYXJ9LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKiBAc2VlIEdyYW1tYXJUb2tlblxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKi9cblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXHRcdC8qKlxuXHRcdCAqIFRoZSBzdHJpbmdzIG9yIHRva2VucyBjb250YWluZWQgYnkgdGhpcyB0b2tlbi5cblx0XHQgKlxuXHRcdCAqIFRoaXMgd2lsbCBiZSBhIHRva2VuIHN0cmVhbSBpZiB0aGUgcGF0dGVybiBtYXRjaGVkIGFsc28gZGVmaW5lZCBhbiBgaW5zaWRlYCBncmFtbWFyLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge3N0cmluZyB8IFRva2VuU3RyZWFtfVxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKi9cblx0XHR0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuXHRcdC8qKlxuXHRcdCAqIFRoZSBhbGlhcyhlcykgb2YgdGhlIHRva2VuLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge3N0cmluZ3xzdHJpbmdbXX1cblx0XHQgKiBAc2VlIEdyYW1tYXJUb2tlblxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKi9cblx0XHR0aGlzLmFsaWFzID0gYWxpYXM7XG5cdFx0Ly8gQ29weSBvZiB0aGUgZnVsbCBzdHJpbmcgdGhpcyB0b2tlbiB3YXMgY3JlYXRlZCBmcm9tXG5cdFx0dGhpcy5sZW5ndGggPSAobWF0Y2hlZFN0ciB8fCAnJykubGVuZ3RoIHwgMDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHRva2VuIHN0cmVhbSBpcyBhbiBhcnJheSBvZiBzdHJpbmdzIGFuZCB7QGxpbmsgVG9rZW4gVG9rZW59IG9iamVjdHMuXG5cdCAqXG5cdCAqIFRva2VuIHN0cmVhbXMgaGF2ZSB0byBmdWxmaWxsIGEgZmV3IHByb3BlcnRpZXMgdGhhdCBhcmUgYXNzdW1lZCBieSBtb3N0IGZ1bmN0aW9ucyAobW9zdGx5IGludGVybmFsIG9uZXMpIHRoYXQgcHJvY2Vzc1xuXHQgKiB0aGVtLlxuXHQgKlxuXHQgKiAxLiBObyBhZGphY2VudCBzdHJpbmdzLlxuXHQgKiAyLiBObyBlbXB0eSBzdHJpbmdzLlxuXHQgKlxuXHQgKiAgICBUaGUgb25seSBleGNlcHRpb24gaGVyZSBpcyB0aGUgdG9rZW4gc3RyZWFtIHRoYXQgb25seSBjb250YWlucyB0aGUgZW1wdHkgc3RyaW5nIGFuZCBub3RoaW5nIGVsc2UuXG5cdCAqXG5cdCAqIEB0eXBlZGVmIHtBcnJheTxzdHJpbmcgfCBUb2tlbj59IFRva2VuU3RyZWFtXG5cdCAqIEBnbG9iYWxcblx0ICogQHB1YmxpY1xuXHQgKi9cblxuXHQvKipcblx0ICogQ29udmVydHMgdGhlIGdpdmVuIHRva2VuIG9yIHRva2VuIHN0cmVhbSB0byBhbiBIVE1MIHJlcHJlc2VudGF0aW9uLlxuXHQgKlxuXHQgKiBUaGUgZm9sbG93aW5nIGhvb2tzIHdpbGwgYmUgcnVuOlxuXHQgKiAxLiBgd3JhcGA6IE9uIGVhY2gge0BsaW5rIFRva2VufS5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmcgfCBUb2tlbiB8IFRva2VuU3RyZWFtfSBvIFRoZSB0b2tlbiBvciB0b2tlbiBzdHJlYW0gdG8gYmUgY29udmVydGVkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2UgVGhlIG5hbWUgb2YgY3VycmVudCBsYW5ndWFnZS5cblx0ICogQHJldHVybnMge3N0cmluZ30gVGhlIEhUTUwgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRva2VuIG9yIHRva2VuIHN0cmVhbS5cblx0ICogQG1lbWJlcm9mIFRva2VuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdFRva2VuLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIHN0cmluZ2lmeShvLCBsYW5ndWFnZSkge1xuXHRcdGlmICh0eXBlb2YgbyA9PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuIG87XG5cdFx0fVxuXHRcdGlmIChBcnJheS5pc0FycmF5KG8pKSB7XG5cdFx0XHR2YXIgcyA9ICcnO1xuXHRcdFx0by5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdHMgKz0gc3RyaW5naWZ5KGUsIGxhbmd1YWdlKTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHM7XG5cdFx0fVxuXG5cdFx0dmFyIGVudiA9IHtcblx0XHRcdHR5cGU6IG8udHlwZSxcblx0XHRcdGNvbnRlbnQ6IHN0cmluZ2lmeShvLmNvbnRlbnQsIGxhbmd1YWdlKSxcblx0XHRcdHRhZzogJ3NwYW4nLFxuXHRcdFx0Y2xhc3NlczogWyd0b2tlbicsIG8udHlwZV0sXG5cdFx0XHRhdHRyaWJ1dGVzOiB7fSxcblx0XHRcdGxhbmd1YWdlOiBsYW5ndWFnZVxuXHRcdH07XG5cblx0XHR2YXIgYWxpYXNlcyA9IG8uYWxpYXM7XG5cdFx0aWYgKGFsaWFzZXMpIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGFsaWFzZXMpKSB7XG5cdFx0XHRcdEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGVudi5jbGFzc2VzLCBhbGlhc2VzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVudi5jbGFzc2VzLnB1c2goYWxpYXNlcyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Xy5ob29rcy5ydW4oJ3dyYXAnLCBlbnYpO1xuXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSAnJztcblx0XHRmb3IgKHZhciBuYW1lIGluIGVudi5hdHRyaWJ1dGVzKSB7XG5cdFx0XHRhdHRyaWJ1dGVzICs9ICcgJyArIG5hbWUgKyAnPVwiJyArIChlbnYuYXR0cmlidXRlc1tuYW1lXSB8fCAnJykucmVwbGFjZSgvXCIvZywgJyZxdW90OycpICsgJ1wiJztcblx0XHR9XG5cblx0XHRyZXR1cm4gJzwnICsgZW52LnRhZyArICcgY2xhc3M9XCInICsgZW52LmNsYXNzZXMuam9pbignICcpICsgJ1wiJyArIGF0dHJpYnV0ZXMgKyAnPicgKyBlbnYuY29udGVudCArICc8LycgKyBlbnYudGFnICsgJz4nO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1JlZ0V4cH0gcGF0dGVyblxuXHQgKiBAcGFyYW0ge251bWJlcn0gcG9zXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9va2JlaGluZFxuXHQgKiBAcmV0dXJucyB7UmVnRXhwRXhlY0FycmF5IHwgbnVsbH1cblx0ICovXG5cdGZ1bmN0aW9uIG1hdGNoUGF0dGVybihwYXR0ZXJuLCBwb3MsIHRleHQsIGxvb2tiZWhpbmQpIHtcblx0XHRwYXR0ZXJuLmxhc3RJbmRleCA9IHBvcztcblx0XHR2YXIgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWModGV4dCk7XG5cdFx0aWYgKG1hdGNoICYmIGxvb2tiZWhpbmQgJiYgbWF0Y2hbMV0pIHtcblx0XHRcdC8vIGNoYW5nZSB0aGUgbWF0Y2ggdG8gcmVtb3ZlIHRoZSB0ZXh0IG1hdGNoZWQgYnkgdGhlIFByaXNtIGxvb2tiZWhpbmQgZ3JvdXBcblx0XHRcdHZhciBsb29rYmVoaW5kTGVuZ3RoID0gbWF0Y2hbMV0ubGVuZ3RoO1xuXHRcdFx0bWF0Y2guaW5kZXggKz0gbG9va2JlaGluZExlbmd0aDtcblx0XHRcdG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UobG9va2JlaGluZExlbmd0aCk7XG5cdFx0fVxuXHRcdHJldHVybiBtYXRjaDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuXHQgKiBAcGFyYW0ge0xpbmtlZExpc3Q8c3RyaW5nIHwgVG9rZW4+fSB0b2tlbkxpc3Rcblx0ICogQHBhcmFtIHthbnl9IGdyYW1tYXJcblx0ICogQHBhcmFtIHtMaW5rZWRMaXN0Tm9kZTxzdHJpbmcgfCBUb2tlbj59IHN0YXJ0Tm9kZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRQb3Ncblx0ICogQHBhcmFtIHtSZW1hdGNoT3B0aW9uc30gW3JlbWF0Y2hdXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKlxuXHQgKiBAdHlwZWRlZiBSZW1hdGNoT3B0aW9uc1xuXHQgKiBAcHJvcGVydHkge3N0cmluZ30gY2F1c2Vcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IHJlYWNoXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXRjaEdyYW1tYXIodGV4dCwgdG9rZW5MaXN0LCBncmFtbWFyLCBzdGFydE5vZGUsIHN0YXJ0UG9zLCByZW1hdGNoKSB7XG5cdFx0Zm9yICh2YXIgdG9rZW4gaW4gZ3JhbW1hcikge1xuXHRcdFx0aWYgKCFncmFtbWFyLmhhc093blByb3BlcnR5KHRva2VuKSB8fCAhZ3JhbW1hclt0b2tlbl0pIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBwYXR0ZXJucyA9IGdyYW1tYXJbdG9rZW5dO1xuXHRcdFx0cGF0dGVybnMgPSBBcnJheS5pc0FycmF5KHBhdHRlcm5zKSA/IHBhdHRlcm5zIDogW3BhdHRlcm5zXTtcblxuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBwYXR0ZXJucy5sZW5ndGg7ICsraikge1xuXHRcdFx0XHRpZiAocmVtYXRjaCAmJiByZW1hdGNoLmNhdXNlID09IHRva2VuICsgJywnICsgaikge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBwYXR0ZXJuT2JqID0gcGF0dGVybnNbal07XG5cdFx0XHRcdHZhciBpbnNpZGUgPSBwYXR0ZXJuT2JqLmluc2lkZTtcblx0XHRcdFx0dmFyIGxvb2tiZWhpbmQgPSAhIXBhdHRlcm5PYmoubG9va2JlaGluZDtcblx0XHRcdFx0dmFyIGdyZWVkeSA9ICEhcGF0dGVybk9iai5ncmVlZHk7XG5cdFx0XHRcdHZhciBhbGlhcyA9IHBhdHRlcm5PYmouYWxpYXM7XG5cblx0XHRcdFx0aWYgKGdyZWVkeSAmJiAhcGF0dGVybk9iai5wYXR0ZXJuLmdsb2JhbCkge1xuXHRcdFx0XHRcdC8vIFdpdGhvdXQgdGhlIGdsb2JhbCBmbGFnLCBsYXN0SW5kZXggd29uJ3Qgd29ya1xuXHRcdFx0XHRcdHZhciBmbGFncyA9IHBhdHRlcm5PYmoucGF0dGVybi50b1N0cmluZygpLm1hdGNoKC9baW1zdXldKiQvKVswXTtcblx0XHRcdFx0XHRwYXR0ZXJuT2JqLnBhdHRlcm4gPSBSZWdFeHAocGF0dGVybk9iai5wYXR0ZXJuLnNvdXJjZSwgZmxhZ3MgKyAnZycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0LyoqIEB0eXBlIHtSZWdFeHB9ICovXG5cdFx0XHRcdHZhciBwYXR0ZXJuID0gcGF0dGVybk9iai5wYXR0ZXJuIHx8IHBhdHRlcm5PYmo7XG5cblx0XHRcdFx0Zm9yICggLy8gaXRlcmF0ZSB0aGUgdG9rZW4gbGlzdCBhbmQga2VlcCB0cmFjayBvZiB0aGUgY3VycmVudCB0b2tlbi9zdHJpbmcgcG9zaXRpb25cblx0XHRcdFx0XHR2YXIgY3VycmVudE5vZGUgPSBzdGFydE5vZGUubmV4dCwgcG9zID0gc3RhcnRQb3M7XG5cdFx0XHRcdFx0Y3VycmVudE5vZGUgIT09IHRva2VuTGlzdC50YWlsO1xuXHRcdFx0XHRcdHBvcyArPSBjdXJyZW50Tm9kZS52YWx1ZS5sZW5ndGgsIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUubmV4dFxuXHRcdFx0XHQpIHtcblxuXHRcdFx0XHRcdGlmIChyZW1hdGNoICYmIHBvcyA+PSByZW1hdGNoLnJlYWNoKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXIgc3RyID0gY3VycmVudE5vZGUudmFsdWU7XG5cblx0XHRcdFx0XHRpZiAodG9rZW5MaXN0Lmxlbmd0aCA+IHRleHQubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHQvLyBTb21ldGhpbmcgd2VudCB0ZXJyaWJseSB3cm9uZywgQUJPUlQsIEFCT1JUIVxuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChzdHIgaW5zdGFuY2VvZiBUb2tlbikge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIHJlbW92ZUNvdW50ID0gMTsgLy8gdGhpcyBpcyB0aGUgdG8gcGFyYW1ldGVyIG9mIHJlbW92ZUJldHdlZW5cblx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cblx0XHRcdFx0XHRpZiAoZ3JlZWR5KSB7XG5cdFx0XHRcdFx0XHRtYXRjaCA9IG1hdGNoUGF0dGVybihwYXR0ZXJuLCBwb3MsIHRleHQsIGxvb2tiZWhpbmQpO1xuXHRcdFx0XHRcdFx0aWYgKCFtYXRjaCB8fCBtYXRjaC5pbmRleCA+PSB0ZXh0Lmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0dmFyIGZyb20gPSBtYXRjaC5pbmRleDtcblx0XHRcdFx0XHRcdHZhciB0byA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuXHRcdFx0XHRcdFx0dmFyIHAgPSBwb3M7XG5cblx0XHRcdFx0XHRcdC8vIGZpbmQgdGhlIG5vZGUgdGhhdCBjb250YWlucyB0aGUgbWF0Y2hcblx0XHRcdFx0XHRcdHAgKz0gY3VycmVudE5vZGUudmFsdWUubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKGZyb20gPj0gcCkge1xuXHRcdFx0XHRcdFx0XHRjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLm5leHQ7XG5cdFx0XHRcdFx0XHRcdHAgKz0gY3VycmVudE5vZGUudmFsdWUubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gYWRqdXN0IHBvcyAoYW5kIHApXG5cdFx0XHRcdFx0XHRwIC09IGN1cnJlbnROb2RlLnZhbHVlLmxlbmd0aDtcblx0XHRcdFx0XHRcdHBvcyA9IHA7XG5cblx0XHRcdFx0XHRcdC8vIHRoZSBjdXJyZW50IG5vZGUgaXMgYSBUb2tlbiwgdGhlbiB0aGUgbWF0Y2ggc3RhcnRzIGluc2lkZSBhbm90aGVyIFRva2VuLCB3aGljaCBpcyBpbnZhbGlkXG5cdFx0XHRcdFx0XHRpZiAoY3VycmVudE5vZGUudmFsdWUgaW5zdGFuY2VvZiBUb2tlbikge1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gZmluZCB0aGUgbGFzdCBub2RlIHdoaWNoIGlzIGFmZmVjdGVkIGJ5IHRoaXMgbWF0Y2hcblx0XHRcdFx0XHRcdGZvciAoXG5cdFx0XHRcdFx0XHRcdHZhciBrID0gY3VycmVudE5vZGU7XG5cdFx0XHRcdFx0XHRcdGsgIT09IHRva2VuTGlzdC50YWlsICYmIChwIDwgdG8gfHwgdHlwZW9mIGsudmFsdWUgPT09ICdzdHJpbmcnKTtcblx0XHRcdFx0XHRcdFx0ayA9IGsubmV4dFxuXHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdHJlbW92ZUNvdW50Kys7XG5cdFx0XHRcdFx0XHRcdHAgKz0gay52YWx1ZS5sZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZW1vdmVDb3VudC0tO1xuXG5cdFx0XHRcdFx0XHQvLyByZXBsYWNlIHdpdGggdGhlIG5ldyBtYXRjaFxuXHRcdFx0XHRcdFx0c3RyID0gdGV4dC5zbGljZShwb3MsIHApO1xuXHRcdFx0XHRcdFx0bWF0Y2guaW5kZXggLT0gcG9zO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRtYXRjaCA9IG1hdGNoUGF0dGVybihwYXR0ZXJuLCAwLCBzdHIsIGxvb2tiZWhpbmQpO1xuXHRcdFx0XHRcdFx0aWYgKCFtYXRjaCkge1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cdFx0XHRcdFx0dmFyIGZyb20gPSBtYXRjaC5pbmRleDtcblx0XHRcdFx0XHR2YXIgbWF0Y2hTdHIgPSBtYXRjaFswXTtcblx0XHRcdFx0XHR2YXIgYmVmb3JlID0gc3RyLnNsaWNlKDAsIGZyb20pO1xuXHRcdFx0XHRcdHZhciBhZnRlciA9IHN0ci5zbGljZShmcm9tICsgbWF0Y2hTdHIubGVuZ3RoKTtcblxuXHRcdFx0XHRcdHZhciByZWFjaCA9IHBvcyArIHN0ci5sZW5ndGg7XG5cdFx0XHRcdFx0aWYgKHJlbWF0Y2ggJiYgcmVhY2ggPiByZW1hdGNoLnJlYWNoKSB7XG5cdFx0XHRcdFx0XHRyZW1hdGNoLnJlYWNoID0gcmVhY2g7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIHJlbW92ZUZyb20gPSBjdXJyZW50Tm9kZS5wcmV2O1xuXG5cdFx0XHRcdFx0aWYgKGJlZm9yZSkge1xuXHRcdFx0XHRcdFx0cmVtb3ZlRnJvbSA9IGFkZEFmdGVyKHRva2VuTGlzdCwgcmVtb3ZlRnJvbSwgYmVmb3JlKTtcblx0XHRcdFx0XHRcdHBvcyArPSBiZWZvcmUubGVuZ3RoO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJlbW92ZVJhbmdlKHRva2VuTGlzdCwgcmVtb3ZlRnJvbSwgcmVtb3ZlQ291bnQpO1xuXG5cdFx0XHRcdFx0dmFyIHdyYXBwZWQgPSBuZXcgVG9rZW4odG9rZW4sIGluc2lkZSA/IF8udG9rZW5pemUobWF0Y2hTdHIsIGluc2lkZSkgOiBtYXRjaFN0ciwgYWxpYXMsIG1hdGNoU3RyKTtcblx0XHRcdFx0XHRjdXJyZW50Tm9kZSA9IGFkZEFmdGVyKHRva2VuTGlzdCwgcmVtb3ZlRnJvbSwgd3JhcHBlZCk7XG5cblx0XHRcdFx0XHRpZiAoYWZ0ZXIpIHtcblx0XHRcdFx0XHRcdGFkZEFmdGVyKHRva2VuTGlzdCwgY3VycmVudE5vZGUsIGFmdGVyKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAocmVtb3ZlQ291bnQgPiAxKSB7XG5cdFx0XHRcdFx0XHQvLyBhdCBsZWFzdCBvbmUgVG9rZW4gb2JqZWN0IHdhcyByZW1vdmVkLCBzbyB3ZSBoYXZlIHRvIGRvIHNvbWUgcmVtYXRjaGluZ1xuXHRcdFx0XHRcdFx0Ly8gdGhpcyBjYW4gb25seSBoYXBwZW4gaWYgdGhlIGN1cnJlbnQgcGF0dGVybiBpcyBncmVlZHlcblxuXHRcdFx0XHRcdFx0LyoqIEB0eXBlIHtSZW1hdGNoT3B0aW9uc30gKi9cblx0XHRcdFx0XHRcdHZhciBuZXN0ZWRSZW1hdGNoID0ge1xuXHRcdFx0XHRcdFx0XHRjYXVzZTogdG9rZW4gKyAnLCcgKyBqLFxuXHRcdFx0XHRcdFx0XHRyZWFjaDogcmVhY2hcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRtYXRjaEdyYW1tYXIodGV4dCwgdG9rZW5MaXN0LCBncmFtbWFyLCBjdXJyZW50Tm9kZS5wcmV2LCBwb3MsIG5lc3RlZFJlbWF0Y2gpO1xuXG5cdFx0XHRcdFx0XHQvLyB0aGUgcmVhY2ggbWlnaHQgaGF2ZSBiZWVuIGV4dGVuZGVkIGJlY2F1c2Ugb2YgdGhlIHJlbWF0Y2hpbmdcblx0XHRcdFx0XHRcdGlmIChyZW1hdGNoICYmIG5lc3RlZFJlbWF0Y2gucmVhY2ggPiByZW1hdGNoLnJlYWNoKSB7XG5cdFx0XHRcdFx0XHRcdHJlbWF0Y2gucmVhY2ggPSBuZXN0ZWRSZW1hdGNoLnJlYWNoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZWRlZiBMaW5rZWRMaXN0Tm9kZVxuXHQgKiBAcHJvcGVydHkge1R9IHZhbHVlXG5cdCAqIEBwcm9wZXJ0eSB7TGlua2VkTGlzdE5vZGU8VD4gfCBudWxsfSBwcmV2IFRoZSBwcmV2aW91cyBub2RlLlxuXHQgKiBAcHJvcGVydHkge0xpbmtlZExpc3ROb2RlPFQ+IHwgbnVsbH0gbmV4dCBUaGUgbmV4dCBub2RlLlxuXHQgKiBAdGVtcGxhdGUgVFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblxuXHQvKipcblx0ICogQHRlbXBsYXRlIFRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIExpbmtlZExpc3QoKSB7XG5cdFx0LyoqIEB0eXBlIHtMaW5rZWRMaXN0Tm9kZTxUPn0gKi9cblx0XHR2YXIgaGVhZCA9IHsgdmFsdWU6IG51bGwsIHByZXY6IG51bGwsIG5leHQ6IG51bGwgfTtcblx0XHQvKiogQHR5cGUge0xpbmtlZExpc3ROb2RlPFQ+fSAqL1xuXHRcdHZhciB0YWlsID0geyB2YWx1ZTogbnVsbCwgcHJldjogaGVhZCwgbmV4dDogbnVsbCB9O1xuXHRcdGhlYWQubmV4dCA9IHRhaWw7XG5cblx0XHQvKiogQHR5cGUge0xpbmtlZExpc3ROb2RlPFQ+fSAqL1xuXHRcdHRoaXMuaGVhZCA9IGhlYWQ7XG5cdFx0LyoqIEB0eXBlIHtMaW5rZWRMaXN0Tm9kZTxUPn0gKi9cblx0XHR0aGlzLnRhaWwgPSB0YWlsO1xuXHRcdHRoaXMubGVuZ3RoID0gMDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgbmV3IG5vZGUgd2l0aCB0aGUgZ2l2ZW4gdmFsdWUgdG8gdGhlIGxpc3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TGlua2VkTGlzdDxUPn0gbGlzdFxuXHQgKiBAcGFyYW0ge0xpbmtlZExpc3ROb2RlPFQ+fSBub2RlXG5cdCAqIEBwYXJhbSB7VH0gdmFsdWVcblx0ICogQHJldHVybnMge0xpbmtlZExpc3ROb2RlPFQ+fSBUaGUgYWRkZWQgbm9kZS5cblx0ICogQHRlbXBsYXRlIFRcblx0ICovXG5cdGZ1bmN0aW9uIGFkZEFmdGVyKGxpc3QsIG5vZGUsIHZhbHVlKSB7XG5cdFx0Ly8gYXNzdW1lcyB0aGF0IG5vZGUgIT0gbGlzdC50YWlsICYmIHZhbHVlcy5sZW5ndGggPj0gMFxuXHRcdHZhciBuZXh0ID0gbm9kZS5uZXh0O1xuXG5cdFx0dmFyIG5ld05vZGUgPSB7IHZhbHVlOiB2YWx1ZSwgcHJldjogbm9kZSwgbmV4dDogbmV4dCB9O1xuXHRcdG5vZGUubmV4dCA9IG5ld05vZGU7XG5cdFx0bmV4dC5wcmV2ID0gbmV3Tm9kZTtcblx0XHRsaXN0Lmxlbmd0aCsrO1xuXG5cdFx0cmV0dXJuIG5ld05vZGU7XG5cdH1cblx0LyoqXG5cdCAqIFJlbW92ZXMgYGNvdW50YCBub2RlcyBhZnRlciB0aGUgZ2l2ZW4gbm9kZS4gVGhlIGdpdmVuIG5vZGUgd2lsbCBub3QgYmUgcmVtb3ZlZC5cblx0ICpcblx0ICogQHBhcmFtIHtMaW5rZWRMaXN0PFQ+fSBsaXN0XG5cdCAqIEBwYXJhbSB7TGlua2VkTGlzdE5vZGU8VD59IG5vZGVcblx0ICogQHBhcmFtIHtudW1iZXJ9IGNvdW50XG5cdCAqIEB0ZW1wbGF0ZSBUXG5cdCAqL1xuXHRmdW5jdGlvbiByZW1vdmVSYW5nZShsaXN0LCBub2RlLCBjb3VudCkge1xuXHRcdHZhciBuZXh0ID0gbm9kZS5uZXh0O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQgJiYgbmV4dCAhPT0gbGlzdC50YWlsOyBpKyspIHtcblx0XHRcdG5leHQgPSBuZXh0Lm5leHQ7XG5cdFx0fVxuXHRcdG5vZGUubmV4dCA9IG5leHQ7XG5cdFx0bmV4dC5wcmV2ID0gbm9kZTtcblx0XHRsaXN0Lmxlbmd0aCAtPSBpO1xuXHR9XG5cdC8qKlxuXHQgKiBAcGFyYW0ge0xpbmtlZExpc3Q8VD59IGxpc3Rcblx0ICogQHJldHVybnMge1RbXX1cblx0ICogQHRlbXBsYXRlIFRcblx0ICovXG5cdGZ1bmN0aW9uIHRvQXJyYXkobGlzdCkge1xuXHRcdHZhciBhcnJheSA9IFtdO1xuXHRcdHZhciBub2RlID0gbGlzdC5oZWFkLm5leHQ7XG5cdFx0d2hpbGUgKG5vZGUgIT09IGxpc3QudGFpbCkge1xuXHRcdFx0YXJyYXkucHVzaChub2RlLnZhbHVlKTtcblx0XHRcdG5vZGUgPSBub2RlLm5leHQ7XG5cdFx0fVxuXHRcdHJldHVybiBhcnJheTtcblx0fVxuXG5cblx0aWYgKCFfc2VsZi5kb2N1bWVudCkge1xuXHRcdGlmICghX3NlbGYuYWRkRXZlbnRMaXN0ZW5lcikge1xuXHRcdFx0Ly8gaW4gTm9kZS5qc1xuXHRcdFx0cmV0dXJuIF87XG5cdFx0fVxuXG5cdFx0aWYgKCFfLmRpc2FibGVXb3JrZXJNZXNzYWdlSGFuZGxlcikge1xuXHRcdFx0Ly8gSW4gd29ya2VyXG5cdFx0XHRfc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2dCkge1xuXHRcdFx0XHR2YXIgbWVzc2FnZSA9IEpTT04ucGFyc2UoZXZ0LmRhdGEpO1xuXHRcdFx0XHR2YXIgbGFuZyA9IG1lc3NhZ2UubGFuZ3VhZ2U7XG5cdFx0XHRcdHZhciBjb2RlID0gbWVzc2FnZS5jb2RlO1xuXHRcdFx0XHR2YXIgaW1tZWRpYXRlQ2xvc2UgPSBtZXNzYWdlLmltbWVkaWF0ZUNsb3NlO1xuXG5cdFx0XHRcdF9zZWxmLnBvc3RNZXNzYWdlKF8uaGlnaGxpZ2h0KGNvZGUsIF8ubGFuZ3VhZ2VzW2xhbmddLCBsYW5nKSk7XG5cdFx0XHRcdGlmIChpbW1lZGlhdGVDbG9zZSkge1xuXHRcdFx0XHRcdF9zZWxmLmNsb3NlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIGZhbHNlKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gXztcblx0fVxuXG5cdC8vIEdldCBjdXJyZW50IHNjcmlwdCBhbmQgaGlnaGxpZ2h0XG5cdHZhciBzY3JpcHQgPSBfLnV0aWwuY3VycmVudFNjcmlwdCgpO1xuXG5cdGlmIChzY3JpcHQpIHtcblx0XHRfLmZpbGVuYW1lID0gc2NyaXB0LnNyYztcblxuXHRcdGlmIChzY3JpcHQuaGFzQXR0cmlidXRlKCdkYXRhLW1hbnVhbCcpKSB7XG5cdFx0XHRfLm1hbnVhbCA9IHRydWU7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gaGlnaGxpZ2h0QXV0b21hdGljYWxseUNhbGxiYWNrKCkge1xuXHRcdGlmICghXy5tYW51YWwpIHtcblx0XHRcdF8uaGlnaGxpZ2h0QWxsKCk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCFfLm1hbnVhbCkge1xuXHRcdC8vIElmIHRoZSBkb2N1bWVudCBzdGF0ZSBpcyBcImxvYWRpbmdcIiwgdGhlbiB3ZSdsbCB1c2UgRE9NQ29udGVudExvYWRlZC5cblx0XHQvLyBJZiB0aGUgZG9jdW1lbnQgc3RhdGUgaXMgXCJpbnRlcmFjdGl2ZVwiIGFuZCB0aGUgcHJpc20uanMgc2NyaXB0IGlzIGRlZmVycmVkLCB0aGVuIHdlJ2xsIGFsc28gdXNlIHRoZVxuXHRcdC8vIERPTUNvbnRlbnRMb2FkZWQgZXZlbnQgYmVjYXVzZSB0aGVyZSBtaWdodCBiZSBzb21lIHBsdWdpbnMgb3IgbGFuZ3VhZ2VzIHdoaWNoIGhhdmUgYWxzbyBiZWVuIGRlZmVycmVkIGFuZCB0aGV5XG5cdFx0Ly8gbWlnaHQgdGFrZSBsb25nZXIgb25lIGFuaW1hdGlvbiBmcmFtZSB0byBleGVjdXRlIHdoaWNoIGNhbiBjcmVhdGUgYSByYWNlIGNvbmRpdGlvbiB3aGVyZSBvbmx5IHNvbWUgcGx1Z2lucyBoYXZlXG5cdFx0Ly8gYmVlbiBsb2FkZWQgd2hlbiBQcmlzbS5oaWdobGlnaHRBbGwoKSBpcyBleGVjdXRlZCwgZGVwZW5kaW5nIG9uIGhvdyBmYXN0IHJlc291cmNlcyBhcmUgbG9hZGVkLlxuXHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vUHJpc21KUy9wcmlzbS9pc3N1ZXMvMjEwMlxuXHRcdHZhciByZWFkeVN0YXRlID0gZG9jdW1lbnQucmVhZHlTdGF0ZTtcblx0XHRpZiAocmVhZHlTdGF0ZSA9PT0gJ2xvYWRpbmcnIHx8IHJlYWR5U3RhdGUgPT09ICdpbnRlcmFjdGl2ZScgJiYgc2NyaXB0ICYmIHNjcmlwdC5kZWZlcikge1xuXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGhpZ2hsaWdodEF1dG9tYXRpY2FsbHlDYWxsYmFjayk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICh3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG5cdFx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoaGlnaGxpZ2h0QXV0b21hdGljYWxseUNhbGxiYWNrKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KGhpZ2hsaWdodEF1dG9tYXRpY2FsbHlDYWxsYmFjaywgMTYpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBfO1xuXG59KF9zZWxmKSk7XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRtb2R1bGUuZXhwb3J0cyA9IFByaXNtO1xufVxuXG4vLyBoYWNrIGZvciBjb21wb25lbnRzIHRvIHdvcmsgY29ycmVjdGx5IGluIG5vZGUuanNcbmlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuXHRnbG9iYWwuUHJpc20gPSBQcmlzbTtcbn1cblxuLy8gc29tZSBhZGRpdGlvbmFsIGRvY3VtZW50YXRpb24vdHlwZXNcblxuLyoqXG4gKiBUaGUgZXhwYW5zaW9uIG9mIGEgc2ltcGxlIGBSZWdFeHBgIGxpdGVyYWwgdG8gc3VwcG9ydCBhZGRpdGlvbmFsIHByb3BlcnRpZXMuXG4gKlxuICogQHR5cGVkZWYgR3JhbW1hclRva2VuXG4gKiBAcHJvcGVydHkge1JlZ0V4cH0gcGF0dGVybiBUaGUgcmVndWxhciBleHByZXNzaW9uIG9mIHRoZSB0b2tlbi5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2xvb2tiZWhpbmQ9ZmFsc2VdIElmIGB0cnVlYCwgdGhlbiB0aGUgZmlyc3QgY2FwdHVyaW5nIGdyb3VwIG9mIGBwYXR0ZXJuYCB3aWxsIChlZmZlY3RpdmVseSlcbiAqIGJlaGF2ZSBhcyBhIGxvb2tiZWhpbmQgZ3JvdXAgbWVhbmluZyB0aGF0IHRoZSBjYXB0dXJlZCB0ZXh0IHdpbGwgbm90IGJlIHBhcnQgb2YgdGhlIG1hdGNoZWQgdGV4dCBvZiB0aGUgbmV3IHRva2VuLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbZ3JlZWR5PWZhbHNlXSBXaGV0aGVyIHRoZSB0b2tlbiBpcyBncmVlZHkuXG4gKiBAcHJvcGVydHkge3N0cmluZ3xzdHJpbmdbXX0gW2FsaWFzXSBBbiBvcHRpb25hbCBhbGlhcyBvciBsaXN0IG9mIGFsaWFzZXMuXG4gKiBAcHJvcGVydHkge0dyYW1tYXJ9IFtpbnNpZGVdIFRoZSBuZXN0ZWQgZ3JhbW1hciBvZiB0aGlzIHRva2VuLlxuICpcbiAqIFRoZSBgaW5zaWRlYCBncmFtbWFyIHdpbGwgYmUgdXNlZCB0byB0b2tlbml6ZSB0aGUgdGV4dCB2YWx1ZSBvZiBlYWNoIHRva2VuIG9mIHRoaXMga2luZC5cbiAqXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIG1ha2UgbmVzdGVkIGFuZCBldmVuIHJlY3Vyc2l2ZSBsYW5ndWFnZSBkZWZpbml0aW9ucy5cbiAqXG4gKiBOb3RlOiBUaGlzIGNhbiBjYXVzZSBpbmZpbml0ZSByZWN1cnNpb24uIEJlIGNhcmVmdWwgd2hlbiB5b3UgZW1iZWQgZGlmZmVyZW50IGxhbmd1YWdlcyBvciBldmVuIHRoZSBzYW1lIGxhbmd1YWdlIGludG9cbiAqIGVhY2ggYW5vdGhlci5cbiAqIEBnbG9iYWxcbiAqIEBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIEdyYW1tYXJcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBSZWdFeHAgfCBHcmFtbWFyVG9rZW4gfCBBcnJheTxSZWdFeHAgfCBHcmFtbWFyVG9rZW4+Pn1cbiAqIEBwcm9wZXJ0eSB7R3JhbW1hcn0gW3Jlc3RdIEFuIG9wdGlvbmFsIGdyYW1tYXIgb2JqZWN0IHRoYXQgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGlzIGdyYW1tYXIuXG4gKiBAZ2xvYmFsXG4gKiBAcHVibGljXG4gKi9cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHdoaWNoIHdpbGwgaW52b2tlZCBhZnRlciBhbiBlbGVtZW50IHdhcyBzdWNjZXNzZnVsbHkgaGlnaGxpZ2h0ZWQuXG4gKlxuICogQGNhbGxiYWNrIEhpZ2hsaWdodENhbGxiYWNrXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgc3VjY2Vzc2Z1bGx5IGhpZ2hsaWdodGVkLlxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAZ2xvYmFsXG4gKiBAcHVibGljXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgSG9va0NhbGxiYWNrXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IGVudiBUaGUgZW52aXJvbm1lbnQgdmFyaWFibGVzIG9mIHRoZSBob29rLlxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAZ2xvYmFsXG4gKiBAcHVibGljXG4gKi9cblxuXG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgIEJlZ2luIHByaXNtLW1hcmt1cC5qc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG5QcmlzbS5sYW5ndWFnZXMubWFya3VwID0ge1xuXHQnY29tbWVudCc6IHtcblx0XHRwYXR0ZXJuOiAvPCEtLSg/Oig/ITwhLS0pW1xcc1xcU10pKj8tLT4vLFxuXHRcdGdyZWVkeTogdHJ1ZVxuXHR9LFxuXHQncHJvbG9nJzoge1xuXHRcdHBhdHRlcm46IC88XFw/W1xcc1xcU10rP1xcPz4vLFxuXHRcdGdyZWVkeTogdHJ1ZVxuXHR9LFxuXHQnZG9jdHlwZSc6IHtcblx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIveG1sLyNOVC1kb2N0eXBlZGVjbFxuXHRcdHBhdHRlcm46IC88IURPQ1RZUEUoPzpbXj5cIidbXFxdXXxcIlteXCJdKlwifCdbXiddKicpKyg/OlxcWyg/OltePFwiJ1xcXV18XCJbXlwiXSpcInwnW14nXSonfDwoPyEhLS0pfDwhLS0oPzpbXi1dfC0oPyEtPikpKi0tPikqXFxdXFxzKik/Pi9pLFxuXHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRpbnNpZGU6IHtcblx0XHRcdCdpbnRlcm5hbC1zdWJzZXQnOiB7XG5cdFx0XHRcdHBhdHRlcm46IC8oXlteXFxbXSpcXFspW1xcc1xcU10rKD89XFxdPiQpLyxcblx0XHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdFx0Z3JlZWR5OiB0cnVlLFxuXHRcdFx0XHRpbnNpZGU6IG51bGwgLy8gc2VlIGJlbG93XG5cdFx0XHR9LFxuXHRcdFx0J3N0cmluZyc6IHtcblx0XHRcdFx0cGF0dGVybjogL1wiW15cIl0qXCJ8J1teJ10qJy8sXG5cdFx0XHRcdGdyZWVkeTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdCdwdW5jdHVhdGlvbic6IC9ePCF8PiR8W1tcXF1dLyxcblx0XHRcdCdkb2N0eXBlLXRhZyc6IC9eRE9DVFlQRS9pLFxuXHRcdFx0J25hbWUnOiAvW15cXHM8PidcIl0rL1xuXHRcdH1cblx0fSxcblx0J2NkYXRhJzoge1xuXHRcdHBhdHRlcm46IC88IVxcW0NEQVRBXFxbW1xcc1xcU10qP1xcXVxcXT4vaSxcblx0XHRncmVlZHk6IHRydWVcblx0fSxcblx0J3RhZyc6IHtcblx0XHRwYXR0ZXJuOiAvPFxcLz8oPyFcXGQpW15cXHM+XFwvPSQ8JV0rKD86XFxzKD86XFxzKlteXFxzPlxcLz1dKyg/Olxccyo9XFxzKig/OlwiW15cIl0qXCJ8J1teJ10qJ3xbXlxccydcIj49XSsoPz1bXFxzPl0pKXwoPz1bXFxzLz5dKSkpKyk/XFxzKlxcLz8+Lyxcblx0XHRncmVlZHk6IHRydWUsXG5cdFx0aW5zaWRlOiB7XG5cdFx0XHQndGFnJzoge1xuXHRcdFx0XHRwYXR0ZXJuOiAvXjxcXC8/W15cXHM+XFwvXSsvLFxuXHRcdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0XHQncHVuY3R1YXRpb24nOiAvXjxcXC8/Lyxcblx0XHRcdFx0XHQnbmFtZXNwYWNlJzogL15bXlxccz5cXC86XSs6L1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0J3NwZWNpYWwtYXR0cic6IFtdLFxuXHRcdFx0J2F0dHItdmFsdWUnOiB7XG5cdFx0XHRcdHBhdHRlcm46IC89XFxzKig/OlwiW15cIl0qXCJ8J1teJ10qJ3xbXlxccydcIj49XSspLyxcblx0XHRcdFx0aW5zaWRlOiB7XG5cdFx0XHRcdFx0J3B1bmN0dWF0aW9uJzogW1xuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRwYXR0ZXJuOiAvXj0vLFxuXHRcdFx0XHRcdFx0XHRhbGlhczogJ2F0dHItZXF1YWxzJ1xuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdC9cInwnL1xuXHRcdFx0XHRcdF1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdCdwdW5jdHVhdGlvbic6IC9cXC8/Pi8sXG5cdFx0XHQnYXR0ci1uYW1lJzoge1xuXHRcdFx0XHRwYXR0ZXJuOiAvW15cXHM+XFwvXSsvLFxuXHRcdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0XHQnbmFtZXNwYWNlJzogL15bXlxccz5cXC86XSs6L1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9XG5cdH0sXG5cdCdlbnRpdHknOiBbXG5cdFx0e1xuXHRcdFx0cGF0dGVybjogLyZbXFxkYS16XXsxLDh9Oy9pLFxuXHRcdFx0YWxpYXM6ICduYW1lZC1lbnRpdHknXG5cdFx0fSxcblx0XHQvJiN4P1tcXGRhLWZdezEsOH07L2lcblx0XVxufTtcblxuUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cFsndGFnJ10uaW5zaWRlWydhdHRyLXZhbHVlJ10uaW5zaWRlWydlbnRpdHknXSA9XG5cdFByaXNtLmxhbmd1YWdlcy5tYXJrdXBbJ2VudGl0eSddO1xuUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cFsnZG9jdHlwZSddLmluc2lkZVsnaW50ZXJuYWwtc3Vic2V0J10uaW5zaWRlID0gUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cDtcblxuLy8gUGx1Z2luIHRvIG1ha2UgZW50aXR5IHRpdGxlIHNob3cgdGhlIHJlYWwgZW50aXR5LCBpZGVhIGJ5IFJvbWFuIEtvbWFyb3ZcblByaXNtLmhvb2tzLmFkZCgnd3JhcCcsIGZ1bmN0aW9uIChlbnYpIHtcblxuXHRpZiAoZW52LnR5cGUgPT09ICdlbnRpdHknKSB7XG5cdFx0ZW52LmF0dHJpYnV0ZXNbJ3RpdGxlJ10gPSBlbnYuY29udGVudC5yZXBsYWNlKC8mYW1wOy8sICcmJyk7XG5cdH1cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcsICdhZGRJbmxpbmVkJywge1xuXHQvKipcblx0ICogQWRkcyBhbiBpbmxpbmVkIGxhbmd1YWdlIHRvIG1hcmt1cC5cblx0ICpcblx0ICogQW4gZXhhbXBsZSBvZiBhbiBpbmxpbmVkIGxhbmd1YWdlIGlzIENTUyB3aXRoIGA8c3R5bGU+YCB0YWdzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdGFnTmFtZSBUaGUgbmFtZSBvZiB0aGUgdGFnIHRoYXQgY29udGFpbnMgdGhlIGlubGluZWQgbGFuZ3VhZ2UuIFRoaXMgbmFtZSB3aWxsIGJlIHRyZWF0ZWQgYXNcblx0ICogY2FzZSBpbnNlbnNpdGl2ZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGxhbmcgVGhlIGxhbmd1YWdlIGtleS5cblx0ICogQGV4YW1wbGVcblx0ICogYWRkSW5saW5lZCgnc3R5bGUnLCAnY3NzJyk7XG5cdCAqL1xuXHR2YWx1ZTogZnVuY3Rpb24gYWRkSW5saW5lZCh0YWdOYW1lLCBsYW5nKSB7XG5cdFx0dmFyIGluY2x1ZGVkQ2RhdGFJbnNpZGUgPSB7fTtcblx0XHRpbmNsdWRlZENkYXRhSW5zaWRlWydsYW5ndWFnZS0nICsgbGFuZ10gPSB7XG5cdFx0XHRwYXR0ZXJuOiAvKF48IVxcW0NEQVRBXFxbKVtcXHNcXFNdKz8oPz1cXF1cXF0+JCkvaSxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRpbnNpZGU6IFByaXNtLmxhbmd1YWdlc1tsYW5nXVxuXHRcdH07XG5cdFx0aW5jbHVkZWRDZGF0YUluc2lkZVsnY2RhdGEnXSA9IC9ePCFcXFtDREFUQVxcW3xcXF1cXF0+JC9pO1xuXG5cdFx0dmFyIGluc2lkZSA9IHtcblx0XHRcdCdpbmNsdWRlZC1jZGF0YSc6IHtcblx0XHRcdFx0cGF0dGVybjogLzwhXFxbQ0RBVEFcXFtbXFxzXFxTXSo/XFxdXFxdPi9pLFxuXHRcdFx0XHRpbnNpZGU6IGluY2x1ZGVkQ2RhdGFJbnNpZGVcblx0XHRcdH1cblx0XHR9O1xuXHRcdGluc2lkZVsnbGFuZ3VhZ2UtJyArIGxhbmddID0ge1xuXHRcdFx0cGF0dGVybjogL1tcXHNcXFNdKy8sXG5cdFx0XHRpbnNpZGU6IFByaXNtLmxhbmd1YWdlc1tsYW5nXVxuXHRcdH07XG5cblx0XHR2YXIgZGVmID0ge307XG5cdFx0ZGVmW3RhZ05hbWVdID0ge1xuXHRcdFx0cGF0dGVybjogUmVnRXhwKC8oPF9fW14+XSo+KSg/OjwhXFxbQ0RBVEFcXFsoPzpbXlxcXV18XFxdKD8hXFxdPikpKlxcXVxcXT58KD8hPCFcXFtDREFUQVxcWylbXFxzXFxTXSkqPyg/PTxcXC9fXz4pLy5zb3VyY2UucmVwbGFjZSgvX18vZywgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGFnTmFtZTsgfSksICdpJyksXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0Z3JlZWR5OiB0cnVlLFxuXHRcdFx0aW5zaWRlOiBpbnNpZGVcblx0XHR9O1xuXG5cdFx0UHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnbWFya3VwJywgJ2NkYXRhJywgZGVmKTtcblx0fVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcsICdhZGRBdHRyaWJ1dGUnLCB7XG5cdC8qKlxuXHQgKiBBZGRzIGFuIHBhdHRlcm4gdG8gaGlnaGxpZ2h0IGxhbmd1YWdlcyBlbWJlZGRlZCBpbiBIVE1MIGF0dHJpYnV0ZXMuXG5cdCAqXG5cdCAqIEFuIGV4YW1wbGUgb2YgYW4gaW5saW5lZCBsYW5ndWFnZSBpcyBDU1Mgd2l0aCBgc3R5bGVgIGF0dHJpYnV0ZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyTmFtZSBUaGUgbmFtZSBvZiB0aGUgdGFnIHRoYXQgY29udGFpbnMgdGhlIGlubGluZWQgbGFuZ3VhZ2UuIFRoaXMgbmFtZSB3aWxsIGJlIHRyZWF0ZWQgYXNcblx0ICogY2FzZSBpbnNlbnNpdGl2ZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGxhbmcgVGhlIGxhbmd1YWdlIGtleS5cblx0ICogQGV4YW1wbGVcblx0ICogYWRkQXR0cmlidXRlKCdzdHlsZScsICdjc3MnKTtcblx0ICovXG5cdHZhbHVlOiBmdW5jdGlvbiAoYXR0ck5hbWUsIGxhbmcpIHtcblx0XHRQcmlzbS5sYW5ndWFnZXMubWFya3VwLnRhZy5pbnNpZGVbJ3NwZWNpYWwtYXR0ciddLnB1c2goe1xuXHRcdFx0cGF0dGVybjogUmVnRXhwKFxuXHRcdFx0XHQvKF58W1wiJ1xcc10pLy5zb3VyY2UgKyAnKD86JyArIGF0dHJOYW1lICsgJyknICsgL1xccyo9XFxzKig/OlwiW15cIl0qXCJ8J1teJ10qJ3xbXlxccydcIj49XSsoPz1bXFxzPl0pKS8uc291cmNlLFxuXHRcdFx0XHQnaSdcblx0XHRcdCksXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0aW5zaWRlOiB7XG5cdFx0XHRcdCdhdHRyLW5hbWUnOiAvXlteXFxzPV0rLyxcblx0XHRcdFx0J2F0dHItdmFsdWUnOiB7XG5cdFx0XHRcdFx0cGF0dGVybjogLz1bXFxzXFxTXSsvLFxuXHRcdFx0XHRcdGluc2lkZToge1xuXHRcdFx0XHRcdFx0J3ZhbHVlJzoge1xuXHRcdFx0XHRcdFx0XHRwYXR0ZXJuOiAvKF49XFxzKihbXCInXXwoPyFbXCInXSkpKVxcU1tcXHNcXFNdKig/PVxcMiQpLyxcblx0XHRcdFx0XHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0YWxpYXM6IFtsYW5nLCAnbGFuZ3VhZ2UtJyArIGxhbmddLFxuXHRcdFx0XHRcdFx0XHRpbnNpZGU6IFByaXNtLmxhbmd1YWdlc1tsYW5nXVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdCdwdW5jdHVhdGlvbic6IFtcblx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdHBhdHRlcm46IC9ePS8sXG5cdFx0XHRcdFx0XHRcdFx0YWxpYXM6ICdhdHRyLWVxdWFscydcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0L1wifCcvXG5cdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5QcmlzbS5sYW5ndWFnZXMuaHRtbCA9IFByaXNtLmxhbmd1YWdlcy5tYXJrdXA7XG5QcmlzbS5sYW5ndWFnZXMubWF0aG1sID0gUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cDtcblByaXNtLmxhbmd1YWdlcy5zdmcgPSBQcmlzbS5sYW5ndWFnZXMubWFya3VwO1xuXG5QcmlzbS5sYW5ndWFnZXMueG1sID0gUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnbWFya3VwJywge30pO1xuUHJpc20ubGFuZ3VhZ2VzLnNzbWwgPSBQcmlzbS5sYW5ndWFnZXMueG1sO1xuUHJpc20ubGFuZ3VhZ2VzLmF0b20gPSBQcmlzbS5sYW5ndWFnZXMueG1sO1xuUHJpc20ubGFuZ3VhZ2VzLnJzcyA9IFByaXNtLmxhbmd1YWdlcy54bWw7XG5cblxuLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICBCZWdpbiBwcmlzbS1jc3MuanNcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuKGZ1bmN0aW9uIChQcmlzbSkge1xuXG5cdHZhciBzdHJpbmcgPSAvKD86XCIoPzpcXFxcKD86XFxyXFxufFtcXHNcXFNdKXxbXlwiXFxcXFxcclxcbl0pKlwifCcoPzpcXFxcKD86XFxyXFxufFtcXHNcXFNdKXxbXidcXFxcXFxyXFxuXSkqJykvO1xuXG5cdFByaXNtLmxhbmd1YWdlcy5jc3MgPSB7XG5cdFx0J2NvbW1lbnQnOiAvXFwvXFwqW1xcc1xcU10qP1xcKlxcLy8sXG5cdFx0J2F0cnVsZSc6IHtcblx0XHRcdHBhdHRlcm46IC9AW1xcdy1dKD86W147e1xcc118XFxzKyg/IVtcXHN7XSkpKig/Ojt8KD89XFxzKlxceykpLyxcblx0XHRcdGluc2lkZToge1xuXHRcdFx0XHQncnVsZSc6IC9eQFtcXHctXSsvLFxuXHRcdFx0XHQnc2VsZWN0b3ItZnVuY3Rpb24tYXJndW1lbnQnOiB7XG5cdFx0XHRcdFx0cGF0dGVybjogLyhcXGJzZWxlY3RvclxccypcXChcXHMqKD8hW1xccyldKSkoPzpbXigpXFxzXXxcXHMrKD8hW1xccyldKXxcXCgoPzpbXigpXXxcXChbXigpXSpcXCkpKlxcKSkrKD89XFxzKlxcKSkvLFxuXHRcdFx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRcdFx0YWxpYXM6ICdzZWxlY3Rvcidcblx0XHRcdFx0fSxcblx0XHRcdFx0J2tleXdvcmQnOiB7XG5cdFx0XHRcdFx0cGF0dGVybjogLyhefFteXFx3LV0pKD86YW5kfG5vdHxvbmx5fG9yKSg/IVtcXHctXSkvLFxuXHRcdFx0XHRcdGxvb2tiZWhpbmQ6IHRydWVcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBTZWUgcmVzdCBiZWxvd1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0J3VybCc6IHtcblx0XHRcdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3MtdmFsdWVzLTMvI3VybHNcblx0XHRcdHBhdHRlcm46IFJlZ0V4cCgnXFxcXGJ1cmxcXFxcKCg/OicgKyBzdHJpbmcuc291cmNlICsgJ3wnICsgLyg/OlteXFxcXFxcclxcbigpXCInXXxcXFxcW1xcc1xcU10pKi8uc291cmNlICsgJylcXFxcKScsICdpJyksXG5cdFx0XHRncmVlZHk6IHRydWUsXG5cdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0J2Z1bmN0aW9uJzogL151cmwvaSxcblx0XHRcdFx0J3B1bmN0dWF0aW9uJzogL15cXCh8XFwpJC8sXG5cdFx0XHRcdCdzdHJpbmcnOiB7XG5cdFx0XHRcdFx0cGF0dGVybjogUmVnRXhwKCdeJyArIHN0cmluZy5zb3VyY2UgKyAnJCcpLFxuXHRcdFx0XHRcdGFsaWFzOiAndXJsJ1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQnc2VsZWN0b3InOiB7XG5cdFx0XHRwYXR0ZXJuOiBSZWdFeHAoJyhefFt7fVxcXFxzXSlbXnt9XFxcXHNdKD86W157fTtcIlxcJ1xcXFxzXXxcXFxccysoPyFbXFxcXHN7XSl8JyArIHN0cmluZy5zb3VyY2UgKyAnKSooPz1cXFxccypcXFxceyknKSxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWVcblx0XHR9LFxuXHRcdCdzdHJpbmcnOiB7XG5cdFx0XHRwYXR0ZXJuOiBzdHJpbmcsXG5cdFx0XHRncmVlZHk6IHRydWVcblx0XHR9LFxuXHRcdCdwcm9wZXJ0eSc6IHtcblx0XHRcdHBhdHRlcm46IC8oXnxbXi1cXHdcXHhBMC1cXHVGRkZGXSkoPyFcXHMpWy1fYS16XFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWy1cXHdcXHhBMC1cXHVGRkZGXSkqKD89XFxzKjopL2ksXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdFx0fSxcblx0XHQnaW1wb3J0YW50JzogLyFpbXBvcnRhbnRcXGIvaSxcblx0XHQnZnVuY3Rpb24nOiB7XG5cdFx0XHRwYXR0ZXJuOiAvKF58W14tYS16MC05XSlbLWEtejAtOV0rKD89XFwoKS9pLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZVxuXHRcdH0sXG5cdFx0J3B1bmN0dWF0aW9uJzogL1soKXt9OzosXS9cblx0fTtcblxuXHRQcmlzbS5sYW5ndWFnZXMuY3NzWydhdHJ1bGUnXS5pbnNpZGUucmVzdCA9IFByaXNtLmxhbmd1YWdlcy5jc3M7XG5cblx0dmFyIG1hcmt1cCA9IFByaXNtLmxhbmd1YWdlcy5tYXJrdXA7XG5cdGlmIChtYXJrdXApIHtcblx0XHRtYXJrdXAudGFnLmFkZElubGluZWQoJ3N0eWxlJywgJ2NzcycpO1xuXHRcdG1hcmt1cC50YWcuYWRkQXR0cmlidXRlKCdzdHlsZScsICdjc3MnKTtcblx0fVxuXG59KFByaXNtKSk7XG5cblxuLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICBCZWdpbiBwcmlzbS1jbGlrZS5qc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG5QcmlzbS5sYW5ndWFnZXMuY2xpa2UgPSB7XG5cdCdjb21tZW50JzogW1xuXHRcdHtcblx0XHRcdHBhdHRlcm46IC8oXnxbXlxcXFxdKVxcL1xcKltcXHNcXFNdKj8oPzpcXCpcXC98JCkvLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGdyZWVkeTogdHJ1ZVxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0cGF0dGVybjogLyhefFteXFxcXDpdKVxcL1xcLy4qLyxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRncmVlZHk6IHRydWVcblx0XHR9XG5cdF0sXG5cdCdzdHJpbmcnOiB7XG5cdFx0cGF0dGVybjogLyhbXCInXSkoPzpcXFxcKD86XFxyXFxufFtcXHNcXFNdKXwoPyFcXDEpW15cXFxcXFxyXFxuXSkqXFwxLyxcblx0XHRncmVlZHk6IHRydWVcblx0fSxcblx0J2NsYXNzLW5hbWUnOiB7XG5cdFx0cGF0dGVybjogLyhcXGIoPzpjbGFzc3xleHRlbmRzfGltcGxlbWVudHN8aW5zdGFuY2VvZnxpbnRlcmZhY2V8bmV3fHRyYWl0KVxccyt8XFxiY2F0Y2hcXHMrXFwoKVtcXHcuXFxcXF0rL2ksXG5cdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRpbnNpZGU6IHtcblx0XHRcdCdwdW5jdHVhdGlvbic6IC9bLlxcXFxdL1xuXHRcdH1cblx0fSxcblx0J2tleXdvcmQnOiAvXFxiKD86YnJlYWt8Y2F0Y2h8Y29udGludWV8ZG98ZWxzZXxmaW5hbGx5fGZvcnxmdW5jdGlvbnxpZnxpbnxpbnN0YW5jZW9mfG5ld3xudWxsfHJldHVybnx0aHJvd3x0cnl8d2hpbGUpXFxiLyxcblx0J2Jvb2xlYW4nOiAvXFxiKD86ZmFsc2V8dHJ1ZSlcXGIvLFxuXHQnZnVuY3Rpb24nOiAvXFxiXFx3Kyg/PVxcKCkvLFxuXHQnbnVtYmVyJzogL1xcYjB4W1xcZGEtZl0rXFxifCg/OlxcYlxcZCsoPzpcXC5cXGQqKT98XFxCXFwuXFxkKykoPzplWystXT9cXGQrKT8vaSxcblx0J29wZXJhdG9yJzogL1s8Pl09P3xbIT1dPT89P3wtLT98XFwrXFwrP3wmJj98XFx8XFx8P3xbPyovfl4lXS8sXG5cdCdwdW5jdHVhdGlvbic6IC9be31bXFxdOygpLC46XS9cbn07XG5cblxuLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICBCZWdpbiBwcmlzbS1qYXZhc2NyaXB0LmpzXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cblByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0ID0gUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnY2xpa2UnLCB7XG5cdCdjbGFzcy1uYW1lJzogW1xuXHRcdFByaXNtLmxhbmd1YWdlcy5jbGlrZVsnY2xhc3MtbmFtZSddLFxuXHRcdHtcblx0XHRcdHBhdHRlcm46IC8oXnxbXiRcXHdcXHhBMC1cXHVGRkZGXSkoPyFcXHMpW18kQS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqKD89XFwuKD86Y29uc3RydWN0b3J8cHJvdG90eXBlKSkvLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZVxuXHRcdH1cblx0XSxcblx0J2tleXdvcmQnOiBbXG5cdFx0e1xuXHRcdFx0cGF0dGVybjogLygoPzpefFxcfSlcXHMqKWNhdGNoXFxiLyxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWVcblx0XHR9LFxuXHRcdHtcblx0XHRcdHBhdHRlcm46IC8oXnxbXi5dfFxcLlxcLlxcLlxccyopXFxiKD86YXN8YXNzZXJ0KD89XFxzKlxceyl8YXN5bmMoPz1cXHMqKD86ZnVuY3Rpb25cXGJ8XFwofFskXFx3XFx4QTAtXFx1RkZGRl18JCkpfGF3YWl0fGJyZWFrfGNhc2V8Y2xhc3N8Y29uc3R8Y29udGludWV8ZGVidWdnZXJ8ZGVmYXVsdHxkZWxldGV8ZG98ZWxzZXxlbnVtfGV4cG9ydHxleHRlbmRzfGZpbmFsbHkoPz1cXHMqKD86XFx7fCQpKXxmb3J8ZnJvbSg/PVxccyooPzpbJ1wiXXwkKSl8ZnVuY3Rpb258KD86Z2V0fHNldCkoPz1cXHMqKD86WyNcXFskXFx3XFx4QTAtXFx1RkZGRl18JCkpfGlmfGltcGxlbWVudHN8aW1wb3J0fGlufGluc3RhbmNlb2Z8aW50ZXJmYWNlfGxldHxuZXd8bnVsbHxvZnxwYWNrYWdlfHByaXZhdGV8cHJvdGVjdGVkfHB1YmxpY3xyZXR1cm58c3RhdGljfHN1cGVyfHN3aXRjaHx0aGlzfHRocm93fHRyeXx0eXBlb2Z8dW5kZWZpbmVkfHZhcnx2b2lkfHdoaWxlfHdpdGh8eWllbGQpXFxiLyxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWVcblx0XHR9LFxuXHRdLFxuXHQvLyBBbGxvdyBmb3IgYWxsIG5vbi1BU0NJSSBjaGFyYWN0ZXJzIChTZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjAwODQ0NClcblx0J2Z1bmN0aW9uJzogLyM/KD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKig/PVxccyooPzpcXC5cXHMqKD86YXBwbHl8YmluZHxjYWxsKVxccyopP1xcKCkvLFxuXHQnbnVtYmVyJzoge1xuXHRcdHBhdHRlcm46IFJlZ0V4cChcblx0XHRcdC8oXnxbXlxcdyRdKS8uc291cmNlICtcblx0XHRcdCcoPzonICtcblx0XHRcdChcblx0XHRcdFx0Ly8gY29uc3RhbnRcblx0XHRcdFx0L05hTnxJbmZpbml0eS8uc291cmNlICtcblx0XHRcdFx0J3wnICtcblx0XHRcdFx0Ly8gYmluYXJ5IGludGVnZXJcblx0XHRcdFx0LzBbYkJdWzAxXSsoPzpfWzAxXSspKm4/Ly5zb3VyY2UgK1xuXHRcdFx0XHQnfCcgK1xuXHRcdFx0XHQvLyBvY3RhbCBpbnRlZ2VyXG5cdFx0XHRcdC8wW29PXVswLTddKyg/Ol9bMC03XSspKm4/Ly5zb3VyY2UgK1xuXHRcdFx0XHQnfCcgK1xuXHRcdFx0XHQvLyBoZXhhZGVjaW1hbCBpbnRlZ2VyXG5cdFx0XHRcdC8wW3hYXVtcXGRBLUZhLWZdKyg/Ol9bXFxkQS1GYS1mXSspKm4/Ly5zb3VyY2UgK1xuXHRcdFx0XHQnfCcgK1xuXHRcdFx0XHQvLyBkZWNpbWFsIGJpZ2ludFxuXHRcdFx0XHQvXFxkKyg/Ol9cXGQrKSpuLy5zb3VyY2UgK1xuXHRcdFx0XHQnfCcgK1xuXHRcdFx0XHQvLyBkZWNpbWFsIG51bWJlciAoaW50ZWdlciBvciBmbG9hdCkgYnV0IG5vIGJpZ2ludFxuXHRcdFx0XHQvKD86XFxkKyg/Ol9cXGQrKSooPzpcXC4oPzpcXGQrKD86X1xcZCspKik/KT98XFwuXFxkKyg/Ol9cXGQrKSopKD86W0VlXVsrLV0/XFxkKyg/Ol9cXGQrKSopPy8uc291cmNlXG5cdFx0XHQpICtcblx0XHRcdCcpJyArXG5cdFx0XHQvKD8hW1xcdyRdKS8uc291cmNlXG5cdFx0KSxcblx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdH0sXG5cdCdvcGVyYXRvcic6IC8tLXxcXCtcXCt8XFwqXFwqPT98PT58JiY9P3xcXHxcXHw9P3xbIT1dPT18PDw9P3w+Pj4/PT98Wy0rKi8lJnxeIT08Pl09P3xcXC57M318XFw/XFw/PT98XFw/XFwuP3xbfjpdL1xufSk7XG5cblByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0WydjbGFzcy1uYW1lJ11bMF0ucGF0dGVybiA9IC8oXFxiKD86Y2xhc3N8ZXh0ZW5kc3xpbXBsZW1lbnRzfGluc3RhbmNlb2Z8aW50ZXJmYWNlfG5ldylcXHMrKVtcXHcuXFxcXF0rLztcblxuUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnamF2YXNjcmlwdCcsICdrZXl3b3JkJywge1xuXHQncmVnZXgnOiB7XG5cdFx0cGF0dGVybjogUmVnRXhwKFxuXHRcdFx0Ly8gbG9va2JlaGluZFxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlZ2V4cC9uby1kdXBlLWNoYXJhY3RlcnMtY2hhcmFjdGVyLWNsYXNzXG5cdFx0XHQvKCg/Ol58W14kXFx3XFx4QTAtXFx1RkZGRi5cIidcXF0pXFxzXXxcXGIoPzpyZXR1cm58eWllbGQpKVxccyopLy5zb3VyY2UgK1xuXHRcdFx0Ly8gUmVnZXggcGF0dGVybjpcblx0XHRcdC8vIFRoZXJlIGFyZSAyIHJlZ2V4IHBhdHRlcm5zIGhlcmUuIFRoZSBSZWdFeHAgc2V0IG5vdGF0aW9uIHByb3Bvc2FsIGFkZGVkIHN1cHBvcnQgZm9yIG5lc3RlZCBjaGFyYWN0ZXJcblx0XHRcdC8vIGNsYXNzZXMgaWYgdGhlIGB2YCBmbGFnIGlzIHByZXNlbnQuIFVuZm9ydHVuYXRlbHksIG5lc3RlZCBDQ3MgYXJlIGJvdGggY29udGV4dC1mcmVlIGFuZCBpbmNvbXBhdGlibGVcblx0XHRcdC8vIHdpdGggdGhlIG9ubHkgc3ludGF4LCBzbyB3ZSBoYXZlIHRvIGRlZmluZSAyIGRpZmZlcmVudCByZWdleCBwYXR0ZXJucy5cblx0XHRcdC9cXC8vLnNvdXJjZSArXG5cdFx0XHQnKD86JyArXG5cdFx0XHQvKD86XFxbKD86W15cXF1cXFxcXFxyXFxuXXxcXFxcLikqXFxdfFxcXFwufFteL1xcXFxcXFtcXHJcXG5dKStcXC9bZGdpbXl1c117MCw3fS8uc291cmNlICtcblx0XHRcdCd8JyArXG5cdFx0XHQvLyBgdmAgZmxhZyBzeW50YXguIFRoaXMgc3VwcG9ydHMgMyBsZXZlbHMgb2YgbmVzdGVkIGNoYXJhY3RlciBjbGFzc2VzLlxuXHRcdFx0Lyg/OlxcWyg/OlteW1xcXVxcXFxcXHJcXG5dfFxcXFwufFxcWyg/OlteW1xcXVxcXFxcXHJcXG5dfFxcXFwufFxcWyg/OlteW1xcXVxcXFxcXHJcXG5dfFxcXFwuKSpcXF0pKlxcXSkqXFxdfFxcXFwufFteL1xcXFxcXFtcXHJcXG5dKStcXC9bZGdpbXl1c117MCw3fXZbZGdpbXl1c117MCw3fS8uc291cmNlICtcblx0XHRcdCcpJyArXG5cdFx0XHQvLyBsb29rYWhlYWRcblx0XHRcdC8oPz0oPzpcXHN8XFwvXFwqKD86W14qXXxcXCooPyFcXC8pKSpcXCpcXC8pKig/OiR8W1xcclxcbiwuOzp9KVxcXV18XFwvXFwvKSkvLnNvdXJjZVxuXHRcdCksXG5cdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRncmVlZHk6IHRydWUsXG5cdFx0aW5zaWRlOiB7XG5cdFx0XHQncmVnZXgtc291cmNlJzoge1xuXHRcdFx0XHRwYXR0ZXJuOiAvXihcXC8pW1xcc1xcU10rKD89XFwvW2Etel0qJCkvLFxuXHRcdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0XHRhbGlhczogJ2xhbmd1YWdlLXJlZ2V4Jyxcblx0XHRcdFx0aW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMucmVnZXhcblx0XHRcdH0sXG5cdFx0XHQncmVnZXgtZGVsaW1pdGVyJzogL15cXC98XFwvJC8sXG5cdFx0XHQncmVnZXgtZmxhZ3MnOiAvXlthLXpdKyQvLFxuXHRcdH1cblx0fSxcblx0Ly8gVGhpcyBtdXN0IGJlIGRlY2xhcmVkIGJlZm9yZSBrZXl3b3JkIGJlY2F1c2Ugd2UgdXNlIFwiZnVuY3Rpb25cIiBpbnNpZGUgdGhlIGxvb2stZm9yd2FyZFxuXHQnZnVuY3Rpb24tdmFyaWFibGUnOiB7XG5cdFx0cGF0dGVybjogLyM/KD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKig/PVxccypbPTpdXFxzKig/OmFzeW5jXFxzKik/KD86XFxiZnVuY3Rpb25cXGJ8KD86XFwoKD86W14oKV18XFwoW14oKV0qXFwpKSpcXCl8KD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKilcXHMqPT4pKS8sXG5cdFx0YWxpYXM6ICdmdW5jdGlvbidcblx0fSxcblx0J3BhcmFtZXRlcic6IFtcblx0XHR7XG5cdFx0XHRwYXR0ZXJuOiAvKGZ1bmN0aW9uKD86XFxzKyg/IVxccylbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSopP1xccypcXChcXHMqKSg/IVxccykoPzpbXigpXFxzXXxcXHMrKD8hW1xccyldKXxcXChbXigpXSpcXCkpKyg/PVxccypcXCkpLyxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0XG5cdFx0fSxcblx0XHR7XG5cdFx0XHRwYXR0ZXJuOiAvKF58W14kXFx3XFx4QTAtXFx1RkZGRl0pKD8hXFxzKVtfJGEtelxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKig/PVxccyo9PikvaSxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0XG5cdFx0fSxcblx0XHR7XG5cdFx0XHRwYXR0ZXJuOiAvKFxcKFxccyopKD8hXFxzKSg/OlteKClcXHNdfFxccysoPyFbXFxzKV0pfFxcKFteKCldKlxcKSkrKD89XFxzKlxcKVxccyo9PikvLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRcblx0XHR9LFxuXHRcdHtcblx0XHRcdHBhdHRlcm46IC8oKD86XFxifFxcc3xeKSg/ISg/OmFzfGFzeW5jfGF3YWl0fGJyZWFrfGNhc2V8Y2F0Y2h8Y2xhc3N8Y29uc3R8Y29udGludWV8ZGVidWdnZXJ8ZGVmYXVsdHxkZWxldGV8ZG98ZWxzZXxlbnVtfGV4cG9ydHxleHRlbmRzfGZpbmFsbHl8Zm9yfGZyb218ZnVuY3Rpb258Z2V0fGlmfGltcGxlbWVudHN8aW1wb3J0fGlufGluc3RhbmNlb2Z8aW50ZXJmYWNlfGxldHxuZXd8bnVsbHxvZnxwYWNrYWdlfHByaXZhdGV8cHJvdGVjdGVkfHB1YmxpY3xyZXR1cm58c2V0fHN0YXRpY3xzdXBlcnxzd2l0Y2h8dGhpc3x0aHJvd3x0cnl8dHlwZW9mfHVuZGVmaW5lZHx2YXJ8dm9pZHx3aGlsZXx3aXRofHlpZWxkKSg/IVskXFx3XFx4QTAtXFx1RkZGRl0pKSg/Oig/IVxccylbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSpcXHMqKVxcKFxccyp8XFxdXFxzKlxcKFxccyopKD8hXFxzKSg/OlteKClcXHNdfFxccysoPyFbXFxzKV0pfFxcKFteKCldKlxcKSkrKD89XFxzKlxcKVxccypcXHspLyxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0XG5cdFx0fVxuXHRdLFxuXHQnY29uc3RhbnQnOiAvXFxiW0EtWl0oPzpbQS1aX118XFxkeD8pKlxcYi9cbn0pO1xuXG5QcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdqYXZhc2NyaXB0JywgJ3N0cmluZycsIHtcblx0J2hhc2hiYW5nJzoge1xuXHRcdHBhdHRlcm46IC9eIyEuKi8sXG5cdFx0Z3JlZWR5OiB0cnVlLFxuXHRcdGFsaWFzOiAnY29tbWVudCdcblx0fSxcblx0J3RlbXBsYXRlLXN0cmluZyc6IHtcblx0XHRwYXR0ZXJuOiAvYCg/OlxcXFxbXFxzXFxTXXxcXCRcXHsoPzpbXnt9XXxcXHsoPzpbXnt9XXxcXHtbXn1dKlxcfSkqXFx9KStcXH18KD8hXFwkXFx7KVteXFxcXGBdKSpgLyxcblx0XHRncmVlZHk6IHRydWUsXG5cdFx0aW5zaWRlOiB7XG5cdFx0XHQndGVtcGxhdGUtcHVuY3R1YXRpb24nOiB7XG5cdFx0XHRcdHBhdHRlcm46IC9eYHxgJC8sXG5cdFx0XHRcdGFsaWFzOiAnc3RyaW5nJ1xuXHRcdFx0fSxcblx0XHRcdCdpbnRlcnBvbGF0aW9uJzoge1xuXHRcdFx0XHRwYXR0ZXJuOiAvKCg/Ol58W15cXFxcXSkoPzpcXFxcezJ9KSopXFwkXFx7KD86W157fV18XFx7KD86W157fV18XFx7W159XSpcXH0pKlxcfSkrXFx9Lyxcblx0XHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdFx0aW5zaWRlOiB7XG5cdFx0XHRcdFx0J2ludGVycG9sYXRpb24tcHVuY3R1YXRpb24nOiB7XG5cdFx0XHRcdFx0XHRwYXR0ZXJuOiAvXlxcJFxce3xcXH0kLyxcblx0XHRcdFx0XHRcdGFsaWFzOiAncHVuY3R1YXRpb24nXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRyZXN0OiBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0J3N0cmluZyc6IC9bXFxzXFxTXSsvXG5cdFx0fVxuXHR9LFxuXHQnc3RyaW5nLXByb3BlcnR5Jzoge1xuXHRcdHBhdHRlcm46IC8oKD86XnxbLHtdKVsgXFx0XSopKFtcIiddKSg/OlxcXFwoPzpcXHJcXG58W1xcc1xcU10pfCg/IVxcMilbXlxcXFxcXHJcXG5dKSpcXDIoPz1cXHMqOikvbSxcblx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRhbGlhczogJ3Byb3BlcnR5J1xuXHR9XG59KTtcblxuUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnamF2YXNjcmlwdCcsICdvcGVyYXRvcicsIHtcblx0J2xpdGVyYWwtcHJvcGVydHknOiB7XG5cdFx0cGF0dGVybjogLygoPzpefFsse10pWyBcXHRdKikoPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqKD89XFxzKjopL20sXG5cdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRhbGlhczogJ3Byb3BlcnR5J1xuXHR9LFxufSk7XG5cbmlmIChQcmlzbS5sYW5ndWFnZXMubWFya3VwKSB7XG5cdFByaXNtLmxhbmd1YWdlcy5tYXJrdXAudGFnLmFkZElubGluZWQoJ3NjcmlwdCcsICdqYXZhc2NyaXB0Jyk7XG5cblx0Ly8gYWRkIGF0dHJpYnV0ZSBzdXBwb3J0IGZvciBhbGwgRE9NIGV2ZW50cy5cblx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvRXZlbnRzI1N0YW5kYXJkX2V2ZW50c1xuXHRQcmlzbS5sYW5ndWFnZXMubWFya3VwLnRhZy5hZGRBdHRyaWJ1dGUoXG5cdFx0L29uKD86YWJvcnR8Ymx1cnxjaGFuZ2V8Y2xpY2t8Y29tcG9zaXRpb24oPzplbmR8c3RhcnR8dXBkYXRlKXxkYmxjbGlja3xlcnJvcnxmb2N1cyg/OmlufG91dCk/fGtleSg/OmRvd258dXApfGxvYWR8bW91c2UoPzpkb3dufGVudGVyfGxlYXZlfG1vdmV8b3V0fG92ZXJ8dXApfHJlc2V0fHJlc2l6ZXxzY3JvbGx8c2VsZWN0fHNsb3RjaGFuZ2V8c3VibWl0fHVubG9hZHx3aGVlbCkvLnNvdXJjZSxcblx0XHQnamF2YXNjcmlwdCdcblx0KTtcbn1cblxuUHJpc20ubGFuZ3VhZ2VzLmpzID0gUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHQ7XG5cblxuLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICBCZWdpbiBwcmlzbS1maWxlLWhpZ2hsaWdodC5qc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXG5cdGlmICh0eXBlb2YgUHJpc20gPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9tYXRjaGVzI1BvbHlmaWxsXG5cdGlmICghRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcykge1xuXHRcdEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgPSBFbGVtZW50LnByb3RvdHlwZS5tc01hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50LnByb3RvdHlwZS53ZWJraXRNYXRjaGVzU2VsZWN0b3I7XG5cdH1cblxuXHR2YXIgTE9BRElOR19NRVNTQUdFID0gJ0xvYWRpbmfigKYnO1xuXHR2YXIgRkFJTFVSRV9NRVNTQUdFID0gZnVuY3Rpb24gKHN0YXR1cywgbWVzc2FnZSkge1xuXHRcdHJldHVybiAn4pyWIEVycm9yICcgKyBzdGF0dXMgKyAnIHdoaWxlIGZldGNoaW5nIGZpbGU6ICcgKyBtZXNzYWdlO1xuXHR9O1xuXHR2YXIgRkFJTFVSRV9FTVBUWV9NRVNTQUdFID0gJ+KcliBFcnJvcjogRmlsZSBkb2VzIG5vdCBleGlzdCBvciBpcyBlbXB0eSc7XG5cblx0dmFyIEVYVEVOU0lPTlMgPSB7XG5cdFx0J2pzJzogJ2phdmFzY3JpcHQnLFxuXHRcdCdweSc6ICdweXRob24nLFxuXHRcdCdyYic6ICdydWJ5Jyxcblx0XHQncHMxJzogJ3Bvd2Vyc2hlbGwnLFxuXHRcdCdwc20xJzogJ3Bvd2Vyc2hlbGwnLFxuXHRcdCdzaCc6ICdiYXNoJyxcblx0XHQnYmF0JzogJ2JhdGNoJyxcblx0XHQnaCc6ICdjJyxcblx0XHQndGV4JzogJ2xhdGV4J1xuXHR9O1xuXG5cdHZhciBTVEFUVVNfQVRUUiA9ICdkYXRhLXNyYy1zdGF0dXMnO1xuXHR2YXIgU1RBVFVTX0xPQURJTkcgPSAnbG9hZGluZyc7XG5cdHZhciBTVEFUVVNfTE9BREVEID0gJ2xvYWRlZCc7XG5cdHZhciBTVEFUVVNfRkFJTEVEID0gJ2ZhaWxlZCc7XG5cblx0dmFyIFNFTEVDVE9SID0gJ3ByZVtkYXRhLXNyY106bm90KFsnICsgU1RBVFVTX0FUVFIgKyAnPVwiJyArIFNUQVRVU19MT0FERUQgKyAnXCJdKSdcblx0XHQrICc6bm90KFsnICsgU1RBVFVTX0FUVFIgKyAnPVwiJyArIFNUQVRVU19MT0FESU5HICsgJ1wiXSknO1xuXG5cdC8qKlxuXHQgKiBMb2FkcyB0aGUgZ2l2ZW4gZmlsZS5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHNyYyBUaGUgVVJMIG9yIHBhdGggb2YgdGhlIHNvdXJjZSBmaWxlIHRvIGxvYWQuXG5cdCAqIEBwYXJhbSB7KHJlc3VsdDogc3RyaW5nKSA9PiB2b2lkfSBzdWNjZXNzXG5cdCAqIEBwYXJhbSB7KHJlYXNvbjogc3RyaW5nKSA9PiB2b2lkfSBlcnJvclxuXHQgKi9cblx0ZnVuY3Rpb24gbG9hZEZpbGUoc3JjLCBzdWNjZXNzLCBlcnJvcikge1xuXHRcdHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0XHR4aHIub3BlbignR0VUJywgc3JjLCB0cnVlKTtcblx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKHhoci5yZWFkeVN0YXRlID09IDQpIHtcblx0XHRcdFx0aWYgKHhoci5zdGF0dXMgPCA0MDAgJiYgeGhyLnJlc3BvbnNlVGV4dCkge1xuXHRcdFx0XHRcdHN1Y2Nlc3MoeGhyLnJlc3BvbnNlVGV4dCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHhoci5zdGF0dXMgPj0gNDAwKSB7XG5cdFx0XHRcdFx0XHRlcnJvcihGQUlMVVJFX01FU1NBR0UoeGhyLnN0YXR1cywgeGhyLnN0YXR1c1RleHQpKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZXJyb3IoRkFJTFVSRV9FTVBUWV9NRVNTQUdFKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdHhoci5zZW5kKG51bGwpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFBhcnNlcyB0aGUgZ2l2ZW4gcmFuZ2UuXG5cdCAqXG5cdCAqIFRoaXMgcmV0dXJucyBhIHJhbmdlIHdpdGggaW5jbHVzaXZlIGVuZHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gcmFuZ2Vcblx0ICogQHJldHVybnMge1tudW1iZXIsIG51bWJlciB8IHVuZGVmaW5lZF0gfCB1bmRlZmluZWR9XG5cdCAqL1xuXHRmdW5jdGlvbiBwYXJzZVJhbmdlKHJhbmdlKSB7XG5cdFx0dmFyIG0gPSAvXlxccyooXFxkKylcXHMqKD86KCwpXFxzKig/OihcXGQrKVxccyopPyk/JC8uZXhlYyhyYW5nZSB8fCAnJyk7XG5cdFx0aWYgKG0pIHtcblx0XHRcdHZhciBzdGFydCA9IE51bWJlcihtWzFdKTtcblx0XHRcdHZhciBjb21tYSA9IG1bMl07XG5cdFx0XHR2YXIgZW5kID0gbVszXTtcblxuXHRcdFx0aWYgKCFjb21tYSkge1xuXHRcdFx0XHRyZXR1cm4gW3N0YXJ0LCBzdGFydF07XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWVuZCkge1xuXHRcdFx0XHRyZXR1cm4gW3N0YXJ0LCB1bmRlZmluZWRdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIFtzdGFydCwgTnVtYmVyKGVuZCldO1xuXHRcdH1cblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHR9XG5cblx0UHJpc20uaG9va3MuYWRkKCdiZWZvcmUtaGlnaGxpZ2h0YWxsJywgZnVuY3Rpb24gKGVudikge1xuXHRcdGVudi5zZWxlY3RvciArPSAnLCAnICsgU0VMRUNUT1I7XG5cdH0pO1xuXG5cdFByaXNtLmhvb2tzLmFkZCgnYmVmb3JlLXNhbml0eS1jaGVjaycsIGZ1bmN0aW9uIChlbnYpIHtcblx0XHR2YXIgcHJlID0gLyoqIEB0eXBlIHtIVE1MUHJlRWxlbWVudH0gKi8gKGVudi5lbGVtZW50KTtcblx0XHRpZiAocHJlLm1hdGNoZXMoU0VMRUNUT1IpKSB7XG5cdFx0XHRlbnYuY29kZSA9ICcnOyAvLyBmYXN0LXBhdGggdGhlIHdob2xlIHRoaW5nIGFuZCBnbyB0byBjb21wbGV0ZVxuXG5cdFx0XHRwcmUuc2V0QXR0cmlidXRlKFNUQVRVU19BVFRSLCBTVEFUVVNfTE9BRElORyk7IC8vIG1hcmsgYXMgbG9hZGluZ1xuXG5cdFx0XHQvLyBhZGQgY29kZSBlbGVtZW50IHdpdGggbG9hZGluZyBtZXNzYWdlXG5cdFx0XHR2YXIgY29kZSA9IHByZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdDT0RFJykpO1xuXHRcdFx0Y29kZS50ZXh0Q29udGVudCA9IExPQURJTkdfTUVTU0FHRTtcblxuXHRcdFx0dmFyIHNyYyA9IHByZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3JjJyk7XG5cblx0XHRcdHZhciBsYW5ndWFnZSA9IGVudi5sYW5ndWFnZTtcblx0XHRcdGlmIChsYW5ndWFnZSA9PT0gJ25vbmUnKSB7XG5cdFx0XHRcdC8vIHRoZSBsYW5ndWFnZSBtaWdodCBiZSAnbm9uZScgYmVjYXVzZSB0aGVyZSBpcyBubyBsYW5ndWFnZSBzZXQ7XG5cdFx0XHRcdC8vIGluIHRoaXMgY2FzZSwgd2Ugd2FudCB0byB1c2UgdGhlIGV4dGVuc2lvbiBhcyB0aGUgbGFuZ3VhZ2Vcblx0XHRcdFx0dmFyIGV4dGVuc2lvbiA9ICgvXFwuKFxcdyspJC8uZXhlYyhzcmMpIHx8IFssICdub25lJ10pWzFdO1xuXHRcdFx0XHRsYW5ndWFnZSA9IEVYVEVOU0lPTlNbZXh0ZW5zaW9uXSB8fCBleHRlbnNpb247XG5cdFx0XHR9XG5cblx0XHRcdC8vIHNldCBsYW5ndWFnZSBjbGFzc2VzXG5cdFx0XHRQcmlzbS51dGlsLnNldExhbmd1YWdlKGNvZGUsIGxhbmd1YWdlKTtcblx0XHRcdFByaXNtLnV0aWwuc2V0TGFuZ3VhZ2UocHJlLCBsYW5ndWFnZSk7XG5cblx0XHRcdC8vIHByZWxvYWQgdGhlIGxhbmd1YWdlXG5cdFx0XHR2YXIgYXV0b2xvYWRlciA9IFByaXNtLnBsdWdpbnMuYXV0b2xvYWRlcjtcblx0XHRcdGlmIChhdXRvbG9hZGVyKSB7XG5cdFx0XHRcdGF1dG9sb2FkZXIubG9hZExhbmd1YWdlcyhsYW5ndWFnZSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGxvYWQgZmlsZVxuXHRcdFx0bG9hZEZpbGUoXG5cdFx0XHRcdHNyYyxcblx0XHRcdFx0ZnVuY3Rpb24gKHRleHQpIHtcblx0XHRcdFx0XHQvLyBtYXJrIGFzIGxvYWRlZFxuXHRcdFx0XHRcdHByZS5zZXRBdHRyaWJ1dGUoU1RBVFVTX0FUVFIsIFNUQVRVU19MT0FERUQpO1xuXG5cdFx0XHRcdFx0Ly8gaGFuZGxlIGRhdGEtcmFuZ2Vcblx0XHRcdFx0XHR2YXIgcmFuZ2UgPSBwYXJzZVJhbmdlKHByZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmFuZ2UnKSk7XG5cdFx0XHRcdFx0aWYgKHJhbmdlKSB7XG5cdFx0XHRcdFx0XHR2YXIgbGluZXMgPSB0ZXh0LnNwbGl0KC9cXHJcXG4/fFxcbi9nKTtcblxuXHRcdFx0XHRcdFx0Ly8gdGhlIHJhbmdlIGlzIG9uZS1iYXNlZCBhbmQgaW5jbHVzaXZlIG9uIGJvdGggZW5kc1xuXHRcdFx0XHRcdFx0dmFyIHN0YXJ0ID0gcmFuZ2VbMF07XG5cdFx0XHRcdFx0XHR2YXIgZW5kID0gcmFuZ2VbMV0gPT0gbnVsbCA/IGxpbmVzLmxlbmd0aCA6IHJhbmdlWzFdO1xuXG5cdFx0XHRcdFx0XHRpZiAoc3RhcnQgPCAwKSB7IHN0YXJ0ICs9IGxpbmVzLmxlbmd0aDsgfVxuXHRcdFx0XHRcdFx0c3RhcnQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihzdGFydCAtIDEsIGxpbmVzLmxlbmd0aCkpO1xuXHRcdFx0XHRcdFx0aWYgKGVuZCA8IDApIHsgZW5kICs9IGxpbmVzLmxlbmd0aDsgfVxuXHRcdFx0XHRcdFx0ZW5kID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oZW5kLCBsaW5lcy5sZW5ndGgpKTtcblxuXHRcdFx0XHRcdFx0dGV4dCA9IGxpbmVzLnNsaWNlKHN0YXJ0LCBlbmQpLmpvaW4oJ1xcbicpO1xuXG5cdFx0XHRcdFx0XHQvLyBhZGQgZGF0YS1zdGFydCBmb3IgbGluZSBudW1iZXJzXG5cdFx0XHRcdFx0XHRpZiAoIXByZS5oYXNBdHRyaWJ1dGUoJ2RhdGEtc3RhcnQnKSkge1xuXHRcdFx0XHRcdFx0XHRwcmUuc2V0QXR0cmlidXRlKCdkYXRhLXN0YXJ0JywgU3RyaW5nKHN0YXJ0ICsgMSkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGhpZ2hsaWdodCBjb2RlXG5cdFx0XHRcdFx0Y29kZS50ZXh0Q29udGVudCA9IHRleHQ7XG5cdFx0XHRcdFx0UHJpc20uaGlnaGxpZ2h0RWxlbWVudChjb2RlKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0ZnVuY3Rpb24gKGVycm9yKSB7XG5cdFx0XHRcdFx0Ly8gbWFyayBhcyBmYWlsZWRcblx0XHRcdFx0XHRwcmUuc2V0QXR0cmlidXRlKFNUQVRVU19BVFRSLCBTVEFUVVNfRkFJTEVEKTtcblxuXHRcdFx0XHRcdGNvZGUudGV4dENvbnRlbnQgPSBlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XHR9XG5cdH0pO1xuXG5cdFByaXNtLnBsdWdpbnMuZmlsZUhpZ2hsaWdodCA9IHtcblx0XHQvKipcblx0XHQgKiBFeGVjdXRlcyB0aGUgRmlsZSBIaWdobGlnaHQgcGx1Z2luIGZvciBhbGwgbWF0Y2hpbmcgYHByZWAgZWxlbWVudHMgdW5kZXIgdGhlIGdpdmVuIGNvbnRhaW5lci5cblx0XHQgKlxuXHRcdCAqIE5vdGU6IEVsZW1lbnRzIHdoaWNoIGFyZSBhbHJlYWR5IGxvYWRlZCBvciBjdXJyZW50bHkgbG9hZGluZyB3aWxsIG5vdCBiZSB0b3VjaGVkIGJ5IHRoaXMgbWV0aG9kLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtQYXJlbnROb2RlfSBbY29udGFpbmVyPWRvY3VtZW50XVxuXHRcdCAqL1xuXHRcdGhpZ2hsaWdodDogZnVuY3Rpb24gaGlnaGxpZ2h0KGNvbnRhaW5lcikge1xuXHRcdFx0dmFyIGVsZW1lbnRzID0gKGNvbnRhaW5lciB8fCBkb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbChTRUxFQ1RPUik7XG5cblx0XHRcdGZvciAodmFyIGkgPSAwLCBlbGVtZW50OyAoZWxlbWVudCA9IGVsZW1lbnRzW2krK10pOykge1xuXHRcdFx0XHRQcmlzbS5oaWdobGlnaHRFbGVtZW50KGVsZW1lbnQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHR2YXIgbG9nZ2VkID0gZmFsc2U7XG5cdC8qKiBAZGVwcmVjYXRlZCBVc2UgYFByaXNtLnBsdWdpbnMuZmlsZUhpZ2hsaWdodC5oaWdobGlnaHRgIGluc3RlYWQuICovXG5cdFByaXNtLmZpbGVIaWdobGlnaHQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCFsb2dnZWQpIHtcblx0XHRcdGNvbnNvbGUud2FybignUHJpc20uZmlsZUhpZ2hsaWdodCBpcyBkZXByZWNhdGVkLiBVc2UgYFByaXNtLnBsdWdpbnMuZmlsZUhpZ2hsaWdodC5oaWdobGlnaHRgIGluc3RlYWQuJyk7XG5cdFx0XHRsb2dnZWQgPSB0cnVlO1xuXHRcdH1cblx0XHRQcmlzbS5wbHVnaW5zLmZpbGVIaWdobGlnaHQuaGlnaGxpZ2h0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH07XG5cbn0oKSk7XG4iLCIvKiohXG4qIHRpcHB5LmpzIHY2LjIuM1xuKiAoYykgMjAxNy0yMDIwIGF0b21pa3NcbiogTUlUIExpY2Vuc2VcbiovXG5pbXBvcnQgeyBjcmVhdGVQb3BwZXIgfSBmcm9tICdAcG9wcGVyanMvY29yZSc7XG5cbnZhciBST1VORF9BUlJPVyA9ICc8c3ZnIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCI2XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGQ9XCJNMCA2czEuNzk2LS4wMTMgNC42Ny0zLjYxNUM1Ljg1MS45IDYuOTMuMDA2IDggMGMxLjA3LS4wMDYgMi4xNDguODg3IDMuMzQzIDIuMzg1QzE0LjIzMyA2LjAwNSAxNiA2IDE2IDZIMHpcIj48L3N2Zz4nO1xudmFyIEJPWF9DTEFTUyA9IFwidGlwcHktYm94XCI7XG52YXIgQ09OVEVOVF9DTEFTUyA9IFwidGlwcHktY29udGVudFwiO1xudmFyIEJBQ0tEUk9QX0NMQVNTID0gXCJ0aXBweS1iYWNrZHJvcFwiO1xudmFyIEFSUk9XX0NMQVNTID0gXCJ0aXBweS1hcnJvd1wiO1xudmFyIFNWR19BUlJPV19DTEFTUyA9IFwidGlwcHktc3ZnLWFycm93XCI7XG52YXIgVE9VQ0hfT1BUSU9OUyA9IHtcbiAgcGFzc2l2ZTogdHJ1ZSxcbiAgY2FwdHVyZTogdHJ1ZVxufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBrZXkpIHtcbiAgcmV0dXJuIHt9Lmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuZnVuY3Rpb24gZ2V0VmFsdWVBdEluZGV4T3JSZXR1cm4odmFsdWUsIGluZGV4LCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdmFyIHYgPSB2YWx1ZVtpbmRleF07XG4gICAgcmV0dXJuIHYgPT0gbnVsbCA/IEFycmF5LmlzQXJyYXkoZGVmYXVsdFZhbHVlKSA/IGRlZmF1bHRWYWx1ZVtpbmRleF0gOiBkZWZhdWx0VmFsdWUgOiB2O1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gaXNUeXBlKHZhbHVlLCB0eXBlKSB7XG4gIHZhciBzdHIgPSB7fS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgcmV0dXJuIHN0ci5pbmRleE9mKCdbb2JqZWN0JykgPT09IDAgJiYgc3RyLmluZGV4T2YodHlwZSArIFwiXVwiKSA+IC0xO1xufVxuZnVuY3Rpb24gaW52b2tlV2l0aEFyZ3NPclJldHVybih2YWx1ZSwgYXJncykge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gdmFsdWUuYXBwbHkodm9pZCAwLCBhcmdzKSA6IHZhbHVlO1xufVxuZnVuY3Rpb24gZGVib3VuY2UoZm4sIG1zKSB7XG4gIC8vIEF2b2lkIHdyYXBwaW5nIGluIGBzZXRUaW1lb3V0YCBpZiBtcyBpcyAwIGFueXdheVxuICBpZiAobXMgPT09IDApIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgdGltZW91dDtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgZm4oYXJnKTtcbiAgICB9LCBtcyk7XG4gIH07XG59XG5mdW5jdGlvbiByZW1vdmVQcm9wZXJ0aWVzKG9iaiwga2V5cykge1xuICB2YXIgY2xvbmUgPSBPYmplY3QuYXNzaWduKHt9LCBvYmopO1xuICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGRlbGV0ZSBjbG9uZVtrZXldO1xuICB9KTtcbiAgcmV0dXJuIGNsb25lO1xufVxuZnVuY3Rpb24gc3BsaXRCeVNwYWNlcyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUuc3BsaXQoL1xccysvKS5maWx0ZXIoQm9vbGVhbik7XG59XG5mdW5jdGlvbiBub3JtYWxpemVUb0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiBbXS5jb25jYXQodmFsdWUpO1xufVxuZnVuY3Rpb24gcHVzaElmVW5pcXVlKGFyciwgdmFsdWUpIHtcbiAgaWYgKGFyci5pbmRleE9mKHZhbHVlKSA9PT0gLTEpIHtcbiAgICBhcnIucHVzaCh2YWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVuaXF1ZShhcnIpIHtcbiAgcmV0dXJuIGFyci5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgcmV0dXJuIGFyci5pbmRleE9mKGl0ZW0pID09PSBpbmRleDtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG59XG5mdW5jdGlvbiBhcnJheUZyb20odmFsdWUpIHtcbiAgcmV0dXJuIFtdLnNsaWNlLmNhbGwodmFsdWUpO1xufVxuXG5mdW5jdGlvbiBkaXYoKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICByZXR1cm4gWydFbGVtZW50JywgJ0ZyYWdtZW50J10uc29tZShmdW5jdGlvbiAodHlwZSkge1xuICAgIHJldHVybiBpc1R5cGUodmFsdWUsIHR5cGUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGlzTm9kZUxpc3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzVHlwZSh2YWx1ZSwgJ05vZGVMaXN0Jyk7XG59XG5mdW5jdGlvbiBpc01vdXNlRXZlbnQodmFsdWUpIHtcbiAgcmV0dXJuIGlzVHlwZSh2YWx1ZSwgJ01vdXNlRXZlbnQnKTtcbn1cbmZ1bmN0aW9uIGlzUmVmZXJlbmNlRWxlbWVudCh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX3RpcHB5ICYmIHZhbHVlLl90aXBweS5yZWZlcmVuY2UgPT09IHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGdldEFycmF5T2ZFbGVtZW50cyh2YWx1ZSkge1xuICBpZiAoaXNFbGVtZW50KHZhbHVlKSkge1xuICAgIHJldHVybiBbdmFsdWVdO1xuICB9XG5cbiAgaWYgKGlzTm9kZUxpc3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGFycmF5RnJvbSh2YWx1ZSk7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gYXJyYXlGcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodmFsdWUpKTtcbn1cbmZ1bmN0aW9uIHNldFRyYW5zaXRpb25EdXJhdGlvbihlbHMsIHZhbHVlKSB7XG4gIGVscy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChlbCkge1xuICAgICAgZWwuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gdmFsdWUgKyBcIm1zXCI7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHNldFZpc2liaWxpdHlTdGF0ZShlbHMsIHN0YXRlKSB7XG4gIGVscy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChlbCkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdkYXRhLXN0YXRlJywgc3RhdGUpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRPd25lckRvY3VtZW50KGVsZW1lbnRPckVsZW1lbnRzKSB7XG4gIHZhciBfbm9ybWFsaXplVG9BcnJheSA9IG5vcm1hbGl6ZVRvQXJyYXkoZWxlbWVudE9yRWxlbWVudHMpLFxuICAgICAgZWxlbWVudCA9IF9ub3JtYWxpemVUb0FycmF5WzBdO1xuXG4gIHJldHVybiBlbGVtZW50ID8gZWxlbWVudC5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50IDogZG9jdW1lbnQ7XG59XG5mdW5jdGlvbiBpc0N1cnNvck91dHNpZGVJbnRlcmFjdGl2ZUJvcmRlcihwb3BwZXJUcmVlRGF0YSwgZXZlbnQpIHtcbiAgdmFyIGNsaWVudFggPSBldmVudC5jbGllbnRYLFxuICAgICAgY2xpZW50WSA9IGV2ZW50LmNsaWVudFk7XG4gIHJldHVybiBwb3BwZXJUcmVlRGF0YS5ldmVyeShmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBwb3BwZXJSZWN0ID0gX3JlZi5wb3BwZXJSZWN0LFxuICAgICAgICBwb3BwZXJTdGF0ZSA9IF9yZWYucG9wcGVyU3RhdGUsXG4gICAgICAgIHByb3BzID0gX3JlZi5wcm9wcztcbiAgICB2YXIgaW50ZXJhY3RpdmVCb3JkZXIgPSBwcm9wcy5pbnRlcmFjdGl2ZUJvcmRlcjtcbiAgICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocG9wcGVyU3RhdGUucGxhY2VtZW50KTtcbiAgICB2YXIgb2Zmc2V0RGF0YSA9IHBvcHBlclN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0O1xuXG4gICAgaWYgKCFvZmZzZXREYXRhKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgdG9wRGlzdGFuY2UgPSBiYXNlUGxhY2VtZW50ID09PSAnYm90dG9tJyA/IG9mZnNldERhdGEudG9wLnkgOiAwO1xuICAgIHZhciBib3R0b21EaXN0YW5jZSA9IGJhc2VQbGFjZW1lbnQgPT09ICd0b3AnID8gb2Zmc2V0RGF0YS5ib3R0b20ueSA6IDA7XG4gICAgdmFyIGxlZnREaXN0YW5jZSA9IGJhc2VQbGFjZW1lbnQgPT09ICdyaWdodCcgPyBvZmZzZXREYXRhLmxlZnQueCA6IDA7XG4gICAgdmFyIHJpZ2h0RGlzdGFuY2UgPSBiYXNlUGxhY2VtZW50ID09PSAnbGVmdCcgPyBvZmZzZXREYXRhLnJpZ2h0LnggOiAwO1xuICAgIHZhciBleGNlZWRzVG9wID0gcG9wcGVyUmVjdC50b3AgLSBjbGllbnRZICsgdG9wRGlzdGFuY2UgPiBpbnRlcmFjdGl2ZUJvcmRlcjtcbiAgICB2YXIgZXhjZWVkc0JvdHRvbSA9IGNsaWVudFkgLSBwb3BwZXJSZWN0LmJvdHRvbSAtIGJvdHRvbURpc3RhbmNlID4gaW50ZXJhY3RpdmVCb3JkZXI7XG4gICAgdmFyIGV4Y2VlZHNMZWZ0ID0gcG9wcGVyUmVjdC5sZWZ0IC0gY2xpZW50WCArIGxlZnREaXN0YW5jZSA+IGludGVyYWN0aXZlQm9yZGVyO1xuICAgIHZhciBleGNlZWRzUmlnaHQgPSBjbGllbnRYIC0gcG9wcGVyUmVjdC5yaWdodCAtIHJpZ2h0RGlzdGFuY2UgPiBpbnRlcmFjdGl2ZUJvcmRlcjtcbiAgICByZXR1cm4gZXhjZWVkc1RvcCB8fCBleGNlZWRzQm90dG9tIHx8IGV4Y2VlZHNMZWZ0IHx8IGV4Y2VlZHNSaWdodDtcbiAgfSk7XG59XG5mdW5jdGlvbiB1cGRhdGVUcmFuc2l0aW9uRW5kTGlzdGVuZXIoYm94LCBhY3Rpb24sIGxpc3RlbmVyKSB7XG4gIHZhciBtZXRob2QgPSBhY3Rpb24gKyBcIkV2ZW50TGlzdGVuZXJcIjsgLy8gc29tZSBicm93c2VycyBhcHBhcmVudGx5IHN1cHBvcnQgYHRyYW5zaXRpb25gICh1bnByZWZpeGVkKSBidXQgb25seSBmaXJlXG4gIC8vIGB3ZWJraXRUcmFuc2l0aW9uRW5kYC4uLlxuXG4gIFsndHJhbnNpdGlvbmVuZCcsICd3ZWJraXRUcmFuc2l0aW9uRW5kJ10uZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBib3hbbWV0aG9kXShldmVudCwgbGlzdGVuZXIpO1xuICB9KTtcbn1cblxudmFyIGN1cnJlbnRJbnB1dCA9IHtcbiAgaXNUb3VjaDogZmFsc2Vcbn07XG52YXIgbGFzdE1vdXNlTW92ZVRpbWUgPSAwO1xuLyoqXG4gKiBXaGVuIGEgYHRvdWNoc3RhcnRgIGV2ZW50IGlzIGZpcmVkLCBpdCdzIGFzc3VtZWQgdGhlIHVzZXIgaXMgdXNpbmcgdG91Y2hcbiAqIGlucHV0LiBXZSdsbCBiaW5kIGEgYG1vdXNlbW92ZWAgZXZlbnQgbGlzdGVuZXIgdG8gbGlzdGVuIGZvciBtb3VzZSBpbnB1dCBpblxuICogdGhlIGZ1dHVyZS4gVGhpcyB3YXksIHRoZSBgaXNUb3VjaGAgcHJvcGVydHkgaXMgZnVsbHkgZHluYW1pYyBhbmQgd2lsbCBoYW5kbGVcbiAqIGh5YnJpZCBkZXZpY2VzIHRoYXQgdXNlIGEgbWl4IG9mIHRvdWNoICsgbW91c2UgaW5wdXQuXG4gKi9cblxuZnVuY3Rpb24gb25Eb2N1bWVudFRvdWNoU3RhcnQoKSB7XG4gIGlmIChjdXJyZW50SW5wdXQuaXNUb3VjaCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGN1cnJlbnRJbnB1dC5pc1RvdWNoID0gdHJ1ZTtcblxuICBpZiAod2luZG93LnBlcmZvcm1hbmNlKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Eb2N1bWVudE1vdXNlTW92ZSk7XG4gIH1cbn1cbi8qKlxuICogV2hlbiB0d28gYG1vdXNlbW92ZWAgZXZlbnQgYXJlIGZpcmVkIGNvbnNlY3V0aXZlbHkgd2l0aGluIDIwbXMsIGl0J3MgYXNzdW1lZFxuICogdGhlIHVzZXIgaXMgdXNpbmcgbW91c2UgaW5wdXQgYWdhaW4uIGBtb3VzZW1vdmVgIGNhbiBmaXJlIG9uIHRvdWNoIGRldmljZXMgYXNcbiAqIHdlbGwsIGJ1dCB2ZXJ5IHJhcmVseSB0aGF0IHF1aWNrbHkuXG4gKi9cblxuZnVuY3Rpb24gb25Eb2N1bWVudE1vdXNlTW92ZSgpIHtcbiAgdmFyIG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gIGlmIChub3cgLSBsYXN0TW91c2VNb3ZlVGltZSA8IDIwKSB7XG4gICAgY3VycmVudElucHV0LmlzVG91Y2ggPSBmYWxzZTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbkRvY3VtZW50TW91c2VNb3ZlKTtcbiAgfVxuXG4gIGxhc3RNb3VzZU1vdmVUaW1lID0gbm93O1xufVxuLyoqXG4gKiBXaGVuIGFuIGVsZW1lbnQgaXMgaW4gZm9jdXMgYW5kIGhhcyBhIHRpcHB5LCBsZWF2aW5nIHRoZSB0YWIvd2luZG93IGFuZFxuICogcmV0dXJuaW5nIGNhdXNlcyBpdCB0byBzaG93IGFnYWluLiBGb3IgbW91c2UgdXNlcnMgdGhpcyBpcyB1bmV4cGVjdGVkLCBidXRcbiAqIGZvciBrZXlib2FyZCB1c2UgaXQgbWFrZXMgc2Vuc2UuXG4gKiBUT0RPOiBmaW5kIGEgYmV0dGVyIHRlY2huaXF1ZSB0byBzb2x2ZSB0aGlzIHByb2JsZW1cbiAqL1xuXG5mdW5jdGlvbiBvbldpbmRvd0JsdXIoKSB7XG4gIHZhciBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblxuICBpZiAoaXNSZWZlcmVuY2VFbGVtZW50KGFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgdmFyIGluc3RhbmNlID0gYWN0aXZlRWxlbWVudC5fdGlwcHk7XG5cbiAgICBpZiAoYWN0aXZlRWxlbWVudC5ibHVyICYmICFpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUpIHtcbiAgICAgIGFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYmluZEdsb2JhbEV2ZW50TGlzdGVuZXJzKCkge1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb25Eb2N1bWVudFRvdWNoU3RhcnQsIFRPVUNIX09QVElPTlMpO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIG9uV2luZG93Qmx1cik7XG59XG5cbnZhciBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xudmFyIHVhID0gaXNCcm93c2VyID8gbmF2aWdhdG9yLnVzZXJBZ2VudCA6ICcnO1xudmFyIGlzSUUgPSAvTVNJRSB8VHJpZGVudFxcLy8udGVzdCh1YSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZU1lbW9yeUxlYWtXYXJuaW5nKG1ldGhvZCkge1xuICB2YXIgdHh0ID0gbWV0aG9kID09PSAnZGVzdHJveScgPyAnbiBhbHJlYWR5LScgOiAnICc7XG4gIHJldHVybiBbbWV0aG9kICsgXCIoKSB3YXMgY2FsbGVkIG9uIGFcIiArIHR4dCArIFwiZGVzdHJveWVkIGluc3RhbmNlLiBUaGlzIGlzIGEgbm8tb3AgYnV0XCIsICdpbmRpY2F0ZXMgYSBwb3RlbnRpYWwgbWVtb3J5IGxlYWsuJ10uam9pbignICcpO1xufVxuZnVuY3Rpb24gY2xlYW4odmFsdWUpIHtcbiAgdmFyIHNwYWNlc0FuZFRhYnMgPSAvWyBcXHRdezIsfS9nO1xuICB2YXIgbGluZVN0YXJ0V2l0aFNwYWNlcyA9IC9eWyBcXHRdKi9nbTtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2Uoc3BhY2VzQW5kVGFicywgJyAnKS5yZXBsYWNlKGxpbmVTdGFydFdpdGhTcGFjZXMsICcnKS50cmltKCk7XG59XG5cbmZ1bmN0aW9uIGdldERldk1lc3NhZ2UobWVzc2FnZSkge1xuICByZXR1cm4gY2xlYW4oXCJcXG4gICVjdGlwcHkuanNcXG5cXG4gICVjXCIgKyBjbGVhbihtZXNzYWdlKSArIFwiXFxuXFxuICAlY1xcdUQ4M0RcXHVEQzc3XFx1MjAwRCBUaGlzIGlzIGEgZGV2ZWxvcG1lbnQtb25seSBtZXNzYWdlLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gcHJvZHVjdGlvbi5cXG4gIFwiKTtcbn1cblxuZnVuY3Rpb24gZ2V0Rm9ybWF0dGVkTWVzc2FnZShtZXNzYWdlKSB7XG4gIHJldHVybiBbZ2V0RGV2TWVzc2FnZShtZXNzYWdlKSwgLy8gdGl0bGVcbiAgJ2NvbG9yOiAjMDBDNTg0OyBmb250LXNpemU6IDEuM2VtOyBmb250LXdlaWdodDogYm9sZDsnLCAvLyBtZXNzYWdlXG4gICdsaW5lLWhlaWdodDogMS41JywgLy8gZm9vdGVyXG4gICdjb2xvcjogI2E2YTA5NTsnXTtcbn0gLy8gQXNzdW1lIHdhcm5pbmdzIGFuZCBlcnJvcnMgbmV2ZXIgaGF2ZSB0aGUgc2FtZSBtZXNzYWdlXG5cbnZhciB2aXNpdGVkTWVzc2FnZXM7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgcmVzZXRWaXNpdGVkTWVzc2FnZXMoKTtcbn1cblxuZnVuY3Rpb24gcmVzZXRWaXNpdGVkTWVzc2FnZXMoKSB7XG4gIHZpc2l0ZWRNZXNzYWdlcyA9IG5ldyBTZXQoKTtcbn1cbmZ1bmN0aW9uIHdhcm5XaGVuKGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoY29uZGl0aW9uICYmICF2aXNpdGVkTWVzc2FnZXMuaGFzKG1lc3NhZ2UpKSB7XG4gICAgdmFyIF9jb25zb2xlO1xuXG4gICAgdmlzaXRlZE1lc3NhZ2VzLmFkZChtZXNzYWdlKTtcblxuICAgIChfY29uc29sZSA9IGNvbnNvbGUpLndhcm4uYXBwbHkoX2NvbnNvbGUsIGdldEZvcm1hdHRlZE1lc3NhZ2UobWVzc2FnZSkpO1xuICB9XG59XG5mdW5jdGlvbiBlcnJvcldoZW4oY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmIChjb25kaXRpb24gJiYgIXZpc2l0ZWRNZXNzYWdlcy5oYXMobWVzc2FnZSkpIHtcbiAgICB2YXIgX2NvbnNvbGUyO1xuXG4gICAgdmlzaXRlZE1lc3NhZ2VzLmFkZChtZXNzYWdlKTtcblxuICAgIChfY29uc29sZTIgPSBjb25zb2xlKS5lcnJvci5hcHBseShfY29uc29sZTIsIGdldEZvcm1hdHRlZE1lc3NhZ2UobWVzc2FnZSkpO1xuICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVRhcmdldHModGFyZ2V0cykge1xuICB2YXIgZGlkUGFzc0ZhbHN5VmFsdWUgPSAhdGFyZ2V0cztcbiAgdmFyIGRpZFBhc3NQbGFpbk9iamVjdCA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0YXJnZXRzKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgJiYgIXRhcmdldHMuYWRkRXZlbnRMaXN0ZW5lcjtcbiAgZXJyb3JXaGVuKGRpZFBhc3NGYWxzeVZhbHVlLCBbJ3RpcHB5KCkgd2FzIHBhc3NlZCcsICdgJyArIFN0cmluZyh0YXJnZXRzKSArICdgJywgJ2FzIGl0cyB0YXJnZXRzIChmaXJzdCkgYXJndW1lbnQuIFZhbGlkIHR5cGVzIGFyZTogU3RyaW5nLCBFbGVtZW50LCcsICdFbGVtZW50W10sIG9yIE5vZGVMaXN0LiddLmpvaW4oJyAnKSk7XG4gIGVycm9yV2hlbihkaWRQYXNzUGxhaW5PYmplY3QsIFsndGlwcHkoKSB3YXMgcGFzc2VkIGEgcGxhaW4gb2JqZWN0IHdoaWNoIGlzIG5vdCBzdXBwb3J0ZWQgYXMgYW4gYXJndW1lbnQnLCAnZm9yIHZpcnR1YWwgcG9zaXRpb25pbmcuIFVzZSBwcm9wcy5nZXRSZWZlcmVuY2VDbGllbnRSZWN0IGluc3RlYWQuJ10uam9pbignICcpKTtcbn1cblxudmFyIHBsdWdpblByb3BzID0ge1xuICBhbmltYXRlRmlsbDogZmFsc2UsXG4gIGZvbGxvd0N1cnNvcjogZmFsc2UsXG4gIGlubGluZVBvc2l0aW9uaW5nOiBmYWxzZSxcbiAgc3RpY2t5OiBmYWxzZVxufTtcbnZhciByZW5kZXJQcm9wcyA9IHtcbiAgYWxsb3dIVE1MOiBmYWxzZSxcbiAgYW5pbWF0aW9uOiAnZmFkZScsXG4gIGFycm93OiB0cnVlLFxuICBjb250ZW50OiAnJyxcbiAgaW5lcnRpYTogZmFsc2UsXG4gIG1heFdpZHRoOiAzNTAsXG4gIHJvbGU6ICd0b29sdGlwJyxcbiAgdGhlbWU6ICcnLFxuICB6SW5kZXg6IDk5OTlcbn07XG52YXIgZGVmYXVsdFByb3BzID0gT2JqZWN0LmFzc2lnbih7XG4gIGFwcGVuZFRvOiBmdW5jdGlvbiBhcHBlbmRUbygpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgfSxcbiAgYXJpYToge1xuICAgIGNvbnRlbnQ6ICdhdXRvJyxcbiAgICBleHBhbmRlZDogJ2F1dG8nXG4gIH0sXG4gIGRlbGF5OiAwLFxuICBkdXJhdGlvbjogWzMwMCwgMjUwXSxcbiAgZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdDogbnVsbCxcbiAgaGlkZU9uQ2xpY2s6IHRydWUsXG4gIGlnbm9yZUF0dHJpYnV0ZXM6IGZhbHNlLFxuICBpbnRlcmFjdGl2ZTogZmFsc2UsXG4gIGludGVyYWN0aXZlQm9yZGVyOiAyLFxuICBpbnRlcmFjdGl2ZURlYm91bmNlOiAwLFxuICBtb3ZlVHJhbnNpdGlvbjogJycsXG4gIG9mZnNldDogWzAsIDEwXSxcbiAgb25BZnRlclVwZGF0ZTogZnVuY3Rpb24gb25BZnRlclVwZGF0ZSgpIHt9LFxuICBvbkJlZm9yZVVwZGF0ZTogZnVuY3Rpb24gb25CZWZvcmVVcGRhdGUoKSB7fSxcbiAgb25DcmVhdGU6IGZ1bmN0aW9uIG9uQ3JlYXRlKCkge30sXG4gIG9uRGVzdHJveTogZnVuY3Rpb24gb25EZXN0cm95KCkge30sXG4gIG9uSGlkZGVuOiBmdW5jdGlvbiBvbkhpZGRlbigpIHt9LFxuICBvbkhpZGU6IGZ1bmN0aW9uIG9uSGlkZSgpIHt9LFxuICBvbk1vdW50OiBmdW5jdGlvbiBvbk1vdW50KCkge30sXG4gIG9uU2hvdzogZnVuY3Rpb24gb25TaG93KCkge30sXG4gIG9uU2hvd246IGZ1bmN0aW9uIG9uU2hvd24oKSB7fSxcbiAgb25UcmlnZ2VyOiBmdW5jdGlvbiBvblRyaWdnZXIoKSB7fSxcbiAgb25VbnRyaWdnZXI6IGZ1bmN0aW9uIG9uVW50cmlnZ2VyKCkge30sXG4gIG9uQ2xpY2tPdXRzaWRlOiBmdW5jdGlvbiBvbkNsaWNrT3V0c2lkZSgpIHt9LFxuICBwbGFjZW1lbnQ6ICd0b3AnLFxuICBwbHVnaW5zOiBbXSxcbiAgcG9wcGVyT3B0aW9uczoge30sXG4gIHJlbmRlcjogbnVsbCxcbiAgc2hvd09uQ3JlYXRlOiBmYWxzZSxcbiAgdG91Y2g6IHRydWUsXG4gIHRyaWdnZXI6ICdtb3VzZWVudGVyIGZvY3VzJyxcbiAgdHJpZ2dlclRhcmdldDogbnVsbFxufSwgcGx1Z2luUHJvcHMsIHt9LCByZW5kZXJQcm9wcyk7XG52YXIgZGVmYXVsdEtleXMgPSBPYmplY3Qua2V5cyhkZWZhdWx0UHJvcHMpO1xudmFyIHNldERlZmF1bHRQcm9wcyA9IGZ1bmN0aW9uIHNldERlZmF1bHRQcm9wcyhwYXJ0aWFsUHJvcHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhbGlkYXRlUHJvcHMocGFydGlhbFByb3BzLCBbXSk7XG4gIH1cblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHBhcnRpYWxQcm9wcyk7XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgZGVmYXVsdFByb3BzW2tleV0gPSBwYXJ0aWFsUHJvcHNba2V5XTtcbiAgfSk7XG59O1xuZnVuY3Rpb24gZ2V0RXh0ZW5kZWRQYXNzZWRQcm9wcyhwYXNzZWRQcm9wcykge1xuICB2YXIgcGx1Z2lucyA9IHBhc3NlZFByb3BzLnBsdWdpbnMgfHwgW107XG4gIHZhciBwbHVnaW5Qcm9wcyA9IHBsdWdpbnMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsdWdpbikge1xuICAgIHZhciBuYW1lID0gcGx1Z2luLm5hbWUsXG4gICAgICAgIGRlZmF1bHRWYWx1ZSA9IHBsdWdpbi5kZWZhdWx0VmFsdWU7XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgYWNjW25hbWVdID0gcGFzc2VkUHJvcHNbbmFtZV0gIT09IHVuZGVmaW5lZCA/IHBhc3NlZFByb3BzW25hbWVdIDogZGVmYXVsdFZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHBhc3NlZFByb3BzLCB7fSwgcGx1Z2luUHJvcHMpO1xufVxuZnVuY3Rpb24gZ2V0RGF0YUF0dHJpYnV0ZVByb3BzKHJlZmVyZW5jZSwgcGx1Z2lucykge1xuICB2YXIgcHJvcEtleXMgPSBwbHVnaW5zID8gT2JqZWN0LmtleXMoZ2V0RXh0ZW5kZWRQYXNzZWRQcm9wcyhPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UHJvcHMsIHtcbiAgICBwbHVnaW5zOiBwbHVnaW5zXG4gIH0pKSkgOiBkZWZhdWx0S2V5cztcbiAgdmFyIHByb3BzID0gcHJvcEtleXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkge1xuICAgIHZhciB2YWx1ZUFzU3RyaW5nID0gKHJlZmVyZW5jZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRpcHB5LVwiICsga2V5KSB8fCAnJykudHJpbSgpO1xuXG4gICAgaWYgKCF2YWx1ZUFzU3RyaW5nKSB7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICdjb250ZW50Jykge1xuICAgICAgYWNjW2tleV0gPSB2YWx1ZUFzU3RyaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICBhY2Nba2V5XSA9IEpTT04ucGFyc2UodmFsdWVBc1N0cmluZyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGFjY1trZXldID0gdmFsdWVBc1N0cmluZztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIHJldHVybiBwcm9wcztcbn1cbmZ1bmN0aW9uIGV2YWx1YXRlUHJvcHMocmVmZXJlbmNlLCBwcm9wcykge1xuICB2YXIgb3V0ID0gT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICBjb250ZW50OiBpbnZva2VXaXRoQXJnc09yUmV0dXJuKHByb3BzLmNvbnRlbnQsIFtyZWZlcmVuY2VdKVxuICB9LCBwcm9wcy5pZ25vcmVBdHRyaWJ1dGVzID8ge30gOiBnZXREYXRhQXR0cmlidXRlUHJvcHMocmVmZXJlbmNlLCBwcm9wcy5wbHVnaW5zKSk7XG4gIG91dC5hcmlhID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFByb3BzLmFyaWEsIHt9LCBvdXQuYXJpYSk7XG4gIG91dC5hcmlhID0ge1xuICAgIGV4cGFuZGVkOiBvdXQuYXJpYS5leHBhbmRlZCA9PT0gJ2F1dG8nID8gcHJvcHMuaW50ZXJhY3RpdmUgOiBvdXQuYXJpYS5leHBhbmRlZCxcbiAgICBjb250ZW50OiBvdXQuYXJpYS5jb250ZW50ID09PSAnYXV0bycgPyBwcm9wcy5pbnRlcmFjdGl2ZSA/IG51bGwgOiAnZGVzY3JpYmVkYnknIDogb3V0LmFyaWEuY29udGVudFxuICB9O1xuICByZXR1cm4gb3V0O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wcyhwYXJ0aWFsUHJvcHMsIHBsdWdpbnMpIHtcbiAgaWYgKHBhcnRpYWxQcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcGFydGlhbFByb3BzID0ge307XG4gIH1cblxuICBpZiAocGx1Z2lucyA9PT0gdm9pZCAwKSB7XG4gICAgcGx1Z2lucyA9IFtdO1xuICB9XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwYXJ0aWFsUHJvcHMpO1xuICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICB2YXIgbm9uUGx1Z2luUHJvcHMgPSByZW1vdmVQcm9wZXJ0aWVzKGRlZmF1bHRQcm9wcywgT2JqZWN0LmtleXMocGx1Z2luUHJvcHMpKTtcbiAgICB2YXIgZGlkUGFzc1Vua25vd25Qcm9wID0gIWhhc093blByb3BlcnR5KG5vblBsdWdpblByb3BzLCBwcm9wKTsgLy8gQ2hlY2sgaWYgdGhlIHByb3AgZXhpc3RzIGluIGBwbHVnaW5zYFxuXG4gICAgaWYgKGRpZFBhc3NVbmtub3duUHJvcCkge1xuICAgICAgZGlkUGFzc1Vua25vd25Qcm9wID0gcGx1Z2lucy5maWx0ZXIoZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICByZXR1cm4gcGx1Z2luLm5hbWUgPT09IHByb3A7XG4gICAgICB9KS5sZW5ndGggPT09IDA7XG4gICAgfVxuXG4gICAgd2FybldoZW4oZGlkUGFzc1Vua25vd25Qcm9wLCBbXCJgXCIgKyBwcm9wICsgXCJgXCIsIFwiaXMgbm90IGEgdmFsaWQgcHJvcC4gWW91IG1heSBoYXZlIHNwZWxsZWQgaXQgaW5jb3JyZWN0bHksIG9yIGlmIGl0J3NcIiwgJ2EgcGx1Z2luLCBmb3Jnb3QgdG8gcGFzcyBpdCBpbiBhbiBhcnJheSBhcyBwcm9wcy5wbHVnaW5zLicsICdcXG5cXG4nLCAnQWxsIHByb3BzOiBodHRwczovL2F0b21pa3MuZ2l0aHViLmlvL3RpcHB5anMvdjYvYWxsLXByb3BzL1xcbicsICdQbHVnaW5zOiBodHRwczovL2F0b21pa3MuZ2l0aHViLmlvL3RpcHB5anMvdjYvcGx1Z2lucy8nXS5qb2luKCcgJykpO1xuICB9KTtcbn1cblxudmFyIGlubmVySFRNTCA9IGZ1bmN0aW9uIGlubmVySFRNTCgpIHtcbiAgcmV0dXJuICdpbm5lckhUTUwnO1xufTtcblxuZnVuY3Rpb24gZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwoZWxlbWVudCwgaHRtbCkge1xuICBlbGVtZW50W2lubmVySFRNTCgpXSA9IGh0bWw7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFycm93RWxlbWVudCh2YWx1ZSkge1xuICB2YXIgYXJyb3cgPSBkaXYoKTtcblxuICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICBhcnJvdy5jbGFzc05hbWUgPSBBUlJPV19DTEFTUztcbiAgfSBlbHNlIHtcbiAgICBhcnJvdy5jbGFzc05hbWUgPSBTVkdfQVJST1dfQ0xBU1M7XG5cbiAgICBpZiAoaXNFbGVtZW50KHZhbHVlKSkge1xuICAgICAgYXJyb3cuYXBwZW5kQ2hpbGQodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTChhcnJvdywgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhcnJvdztcbn1cblxuZnVuY3Rpb24gc2V0Q29udGVudChjb250ZW50LCBwcm9wcykge1xuICBpZiAoaXNFbGVtZW50KHByb3BzLmNvbnRlbnQpKSB7XG4gICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwoY29udGVudCwgJycpO1xuICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQocHJvcHMuY29udGVudCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb3BzLmNvbnRlbnQgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAocHJvcHMuYWxsb3dIVE1MKSB7XG4gICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTChjb250ZW50LCBwcm9wcy5jb250ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudC50ZXh0Q29udGVudCA9IHByb3BzLmNvbnRlbnQ7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRDaGlsZHJlbihwb3BwZXIpIHtcbiAgdmFyIGJveCA9IHBvcHBlci5maXJzdEVsZW1lbnRDaGlsZDtcbiAgdmFyIGJveENoaWxkcmVuID0gYXJyYXlGcm9tKGJveC5jaGlsZHJlbik7XG4gIHJldHVybiB7XG4gICAgYm94OiBib3gsXG4gICAgY29udGVudDogYm94Q2hpbGRyZW4uZmluZChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKENPTlRFTlRfQ0xBU1MpO1xuICAgIH0pLFxuICAgIGFycm93OiBib3hDaGlsZHJlbi5maW5kKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5jbGFzc0xpc3QuY29udGFpbnMoQVJST1dfQ0xBU1MpIHx8IG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKFNWR19BUlJPV19DTEFTUyk7XG4gICAgfSksXG4gICAgYmFja2Ryb3A6IGJveENoaWxkcmVuLmZpbmQoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLmNsYXNzTGlzdC5jb250YWlucyhCQUNLRFJPUF9DTEFTUyk7XG4gICAgfSlcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlbmRlcihpbnN0YW5jZSkge1xuICB2YXIgcG9wcGVyID0gZGl2KCk7XG4gIHZhciBib3ggPSBkaXYoKTtcbiAgYm94LmNsYXNzTmFtZSA9IEJPWF9DTEFTUztcbiAgYm94LnNldEF0dHJpYnV0ZSgnZGF0YS1zdGF0ZScsICdoaWRkZW4nKTtcbiAgYm94LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgdmFyIGNvbnRlbnQgPSBkaXYoKTtcbiAgY29udGVudC5jbGFzc05hbWUgPSBDT05URU5UX0NMQVNTO1xuICBjb250ZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1zdGF0ZScsICdoaWRkZW4nKTtcbiAgc2V0Q29udGVudChjb250ZW50LCBpbnN0YW5jZS5wcm9wcyk7XG4gIHBvcHBlci5hcHBlbmRDaGlsZChib3gpO1xuICBib3guYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gIG9uVXBkYXRlKGluc3RhbmNlLnByb3BzLCBpbnN0YW5jZS5wcm9wcyk7XG5cbiAgZnVuY3Rpb24gb25VcGRhdGUocHJldlByb3BzLCBuZXh0UHJvcHMpIHtcbiAgICB2YXIgX2dldENoaWxkcmVuID0gZ2V0Q2hpbGRyZW4ocG9wcGVyKSxcbiAgICAgICAgYm94ID0gX2dldENoaWxkcmVuLmJveCxcbiAgICAgICAgY29udGVudCA9IF9nZXRDaGlsZHJlbi5jb250ZW50LFxuICAgICAgICBhcnJvdyA9IF9nZXRDaGlsZHJlbi5hcnJvdztcblxuICAgIGlmIChuZXh0UHJvcHMudGhlbWUpIHtcbiAgICAgIGJveC5zZXRBdHRyaWJ1dGUoJ2RhdGEtdGhlbWUnLCBuZXh0UHJvcHMudGhlbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3gucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXRoZW1lJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXh0UHJvcHMuYW5pbWF0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgYm94LnNldEF0dHJpYnV0ZSgnZGF0YS1hbmltYXRpb24nLCBuZXh0UHJvcHMuYW5pbWF0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm94LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1hbmltYXRpb24nKTtcbiAgICB9XG5cbiAgICBpZiAobmV4dFByb3BzLmluZXJ0aWEpIHtcbiAgICAgIGJveC5zZXRBdHRyaWJ1dGUoJ2RhdGEtaW5lcnRpYScsICcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm94LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1pbmVydGlhJyk7XG4gICAgfVxuXG4gICAgYm94LnN0eWxlLm1heFdpZHRoID0gdHlwZW9mIG5leHRQcm9wcy5tYXhXaWR0aCA9PT0gJ251bWJlcicgPyBuZXh0UHJvcHMubWF4V2lkdGggKyBcInB4XCIgOiBuZXh0UHJvcHMubWF4V2lkdGg7XG5cbiAgICBpZiAobmV4dFByb3BzLnJvbGUpIHtcbiAgICAgIGJveC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCBuZXh0UHJvcHMucm9sZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJveC5yZW1vdmVBdHRyaWJ1dGUoJ3JvbGUnKTtcbiAgICB9XG5cbiAgICBpZiAocHJldlByb3BzLmNvbnRlbnQgIT09IG5leHRQcm9wcy5jb250ZW50IHx8IHByZXZQcm9wcy5hbGxvd0hUTUwgIT09IG5leHRQcm9wcy5hbGxvd0hUTUwpIHtcbiAgICAgIHNldENvbnRlbnQoY29udGVudCwgaW5zdGFuY2UucHJvcHMpO1xuICAgIH1cblxuICAgIGlmIChuZXh0UHJvcHMuYXJyb3cpIHtcbiAgICAgIGlmICghYXJyb3cpIHtcbiAgICAgICAgYm94LmFwcGVuZENoaWxkKGNyZWF0ZUFycm93RWxlbWVudChuZXh0UHJvcHMuYXJyb3cpKTtcbiAgICAgIH0gZWxzZSBpZiAocHJldlByb3BzLmFycm93ICE9PSBuZXh0UHJvcHMuYXJyb3cpIHtcbiAgICAgICAgYm94LnJlbW92ZUNoaWxkKGFycm93KTtcbiAgICAgICAgYm94LmFwcGVuZENoaWxkKGNyZWF0ZUFycm93RWxlbWVudChuZXh0UHJvcHMuYXJyb3cpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFycm93KSB7XG4gICAgICBib3gucmVtb3ZlQ2hpbGQoYXJyb3cpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcG9wcGVyOiBwb3BwZXIsXG4gICAgb25VcGRhdGU6IG9uVXBkYXRlXG4gIH07XG59IC8vIFJ1bnRpbWUgY2hlY2sgdG8gaWRlbnRpZnkgaWYgdGhlIHJlbmRlciBmdW5jdGlvbiBpcyB0aGUgZGVmYXVsdCBvbmU7IHRoaXNcbi8vIHdheSB3ZSBjYW4gYXBwbHkgZGVmYXVsdCBDU1MgdHJhbnNpdGlvbnMgbG9naWMgYW5kIGl0IGNhbiBiZSB0cmVlLXNoYWtlbiBhd2F5XG5cbnJlbmRlci4kJHRpcHB5ID0gdHJ1ZTtcblxudmFyIGlkQ291bnRlciA9IDE7XG52YXIgbW91c2VNb3ZlTGlzdGVuZXJzID0gW107IC8vIFVzZWQgYnkgYGhpZGVBbGwoKWBcblxudmFyIG1vdW50ZWRJbnN0YW5jZXMgPSBbXTtcbmZ1bmN0aW9uIGNyZWF0ZVRpcHB5KHJlZmVyZW5jZSwgcGFzc2VkUHJvcHMpIHtcbiAgdmFyIHByb3BzID0gZXZhbHVhdGVQcm9wcyhyZWZlcmVuY2UsIE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQcm9wcywge30sIGdldEV4dGVuZGVkUGFzc2VkUHJvcHMocGFzc2VkUHJvcHMpKSk7IC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyDwn5SSIFByaXZhdGUgbWVtYmVyc1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgc2hvd1RpbWVvdXQ7XG4gIHZhciBoaWRlVGltZW91dDtcbiAgdmFyIHNjaGVkdWxlSGlkZUFuaW1hdGlvbkZyYW1lO1xuICB2YXIgaXNWaXNpYmxlRnJvbUNsaWNrID0gZmFsc2U7XG4gIHZhciBkaWRIaWRlRHVlVG9Eb2N1bWVudE1vdXNlRG93biA9IGZhbHNlO1xuICB2YXIgZGlkVG91Y2hNb3ZlID0gZmFsc2U7XG4gIHZhciBpZ25vcmVPbkZpcnN0VXBkYXRlID0gZmFsc2U7XG4gIHZhciBsYXN0VHJpZ2dlckV2ZW50O1xuICB2YXIgY3VycmVudFRyYW5zaXRpb25FbmRMaXN0ZW5lcjtcbiAgdmFyIG9uRmlyc3RVcGRhdGU7XG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIGRlYm91bmNlZE9uTW91c2VNb3ZlID0gZGVib3VuY2Uob25Nb3VzZU1vdmUsIHByb3BzLmludGVyYWN0aXZlRGVib3VuY2UpO1xuICB2YXIgY3VycmVudFRhcmdldDtcbiAgdmFyIGRvYyA9IGdldE93bmVyRG9jdW1lbnQocHJvcHMudHJpZ2dlclRhcmdldCB8fCByZWZlcmVuY2UpOyAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8g8J+UkSBQdWJsaWMgbWVtYmVyc1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgaWQgPSBpZENvdW50ZXIrKztcbiAgdmFyIHBvcHBlckluc3RhbmNlID0gbnVsbDtcbiAgdmFyIHBsdWdpbnMgPSB1bmlxdWUocHJvcHMucGx1Z2lucyk7XG4gIHZhciBzdGF0ZSA9IHtcbiAgICAvLyBJcyB0aGUgaW5zdGFuY2UgY3VycmVudGx5IGVuYWJsZWQ/XG4gICAgaXNFbmFibGVkOiB0cnVlLFxuICAgIC8vIElzIHRoZSB0aXBweSBjdXJyZW50bHkgc2hvd2luZyBhbmQgbm90IHRyYW5zaXRpb25pbmcgb3V0P1xuICAgIGlzVmlzaWJsZTogZmFsc2UsXG4gICAgLy8gSGFzIHRoZSBpbnN0YW5jZSBiZWVuIGRlc3Ryb3llZD9cbiAgICBpc0Rlc3Ryb3llZDogZmFsc2UsXG4gICAgLy8gSXMgdGhlIHRpcHB5IGN1cnJlbnRseSBtb3VudGVkIHRvIHRoZSBET00/XG4gICAgaXNNb3VudGVkOiBmYWxzZSxcbiAgICAvLyBIYXMgdGhlIHRpcHB5IGZpbmlzaGVkIHRyYW5zaXRpb25pbmcgaW4/XG4gICAgaXNTaG93bjogZmFsc2VcbiAgfTtcbiAgdmFyIGluc3RhbmNlID0ge1xuICAgIC8vIHByb3BlcnRpZXNcbiAgICBpZDogaWQsXG4gICAgcmVmZXJlbmNlOiByZWZlcmVuY2UsXG4gICAgcG9wcGVyOiBkaXYoKSxcbiAgICBwb3BwZXJJbnN0YW5jZTogcG9wcGVySW5zdGFuY2UsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIHN0YXRlOiBzdGF0ZSxcbiAgICBwbHVnaW5zOiBwbHVnaW5zLFxuICAgIC8vIG1ldGhvZHNcbiAgICBjbGVhckRlbGF5VGltZW91dHM6IGNsZWFyRGVsYXlUaW1lb3V0cyxcbiAgICBzZXRQcm9wczogc2V0UHJvcHMsXG4gICAgc2V0Q29udGVudDogc2V0Q29udGVudCxcbiAgICBzaG93OiBzaG93LFxuICAgIGhpZGU6IGhpZGUsXG4gICAgaGlkZVdpdGhJbnRlcmFjdGl2aXR5OiBoaWRlV2l0aEludGVyYWN0aXZpdHksXG4gICAgZW5hYmxlOiBlbmFibGUsXG4gICAgZGlzYWJsZTogZGlzYWJsZSxcbiAgICB1bm1vdW50OiB1bm1vdW50LFxuICAgIGRlc3Ryb3k6IGRlc3Ryb3lcbiAgfTsgLy8gVE9ETzogSW52ZXN0aWdhdGUgd2h5IHRoaXMgZWFybHkgcmV0dXJuIGNhdXNlcyBhIFREWiBlcnJvciBpbiB0aGUgdGVzdHMg4oCUXG4gIC8vIGl0IGRvZXNuJ3Qgc2VlbSB0byBoYXBwZW4gaW4gdGhlIGJyb3dzZXJcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblxuICBpZiAoIXByb3BzLnJlbmRlcikge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGVycm9yV2hlbih0cnVlLCAncmVuZGVyKCkgZnVuY3Rpb24gaGFzIG5vdCBiZWVuIHN1cHBsaWVkLicpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gSW5pdGlhbCBtdXRhdGlvbnNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICB2YXIgX3Byb3BzJHJlbmRlciA9IHByb3BzLnJlbmRlcihpbnN0YW5jZSksXG4gICAgICBwb3BwZXIgPSBfcHJvcHMkcmVuZGVyLnBvcHBlcixcbiAgICAgIG9uVXBkYXRlID0gX3Byb3BzJHJlbmRlci5vblVwZGF0ZTtcblxuICBwb3BwZXIuc2V0QXR0cmlidXRlKCdkYXRhLXRpcHB5LXJvb3QnLCAnJyk7XG4gIHBvcHBlci5pZCA9IFwidGlwcHktXCIgKyBpbnN0YW5jZS5pZDtcbiAgaW5zdGFuY2UucG9wcGVyID0gcG9wcGVyO1xuICByZWZlcmVuY2UuX3RpcHB5ID0gaW5zdGFuY2U7XG4gIHBvcHBlci5fdGlwcHkgPSBpbnN0YW5jZTtcbiAgdmFyIHBsdWdpbnNIb29rcyA9IHBsdWdpbnMubWFwKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICByZXR1cm4gcGx1Z2luLmZuKGluc3RhbmNlKTtcbiAgfSk7XG4gIHZhciBoYXNBcmlhRXhwYW5kZWQgPSByZWZlcmVuY2UuaGFzQXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJyk7XG4gIGFkZExpc3RlbmVycygpO1xuICBoYW5kbGVBcmlhRXhwYW5kZWRBdHRyaWJ1dGUoKTtcbiAgaGFuZGxlU3R5bGVzKCk7XG4gIGludm9rZUhvb2soJ29uQ3JlYXRlJywgW2luc3RhbmNlXSk7XG5cbiAgaWYgKHByb3BzLnNob3dPbkNyZWF0ZSkge1xuICAgIHNjaGVkdWxlU2hvdygpO1xuICB9IC8vIFByZXZlbnQgYSB0aXBweSB3aXRoIGEgZGVsYXkgZnJvbSBoaWRpbmcgaWYgdGhlIGN1cnNvciBsZWZ0IHRoZW4gcmV0dXJuZWRcbiAgLy8gYmVmb3JlIGl0IHN0YXJ0ZWQgaGlkaW5nXG5cblxuICBwb3BwZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUgJiYgaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICBpbnN0YW5jZS5jbGVhckRlbGF5VGltZW91dHMoKTtcbiAgICB9XG4gIH0pO1xuICBwb3BwZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZSAmJiBpbnN0YW5jZS5wcm9wcy50cmlnZ2VyLmluZGV4T2YoJ21vdXNlZW50ZXInKSA+PSAwKSB7XG4gICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZGVib3VuY2VkT25Nb3VzZU1vdmUpO1xuICAgICAgZGVib3VuY2VkT25Nb3VzZU1vdmUoZXZlbnQpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBpbnN0YW5jZTsgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIPCflJIgUHJpdmF0ZSBtZXRob2RzXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIGdldE5vcm1hbGl6ZWRUb3VjaFNldHRpbmdzKCkge1xuICAgIHZhciB0b3VjaCA9IGluc3RhbmNlLnByb3BzLnRvdWNoO1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRvdWNoKSA/IHRvdWNoIDogW3RvdWNoLCAwXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldElzQ3VzdG9tVG91Y2hCZWhhdmlvcigpIHtcbiAgICByZXR1cm4gZ2V0Tm9ybWFsaXplZFRvdWNoU2V0dGluZ3MoKVswXSA9PT0gJ2hvbGQnO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKSB7XG4gICAgdmFyIF9pbnN0YW5jZSRwcm9wcyRyZW5kZTtcblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gISEoKF9pbnN0YW5jZSRwcm9wcyRyZW5kZSA9IGluc3RhbmNlLnByb3BzLnJlbmRlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbnN0YW5jZSRwcm9wcyRyZW5kZS4kJHRpcHB5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEN1cnJlbnRUYXJnZXQoKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRUYXJnZXQgfHwgcmVmZXJlbmNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RGVmYXVsdFRlbXBsYXRlQ2hpbGRyZW4oKSB7XG4gICAgcmV0dXJuIGdldENoaWxkcmVuKHBvcHBlcik7XG4gIH1cblxuICBmdW5jdGlvbiBnZXREZWxheShpc1Nob3cpIHtcbiAgICAvLyBGb3IgdG91Y2ggb3Iga2V5Ym9hcmQgaW5wdXQsIGZvcmNlIGAwYCBkZWxheSBmb3IgVVggcmVhc29uc1xuICAgIC8vIEFsc28gaWYgdGhlIGluc3RhbmNlIGlzIG1vdW50ZWQgYnV0IG5vdCB2aXNpYmxlICh0cmFuc2l0aW9uaW5nIG91dCksXG4gICAgLy8gaWdub3JlIGRlbGF5XG4gICAgaWYgKGluc3RhbmNlLnN0YXRlLmlzTW91bnRlZCAmJiAhaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlIHx8IGN1cnJlbnRJbnB1dC5pc1RvdWNoIHx8IGxhc3RUcmlnZ2VyRXZlbnQgJiYgbGFzdFRyaWdnZXJFdmVudC50eXBlID09PSAnZm9jdXMnKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0VmFsdWVBdEluZGV4T3JSZXR1cm4oaW5zdGFuY2UucHJvcHMuZGVsYXksIGlzU2hvdyA/IDAgOiAxLCBkZWZhdWx0UHJvcHMuZGVsYXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlU3R5bGVzKCkge1xuICAgIHBvcHBlci5zdHlsZS5wb2ludGVyRXZlbnRzID0gaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUgJiYgaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlID8gJycgOiAnbm9uZSc7XG4gICAgcG9wcGVyLnN0eWxlLnpJbmRleCA9IFwiXCIgKyBpbnN0YW5jZS5wcm9wcy56SW5kZXg7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VIb29rKGhvb2ssIGFyZ3MsIHNob3VsZEludm9rZVByb3BzSG9vaykge1xuICAgIGlmIChzaG91bGRJbnZva2VQcm9wc0hvb2sgPT09IHZvaWQgMCkge1xuICAgICAgc2hvdWxkSW52b2tlUHJvcHNIb29rID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBwbHVnaW5zSG9va3MuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luSG9va3MpIHtcbiAgICAgIGlmIChwbHVnaW5Ib29rc1tob29rXSkge1xuICAgICAgICBwbHVnaW5Ib29rc1tob29rXS5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHNob3VsZEludm9rZVByb3BzSG9vaykge1xuICAgICAgdmFyIF9pbnN0YW5jZSRwcm9wcztcblxuICAgICAgKF9pbnN0YW5jZSRwcm9wcyA9IGluc3RhbmNlLnByb3BzKVtob29rXS5hcHBseShfaW5zdGFuY2UkcHJvcHMsIGFyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUFyaWFDb250ZW50QXR0cmlidXRlKCkge1xuICAgIHZhciBhcmlhID0gaW5zdGFuY2UucHJvcHMuYXJpYTtcblxuICAgIGlmICghYXJpYS5jb250ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGF0dHIgPSBcImFyaWEtXCIgKyBhcmlhLmNvbnRlbnQ7XG4gICAgdmFyIGlkID0gcG9wcGVyLmlkO1xuICAgIHZhciBub2RlcyA9IG5vcm1hbGl6ZVRvQXJyYXkoaW5zdGFuY2UucHJvcHMudHJpZ2dlclRhcmdldCB8fCByZWZlcmVuY2UpO1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHZhciBjdXJyZW50VmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShhdHRyKTtcblxuICAgICAgaWYgKGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyLCBjdXJyZW50VmFsdWUgPyBjdXJyZW50VmFsdWUgKyBcIiBcIiArIGlkIDogaWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5leHRWYWx1ZSA9IGN1cnJlbnRWYWx1ZSAmJiBjdXJyZW50VmFsdWUucmVwbGFjZShpZCwgJycpLnRyaW0oKTtcblxuICAgICAgICBpZiAobmV4dFZhbHVlKSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0ciwgbmV4dFZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQXJpYUV4cGFuZGVkQXR0cmlidXRlKCkge1xuICAgIGlmIChoYXNBcmlhRXhwYW5kZWQgfHwgIWluc3RhbmNlLnByb3BzLmFyaWEuZXhwYW5kZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbm9kZXMgPSBub3JtYWxpemVUb0FycmF5KGluc3RhbmNlLnByb3BzLnRyaWdnZXJUYXJnZXQgfHwgcmVmZXJlbmNlKTtcbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBpZiAoaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCBpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUgJiYgbm9kZSA9PT0gZ2V0Q3VycmVudFRhcmdldCgpID8gJ3RydWUnIDogJ2ZhbHNlJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYW51cEludGVyYWN0aXZlTW91c2VMaXN0ZW5lcnMoKSB7XG4gICAgZG9jLmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHNjaGVkdWxlSGlkZSk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGRlYm91bmNlZE9uTW91c2VNb3ZlKTtcbiAgICBtb3VzZU1vdmVMaXN0ZW5lcnMgPSBtb3VzZU1vdmVMaXN0ZW5lcnMuZmlsdGVyKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGxpc3RlbmVyICE9PSBkZWJvdW5jZWRPbk1vdXNlTW92ZTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRG9jdW1lbnRQcmVzcyhldmVudCkge1xuICAgIC8vIE1vdmVkIGZpbmdlciB0byBzY3JvbGwgaW5zdGVhZCBvZiBhbiBpbnRlbnRpb25hbCB0YXAgb3V0c2lkZVxuICAgIGlmIChjdXJyZW50SW5wdXQuaXNUb3VjaCkge1xuICAgICAgaWYgKGRpZFRvdWNoTW92ZSB8fCBldmVudC50eXBlID09PSAnbW91c2Vkb3duJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSAvLyBDbGlja2VkIG9uIGludGVyYWN0aXZlIHBvcHBlclxuXG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUgJiYgcG9wcGVyLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIENsaWNrZWQgb24gdGhlIGV2ZW50IGxpc3RlbmVycyB0YXJnZXRcblxuXG4gICAgaWYgKGdldEN1cnJlbnRUYXJnZXQoKS5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICBpZiAoY3VycmVudElucHV0LmlzVG91Y2gpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlICYmIGluc3RhbmNlLnByb3BzLnRyaWdnZXIuaW5kZXhPZignY2xpY2snKSA+PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaW52b2tlSG9vaygnb25DbGlja091dHNpZGUnLCBbaW5zdGFuY2UsIGV2ZW50XSk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzLmhpZGVPbkNsaWNrID09PSB0cnVlKSB7XG4gICAgICBpc1Zpc2libGVGcm9tQ2xpY2sgPSBmYWxzZTtcbiAgICAgIGluc3RhbmNlLmNsZWFyRGVsYXlUaW1lb3V0cygpO1xuICAgICAgaW5zdGFuY2UuaGlkZSgpOyAvLyBgbW91c2Vkb3duYCBldmVudCBpcyBmaXJlZCByaWdodCBiZWZvcmUgYGZvY3VzYCBpZiBwcmVzc2luZyB0aGVcbiAgICAgIC8vIGN1cnJlbnRUYXJnZXQuIFRoaXMgbGV0cyBhIHRpcHB5IHdpdGggYGZvY3VzYCB0cmlnZ2VyIGtub3cgdGhhdCBpdFxuICAgICAgLy8gc2hvdWxkIG5vdCBzaG93XG5cbiAgICAgIGRpZEhpZGVEdWVUb0RvY3VtZW50TW91c2VEb3duID0gdHJ1ZTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBkaWRIaWRlRHVlVG9Eb2N1bWVudE1vdXNlRG93biA9IGZhbHNlO1xuICAgICAgfSk7IC8vIFRoZSBsaXN0ZW5lciBnZXRzIGFkZGVkIGluIGBzY2hlZHVsZVNob3coKWAsIGJ1dCB0aGlzIG1heSBiZSBoaWRpbmcgaXRcbiAgICAgIC8vIGJlZm9yZSBpdCBzaG93cywgYW5kIGhpZGUoKSdzIGVhcmx5IGJhaWwtb3V0IGJlaGF2aW9yIGNhbiBwcmV2ZW50IGl0XG4gICAgICAvLyBmcm9tIGJlaW5nIGNsZWFuZWQgdXBcblxuICAgICAgaWYgKCFpbnN0YW5jZS5zdGF0ZS5pc01vdW50ZWQpIHtcbiAgICAgICAgcmVtb3ZlRG9jdW1lbnRQcmVzcygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVG91Y2hNb3ZlKCkge1xuICAgIGRpZFRvdWNoTW92ZSA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBvblRvdWNoU3RhcnQoKSB7XG4gICAgZGlkVG91Y2hNb3ZlID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBhZGREb2N1bWVudFByZXNzKCkge1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvbkRvY3VtZW50UHJlc3MsIHRydWUpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uRG9jdW1lbnRQcmVzcywgVE9VQ0hfT1BUSU9OUyk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBvblRvdWNoU3RhcnQsIFRPVUNIX09QVElPTlMpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSwgVE9VQ0hfT1BUSU9OUyk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVEb2N1bWVudFByZXNzKCkge1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvbkRvY3VtZW50UHJlc3MsIHRydWUpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uRG9jdW1lbnRQcmVzcywgVE9VQ0hfT1BUSU9OUyk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBvblRvdWNoU3RhcnQsIFRPVUNIX09QVElPTlMpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSwgVE9VQ0hfT1BUSU9OUyk7XG4gIH1cblxuICBmdW5jdGlvbiBvblRyYW5zaXRpb25lZE91dChkdXJhdGlvbiwgY2FsbGJhY2spIHtcbiAgICBvblRyYW5zaXRpb25FbmQoZHVyYXRpb24sIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlICYmIHBvcHBlci5wYXJlbnROb2RlICYmIHBvcHBlci5wYXJlbnROb2RlLmNvbnRhaW5zKHBvcHBlcikpIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVHJhbnNpdGlvbmVkSW4oZHVyYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgb25UcmFuc2l0aW9uRW5kKGR1cmF0aW9uLCBjYWxsYmFjayk7XG4gIH1cblxuICBmdW5jdGlvbiBvblRyYW5zaXRpb25FbmQoZHVyYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgdmFyIGJveCA9IGdldERlZmF1bHRUZW1wbGF0ZUNoaWxkcmVuKCkuYm94O1xuXG4gICAgZnVuY3Rpb24gbGlzdGVuZXIoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC50YXJnZXQgPT09IGJveCkge1xuICAgICAgICB1cGRhdGVUcmFuc2l0aW9uRW5kTGlzdGVuZXIoYm94LCAncmVtb3ZlJywgbGlzdGVuZXIpO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH0gLy8gTWFrZSBjYWxsYmFjayBzeW5jaHJvbm91cyBpZiBkdXJhdGlvbiBpcyAwXG4gICAgLy8gYHRyYW5zaXRpb25lbmRgIHdvbid0IGZpcmUgb3RoZXJ3aXNlXG5cblxuICAgIGlmIChkdXJhdGlvbiA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlVHJhbnNpdGlvbkVuZExpc3RlbmVyKGJveCwgJ3JlbW92ZScsIGN1cnJlbnRUcmFuc2l0aW9uRW5kTGlzdGVuZXIpO1xuICAgIHVwZGF0ZVRyYW5zaXRpb25FbmRMaXN0ZW5lcihib3gsICdhZGQnLCBsaXN0ZW5lcik7XG4gICAgY3VycmVudFRyYW5zaXRpb25FbmRMaXN0ZW5lciA9IGxpc3RlbmVyO1xuICB9XG5cbiAgZnVuY3Rpb24gb24oZXZlbnRUeXBlLCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBub2RlcyA9IG5vcm1hbGl6ZVRvQXJyYXkoaW5zdGFuY2UucHJvcHMudHJpZ2dlclRhcmdldCB8fCByZWZlcmVuY2UpO1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgICAgbGlzdGVuZXJzLnB1c2goe1xuICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICBldmVudFR5cGU6IGV2ZW50VHlwZSxcbiAgICAgICAgaGFuZGxlcjogaGFuZGxlcixcbiAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKGdldElzQ3VzdG9tVG91Y2hCZWhhdmlvcigpKSB7XG4gICAgICBvbigndG91Y2hzdGFydCcsIG9uVHJpZ2dlciwge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIG9uKCd0b3VjaGVuZCcsIG9uTW91c2VMZWF2ZSwge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBzcGxpdEJ5U3BhY2VzKGluc3RhbmNlLnByb3BzLnRyaWdnZXIpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50VHlwZSkge1xuICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gJ21hbnVhbCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBvbihldmVudFR5cGUsIG9uVHJpZ2dlcik7XG5cbiAgICAgIHN3aXRjaCAoZXZlbnRUeXBlKSB7XG4gICAgICAgIGNhc2UgJ21vdXNlZW50ZXInOlxuICAgICAgICAgIG9uKCdtb3VzZWxlYXZlJywgb25Nb3VzZUxlYXZlKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmb2N1cyc6XG4gICAgICAgICAgb24oaXNJRSA/ICdmb2N1c291dCcgOiAnYmx1cicsIG9uQmx1ck9yRm9jdXNPdXQpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2ZvY3VzaW4nOlxuICAgICAgICAgIG9uKCdmb2N1c291dCcsIG9uQmx1ck9yRm9jdXNPdXQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzKCkge1xuICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgbm9kZSA9IF9yZWYubm9kZSxcbiAgICAgICAgICBldmVudFR5cGUgPSBfcmVmLmV2ZW50VHlwZSxcbiAgICAgICAgICBoYW5kbGVyID0gX3JlZi5oYW5kbGVyLFxuICAgICAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XG4gICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgICBsaXN0ZW5lcnMgPSBbXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVHJpZ2dlcihldmVudCkge1xuICAgIHZhciBfbGFzdFRyaWdnZXJFdmVudDtcblxuICAgIHZhciBzaG91bGRTY2hlZHVsZUNsaWNrSGlkZSA9IGZhbHNlO1xuXG4gICAgaWYgKCFpbnN0YW5jZS5zdGF0ZS5pc0VuYWJsZWQgfHwgaXNFdmVudExpc3RlbmVyU3RvcHBlZChldmVudCkgfHwgZGlkSGlkZUR1ZVRvRG9jdW1lbnRNb3VzZURvd24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgd2FzRm9jdXNlZCA9ICgoX2xhc3RUcmlnZ2VyRXZlbnQgPSBsYXN0VHJpZ2dlckV2ZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2xhc3RUcmlnZ2VyRXZlbnQudHlwZSkgPT09ICdmb2N1cyc7XG4gICAgbGFzdFRyaWdnZXJFdmVudCA9IGV2ZW50O1xuICAgIGN1cnJlbnRUYXJnZXQgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgIGhhbmRsZUFyaWFFeHBhbmRlZEF0dHJpYnV0ZSgpO1xuXG4gICAgaWYgKCFpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUgJiYgaXNNb3VzZUV2ZW50KGV2ZW50KSkge1xuICAgICAgLy8gSWYgc2Nyb2xsaW5nLCBgbW91c2VlbnRlcmAgZXZlbnRzIGNhbiBiZSBmaXJlZCBpZiB0aGUgY3Vyc29yIGxhbmRzXG4gICAgICAvLyBvdmVyIGEgbmV3IHRhcmdldCwgYnV0IGBtb3VzZW1vdmVgIGV2ZW50cyBkb24ndCBnZXQgZmlyZWQuIFRoaXNcbiAgICAgIC8vIGNhdXNlcyBpbnRlcmFjdGl2ZSB0b29sdGlwcyB0byBnZXQgc3R1Y2sgb3BlbiB1bnRpbCB0aGUgY3Vyc29yIGlzXG4gICAgICAvLyBtb3ZlZFxuICAgICAgbW91c2VNb3ZlTGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBsaXN0ZW5lcihldmVudCk7XG4gICAgICB9KTtcbiAgICB9IC8vIFRvZ2dsZSBzaG93L2hpZGUgd2hlbiBjbGlja2luZyBjbGljay10cmlnZ2VyZWQgdG9vbHRpcHNcblxuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdjbGljaycgJiYgKGluc3RhbmNlLnByb3BzLnRyaWdnZXIuaW5kZXhPZignbW91c2VlbnRlcicpIDwgMCB8fCBpc1Zpc2libGVGcm9tQ2xpY2spICYmIGluc3RhbmNlLnByb3BzLmhpZGVPbkNsaWNrICE9PSBmYWxzZSAmJiBpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUpIHtcbiAgICAgIHNob3VsZFNjaGVkdWxlQ2xpY2tIaWRlID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZWR1bGVTaG93KGV2ZW50KTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2NsaWNrJykge1xuICAgICAgaXNWaXNpYmxlRnJvbUNsaWNrID0gIXNob3VsZFNjaGVkdWxlQ2xpY2tIaWRlO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRTY2hlZHVsZUNsaWNrSGlkZSAmJiAhd2FzRm9jdXNlZCkge1xuICAgICAgc2NoZWR1bGVIaWRlKGV2ZW50KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbk1vdXNlTW92ZShldmVudCkge1xuICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgdmFyIGlzQ3Vyc29yT3ZlclJlZmVyZW5jZU9yUG9wcGVyID0gcmVmZXJlbmNlLmNvbnRhaW5zKHRhcmdldCkgfHwgcG9wcGVyLmNvbnRhaW5zKHRhcmdldCk7XG5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ21vdXNlbW92ZScgJiYgaXNDdXJzb3JPdmVyUmVmZXJlbmNlT3JQb3BwZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcG9wcGVyVHJlZURhdGEgPSBnZXROZXN0ZWRQb3BwZXJUcmVlKCkuY29uY2F0KHBvcHBlcikubWFwKGZ1bmN0aW9uIChwb3BwZXIpIHtcbiAgICAgIHZhciBfaW5zdGFuY2UkcG9wcGVySW5zdGE7XG5cbiAgICAgIHZhciBpbnN0YW5jZSA9IHBvcHBlci5fdGlwcHk7XG4gICAgICB2YXIgc3RhdGUgPSAoX2luc3RhbmNlJHBvcHBlckluc3RhID0gaW5zdGFuY2UucG9wcGVySW5zdGFuY2UpID09IG51bGwgPyB2b2lkIDAgOiBfaW5zdGFuY2UkcG9wcGVySW5zdGEuc3RhdGU7XG5cbiAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBvcHBlclJlY3Q6IHBvcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICBwb3BwZXJTdGF0ZTogc3RhdGUsXG4gICAgICAgICAgcHJvcHM6IHByb3BzXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0pLmZpbHRlcihCb29sZWFuKTtcblxuICAgIGlmIChpc0N1cnNvck91dHNpZGVJbnRlcmFjdGl2ZUJvcmRlcihwb3BwZXJUcmVlRGF0YSwgZXZlbnQpKSB7XG4gICAgICBjbGVhbnVwSW50ZXJhY3RpdmVNb3VzZUxpc3RlbmVycygpO1xuICAgICAgc2NoZWR1bGVIaWRlKGV2ZW50KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbk1vdXNlTGVhdmUoZXZlbnQpIHtcbiAgICB2YXIgc2hvdWxkQmFpbCA9IGlzRXZlbnRMaXN0ZW5lclN0b3BwZWQoZXZlbnQpIHx8IGluc3RhbmNlLnByb3BzLnRyaWdnZXIuaW5kZXhPZignY2xpY2snKSA+PSAwICYmIGlzVmlzaWJsZUZyb21DbGljaztcblxuICAgIGlmIChzaG91bGRCYWlsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlKSB7XG4gICAgICBpbnN0YW5jZS5oaWRlV2l0aEludGVyYWN0aXZpdHkoZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNjaGVkdWxlSGlkZShldmVudCk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkJsdXJPckZvY3VzT3V0KGV2ZW50KSB7XG4gICAgaWYgKGluc3RhbmNlLnByb3BzLnRyaWdnZXIuaW5kZXhPZignZm9jdXNpbicpIDwgMCAmJiBldmVudC50YXJnZXQgIT09IGdldEN1cnJlbnRUYXJnZXQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gSWYgZm9jdXMgd2FzIG1vdmVkIHRvIHdpdGhpbiB0aGUgcG9wcGVyXG5cblxuICAgIGlmIChpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZSAmJiBldmVudC5yZWxhdGVkVGFyZ2V0ICYmIHBvcHBlci5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNjaGVkdWxlSGlkZShldmVudCk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0V2ZW50TGlzdGVuZXJTdG9wcGVkKGV2ZW50KSB7XG4gICAgcmV0dXJuIGN1cnJlbnRJbnB1dC5pc1RvdWNoID8gZ2V0SXNDdXN0b21Ub3VjaEJlaGF2aW9yKCkgIT09IGV2ZW50LnR5cGUuaW5kZXhPZigndG91Y2gnKSA+PSAwIDogZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQb3BwZXJJbnN0YW5jZSgpIHtcbiAgICBkZXN0cm95UG9wcGVySW5zdGFuY2UoKTtcbiAgICB2YXIgX2luc3RhbmNlJHByb3BzMiA9IGluc3RhbmNlLnByb3BzLFxuICAgICAgICBwb3BwZXJPcHRpb25zID0gX2luc3RhbmNlJHByb3BzMi5wb3BwZXJPcHRpb25zLFxuICAgICAgICBwbGFjZW1lbnQgPSBfaW5zdGFuY2UkcHJvcHMyLnBsYWNlbWVudCxcbiAgICAgICAgb2Zmc2V0ID0gX2luc3RhbmNlJHByb3BzMi5vZmZzZXQsXG4gICAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3QgPSBfaW5zdGFuY2UkcHJvcHMyLmdldFJlZmVyZW5jZUNsaWVudFJlY3QsXG4gICAgICAgIG1vdmVUcmFuc2l0aW9uID0gX2luc3RhbmNlJHByb3BzMi5tb3ZlVHJhbnNpdGlvbjtcbiAgICB2YXIgYXJyb3cgPSBnZXRJc0RlZmF1bHRSZW5kZXJGbigpID8gZ2V0Q2hpbGRyZW4ocG9wcGVyKS5hcnJvdyA6IG51bGw7XG4gICAgdmFyIGNvbXB1dGVkUmVmZXJlbmNlID0gZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdCA/IHtcbiAgICAgIGdldEJvdW5kaW5nQ2xpZW50UmVjdDogZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdCxcbiAgICAgIGNvbnRleHRFbGVtZW50OiBnZXRSZWZlcmVuY2VDbGllbnRSZWN0LmNvbnRleHRFbGVtZW50IHx8IGdldEN1cnJlbnRUYXJnZXQoKVxuICAgIH0gOiByZWZlcmVuY2U7XG4gICAgdmFyIHRpcHB5TW9kaWZpZXIgPSB7XG4gICAgICBuYW1lOiAnJCR0aXBweScsXG4gICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgcGhhc2U6ICdiZWZvcmVXcml0ZScsXG4gICAgICByZXF1aXJlczogWydjb21wdXRlU3R5bGVzJ10sXG4gICAgICBmbjogZnVuY3Rpb24gZm4oX3JlZjIpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGU7XG5cbiAgICAgICAgaWYgKGdldElzRGVmYXVsdFJlbmRlckZuKCkpIHtcbiAgICAgICAgICB2YXIgX2dldERlZmF1bHRUZW1wbGF0ZUNoID0gZ2V0RGVmYXVsdFRlbXBsYXRlQ2hpbGRyZW4oKSxcbiAgICAgICAgICAgICAgYm94ID0gX2dldERlZmF1bHRUZW1wbGF0ZUNoLmJveDtcblxuICAgICAgICAgIFsncGxhY2VtZW50JywgJ3JlZmVyZW5jZS1oaWRkZW4nLCAnZXNjYXBlZCddLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICAgIGlmIChhdHRyID09PSAncGxhY2VtZW50Jykge1xuICAgICAgICAgICAgICBib3guc2V0QXR0cmlidXRlKCdkYXRhLXBsYWNlbWVudCcsIHN0YXRlLnBsYWNlbWVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoc3RhdGUuYXR0cmlidXRlcy5wb3BwZXJbXCJkYXRhLXBvcHBlci1cIiArIGF0dHJdKSB7XG4gICAgICAgICAgICAgICAgYm94LnNldEF0dHJpYnV0ZShcImRhdGEtXCIgKyBhdHRyLCAnJyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYm94LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtXCIgKyBhdHRyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0ge307XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBtb2RpZmllcnMgPSBbe1xuICAgICAgbmFtZTogJ29mZnNldCcsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIG9mZnNldDogb2Zmc2V0XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgbmFtZTogJ3ByZXZlbnRPdmVyZmxvdycsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgICB0b3A6IDIsXG4gICAgICAgICAgYm90dG9tOiAyLFxuICAgICAgICAgIGxlZnQ6IDUsXG4gICAgICAgICAgcmlnaHQ6IDVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdmbGlwJyxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgcGFkZGluZzogNVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdjb21wdXRlU3R5bGVzJyxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgYWRhcHRpdmU6ICFtb3ZlVHJhbnNpdGlvblxuICAgICAgfVxuICAgIH0sIHRpcHB5TW9kaWZpZXJdO1xuXG4gICAgaWYgKGdldElzRGVmYXVsdFJlbmRlckZuKCkgJiYgYXJyb3cpIHtcbiAgICAgIG1vZGlmaWVycy5wdXNoKHtcbiAgICAgICAgbmFtZTogJ2Fycm93JyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIGVsZW1lbnQ6IGFycm93LFxuICAgICAgICAgIHBhZGRpbmc6IDNcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgbW9kaWZpZXJzLnB1c2guYXBwbHkobW9kaWZpZXJzLCAocG9wcGVyT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogcG9wcGVyT3B0aW9ucy5tb2RpZmllcnMpIHx8IFtdKTtcbiAgICBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZSA9IGNyZWF0ZVBvcHBlcihjb21wdXRlZFJlZmVyZW5jZSwgcG9wcGVyLCBPYmplY3QuYXNzaWduKHt9LCBwb3BwZXJPcHRpb25zLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIG9uRmlyc3RVcGRhdGU6IG9uRmlyc3RVcGRhdGUsXG4gICAgICBtb2RpZmllcnM6IG1vZGlmaWVyc1xuICAgIH0pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlc3Ryb3lQb3BwZXJJbnN0YW5jZSgpIHtcbiAgICBpZiAoaW5zdGFuY2UucG9wcGVySW5zdGFuY2UpIHtcbiAgICAgIGluc3RhbmNlLnBvcHBlckluc3RhbmNlLmRlc3Ryb3koKTtcbiAgICAgIGluc3RhbmNlLnBvcHBlckluc3RhbmNlID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICB2YXIgYXBwZW5kVG8gPSBpbnN0YW5jZS5wcm9wcy5hcHBlbmRUbztcbiAgICB2YXIgcGFyZW50Tm9kZTsgLy8gQnkgZGVmYXVsdCwgd2UnbGwgYXBwZW5kIHRoZSBwb3BwZXIgdG8gdGhlIHRyaWdnZXJUYXJnZXRzJ3MgcGFyZW50Tm9kZSBzb1xuICAgIC8vIGl0J3MgZGlyZWN0bHkgYWZ0ZXIgdGhlIHJlZmVyZW5jZSBlbGVtZW50IHNvIHRoZSBlbGVtZW50cyBpbnNpZGUgdGhlXG4gICAgLy8gdGlwcHkgY2FuIGJlIHRhYmJlZCB0b1xuICAgIC8vIElmIHRoZXJlIGFyZSBjbGlwcGluZyBpc3N1ZXMsIHRoZSB1c2VyIGNhbiBzcGVjaWZ5IGEgZGlmZmVyZW50IGFwcGVuZFRvXG4gICAgLy8gYW5kIGVuc3VyZSBmb2N1cyBtYW5hZ2VtZW50IGlzIGhhbmRsZWQgY29ycmVjdGx5IG1hbnVhbGx5XG5cbiAgICB2YXIgbm9kZSA9IGdldEN1cnJlbnRUYXJnZXQoKTtcblxuICAgIGlmIChpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZSAmJiBhcHBlbmRUbyA9PT0gZGVmYXVsdFByb3BzLmFwcGVuZFRvIHx8IGFwcGVuZFRvID09PSAncGFyZW50Jykge1xuICAgICAgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50Tm9kZSA9IGludm9rZVdpdGhBcmdzT3JSZXR1cm4oYXBwZW5kVG8sIFtub2RlXSk7XG4gICAgfSAvLyBUaGUgcG9wcGVyIGVsZW1lbnQgbmVlZHMgdG8gZXhpc3Qgb24gdGhlIERPTSBiZWZvcmUgaXRzIHBvc2l0aW9uIGNhbiBiZVxuICAgIC8vIHVwZGF0ZWQgYXMgUG9wcGVyIG5lZWRzIHRvIHJlYWQgaXRzIGRpbWVuc2lvbnNcblxuXG4gICAgaWYgKCFwYXJlbnROb2RlLmNvbnRhaW5zKHBvcHBlcikpIHtcbiAgICAgIHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQocG9wcGVyKTtcbiAgICB9XG5cbiAgICBjcmVhdGVQb3BwZXJJbnN0YW5jZSgpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAvLyBBY2Nlc3NpYmlsaXR5IGNoZWNrXG4gICAgICB3YXJuV2hlbihpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZSAmJiBhcHBlbmRUbyA9PT0gZGVmYXVsdFByb3BzLmFwcGVuZFRvICYmIG5vZGUubmV4dEVsZW1lbnRTaWJsaW5nICE9PSBwb3BwZXIsIFsnSW50ZXJhY3RpdmUgdGlwcHkgZWxlbWVudCBtYXkgbm90IGJlIGFjY2Vzc2libGUgdmlhIGtleWJvYXJkJywgJ25hdmlnYXRpb24gYmVjYXVzZSBpdCBpcyBub3QgZGlyZWN0bHkgYWZ0ZXIgdGhlIHJlZmVyZW5jZSBlbGVtZW50JywgJ2luIHRoZSBET00gc291cmNlIG9yZGVyLicsICdcXG5cXG4nLCAnVXNpbmcgYSB3cmFwcGVyIDxkaXY+IG9yIDxzcGFuPiB0YWcgYXJvdW5kIHRoZSByZWZlcmVuY2UgZWxlbWVudCcsICdzb2x2ZXMgdGhpcyBieSBjcmVhdGluZyBhIG5ldyBwYXJlbnROb2RlIGNvbnRleHQuJywgJ1xcblxcbicsICdTcGVjaWZ5aW5nIGBhcHBlbmRUbzogZG9jdW1lbnQuYm9keWAgc2lsZW5jZXMgdGhpcyB3YXJuaW5nLCBidXQgaXQnLCAnYXNzdW1lcyB5b3UgYXJlIHVzaW5nIGEgZm9jdXMgbWFuYWdlbWVudCBzb2x1dGlvbiB0byBoYW5kbGUnLCAna2V5Ym9hcmQgbmF2aWdhdGlvbi4nLCAnXFxuXFxuJywgJ1NlZTogaHR0cHM6Ly9hdG9taWtzLmdpdGh1Yi5pby90aXBweWpzL3Y2L2FjY2Vzc2liaWxpdHkvI2ludGVyYWN0aXZpdHknXS5qb2luKCcgJykpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE5lc3RlZFBvcHBlclRyZWUoKSB7XG4gICAgcmV0dXJuIGFycmF5RnJvbShwb3BwZXIucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtdGlwcHktcm9vdF0nKSk7XG4gIH1cblxuICBmdW5jdGlvbiBzY2hlZHVsZVNob3coZXZlbnQpIHtcbiAgICBpbnN0YW5jZS5jbGVhckRlbGF5VGltZW91dHMoKTtcblxuICAgIGlmIChldmVudCkge1xuICAgICAgaW52b2tlSG9vaygnb25UcmlnZ2VyJywgW2luc3RhbmNlLCBldmVudF0pO1xuICAgIH1cblxuICAgIGFkZERvY3VtZW50UHJlc3MoKTtcbiAgICB2YXIgZGVsYXkgPSBnZXREZWxheSh0cnVlKTtcblxuICAgIHZhciBfZ2V0Tm9ybWFsaXplZFRvdWNoU2UgPSBnZXROb3JtYWxpemVkVG91Y2hTZXR0aW5ncygpLFxuICAgICAgICB0b3VjaFZhbHVlID0gX2dldE5vcm1hbGl6ZWRUb3VjaFNlWzBdLFxuICAgICAgICB0b3VjaERlbGF5ID0gX2dldE5vcm1hbGl6ZWRUb3VjaFNlWzFdO1xuXG4gICAgaWYgKGN1cnJlbnRJbnB1dC5pc1RvdWNoICYmIHRvdWNoVmFsdWUgPT09ICdob2xkJyAmJiB0b3VjaERlbGF5KSB7XG4gICAgICBkZWxheSA9IHRvdWNoRGVsYXk7XG4gICAgfVxuXG4gICAgaWYgKGRlbGF5KSB7XG4gICAgICBzaG93VGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnN0YW5jZS5zaG93KCk7XG4gICAgICB9LCBkZWxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlLnNob3coKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY2hlZHVsZUhpZGUoZXZlbnQpIHtcbiAgICBpbnN0YW5jZS5jbGVhckRlbGF5VGltZW91dHMoKTtcbiAgICBpbnZva2VIb29rKCdvblVudHJpZ2dlcicsIFtpbnN0YW5jZSwgZXZlbnRdKTtcblxuICAgIGlmICghaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICByZW1vdmVEb2N1bWVudFByZXNzKCk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBGb3IgaW50ZXJhY3RpdmUgdGlwcGllcywgc2NoZWR1bGVIaWRlIGlzIGFkZGVkIHRvIGEgZG9jdW1lbnQuYm9keSBoYW5kbGVyXG4gICAgLy8gZnJvbSBvbk1vdXNlTGVhdmUgc28gbXVzdCBpbnRlcmNlcHQgc2NoZWR1bGVkIGhpZGVzIGZyb20gbW91c2Vtb3ZlL2xlYXZlXG4gICAgLy8gZXZlbnRzIHdoZW4gdHJpZ2dlciBjb250YWlucyBtb3VzZWVudGVyIGFuZCBjbGljaywgYW5kIHRoZSB0aXAgaXNcbiAgICAvLyBjdXJyZW50bHkgc2hvd24gYXMgYSByZXN1bHQgb2YgYSBjbGljay5cblxuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzLnRyaWdnZXIuaW5kZXhPZignbW91c2VlbnRlcicpID49IDAgJiYgaW5zdGFuY2UucHJvcHMudHJpZ2dlci5pbmRleE9mKCdjbGljaycpID49IDAgJiYgWydtb3VzZWxlYXZlJywgJ21vdXNlbW92ZSddLmluZGV4T2YoZXZlbnQudHlwZSkgPj0gMCAmJiBpc1Zpc2libGVGcm9tQ2xpY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGVsYXkgPSBnZXREZWxheShmYWxzZSk7XG5cbiAgICBpZiAoZGVsYXkpIHtcbiAgICAgIGhpZGVUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUpIHtcbiAgICAgICAgICBpbnN0YW5jZS5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIGRlbGF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRml4ZXMgYSBgdHJhbnNpdGlvbmVuZGAgcHJvYmxlbSB3aGVuIGl0IGZpcmVzIDEgZnJhbWUgdG9vXG4gICAgICAvLyBsYXRlIHNvbWV0aW1lcywgd2UgZG9uJ3Qgd2FudCBoaWRlKCkgdG8gYmUgY2FsbGVkLlxuICAgICAgc2NoZWR1bGVIaWRlQW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnN0YW5jZS5oaWRlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0gLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIPCflJEgUHVibGljIG1ldGhvZHNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICBmdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgaW5zdGFuY2Uuc3RhdGUuaXNFbmFibGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgLy8gRGlzYWJsaW5nIHRoZSBpbnN0YW5jZSBzaG91bGQgYWxzbyBoaWRlIGl0XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2F0b21pa3MvdGlwcHkuanMtcmVhY3QvaXNzdWVzLzEwNlxuICAgIGluc3RhbmNlLmhpZGUoKTtcbiAgICBpbnN0YW5jZS5zdGF0ZS5pc0VuYWJsZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyRGVsYXlUaW1lb3V0cygpIHtcbiAgICBjbGVhclRpbWVvdXQoc2hvd1RpbWVvdXQpO1xuICAgIGNsZWFyVGltZW91dChoaWRlVGltZW91dCk7XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoc2NoZWR1bGVIaWRlQW5pbWF0aW9uRnJhbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0UHJvcHMocGFydGlhbFByb3BzKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICB3YXJuV2hlbihpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZCwgY3JlYXRlTWVtb3J5TGVha1dhcm5pbmcoJ3NldFByb3BzJykpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludm9rZUhvb2soJ29uQmVmb3JlVXBkYXRlJywgW2luc3RhbmNlLCBwYXJ0aWFsUHJvcHNdKTtcbiAgICByZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICB2YXIgcHJldlByb3BzID0gaW5zdGFuY2UucHJvcHM7XG4gICAgdmFyIG5leHRQcm9wcyA9IGV2YWx1YXRlUHJvcHMocmVmZXJlbmNlLCBPYmplY3QuYXNzaWduKHt9LCBpbnN0YW5jZS5wcm9wcywge30sIHBhcnRpYWxQcm9wcywge1xuICAgICAgaWdub3JlQXR0cmlidXRlczogdHJ1ZVxuICAgIH0pKTtcbiAgICBpbnN0YW5jZS5wcm9wcyA9IG5leHRQcm9wcztcbiAgICBhZGRMaXN0ZW5lcnMoKTtcblxuICAgIGlmIChwcmV2UHJvcHMuaW50ZXJhY3RpdmVEZWJvdW5jZSAhPT0gbmV4dFByb3BzLmludGVyYWN0aXZlRGVib3VuY2UpIHtcbiAgICAgIGNsZWFudXBJbnRlcmFjdGl2ZU1vdXNlTGlzdGVuZXJzKCk7XG4gICAgICBkZWJvdW5jZWRPbk1vdXNlTW92ZSA9IGRlYm91bmNlKG9uTW91c2VNb3ZlLCBuZXh0UHJvcHMuaW50ZXJhY3RpdmVEZWJvdW5jZSk7XG4gICAgfSAvLyBFbnN1cmUgc3RhbGUgYXJpYS1leHBhbmRlZCBhdHRyaWJ1dGVzIGFyZSByZW1vdmVkXG5cblxuICAgIGlmIChwcmV2UHJvcHMudHJpZ2dlclRhcmdldCAmJiAhbmV4dFByb3BzLnRyaWdnZXJUYXJnZXQpIHtcbiAgICAgIG5vcm1hbGl6ZVRvQXJyYXkocHJldlByb3BzLnRyaWdnZXJUYXJnZXQpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAobmV4dFByb3BzLnRyaWdnZXJUYXJnZXQpIHtcbiAgICAgIHJlZmVyZW5jZS5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnKTtcbiAgICB9XG5cbiAgICBoYW5kbGVBcmlhRXhwYW5kZWRBdHRyaWJ1dGUoKTtcbiAgICBoYW5kbGVTdHlsZXMoKTtcblxuICAgIGlmIChvblVwZGF0ZSkge1xuICAgICAgb25VcGRhdGUocHJldlByb3BzLCBuZXh0UHJvcHMpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZSkge1xuICAgICAgY3JlYXRlUG9wcGVySW5zdGFuY2UoKTsgLy8gRml4ZXMgYW4gaXNzdWUgd2l0aCBuZXN0ZWQgdGlwcGllcyBpZiB0aGV5IGFyZSBhbGwgZ2V0dGluZyByZS1yZW5kZXJlZCxcbiAgICAgIC8vIGFuZCB0aGUgbmVzdGVkIG9uZXMgZ2V0IHJlLXJlbmRlcmVkIGZpcnN0LlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2F0b21pa3MvdGlwcHlqcy1yZWFjdC9pc3N1ZXMvMTc3XG4gICAgICAvLyBUT0RPOiBmaW5kIGEgY2xlYW5lciAvIG1vcmUgZWZmaWNpZW50IHNvbHV0aW9uKCEpXG5cbiAgICAgIGdldE5lc3RlZFBvcHBlclRyZWUoKS5mb3JFYWNoKGZ1bmN0aW9uIChuZXN0ZWRQb3BwZXIpIHtcbiAgICAgICAgLy8gUmVhY3QgKGFuZCBvdGhlciBVSSBsaWJzIGxpa2VseSkgcmVxdWlyZXMgYSByQUYgd3JhcHBlciBhcyBpdCBmbHVzaGVzXG4gICAgICAgIC8vIGl0cyB3b3JrIGluIG9uZVxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobmVzdGVkUG9wcGVyLl90aXBweS5wb3BwZXJJbnN0YW5jZS5mb3JjZVVwZGF0ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpbnZva2VIb29rKCdvbkFmdGVyVXBkYXRlJywgW2luc3RhbmNlLCBwYXJ0aWFsUHJvcHNdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldENvbnRlbnQoY29udGVudCkge1xuICAgIGluc3RhbmNlLnNldFByb3BzKHtcbiAgICAgIGNvbnRlbnQ6IGNvbnRlbnRcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3coKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICB3YXJuV2hlbihpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZCwgY3JlYXRlTWVtb3J5TGVha1dhcm5pbmcoJ3Nob3cnKSk7XG4gICAgfSAvLyBFYXJseSBiYWlsLW91dFxuXG5cbiAgICB2YXIgaXNBbHJlYWR5VmlzaWJsZSA9IGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZTtcbiAgICB2YXIgaXNEZXN0cm95ZWQgPSBpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZDtcbiAgICB2YXIgaXNEaXNhYmxlZCA9ICFpbnN0YW5jZS5zdGF0ZS5pc0VuYWJsZWQ7XG4gICAgdmFyIGlzVG91Y2hBbmRUb3VjaERpc2FibGVkID0gY3VycmVudElucHV0LmlzVG91Y2ggJiYgIWluc3RhbmNlLnByb3BzLnRvdWNoO1xuICAgIHZhciBkdXJhdGlvbiA9IGdldFZhbHVlQXRJbmRleE9yUmV0dXJuKGluc3RhbmNlLnByb3BzLmR1cmF0aW9uLCAwLCBkZWZhdWx0UHJvcHMuZHVyYXRpb24pO1xuXG4gICAgaWYgKGlzQWxyZWFkeVZpc2libGUgfHwgaXNEZXN0cm95ZWQgfHwgaXNEaXNhYmxlZCB8fCBpc1RvdWNoQW5kVG91Y2hEaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gTm9ybWFsaXplIGBkaXNhYmxlZGAgYmVoYXZpb3IgYWNyb3NzIGJyb3dzZXJzLlxuICAgIC8vIEZpcmVmb3ggYWxsb3dzIGV2ZW50cyBvbiBkaXNhYmxlZCBlbGVtZW50cywgYnV0IENocm9tZSBkb2Vzbid0LlxuICAgIC8vIFVzaW5nIGEgd3JhcHBlciBlbGVtZW50IChpLmUuIDxzcGFuPikgaXMgcmVjb21tZW5kZWQuXG5cblxuICAgIGlmIChnZXRDdXJyZW50VGFyZ2V0KCkuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW52b2tlSG9vaygnb25TaG93JywgW2luc3RhbmNlXSwgZmFsc2UpO1xuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzLm9uU2hvdyhpbnN0YW5jZSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlID0gdHJ1ZTtcblxuICAgIGlmIChnZXRJc0RlZmF1bHRSZW5kZXJGbigpKSB7XG4gICAgICBwb3BwZXIuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICB9XG5cbiAgICBoYW5kbGVTdHlsZXMoKTtcbiAgICBhZGREb2N1bWVudFByZXNzKCk7XG5cbiAgICBpZiAoIWluc3RhbmNlLnN0YXRlLmlzTW91bnRlZCkge1xuICAgICAgcG9wcGVyLnN0eWxlLnRyYW5zaXRpb24gPSAnbm9uZSc7XG4gICAgfSAvLyBJZiBmbGlwcGluZyB0byB0aGUgb3Bwb3NpdGUgc2lkZSBhZnRlciBoaWRpbmcgYXQgbGVhc3Qgb25jZSwgdGhlXG4gICAgLy8gYW5pbWF0aW9uIHdpbGwgdXNlIHRoZSB3cm9uZyBwbGFjZW1lbnQgd2l0aG91dCByZXNldHRpbmcgdGhlIGR1cmF0aW9uXG5cblxuICAgIGlmIChnZXRJc0RlZmF1bHRSZW5kZXJGbigpKSB7XG4gICAgICB2YXIgX2dldERlZmF1bHRUZW1wbGF0ZUNoMiA9IGdldERlZmF1bHRUZW1wbGF0ZUNoaWxkcmVuKCksXG4gICAgICAgICAgYm94ID0gX2dldERlZmF1bHRUZW1wbGF0ZUNoMi5ib3gsXG4gICAgICAgICAgY29udGVudCA9IF9nZXREZWZhdWx0VGVtcGxhdGVDaDIuY29udGVudDtcblxuICAgICAgc2V0VHJhbnNpdGlvbkR1cmF0aW9uKFtib3gsIGNvbnRlbnRdLCAwKTtcbiAgICB9XG5cbiAgICBvbkZpcnN0VXBkYXRlID0gZnVuY3Rpb24gb25GaXJzdFVwZGF0ZSgpIHtcbiAgICAgIGlmICghaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlIHx8IGlnbm9yZU9uRmlyc3RVcGRhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZ25vcmVPbkZpcnN0VXBkYXRlID0gdHJ1ZTsgLy8gcmVmbG93XG5cbiAgICAgIHZvaWQgcG9wcGVyLm9mZnNldEhlaWdodDtcbiAgICAgIHBvcHBlci5zdHlsZS50cmFuc2l0aW9uID0gaW5zdGFuY2UucHJvcHMubW92ZVRyYW5zaXRpb247XG5cbiAgICAgIGlmIChnZXRJc0RlZmF1bHRSZW5kZXJGbigpICYmIGluc3RhbmNlLnByb3BzLmFuaW1hdGlvbikge1xuICAgICAgICB2YXIgX2dldERlZmF1bHRUZW1wbGF0ZUNoMyA9IGdldERlZmF1bHRUZW1wbGF0ZUNoaWxkcmVuKCksXG4gICAgICAgICAgICBfYm94ID0gX2dldERlZmF1bHRUZW1wbGF0ZUNoMy5ib3gsXG4gICAgICAgICAgICBfY29udGVudCA9IF9nZXREZWZhdWx0VGVtcGxhdGVDaDMuY29udGVudDtcblxuICAgICAgICBzZXRUcmFuc2l0aW9uRHVyYXRpb24oW19ib3gsIF9jb250ZW50XSwgZHVyYXRpb24pO1xuICAgICAgICBzZXRWaXNpYmlsaXR5U3RhdGUoW19ib3gsIF9jb250ZW50XSwgJ3Zpc2libGUnKTtcbiAgICAgIH1cblxuICAgICAgaGFuZGxlQXJpYUNvbnRlbnRBdHRyaWJ1dGUoKTtcbiAgICAgIGhhbmRsZUFyaWFFeHBhbmRlZEF0dHJpYnV0ZSgpO1xuICAgICAgcHVzaElmVW5pcXVlKG1vdW50ZWRJbnN0YW5jZXMsIGluc3RhbmNlKTtcbiAgICAgIGluc3RhbmNlLnN0YXRlLmlzTW91bnRlZCA9IHRydWU7XG4gICAgICBpbnZva2VIb29rKCdvbk1vdW50JywgW2luc3RhbmNlXSk7XG5cbiAgICAgIGlmIChpbnN0YW5jZS5wcm9wcy5hbmltYXRpb24gJiYgZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKSkge1xuICAgICAgICBvblRyYW5zaXRpb25lZEluKGR1cmF0aW9uLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaW5zdGFuY2Uuc3RhdGUuaXNTaG93biA9IHRydWU7XG4gICAgICAgICAgaW52b2tlSG9vaygnb25TaG93bicsIFtpbnN0YW5jZV0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbW91bnQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICB3YXJuV2hlbihpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZCwgY3JlYXRlTWVtb3J5TGVha1dhcm5pbmcoJ2hpZGUnKSk7XG4gICAgfSAvLyBFYXJseSBiYWlsLW91dFxuXG5cbiAgICB2YXIgaXNBbHJlYWR5SGlkZGVuID0gIWluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZTtcbiAgICB2YXIgaXNEZXN0cm95ZWQgPSBpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZDtcbiAgICB2YXIgaXNEaXNhYmxlZCA9ICFpbnN0YW5jZS5zdGF0ZS5pc0VuYWJsZWQ7XG4gICAgdmFyIGR1cmF0aW9uID0gZ2V0VmFsdWVBdEluZGV4T3JSZXR1cm4oaW5zdGFuY2UucHJvcHMuZHVyYXRpb24sIDEsIGRlZmF1bHRQcm9wcy5kdXJhdGlvbik7XG5cbiAgICBpZiAoaXNBbHJlYWR5SGlkZGVuIHx8IGlzRGVzdHJveWVkIHx8IGlzRGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnZva2VIb29rKCdvbkhpZGUnLCBbaW5zdGFuY2VdLCBmYWxzZSk7XG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcHMub25IaWRlKGluc3RhbmNlKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUgPSBmYWxzZTtcbiAgICBpbnN0YW5jZS5zdGF0ZS5pc1Nob3duID0gZmFsc2U7XG4gICAgaWdub3JlT25GaXJzdFVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgaWYgKGdldElzRGVmYXVsdFJlbmRlckZuKCkpIHtcbiAgICAgIHBvcHBlci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgfVxuXG4gICAgY2xlYW51cEludGVyYWN0aXZlTW91c2VMaXN0ZW5lcnMoKTtcbiAgICByZW1vdmVEb2N1bWVudFByZXNzKCk7XG4gICAgaGFuZGxlU3R5bGVzKCk7XG5cbiAgICBpZiAoZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKSkge1xuICAgICAgdmFyIF9nZXREZWZhdWx0VGVtcGxhdGVDaDQgPSBnZXREZWZhdWx0VGVtcGxhdGVDaGlsZHJlbigpLFxuICAgICAgICAgIGJveCA9IF9nZXREZWZhdWx0VGVtcGxhdGVDaDQuYm94LFxuICAgICAgICAgIGNvbnRlbnQgPSBfZ2V0RGVmYXVsdFRlbXBsYXRlQ2g0LmNvbnRlbnQ7XG5cbiAgICAgIGlmIChpbnN0YW5jZS5wcm9wcy5hbmltYXRpb24pIHtcbiAgICAgICAgc2V0VHJhbnNpdGlvbkR1cmF0aW9uKFtib3gsIGNvbnRlbnRdLCBkdXJhdGlvbik7XG4gICAgICAgIHNldFZpc2liaWxpdHlTdGF0ZShbYm94LCBjb250ZW50XSwgJ2hpZGRlbicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZUFyaWFDb250ZW50QXR0cmlidXRlKCk7XG4gICAgaGFuZGxlQXJpYUV4cGFuZGVkQXR0cmlidXRlKCk7XG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcHMuYW5pbWF0aW9uKSB7XG4gICAgICBpZiAoZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKSkge1xuICAgICAgICBvblRyYW5zaXRpb25lZE91dChkdXJhdGlvbiwgaW5zdGFuY2UudW5tb3VudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlLnVubW91bnQoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoaWRlV2l0aEludGVyYWN0aXZpdHkoZXZlbnQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHdhcm5XaGVuKGluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkLCBjcmVhdGVNZW1vcnlMZWFrV2FybmluZygnaGlkZVdpdGhJbnRlcmFjdGl2aXR5JykpO1xuICAgIH1cblxuICAgIGRvYy5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBzY2hlZHVsZUhpZGUpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBkZWJvdW5jZWRPbk1vdXNlTW92ZSk7XG4gICAgcHVzaElmVW5pcXVlKG1vdXNlTW92ZUxpc3RlbmVycywgZGVib3VuY2VkT25Nb3VzZU1vdmUpO1xuICAgIGRlYm91bmNlZE9uTW91c2VNb3ZlKGV2ZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVubW91bnQoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICB3YXJuV2hlbihpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZCwgY3JlYXRlTWVtb3J5TGVha1dhcm5pbmcoJ3VubW91bnQnKSk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSkge1xuICAgICAgaW5zdGFuY2UuaGlkZSgpO1xuICAgIH1cblxuICAgIGlmICghaW5zdGFuY2Uuc3RhdGUuaXNNb3VudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGVzdHJveVBvcHBlckluc3RhbmNlKCk7IC8vIElmIGEgcG9wcGVyIGlzIG5vdCBpbnRlcmFjdGl2ZSwgaXQgd2lsbCBiZSBhcHBlbmRlZCBvdXRzaWRlIHRoZSBwb3BwZXJcbiAgICAvLyB0cmVlIGJ5IGRlZmF1bHQuIFRoaXMgc2VlbXMgbWFpbmx5IGZvciBpbnRlcmFjdGl2ZSB0aXBwaWVzLCBidXQgd2Ugc2hvdWxkXG4gICAgLy8gZmluZCBhIHdvcmthcm91bmQgaWYgcG9zc2libGVcblxuICAgIGdldE5lc3RlZFBvcHBlclRyZWUoKS5mb3JFYWNoKGZ1bmN0aW9uIChuZXN0ZWRQb3BwZXIpIHtcbiAgICAgIG5lc3RlZFBvcHBlci5fdGlwcHkudW5tb3VudCgpO1xuICAgIH0pO1xuXG4gICAgaWYgKHBvcHBlci5wYXJlbnROb2RlKSB7XG4gICAgICBwb3BwZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwb3BwZXIpO1xuICAgIH1cblxuICAgIG1vdW50ZWRJbnN0YW5jZXMgPSBtb3VudGVkSW5zdGFuY2VzLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIGkgIT09IGluc3RhbmNlO1xuICAgIH0pO1xuICAgIGluc3RhbmNlLnN0YXRlLmlzTW91bnRlZCA9IGZhbHNlO1xuICAgIGludm9rZUhvb2soJ29uSGlkZGVuJywgW2luc3RhbmNlXSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgd2FybldoZW4oaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQsIGNyZWF0ZU1lbW9yeUxlYWtXYXJuaW5nKCdkZXN0cm95JykpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGluc3RhbmNlLmNsZWFyRGVsYXlUaW1lb3V0cygpO1xuICAgIGluc3RhbmNlLnVubW91bnQoKTtcbiAgICByZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICBkZWxldGUgcmVmZXJlbmNlLl90aXBweTtcbiAgICBpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgaW52b2tlSG9vaygnb25EZXN0cm95JywgW2luc3RhbmNlXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdGlwcHkodGFyZ2V0cywgb3B0aW9uYWxQcm9wcykge1xuICBpZiAob3B0aW9uYWxQcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9uYWxQcm9wcyA9IHt9O1xuICB9XG5cbiAgdmFyIHBsdWdpbnMgPSBkZWZhdWx0UHJvcHMucGx1Z2lucy5jb25jYXQob3B0aW9uYWxQcm9wcy5wbHVnaW5zIHx8IFtdKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFsaWRhdGVUYXJnZXRzKHRhcmdldHMpO1xuICAgIHZhbGlkYXRlUHJvcHMob3B0aW9uYWxQcm9wcywgcGx1Z2lucyk7XG4gIH1cblxuICBiaW5kR2xvYmFsRXZlbnRMaXN0ZW5lcnMoKTtcbiAgdmFyIHBhc3NlZFByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9uYWxQcm9wcywge1xuICAgIHBsdWdpbnM6IHBsdWdpbnNcbiAgfSk7XG4gIHZhciBlbGVtZW50cyA9IGdldEFycmF5T2ZFbGVtZW50cyh0YXJnZXRzKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFyIGlzU2luZ2xlQ29udGVudEVsZW1lbnQgPSBpc0VsZW1lbnQocGFzc2VkUHJvcHMuY29udGVudCk7XG4gICAgdmFyIGlzTW9yZVRoYW5PbmVSZWZlcmVuY2VFbGVtZW50ID0gZWxlbWVudHMubGVuZ3RoID4gMTtcbiAgICB3YXJuV2hlbihpc1NpbmdsZUNvbnRlbnRFbGVtZW50ICYmIGlzTW9yZVRoYW5PbmVSZWZlcmVuY2VFbGVtZW50LCBbJ3RpcHB5KCkgd2FzIHBhc3NlZCBhbiBFbGVtZW50IGFzIHRoZSBgY29udGVudGAgcHJvcCwgYnV0IG1vcmUgdGhhbicsICdvbmUgdGlwcHkgaW5zdGFuY2Ugd2FzIGNyZWF0ZWQgYnkgdGhpcyBpbnZvY2F0aW9uLiBUaGlzIG1lYW5zIHRoZScsICdjb250ZW50IGVsZW1lbnQgd2lsbCBvbmx5IGJlIGFwcGVuZGVkIHRvIHRoZSBsYXN0IHRpcHB5IGluc3RhbmNlLicsICdcXG5cXG4nLCAnSW5zdGVhZCwgcGFzcyB0aGUgLmlubmVySFRNTCBvZiB0aGUgZWxlbWVudCwgb3IgdXNlIGEgZnVuY3Rpb24gdGhhdCcsICdyZXR1cm5zIGEgY2xvbmVkIHZlcnNpb24gb2YgdGhlIGVsZW1lbnQgaW5zdGVhZC4nLCAnXFxuXFxuJywgJzEpIGNvbnRlbnQ6IGVsZW1lbnQuaW5uZXJIVE1MXFxuJywgJzIpIGNvbnRlbnQ6ICgpID0+IGVsZW1lbnQuY2xvbmVOb2RlKHRydWUpJ10uam9pbignICcpKTtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZXMgPSBlbGVtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcmVmZXJlbmNlKSB7XG4gICAgdmFyIGluc3RhbmNlID0gcmVmZXJlbmNlICYmIGNyZWF0ZVRpcHB5KHJlZmVyZW5jZSwgcGFzc2VkUHJvcHMpO1xuXG4gICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICBhY2MucHVzaChpbnN0YW5jZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfSwgW10pO1xuICByZXR1cm4gaXNFbGVtZW50KHRhcmdldHMpID8gaW5zdGFuY2VzWzBdIDogaW5zdGFuY2VzO1xufVxuXG50aXBweS5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG50aXBweS5zZXREZWZhdWx0UHJvcHMgPSBzZXREZWZhdWx0UHJvcHM7XG50aXBweS5jdXJyZW50SW5wdXQgPSBjdXJyZW50SW5wdXQ7XG52YXIgaGlkZUFsbCA9IGZ1bmN0aW9uIGhpZGVBbGwoX3RlbXApIHtcbiAgdmFyIF9yZWYgPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcCxcbiAgICAgIGV4Y2x1ZGVkUmVmZXJlbmNlT3JJbnN0YW5jZSA9IF9yZWYuZXhjbHVkZSxcbiAgICAgIGR1cmF0aW9uID0gX3JlZi5kdXJhdGlvbjtcblxuICBtb3VudGVkSW5zdGFuY2VzLmZvckVhY2goZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgdmFyIGlzRXhjbHVkZWQgPSBmYWxzZTtcblxuICAgIGlmIChleGNsdWRlZFJlZmVyZW5jZU9ySW5zdGFuY2UpIHtcbiAgICAgIGlzRXhjbHVkZWQgPSBpc1JlZmVyZW5jZUVsZW1lbnQoZXhjbHVkZWRSZWZlcmVuY2VPckluc3RhbmNlKSA/IGluc3RhbmNlLnJlZmVyZW5jZSA9PT0gZXhjbHVkZWRSZWZlcmVuY2VPckluc3RhbmNlIDogaW5zdGFuY2UucG9wcGVyID09PSBleGNsdWRlZFJlZmVyZW5jZU9ySW5zdGFuY2UucG9wcGVyO1xuICAgIH1cblxuICAgIGlmICghaXNFeGNsdWRlZCkge1xuICAgICAgdmFyIG9yaWdpbmFsRHVyYXRpb24gPSBpbnN0YW5jZS5wcm9wcy5kdXJhdGlvbjtcbiAgICAgIGluc3RhbmNlLnNldFByb3BzKHtcbiAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uXG4gICAgICB9KTtcbiAgICAgIGluc3RhbmNlLmhpZGUoKTtcblxuICAgICAgaWYgKCFpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZCkge1xuICAgICAgICBpbnN0YW5jZS5zZXRQcm9wcyh7XG4gICAgICAgICAgZHVyYXRpb246IG9yaWdpbmFsRHVyYXRpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBjcmVhdGVTaW5nbGV0b24gPSBmdW5jdGlvbiBjcmVhdGVTaW5nbGV0b24odGlwcHlJbnN0YW5jZXMsIG9wdGlvbmFsUHJvcHMpIHtcbiAgaWYgKG9wdGlvbmFsUHJvcHMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbmFsUHJvcHMgPSB7fTtcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBlcnJvcldoZW4oIUFycmF5LmlzQXJyYXkodGlwcHlJbnN0YW5jZXMpLCBbJ1RoZSBmaXJzdCBhcmd1bWVudCBwYXNzZWQgdG8gY3JlYXRlU2luZ2xldG9uKCkgbXVzdCBiZSBhbiBhcnJheSBvZicsICd0aXBweSBpbnN0YW5jZXMuIFRoZSBwYXNzZWQgdmFsdWUgd2FzJywgU3RyaW5nKHRpcHB5SW5zdGFuY2VzKV0uam9pbignICcpKTtcbiAgfVxuXG4gIHZhciBtdXRUaXBweUluc3RhbmNlcyA9IHRpcHB5SW5zdGFuY2VzO1xuICB2YXIgcmVmZXJlbmNlcyA9IFtdO1xuICB2YXIgY3VycmVudFRhcmdldDtcbiAgdmFyIG92ZXJyaWRlcyA9IG9wdGlvbmFsUHJvcHMub3ZlcnJpZGVzO1xuXG4gIGZ1bmN0aW9uIHNldFJlZmVyZW5jZXMoKSB7XG4gICAgcmVmZXJlbmNlcyA9IG11dFRpcHB5SW5zdGFuY2VzLm1hcChmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZS5yZWZlcmVuY2U7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBlbmFibGVJbnN0YW5jZXMoaXNFbmFibGVkKSB7XG4gICAgbXV0VGlwcHlJbnN0YW5jZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgIGlmIChpc0VuYWJsZWQpIHtcbiAgICAgICAgaW5zdGFuY2UuZW5hYmxlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0YW5jZS5kaXNhYmxlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBlbmFibGVJbnN0YW5jZXMoZmFsc2UpO1xuICBzZXRSZWZlcmVuY2VzKCk7XG4gIHZhciBzaW5nbGV0b24gPSB7XG4gICAgZm46IGZ1bmN0aW9uIGZuKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb25EZXN0cm95OiBmdW5jdGlvbiBvbkRlc3Ryb3koKSB7XG4gICAgICAgICAgZW5hYmxlSW5zdGFuY2VzKHRydWUpO1xuICAgICAgICB9LFxuICAgICAgICBvblRyaWdnZXI6IGZ1bmN0aW9uIG9uVHJpZ2dlcihpbnN0YW5jZSwgZXZlbnQpIHtcbiAgICAgICAgICB2YXIgdGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgICB2YXIgaW5kZXggPSByZWZlcmVuY2VzLmluZGV4T2YodGFyZ2V0KTsgLy8gYmFpbC1vdXRcblxuICAgICAgICAgIGlmICh0YXJnZXQgPT09IGN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdXJyZW50VGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICAgIHZhciBvdmVycmlkZVByb3BzID0gKG92ZXJyaWRlcyB8fCBbXSkuY29uY2F0KCdjb250ZW50JykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHByb3ApIHtcbiAgICAgICAgICAgIGFjY1twcm9wXSA9IG11dFRpcHB5SW5zdGFuY2VzW2luZGV4XS5wcm9wc1twcm9wXTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgfSwge30pO1xuICAgICAgICAgIGluc3RhbmNlLnNldFByb3BzKE9iamVjdC5hc3NpZ24oe30sIG92ZXJyaWRlUHJvcHMsIHtcbiAgICAgICAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6IGZ1bmN0aW9uIGdldFJlZmVyZW5jZUNsaWVudFJlY3QoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgdmFyIGluc3RhbmNlID0gdGlwcHkoZGl2KCksIE9iamVjdC5hc3NpZ24oe30sIHJlbW92ZVByb3BlcnRpZXMob3B0aW9uYWxQcm9wcywgWydvdmVycmlkZXMnXSksIHtcbiAgICBwbHVnaW5zOiBbc2luZ2xldG9uXS5jb25jYXQob3B0aW9uYWxQcm9wcy5wbHVnaW5zIHx8IFtdKSxcbiAgICB0cmlnZ2VyVGFyZ2V0OiByZWZlcmVuY2VzXG4gIH0pKTtcbiAgdmFyIG9yaWdpbmFsU2V0UHJvcHMgPSBpbnN0YW5jZS5zZXRQcm9wcztcblxuICBpbnN0YW5jZS5zZXRQcm9wcyA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgIG92ZXJyaWRlcyA9IHByb3BzLm92ZXJyaWRlcyB8fCBvdmVycmlkZXM7XG4gICAgb3JpZ2luYWxTZXRQcm9wcyhwcm9wcyk7XG4gIH07XG5cbiAgaW5zdGFuY2Uuc2V0SW5zdGFuY2VzID0gZnVuY3Rpb24gKG5leHRJbnN0YW5jZXMpIHtcbiAgICBlbmFibGVJbnN0YW5jZXModHJ1ZSk7XG4gICAgbXV0VGlwcHlJbnN0YW5jZXMgPSBuZXh0SW5zdGFuY2VzO1xuICAgIGVuYWJsZUluc3RhbmNlcyhmYWxzZSk7XG4gICAgc2V0UmVmZXJlbmNlcygpO1xuICAgIGluc3RhbmNlLnNldFByb3BzKHtcbiAgICAgIHRyaWdnZXJUYXJnZXQ6IHJlZmVyZW5jZXNcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gaW5zdGFuY2U7XG59O1xuXG52YXIgQlVCQkxJTkdfRVZFTlRTX01BUCA9IHtcbiAgbW91c2VvdmVyOiAnbW91c2VlbnRlcicsXG4gIGZvY3VzaW46ICdmb2N1cycsXG4gIGNsaWNrOiAnY2xpY2snXG59O1xuLyoqXG4gKiBDcmVhdGVzIGEgZGVsZWdhdGUgaW5zdGFuY2UgdGhhdCBjb250cm9scyB0aGUgY3JlYXRpb24gb2YgdGlwcHkgaW5zdGFuY2VzXG4gKiBmb3IgY2hpbGQgZWxlbWVudHMgKGB0YXJnZXRgIENTUyBzZWxlY3RvcikuXG4gKi9cblxuZnVuY3Rpb24gZGVsZWdhdGUodGFyZ2V0cywgcHJvcHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGVycm9yV2hlbighKHByb3BzICYmIHByb3BzLnRhcmdldCksIFsnWW91IG11c3Qgc3BlY2l0eSBhIGB0YXJnZXRgIHByb3AgaW5kaWNhdGluZyBhIENTUyBzZWxlY3RvciBzdHJpbmcgbWF0Y2hpbmcnLCAndGhlIHRhcmdldCBlbGVtZW50cyB0aGF0IHNob3VsZCByZWNlaXZlIGEgdGlwcHkuJ10uam9pbignICcpKTtcbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIGNoaWxkVGlwcHlJbnN0YW5jZXMgPSBbXTtcbiAgdmFyIHRhcmdldCA9IHByb3BzLnRhcmdldDtcbiAgdmFyIG5hdGl2ZVByb3BzID0gcmVtb3ZlUHJvcGVydGllcyhwcm9wcywgWyd0YXJnZXQnXSk7XG4gIHZhciBwYXJlbnRQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIG5hdGl2ZVByb3BzLCB7XG4gICAgdHJpZ2dlcjogJ21hbnVhbCcsXG4gICAgdG91Y2g6IGZhbHNlXG4gIH0pO1xuICB2YXIgY2hpbGRQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIG5hdGl2ZVByb3BzLCB7XG4gICAgc2hvd09uQ3JlYXRlOiB0cnVlXG4gIH0pO1xuICB2YXIgcmV0dXJuVmFsdWUgPSB0aXBweSh0YXJnZXRzLCBwYXJlbnRQcm9wcyk7XG4gIHZhciBub3JtYWxpemVkUmV0dXJuVmFsdWUgPSBub3JtYWxpemVUb0FycmF5KHJldHVyblZhbHVlKTtcblxuICBmdW5jdGlvbiBvblRyaWdnZXIoZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50LnRhcmdldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXROb2RlID0gZXZlbnQudGFyZ2V0LmNsb3Nlc3QodGFyZ2V0KTtcblxuICAgIGlmICghdGFyZ2V0Tm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gR2V0IHJlbGV2YW50IHRyaWdnZXIgd2l0aCBmYWxsYmFja3M6XG4gICAgLy8gMS4gQ2hlY2sgYGRhdGEtdGlwcHktdHJpZ2dlcmAgYXR0cmlidXRlIG9uIHRhcmdldCBub2RlXG4gICAgLy8gMi4gRmFsbGJhY2sgdG8gYHRyaWdnZXJgIHBhc3NlZCB0byBgZGVsZWdhdGUoKWBcbiAgICAvLyAzLiBGYWxsYmFjayB0byBgZGVmYXVsdFByb3BzLnRyaWdnZXJgXG5cblxuICAgIHZhciB0cmlnZ2VyID0gdGFyZ2V0Tm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGlwcHktdHJpZ2dlcicpIHx8IHByb3BzLnRyaWdnZXIgfHwgZGVmYXVsdFByb3BzLnRyaWdnZXI7IC8vIEB0cy1pZ25vcmVcblxuICAgIGlmICh0YXJnZXROb2RlLl90aXBweSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC50eXBlID09PSAndG91Y2hzdGFydCcgJiYgdHlwZW9mIGNoaWxkUHJvcHMudG91Y2ggPT09ICdib29sZWFuJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC50eXBlICE9PSAndG91Y2hzdGFydCcgJiYgdHJpZ2dlci5pbmRleE9mKEJVQkJMSU5HX0VWRU5UU19NQVBbZXZlbnQudHlwZV0pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGluc3RhbmNlID0gdGlwcHkodGFyZ2V0Tm9kZSwgY2hpbGRQcm9wcyk7XG5cbiAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgIGNoaWxkVGlwcHlJbnN0YW5jZXMgPSBjaGlsZFRpcHB5SW5zdGFuY2VzLmNvbmNhdChpbnN0YW5jZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb24obm9kZSwgZXZlbnRUeXBlLCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IGZhbHNlO1xuICAgIH1cblxuICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIGxpc3RlbmVycy5wdXNoKHtcbiAgICAgIG5vZGU6IG5vZGUsXG4gICAgICBldmVudFR5cGU6IGV2ZW50VHlwZSxcbiAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXG4gICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVycyhpbnN0YW5jZSkge1xuICAgIHZhciByZWZlcmVuY2UgPSBpbnN0YW5jZS5yZWZlcmVuY2U7XG4gICAgb24ocmVmZXJlbmNlLCAndG91Y2hzdGFydCcsIG9uVHJpZ2dlcik7XG4gICAgb24ocmVmZXJlbmNlLCAnbW91c2VvdmVyJywgb25UcmlnZ2VyKTtcbiAgICBvbihyZWZlcmVuY2UsICdmb2N1c2luJywgb25UcmlnZ2VyKTtcbiAgICBvbihyZWZlcmVuY2UsICdjbGljaycsIG9uVHJpZ2dlcik7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycygpIHtcbiAgICBsaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgdmFyIG5vZGUgPSBfcmVmLm5vZGUsXG4gICAgICAgICAgZXZlbnRUeXBlID0gX3JlZi5ldmVudFR5cGUsXG4gICAgICAgICAgaGFuZGxlciA9IF9yZWYuaGFuZGxlcixcbiAgICAgICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zO1xuICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgfSk7XG4gICAgbGlzdGVuZXJzID0gW107XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseU11dGF0aW9ucyhpbnN0YW5jZSkge1xuICAgIHZhciBvcmlnaW5hbERlc3Ryb3kgPSBpbnN0YW5jZS5kZXN0cm95O1xuXG4gICAgaW5zdGFuY2UuZGVzdHJveSA9IGZ1bmN0aW9uIChzaG91bGREZXN0cm95Q2hpbGRJbnN0YW5jZXMpIHtcbiAgICAgIGlmIChzaG91bGREZXN0cm95Q2hpbGRJbnN0YW5jZXMgPT09IHZvaWQgMCkge1xuICAgICAgICBzaG91bGREZXN0cm95Q2hpbGRJbnN0YW5jZXMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hvdWxkRGVzdHJveUNoaWxkSW5zdGFuY2VzKSB7XG4gICAgICAgIGNoaWxkVGlwcHlJbnN0YW5jZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICBpbnN0YW5jZS5kZXN0cm95KCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjaGlsZFRpcHB5SW5zdGFuY2VzID0gW107XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVycygpO1xuICAgICAgb3JpZ2luYWxEZXN0cm95KCk7XG4gICAgfTtcblxuICAgIGFkZEV2ZW50TGlzdGVuZXJzKGluc3RhbmNlKTtcbiAgfVxuXG4gIG5vcm1hbGl6ZWRSZXR1cm5WYWx1ZS5mb3JFYWNoKGFwcGx5TXV0YXRpb25zKTtcbiAgcmV0dXJuIHJldHVyblZhbHVlO1xufVxuXG52YXIgYW5pbWF0ZUZpbGwgPSB7XG4gIG5hbWU6ICdhbmltYXRlRmlsbCcsXG4gIGRlZmF1bHRWYWx1ZTogZmFsc2UsXG4gIGZuOiBmdW5jdGlvbiBmbihpbnN0YW5jZSkge1xuICAgIHZhciBfaW5zdGFuY2UkcHJvcHMkcmVuZGU7XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKCEoKF9pbnN0YW5jZSRwcm9wcyRyZW5kZSA9IGluc3RhbmNlLnByb3BzLnJlbmRlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbnN0YW5jZSRwcm9wcyRyZW5kZS4kJHRpcHB5KSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBlcnJvcldoZW4oaW5zdGFuY2UucHJvcHMuYW5pbWF0ZUZpbGwsICdUaGUgYGFuaW1hdGVGaWxsYCBwbHVnaW4gcmVxdWlyZXMgdGhlIGRlZmF1bHQgcmVuZGVyIGZ1bmN0aW9uLicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgdmFyIF9nZXRDaGlsZHJlbiA9IGdldENoaWxkcmVuKGluc3RhbmNlLnBvcHBlciksXG4gICAgICAgIGJveCA9IF9nZXRDaGlsZHJlbi5ib3gsXG4gICAgICAgIGNvbnRlbnQgPSBfZ2V0Q2hpbGRyZW4uY29udGVudDtcblxuICAgIHZhciBiYWNrZHJvcCA9IGluc3RhbmNlLnByb3BzLmFuaW1hdGVGaWxsID8gY3JlYXRlQmFja2Ryb3BFbGVtZW50KCkgOiBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICBvbkNyZWF0ZTogZnVuY3Rpb24gb25DcmVhdGUoKSB7XG4gICAgICAgIGlmIChiYWNrZHJvcCkge1xuICAgICAgICAgIGJveC5pbnNlcnRCZWZvcmUoYmFja2Ryb3AsIGJveC5maXJzdEVsZW1lbnRDaGlsZCk7XG4gICAgICAgICAgYm94LnNldEF0dHJpYnV0ZSgnZGF0YS1hbmltYXRlZmlsbCcsICcnKTtcbiAgICAgICAgICBib3guc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgICAgICBpbnN0YW5jZS5zZXRQcm9wcyh7XG4gICAgICAgICAgICBhcnJvdzogZmFsc2UsXG4gICAgICAgICAgICBhbmltYXRpb246ICdzaGlmdC1hd2F5J1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25Nb3VudDogZnVuY3Rpb24gb25Nb3VudCgpIHtcbiAgICAgICAgaWYgKGJhY2tkcm9wKSB7XG4gICAgICAgICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IGJveC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb247XG4gICAgICAgICAgdmFyIGR1cmF0aW9uID0gTnVtYmVyKHRyYW5zaXRpb25EdXJhdGlvbi5yZXBsYWNlKCdtcycsICcnKSk7IC8vIFRoZSBjb250ZW50IHNob3VsZCBmYWRlIGluIGFmdGVyIHRoZSBiYWNrZHJvcCBoYXMgbW9zdGx5IGZpbGxlZCB0aGVcbiAgICAgICAgICAvLyB0b29sdGlwIGVsZW1lbnQuIGBjbGlwLXBhdGhgIGlzIHRoZSBvdGhlciBhbHRlcm5hdGl2ZSBidXQgaXMgbm90XG4gICAgICAgICAgLy8gd2VsbC1zdXBwb3J0ZWQgYW5kIGlzIGJ1Z2d5IG9uIHNvbWUgZGV2aWNlcy5cblxuICAgICAgICAgIGNvbnRlbnQuc3R5bGUudHJhbnNpdGlvbkRlbGF5ID0gTWF0aC5yb3VuZChkdXJhdGlvbiAvIDEwKSArIFwibXNcIjtcbiAgICAgICAgICBiYWNrZHJvcC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSB0cmFuc2l0aW9uRHVyYXRpb247XG4gICAgICAgICAgc2V0VmlzaWJpbGl0eVN0YXRlKFtiYWNrZHJvcF0sICd2aXNpYmxlJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvblNob3c6IGZ1bmN0aW9uIG9uU2hvdygpIHtcbiAgICAgICAgaWYgKGJhY2tkcm9wKSB7XG4gICAgICAgICAgYmFja2Ryb3Auc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBtcyc7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbkhpZGU6IGZ1bmN0aW9uIG9uSGlkZSgpIHtcbiAgICAgICAgaWYgKGJhY2tkcm9wKSB7XG4gICAgICAgICAgc2V0VmlzaWJpbGl0eVN0YXRlKFtiYWNrZHJvcF0sICdoaWRkZW4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUJhY2tkcm9wRWxlbWVudCgpIHtcbiAgdmFyIGJhY2tkcm9wID0gZGl2KCk7XG4gIGJhY2tkcm9wLmNsYXNzTmFtZSA9IEJBQ0tEUk9QX0NMQVNTO1xuICBzZXRWaXNpYmlsaXR5U3RhdGUoW2JhY2tkcm9wXSwgJ2hpZGRlbicpO1xuICByZXR1cm4gYmFja2Ryb3A7XG59XG5cbnZhciBmb2xsb3dDdXJzb3IgPSB7XG4gIG5hbWU6ICdmb2xsb3dDdXJzb3InLFxuICBkZWZhdWx0VmFsdWU6IGZhbHNlLFxuICBmbjogZnVuY3Rpb24gZm4oaW5zdGFuY2UpIHtcbiAgICB2YXIgcmVmZXJlbmNlID0gaW5zdGFuY2UucmVmZXJlbmNlO1xuICAgIHZhciBkb2MgPSBnZXRPd25lckRvY3VtZW50KGluc3RhbmNlLnByb3BzLnRyaWdnZXJUYXJnZXQgfHwgcmVmZXJlbmNlKTtcbiAgICB2YXIgaW5pdGlhbE1vdXNlQ29vcmRzID0gbnVsbDtcblxuICAgIGZ1bmN0aW9uIGdldElzTWFudWFsKCkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlLnByb3BzLnRyaWdnZXIudHJpbSgpID09PSAnbWFudWFsJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJc0VuYWJsZWQoKSB7XG4gICAgICAvLyAjNTk3XG4gICAgICB2YXIgaXNWYWxpZE1vdXNlRXZlbnQgPSBnZXRJc01hbnVhbCgpID8gdHJ1ZSA6IC8vIENoZWNrIGlmIGEga2V5Ym9hcmQgXCJjbGlja1wiXG4gICAgICBpbml0aWFsTW91c2VDb29yZHMgIT09IG51bGwgJiYgIShpbml0aWFsTW91c2VDb29yZHMuY2xpZW50WCA9PT0gMCAmJiBpbml0aWFsTW91c2VDb29yZHMuY2xpZW50WSA9PT0gMCk7XG4gICAgICByZXR1cm4gaW5zdGFuY2UucHJvcHMuZm9sbG93Q3Vyc29yICYmIGlzVmFsaWRNb3VzZUV2ZW50O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldElzSW5pdGlhbEJlaGF2aW9yKCkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRJbnB1dC5pc1RvdWNoIHx8IGluc3RhbmNlLnByb3BzLmZvbGxvd0N1cnNvciA9PT0gJ2luaXRpYWwnICYmIGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bnNldFJlZmVyZW5jZUNsaWVudFJlY3Qoc2hvdWxkVW5zZXQpIHtcbiAgICAgIGlmIChzaG91bGRVbnNldCkge1xuICAgICAgICBpbnN0YW5jZS5zZXRQcm9wcyh7XG4gICAgICAgICAgZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdDogbnVsbFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmVMaXN0ZW5lcigpIHtcbiAgICAgIGlmIChnZXRJc0VuYWJsZWQoKSkge1xuICAgICAgICBhZGRMaXN0ZW5lcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdW5zZXRSZWZlcmVuY2VDbGllbnRSZWN0KGluc3RhbmNlLnByb3BzLmZvbGxvd0N1cnNvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJpZ2dlckxhc3RNb3VzZU1vdmUoKSB7XG4gICAgICBpZiAoZ2V0SXNFbmFibGVkKCkpIHtcbiAgICAgICAgb25Nb3VzZU1vdmUoaW5pdGlhbE1vdXNlQ29vcmRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRMaXN0ZW5lcigpIHtcbiAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoKSB7XG4gICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgICBpbml0aWFsTW91c2VDb29yZHMgPSB7XG4gICAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXG4gICAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFlcbiAgICAgIH07IC8vIElmIHRoZSBpbnN0YW5jZSBpcyBpbnRlcmFjdGl2ZSwgYXZvaWQgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHVubGVzcyBpdCdzXG4gICAgICAvLyBvdmVyIHRoZSByZWZlcmVuY2UgZWxlbWVudFxuXG4gICAgICB2YXIgaXNDdXJzb3JPdmVyUmVmZXJlbmNlID0gZXZlbnQudGFyZ2V0ID8gcmVmZXJlbmNlLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkgOiB0cnVlO1xuICAgICAgdmFyIGZvbGxvd0N1cnNvciA9IGluc3RhbmNlLnByb3BzLmZvbGxvd0N1cnNvcjtcbiAgICAgIHZhciBjbGllbnRYID0gZXZlbnQuY2xpZW50WCxcbiAgICAgICAgICBjbGllbnRZID0gZXZlbnQuY2xpZW50WTtcbiAgICAgIHZhciByZWN0ID0gcmVmZXJlbmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIHJlbGF0aXZlWCA9IGNsaWVudFggLSByZWN0LmxlZnQ7XG4gICAgICB2YXIgcmVsYXRpdmVZID0gY2xpZW50WSAtIHJlY3QudG9wO1xuXG4gICAgICBpZiAoaXNDdXJzb3JPdmVyUmVmZXJlbmNlIHx8ICFpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZSkge1xuICAgICAgICBpbnN0YW5jZS5zZXRQcm9wcyh7XG4gICAgICAgICAgZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdDogZnVuY3Rpb24gZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdCgpIHtcbiAgICAgICAgICAgIHZhciByZWN0ID0gcmVmZXJlbmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdmFyIHggPSBjbGllbnRYO1xuICAgICAgICAgICAgdmFyIHkgPSBjbGllbnRZO1xuXG4gICAgICAgICAgICBpZiAoZm9sbG93Q3Vyc29yID09PSAnaW5pdGlhbCcpIHtcbiAgICAgICAgICAgICAgeCA9IHJlY3QubGVmdCArIHJlbGF0aXZlWDtcbiAgICAgICAgICAgICAgeSA9IHJlY3QudG9wICsgcmVsYXRpdmVZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdG9wID0gZm9sbG93Q3Vyc29yID09PSAnaG9yaXpvbnRhbCcgPyByZWN0LnRvcCA6IHk7XG4gICAgICAgICAgICB2YXIgcmlnaHQgPSBmb2xsb3dDdXJzb3IgPT09ICd2ZXJ0aWNhbCcgPyByZWN0LnJpZ2h0IDogeDtcbiAgICAgICAgICAgIHZhciBib3R0b20gPSBmb2xsb3dDdXJzb3IgPT09ICdob3Jpem9udGFsJyA/IHJlY3QuYm90dG9tIDogeTtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gZm9sbG93Q3Vyc29yID09PSAndmVydGljYWwnID8gcmVjdC5sZWZ0IDogeDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHdpZHRoOiByaWdodCAtIGxlZnQsXG4gICAgICAgICAgICAgIGhlaWdodDogYm90dG9tIC0gdG9wLFxuICAgICAgICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgICAgICAgICBib3R0b206IGJvdHRvbSxcbiAgICAgICAgICAgICAgbGVmdDogbGVmdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ2V0SXNJbml0aWFsQmVoYXZpb3IoKSkge1xuICAgICAgICByZW1vdmVMaXN0ZW5lcigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBvbkFmdGVyVXBkYXRlOiBmdW5jdGlvbiBvbkFmdGVyVXBkYXRlKF8sIF9yZWYpIHtcbiAgICAgICAgdmFyIGZvbGxvd0N1cnNvciA9IF9yZWYuZm9sbG93Q3Vyc29yO1xuXG4gICAgICAgIGlmIChmb2xsb3dDdXJzb3IgIT09IHVuZGVmaW5lZCAmJiAhZm9sbG93Q3Vyc29yKSB7XG4gICAgICAgICAgdW5zZXRSZWZlcmVuY2VDbGllbnRSZWN0KHRydWUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25Nb3VudDogZnVuY3Rpb24gb25Nb3VudCgpIHtcbiAgICAgICAgdHJpZ2dlckxhc3RNb3VzZU1vdmUoKTtcbiAgICAgIH0sXG4gICAgICBvblNob3c6IGZ1bmN0aW9uIG9uU2hvdygpIHtcbiAgICAgICAgaWYgKGdldElzTWFudWFsKCkpIHtcbiAgICAgICAgICAvLyBTaW5jZSB0aGVyZSdzIG5vIHRyaWdnZXIgZXZlbnQgdG8gdXNlLCB3ZSBoYXZlIHRvIHVzZSB0aGVzZSBhc1xuICAgICAgICAgIC8vIGJhc2VsaW5lIGNvb3Jkc1xuICAgICAgICAgIGluaXRpYWxNb3VzZUNvb3JkcyA9IHtcbiAgICAgICAgICAgIGNsaWVudFg6IDAsXG4gICAgICAgICAgICBjbGllbnRZOiAwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBoYW5kbGVNb3VzZU1vdmVMaXN0ZW5lcigpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25UcmlnZ2VyOiBmdW5jdGlvbiBvblRyaWdnZXIoXywgZXZlbnQpIHtcbiAgICAgICAgLy8gVGFwcGluZyBvbiB0b3VjaCBkZXZpY2VzIGNhbiB0cmlnZ2VyIGBtb3VzZWVudGVyYCB0aGVuIGBmb2N1c2BcbiAgICAgICAgaWYgKGluaXRpYWxNb3VzZUNvb3Jkcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc01vdXNlRXZlbnQoZXZlbnQpKSB7XG4gICAgICAgICAgaW5pdGlhbE1vdXNlQ29vcmRzID0ge1xuICAgICAgICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaGFuZGxlTW91c2VNb3ZlTGlzdGVuZXIoKTtcbiAgICAgIH0sXG4gICAgICBvblVudHJpZ2dlcjogZnVuY3Rpb24gb25VbnRyaWdnZXIoKSB7XG4gICAgICAgIC8vIElmIHVudHJpZ2dlcmVkIGJlZm9yZSBzaG93aW5nIChgb25IaWRkZW5gIHdpbGwgbmV2ZXIgYmUgaW52b2tlZClcbiAgICAgICAgaWYgKCFpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUpIHtcbiAgICAgICAgICByZW1vdmVMaXN0ZW5lcigpO1xuICAgICAgICAgIGluaXRpYWxNb3VzZUNvb3JkcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbkhpZGRlbjogZnVuY3Rpb24gb25IaWRkZW4oKSB7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XG4gICAgICAgIGluaXRpYWxNb3VzZUNvb3JkcyA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0UHJvcHMocHJvcHMsIG1vZGlmaWVyKSB7XG4gIHZhciBfcHJvcHMkcG9wcGVyT3B0aW9ucztcblxuICByZXR1cm4ge1xuICAgIHBvcHBlck9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIHByb3BzLnBvcHBlck9wdGlvbnMsIHtcbiAgICAgIG1vZGlmaWVyczogW10uY29uY2F0KCgoKF9wcm9wcyRwb3BwZXJPcHRpb25zID0gcHJvcHMucG9wcGVyT3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9wcm9wcyRwb3BwZXJPcHRpb25zLm1vZGlmaWVycykgfHwgW10pLmZpbHRlcihmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgbmFtZSA9IF9yZWYubmFtZTtcbiAgICAgICAgcmV0dXJuIG5hbWUgIT09IG1vZGlmaWVyLm5hbWU7XG4gICAgICB9KSwgW21vZGlmaWVyXSlcbiAgICB9KVxuICB9O1xufVxuXG52YXIgaW5saW5lUG9zaXRpb25pbmcgPSB7XG4gIG5hbWU6ICdpbmxpbmVQb3NpdGlvbmluZycsXG4gIGRlZmF1bHRWYWx1ZTogZmFsc2UsXG4gIGZuOiBmdW5jdGlvbiBmbihpbnN0YW5jZSkge1xuICAgIHZhciByZWZlcmVuY2UgPSBpbnN0YW5jZS5yZWZlcmVuY2U7XG5cbiAgICBmdW5jdGlvbiBpc0VuYWJsZWQoKSB7XG4gICAgICByZXR1cm4gISFpbnN0YW5jZS5wcm9wcy5pbmxpbmVQb3NpdGlvbmluZztcbiAgICB9XG5cbiAgICB2YXIgcGxhY2VtZW50O1xuICAgIHZhciBjdXJzb3JSZWN0SW5kZXggPSAtMTtcbiAgICB2YXIgaXNJbnRlcm5hbFVwZGF0ZSA9IGZhbHNlO1xuICAgIHZhciBtb2RpZmllciA9IHtcbiAgICAgIG5hbWU6ICd0aXBweUlubGluZVBvc2l0aW9uaW5nJyxcbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICBwaGFzZTogJ2FmdGVyV3JpdGUnLFxuICAgICAgZm46IGZ1bmN0aW9uIGZuKF9yZWYyKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlO1xuXG4gICAgICAgIGlmIChpc0VuYWJsZWQoKSkge1xuICAgICAgICAgIGlmIChwbGFjZW1lbnQgIT09IHN0YXRlLnBsYWNlbWVudCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0UHJvcHMoe1xuICAgICAgICAgICAgICBnZXRSZWZlcmVuY2VDbGllbnRSZWN0OiBmdW5jdGlvbiBnZXRSZWZlcmVuY2VDbGllbnRSZWN0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdChzdGF0ZS5wbGFjZW1lbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwbGFjZW1lbnQgPSBzdGF0ZS5wbGFjZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gX2dldFJlZmVyZW5jZUNsaWVudFJlY3QocGxhY2VtZW50KSB7XG4gICAgICByZXR1cm4gZ2V0SW5saW5lQm91bmRpbmdDbGllbnRSZWN0KGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSwgcmVmZXJlbmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBhcnJheUZyb20ocmVmZXJlbmNlLmdldENsaWVudFJlY3RzKCkpLCBjdXJzb3JSZWN0SW5kZXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldEludGVybmFsUHJvcHMocGFydGlhbFByb3BzKSB7XG4gICAgICBpc0ludGVybmFsVXBkYXRlID0gdHJ1ZTtcbiAgICAgIGluc3RhbmNlLnNldFByb3BzKHBhcnRpYWxQcm9wcyk7XG4gICAgICBpc0ludGVybmFsVXBkYXRlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkTW9kaWZpZXIoKSB7XG4gICAgICBpZiAoIWlzSW50ZXJuYWxVcGRhdGUpIHtcbiAgICAgICAgc2V0SW50ZXJuYWxQcm9wcyhnZXRQcm9wcyhpbnN0YW5jZS5wcm9wcywgbW9kaWZpZXIpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgb25DcmVhdGU6IGFkZE1vZGlmaWVyLFxuICAgICAgb25BZnRlclVwZGF0ZTogYWRkTW9kaWZpZXIsXG4gICAgICBvblRyaWdnZXI6IGZ1bmN0aW9uIG9uVHJpZ2dlcihfLCBldmVudCkge1xuICAgICAgICBpZiAoaXNNb3VzZUV2ZW50KGV2ZW50KSkge1xuICAgICAgICAgIHZhciByZWN0cyA9IGFycmF5RnJvbShpbnN0YW5jZS5yZWZlcmVuY2UuZ2V0Q2xpZW50UmVjdHMoKSk7XG4gICAgICAgICAgdmFyIGN1cnNvclJlY3QgPSByZWN0cy5maW5kKGZ1bmN0aW9uIChyZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjdC5sZWZ0IC0gMiA8PSBldmVudC5jbGllbnRYICYmIHJlY3QucmlnaHQgKyAyID49IGV2ZW50LmNsaWVudFggJiYgcmVjdC50b3AgLSAyIDw9IGV2ZW50LmNsaWVudFkgJiYgcmVjdC5ib3R0b20gKyAyID49IGV2ZW50LmNsaWVudFk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY3Vyc29yUmVjdEluZGV4ID0gcmVjdHMuaW5kZXhPZihjdXJzb3JSZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uVW50cmlnZ2VyOiBmdW5jdGlvbiBvblVudHJpZ2dlcigpIHtcbiAgICAgICAgY3Vyc29yUmVjdEluZGV4ID0gLTE7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIGdldElubGluZUJvdW5kaW5nQ2xpZW50UmVjdChjdXJyZW50QmFzZVBsYWNlbWVudCwgYm91bmRpbmdSZWN0LCBjbGllbnRSZWN0cywgY3Vyc29yUmVjdEluZGV4KSB7XG4gIC8vIE5vdCBhbiBpbmxpbmUgZWxlbWVudCwgb3IgcGxhY2VtZW50IGlzIG5vdCB5ZXQga25vd25cbiAgaWYgKGNsaWVudFJlY3RzLmxlbmd0aCA8IDIgfHwgY3VycmVudEJhc2VQbGFjZW1lbnQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gYm91bmRpbmdSZWN0O1xuICB9IC8vIFRoZXJlIGFyZSB0d28gcmVjdHMgYW5kIHRoZXkgYXJlIGRpc2pvaW5lZFxuXG5cbiAgaWYgKGNsaWVudFJlY3RzLmxlbmd0aCA9PT0gMiAmJiBjdXJzb3JSZWN0SW5kZXggPj0gMCAmJiBjbGllbnRSZWN0c1swXS5sZWZ0ID4gY2xpZW50UmVjdHNbMV0ucmlnaHQpIHtcbiAgICByZXR1cm4gY2xpZW50UmVjdHNbY3Vyc29yUmVjdEluZGV4XSB8fCBib3VuZGluZ1JlY3Q7XG4gIH1cblxuICBzd2l0Y2ggKGN1cnJlbnRCYXNlUGxhY2VtZW50KSB7XG4gICAgY2FzZSAndG9wJzpcbiAgICBjYXNlICdib3R0b20nOlxuICAgICAge1xuICAgICAgICB2YXIgZmlyc3RSZWN0ID0gY2xpZW50UmVjdHNbMF07XG4gICAgICAgIHZhciBsYXN0UmVjdCA9IGNsaWVudFJlY3RzW2NsaWVudFJlY3RzLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgaXNUb3AgPSBjdXJyZW50QmFzZVBsYWNlbWVudCA9PT0gJ3RvcCc7XG4gICAgICAgIHZhciB0b3AgPSBmaXJzdFJlY3QudG9wO1xuICAgICAgICB2YXIgYm90dG9tID0gbGFzdFJlY3QuYm90dG9tO1xuICAgICAgICB2YXIgbGVmdCA9IGlzVG9wID8gZmlyc3RSZWN0LmxlZnQgOiBsYXN0UmVjdC5sZWZ0O1xuICAgICAgICB2YXIgcmlnaHQgPSBpc1RvcCA/IGZpcnN0UmVjdC5yaWdodCA6IGxhc3RSZWN0LnJpZ2h0O1xuICAgICAgICB2YXIgd2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgICAgIHZhciBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgICAgYm90dG9tOiBib3R0b20sXG4gICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICBjYXNlICdsZWZ0JzpcbiAgICBjYXNlICdyaWdodCc6XG4gICAgICB7XG4gICAgICAgIHZhciBtaW5MZWZ0ID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgY2xpZW50UmVjdHMubWFwKGZ1bmN0aW9uIChyZWN0cykge1xuICAgICAgICAgIHJldHVybiByZWN0cy5sZWZ0O1xuICAgICAgICB9KSk7XG4gICAgICAgIHZhciBtYXhSaWdodCA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIGNsaWVudFJlY3RzLm1hcChmdW5jdGlvbiAocmVjdHMpIHtcbiAgICAgICAgICByZXR1cm4gcmVjdHMucmlnaHQ7XG4gICAgICAgIH0pKTtcbiAgICAgICAgdmFyIG1lYXN1cmVSZWN0cyA9IGNsaWVudFJlY3RzLmZpbHRlcihmdW5jdGlvbiAocmVjdCkge1xuICAgICAgICAgIHJldHVybiBjdXJyZW50QmFzZVBsYWNlbWVudCA9PT0gJ2xlZnQnID8gcmVjdC5sZWZ0ID09PSBtaW5MZWZ0IDogcmVjdC5yaWdodCA9PT0gbWF4UmlnaHQ7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgX3RvcCA9IG1lYXN1cmVSZWN0c1swXS50b3A7XG4gICAgICAgIHZhciBfYm90dG9tID0gbWVhc3VyZVJlY3RzW21lYXN1cmVSZWN0cy5sZW5ndGggLSAxXS5ib3R0b207XG4gICAgICAgIHZhciBfbGVmdCA9IG1pbkxlZnQ7XG4gICAgICAgIHZhciBfcmlnaHQgPSBtYXhSaWdodDtcblxuICAgICAgICB2YXIgX3dpZHRoID0gX3JpZ2h0IC0gX2xlZnQ7XG5cbiAgICAgICAgdmFyIF9oZWlnaHQgPSBfYm90dG9tIC0gX3RvcDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRvcDogX3RvcCxcbiAgICAgICAgICBib3R0b206IF9ib3R0b20sXG4gICAgICAgICAgbGVmdDogX2xlZnQsXG4gICAgICAgICAgcmlnaHQ6IF9yaWdodCxcbiAgICAgICAgICB3aWR0aDogX3dpZHRoLFxuICAgICAgICAgIGhlaWdodDogX2hlaWdodFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIGJvdW5kaW5nUmVjdDtcbiAgICAgIH1cbiAgfVxufVxuXG52YXIgc3RpY2t5ID0ge1xuICBuYW1lOiAnc3RpY2t5JyxcbiAgZGVmYXVsdFZhbHVlOiBmYWxzZSxcbiAgZm46IGZ1bmN0aW9uIGZuKGluc3RhbmNlKSB7XG4gICAgdmFyIHJlZmVyZW5jZSA9IGluc3RhbmNlLnJlZmVyZW5jZSxcbiAgICAgICAgcG9wcGVyID0gaW5zdGFuY2UucG9wcGVyO1xuXG4gICAgZnVuY3Rpb24gZ2V0UmVmZXJlbmNlKCkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlLnBvcHBlckluc3RhbmNlID8gaW5zdGFuY2UucG9wcGVySW5zdGFuY2Uuc3RhdGUuZWxlbWVudHMucmVmZXJlbmNlIDogcmVmZXJlbmNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNob3VsZENoZWNrKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2UucHJvcHMuc3RpY2t5ID09PSB0cnVlIHx8IGluc3RhbmNlLnByb3BzLnN0aWNreSA9PT0gdmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIHByZXZSZWZSZWN0ID0gbnVsbDtcbiAgICB2YXIgcHJldlBvcFJlY3QgPSBudWxsO1xuXG4gICAgZnVuY3Rpb24gdXBkYXRlUG9zaXRpb24oKSB7XG4gICAgICB2YXIgY3VycmVudFJlZlJlY3QgPSBzaG91bGRDaGVjaygncmVmZXJlbmNlJykgPyBnZXRSZWZlcmVuY2UoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IG51bGw7XG4gICAgICB2YXIgY3VycmVudFBvcFJlY3QgPSBzaG91bGRDaGVjaygncG9wcGVyJykgPyBwb3BwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiBudWxsO1xuXG4gICAgICBpZiAoY3VycmVudFJlZlJlY3QgJiYgYXJlUmVjdHNEaWZmZXJlbnQocHJldlJlZlJlY3QsIGN1cnJlbnRSZWZSZWN0KSB8fCBjdXJyZW50UG9wUmVjdCAmJiBhcmVSZWN0c0RpZmZlcmVudChwcmV2UG9wUmVjdCwgY3VycmVudFBvcFJlY3QpKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZSkge1xuICAgICAgICAgIGluc3RhbmNlLnBvcHBlckluc3RhbmNlLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHByZXZSZWZSZWN0ID0gY3VycmVudFJlZlJlY3Q7XG4gICAgICBwcmV2UG9wUmVjdCA9IGN1cnJlbnRQb3BSZWN0O1xuXG4gICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUuaXNNb3VudGVkKSB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh1cGRhdGVQb3NpdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9uTW91bnQ6IGZ1bmN0aW9uIG9uTW91bnQoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZS5wcm9wcy5zdGlja3kpIHtcbiAgICAgICAgICB1cGRhdGVQb3NpdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcblxuZnVuY3Rpb24gYXJlUmVjdHNEaWZmZXJlbnQocmVjdEEsIHJlY3RCKSB7XG4gIGlmIChyZWN0QSAmJiByZWN0Qikge1xuICAgIHJldHVybiByZWN0QS50b3AgIT09IHJlY3RCLnRvcCB8fCByZWN0QS5yaWdodCAhPT0gcmVjdEIucmlnaHQgfHwgcmVjdEEuYm90dG9tICE9PSByZWN0Qi5ib3R0b20gfHwgcmVjdEEubGVmdCAhPT0gcmVjdEIubGVmdDtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG50aXBweS5zZXREZWZhdWx0UHJvcHMoe1xuICByZW5kZXI6IHJlbmRlclxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHRpcHB5O1xuZXhwb3J0IHsgYW5pbWF0ZUZpbGwsIGNyZWF0ZVNpbmdsZXRvbiwgZGVsZWdhdGUsIGZvbGxvd0N1cnNvciwgaGlkZUFsbCwgaW5saW5lUG9zaXRpb25pbmcsIFJPVU5EX0FSUk9XIGFzIHJvdW5kQXJyb3csIHN0aWNreSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGlwcHkuZXNtLmpzLm1hcFxuIiwiLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG52YXIgYnl0ZVRvSGV4ID0gW107XG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGJ5dGVUb0hleFtpXSA9IChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7XG59XG5cbmZ1bmN0aW9uIGJ5dGVzVG9VdWlkKGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBidGggPSBieXRlVG9IZXg7XG4gIC8vIGpvaW4gdXNlZCB0byBmaXggbWVtb3J5IGlzc3VlIGNhdXNlZCBieSBjb25jYXRlbmF0aW9uOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMTc1I2M0XG4gIHJldHVybiAoW2J0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sIFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcblx0YnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV1dKS5qb2luKCcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBieXRlc1RvVXVpZDtcbiIsIi8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuICBJbiB0aGVcbi8vIGJyb3dzZXIgdGhpcyBpcyBhIGxpdHRsZSBjb21wbGljYXRlZCBkdWUgdG8gdW5rbm93biBxdWFsaXR5IG9mIE1hdGgucmFuZG9tKClcbi8vIGFuZCBpbmNvbnNpc3RlbnQgc3VwcG9ydCBmb3IgdGhlIGBjcnlwdG9gIEFQSS4gIFdlIGRvIHRoZSBiZXN0IHdlIGNhbiB2aWFcbi8vIGZlYXR1cmUtZGV0ZWN0aW9uXG5cbi8vIGdldFJhbmRvbVZhbHVlcyBuZWVkcyB0byBiZSBpbnZva2VkIGluIGEgY29udGV4dCB3aGVyZSBcInRoaXNcIiBpcyBhIENyeXB0b1xuLy8gaW1wbGVtZW50YXRpb24uIEFsc28sIGZpbmQgdGhlIGNvbXBsZXRlIGltcGxlbWVudGF0aW9uIG9mIGNyeXB0byBvbiBJRTExLlxudmFyIGdldFJhbmRvbVZhbHVlcyA9ICh0eXBlb2YoY3J5cHRvKSAhPSAndW5kZWZpbmVkJyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChjcnlwdG8pKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YobXNDcnlwdG8pICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cubXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09ICdmdW5jdGlvbicgJiYgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQobXNDcnlwdG8pKTtcblxuaWYgKGdldFJhbmRvbVZhbHVlcykge1xuICAvLyBXSEFUV0cgY3J5cHRvIFJORyAtIGh0dHA6Ly93aWtpLndoYXR3Zy5vcmcvd2lraS9DcnlwdG9cbiAgdmFyIHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB3aGF0d2dSTkcoKSB7XG4gICAgZ2V0UmFuZG9tVmFsdWVzKHJuZHM4KTtcbiAgICByZXR1cm4gcm5kczg7XG4gIH07XG59IGVsc2Uge1xuICAvLyBNYXRoLnJhbmRvbSgpLWJhc2VkIChSTkcpXG4gIC8vXG4gIC8vIElmIGFsbCBlbHNlIGZhaWxzLCB1c2UgTWF0aC5yYW5kb20oKS4gIEl0J3MgZmFzdCwgYnV0IGlzIG9mIHVuc3BlY2lmaWVkXG4gIC8vIHF1YWxpdHkuXG4gIHZhciBybmRzID0gbmV3IEFycmF5KDE2KTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1hdGhSTkcoKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIHI7IGkgPCAxNjsgaSsrKSB7XG4gICAgICBpZiAoKGkgJiAweDAzKSA9PT0gMCkgciA9IE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDAwMDtcbiAgICAgIHJuZHNbaV0gPSByID4+PiAoKGkgJiAweDAzKSA8PCAzKSAmIDB4ZmY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJuZHM7XG4gIH07XG59XG4iLCJ2YXIgcm5nID0gcmVxdWlyZSgnLi9saWIvcm5nJyk7XG52YXIgYnl0ZXNUb1V1aWQgPSByZXF1aXJlKCcuL2xpYi9ieXRlc1RvVXVpZCcpO1xuXG4vLyAqKmB2MSgpYCAtIEdlbmVyYXRlIHRpbWUtYmFzZWQgVVVJRCoqXG4vL1xuLy8gSW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL0xpb3NLL1VVSUQuanNcbi8vIGFuZCBodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvdXVpZC5odG1sXG5cbnZhciBfbm9kZUlkO1xudmFyIF9jbG9ja3NlcTtcblxuLy8gUHJldmlvdXMgdXVpZCBjcmVhdGlvbiB0aW1lXG52YXIgX2xhc3RNU2VjcyA9IDA7XG52YXIgX2xhc3ROU2VjcyA9IDA7XG5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYnJvb2ZhL25vZGUtdXVpZCBmb3IgQVBJIGRldGFpbHNcbmZ1bmN0aW9uIHYxKG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuICB2YXIgYiA9IGJ1ZiB8fCBbXTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIG5vZGUgPSBvcHRpb25zLm5vZGUgfHwgX25vZGVJZDtcbiAgdmFyIGNsb2Nrc2VxID0gb3B0aW9ucy5jbG9ja3NlcSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jbG9ja3NlcSA6IF9jbG9ja3NlcTtcblxuICAvLyBub2RlIGFuZCBjbG9ja3NlcSBuZWVkIHRvIGJlIGluaXRpYWxpemVkIHRvIHJhbmRvbSB2YWx1ZXMgaWYgdGhleSdyZSBub3RcbiAgLy8gc3BlY2lmaWVkLiAgV2UgZG8gdGhpcyBsYXppbHkgdG8gbWluaW1pemUgaXNzdWVzIHJlbGF0ZWQgdG8gaW5zdWZmaWNpZW50XG4gIC8vIHN5c3RlbSBlbnRyb3B5LiAgU2VlICMxODlcbiAgaWYgKG5vZGUgPT0gbnVsbCB8fCBjbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgdmFyIHNlZWRCeXRlcyA9IHJuZygpO1xuICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjUsIGNyZWF0ZSBhbmQgNDgtYml0IG5vZGUgaWQsICg0NyByYW5kb20gYml0cyArIG11bHRpY2FzdCBiaXQgPSAxKVxuICAgICAgbm9kZSA9IF9ub2RlSWQgPSBbXG4gICAgICAgIHNlZWRCeXRlc1swXSB8IDB4MDEsXG4gICAgICAgIHNlZWRCeXRlc1sxXSwgc2VlZEJ5dGVzWzJdLCBzZWVkQnl0ZXNbM10sIHNlZWRCeXRlc1s0XSwgc2VlZEJ5dGVzWzVdXG4gICAgICBdO1xuICAgIH1cbiAgICBpZiAoY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgICAgLy8gUGVyIDQuMi4yLCByYW5kb21pemUgKDE0IGJpdCkgY2xvY2tzZXFcbiAgICAgIGNsb2Nrc2VxID0gX2Nsb2Nrc2VxID0gKHNlZWRCeXRlc1s2XSA8PCA4IHwgc2VlZEJ5dGVzWzddKSAmIDB4M2ZmZjtcbiAgICB9XG4gIH1cblxuICAvLyBVVUlEIHRpbWVzdGFtcHMgYXJlIDEwMCBuYW5vLXNlY29uZCB1bml0cyBzaW5jZSB0aGUgR3JlZ29yaWFuIGVwb2NoLFxuICAvLyAoMTU4Mi0xMC0xNSAwMDowMCkuICBKU051bWJlcnMgYXJlbid0IHByZWNpc2UgZW5vdWdoIGZvciB0aGlzLCBzb1xuICAvLyB0aW1lIGlzIGhhbmRsZWQgaW50ZXJuYWxseSBhcyAnbXNlY3MnIChpbnRlZ2VyIG1pbGxpc2Vjb25kcykgYW5kICduc2VjcydcbiAgLy8gKDEwMC1uYW5vc2Vjb25kcyBvZmZzZXQgZnJvbSBtc2Vjcykgc2luY2UgdW5peCBlcG9jaCwgMTk3MC0wMS0wMSAwMDowMC5cbiAgdmFyIG1zZWNzID0gb3B0aW9ucy5tc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tc2VjcyA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gIC8vIFBlciA0LjIuMS4yLCB1c2UgY291bnQgb2YgdXVpZCdzIGdlbmVyYXRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgY2xvY2tcbiAgLy8gY3ljbGUgdG8gc2ltdWxhdGUgaGlnaGVyIHJlc29sdXRpb24gY2xvY2tcbiAgdmFyIG5zZWNzID0gb3B0aW9ucy5uc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uc2VjcyA6IF9sYXN0TlNlY3MgKyAxO1xuXG4gIC8vIFRpbWUgc2luY2UgbGFzdCB1dWlkIGNyZWF0aW9uIChpbiBtc2VjcylcbiAgdmFyIGR0ID0gKG1zZWNzIC0gX2xhc3RNU2VjcykgKyAobnNlY3MgLSBfbGFzdE5TZWNzKS8xMDAwMDtcblxuICAvLyBQZXIgNC4yLjEuMiwgQnVtcCBjbG9ja3NlcSBvbiBjbG9jayByZWdyZXNzaW9uXG4gIGlmIChkdCA8IDAgJiYgb3B0aW9ucy5jbG9ja3NlcSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2xvY2tzZXEgPSBjbG9ja3NlcSArIDEgJiAweDNmZmY7XG4gIH1cblxuICAvLyBSZXNldCBuc2VjcyBpZiBjbG9jayByZWdyZXNzZXMgKG5ldyBjbG9ja3NlcSkgb3Igd2UndmUgbW92ZWQgb250byBhIG5ld1xuICAvLyB0aW1lIGludGVydmFsXG4gIGlmICgoZHQgPCAwIHx8IG1zZWNzID4gX2xhc3RNU2VjcykgJiYgb3B0aW9ucy5uc2VjcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbnNlY3MgPSAwO1xuICB9XG5cbiAgLy8gUGVyIDQuMi4xLjIgVGhyb3cgZXJyb3IgaWYgdG9vIG1hbnkgdXVpZHMgYXJlIHJlcXVlc3RlZFxuICBpZiAobnNlY3MgPj0gMTAwMDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3V1aWQudjEoKTogQ2FuXFwndCBjcmVhdGUgbW9yZSB0aGFuIDEwTSB1dWlkcy9zZWMnKTtcbiAgfVxuXG4gIF9sYXN0TVNlY3MgPSBtc2VjcztcbiAgX2xhc3ROU2VjcyA9IG5zZWNzO1xuICBfY2xvY2tzZXEgPSBjbG9ja3NlcTtcblxuICAvLyBQZXIgNC4xLjQgLSBDb252ZXJ0IGZyb20gdW5peCBlcG9jaCB0byBHcmVnb3JpYW4gZXBvY2hcbiAgbXNlY3MgKz0gMTIyMTkyOTI4MDAwMDA7XG5cbiAgLy8gYHRpbWVfbG93YFxuICB2YXIgdGwgPSAoKG1zZWNzICYgMHhmZmZmZmZmKSAqIDEwMDAwICsgbnNlY3MpICUgMHgxMDAwMDAwMDA7XG4gIGJbaSsrXSA9IHRsID4+PiAyNCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiAxNiAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdGwgJiAweGZmO1xuXG4gIC8vIGB0aW1lX21pZGBcbiAgdmFyIHRtaCA9IChtc2VjcyAvIDB4MTAwMDAwMDAwICogMTAwMDApICYgMHhmZmZmZmZmO1xuICBiW2krK10gPSB0bWggPj4+IDggJiAweGZmO1xuICBiW2krK10gPSB0bWggJiAweGZmO1xuXG4gIC8vIGB0aW1lX2hpZ2hfYW5kX3ZlcnNpb25gXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMjQgJiAweGYgfCAweDEwOyAvLyBpbmNsdWRlIHZlcnNpb25cbiAgYltpKytdID0gdG1oID4+PiAxNiAmIDB4ZmY7XG5cbiAgLy8gYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgIChQZXIgNC4yLjIgLSBpbmNsdWRlIHZhcmlhbnQpXG4gIGJbaSsrXSA9IGNsb2Nrc2VxID4+PiA4IHwgMHg4MDtcblxuICAvLyBgY2xvY2tfc2VxX2xvd2BcbiAgYltpKytdID0gY2xvY2tzZXEgJiAweGZmO1xuXG4gIC8vIGBub2RlYFxuICBmb3IgKHZhciBuID0gMDsgbiA8IDY7ICsrbikge1xuICAgIGJbaSArIG5dID0gbm9kZVtuXTtcbiAgfVxuXG4gIHJldHVybiBidWYgPyBidWYgOiBieXRlc1RvVXVpZChiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2MTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vbGliL3BpeGVsc2NodWJzZXIvdXRpbHMnKTtcblxudmFyIENhcmV0ID0gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgIHRoaXMuc2VsZWN0aW9uY2hhbmdlU3Vic2NyaWJlcnMgPSBbXTtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblxuICAgICAgICBpZihzZWxmLl9pc1NlbGVjdGlvblByb2Nlc3NlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBzZWxmLl9tYXJrU2VsZWN0aW9uQXNQcm9jZXNzZWQoc2VsZWN0aW9uKVxuICAgICAgICAgICAgZm9yKGxldCBpPTA7IGk8c2VsZi5zZWxlY3Rpb25jaGFuZ2VTdWJzY3JpYmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0aW9uY2hhbmdlU3Vic2NyaWJlcnNbaV0oc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5DYXJldC5wcm90b3R5cGUgPSB7XG5cbiAgICBzdWJzY3JpYmVTZWxlY3Rpb25DaGFuZ2U6IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25jaGFuZ2VTdWJzY3JpYmVycy5wdXNoKGYpO1xuICAgIH0sXG5cbiAgICBfbWFya1NlbGVjdGlvbkFzUHJvY2Vzc2VkOiBmdW5jdGlvbihzZWxlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5sYXN0UHJvY2Vzc2VkU2VsZWN0aW9uQ2hhbmdlID0ge1xuICAgICAgICAgICAgYW5jaG9yTm9kZTogc2VsZWN0aW9uLmFuY2hvck5vZGUsXG4gICAgICAgICAgICBhbmNob3JPZmZzZXQ6IHNlbGVjdGlvbi5hbmNob3JPZmZzZXQsXG4gICAgICAgICAgICBmb2N1c05vZGU6IHNlbGVjdGlvbi5mb2N1c05vZGUsXG4gICAgICAgICAgICBmb2N1c09mZnNldDogc2VsZWN0aW9uLmZvY3VzT2Zmc2V0XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIF9pc1NlbGVjdGlvblByb2Nlc3NlZDogZnVuY3Rpb24oc2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYXN0UHJvY2Vzc2VkU2VsZWN0aW9uQ2hhbmdlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICB0aGlzLmxhc3RQcm9jZXNzZWRTZWxlY3Rpb25DaGFuZ2UuYW5jaG9yTm9kZSAhPT0gIHNlbGVjdGlvbi5hbmNob3JOb2RlIHx8XG4gICAgICAgICAgICAgdGhpcy5sYXN0UHJvY2Vzc2VkU2VsZWN0aW9uQ2hhbmdlLmFuY2hvck9mZnNldCAhPT0gIHNlbGVjdGlvbi5hbmNob3JPZmZzZXQgfHxcbiAgICAgICAgICAgICB0aGlzLmxhc3RQcm9jZXNzZWRTZWxlY3Rpb25DaGFuZ2UuZm9jdXNOb2RlICE9PSAgc2VsZWN0aW9uLmZvY3VzTm9kZSB8fFxuICAgICAgICAgICAgIHRoaXMubGFzdFByb2Nlc3NlZFNlbGVjdGlvbkNoYW5nZS5mb2N1c09mZnNldCAhPT0gIHNlbGVjdGlvbi5mb2N1c09mZnNldFxuICAgIH0sXG5cbiAgICBfZ2V0RWxlbWVudHNDb250ZW50TGVuZ3RoSW5jcmVtZW50OiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIGlmKFsnQlInLCAnSU1HJ10uaW5jbHVkZXMoZWxlbWVudC50YWdOYW1lKSkgcmV0dXJuIDE7XG5cbiAgICAgICAgaWYoZWxlbWVudCAmJiBlbGVtZW50LmNsYXNzTGlzdCAmJiBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygndG9jLWNvbnRlbnQnKSkgcmV0dXJuIDA7XG4gICAgICAgIGlmKGVsZW1lbnQgJiYgZWxlbWVudC5jbGFzc0xpc3QgJiYgZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ21pc3NpbmdMZXZlbEhpbnQnKSkgcmV0dXJuIDA7XG5cbiAgICAgICAgaWYoZWxlbWVudC50YWdOYW1lID09PSAnTEknICYmIGVsZW1lbnQuaW5uZXJUZXh0ID09PSAnJykgcmV0dXJuIDE7XG4gICAgICAgIGlmKGVsZW1lbnQuZ2V0QXR0cmlidXRlICYmIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKSA9PT0gJ2ZhbHNlJykgcmV0dXJuIDE7XG4gICAgICAgIGlmKHRoaXMud2l0aGluVW5lZGlkYWJsZVJlZmVyZW5jZUVsKGVsZW1lbnQpKSByZXR1cm4gMDtcblxuICAgICAgICBpZihbJ0NBUFRJT04nLCAnRklHQ0FQVElPTicsICdDSVRFU1JDJ10uaW5jbHVkZXMoZWxlbWVudC50YWdOYW1lKSAmJiAoZWxlbWVudC5jaGlsZHJlbiAmJiBlbGVtZW50LmNoaWxkcmVuLmxlbmd0aCkgPT09IDApIHsgLy9GaXhtZTogU2hvdWxkIGl0IG5vdCBiZSBjaGlsZE5vZGVzIGluc3RlYWQgb2YgY2hpbGRyZW5cbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIWVsZW1lbnQubGVuZ3RoKSByZXR1cm4gMDtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQubGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvLyBleGFtcGxlIElucHV0OiAgXCJ0ZXN0PHNwYW4gY2xhc3M9XCJmb290bm90ZVwiIGRhdGEtbm90ZT1cIm5vdGUgbnVtYmVyIDExXCIgY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIj4xMTwvc3Bhbj4gdGhlIGVkaXRvciBpbnRlcmZhY2UgdG8gcmVzdG9yZVggc2VsZWN0aW9uXCJcbiAgICAvLyBleGFtcGxlIE91dHB1dDogXCJ0ZXN0XyB0aGUgZWRpdG9yIGludGVyZmFjZSB0byByZXN0b3JlWCBzZWxlY3Rpb25cIlxuICAgIC8vIC0+IGJlY2F1c2Ugd2UgY2Fubm90IHBsYWNlIHRoZSBjYXJldCB3aXRoaW4gdGhlIGZvb3Rub3RlIChvciByZWZlcmVuY2UsIGlubGluZSBlcXVhdGlvbiwgdG9jIHNlY3Rpb24pXG4gICAgLy8gd2UgcmVwbGFjZSB0aGUgZm9vdGVub3RlIHdpdGggb25lIHBsYWNlaG9sZGVyIGNoYXIuXG4gICAgX2dldENvbnRlbnRMZW5ndGhJbmNyZW1lbnRNYXNrZWRUZXh0OiBmdW5jdGlvbihyb290RWxlbWVudCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG5cblxuICAgICAgICBpZihyb290RWxlbWVudC5sZW5ndGggJiYgcm9vdEVsZW1lbnQudGV4dENvbnRlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiByb290RWxlbWVudC50ZXh0Q29udGVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJvb3RFbGVtZW50LmNoaWxkTm9kZXMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgICAgIGlmKFsnQlInLCAnSU1HJ10uaW5jbHVkZXMoZWxlbWVudC50YWdOYW1lKSkgeyByZXN1bHQgKz0gJ18nOyB9XG4gICAgICAgICAgICBlbHNlIGlmKGVsZW1lbnQgJiYgZWxlbWVudC5jbGFzc0xpc3QgJiYgZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ3RvYy1jb250ZW50JykpIHsgcmVzdWx0ICs9ICcnOyB9XG4gICAgICAgICAgICBlbHNlIGlmKGVsZW1lbnQgJiYgZWxlbWVudC5jbGFzc0xpc3QgJiYgZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ21pc3NpbmdMZXZlbEhpbnQnKSkgeyByZXN1bHQgKz0gJyc7IH1cbiAgICAgICAgICAgIGVsc2UgaWYoZWxlbWVudC50YWdOYW1lID09PSAnTEknICYmIGVsZW1lbnQuaW5uZXJUZXh0ID09PSAnJykgeyByZXN1bHQgKz0gJ18nOyB9XG4gICAgICAgICAgICBlbHNlIGlmKGVsZW1lbnQuZ2V0QXR0cmlidXRlICYmIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKSA9PT0gJ2ZhbHNlJykgeyByZXN1bHQgKz0gJ18nOyB9XG4gICAgICAgICAgICBlbHNlIGlmKHRoaXMud2l0aGluVW5lZGlkYWJsZVJlZmVyZW5jZUVsKGVsZW1lbnQpKSB7IHJlc3VsdCArPSAnJzsgfVxuXG4gICAgICAgICAgICBlbHNlIGlmKFsnQ0FQVElPTicsICdGSUdDQVBUSU9OJywgJ0NJVEVTUkMnXS5pbmNsdWRlcyhlbGVtZW50LnRhZ05hbWUpICYmIChlbGVtZW50LmNoaWxkTm9kZXMgJiYgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ18nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuX2dldENvbnRlbnRMZW5ndGhJbmNyZW1lbnRNYXNrZWRUZXh0KGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIF9nZXRDb250ZW50TGVuZ3RoT2ZET01FbGVtZW50OiBmdW5jdGlvbihlbGVtZW50LCBlbmRDaGlsZCkge1xuICAgICAgICBpZighZW5kQ2hpbGQgJiYgZWxlbWVudC5zdW1tYXJpemVkQ29udGVudExlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuc3VtbWFyaXplZENvbnRlbnRMZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZW5kU2VjdGlvbiA9IGVuZENoaWxkICYmIHV0aWxzLmdldFN1YnRyZWVCeUNoaWxkTm9kZShlbGVtZW50LCBlbmRDaGlsZCksXG4gICAgICAgICAgICBlbmRTZWN0aW9uSW5kZXggPSBlbmRTZWN0aW9uICYmIGVsZW1lbnQuY2hpbGRyZW4uaW5kZXhPZihlbmRTZWN0aW9uKSxcbiAgICAgICAgICAgIHRyZWVXYWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGVuZFNlY3Rpb24gfHwgZWxlbWVudCksXG4gICAgICAgICAgICBsZW5ndGggPSAwLFxuICAgICAgICAgICAgY3VycmVudEVsO1xuXG4gICAgICAgIGlmKGVuZFNlY3Rpb24pIHtcbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPGVuZFNlY3Rpb25JbmRleDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoICs9IHRoaXMuX2dldENvbnRlbnRMZW5ndGhPZkRPTUVsZW1lbnQoZWxlbWVudC5jaGlsZHJlbltpXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlKChjdXJyZW50RWwgPSB0cmVlV2Fsa2VyLmN1cnJlbnROb2RlKSkge1xuICAgICAgICAgICAgaWYoY3VycmVudEVsID09PSBlbmRDaGlsZCkgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgICAgIGxlbmd0aCArPSB0aGlzLl9nZXRFbGVtZW50c0NvbnRlbnRMZW5ndGhJbmNyZW1lbnQoY3VycmVudEVsKTtcblxuICAgICAgICAgICAgaWYoIXRyZWVXYWxrZXIubmV4dE5vZGUoKSkgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZighZW5kQ2hpbGQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc3VtbWFyaXplZENvbnRlbnRMZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH0sXG5cbiAgICBfd2Fsa1RvTmV4dEVkaXRhYmxlTm9kZTogZnVuY3Rpb24odHJlZVdhbGtlcikge1xuICAgICAgICB2YXIgY2FuZGlkdGUgPSB0cmVlV2Fsa2VyLm5leHROb2RlKCk7XG4gICAgICAgIGlmKCFjYW5kaWR0ZSkgeyByZXR1cm4gY2FuZGlkdGUgfVxuXG4gICAgICAgIHdoaWxlKHRoaXMud2l0aGluVW5lZGlkYWJsZVJlZmVyZW5jZUVsKGNhbmRpZHRlKSkge1xuICAgICAgICAgICAgY2FuZGlkdGUgPSB0cmVlV2Fsa2VyLm5leHROb2RlKCk7XG4gICAgICAgICAgICBpZighY2FuZGlkdGUpIHsgcmV0dXJuIGNhbmRpZHRlIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjYW5kaWR0ZTtcbiAgICB9LFxuXG4gICAgLy8gcmlnaHRNYXRjaDogd2hlbiByb290IGVsZW1lbnQgY29udGFpbnM6ICc8cD5IZWxsbzwvcD48cD5Xb3JsZDwvcD4nIGFuZCBjb250ZW50TGVuZ3RoIGlzICc1J1xuICAgIC8vICAgICAgICAgICAgIGl0IGlzIG5vdCBjbGVhciB3aGljaCBlbGVtZW50IHRvIHJldHVybiwgaWYgcmlnaHRNYXRjaCBpcyB0cnVlIHRoZW4gJzxwPldvcmxkPC9wPicgd2lsbFxuICAgIC8vICAgICAgICAgICAgIGJlIHJldHVybmVkLCAnPHA+SGVsbG88L3A+JyBvdGhlcndpc2VcbiAgICBfZ2V0RWxlbWVudEJ5Q29udGVudExlbmd0aDogZnVuY3Rpb24ocm9vdEVsLCBjb250ZW50TGVuZ3RoLCByaWdodE1hdGNoKSB7XG4gICAgICAgIHZhciB0cmVlV2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihyb290RWwpLFxuICAgICAgICAgICAgY3VycmVudEVsLFxuICAgICAgICAgICAgbGVuZ3RoID0gMCxcbiAgICAgICAgICAgIGN1cnJlbnRFbExlbmd0aDtcblxuICAgICAgICB3aGlsZShjdXJyZW50RWwgPSB0cmVlV2Fsa2VyLmN1cnJlbnROb2RlKSB7XG4gICAgICAgICAgICBjdXJyZW50RWxMZW5ndGggPSB0aGlzLl9nZXRFbGVtZW50c0NvbnRlbnRMZW5ndGhJbmNyZW1lbnQoY3VycmVudEVsKTtcblxuICAgICAgICAgICAgaWYoKGxlbmd0aCArIGN1cnJlbnRFbExlbmd0aCkgPCBjb250ZW50TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoICs9IGN1cnJlbnRFbExlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSBpZigobGVuZ3RoICsgY3VycmVudEVsTGVuZ3RoKSA9PT0gY29udGVudExlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByaWdodE1hdGNoID8gKHRoaXMuX3dhbGtUb05leHRFZGl0YWJsZU5vZGUodHJlZVdhbGtlcikgfHwgY3VycmVudEVsKSA6IGN1cnJlbnRFbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRFbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIXRyZWVXYWxrZXIubmV4dE5vZGUoKSkgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgX2dldEZpcnN0UGFyZW50V2hpY2hNYXRjaENvbnRleHQ6IGZ1bmN0aW9uKG5vZGUsIGNvbnRleHQpIHtcbiAgICAgICAgaWYoIW5vZGUpIHJldHVybjtcblxuICAgICAgICB2YXIgdG1wTm9kZSA9IG5vZGUsXG4gICAgICAgICAgICBjb250ZXh0VHlwZSxcbiAgICAgICAgICAgIG1hdGNoRm5zO1xuXG4gICAgICAgIGlmKCFBcnJheS5pc0FycmF5KGNvbnRleHQpKSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gW2NvbnRleHRdXG4gICAgICAgIH1cblxuICAgICAgICBtYXRjaEZucyA9IGNvbnRleHQubWFwKGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAgICAgaWYoY3R4LnN0YXJ0c1dpdGgoJy4nKSkge1xuICAgICAgICAgICAgICAgIGNvbnRleHRUeXBlID0gJ2NsYXNzJztcbiAgICAgICAgICAgICAgICBjdHggPSBjdHguc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0VHlwZSA9ICd0YWcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZigoY29udGV4dFR5cGUgPT09ICd0YWcnIHx8ICFjb250ZXh0VHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24obm9kZSkge3JldHVybiBub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IGN0eH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtyZXR1cm4gbm9kZS5jbGFzc0xpc3QgJiYgbm9kZS5jbGFzc0xpc3QuY29udGFpbnMoY3R4KX1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICB3aGlsZSh0bXBOb2RlKSB7XG4gICAgICAgICAgICBpZihtYXRjaEZucy5zb21lKGZ1bmN0aW9uKG1hdGNoRm4pIHtyZXR1cm4gbWF0Y2hGbih0bXBOb2RlKX0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRtcE5vZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRtcE5vZGUgPSB0bXBOb2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaXNXaXRoaW5FbGVtZW50OiBmdW5jdGlvbihlbCkge1xuICAgICAgICB2YXIgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuXG4gICAgICAgIHJldHVybiBzZWwuZm9jdXNOb2RlICYmXG4gICAgICAgICAgICAgICBzZWwuYW5jaG9yTm9kZSAmJlxuICAgICAgICAgICAgICAgZWwuY29udGFpbnMoc2VsLmZvY3VzTm9kZSkgJiZcbiAgICAgICAgICAgICAgIGVsLmNvbnRhaW5zKHNlbC5hbmNob3JOb2RlKVxuICAgIH0sXG5cbiAgICBnZXRQcmVjZWRpbmdDaGFyYWN0ZXI6IGZ1bmN0aW9uKGNvbnRleHRFbGVtZW50KSB7XG4gICAgICAgIHZhciBwcmVjZWRpbmdDaGFyID0gJycsIHNlbCwgcmFuZ2U7XG4gICAgICAgIHZhciBzZWwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIGlmIChzZWwucmFuZ2VDb3VudCA+IDApIHtcbiAgICAgICAgICAgIHJhbmdlID0gc2VsLmdldFJhbmdlQXQoMCkuY2xvbmVSYW5nZSgpO1xuICAgICAgICAgICAgcmFuZ2UuY29sbGFwc2UodHJ1ZSk7XG4gICAgICAgICAgICByYW5nZS5zZXRTdGFydChjb250ZXh0RWxlbWVudCwgMCk7XG4gICAgICAgICAgICBwcmVjZWRpbmdDaGFyID0gcmFuZ2UudG9TdHJpbmcoKS5zbGljZSgtMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByZWNlZGluZ0NoYXI7XG4gICAgfSxcblxuICAgIGlzUHJlY2VkaW5nQ2hhcmFjdGVyV2hpdGVzcGFjZTogZnVuY3Rpb24oY29udGV4dEVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHByZWNlZGluZ0NoYXJhY3RlciA9IENhcmV0LnByb3RvdHlwZS5nZXRQcmVjZWRpbmdDaGFyYWN0ZXIoY29udGV4dEVsZW1lbnQpLFxuICAgICAgICAgICAgcHJlY2VkaW5nQ2hhcmFjdGVyQ29kZTtcblxuICAgICAgICBpZighcHJlY2VkaW5nQ2hhcmFjdGVyKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICAgIHByZWNlZGluZ0NoYXJhY3RlckNvZGUgPSBwcmVjZWRpbmdDaGFyYWN0ZXIuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgcmV0dXJuIChwcmVjZWRpbmdDaGFyYWN0ZXJDb2RlID09PSAzMiB8fCBwcmVjZWRpbmdDaGFyYWN0ZXJDb2RlID09PSAxNjApO1xuICAgIH0sXG5cbiAgICBpc0NvbGxhcHNlZEFuZFBvc2l0aW9uZWRBdFRoZUZpcnN0TGluZU9mOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIGlmKCFub2RlLm9mZnNldFRvcCkgeyByZXR1cm4gfVxuXG4gICAgICAgIGlmKG5vZGUuaW5uZXJUZXh0ID09PSAnJyAmJiAobm9kZS50YWdOYW1lID09PSAnT0wnIHx8IG5vZGUudGFnTmFtZSA9PT0gJ1VMJykpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXRFbCA9IHRoaXMuZ2V0Q29udGV4dEVsZW1lbnQoJ2xpJyk7XG4gICAgICAgICAgICBpZih0YXJnZXRFbCAmJiB0YXJnZXRFbCAhPT0gbm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYobm9kZS5pbm5lclRleHQgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSksXG4gICAgICAgICAgICBjYXJldFBvcyA9IHRoaXMuZ2V0UG9zaXRpb24oKSxcbiAgICAgICAgICAgIGNhcmV0UG9zWSA9IGNhcmV0UG9zICYmIGNhcmV0UG9zLnksXG4gICAgICAgICAgICBwYWRkaW5nVG9wID0gcGFyc2VJbnQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgncGFkZGluZy10b3AnKSksXG4gICAgICAgICAgICBsaW5lSGVpZ2h0ID0gcGFyc2VJbnQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnbGluZS1oZWlnaHQnKSksXG4gICAgICAgICAgICBmaXJzdExpbmVTdGFydFlQb3MgPSBub2RlLm9mZnNldFRvcCArIHBhZGRpbmdUb3AsXG4gICAgICAgICAgICBmaXJzdExpbmVFbmRZUG9zID0gZmlyc3RMaW5lU3RhcnRZUG9zICsgbGluZUhlaWdodDtcblxuICAgICAgICByZXR1cm4gZmlyc3RMaW5lU3RhcnRZUG9zIDwgY2FyZXRQb3NZICYmIGZpcnN0TGluZUVuZFlQb3MgPiBjYXJldFBvc1k7XG4gICAgfSxcblxuICAgIGlzQ29sbGFwc2VkQW5kUG9zaXRpb25lZEF0VGhlTGFzdExpbmVPZjogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBpZighbm9kZS5vZmZzZXRUb3ApIHsgcmV0dXJuIH1cbiAgICAgICAgaWYobm9kZS5pbm5lclRleHQgPT09ICcnKSB7IHJldHVybiB0cnVlIH1cblxuICAgICAgICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKSxcbiAgICAgICAgICAgIGNhcmV0UG9zID0gdGhpcy5nZXRQb3NpdGlvbigpLFxuICAgICAgICAgICAgY2FyZXRQb3NZID0gY2FyZXRQb3MgJiYgY2FyZXRQb3MueSxcbiAgICAgICAgICAgIHBhZGRpbmdCb3R0b20gPSBwYXJzZUludChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdwYWRkaW5nLWJvdHRvbScpKSxcbiAgICAgICAgICAgIGxpbmVIZWlnaHQgPSBwYXJzZUludChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdsaW5lLWhlaWdodCcpKSxcbiAgICAgICAgICAgIGJvcmRlckJvdHRvbSA9IDEsXG4gICAgICAgICAgICBsYXN0TGluZUVuZFlQb3MgPSAobm9kZS5vZmZzZXRUb3AgKyBub2RlLm9mZnNldEhlaWdodCkgLSBwYWRkaW5nQm90dG9tIC0gYm9yZGVyQm90dG9tLFxuICAgICAgICAgICAgbGFzdExpbmVTdGFydFlQb3MgPSBsYXN0TGluZUVuZFlQb3MgLSBsaW5lSGVpZ2h0IC0gMTA7XG5cbiAgICAgICAgcmV0dXJuIGxhc3RMaW5lRW5kWVBvcyA+IGNhcmV0UG9zWSAmJiBsYXN0TGluZVN0YXJ0WVBvcyA8IGNhcmV0UG9zWTtcbiAgICB9LFxuXG4gICAgaXNDb2xsYXBzZWRBbmRQb3NpdGlvbmVkQXRUaGVCZWdpbm5pbmdPZjogZnVuY3Rpb24obm9kZSwgaWdub3JlRmlyc3RDaGFySWZXaGl0ZXNwYWNlKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCksXG4gICAgICAgICAgICBwb3M7XG5cbiAgICAgICAgaWdub3JlRmlyc3RDaGFySWZXaGl0ZXNwYWNlID0gaWdub3JlRmlyc3RDaGFySWZXaGl0ZXNwYWNlID09PSB1bmRlZmluZWQgPyB0cnVlIDogaWdub3JlRmlyc3RDaGFySWZXaGl0ZXNwYWNlO1xuXG4gICAgICAgIGlmKCFzZWxlY3Rpb24uaXNDb2xsYXBzZWQgfHwgIW5vZGUpIHsgcmV0dXJuIGZhbHNlIH1cblxuICAgICAgICBwb3MgPSB0aGlzLl9nZXRDb250ZW50TGVuZ3RoT2ZET01FbGVtZW50KG5vZGUsIHNlbGVjdGlvbi5hbmNob3JOb2RlKSArIHNlbGVjdGlvbi5hbmNob3JPZmZzZXQ7XG4gICAgICAgIGlmKGlnbm9yZUZpcnN0Q2hhcklmV2hpdGVzcGFjZSAmJlxuICAgICAgICAgICBwb3MgPT09IDEgJiZcbiAgICAgICAgICAgbm9kZS5jaGlsZE5vZGVzICYmIG5vZGUuY2hpbGROb2Rlc1swXSA9PT0gc2VsZWN0aW9uLmFuY2hvck5vZGUgJiZcbiAgICAgICAgICAgKHNlbGVjdGlvbi5mb2N1c05vZGUubm9kZVZhbHVlICYmIChzZWxlY3Rpb24uZm9jdXNOb2RlLm5vZGVWYWx1ZVswXSA9PT0gJ1xcdTAwQTAnIHx8IHNlbGVjdGlvbi5mb2N1c05vZGUubm9kZVZhbHVlWzBdID09PSAnICcpKSkge1xuXG4gICAgICAgICAgICAvLyB3aGVuIHRoZSBmaXJzdCBub2RlIG9mIHRoZSBzZWN0aW9uIGlzIGZvY3VzZWQgYW5kIGl0IHN0YXJ0cyB3aXRoXG4gICAgICAgICAgICAvLyBhIHdoaXRlIHNwYWNlIHdlIGRvIG5vdCBtaW5kIHdoZXRoZXIgdGhlIGNhcmV0IGlzIHBsYWNlZCByaWdodCBvclxuICAgICAgICAgICAgLy8gbGVmdCBmcm9tIHRoYXQgd2hpdGVzcGFjZS4gVGhpcyBpcyBiZWNhdXNlIGZvciBzb21lIHJlYXNvbiB0aGUgYnJvd3NlclxuICAgICAgICAgICAgLy8ganVzdCBkb2VzIG5vdCBkaXNwbGF5IHRoaXMgd2hpdGVzcGFjZSA/IT8hPyBCbGFtZSB0aGlzIGxpbmUgaW4gZ2l0XG4gICAgICAgICAgICAvLyBhbmQgc2VlIHRoZSBzcGVjIGluIHRoZSBzYW1lIGNvbW1pdCB0byBnZXQgbW9yZSBkZXRhaWxzIGFib3V0IHRoaXNcbiAgICAgICAgICAgIC8vIHNwZWNpZmMgc2NlbmFyaW8uXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb3MgPT09IDA7XG4gICAgfSxcblxuICAgIGlzQ29sbGFwc2VkQW5kUG9zaXRpb25lZEF0VGhlRW5kT2Y6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSxcbiAgICAgICAgICAgIHBvcywgbm9kZUxlbmd0aCwgbGFzdEVsO1xuXG4gICAgICAgIGlmKCFzZWxlY3Rpb24uaXNDb2xsYXBzZWQgfHwgIW5vZGUpIHsgcmV0dXJuIGZhbHNlIH1cblxuICAgICAgICBpZihzZWxlY3Rpb24uYW5jaG9yTm9kZSA9PT0gbm9kZSAmJiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0ID09PSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBvcyA9IHRoaXMuX2dldENvbnRlbnRMZW5ndGhPZkRPTUVsZW1lbnQobm9kZSwgc2VsZWN0aW9uLmFuY2hvck5vZGUpICsgc2VsZWN0aW9uLmFuY2hvck9mZnNldDtcbiAgICAgICAgbm9kZUxlbmd0aCA9IHRoaXMuX2dldENvbnRlbnRMZW5ndGhPZkRPTUVsZW1lbnQobm9kZSk7XG5cbiAgICAgICAgaWYocG9zID09PSBub2RlTGVuZ3RoLTEgJiYgbm9kZS5pbm5lclRleHRbbm9kZS5pbm5lclRleHQubGVuZ3RoLTFdID09PSAnXFxuJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9zID09PSBub2RlTGVuZ3RoO1xuICAgIH0sXG5cbiAgICBwb3NpdGlvbkF0VGhlQmVnaW5uaW5nT2Y6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKSxcbiAgICAgICAgICAgIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblxuICAgICAgICByYW5nZS5zZXRFbmQobm9kZSwgMCk7XG4gICAgICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIDApO1xuICAgICAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgfSxcblxuICAgIHBvc2l0aW9uQWZ0ZXI6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIG5vZGVJbmRleCxcbiAgICAgICAgICAgIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKSxcbiAgICAgICAgICAgIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSxcbiAgICAgICAgICAgIHVuZWRpdGFibGVQYXJlbnQgPSB0aGlzLndpdGhpblVuZWRpZGFibGVSZWZlcmVuY2VFbChub2RlKTtcblxuICAgICAgICBpZih1bmVkaXRhYmxlUGFyZW50KSB7XG4gICAgICAgICAgICBub2RlID0gdW5lZGl0YWJsZVBhcmVudFxuICAgICAgICB9XG5cbiAgICAgICAgaWYobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBub2RlSW5kZXggPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKG5vZGUucGFyZW50Tm9kZS5jaGlsZE5vZGVzLCBub2RlKTtcbiAgICAgICAgICAgIHJhbmdlLnNldEVuZChub2RlLnBhcmVudE5vZGUsIG5vZGVJbmRleCsxKTtcbiAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUucGFyZW50Tm9kZSwgbm9kZUluZGV4KzEpO1xuICAgICAgICAgICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBwb3NpdGlvbkluOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCksXG4gICAgICAgICAgICBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKG5vZGUpO1xuICAgICAgICByYW5nZS5jb2xsYXBzZSgpO1xuICAgICAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgfSxcblxuICAgIG1vZGlmeVJhbmdlVG9CZVZhbGlkSW5zZXJ0UG9zaXRpb246IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgIHZhciBub2RlID0gcmFuZ2UgJiYgcmFuZ2UuY29sbGFwc2VkICYmIHJhbmdlLnN0YXJ0Q29udGFpbmVyLFxuICAgICAgICAgICAgZmlyc3RMSTtcblxuICAgICAgICBpZihub2RlICYmIFsnVUwnLCAnT0wnXS5pbmNsdWRlcyhub2RlLnRhZ05hbWUpICYmIHJhbmdlLnN0YXJ0T2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICBpZihmaXJzdExJID0gbm9kZS5xdWVyeVNlbGVjdG9yKCdsaScpKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoZmlyc3RMSSwgMCk7XG4gICAgICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKGZpcnN0TEksIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH0sXG5cbiAgICBpbnNlcnROb2RlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpLFxuICAgICAgICAgICAgcmFuZ2UgPSBzZWwuZ2V0UmFuZ2VBdCgwKTtcblxuICAgICAgICB0aGlzLm1vZGlmeVJhbmdlVG9CZVZhbGlkSW5zZXJ0UG9zaXRpb24ocmFuZ2UpO1xuICAgICAgICByYW5nZS5pbnNlcnROb2RlKG5vZGUpO1xuICAgICAgICByYW5nZS5jb2xsYXBzZSgpO1xuICAgICAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgIHNlbC5hZGRSYW5nZShyYW5nZSk7XG5cbiAgICAgICAgaWYobm9kZS5uZXh0U2libGluZyAmJiBub2RlLm5leHRTaWJsaW5nLm5vZGVWYWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIG5vZGUubmV4dFNpYmxpbmcucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaW5zZXJ0TGluZUJyZWFrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdicicpLFxuICAgICAgICAgICAgZm9jdXNlZFNlY3Rpb24gPSB0aGlzLmVkaXRvci5mb2N1c2VkU2VjdGlvbigpLFxuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmVkaXRvci5pbmRleE9mRm9jdXNlZFNlY3Rpb24oKSxcbiAgICAgICAgICAgIG5leHRTZWN0aW9uID0gMTtcblxuICAgICAgICBpZih0aGlzLmlzUG9zaXRpb25lZEF0VGhlQmVnaW5uaW5nT2ZGb2N1c05vZGUod2luZG93LmdldFNlbGVjdGlvbigpKSkge1xuICAgICAgICAgICAgbmV4dFNlY3Rpb24gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lZGl0b3IuY2FyZXQuaW5zZXJ0Tm9kZShub2RlKTtcbiAgICAgICAgdGhpcy5lZGl0b3IucmVwbGFjZVNlY3Rpb25XaXRoSFRNTChmb2N1c2VkU2VjdGlvbiwgZm9jdXNlZFNlY3Rpb24ub3V0ZXJIVE1MLCB7XG4gICAgICAgICAgICBwb3NpdGlvbkNhcmV0QXRUaGVFbmRPZlNlY3Rpb25XaXRoSW5kZXg6IGluZGV4K25leHRTZWN0aW9uXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICB3aXRoaW5VbmVkaWRhYmxlUmVmZXJlbmNlRWw6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgaWYobm9kZSAmJiBub2RlLmlzQ29udGVudEVkaXRhYmxlKSB7IHJldHVybiBmYWxzZSB9XG5cbiAgICAgICAgdmFyIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSxcbiAgICAgICAgICAgIHRtcE5vZGUgPSBub2RlIHx8IHNlbC5mb2N1c05vZGU7XG5cbiAgICAgICAgaWYoIXRtcE5vZGUpIHsgcmV0dXJuIGZhbHNlIH1cblxuICAgICAgICB3aGlsZSh0bXBOb2RlKSB7XG4gICAgICAgICAgICBpZih0bXBOb2RlLmlzQ29udGVudEVkaXRhYmxlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZih0bXBOb2RlLmdldEF0dHJpYnV0ZSAmJiB0bXBOb2RlLmdldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykgPT09ICdmYWxzZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG1wTm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG1wTm9kZSA9IHRtcE5vZGUucGFyZW50RWxlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgaXNQb3NpdGlvbmVkQXRUaGVFbmRPZkZvY3VzTm9kZTogZnVuY3Rpb24oc2VsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3Rpb24uaXNDb2xsYXBzZWQgJiZcbiAgICAgICAgICAgICAgIHNlbGVjdGlvbi5mb2N1c05vZGUgJiZcbiAgICAgICAgICAgICAgIHNlbGVjdGlvbi5mb2N1c09mZnNldCA9PT0gc2VsZWN0aW9uLmZvY3VzTm9kZS5sZW5ndGg7XG4gICAgfSxcblxuICAgIGlzUG9zaXRpb25lZEF0VGhlQmVnaW5uaW5nT2ZGb2N1c05vZGU6IGZ1bmN0aW9uKHNlbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gc2VsZWN0aW9uLmlzQ29sbGFwc2VkICYmXG4gICAgICAgICAgICAgICBzZWxlY3Rpb24uZm9jdXNOb2RlICYmXG4gICAgICAgICAgICAgICBzZWxlY3Rpb24uZm9jdXNPZmZzZXQgPT09IDA7XG4gICAgfSxcblxuICAgIGdldFRhbmdldE5vZGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpLFxuICAgICAgICAgICAgdGFuZ2VudE5vZGVzID0ge2xlZnQ6IG51bGwsIHJpZ2h0OiBudWxsfSxcbiAgICAgICAgICAgIG5vZGVJdGVyYXRvcixcbiAgICAgICAgICAgIGVuc3VyZVNhbWVTZWN0aW9uID0gZnVuY3Rpb24obikgeyByZXR1cm4gbiB9O1xuXG4gICAgICAgIGlmKHRoaXMuZWRpdG9yICYmIHNlbGYuZWRpdG9yLmZvY3VzZWRTZWN0aW9uKSB7XG4gICAgICAgICAgICBlbnN1cmVTYW1lU2VjdGlvbiA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgICAgICBpZihuICYmIHNlbGYuZWRpdG9yLmZvY3VzZWRTZWN0aW9uKCkgPT09IHNlbGYuZWRpdG9yLnNlY3Rpb25CeUNoaWxkTm9kZShuKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZihzZWxlY3Rpb24gJiYgc2VsZWN0aW9uLmZvY3VzTm9kZSAmJiBzZWxlY3Rpb24uZm9jdXNOb2RlLm5vZGVUeXBlICE9PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBzZWxlY3Rpb24uZm9jdXNOb2RlLmNoaWxkTm9kZXNbc2VsZWN0aW9uLmZvY3VzT2Zmc2V0LTFdLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBzZWxlY3Rpb24uZm9jdXNOb2RlLmNoaWxkTm9kZXNbc2VsZWN0aW9uLmZvY3VzT2Zmc2V0XVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbm9kZUl0ZXJhdG9yID0gdXRpbHMuZ2V0Tm9kZUl0ZXJhdG9yUG9pbnRpbmdUbyhzZWxlY3Rpb24uZm9jdXNOb2RlKTtcblxuICAgICAgICBpZighbm9kZUl0ZXJhdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFuZ2VudE5vZGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5pc1Bvc2l0aW9uZWRBdFRoZUJlZ2lubmluZ09mRm9jdXNOb2RlKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHRhbmdlbnROb2Rlcy5sZWZ0ID0gZW5zdXJlU2FtZVNlY3Rpb24obm9kZUl0ZXJhdG9yLnByZXZpb3VzTm9kZSgpKTtcbiAgICAgICAgICAgIG5vZGVJdGVyYXRvci5uZXh0Tm9kZSgpOyAvL21vdmUgdGhlIGl0ZXJhdG9yIGJhY2sgdG8gdGhlIGZvY3VzIG5vZGVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuaXNQb3NpdGlvbmVkQXRUaGVFbmRPZkZvY3VzTm9kZShzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICB0YW5nZW50Tm9kZXMucmlnaHQgPSBlbnN1cmVTYW1lU2VjdGlvbihub2RlSXRlcmF0b3IubmV4dE5vZGUoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFuZ2VudE5vZGVzO1xuICAgIH0sXG5cbiAgICAvLyBUaGlzIG1ldGhvZCBmaW5kcyBhIERPTSBlbGVtZW50IHdoaWNoIHdyYXBzIHRoZSBwYXNzZWQgc2VsZWN0aW9uIGFuZCBtYXRjaGVzIHRoZSBjb250ZXh0LlxuICAgIC8vICAgLSB3cmFwcyBtZWFucywgZm9jdXNOb2RlIGFuZCBhbmNob3JOb2RlIGFyZSBjb250YWluZWQgd2l0aGluIHRoZSBlbGVtZW50XG4gICAgLy8gICAtIG1hdGNoZXMgdGhlIGNvbnRleHQgbWVhbnMsIHRoZSByZXR1cm5lZCBlbGVtZW50IGhhcyBlaXRoZXIgKGRlcGVuZGluZyBvbiBjb250ZXh0VHlwZSwgc2VlIGJlbG93KVxuICAgIC8vICAgICB0aGUgc2FtZSB0YWdOYW1lIGFzIHNwZWNpZmllZCBpbiBjb250ZXh0LCBvciBhIGNsYXNzIG5hbWUgc3BlY2lmaWVkIGluIGNvbnRleHRcbiAgICAvLyAgIC0gdGhlIGNvbnRleHRUeXBlIGlzIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGNoYXIgb2YgdGhlIGNvbnRleHQgYXJndW1lbnQuIElmIGl0IGlzICcuJyB0aGUgdHlwZSBpc1xuICAgIC8vICAgICBcImNsYXNzXCIgd2lsbCBtYXRjaCBhIGVsZW1lbnQgd2hpY2ggaGFzIHRoZSBhY2NvcmRpbmcgY2xhc3MgYXNzaWduZWQgaW4gaXRzIGNsYXNzIGF0dHJpYnV0ZS5cbiAgICAvLyAgICAgSWYgdGhlIGNvbnRleHQgZG9lcyBub3Qgc3RhcnQgd2l0aCBhICcuJyBhIGVsZW1lbnQgd2l0aCB0aGUgYWNjb3JkaW5nIHRhZyBuYW1lIHdpbGwgbWF0Y2guXG4gICAgZ2V0Q29udGV4dEVsZW1lbnQ6IGZ1bmN0aW9uKGNvbnRleHQsIHNlbGVjdGlvbiwgdGFuZ2VudE5vZGVzKSB7XG4gICAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbiB8fCB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIHRhbmdlbnROb2RlcyA9IHRhbmdlbnROb2RlcyB8fCB0aGlzLmdldFRhbmdldE5vZGVzKCk7XG5cbiAgICAgICAgaWYoc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDApIHJldHVybiBudWxsO1xuXG4gICAgICAgIHZhciBjb21tb25BbmNlc3RvciA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRGaXJzdFBhcmVudFdoaWNoTWF0Y2hDb250ZXh0KGNvbW1vbkFuY2VzdG9yLCBjb250ZXh0KSB8fFxuICAgICAgICAgICAgICAgdGhpcy5fZ2V0Rmlyc3RQYXJlbnRXaGljaE1hdGNoQ29udGV4dCh0YW5nZW50Tm9kZXMucmlnaHQsIGNvbnRleHQpIHx8XG4gICAgICAgICAgICAgICB0aGlzLl9nZXRGaXJzdFBhcmVudFdoaWNoTWF0Y2hDb250ZXh0KHRhbmdlbnROb2Rlcy5sZWZ0LCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgZ2V0UG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpLFxuICAgICAgICAgICAgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKSxcbiAgICAgICAgICAgIHJlY3QgPSByYW5nZS5nZXRDbGllbnRSZWN0cygpWzBdLFxuICAgICAgICAgICAgdG47XG5cbiAgICAgICAgaWYocmVjdCkge1xuICAgICAgICAgIHJldHVybiB7eDogcmVjdC5sZWZ0LCB5OiByZWN0LnRvcCArIHdpbmRvdy5zY3JvbGxZLCB3aWR0aDogcmVjdC53aWR0aCwgaGVpZ2h0OiByZWN0LmhlaWdodH07XG4gICAgICAgIH1cblxuICAgICAgICB0biA9IHRoaXMuZ2V0VGFuZ2V0Tm9kZXMoKTtcblxuICAgICAgICBpZih0bi5sZWZ0ICYmIHRuLmxlZnQubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHModG4ubGVmdCk7XG4gICAgICAgICAgICByYW5nZS5jb2xsYXBzZShmYWxzZSk7XG4gICAgICAgICAgICByZWN0ID0gcmFuZ2UuZ2V0Q2xpZW50UmVjdHMoKVswXTtcbiAgICAgICAgICAgIHJldHVybiB7eDogcmVjdC5sZWZ0K3JlY3Qud2lkdGgsIHk6IHJlY3QudG9wICsgd2luZG93LnNjcm9sbFksIHdpZHRoOiAwLCBoZWlnaHQ6IHJlY3QuaGVpZ2h0fTtcbiAgICAgICAgfSBlbHNlIGlmKHRuLmxlZnQpIHtcbiAgICAgICAgICAgIHJlY3QgPSB0bi5sZWZ0LmdldENsaWVudFJlY3RzKClbMF07XG4gICAgICAgICAgICByZXR1cm4ge3g6IHJlY3QubGVmdCtyZWN0LndpZHRoLCB5OiByZWN0LnRvcCArIHdpbmRvdy5zY3JvbGxZLCB3aWR0aDogMCwgaGVpZ2h0OiByZWN0LmhlaWdodH07XG4gICAgICAgIH0gZWxzZSBpZighcmVjdCAmJiByYW5nZS5zdGFydENvbnRhaW5lciA9PT0gcmFuZ2UuZW5kQ29udGFpbmVyKSAge1xuICAgICAgICAgICAgcmVjdCA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyLmdldENsaWVudFJlY3RzKClbMF07XG4gICAgICAgICAgICByZXR1cm4ge3g6IHJlY3QubGVmdCwgeTogcmVjdC50b3AgKyB3aW5kb3cuc2Nyb2xsWSwgd2lkdGg6IHJlY3Qud2lkdGgsIGhlaWdodDogcmVjdC5oZWlnaHR9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaXQgc2VlZW1zIHRoZXJlIGlzIG5vIGtub3duIHNpdHVhdGlvbiBpbiB3aGljaCB3ZSBoYXZlIHRvIGNvbnNpZGVyIHRuLnJpZ2h0XG4gICAgfSxcblxuICAgIHJlc3RvcmVTZWxlY3Rpb246IGZ1bmN0aW9uKG1vdmVUb0xlZnQsIHN0cmF0ZWd5KSB7XG4gICAgICAgIHN0cmF0ZWd5ID0gc3RyYXRlZ3kgfHwgJ09mZnNldFN0cmF0ZWd5JztcbiAgICAgICAgaWYoc3RyYXRlZ3kgPT09ICdPZmZzZXRTdHJhdGVneScpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3RvcmVTZWxlY3Rpb25WaWFPZmZzZXRTdHJhdGVneShtb3ZlVG9MZWZ0KTtcbiAgICAgICAgfSBlbHNlIGlmKHN0cmF0ZWd5ID09PSAnVHJ5RE9NU3RyYXRlZ3lGaXJzdCcpIHtcbiAgICAgICAgICAgIGlmKCF0aGlzLnJlc3RvcmVTZWxlY3Rpb25WaWFET01TdHJhdGVneSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdG9yZVNlbGVjdGlvblZpYU9mZnNldFN0cmF0ZWd5KG1vdmVUb0xlZnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN0b3JlU2VsZWN0aW9uVmlhRE9NU3RyYXRlZ3koKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBwYXJhbSAnbW92ZVRvTGVmdCc6IHdpbGwgY29ycmVjdCB0aGUgcG9pc3Rpb24gYnkgdGhlIGdpdmVuIGFtb3VudCBvZiBjaGFyXG4gICAgcmVzdG9yZVNlbGVjdGlvblZpYU9mZnNldFN0cmF0ZWd5OiBmdW5jdGlvbihtb3ZlVG9MZWZ0LCBzYXZlZFNlbGVjdGlvbikge1xuICAgICAgICBtb3ZlVG9MZWZ0ID0gbW92ZVRvTGVmdCB8fCAwO1xuXG4gICAgICAgIGlmKHNhdmVkU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3RFbCA9IHNhdmVkU2VsZWN0aW9uLnJvb3RFbDtcbiAgICAgICAgICAgIHRoaXMucmFuZ2VTdGFydCA9IHNhdmVkU2VsZWN0aW9uLnJhbmdlU3RhcnQ7XG4gICAgICAgICAgICB0aGlzLnJhbmdlRW5kID0gc2F2ZWRTZWxlY3Rpb24ucmFuZ2VFbmQ7XG4gICAgICAgICAgICB0aGlzLmlzQW5jaG9yTGVmdCA9IHNhdmVkU2VsZWN0aW9uLmlzQW5jaG9yTGVmdDtcbiAgICAgICAgICAgIHRoaXMucmFuZ2VTdGFydEF0WmVyb09mZnNldCA9IHNhdmVkU2VsZWN0aW9uLnJhbmdlU3RhcnRBdFplcm9PZmZzZXQ7XG4gICAgICAgICAgICB0aGlzLnJhbmdlRW5kQXRaZXJvT2Zmc2V0ID0gIHNhdmVkU2VsZWN0aW9uLnJhbmdlRW5kQXRaZXJvT2Zmc2V0O1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25Gb2N1c05vZGUgPSBzYXZlZFNlbGVjdGlvbi5zZWxlY3Rpb25Gb2N1c05vZGU7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkFuY2hvck5vZGUgPSBzYXZlZFNlbGVjdGlvbi5zZWxlY3Rpb25BbmNob3JOb2RlO1xuICAgICAgICAgICAgdGhpcy5yYW5nZVN0YXJ0QXRaZXJvT2Zmc2V0ID0gc2F2ZWRTZWxlY3Rpb24ucmFuZ2VTdGFydEF0WmVyb09mZnNldDtcbiAgICAgICAgICAgIHRoaXMucmFuZ2VFbmRBdFplcm9PZmZzZXQgPSBzYXZlZFNlbGVjdGlvbi5yYW5nZUVuZEF0WmVyb09mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuc2VsZWN0aW9uSXNVbmVkaWRhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuY2FycmV0UGxhY2VtZW50Q29ycmVjdGlvbikge1xuICAgICAgICAgICAgbW92ZVRvTGVmdCArPSB0aGlzLmNhcnJldFBsYWNlbWVudENvcnJlY3Rpb247XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJhbmdlU3RhcnRBdFplcm9PZmZzZXQgPSAodGhpcy5zZWxlY3Rpb25BbmNob3JPZmZzZXQtbW92ZVRvTGVmdCkgPT09IDA7XG4gICAgICAgIHRoaXMucmFuZ2VFbmRBdFplcm9PZmZzZXQgPSAodGhpcy5zZWxlY3Rpb25Gb2N1c09mZnNldC1tb3ZlVG9MZWZ0KSA9PT0gMDtcblxuICAgICAgICBpZih0eXBlb2YgdGhpcy5yYW5nZVN0YXJ0ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdGhpcy5yYW5nZUVuZCA9PT0gJ251bWJlcicpIHtcblxuICAgICAgICAgICAgdmFyIHJhbmdlLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSxcbiAgICAgICAgICAgICAgICBzdGFydE5vZGUgPSB0aGlzLl9nZXRFbGVtZW50QnlDb250ZW50TGVuZ3RoKHRoaXMucm9vdEVsLCB0aGlzLnJhbmdlU3RhcnQgLSBtb3ZlVG9MZWZ0LCB0aGlzLnJhbmdlU3RhcnRBdFplcm9PZmZzZXQpLFxuICAgICAgICAgICAgICAgIHN0YXJ0T2Zmc2V0ID0gdGhpcy5yYW5nZVN0YXJ0IC0gbW92ZVRvTGVmdCAtIHRoaXMuX2dldENvbnRlbnRMZW5ndGhPZkRPTUVsZW1lbnQodGhpcy5yb290RWwsIHN0YXJ0Tm9kZSksXG4gICAgICAgICAgICAgICAgZW5kTm9kZSxcbiAgICAgICAgICAgICAgICBlbmRPZmZzZXQsXG4gICAgICAgICAgICAgICAgdW5lZGlhYmxlQ29udGV4RWw7XG5cbiAgICAgICAgICAgIGlmKHRoaXMuc2VsZWN0aW9uSXNDb2xsYXBzZWQpIHtcbiAgICAgICAgICAgICAgICBlbmROb2RlID0gc3RhcnROb2RlO1xuICAgICAgICAgICAgICAgIGVuZE9mZnNldCA9IHN0YXJ0T2Zmc2V0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmROb2RlID0gdGhpcy5fZ2V0RWxlbWVudEJ5Q29udGVudExlbmd0aCh0aGlzLnJvb3RFbCwgdGhpcy5yYW5nZUVuZCAtIG1vdmVUb0xlZnQsIHRoaXMucmFuZ2VFbmRBdFplcm9PZmZzZXQpO1xuICAgICAgICAgICAgICAgIGVuZE9mZnNldCA9IHRoaXMucmFuZ2VFbmQgLSBtb3ZlVG9MZWZ0IC0gdGhpcy5fZ2V0Q29udGVudExlbmd0aE9mRE9NRWxlbWVudCh0aGlzLnJvb3RFbCwgZW5kTm9kZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHVuZWRpYWJsZUNvbnRleEVsID0gc3RhcnROb2RlID09IGVuZE5vZGUgJiYgKHVuZWRpYWJsZUNvbnRleEVsID0gdGhpcy53aXRoaW5VbmVkaWRhYmxlUmVmZXJlbmNlRWwoc3RhcnROb2RlKSk7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYodW5lZGlhYmxlQ29udGV4RWwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRPZmZzZXQgPSBlbmRPZmZzZXQgPSB1bmVkaWFibGVDb250ZXhFbC5wYXJlbnRFbGVtZW50LmNoaWxkTm9kZXMuaW5kZXhPZih1bmVkaWFibGVDb250ZXhFbCkgKyAxO1xuICAgICAgICAgICAgICAgICAgICBzdGFydE5vZGUgPSBlbmROb2RlID0gdW5lZGlhYmxlQ29udGV4RWwucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5pc0FuY2hvckxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnROb2RlLCBzdGFydE9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldEVuZChlbmROb2RlLCBlbmRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldEVuZChzdGFydE5vZGUsIHN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoZW5kTm9kZSwgZW5kT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnZmFpbGVkIHRvIHNldCBjYXJldCBwb3NpdGlvbiB2aWEgb2Zmc2V0IHN0cmF0ZWd5JywgZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZXN0b3JlU2VsZWN0aW9uVmlhRE9NU3RyYXRlZ3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmFuZ2UsIHNlbGVjdGlvbjtcblxuICAgICAgICBpZighdGhpcy5yb290RWwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuc2VsZWN0aW9uSXNVbmVkaWRhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMucm9vdEVsLmNvbnRhaW5zKHRoaXMuc2VsZWN0aW9uQW5jaG9yTm9kZSkgJiYgdGhpcy5yb290RWwuY29udGFpbnModGhpcy5zZWxlY3Rpb25Gb2N1c05vZGUpKSB7XG4gICAgICAgICAgICByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBpZih0aGlzLmlzQW5jaG9yTGVmdCkge1xuICAgICAgICAgICAgICAgIHJhbmdlLnNldEVuZCh0aGlzLnNlbGVjdGlvbkFuY2hvck5vZGUsIHRoaXMuc2VsZWN0aW9uQW5jaG9yT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydCh0aGlzLnNlbGVjdGlvbkZvY3VzTm9kZSwgdGhpcy5zZWxlY3Rpb25Gb2N1c09mZnNldCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KHRoaXMuc2VsZWN0aW9uQW5jaG9yTm9kZSwgdGhpcy5zZWxlY3Rpb25BbmNob3JPZmZzZXQpO1xuICAgICAgICAgICAgICAgIHJhbmdlLnNldEVuZCh0aGlzLnNlbGVjdGlvbkZvY3VzTm9kZSwgdGhpcy5zZWxlY3Rpb25Gb2N1c09mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIHNhdmVTZWxlY3Rpb246IGZ1bmN0aW9uKHJvb3RFbCwgaW5zZXJ0ZWRDb250ZW50KSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgICAgaWYodGhpcy53aXRoaW5VbmVkaWRhYmxlUmVmZXJlbmNlRWwoc2VsZWN0aW9uLmFuY2hvck5vZGUpKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbklzVW5lZGlkYWJsZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZighc2VsZWN0aW9uLmlzQ29sbGFwc2VkICYmIHRoaXMud2l0aGluVW5lZGlkYWJsZVJlZmVyZW5jZUVsKHNlbGVjdGlvbi5mb2N1c05vZGUpKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbklzVW5lZGlkYWJsZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbklzVW5lZGlkYWJsZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5zZWxlY3Rpb25Jc1VuZWRpZGFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHNlbGVjdGlvbklzVW5lZGlkYWJsZTogdHJ1ZSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoc2VsZWN0aW9uLmFuY2hvck5vZGUgJiYgc2VsZWN0aW9uLmZvY3VzTm9kZSkge1xuICAgICAgICAgICAgaWYoc2VsZWN0aW9uLmFuY2hvck5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yYW5nZVN0YXJ0ID0gdGhpcy5fZ2V0Q29udGVudExlbmd0aE9mRE9NRWxlbWVudChyb290RWwsIHNlbGVjdGlvbi5hbmNob3JOb2RlKSArIHNlbGVjdGlvbi5hbmNob3JPZmZzZXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmFuZ2VTdGFydCA9IHRoaXMuX2dldENvbnRlbnRMZW5ndGhPZkRPTUVsZW1lbnQocm9vdEVsLCBzZWxlY3Rpb24uYW5jaG9yTm9kZSk7XG4gICAgICAgICAgICAgICAgZm9yKGxldCBpPTA7IGk8c2VsZWN0aW9uLmFuY2hvck9mZnNldDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmFuZ2VTdGFydCArPSB0aGlzLl9nZXRDb250ZW50TGVuZ3RoT2ZET01FbGVtZW50KHNlbGVjdGlvbi5hbmNob3JOb2RlLmNoaWxkTm9kZXNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoc2VsZWN0aW9uLmlzQ29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yYW5nZUVuZCA9IHRoaXMucmFuZ2VTdGFydDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYoc2VsZWN0aW9uLmZvY3VzTm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yYW5nZUVuZCA9IHRoaXMuX2dldENvbnRlbnRMZW5ndGhPZkRPTUVsZW1lbnQocm9vdEVsLCBzZWxlY3Rpb24uZm9jdXNOb2RlKSArIHNlbGVjdGlvbi5mb2N1c09mZnNldDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJhbmdlRW5kID0gdGhpcy5fZ2V0Q29udGVudExlbmd0aE9mRE9NRWxlbWVudChyb290RWwsIHNlbGVjdGlvbi5mb2N1c05vZGUpO1xuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGk9MDsgaTxzZWxlY3Rpb24uZm9jdXNPZmZzZXQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yYW5nZUVuZCArPSB0aGlzLl9nZXRDb250ZW50TGVuZ3RoT2ZET01FbGVtZW50KHNlbGVjdGlvbi5mb2N1c05vZGUuY2hpbGROb2Rlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucm9vdEVsID0gcm9vdEVsO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25Jc1VuZWRpZGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuaXNBbmNob3JMZWZ0ID0gdGhpcy5yYW5nZVN0YXJ0IDw9IHRoaXMucmFuZ2VFbmQ7XG4gICAgICAgICAgICB0aGlzLnJhbmdlU3RhcnRBdFplcm9PZmZzZXQgPSBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0ID09PSAwO1xuICAgICAgICAgICAgdGhpcy5yYW5nZUVuZEF0WmVyb09mZnNldCA9IHNlbGVjdGlvbi5mb2N1c09mZnNldCA9PT0gMDtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uQW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3JOb2RlO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25Gb2N1c05vZGUgPSBzZWxlY3Rpb24uZm9jdXNOb2RlO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25BbmNob3JPZmZzZXQgPSBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0O1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25Gb2N1c09mZnNldCA9IHNlbGVjdGlvbi5mb2N1c09mZnNldDtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uSXNDb2xsYXBzZWQgPSBzZWxlY3Rpb24uaXNDb2xsYXBzZWQ7XG5cbiAgICAgICAgICAgIHRoaXMuZm9sbG93aW5nU3BhY2VUZXJtaW5hdGVzVGV4dE5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yTm9kZSA9PT0gc2VsZWN0aW9uLmZvY3VzTm9kZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5mb2N1c05vZGUubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uLmFuY2hvck9mZnNldCA9PT0gKHNlbGVjdGlvbi5mb2N1c05vZGUubGVuZ3RoLTEpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNlbGVjdGlvbi5mb2N1c05vZGUubm9kZVZhbHVlW3NlbGVjdGlvbi5mb2N1c05vZGUubGVuZ3RoLTFdID09PSAnXFx1MDBBMCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uLmZvY3VzTm9kZS5ub2RlVmFsdWVbc2VsZWN0aW9uLmZvY3VzTm9kZS5sZW5ndGgtMV0gPT09ICcgJyk7XG5cbiAgICAgICAgICAgICBpZihpbnNlcnRlZENvbnRlbnQgPT09ICcgJyAmJiB0aGlzLmZvbGxvd2luZ1NwYWNlVGVybWluYXRlc1RleHROb2RlKSB7XG4gICAgICAgICAgICAgICB0aGlzLmNhcnJldFBsYWNlbWVudENvcnJlY3Rpb24gPSAtMTtcbiAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgdGhpcy5jYXJyZXRQbGFjZW1lbnRDb3JyZWN0aW9uID0gMDtcbiAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJvb3RFbDogdGhpcy5yb290RWwsXG4gICAgICAgICAgICAgICAgcmFuZ2VTdGFydDogdGhpcy5yYW5nZVN0YXJ0LFxuICAgICAgICAgICAgICAgIHJhbmdlRW5kOiB0aGlzLnJhbmdlRW5kLFxuICAgICAgICAgICAgICAgIGlzQW5jaG9yTGVmdDogdGhpcy5pc0FuY2hvckxlZnQsXG4gICAgICAgICAgICAgICAgcmFuZ2VTdGFydEF0WmVyb09mZnNldDogdGhpcy5yYW5nZVN0YXJ0QXRaZXJvT2Zmc2V0LFxuICAgICAgICAgICAgICAgIHJhbmdlRW5kQXRaZXJvT2Zmc2V0OiB0aGlzLnJhbmdlRW5kQXRaZXJvT2Zmc2V0LFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbkZvY3VzTm9kZTogdGhpcy5zZWxlY3Rpb25Gb2N1c05vZGUsXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uQW5jaG9yTm9kZTogdGhpcy5zZWxlY3Rpb25BbmNob3JOb2RlLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbklzQ29sbGFwc2VkOiB0aGlzLnNlbGVjdGlvbklzQ29sbGFwc2VkLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbklzVW5lZGlkYWJsZTogdGhpcy5zZWxlY3Rpb25Jc1VuZWRpZGFibGVcbiAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY2xlYXJTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgfSxcblxuICAgIHRhcmdldEVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gd2luZG93LmdldFNlbGVjdGlvbigpLmZvY3VzTm9kZTtcbiAgICB9LFxuXG4gICAgaXNDb2xsYXBzZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpLFxuICAgICAgICAgICAgcmFuZ2U7XG5cbiAgICAgICAgaWYoc2VsLnJhbmdlQ291bnQgPT09IDApIHJldHVybjtcblxuICAgICAgICByYW5nZSA9IHNlbC5nZXRSYW5nZUF0KDApO1xuICAgICAgICBpZighcmFuZ2UpIHJldHVybjtcbiAgICAgICAgcmV0dXJuIHJhbmdlLmNvbGxhcHNlZDtcbiAgICB9LFxuXG4gICAgLy8gSWYgdGhlIHNlbGVjdGlvbiBpcyBub3QgY29sbGFwc2VkIGFuZCB0aGUgc3RhcnQgb3IgZW5kXG4gICAgLy8gaXMgb3V0c2l0ZSB0aGUgZ2l2ZW4gZWxlbWVudCwgdGhpcyBmdW5jdGlvbiB3aWxsIG1vdmUgdGhlXG4gICAgLy8gY29ycmVzcG9uZGluZyBzZWxlY3Rpb24gZW5kIGluc2lkZSB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAvL1xuICAgIC8vIEluIHRoZSBmb2xsb3dpbmcgRXhhbXBsZSB0aGUgcGFzc2VkIGVsZW1lbnQgaXMgdGhlIHAgc2VjdGlvblxuICAgIC8vIGluIHRoZSBtaWRkbGU6XG4gICAgLy8gPHA+dGV4dDwvcD48cD53fGl0aDwvcD48cD5wYXJhZ3J8YXBoczwvcD5cbiAgICAvLyA9PlxuICAgIC8vIDxwPnRleHQ8L3A+PHA+d3xpdGh8PC9wPjxwPnBhcmFncmFwaHM8L3A+XG4gICAgLy9cbiAgICAvLyBUaGlzIGlzIGFjdHVhbGx5IG5vdCB1c2VkIG9uIHNlY3Rpb24gbGV2ZWwgYnV0IHRvIGVuc3VyZVxuICAgIC8vIHRoYXQgdGhlIHNlbGVjdGlvbiBpcyB3aXRoaW4gdGhlIGVkaXRvciBpdGVzZWxmLlxuICAgIGVuc3VyZUV4cGFuZGVkU2VsZWN0aW9uSXNXaXRoaW5FbGVtZW50OiBmdW5jdGlvbihlbCkge1xuICAgICAgICB2YXIgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpLFxuICAgICAgICAgICAgbjEgPSBzZWwuZm9jdXNOb2RlLFxuICAgICAgICAgICAgbzEgPSBzZWwuZm9jdXNPZmZzZXQsXG4gICAgICAgICAgICBuMiA9IHNlbC5hbmNob3JOb2RlLFxuICAgICAgICAgICAgbzIgPSBzZWwuYW5jaG9yT2Zmc2V0LFxuICAgICAgICAgICAgdG1wLCBuMUluY2x1ZGVkSW5FbCwgbjJJbmNsdWRlZEluRWwsIG4xUG9zLCBuMlBvcyxcbiAgICAgICAgICAgIG4xQW5kTjJBcmVGb2xsb3dpbmdFbCwgbjFBbmROMkFyZVByZWNlZGluZ0VsLCBjaGlsZEVsLFxuICAgICAgICAgICAgZWxXYWxrZXIsIG5ld1JhbmdlO1xuXG4gICAgICAgIGlmKCFuMSB8fCAhbjIgfHwgc2VsLmlzQ29sbGFwc2VkKSB7IHJldHVybiB9XG5cbiAgICAgICAgbjFQb3MgPSBuMS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihlbCk7XG4gICAgICAgIG4yUG9zID0gbjIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZWwpO1xuXG4gICAgICAgIG4xSW5jbHVkZWRJbkVsID0gbjFQb3MgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5TO1xuICAgICAgICBuMkluY2x1ZGVkSW5FbCA9IG4yUG9zICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9DT05UQUlOUztcblxuICAgICAgICBpZihuMUluY2x1ZGVkSW5FbCAmJiBuMkluY2x1ZGVkSW5FbCkgeyByZXR1cm4gfVxuXG4gICAgICAgIG4xQW5kTjJBcmVGb2xsb3dpbmdFbCA9ICEhKChuMVBvcyAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HKSAmJiAobjJQb3MgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORykgJiYgIW4xSW5jbHVkZWRJbkVsICYmICFuMkluY2x1ZGVkSW5FbCk7XG4gICAgICAgIG4xQW5kTjJBcmVQcmVjZWRpbmdFbCA9ICEhKChuMVBvcyAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fUFJFQ0VESU5HKSAmJiAobjJQb3MgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORykgJiYgIW4xSW5jbHVkZWRJbkVsICYmICFuMkluY2x1ZGVkSW5FbCk7XG5cbiAgICAgICAgaWYobjFBbmROMkFyZUZvbGxvd2luZ0VsIHx8IG4xQW5kTjJBcmVQcmVjZWRpbmdFbCkgeyByZXR1cm4gfVxuXG4gICAgICAgIGlmKG4xLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKG4yKSAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fUFJFQ0VESU5HKSB7XG4gICAgICAgICAgICB0bXAgPSBuMjsgbjIgPSBuMTsgbjEgPSB0bXA7XG4gICAgICAgICAgICB0bXAgPSBvMjsgbzIgPSBvMTsgbzEgPSB0bXA7XG4gICAgICAgICAgICB0bXAgPSBuMkluY2x1ZGVkSW5FbDsgbjJJbmNsdWRlZEluRWwgPSBuMUluY2x1ZGVkSW5FbDsgbjFJbmNsdWRlZEluRWwgPSB0bXA7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdSYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG5cbiAgICAgICAgaWYoIW4xSW5jbHVkZWRJbkVsKSB7XG4gICAgICAgICAgICBlbFdhbGtlciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoZWwsIE5vZGVGaWx0ZXIuU0hPV19URVhULCBudWxsLCBmYWxzZSk7XG4gICAgICAgICAgICBuZXdSYW5nZS5zZXRTdGFydChlbFdhbGtlci5maXJzdENoaWxkKCksIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3UmFuZ2Uuc2V0U3RhcnQobjEsIG8xKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFuMkluY2x1ZGVkSW5FbCkge1xuICAgICAgICAgICAgZWxXYWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGVsLCBOb2RlRmlsdGVyLlNIT1dfVEVYVCwgbnVsbCwgZmFsc2UpO1xuICAgICAgICAgICAgY2hpbGRFbCA9IGVsV2Fsa2VyLmxhc3RDaGlsZCgpO1xuICAgICAgICAgICAgbmV3UmFuZ2Uuc2V0RW5kKGNoaWxkRWwsIGNoaWxkRWwubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld1JhbmdlLnNldEVuZChuMiwgbzIpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICBzZWwuYWRkUmFuZ2UobmV3UmFuZ2UpO1xuICAgIH0sXG5cbiAgICBnZXRDb250ZW50TGVuZ3RoVGlsbFNlY3Rpb246IGZ1bmN0aW9uKHNlY3Rpb24pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IDA7XG4gICAgICAgIHNlY3Rpb24gPSBzZWN0aW9uLnByZXZpb3VzU2libGluZztcblxuICAgICAgICB3aGlsZShzZWN0aW9uKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5fZ2V0Q29udGVudExlbmd0aE9mRE9NRWxlbWVudChzZWN0aW9uKTtcbiAgICAgICAgICAgIHNlY3Rpb24gPSBzZWN0aW9uLnByZXZpb3VzU2libGluZztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDYXJldDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEhUTUxSYXpvciA9IHJlcXVpcmUoJy4uL2xpYi9odG1sX3Jhem9yL2h0bWxfcmF6b3InKSxcbiAgICBUYWdUcmFuc2Zvcm1hdGlvbnMgPSByZXF1aXJlKCcuLi9saWIvaHRtbF9yYXpvci90YWdfdHJhbnNmb3JtYXRpb24nKSxcbiAgICBDYXJldCA9IHJlcXVpcmUoJy4vY2FyZXQnKSxcbiAgICBTZWN0aW9uVHlwZVNlbGVjdG9yQ29udHJvbCA9IHJlcXVpcmUoJy4vc2VjdGlvbl90eXBlX3NlbGVjdG9yX2NvbnRyb2wnKSxcbiAgICBLZXlQcmVzc0hhbmRsZXIgPSByZXF1aXJlKCcuL2tleV9wcmVzc19oYW5kbGVyJyksXG4gICAgVGV4dEVucmljaG1lbnRDb250cm9sID0gcmVxdWlyZSgnLi90ZXh0X2VucmljaG1lbnRfY29udHJvbCcpLFxuICAgIERvY3VtZW50dXBkYXRlciA9IHJlcXVpcmUoJy4uL2xpYi9kb2N1bWVudHVwZGF0ZXIvZG9jdW1lbnR1cGRhdGVyJyksXG4gICAgTW9kaWZpY2F0aW9uTG9nRW50cnkgPSByZXF1aXJlKCcuLi9saWIvZG9jdW1lbnR1cGRhdGVyL21vZGlmaWNhdGlvbl9sb2cnKSxcbiAgICBSZWZlcmVuY2VTdG9yZSA9IHJlcXVpcmUoJy4vcmVmZXJlbmNlcy9yZWZlcmVuY2Vfc3RvcmUnKSxcbiAgICBSZWZlcmVuY2VDb250cm9sbGVyID0gcmVxdWlyZSgnLi9yZWZlcmVuY2VzL3JlZmVyZW5jZV9jb250cm9sbGVyJyksXG4gICAgRGVjbGFyYXRpdkZvcm0gPSByZXF1aXJlKCcuLi9saWIvZGVjbGFyYXRpdl9mb3Jtcy9zcmMvZGVjbGFyYXRpdl9mb3JtJyksXG4gICAgQ2hhbmdlc2V0ID0gcmVxdWlyZSgnY2hhbmdlc2V0cycpLkNoYW5nZXNldCxcbiAgICBwYXJhZ3JhcGhTZWN0aW9uVHlwZSA9IHJlcXVpcmUoJy4vc2VjdGlvbl90eXBlcy9wYXJhZ3JhcGgvcGFyYWdyYXBoX3NlY3Rpb25fdHlwZScpLFxuICAgIHRhYmxlU2VjdGlvblR5cGUgPSByZXF1aXJlKCcuL3NlY3Rpb25fdHlwZXMvdGFibGUvdGFibGVfc2VjdGlvbl90eXBlJyksXG4gICAgdW5vcmRlcmVkTGlzdFNlY3Rpb25UeXBlID0gcmVxdWlyZSgnLi9zZWN0aW9uX3R5cGVzL2xpc3QvdW5vcmRlcmVkX2xpc3Rfc2VjdGlvbl90eXBlJyksXG4gICAgb3JkZXJlZExpc3RTZWN0aW9uVHlwZSA9IHJlcXVpcmUoJy4vc2VjdGlvbl90eXBlcy9saXN0L29yZGVyZWRfbGlzdF9zZWN0aW9uX3R5cGUnKSxcbiAgICBpbWFnZVNlY3Rpb25UeXBlID0gcmVxdWlyZSgnLi9zZWN0aW9uX3R5cGVzL2ltYWdlL2ltYWdlX3NlY3Rpb25fdHlwZScpLFxuICAgIGNvZGVTZWN0aW9uVHlwZSA9IHJlcXVpcmUoJy4vc2VjdGlvbl90eXBlcy9jb2RlL2NvZGVfc2VjdGlvbl90eXBlJyksXG4gICAgdG9jU2VjdGlvblR5cGUgPSByZXF1aXJlKCcuL3NlY3Rpb25fdHlwZXMvdG9jL3RvY19zZWN0aW9uX3R5cGUnKSxcbiAgICBiaWJsaW9ncmFwaGllU2VjdGlvblR5cGUgPSByZXF1aXJlKCcuL3NlY3Rpb25fdHlwZXMvYmlibGlvZ3JhcGhpZS9iaWJsaW9ncmFwaGllX3NlY3Rpb25fdHlwZScpLFxuICAgIGZvb3Rub3Rlc1NlY3Rpb25UeXBlID0gcmVxdWlyZSgnLi9zZWN0aW9uX3R5cGVzL2Zvb3Rub3Rlcy9mb290bm90ZXNfc2VjdGlvbl90eXBlJyksXG4gICAgZm9ybXVsYVNlY3Rpb25UeXBlID0gcmVxdWlyZSgnLi9zZWN0aW9uX3R5cGVzL2Zvcm11bGEvZm9ybXVsYV9zZWN0aW9uX3R5cGUnKSxcbiAgICBtZXJtYWlkU2VjdGlvblR5cGUgPSByZXF1aXJlKCcuL3NlY3Rpb25fdHlwZXMvbWVybWFpZC9tZXJtYWlkX3NlY3Rpb25fdHlwZScpLFxuICAgIGJsb2NrcXVvdGVTZWN0aW9uVHlwZSA9IHJlcXVpcmUoJy4vc2VjdGlvbl90eXBlcy9ibG9ja3F1b3RlL2Jsb2NrcXVvdGVfc2VjdGlvbl90eXBlJyksXG4gICAgaGVhZGluZzFTZWN0aW9uVHlwZSA9IHJlcXVpcmUoJy4vc2VjdGlvbl90eXBlcy9oZWFkaW5nL2hlYWRpbmcxJyksXG4gICAgaGVhZGluZzJTZWN0aW9uVHlwZSA9IHJlcXVpcmUoJy4vc2VjdGlvbl90eXBlcy9oZWFkaW5nL2hlYWRpbmcyJyksXG4gICAgaGVhZGluZzNTZWN0aW9uVHlwZSA9IHJlcXVpcmUoJy4vc2VjdGlvbl90eXBlcy9oZWFkaW5nL2hlYWRpbmczJyksXG4gICAgaGVhZGluZzRTZWN0aW9uVHlwZSA9IHJlcXVpcmUoJy4vc2VjdGlvbl90eXBlcy9oZWFkaW5nL2hlYWRpbmc0JyksXG4gICAgaGVhZGluZzVTZWN0aW9uVHlwZSA9IHJlcXVpcmUoJy4vc2VjdGlvbl90eXBlcy9oZWFkaW5nL2hlYWRpbmc1JyksXG4gICAgdXRpbHMgPSByZXF1aXJlKCcuLi9saWIvcGl4ZWxzY2h1YnNlci91dGlscycpLFxuICAgIC8vIGthdGV4ID0gcmVxdWlyZSgna2F0ZXgnKSwgLy8gbWFrZSBzdXJlIHRvIGxvYWQgPHNjcmlwdCBzcmM9XCIuL2thdGV4LmpzXCIgZGVmZXI+PC9zY3JpcHQ+IGluIHlvdXIgaHRtbFxuICAgIHV1aWQgPSByZXF1aXJlKCd1dWlkL3YxJyksXG4gICAgaXNNYWMgPSBuYXZpZ2F0b3IucGxhdGZvcm0uaW5kZXhPZihcIk1hY1wiKSA9PT0gMDtcblxud2luZG93LkNoYW5nZXNldCA9IENoYW5nZXNldDtcblxuRE9NVG9rZW5MaXN0LnByb3RvdHlwZS5maW5kID0gQXJyYXkucHJvdG90eXBlLmZpbmQ7XG5Ob2RlTGlzdC5wcm90b3R5cGUuaW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xuTm9kZUxpc3QucHJvdG90eXBlLmZpbHRlciA9IEFycmF5LnByb3RvdHlwZS5maWx0ZXI7XG5Ob2RlTGlzdC5wcm90b3R5cGUuZm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoO1xuTm9kZUxpc3QucHJvdG90eXBlLm1hcCA9IEFycmF5LnByb3RvdHlwZS5tYXA7XG5IVE1MQ29sbGVjdGlvbi5wcm90b3R5cGUuaW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xuSFRNTENvbGxlY3Rpb24ucHJvdG90eXBlLmZpbHRlciA9IEFycmF5LnByb3RvdHlwZS5maWx0ZXI7XG5IVE1MQ29sbGVjdGlvbi5wcm90b3R5cGUuZm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoO1xuSFRNTENvbGxlY3Rpb24ucHJvdG90eXBlLm1hcCA9IEFycmF5LnByb3RvdHlwZS5tYXA7XG5BcnJheS5wcm90b3R5cGUuY29udGFpbnMgPSBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXM7XG5BcnJheS5wcm90b3R5cGUuaW5jbHVkZXNBbGwgPSBmdW5jdGlvbigpIHsgdmFyIHNlbGYgPSB0aGlzLCBhcmdzID0gQXJyYXkuZnJvbShhcmd1bWVudHMpOyByZXR1cm4gYXJncy5ldmVyeShmdW5jdGlvbihyKSB7cmV0dXJuIHNlbGYuaW5jbHVkZXMocikgfSl9XG5BcnJheS5wcm90b3R5cGUudW5pcXVlID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbiAodmFsdWUsIGluZGV4LCBzZWxmKSB7IHJldHVybiBzZWxmLmluZGV4T2YodmFsdWUpID09PSBpbmRleCB9KSB9XG5cbnZhciBFZGl0b3IgPSBmdW5jdGlvbihkb21JZCwgb3B0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gICAgdGhpcy5faW5pdERvbmUgPSBmYWxzZTtcbiAgICB0aGlzLl9pc0NvbnRlbnRFZGl0YWJsZSA9IHRydWU7XG4gICAgdGhpcy5yZWZlcmVuY2UgPSBuZXcgUmVmZXJlbmNlQ29udHJvbGxlcihuZXcgUmVmZXJlbmNlU3RvcmUob3B0aW9ucy5jb250ZW50SUQsIG9wdGlvbnMuUmVmZXJlbmNlUGVyc2l0ZW5jeURyaXZlciksIHRoaXMpO1xuICAgIHRoaXMudGFnVHJhbnNmb3JtYXRpb25zID0gbmV3IFRhZ1RyYW5zZm9ybWF0aW9ucygpO1xuICAgIHRoaXMuZG9tSWQgPSBkb21JZDtcbiAgICB0aGlzLmhpbnRFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0ZS1pbnB1dC1oaW50JylcbiAgICB0aGlzLmNvbnRhaW5lckVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkb21JZCk7XG4gICAgdGhpcy5jb250YWluZXJFbGVtZW50LmlubmVySFRNTCA9ICcnO1xuICAgIHRoaXMuY29udGVudEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmNhcmV0ID0gbmV3IENhcmV0KHRoaXMpO1xuICAgIHRoaXMuc3Vic2NyaWJlcnMgPSBbXTtcbiAgICB0aGlzLnJlZmVyZW5jZUluc2VydGVkU3Vic2NyaWJlcnMgPSBbXTtcbiAgICB0aGlzLnNlY3Rpb25Gb2N1c0NoYW5nZVN1YnNjcmliZXJzID0gW107XG4gICAgdGhpcy5zZWN0aW9uVHlwZVNlbGVjdG9yID0gbmV3IFNlY3Rpb25UeXBlU2VsZWN0b3JDb250cm9sKHRoaXMuY2hhbmdlRm9jdXNlZFNlY3Rpb25UeXBlLCB0aGlzLCB0aGlzKTtcbiAgICB0aGlzLnRleHRFbnJpY2htZW50Q29udHJvbCA9IG5ldyBUZXh0RW5yaWNobWVudENvbnRyb2wodGhpcyk7XG4gICAgdGhpcy5rZXlQcmVzc0hhbmRsZXIgPSBuZXcgS2V5UHJlc3NIYW5kbGVyKHRoaXMpO1xuXG4gICAgdGhpcy5jb250ZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3NwZWxsY2hlY2snLCBvcHRpb25zLnNwZWxsY2hlY2spO1xuICAgIHRoaXMuY29udGVudEVsZW1lbnQuY2xhc3NOYW1lID0gJ3N0cnVjdHVyZWQtdGV4dC1lZGl0b3InO1xuXG4gICAgdGhpcy5oaW50RWwuaW5uZXJIVE1MID0gYFdyaXRlIEhlcmUuLi4gUHJlc3MgPGNvZGU+JHtpc01hYyA/ICfijJgnIDogJ0N0cmwnfTwvY29kZT4gKyA8Y29kZT5pPC9jb2RlPiB0byBpbnNlcnQgYSByZWZlcmVuY2UsIGZvb3Rub3RlIG9yIGVxdWF0aW9uLmA7XG5cbiAgICB0aGlzLmNvbnRhaW5lckVsZW1lbnQuY2xhc3NOYW1lID0gJ3N0cnVjdHVyZWQtdGV4dC1lZGl0b3ItY29udGFpbmVyJztcbiAgICB0aGlzLmNvbnRhaW5lckVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5idWlsZEFkZFNlY3Rpb25CdXR0b24oJ3RvcCcpKTtcbiAgICB0aGlzLmNvbnRhaW5lckVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50RWxlbWVudCk7XG4gICAgdGhpcy5jb250YWluZXJFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuYnVpbGRBZGRTZWN0aW9uQnV0dG9uKCdib3R0b20nKSk7XG5cbiAgICB0aGlzLnN1cHBvcnRlZFNlY3Rpb25UeXBlcyA9IHt9O1xuXG4gICAgdGhpcy5oaXN0b3J5ID0gW107XG4gICAgdGhpcy51bmRvbmVNb2RpZmljYXRpb25zID0gW107XG4gICAgdGhpcy5jYXJldFBvc2l0aW9ucyA9IFtdO1xuXG4gICAgdGhpcy5tYXJrdXBUcmFuc2Zvcm1hdGlvbnMgPSBbXG4gICAgICAgIHsgdG86ICd0YWJsZScsICAgICBwcmFlZml4OiAnI3RhYmxlJyAgfSxcbiAgICAgICAgeyB0bzogJ3ByZScsICAgICAgIHByYWVmaXg6ICcjY29kZScgICB9LFxuICAgICAgICB7IHRvOiAnaDEnLCAgICAgICAgcHJhZWZpeDogJyN0aXRsZScgIH0sXG4gICAgICAgIHsgdG86ICdoMicsICAgICAgICBwcmFlZml4OiAnIycgICAgICAgfSxcbiAgICAgICAgeyB0bzogJ2gyJywgICAgICAgIHByYWVmaXg6ICcjaDEnICAgICB9LFxuICAgICAgICB7IHRvOiAnaDMnLCAgICAgICAgcHJhZWZpeDogJyMjJyAgICAgIH0sXG4gICAgICAgIHsgdG86ICdoMycsICAgICAgICBwcmFlZml4OiAnI2gyJyAgICAgfSxcbiAgICAgICAgeyB0bzogJ2g0JywgICAgICAgIHByYWVmaXg6ICcjIyMnICAgICB9LFxuICAgICAgICB7IHRvOiAnaDQnLCAgICAgICAgcHJhZWZpeDogJyNoMycgICAgIH0sXG4gICAgICAgIHsgdG86ICdoNScsICAgICAgICBwcmFlZml4OiAnIyMjIycgICAgfSxcbiAgICAgICAgeyB0bzogJ2g1JywgICAgICAgIHByYWVmaXg6ICcjaDQnICAgICB9LFxuICAgICAgICB7IHRvOiAncCcsICAgICAgICAgcHJhZWZpeDogJyNwJyAgICAgIH0sXG4gICAgICAgIHsgdG86ICd1bCcsICAgICAgICBwcmFlZml4OiAnI3VsJyAgICAgfSxcbiAgICAgICAgeyB0bzogJ3VsJywgICAgICAgIHByYWVmaXg6ICdcXFxcKicgICAgIH0sXG4gICAgICAgIHsgdG86ICdvbCcsICAgICAgICBwcmFlZml4OiAnI29sJyAgICAgfSxcbiAgICAgICAgeyB0bzogJ29sJywgICAgICAgIHByYWVmaXg6ICcxXFxcXCknICAgIH0sXG4gICAgICAgIHsgdG86ICdmaWd1cmUnLCAgICBwcmFlZml4OiAnI2ltZycgICAgfSxcbiAgICAgICAgeyB0bzogJ2ZpZ3VyZScsICAgIHByYWVmaXg6ICcjaW1hZ2UnICB9LFxuICAgICAgICB7IHRvOiAnbmF2JywgICAgICAgcHJhZWZpeDogJyN0b2MnICAgIH0sXG4gICAgICAgIHsgdG86ICdoMihBYnN0cmFjdCknLCAgIHByYWVmaXg6ICcjYWJzdHJhY3QnICB9LFxuICAgICAgICB7IHRvOiAnaDIoQWJzdHJhY3QpJywgICBwcmFlZml4OiAnI0Fic3RyYWN0JyAgfSxcbiAgICAgICAgeyB0bzogJ2JpYmxpb2dyYXBoaWUnLCAgcHJhZWZpeDogJyNiaWInICAgICAgIH0sXG4gICAgICAgIHsgdG86ICdmb290bm90ZXMnLCAgICAgIHByYWVmaXg6ICcjZm9vdG5vdGVzJyB9LFxuICAgICAgICB7IHRvOiAnZm9ybXVsYScsICAgICAgICBwcmFlZml4OiAnI2Zvcm11bGEnICAgfSxcbiAgICAgICAgeyB0bzogJ2Zvcm11bGEnLCAgICAgICAgcHJhZWZpeDogJyNlcScgICAgICAgIH0sXG4gICAgICAgIHsgdG86ICdtZXJtYWlkJywgICAgICAgIHByYWVmaXg6ICcjZGlhJyAgICAgICB9LFxuICAgICAgICB7IHRvOiAnYnF1b3RlJywgICAgICAgICBwcmFlZml4OiAnI3F1b3RlJyAgICAgfSxcbiAgICAgICAgeyB0bzogJ2JxdW90ZScsICAgICAgICAgcHJhZWZpeDogJyNcIicgICAgICAgICB9LFxuICAgICAgICB7IHRvOiAnYnF1b3RlJywgICAgICAgICBwcmFlZml4OiBcIiMnXCIgICAgICAgICB9LFxuICAgICAgICB7IHRvOiAnYnF1b3RlJywgICAgICAgICBwcmFlZml4OiAnI2Jsb2NrcXVvdGUnfSxcbiAgICBdO1xuXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLnRhZ1RyYW5zZm9ybWF0aW9ucywge1xuICAgICAgICAnL3AnOiB0aGlzLm1hcmt1cFRyYW5zZm9ybWF0aW9ucyxcbiAgICAgICAgJy9oMSc6IHRoaXMubWFya3VwVHJhbnNmb3JtYXRpb25zLFxuICAgICAgICAnL2gyJzogdGhpcy5tYXJrdXBUcmFuc2Zvcm1hdGlvbnMsXG4gICAgICAgICcvaDMnOiB0aGlzLm1hcmt1cFRyYW5zZm9ybWF0aW9ucyxcbiAgICAgICAgJy9oNCc6IHRoaXMubWFya3VwVHJhbnNmb3JtYXRpb25zLFxuICAgICAgICAnL2g1JzogdGhpcy5tYXJrdXBUcmFuc2Zvcm1hdGlvbnMsXG4gICAgICAgICcvZGl2JzogJ3AnLFxuICAgICAgICAnL2InOiAncCcsXG4gICAgICAgICcvaSc6ICdwJyxcbiAgICAgICAgJy9pbmxpbmVjb2RlJzogJ3AnLFxuICAgICAgICAnL3AvYnInOiAnPScsXG4gICAgICAgICcvaDEvYnInOiAnPXAnLFxuICAgICAgICAnL2gyL2JyJzogJz1wJyxcbiAgICAgICAgJy9oMy9icic6ICc9cCcsXG4gICAgICAgICcvaDQvYnInOiAnPXAnLFxuICAgICAgICAnL2g1L2JyJzogJz1wJyxcblxuICAgICAgICAnL3AvYi9icic6ICc9JyxcbiAgICAgICAgJy9wL2IvaS9icic6ICc9JyxcbiAgICAgICAgJy9wL2IvdS9icic6ICc9JyxcbiAgICAgICAgJy9wL2IvYS9icic6ICc9JyxcblxuICAgICAgICAnL3AvdS9icic6ICc9JyxcbiAgICAgICAgJy9wL3UvaS9icic6ICc9JyxcbiAgICAgICAgJy9wL3UvYi9icic6ICc9JyxcbiAgICAgICAgJy9wL3UvYS9icic6ICc9JyxcblxuICAgICAgICAnL3AvaS9icic6ICc9JyxcbiAgICAgICAgJy9wL2kvdS9icic6ICc9JyxcbiAgICAgICAgJy9wL2kvYi9icic6ICc9JyxcbiAgICAgICAgJy9wL2kvYS9icic6ICc9JyxcblxuICAgICAgICAnL3AvY29kZSc6ICdpbmxpbmVjb2RlJyxcbiAgICAgICAgJy9wL2lubGluZWNvZGUvYnInOiAnPScsXG4gICAgICAgICcvcC9pbmxpbmVjb2RlL2lubGluZWNvZGUnOiAnI2NvbnRlbnQnLFxuICAgICAgICAnL3AvaW5saW5lY29kZS9iJzogJyNjb250ZW50JyxcbiAgICAgICAgJy9wL2lubGluZWNvZGUvdSc6ICcjY29udGVudCcsXG4gICAgICAgICcvcC9pbmxpbmVjb2RlL2knOiAnI2NvbnRlbnQnLFxuICAgICAgICAnL3AvaW5saW5lY29kZS9hJzogJyNjb250ZW50JyxcbiAgICAgICAgJy9wL2kvY29kZSc6ICctJyxcbiAgICAgICAgJy9wL2IvY29kZSc6ICctJyxcbiAgICAgICAgJy9wL3UvY29kZSc6ICctJyxcbiAgICAgICAgJy9wL2EvY29kZSc6ICdpbmxpbmVjb2RlJyxcbiAgICAgICAgJy9wL2kvaW5saW5lY29kZSc6ICctJyxcbiAgICAgICAgJy9wL2IvaW5saW5lY29kZSc6ICctJyxcbiAgICAgICAgJy9wL3UvaW5saW5lY29kZSc6ICctJyxcblxuICAgICAgICAnL3AvYS9icic6ICc9JyxcbiAgICAgICAgJy9wL2EvaS9icic6ICc9JyxcbiAgICAgICAgJy9wL2EvdS9icic6ICc9JyxcbiAgICAgICAgJy9wL2EvYi9icic6ICc9JyxcblxuICAgICAgICAnL3AvZGl2JzogJy0nLFxuICAgICAgICAnL2gxL2Rpdic6ICctJyxcbiAgICAgICAgJy9oMi9kaXYnOiAnLScsXG4gICAgICAgICcvaDMvZGl2JzogJy0nLFxuICAgICAgICAnL2g0L2Rpdic6ICctJyxcbiAgICAgICAgJy9oNS9kaXYnOiAnLScsXG4gICAgICAgICcvcC9wJzogJyNjb250ZW50JyxcbiAgICAgICAgJy9wL2ZvbnQnOiAnI2NvbnRlbnQnLFxuICAgICAgICAnL3AvdmFyJzogJyNjb250ZW50JyxcbiAgICAgICAgJy9wL2Evc3Bhbic6ICcjY29udGVudCcsXG4gICAgICAgICcvZmlndXJlL2Rpdic6ICcjY29udGVudCcsXG4gICAgfSk7XG5cbiAgICAgdGhpcy50YWdUcmFuc2Zvcm1hdGlvbnMuYWxsb3dPbmx5VGV4dEluKCcvdGFibGUvY2FwdGlvbicpO1xuICAgICB0aGlzLnRhZ1RyYW5zZm9ybWF0aW9ucy5hbGxvd09ubHlUZXh0SW4oJy9maWd1cmUvZmlnY2FwdGlvbicpO1xuICAgICB0aGlzLnRhZ1RyYW5zZm9ybWF0aW9ucy5hbGxvd09ubHlUZXh0SW4oJy90YWJsZS90Ym9keS90ci90ZCcsIHsgYWxsb3dFcXVhdGlvbnM6IHRydWUsIGFsbG93UmVmczogdHJ1ZSwgYWxsb3dMaW5rczogdHJ1ZSwgYWxsb3dCb2xkSXRhbGljVW5kZXJsaW5lOiB0cnVlIH0pO1xuICAgICB0aGlzLnRhZ1RyYW5zZm9ybWF0aW9ucy5hbGxvd09ubHlUZXh0SW4oJy91bC9saScsIHsgYWxsb3dFcXVhdGlvbnM6IHRydWUsIGFsbG93UmVmczogdHJ1ZSwgYWxsb3dMaW5rczogdHJ1ZSwgYWxsb3dCb2xkSXRhbGljVW5kZXJsaW5lOiB0cnVlIH0pO1xuICAgICB0aGlzLnRhZ1RyYW5zZm9ybWF0aW9ucy5hbGxvd09ubHlUZXh0SW4oJy9vbC9saScsIHsgYWxsb3dFcXVhdGlvbnM6IHRydWUsIGFsbG93UmVmczogdHJ1ZSwgYWxsb3dMaW5rczogdHJ1ZSwgYWxsb3dCb2xkSXRhbGljVW5kZXJsaW5lOiB0cnVlIH0pO1xuXG4gICAgIHRoaXMudGFnVHJhbnNmb3JtYXRpb25zLmFsbG93T25seVRleHRJbignL29sL29sL2xpJywgeyBhbGxvd0VxdWF0aW9uczogdHJ1ZSwgYWxsb3dSZWZzOiB0cnVlLCBhbGxvd0xpbmtzOiB0cnVlLCBhbGxvd0JvbGRJdGFsaWNVbmRlcmxpbmU6IHRydWUgfSk7XG4gICAgIHRoaXMudGFnVHJhbnNmb3JtYXRpb25zLmFsbG93T25seVRleHRJbignL29sL29sL29sL2xpJywgeyBhbGxvd0VxdWF0aW9uczogdHJ1ZSwgYWxsb3dSZWZzOiB0cnVlLCBhbGxvd0xpbmtzOiB0cnVlLCBhbGxvd0JvbGRJdGFsaWNVbmRlcmxpbmU6IHRydWUgfSk7XG5cbiAgICAgdGhpcy50YWdUcmFuc2Zvcm1hdGlvbnMuYWxsb3dPbmx5VGV4dEluKCcvdWwvdWwvbGknLCB7IGFsbG93RXF1YXRpb25zOiB0cnVlLCBhbGxvd1JlZnM6IHRydWUsIGFsbG93TGlua3M6IHRydWUsIGFsbG93Qm9sZEl0YWxpY1VuZGVybGluZTogdHJ1ZSB9KTtcbiAgICAgdGhpcy50YWdUcmFuc2Zvcm1hdGlvbnMuYWxsb3dPbmx5VGV4dEluKCcvdWwvdWwvdWwvbGknLCB7IGFsbG93RXF1YXRpb25zOiB0cnVlLCBhbGxvd1JlZnM6IHRydWUsIGFsbG93TGlua3M6IHRydWUsIGFsbG93Qm9sZEl0YWxpY1VuZGVybGluZTogdHJ1ZSB9KTtcblxuICAgICB0aGlzLnRhZ1RyYW5zZm9ybWF0aW9ucy5hbGxvd09ubHlUZXh0SW4oJy9oMScsIHsgYWxsb3dFcXVhdGlvbnM6IHRydWUgfSk7XG4gICAgIHRoaXMudGFnVHJhbnNmb3JtYXRpb25zLmFsbG93T25seVRleHRJbignL2gyJywgeyBhbGxvd0VxdWF0aW9uczogdHJ1ZSB9KTtcbiAgICAgdGhpcy50YWdUcmFuc2Zvcm1hdGlvbnMuYWxsb3dPbmx5VGV4dEluKCcvaDMnLCB7IGFsbG93RXF1YXRpb25zOiB0cnVlIH0pO1xuICAgICB0aGlzLnRhZ1RyYW5zZm9ybWF0aW9ucy5hbGxvd09ubHlUZXh0SW4oJy9oNCcsIHsgYWxsb3dFcXVhdGlvbnM6IHRydWUgfSk7XG4gICAgIHRoaXMudGFnVHJhbnNmb3JtYXRpb25zLmFsbG93T25seVRleHRJbignL2g1JywgeyBhbGxvd0VxdWF0aW9uczogdHJ1ZSB9KTtcblxuICAgICB0aGlzLnRhZ1RyYW5zZm9ybWF0aW9ucy5hbGxvd1JlZnNJbignL3AnKTtcbiAgICAgdGhpcy50YWdUcmFuc2Zvcm1hdGlvbnMuYWxsb3dSZWZzSW4oJy9wL2InKTtcbiAgICAgdGhpcy50YWdUcmFuc2Zvcm1hdGlvbnMuYWxsb3dSZWZzSW4oJy9wL2knKTtcbiAgICAgdGhpcy50YWdUcmFuc2Zvcm1hdGlvbnMuYWxsb3dSZWZzSW4oJy9wL3UnKTtcbiAgICAgdGhpcy50YWdUcmFuc2Zvcm1hdGlvbnMuYWxsb3dSZWZzSW4oJy9wcmUvY2FwdGlvbicpO1xuICAgICB0aGlzLnRhZ1RyYW5zZm9ybWF0aW9ucy5hbGxvd1JlZnNJbignL3RhYmxlL2NhcHRpb24nKTtcbiAgICAgdGhpcy50YWdUcmFuc2Zvcm1hdGlvbnMuYWxsb3dSZWZzSW4oJy9mb3JtdWxhL2NhcHRpb24nKTtcbiAgICAgdGhpcy50YWdUcmFuc2Zvcm1hdGlvbnMuYWxsb3dSZWZzSW4oJy9tZXJtYWlkL2NhcHRpb24nKTtcbiAgICAgdGhpcy50YWdUcmFuc2Zvcm1hdGlvbnMuYWxsb3dSZWZzSW4oJy9maWd1cmUvZmlnY2FwdGlvbicpO1xuICAgICAvLyB0aGlzLnRhZ1RyYW5zZm9ybWF0aW9ucy5hbGxvd1JlZnNJbignL2JxdW90ZS9jaXRlc3JjJyk7IC8vIHRoaXMgaXMgc3BlY2lmaWVkIGluIHRoZSBzZWN0aW9uIHR5cGUgY29kZSBmaWxlIGl0c2VsZlxuXG4gICAgIHRoaXMudGFnVHJhbnNmb3JtYXRpb25zLmFsbG93SW5saW5lZXF1YXRpb25zSW4oJy9wJyk7XG4gICAgIHRoaXMudGFnVHJhbnNmb3JtYXRpb25zLmFsbG93SW5saW5lZXF1YXRpb25zSW4oJy9wcmUvY2FwdGlvbicpO1xuICAgICB0aGlzLnRhZ1RyYW5zZm9ybWF0aW9ucy5hbGxvd0lubGluZWVxdWF0aW9uc0luKCcvdGFibGUvY2FwdGlvbicpO1xuICAgICB0aGlzLnRhZ1RyYW5zZm9ybWF0aW9ucy5hbGxvd0lubGluZWVxdWF0aW9uc0luKCcvZm9ybXVsYS9jYXB0aW9uJyk7XG4gICAgIHRoaXMudGFnVHJhbnNmb3JtYXRpb25zLmFsbG93SW5saW5lZXF1YXRpb25zSW4oJy9tZXJtYWlkL2NhcHRpb24nKTtcbiAgICAgdGhpcy50YWdUcmFuc2Zvcm1hdGlvbnMuYWxsb3dJbmxpbmVlcXVhdGlvbnNJbignL2ZpZ3VyZS9maWdjYXB0aW9uJyk7XG4gICAgIHRoaXMudGFnVHJhbnNmb3JtYXRpb25zLmFsbG93SW5saW5lZXF1YXRpb25zSW4oJy9icXVvdGUvY2l0ZXNyYycpO1xuXG4gICAgdGhpcy5jb250ZW50UnVsZXMgPSB7XG4gICAgICAgICdpJzoge1xuICAgICAgICAgICAgdGFnTmFtZTogJ2knLFxuICAgICAgICAgICAgYWxsb3dlZENoaWxkcmVuOiBbJyN0ZXh0JywgJ2xpbmsnLCAnYicsICd1JywgJ2Zvb3Rub3RlJywgJ3JlZmVyZW5jZSddLFxuICAgICAgICAgICAgcHJ1bmVTcGFjZXM6IHRydWUsXG4gICAgICAgICAgICBkZWxldGVJZkVtcHR5OiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgICdiJzoge1xuICAgICAgICAgICAgdGFnTmFtZTogJ2InLFxuICAgICAgICAgICAgYWxsb3dlZENoaWxkcmVuOiBbJyN0ZXh0JywgJ2xpbmsnLCAnaScsICd1JywgJ2Zvb3Rub3RlJywgJ3JlZmVyZW5jZSddLFxuICAgICAgICAgICAgcHJ1bmVTcGFjZXM6IHRydWUsXG4gICAgICAgICAgICBkZWxldGVJZkVtcHR5OiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgICd1Jzoge1xuICAgICAgICAgICAgdGFnTmFtZTogJ3UnLFxuICAgICAgICAgICAgYWxsb3dlZENoaWxkcmVuOiBbJyN0ZXh0JywgJ2xpbmsnLCAnYicsICdpJywgJ2Zvb3Rub3RlJywgJ3JlZmVyZW5jZSddLFxuICAgICAgICAgICAgcHJ1bmVTcGFjZXM6IHRydWUsXG4gICAgICAgICAgICBkZWxldGVJZkVtcHR5OiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgICdpbmxpbmVjb2RlJzoge1xuICAgICAgICAgICAgdGFnTmFtZTogJ2lubGluZWNvZGUnLFxuICAgICAgICAgICAgYWxsb3dlZENoaWxkcmVuOiBbJyN0ZXh0J10sXG4gICAgICAgICAgICBwcnVuZVNwYWNlczogdHJ1ZSxcbiAgICAgICAgICAgIGRlbGV0ZUlmRW1wdHk6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgICdsaW5rJzoge1xuICAgICAgICAgICAgdGFnTmFtZTogJ2EnLFxuICAgICAgICAgICAgYWxsb3dlZENoaWxkcmVuOiBbJyN0ZXh0JywgJ2InLCAnaScsICd1JywgJ2lubGluZWNvZGUnXSxcbiAgICAgICAgICAgIGFsbG93ZWRBdHRyaWJ1dGVzOiBbJ2hyZWYnXSxcbiAgICAgICAgICAgIHBydW5lU3BhY2VzOiB0cnVlLFxuICAgICAgICAgICAgZGVsZXRlSWZFbXB0eTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICAnZm9vdG5vdGUnOiB7XG4gICAgICAgICAgICB0YWdOYW1lOiAnc3BhbicsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdmb290bm90ZScsXG4gICAgICAgICAgICBhbGxvd2VkQXR0cmlidXRlczogWydjbGFzcycsICdjb250ZW50ZWRpdGFibGUnLCAnZGF0YS1ub3RlJ10sXG4gICAgICAgICAgICBhbGxvd2VkQ2xhc3NOYW1lczogWydmb290bm90ZSddLFxuICAgICAgICAgICAgYWxsb3dlZENoaWxkcmVuOiBbXSxcbiAgICAgICAgICAgIGJ1aWxkQXR0cmlidXRlczogW3tuYW1lOiAnY29udGVudGVkaXRhYmxlJywgYnVpbGQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2UgfX1dXG4gICAgICAgIH0sXG4gICAgICAgICdpbmxpbmVlcXVhdGlvbic6IHtcbiAgICAgICAgICAgIHRhZ05hbWU6ICdpbmxpbmVlcXVhdGlvbicsXG4gICAgICAgICAgICBhbGxvd2VkQXR0cmlidXRlczogWydjb250ZW50ZWRpdGFibGUnLCAnZGF0YS1sYXRleGVxdWF0aW9uJywgJ2lkJ10sXG4gICAgICAgICAgICBhbGxvd2VkQ2hpbGRyZW46IFtdLFxuICAgICAgICAgICAgYnVpbGRBdHRyaWJ1dGVzOiBbXG4gICAgICAgICAgICAgICAge25hbWU6ICdjb250ZW50ZWRpdGFibGUnLCBidWlsZDogZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZSB9fSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ2lkJywgYnVpbGQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdXVpZCgpIH19XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgICdyZWZlcmVuY2UnOiB7XG4gICAgICAgICAgICB0YWdOYW1lOiAnc3BhbicsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdyZWZlcmVuY2UnLFxuICAgICAgICAgICAgYWxsb3dlZEF0dHJpYnV0ZXM6IFsnY2xhc3MnLCAnY29udGVudGVkaXRhYmxlJywgJ2RhdGEtcmVmJywgJ2RhdGEtZXh0ZXJuYWwnXSxcbiAgICAgICAgICAgIGFsbG93ZWRDbGFzc05hbWVzOiBbJ3JlZmVyZW5jZSddLFxuICAgICAgICAgICAgYWxsb3dlZENoaWxkcmVuOiBbXSxcbiAgICAgICAgICAgIGJ1aWxkQXR0cmlidXRlczogW3tuYW1lOiAnY29udGVudGVkaXRhYmxlJywgYnVpbGQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2UgfX1dXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gQWNjb3JkaW5nIHRvIHRoaXMgY29uZmlnOlxuICAgIC8vICAgd2hlbiB0aGUgZWRpdG9yIHVwZGF0ZWQgYSBzZWN0aW9uIHdoaWNoXG4gICAgLy8gICAgIC0gY29udGFpbnMgYSBcImgyXCIgZWxlbWVudCBvclxuICAgIC8vICAgICAtIGNvbnRhaW5lZCBhIFwiaDJcIiBlbGVtZW50IG9yXG4gICAgLy8gICAgIC0gaXMgYSBcImgyXCIgZWxlbWVudCBvclxuICAgIC8vICAgICAtIHdhcyBhIFwiaDJcIiBlbGVtZW50XG4gICAgLy8gdGhlIG1vZGlmaWNhdGlvbkxvZ0VudHJ5IHdpbGwgaGF2ZSBhIGZpZWxkIFwibWlnaHRJbmNsdWRlSGVhZGluZ1VwZGF0ZXNcIiBzZXQgdG8gdHJ1ZVxuICAgIHRoaXMubW9kTG9nRmxhZ3MgPSB7XG4gICAgICAgIEhlYWRpbmc6IFsnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnXSxcbiAgICAgICAgVGFibGVPZkNvbnRlbnQ6IFsnbmF2J10sXG4gICAgICAgIEJpYmxpb2dyYXBoaWU6IFsnYmlibGlvZ3JhcGhpZSddLFxuICAgICAgICBSZWZlcmVuY2U6IFsnLnJlZmVyZW5jZVtkYXRhLWV4dGVybmFsPVwidHJ1ZVwiXSddLFxuICAgICAgICBGb290bm90ZTogWycuZm9vdG5vdGUnXSxcbiAgICAgICAgSW5saW5lcXVhdGlvbjogWycuaW5saW5lZXF1YXRpb24nXSxcbiAgICAgICAgRm9vdG5vdGVzU2VjdGlvbjogWydmb290bm90ZXMnXSxcbiAgICB9O1xuXG4gICAgdGhpcy5hZGRTZWN0aW9uVHlwZShwYXJhZ3JhcGhTZWN0aW9uVHlwZSk7XG4gICAgdGhpcy5hZGRTZWN0aW9uVHlwZSh0YWJsZVNlY3Rpb25UeXBlKTtcbiAgICB0aGlzLmFkZFNlY3Rpb25UeXBlKHVub3JkZXJlZExpc3RTZWN0aW9uVHlwZSk7XG4gICAgdGhpcy5hZGRTZWN0aW9uVHlwZShvcmRlcmVkTGlzdFNlY3Rpb25UeXBlKTtcbiAgICB0aGlzLmFkZFNlY3Rpb25UeXBlKGNvZGVTZWN0aW9uVHlwZSk7XG4gICAgdGhpcy5hZGRTZWN0aW9uVHlwZSh0b2NTZWN0aW9uVHlwZSk7XG4gICAgdGhpcy5hZGRTZWN0aW9uVHlwZShiaWJsaW9ncmFwaGllU2VjdGlvblR5cGUuc2V0RWRpdG9yKHRoaXMpKTtcbiAgICB0aGlzLmFkZFNlY3Rpb25UeXBlKGZvb3Rub3Rlc1NlY3Rpb25UeXBlLnNldEVkaXRvcih0aGlzKSk7XG4gICAgdGhpcy5hZGRTZWN0aW9uVHlwZShoZWFkaW5nMVNlY3Rpb25UeXBlKTtcbiAgICB0aGlzLmFkZFNlY3Rpb25UeXBlKGhlYWRpbmcyU2VjdGlvblR5cGUpO1xuICAgIHRoaXMuYWRkU2VjdGlvblR5cGUoaGVhZGluZzNTZWN0aW9uVHlwZSk7XG4gICAgdGhpcy5hZGRTZWN0aW9uVHlwZShoZWFkaW5nNFNlY3Rpb25UeXBlKTtcbiAgICB0aGlzLmFkZFNlY3Rpb25UeXBlKGhlYWRpbmc1U2VjdGlvblR5cGUpO1xuICAgIHRoaXMuYWRkU2VjdGlvblR5cGUoaW1hZ2VTZWN0aW9uVHlwZS5zZXRFZGl0b3IodGhpcykpO1xuICAgIHRoaXMuYWRkU2VjdGlvblR5cGUoZm9ybXVsYVNlY3Rpb25UeXBlKTtcbiAgICB0aGlzLmFkZFNlY3Rpb25UeXBlKG1lcm1haWRTZWN0aW9uVHlwZSk7XG4gICAgdGhpcy5hZGRTZWN0aW9uVHlwZShibG9ja3F1b3RlU2VjdGlvblR5cGUpO1xuXG4gICAgdGhpcy5odG1sUmF6b3IgPSBuZXcgSFRNTFJhem9yKHRoaXMudGFnVHJhbnNmb3JtYXRpb25zLCB0aGlzLmNvbnRlbnRSdWxlcyk7XG4gICAgdGhpcy5kb2N1bWVudHVwZGF0ZXIgPSBuZXcgRG9jdW1lbnR1cGRhdGVyKHRoaXMuY29udGVudEVsZW1lbnQsIHRoaXMuaHRtbFJhem9yKTtcbiAgICB0aGlzLmFjdGl2YXRlSW5wdXRFdmVudFByb2Nlc3NpbmcoKTtcblxuICAgIHRoaXMuc3Vic2NyaWJlKGZ1bmN0aW9uKG1vZExvZ0VudHJ5KSB7XG4gICAgICAgIGlmKG1vZExvZ0VudHJ5LnRhZ3MgIT09ICd1bmRvJykge1xuICAgICAgICAgICAgc2VsZi5oaXN0b3J5LnB1c2gobW9kTG9nRW50cnkpO1xuICAgICAgICAgICAgaWYoc2VsZi5oaXN0b3J5Lmxlbmd0aCA+IDMwKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5oaXN0b3J5LnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZihtb2RMb2dFbnRyeS50YWdzICE9PSAncmVkbycgJiYgbW9kTG9nRW50cnkudGFncyAhPT0gJ3VuZG8nKSB7XG4gICAgICAgICAgICBzZWxmLnVuZG9uZU1vZGlmaWNhdGlvbnMgPSBbXTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VjdGlvbiA9IHNlbGYuZm9jdXNlZFNlY3Rpb24oKTtcblxuICAgICAgICBpZihzZWN0aW9uICYmIHNlY3Rpb24ub25XaW5kb3dSZXNpemUpIHtcbiAgICAgICAgICAgIHNlY3Rpb24ub25XaW5kb3dSZXNpemUoc2VsZik7XG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBpZihzZWxmLmlzQ29udGVudEVkaXRhYmxlKCkgJiYgc2VsZi5fbW91c2VEb3duICYmICFzZWxmLmNhcmV0LmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgICAgIHNlbGYuc2V0Q29udGVudEVkaXRhYmxlKGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWN0aW9uID0gc2VsZi5mb2N1c2VkU2VjdGlvbigpO1xuXG4gICAgICAgIGlmKHNlY3Rpb24gJiYgc2VjdGlvbi5vblNlbGVjdGlvbkNoYW5nZSkge1xuICAgICAgICAgICAgc2VjdGlvbi5vblNlbGVjdGlvbkNoYW5nZShzZWxmKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLl9tb3VzZURvd24gPSB0cnVlO1xuICAgICAgICBzZWxmLnNldENvbnRlbnRFZGl0YWJsZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuX21vdXNlRG93biA9IGZhbHNlO1xuICAgICAgICBpZighc2VsZi5hcmVNdWx0aXBsZVNlY3Rpb25zU2VsZWN0ZWQoKSkge1xuICAgICAgICAgICAgc2VsZi5zZXRDb250ZW50RWRpdGFibGUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuc2VjdGlvblR5cGVTZWxlY3Rvci5kaXNwbGF5TmV4dFRvKHNlbGYuZm9jdXNlZFNlY3Rpb24oKSk7XG4gICAgfSk7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLnNlY3Rpb25UeXBlU2VsZWN0b3IuZGlzcGxheU5leHRUbyhzZWxmLmZvY3VzZWRTZWN0aW9uKCkpO1xuICAgICAgICBzZWxmLnRleHRFbnJpY2htZW50Q29udHJvbC51cGRhdGVQb3NpdGlvbklmVmlzaWJsZSgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5jYXJldC5zdWJzY3JpYmVTZWxlY3Rpb25DaGFuZ2UoZnVuY3Rpb24oc2VsZWN0aW9uKSB7XG4gICAgICAgIHZhciBzZWN0aW9uID0gc2VsZi5zZWN0aW9uQXRDYXJldFBvc3Rpb24oKSxcbiAgICAgICAgICAgIHByZXZpb3VzRm9jdXNlZFNlY3Rpb24gPSBzZWxmLmZvY3VzZWRTZWN0aW9uKCk7XG5cbiAgICAgICAgaWYoc2VjdGlvbiAmJiAhc2VsZi5pc0ZvY3VzZWQoc2VjdGlvbikpIHtcbiAgICAgICAgICAgIHNlbGYuZm9jdXNTZWN0aW9uKHNlY3Rpb24pO1xuXG4gICAgICAgICAgICBpZihwcmV2aW91c0ZvY3VzZWRTZWN0aW9uICYmIHNlbGYuc2hvdWxkU2VjdGlvbkJlUmVtb3ZlZElmVW5mb2N1c2VkKHByZXZpb3VzRm9jdXNlZFNlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyB3aWxsIGRlbGV0ZSB0aGUgcHJldmlvdXMgZm9jdXNlZCBTZWN0aW9uIGluIGNhc2UgaXQgaXMgZW1wdHlcbiAgICAgICAgICAgICAgICBzZWxmLnJlcGxhY2VTZWN0aW9uV2l0aEhUTUwocHJldmlvdXNGb2N1c2VkU2VjdGlvbiwgcHJldmlvdXNGb2N1c2VkU2VjdGlvbi5vdXRlckhUTUwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5zY3JvbGxUb0ZvY3VzZWRTZWN0aW9uSWZOb3RJblZpZXdwb3J0KCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmNvbnRlbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgZnVuY3Rpb24oZSkge1xuICAgICAgICBpZihzZWxmLmlzSW5wdXRFdmVudFByb2Nlc3NpbmdBY3RpdmF0ZWQoKSAmJiBlLnRhcmdldC50YWdOYW1lICE9PSAnSU5QVVQnKSB7XG4gICAgICAgICAgICBzZWxmLnJlcGxhY2VTZWN0aW9uV2l0aEhUTUwoZS50YXJnZXQsIGUudGFyZ2V0Lm91dGVySFRNTCwge2lucHV0RXZlbnQ6IGV9KVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLl9pbml0RG9uZSA9IHRydWU7XG59XG5cbkVkaXRvci5wcm90b3R5cGUgPSB7XG5cbiAgICBkaXNwbGF5TW9kYWw6IGZ1bmN0aW9uKGZpZWxkcywgaGFuZGxlciwgbm90Rm9jdXNGaXJzdElucHV0KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcywgZm9ybTtcblxuICAgICAgICB0aGlzLmZyZWV6ZVNlbGVjdGlvbih7XG4gICAgICAgICAgICAndW5mcmVlemVDYWxsYmFjayc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYudGV4dEVucmljaG1lbnRDb250cm9sLnByZXZlbnRFbnJpY2htZW50Q29udHJvbGxUb0JlSGlkZGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2VsZi50ZXh0RW5yaWNobWVudENvbnRyb2wuaGlkZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvcm0gPSBuZXcgRGVjbGFyYXRpdkZvcm0oe2ZpZWxkczogZmllbGRzfSwgaGFuZGxlciwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNlbGYudW5mcmVlemVTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBzZWxmLnVuZm9jdXNTZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5jYXJldC5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3JtLm9wZW5Jbk1vZGFsKCk7XG5cbiAgICAgICAgICAgIGlmKCFub3RGb2N1c0ZpcnN0SW5wdXQgJiYgZmllbGRzWzBdICYmIGZpZWxkc1swXS5kb21FbGVtZW50ICYmIGZpZWxkc1swXS5kb21FbGVtZW50LnRhZ05hbWUgPT09ICdETC1TRUxFQ1QnKSB7XG4gICAgICAgICAgICAgICAgZm9ybS5mb3JtRWxlbWVudC5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCFub3RGb2N1c0ZpcnN0SW5wdXQgJiYgZmllbGRzWzBdICYmIGZpZWxkc1swXS5kb21FbGVtZW50ICYmIGZpZWxkc1swXS5kb21FbGVtZW50LnRhZ05hbWUgPT09ICdURVhUQVJFQScpIHtcbiAgICAgICAgICAgICAgICBmb3JtLmZvcm1FbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ3RleHRhcmVhJykuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIW5vdEZvY3VzRmlyc3RJbnB1dCAmJiBmaWVsZHNbMF0gJiYgZmllbGRzWzBdLmRvbUVsZW1lbnQgJiYgZmllbGRzWzBdLmRvbUVsZW1lbnQudGFnTmFtZSA9PT0gJ0lOUFVUJykge1xuICAgICAgICAgICAgICAgIGZvcm0uZm9ybUVsZW1lbnQucXVlcnlTZWxlY3RvcignaW5wdXQnKS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIHNlbGYudW5mcmVlemVTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdW5kbzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsb2dFbnRyeSA9IHRoaXMuaGlzdG9yeS5wb3AoKTtcblxuICAgICAgICBpZihsb2dFbnRyeSkge1xuICAgICAgICAgICAgdGhpcy5zZXRDb250ZW50KGxvZ0VudHJ5LmJlZm9yZVN0YXRlKCksIHsgY2FyZXRQb3NpdGlvbjogbG9nRW50cnkuYmVmb3JlU3RhdGVDYXJldFBvc2l0aW9uLCBtb2RpZmljYXRpb25Mb2dUYWdzOiAndW5kbycgfSk7XG4gICAgICAgICAgICB0aGlzLmZvY3VzU2VjdGlvbih0aGlzLnNlY3Rpb25BdENhcmV0UG9zdGlvbigpLCB7IGZvcmNlOiB0cnVlIH0pO1xuICAgICAgICAgICAgdGhpcy51bmRvbmVNb2RpZmljYXRpb25zLnB1c2gobG9nRW50cnkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlZG86IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbG9nRW50cnkgPSB0aGlzLnVuZG9uZU1vZGlmaWNhdGlvbnMucG9wKCk7XG5cbiAgICAgICAgaWYobG9nRW50cnkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q29udGVudChsb2dFbnRyeS5hZnRlclN0YXRlKCksIHsgY2FyZXRQb3NpdGlvbjogbG9nRW50cnkuYWZ0ZXJTdGF0ZUNhcmV0UG9zaXRpb24sIG1vZGlmaWNhdGlvbkxvZ1RhZ3M6ICdyZWRvJyB9KTtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNTZWN0aW9uKHRoaXMuc2VjdGlvbkF0Q2FyZXRQb3N0aW9uKCksIHsgZm9yY2U6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZW1wdHlIaXN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5oaXN0b3J5ID0gW107XG4gICAgICAgIHRoaXMudW5kb25lTW9kaWZpY2F0aW9ucyA9IFtdO1xuICAgIH0sXG5cbiAgICBzZWxlY3RFdmVyeXRoaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxhc3RTZWN0aW9uID0gdGhpcy5jb250ZW50RWxlbWVudC5jaGlsZHJlblt0aGlzLmNvbnRlbnRFbGVtZW50LmNoaWxkcmVuLmxlbmd0aC0xXSxcbiAgICAgICAgICAgIGZpcnN0U2VjdGlvbiA9IHRoaXMuY29udGVudEVsZW1lbnQuY2hpbGRyZW5bMF0sXG4gICAgICAgICAgICBsYXN0Tm9uRW1wdHlTZWN0aW9uSW5kZXggPSBsYXN0U2VjdGlvbi5pbm5lclRleHQgIT09ICcnID8gdGhpcy5jb250ZW50RWxlbWVudC5jaGlsZHJlbi5sZW5ndGgtMSA6IHRoaXMuY29udGVudEVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoLTIsXG4gICAgICAgICAgICBmaXJzdE5vbkVtcHR5U2VjdGlvbkluZGV4ID0gZmlyc3RTZWN0aW9uLmlubmVyVGV4dCAhPT0gJycgPyAwIDogMSxcbiAgICAgICAgICAgIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKSxcbiAgICAgICAgICAgIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSxcbiAgICAgICAgICAgIGFsbFRleHROb2Rlc09mRmlyc3RTZWN0aW9uID0gdGhpcy5hbGxUZXh0Tm9kZXNPZlNlY3Rpb24oZmlyc3ROb25FbXB0eVNlY3Rpb25JbmRleCksXG4gICAgICAgICAgICBhbGxUZXh0Tm9kZXNPZkxhc3RTZWN0aW9uID0gdGhpcy5hbGxUZXh0Tm9kZXNPZlNlY3Rpb24obGFzdE5vbkVtcHR5U2VjdGlvbkluZGV4KSxcbiAgICAgICAgICAgIGxhc3RUZXh0Tm9kZU9mTGFzdFNlY3Rpb24gPSBhbGxUZXh0Tm9kZXNPZkxhc3RTZWN0aW9uW2FsbFRleHROb2Rlc09mTGFzdFNlY3Rpb24ubGVuZ3RoLTFdO1xuXG4gICAgICAgIHJhbmdlLnNldFN0YXJ0KGFsbFRleHROb2Rlc09mRmlyc3RTZWN0aW9uWzBdLCAwKTtcbiAgICAgICAgcmFuZ2Uuc2V0RW5kKGxhc3RUZXh0Tm9kZU9mTGFzdFNlY3Rpb24sIGxhc3RUZXh0Tm9kZU9mTGFzdFNlY3Rpb24ubGVuZ3RoKTtcbiAgICAgICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICBzZWwuYWRkUmFuZ2UocmFuZ2UpO1xuXG4gICAgICAgIGlmKGZpcnN0Tm9uRW1wdHlTZWN0aW9uSW5kZXggIT09IGxhc3ROb25FbXB0eVNlY3Rpb25JbmRleCkge1xuICAgICAgICAgICAgZm9yKGxldCBpPTA7IGk8dGhpcy5jb250ZW50RWxlbWVudC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudEVsZW1lbnQuY2hpbGRyZW5baV0uYmx1cigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRDb250ZW50RWRpdGFibGUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGFsbFRleHROb2Rlc09mU2VjdGlvbjogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzLmdldEFsbFRleHROb2Rlc09mRWxlbWVudCh0aGlzLnNlY3Rpb25BdChpbmRleCkpXG4gICAgfSxcblxuICAgIGlzU3BlbGxjaGVja0VuYWJsZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3NwZWxsY2hlY2snKSA9PT0gJ3RydWUnO1xuICAgIH0sXG5cbiAgICBidWlsZEFkZFNlY3Rpb25CdXR0b246IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgYnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgICAgaWYodHlwZSAhPT0gJ2JvdHRvbScgJiYgdHlwZSAhPT0gJ3RvcCcpIHJldHVybiBmYWxzZVxuXG4gICAgICAgIGJ0bi5jbGFzc05hbWUgPSB0eXBlICsgJ1NlY3Rpb25JbnNlcnRCdXR0b24nXG4gICAgICAgIGJ0bi5pbm5lckhUTUwgPSAnPHNwYW4+QWRkIFNlY3Rpb248L3NwYW4+JztcbiAgICAgICAgYnRuLm9uY2xpY2sgPSBmdW5jdGlvbigpIHsgc2VsZi5hZGRTZWN0aW9uKHR5cGUpOyBidG4ub25tb3VzZW92ZXIoKX1cbiAgICAgICAgYnRuLm9ubW91c2VvdmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VjdGlvbiA9IHNlbGYuY29udGVudEVsZW1lbnRbdHlwZSA9PSAnYm90dG9tJyA/ICdsYXN0Q2hpbGQnIDogJ2ZpcnN0Q2hpbGQnXTtcbiAgICAgICAgICAgIGlmKHNlbGYuc2hvdWxkU2VjdGlvbkJlUmVtb3ZlZElmVW5mb2N1c2VkKHNlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICBidG4uY2xhc3NMaXN0LmFkZCgnZGVhY3RpdmF0ZWRTZWN0aW9uSW5zZXJ0QnV0dG9uJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgYnRuLmNsYXNzTGlzdC5yZW1vdmUoJ2RlYWN0aXZhdGVkU2VjdGlvbkluc2VydEJ1dHRvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYnRuO1xuICAgIH0sXG5cbiAgICBpc0NvbnRlbnRFZGl0YWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0NvbnRlbnRFZGl0YWJsZTtcbiAgICB9LFxuXG4gICAgc2V0Q29udGVudEVkaXRhYmxlOiBmdW5jdGlvbihzaG91bGRCZUVkaXRhYmxlKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIGluZGV4T2ZGb2N1c2VkU2VjdGlvbiA9IHRoaXMuaW5kZXhPZkZvY3VzZWRTZWN0aW9uKCk7XG5cbiAgICAgICAgaWYodGhpcy5faXNDb250ZW50RWRpdGFibGUgPT09IHNob3VsZEJlRWRpdGFibGUpIHJldHVybjtcblxuICAgICAgICB2YXIgdXBkYXRlRG9tID0gZnVuY3Rpb24oZWwsIHNob3VsZEJlRWRpdGFibGUpIHtcbiAgICAgICAgICAgIGlmKGVsLnNldENvbnRlbnRlZGl0YWJsZSkge1xuICAgICAgICAgICAgICAgIGVsLnNldENvbnRlbnRlZGl0YWJsZShzaG91bGRCZUVkaXRhYmxlLCBlbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmKHNob3VsZEJlRWRpdGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2lzQ29udGVudEVkaXRhYmxlID0gc2hvdWxkQmVFZGl0YWJsZTtcbiAgICAgICAgZm9yKGxldCBpPTA7IGk8dGhpcy5jb250ZW50RWxlbWVudC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgICBpZihNYXRoLmFicyhpbmRleE9mRm9jdXNlZFNlY3Rpb24gLSBpKSA8PSAzKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlRG9tKHNlbGYuY29udGVudEVsZW1lbnQuY2hpbGRyZW5baV0sIHNob3VsZEJlRWRpdGFibGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAoZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVEb20oZWwsIHNob3VsZEJlRWRpdGFibGUpO1xuICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICB9KShzZWxmLmNvbnRlbnRFbGVtZW50LmNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHNob3VsZEJlRWRpdGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaEZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVmcmVzaEZvY3VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJhbmdlLCBzZWwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIGlmKHNlbC5yYW5nZUNvdW50ID4gMCAmJiAhdGhpcy5pc1NlbGVjdGlvbkZyZWV6ZWQpIHtcbiAgICAgICAgICAgIHJhbmdlID0gc2VsLmdldFJhbmdlQXQoMCk7XG4gICAgICAgICAgICBpZihyYW5nZSkge1xuICAgICAgICAgICAgICAgIHNlbC5yZW1vdmVSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgc2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZWN0aW9uQXQ6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRFbGVtZW50LmNoaWxkcmVuW2luZGV4XTtcbiAgICB9LFxuXG4gICAgaW5kZXhPZjogZnVuY3Rpb24oc2VjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50RWxlbWVudC5jaGlsZHJlbi5pbmRleE9mKHNlY3Rpb24pO1xuICAgIH0sXG5cbiAgICBpbmRleE9mRm9jdXNlZFNlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleE9mKHRoaXMuZm9jdXNlZFNlY3Rpb24oKSk7XG4gICAgfSxcblxuICAgIHNjcm9sbFRvRm9jdXNlZFNlY3Rpb25JZk5vdEluVmlld3BvcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VjdGlvbjtcbiAgICAgICAgaWYodGhpcy5pc0ZvY3VzZWRTZWN0aW9uSW5WaWV3cG9ydCgpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgc2VjdGlvbiA9IHRoaXMuZm9jdXNlZFNlY3Rpb24oKTtcbiAgICAgICAgICAgIGlmKHNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgc2VjdGlvbi5vZmZzZXRUb3AtKHdpbmRvdy5pbm5lckhlaWdodC8yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaXNGb2N1c2VkU2VjdGlvbkluVmlld3BvcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuZm9jdXNlZFNlY3Rpb24oKTtcbiAgICAgICAgaWYoIXNlY3Rpb24pIHJldHVybjtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5pbm5lckhlaWdodC0yMCA+IHNlY3Rpb24uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkueTtcbiAgICB9LFxuXG4gICAgYWRkU2VjdGlvbjogZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiB8fCAnYm90dG9tJztcblxuICAgICAgICBpZihwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZE5ld1NlY3Rpb25OZXh0VG8odGhpcy5jb250ZW50RWxlbWVudC5sYXN0Q2hpbGQpO1xuICAgICAgICB9IGVsc2UgaWYocG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGROZXdTZWN0aW9uTmV4dFRvKHRoaXMuY29udGVudEVsZW1lbnQuZmlyc3RDaGlsZCwgJ2JlZm9yZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGFkZE5ld1NlY3Rpb25OZXh0VG86IGZ1bmN0aW9uKHNlY3Rpb24sIHBvc2l0aW9uKSB7XG4gICAgICAgIGlmKHRoaXMuc2hvdWxkU2VjdGlvbkJlUmVtb3ZlZElmVW5mb2N1c2VkKHNlY3Rpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZW1wdHlTZWN0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuXG4gICAgICAgIHRoaXMubW9kaWZpY2F0aW9uTG9nRW50cnkgPSBuZXcgTW9kaWZpY2F0aW9uTG9nRW50cnkoKTtcbiAgICAgICAgZW1wdHlTZWN0aW9uLmlubmVySFRNTCA9ICcnO1xuICAgICAgICBlbXB0eVNlY3Rpb24ub3JpZ2luYWxIVE1MID0gZW1wdHlTZWN0aW9uLm91dGVySFRNTDtcbiAgICAgICAgZW1wdHlTZWN0aW9uLnNldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJywgdHJ1ZSk7XG5cbiAgICAgICAgdGhpcy5jb250ZW50RWxlbWVudC5pbnNlcnRCZWZvcmUoZW1wdHlTZWN0aW9uLCAocG9zaXRpb24gPT09ICdiZWZvcmUnID8gc2VjdGlvbiA6IHNlY3Rpb24ubmV4dFNpYmxpbmcpKTtcbiAgICAgICAgdGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeS5yZXRhaW5BbGxTZWN0aW9uc0JlZm9yZShlbXB0eVNlY3Rpb24pO1xuICAgICAgICB0aGlzLm1vZGlmaWNhdGlvbkxvZ0VudHJ5Lmluc2VydFNlY3Rpb24oZW1wdHlTZWN0aW9uKTtcbiAgICAgICAgdGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeS5yZXRhaW5BbGxTZWN0aW9uc0FmdGVyKGVtcHR5U2VjdGlvbik7XG5cbiAgICAgICAgdGhpcy5mb2N1c1NlY3Rpb24oZW1wdHlTZWN0aW9uKTtcbiAgICAgICAgdGhpcy5jYXJldC5wb3NpdGlvbkF0VGhlQmVnaW5uaW5nT2YoZW1wdHlTZWN0aW9uKTtcbiAgICAgICAgdGhpcy5ub3RpZnlTdWJzY3JpYmVycyh0aGlzLm1vZGlmaWNhdGlvbkxvZ0VudHJ5KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIHJlbW92ZVNlY3Rpb246IGZ1bmN0aW9uKHNlY3Rpb24pIHtcbiAgICAgICAgaWYoIXRoaXMuaXNTZWN0aW9uKHNlY3Rpb24pKSByZXR1cm47XG5cbiAgICAgICAgaWYodGhpcy5jb250ZW50RWxlbWVudC5jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZVNlY3Rpb25XaXRoSFRNTChzZWN0aW9uLCAnPHA+PC9wPicpO1xuICAgICAgICAgICAgdGhpcy5jYXJldC5wb3NpdGlvbkF0VGhlQmVnaW5uaW5nT2YodGhpcy5jb250ZW50RWxlbWVudC5jaGlsZHJlblswXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmaWNhdGlvbkxvZ0VudHJ5ID0gbmV3IE1vZGlmaWNhdGlvbkxvZ0VudHJ5KCk7XG4gICAgICAgICAgICB0aGlzLm1vZGlmaWNhdGlvbkxvZ0VudHJ5Lm1vZExvZ0ZsYWdzID0gdGhpcy5tb2RMb2dGbGFncztcbiAgICAgICAgICAgIHRoaXMubW9kaWZpY2F0aW9uTG9nRW50cnkucmV0YWluQWxsU2VjdGlvbnNCZWZvcmUoc2VjdGlvbik7XG4gICAgICAgICAgICB0aGlzLm1vZGlmaWNhdGlvbkxvZ0VudHJ5LmRlbGV0ZVNlY3Rpb24oc2VjdGlvbik7XG4gICAgICAgICAgICB0aGlzLm1vZGlmaWNhdGlvbkxvZ0VudHJ5LnJldGFpbkFsbFNlY3Rpb25zQWZ0ZXIoc2VjdGlvbik7XG5cbiAgICAgICAgICAgIHRoaXMuY2FyZXQuc2F2ZVNlbGVjdGlvbih0aGlzLmNvbnRlbnRFbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuY29udGVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoc2VjdGlvbik7XG4gICAgICAgICAgICB0aGlzLm1vZGlmaWNhdGlvbkxvZ0VudHJ5LndvcmRDb3VudCA9IHRoaXMuZ2V0V29yZENvdW50KCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZvb3Rub3Rlc051bWJlcmluZygpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVSZWZlcmVuY2VOdW1iZXJpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuY2FyZXQucmVzdG9yZVNlbGVjdGlvbigwKTtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5U3Vic2NyaWJlcnModGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgYWRkU2VjdGlvblR5cGU6IGZ1bmN0aW9uKHNlY3Rpb25UeXBlKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy50YWdUcmFuc2Zvcm1hdGlvbnMsIHNlY3Rpb25UeXBlLnRhZ1RyYW5zZm9ybWF0aW9ucyB8fCB7fSk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5jb250ZW50UnVsZXMsIHNlY3Rpb25UeXBlLmNvbnRlbnRSdWxlcyB8fCB7fSk7XG4gICAgICAgIHRoaXMudGV4dEVucmljaG1lbnRDb250cm9sLmFkZEVucmljaG1lbnRzKHNlY3Rpb25UeXBlLmVucmljaG1lbnRzIHx8IFtdKTtcbiAgICAgICAgdGhpcy5zdXBwb3J0ZWRTZWN0aW9uVHlwZXNbc2VjdGlvblR5cGUubmFtZV0gPSBzZWN0aW9uVHlwZTtcblxuICAgICAgICBpZihzZWN0aW9uVHlwZS5vbkVkaXRvckNvbnRlbnRDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZShzZWN0aW9uVHlwZS5vbkVkaXRvckNvbnRlbnRDaGFuZ2VkLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uKGNhbGxiYWNrLCBub3RpZnlPbk1ldGFkYXRhQ2hhbmdlKSB7XG5cbiAgICAgICAgaWYobm90aWZ5T25NZXRhZGF0YUNoYW5nZSkge1xuICAgICAgICAgICAgY2FsbGJhY2subm90aWZ5T25NZXRhZGF0YUNoYW5nZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN1YnNjcmliZXJzLnB1c2goY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICBzdWJzY3JpYmVSZWZlcmVuY2VJbnNlcnRpb246IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlSW5zZXJ0ZWRTdWJzY3JpYmVycy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgc3Vic2NyaWJlU2VjdGlvbkZvY3VzQ2hhbmdlOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICB0aGlzLnNlY3Rpb25Gb2N1c0NoYW5nZVN1YnNjcmliZXJzLnB1c2goY2FsbGJhY2spXG4gICAgfSxcblxuICAgIGlzSW5wdXRFdmVudFByb2Nlc3NpbmdBY3RpdmF0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGVhbnVwQ29udGVudE9uSW5wdXRFdmVudDtcbiAgICB9LFxuXG4gICAgZGVhY3RpdmF0ZUlucHV0RXZlbnRQcm9jZXNzaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yKGxldCBpPTA7IGk8dGhpcy5jb250ZW50RWxlbWVudC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50RWxlbWVudC5jaGlsZHJlbltpXS5IVE1MYmV2b3JlSW5wdXRQcm9jZXNzaW5nRGVhY3RpdmF0aW9uID0gdGhpcy5jb250ZW50RWxlbWVudC5jaGlsZHJlbltpXS5vdXRlckhUTUw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNlY3Rpb25Db3VudEJlZm9yZUlucHV0UHJvY2Vzc2luZyA9IHRoaXMuY29udGVudEVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICB0aGlzLmNsZWFudXBDb250ZW50T25JbnB1dEV2ZW50ID0gZmFsc2U7XG4gICAgfSxcblxuICAgIGFjdGl2YXRlSW5wdXRFdmVudFByb2Nlc3Npbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNsZWFudXBDb250ZW50T25JbnB1dEV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgdmFyIGNoYW5nZXNNYWRlID0gZmFsc2U7XG5cbiAgICAgICAgaWYodGhpcy5zZWN0aW9uQ291bnRCZWZvcmVJbnB1dFByb2Nlc3NpbmcgPT09IHRoaXMuY29udGVudEVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IobGV0IGk9MDsgaTx0aGlzLmNvbnRlbnRFbGVtZW50LmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5jb250ZW50RWxlbWVudC5jaGlsZHJlbltpXS5mb3JjZVVwZGF0ZU9uSW5wdXRQcm9jZXNzc2luZ0VuYWJsZW1lbnQgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZW50RWxlbWVudC5jaGlsZHJlbltpXS5IVE1MYmV2b3JlSW5wdXRQcm9jZXNzaW5nRGVhY3RpdmF0aW9uICE9PSB0aGlzLmNvbnRlbnRFbGVtZW50LmNoaWxkcmVuW2ldLm91dGVySFRNTCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VTZWN0aW9uV2l0aEhUTUwodGhpcy5jb250ZW50RWxlbWVudC5jaGlsZHJlbltpXSwgdGhpcy5jb250ZW50RWxlbWVudC5jaGlsZHJlbltpXS5vdXRlckhUTUwpO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzTWFkZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuY29udGVudEVsZW1lbnQuY2hpbGRyZW5baV0uSFRNTGJldm9yZUlucHV0UHJvY2Vzc2luZ0RlYWN0aXZhdGlvbjtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5jb250ZW50RWxlbWVudC5jaGlsZHJlbltpXS5mb3JjZVVwZGF0ZU9uSW5wdXRQcm9jZXNzc2luZ0VuYWJsZW1lbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGNoYW5nZXNNYWRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVGb290bm90ZXNOdW1iZXJpbmcoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVJlZmVyZW5jZU51bWJlcmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50KHRoaXMuY29udGVudEVsZW1lbnQuaW5uZXJIVE1MKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSB0aGlzLnNlY3Rpb25Db3VudEJlZm9yZUlucHV0UHJvY2Vzc2luZztcbiAgICB9LFxuXG4gICAgZnJlZXplU2VsZWN0aW9uOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJncyB8fCB7fSxcbiAgICAgICAgICAgIGNsaWNrYWJsZUVsZW1lbnQgPSBhcmdzWyd1bmZyZWV6ZU9uQ2xpY2tzT3V0c2l0ZU9mJ10sXG4gICAgICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIGY7XG5cbiAgICAgICAgdGhpcy51bmZyZWV6ZUNhbGxiYWNrID0gYXJnc1sndW5mcmVlemVDYWxsYmFjayddO1xuXG4gICAgICAgIGlmKGNsaWNrYWJsZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIHZhciB0bXAgPSBlLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFtdO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUodG1wLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5wdXNoKHRtcC5wYXJlbnRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgdG1wID0gdG1wLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYocGF0aC5pbmRleE9mKGNsaWNrYWJsZUVsZW1lbnQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnVuZnJlZXplU2VsZWN0aW9uKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIXRoaXMuaXNTZWxlY3Rpb25GcmVlemVkKSB7XG4gICAgICAgICAgICB0aGlzLmRlYWN0aXZhdGVJbnB1dEV2ZW50UHJvY2Vzc2luZygpO1xuICAgICAgICAgICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ2JhY2tDb2xvcicsIGZhbHNlLCAnI2IyZDdmZCcpO1xuICAgICAgICAgICAgdGhpcy5jYXJldC5zYXZlU2VsZWN0aW9uKHRoaXMuY29udGVudEVsZW1lbnQpO1xuICAgICAgICAgICAgd2luZG93LmdldFNlbGVjdGlvbigpLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgdGhpcy5pc1NlbGVjdGlvbkZyZWV6ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHVuZnJlZXplU2VsZWN0aW9uOiBmdW5jdGlvbihyZXN0b3JlU2VsZWN0aW9uKSB7XG4gICAgICAgIGlmKHRoaXMuaXNTZWxlY3Rpb25GcmVlemVkKSB7XG4gICAgICAgICAgICByZXN0b3JlU2VsZWN0aW9uID0gcmVzdG9yZVNlbGVjdGlvbiA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHJlc3RvcmVTZWxlY3Rpb247XG5cbiAgICAgICAgICAgIGlmKHJlc3RvcmVTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmNhcmV0LnNlbGVjdGlvbklzQ29sbGFwc2VkICYmIHRoaXMuY2FyZXQuc2VsZWN0aW9uRm9jdXNOb2RlLnRhZ05hbWUgPT09ICdURCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYXJldC5yZXN0b3JlU2VsZWN0aW9uKGZhbHNlLCAnVHJ5RE9NU3RyYXRlZ3lGaXJzdCcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FyZXQucmVzdG9yZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZUlucHV0RXZlbnRQcm9jZXNzaW5nKCk7XG5cbiAgICAgICAgICAgIGlmKHRoaXMudW5mcmVlemVDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMudW5mcmVlemVDYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIHRoaXMudW5mcmVlemVDYWxsYmFjayA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlzU2VsZWN0aW9uRnJlZXplZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG5vdGlmeVN1YnNjcmliZXJzOiBmdW5jdGlvbihtb2RpZmljYXRpb25Mb2dFbnRyeSkge1xuICAgICAgICB0aGlzLl9jbGVhbnVwTW9kaWZpY2F0aW9uTG9nRnJvbUVkaXRvclNwZWNpZmljTWFya3VwKG1vZGlmaWNhdGlvbkxvZ0VudHJ5KTtcblxuICAgICAgICBjb25zdCBub05vT3AgPSBtb2RpZmljYXRpb25Mb2dFbnRyeS5sb2cuZmluZChsID0+IHtcbiAgICAgICAgICAgIGlmKGwudHlwZSA9PT0gJ3JldGFpbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGwudHlwZSA9PT0gJ3JlcGxhY2UnICYmIGwubmV3U2VjdGlvbkhUTUwgPT09IGwub2xkU2VjdGlvbkhUTUwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KVxuXG4gICAgICAgIGlmKCFub05vT3ApIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlcnMuZmlsdGVyKGNiID0+IGNiLm5vdGlmeU9uTWV0YWRhdGFDaGFuZ2UpLmZvckVhY2goZnVuY3Rpb24oZikge2YobW9kaWZpY2F0aW9uTG9nRW50cnkpfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24oZikge2YobW9kaWZpY2F0aW9uTG9nRW50cnkpfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2VjdGlvbkJ5Q2hpbGROb2RlOiBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICB3aGlsZShjaGlsZCkge1xuICAgICAgICAgICAgaWYodGhpcy5pc1NlY3Rpb24oY2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNlY3Rpb25BdENhcmV0UG9zdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlY3Rpb25CeUNoaWxkTm9kZSh0aGlzLmNhcmV0LnRhcmdldEVsZW1lbnQoKSk7XG4gICAgfSxcblxuICAgIGFyZU11bHRpcGxlU2VjdGlvbnNTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCksIHMxLCBzMjtcblxuICAgICAgICBpZighc2VsIHx8IHNlbC5pc0NvbGxhcHNlZCkgeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgICAgIHMxID0gdGhpcy5zZWN0aW9uQnlDaGlsZE5vZGUoc2VsLmFuY2hvck5vZGUpO1xuICAgICAgICBzMiA9IHRoaXMuc2VjdGlvbkJ5Q2hpbGROb2RlKHNlbC5mb2N1c05vZGUpO1xuXG4gICAgICAgIHJldHVybiBzMSAmJiBzMiAmJiBzMSAhPT0gczI7XG4gICAgfSxcblxuICAgIHBsYWNlQ2FyZXRJbnRvU2VjdGlvbjogZnVuY3Rpb24oc2VjdGlvbiwgcG9zaXRpb24sIGRvTm90Rm9jdXNTZWN0aW9uKSB7XG4gICAgICAgIGlmKCFzZWN0aW9uKSByZXR1cm47XG4gICAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gfHwgJ2VuZCc7XG5cbiAgICAgICAgaWYocG9zaXRpb24gPT09ICdwcmVmZXJyZWRPckJlZ2lubmluZycpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gc2VjdGlvbi5zZWN0aW9uVHlwZSAmJiBzZWN0aW9uLnNlY3Rpb25UeXBlLnByZWZlcnJlZENhcmV0UG9zaXRpb25pbmcgfHwgJ2JlZ2lubmluZyc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGFyZ2V0RWwgPSBzZWN0aW9uLFxuICAgICAgICAgICAgdG1wVGFyZ2V0RWw7XG5cbiAgICAgICAgaWYoc2VjdGlvbi5zZWN0aW9uVHlwZSAmJiBzZWN0aW9uLnNlY3Rpb25UeXBlLmVkaXRhYmxlRWxlbWVudFNlbGVjdG9yKSB7XG4gICAgICAgICAgICB0bXBUYXJnZXRFbCA9IHNlY3Rpb24ucXVlcnlTZWxlY3RvcihzZWN0aW9uLnNlY3Rpb25UeXBlLmVkaXRhYmxlRWxlbWVudFNlbGVjdG9yKTtcbiAgICAgICAgICAgIHRhcmdldEVsID0gdG1wVGFyZ2V0RWwgfHwgc2VjdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCksXG4gICAgICAgICAgICBzZWwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCksXG4gICAgICAgICAgICB0ZXh0Tm9kZXMgPSB1dGlscy5nZXRBbGxUZXh0Tm9kZXNPZkVsZW1lbnQodGFyZ2V0RWwpLFxuICAgICAgICAgICAgdGV4dE5vZGUgPSBwb3NpdGlvbiA9PT0gJ2VuZCcgPyB0ZXh0Tm9kZXNbdGV4dE5vZGVzLmxlbmd0aC0xXSA6IHRleHROb2Rlc1swXTtcblxuICAgICAgICAvLyBUaGUgZm9jdXMvYW5jaG9yIG5vZGUgc2hvdWxkIGJlIHRoZSBkZWVwZXN0IG5vZGUgcG9zc2libGUuXG4gICAgICAgIC8vIE90aGVyd2lzZSB0aGUgdGV4dCBlbnJpY2htZW50IGNvbnRyb2xscyB3aWxsIGJlIHBsYWNlZCBhdCB0aGUgd3JvbmdcbiAgICAgICAgLy8gcG9zaXRpb24uXG5cbiAgICAgICAgaWYocG9zaXRpb24gPT09ICdlbmQnICYmIHRleHROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmNhcmV0LnBvc2l0aW9uQWZ0ZXIodGV4dE5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKHRleHROb2RlIHx8IHRhcmdldEVsKTtcbiAgICAgICAgICAgIHJhbmdlLmNvbGxhcHNlKHBvc2l0aW9uICE9PSAnZW5kJyk7XG4gICAgICAgICAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgICBzZWwuYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIWRvTm90Rm9jdXNTZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzU2VjdGlvbih0YXJnZXRFbCwge2FjdGlvbjogJ3BsYWNlQ2FyZXRJbnRvU2VjdGlvbid9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBpc1NlY3Rpb246IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQgJiZcbiAgICAgICAgICAgICAgIGVsZW1lbnQucGFyZW50RWxlbWVudCA9PT0gdGhpcy5jb250ZW50RWxlbWVudCAmJlxuICAgICAgICAgICAgICAgZWxlbWVudC5ub2RlVHlwZSAhPT0gTm9kZS5URVhUX05PREU7XG4gICAgfSxcblxuICAgIGZvY3VzU2VjdGlvbjogZnVuY3Rpb24oZWxlbWVudCwgYXJncykge1xuICAgICAgICBhcmdzID0gYXJncyB8fCB7fTtcbiAgICAgICAgaWYoIWVsZW1lbnQgfHwgIXRoaXMuaXNTZWN0aW9uKGVsZW1lbnQpKSByZXR1cm47XG4gICAgICAgIGlmKHRoaXMuZm9jdXNlZEVsZW1lbnQgPT09IGVsZW1lbnQgJiYgIWFyZ3MuZm9yY2UpIHJldHVybjtcbiAgICAgICAgdmFyIGlzQWxyZWFkeUhpZ2hsaWdodGVkID0gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2ZvY3VzZWQnKTtcblxuICAgICAgICB0aGlzLnVuZm9jdXNTZWN0aW9uKCk7XG4gICAgICAgIHRoaXMuZm9jdXNlZEVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLmZvY3VzZWRFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2ZvY3VzZWQnKTtcblxuICAgICAgICB0aGlzLnNlY3Rpb25Gb2N1c0NoYW5nZVN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24oY2IpIHtjYigpfSk7XG4gICAgICAgIHRoaXMuc2VjdGlvblR5cGVTZWxlY3Rvci5kaXNwbGF5TmV4dFRvKHRoaXMuZm9jdXNlZEVsZW1lbnQpO1xuXG4gICAgICAgIGlmKCFpc0FscmVhZHlIaWdobGlnaHRlZCkge1xuICAgICAgICAgICAgaWYoZWxlbWVudCAmJiBlbGVtZW50LnNlY3Rpb25UeXBlICYmIGVsZW1lbnQuc2VjdGlvblR5cGUub25Gb2N1cykge1xuICAgICAgICAgICAgICAgIGlmKCF0aGlzLmFyZU11bHRpcGxlU2VjdGlvbnNTZWxlY3RlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc2VjdGlvblR5cGUub25Gb2N1cyhlbGVtZW50LCB0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdW5mb2N1c1NlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBmb2N1c2VkU2VjdGlvbnMgPSB0aGlzLmNvbnRlbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5mb2N1c2VkJyk7XG5cbiAgICAgICAgZm9jdXNlZFNlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24oc2VjKSB7XG4gICAgICAgICAgICBpZihzZWMuY2xhc3NMaXN0LmNvbnRhaW5zKCdmb2N1c2VkJykpIHtcbiAgICAgICAgICAgICAgICBzZWMuY2xhc3NMaXN0LnJlbW92ZSgnZm9jdXNlZCcpO1xuXG4gICAgICAgICAgICAgICAgaWYoc2VjLm9uVW5mb2N1cykge1xuICAgICAgICAgICAgICAgICAgICBzZWMub25VbmZvY3VzKHNlbGYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2VsZi5zZWN0aW9uVHlwZVNlbGVjdG9yLmhpZGUoKTtcbiAgICAgICAgdGhpcy5mb2N1c2VkRWxlbWVudCA9IG51bGw7XG4gICAgfSxcblxuICAgIGZvY3VzZWRTZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9jdXNlZEVsZW1lbnQ7XG4gICAgfSxcblxuICAgIGlzRm9jdXNlZDogZnVuY3Rpb24oc2VjdGlvbikge1xuICAgICAgICByZXR1cm4gc2VjdGlvbiA9PT0gdGhpcy5mb2N1c2VkRWxlbWVudDtcbiAgICB9LFxuXG4gICAgbW92ZUNhcmV0T25lU2VjdGlvblVwOiBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uIHx8ICdlbmQnO1xuICAgICAgICB2YXIgcyA9IHRoaXMuZm9jdXNlZFNlY3Rpb24oKTtcbiAgICAgICAgdGhpcy5wbGFjZUNhcmV0SW50b1NlY3Rpb24ocyAmJiBzLnByZXZpb3VzU2libGluZywgcG9zaXRpb24sIHRydWUpO1xuICAgIH0sXG5cbiAgICBtb3ZlQ2FyZXRPbmVTZWN0aW9uRG93bjogZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiB8fCAnZW5kJztcbiAgICAgICAgdmFyIHMgPSB0aGlzLmZvY3VzZWRTZWN0aW9uKCk7XG4gICAgICAgIHRoaXMucGxhY2VDYXJldEludG9TZWN0aW9uKHMgJiYgcy5uZXh0U2libGluZywgcG9zaXRpb24sIHRydWUpO1xuICAgIH0sXG5cbiAgICBtb3ZlRm9jdXNlZFNlY3Rpb25VcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmb2N1c2VkU2VjdGlvbiA9IHRoaXMuZm9jdXNlZFNlY3Rpb24oKTtcbiAgICAgICAgaWYoZm9jdXNlZFNlY3Rpb24gJiYgZm9jdXNlZFNlY3Rpb24ucHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmNhcmV0LnNhdmVTZWxlY3Rpb24odGhpcy5jb250ZW50RWxlbWVudCk7XG5cbiAgICAgICAgICAgIHRoaXMubW9kaWZpY2F0aW9uTG9nRW50cnkgPSBuZXcgTW9kaWZpY2F0aW9uTG9nRW50cnkoKTtcbiAgICAgICAgICAgIHRoaXMubW9kaWZpY2F0aW9uTG9nRW50cnkubW9kTG9nRmxhZ3MgPSB0aGlzLm1vZExvZ0ZsYWdzO1xuICAgICAgICAgICAgdGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeS5yZXRhaW5BbGxTZWN0aW9uc0JlZm9yZShmb2N1c2VkU2VjdGlvbi5wcmV2aW91c1NpYmxpbmcpO1xuICAgICAgICAgICAgdGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeS5yZXBsYWNlU2VjdGlvbihmb2N1c2VkU2VjdGlvbi5wcmV2aW91c1NpYmxpbmcsIGZvY3VzZWRTZWN0aW9uKTtcbiAgICAgICAgICAgIHRoaXMubW9kaWZpY2F0aW9uTG9nRW50cnkucmVwbGFjZVNlY3Rpb24oZm9jdXNlZFNlY3Rpb24sIGZvY3VzZWRTZWN0aW9uLnByZXZpb3VzU2libGluZyk7XG4gICAgICAgICAgICB0aGlzLm1vZGlmaWNhdGlvbkxvZ0VudHJ5LnJldGFpbkFsbFNlY3Rpb25zQWZ0ZXIoZm9jdXNlZFNlY3Rpb24pO1xuXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRFbGVtZW50Lmluc2VydEJlZm9yZShmb2N1c2VkU2VjdGlvbiwgZm9jdXNlZFNlY3Rpb24ucHJldmlvdXNTaWJsaW5nKTtcbiAgICAgICAgICAgIHRoaXMuY2FyZXQucmVzdG9yZVNlbGVjdGlvbigwLCAnRE9NU3RyYXRlZ3knKTtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5U3Vic2NyaWJlcnModGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeSk7XG4gICAgICAgICAgICB0aGlzLnNlY3Rpb25UeXBlU2VsZWN0b3IuZGlzcGxheU5leHRUbyh0aGlzLmZvY3VzZWRTZWN0aW9uKCkpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGb290bm90ZXNOdW1iZXJpbmcoKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUmVmZXJlbmNlTnVtYmVyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbW92ZUZvY3VzZWRTZWN0aW9uRG93bjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmb2N1c2VkU2VjdGlvbiA9IHRoaXMuZm9jdXNlZFNlY3Rpb24oKTtcbiAgICAgICAgaWYoZm9jdXNlZFNlY3Rpb24gJiYgZm9jdXNlZFNlY3Rpb24ubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuY2FyZXQuc2F2ZVNlbGVjdGlvbih0aGlzLmNvbnRlbnRFbGVtZW50KTtcblxuICAgICAgICAgICAgdGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeSA9IG5ldyBNb2RpZmljYXRpb25Mb2dFbnRyeSgpO1xuICAgICAgICAgICAgdGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeS5tb2RMb2dGbGFncyA9IHRoaXMubW9kTG9nRmxhZ3M7XG4gICAgICAgICAgICB0aGlzLm1vZGlmaWNhdGlvbkxvZ0VudHJ5LnJldGFpbkFsbFNlY3Rpb25zQmVmb3JlKGZvY3VzZWRTZWN0aW9uKTtcbiAgICAgICAgICAgIHRoaXMubW9kaWZpY2F0aW9uTG9nRW50cnkucmVwbGFjZVNlY3Rpb24oZm9jdXNlZFNlY3Rpb24sIGZvY3VzZWRTZWN0aW9uLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIHRoaXMubW9kaWZpY2F0aW9uTG9nRW50cnkucmVwbGFjZVNlY3Rpb24oZm9jdXNlZFNlY3Rpb24ubmV4dFNpYmxpbmcsIGZvY3VzZWRTZWN0aW9uKTtcbiAgICAgICAgICAgIHRoaXMubW9kaWZpY2F0aW9uTG9nRW50cnkucmV0YWluQWxsU2VjdGlvbnNBZnRlcihmb2N1c2VkU2VjdGlvbi5uZXh0U2libGluZyk7XG5cbiAgICAgICAgICAgIGlmKGZvY3VzZWRTZWN0aW9uLm5leHRTaWJsaW5nLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50RWxlbWVudC5pbnNlcnRCZWZvcmUoZm9jdXNlZFNlY3Rpb24sIGZvY3VzZWRTZWN0aW9uLm5leHRTaWJsaW5nLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIH0gZWxzZSAge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoZm9jdXNlZFNlY3Rpb24pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNhcmV0LnJlc3RvcmVTZWxlY3Rpb24oMCwgJ0RPTVN0cmF0ZWd5Jyk7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeVN1YnNjcmliZXJzKHRoaXMubW9kaWZpY2F0aW9uTG9nRW50cnkpO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uVHlwZVNlbGVjdG9yLmRpc3BsYXlOZXh0VG8odGhpcy5mb2N1c2VkU2VjdGlvbigpKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRm9vdG5vdGVzTnVtYmVyaW5nKCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVJlZmVyZW5jZU51bWJlcmluZygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNoYW5nZUZvY3VzZWRTZWN0aW9uVHlwZTogZnVuY3Rpb24oc2VjdGlvblR5cGVOYW1lLCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHZhciBmb2N1c2VkU2VjdGlvbiA9IHRoaXMuZm9jdXNlZFNlY3Rpb24oKSxcbiAgICAgICAgICAgIHN0ID0gdGhpcy5zdXBwb3J0ZWRTZWN0aW9uVHlwZXNbc2VjdGlvblR5cGVOYW1lXSxcbiAgICAgICAgICAgIG5ld0VsLCBzZWN0aW9uQ3JlYXRvciwgc2VjdGlvbkluZGV4LCBjaGFuZ2VkU2VjdGlvbixcbiAgICAgICAgICAgIHNlbGYgPSB0aGlzLCBuZXdDb250ZW50LCBvbGRDb250ZW50LCBydWxlO1xuXG4gICAgICAgIGlmKGFubm90YXRpb24pIHtcbiAgICAgICAgICAgIGFubm90YXRpb24gPSBbYW5ub3RhdGlvbl1cbiAgICAgICAgfVxuXG4gICAgICAgIHNlY3Rpb25DcmVhdG9yID0gKHN0ICYmIHN0LmdldFNlY3Rpb25FbGVtZW50KSB8fCBmdW5jdGlvbihleGlzdGluZ1NlY3Rpb25Db250ZW50KSB7XG4gICAgICAgICAgICBuZXdDb250ZW50ID0gc2VsZi5odG1sUmF6b3IuY2xlYW51cEhUTUwoJzwnICsgc2VjdGlvblR5cGVOYW1lICsgJz4nICsgIGV4aXN0aW5nU2VjdGlvbkNvbnRlbnQgKyAgJzwnICsgc2VjdGlvblR5cGVOYW1lICsgJz4nKTtcbiAgICAgICAgICAgIG5ld0NvbnRlbnQgPSBuZXdDb250ZW50Lm5leHQoKSB8fCAnJztcbiAgICAgICAgICAgIG5ld0NvbnRlbnQgPSBuZXdDb250ZW50LnZhbHVlIHx8ICcnO1xuICAgICAgICAgICAgcmV0dXJuIG5ld0NvbnRlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZihmb2N1c2VkU2VjdGlvbikge1xuICAgICAgICAgICAgcnVsZSA9IHN0ICYmIE9iamVjdC52YWx1ZXMoc3QuY29udGVudFJ1bGVzKS5maW5kKGZ1bmN0aW9uKHIpIHsgcmV0dXJuIHIuYWxsb3dlZFRvQmVSb290IH0pO1xuICAgICAgICAgICAgb2xkQ29udGVudCA9IGZvY3VzZWRTZWN0aW9uLmlubmVySFRNTFxuXG4gICAgICAgICAgICBpZihmb2N1c2VkU2VjdGlvbi50YWdOYW1lID09PSAnUFJFJyAmJiBmb2N1c2VkU2VjdGlvbi5xdWVyeVNlbGVjdG9yKCdjb2RlJykpIHtcbiAgICAgICAgICAgICAgICBvbGRDb250ZW50ID0gZm9jdXNlZFNlY3Rpb24ucXVlcnlTZWxlY3RvcignY29kZScpLmlubmVyVGV4dFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBuZXdFbCA9IHNlY3Rpb25DcmVhdG9yKG9sZENvbnRlbnQsIGFubm90YXRpb24sIHJ1bGUpIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoc2VjdGlvblR5cGVOYW1lKTtcbiAgICAgICAgICAgIHNlY3Rpb25JbmRleCA9IHRoaXMuaW5kZXhPZihmb2N1c2VkU2VjdGlvbik7XG4gICAgICAgICAgICB0aGlzLnJlcGxhY2VTZWN0aW9uV2l0aEhUTUwoZm9jdXNlZFNlY3Rpb24sIG5ld0VsLm91dGVySFRNTCwge2FjdGlvbjogJ2NoYW5nZUZvY3VzZWRTZWN0aW9uVHlwZSd9KTtcbiAgICAgICAgICAgIHV0aWxzLmNvcHlFdmVudExpc3RlbmVyc1JlY3Vyc2l2ZWx5KG5ld0VsLCB0aGlzLmNvbnRlbnRFbGVtZW50LmNoaWxkcmVuW3NlY3Rpb25JbmRleF0pO1xuICAgICAgICAgICAgdGhpcy5mb2N1c1NlY3Rpb24obmV3RWwsIHthY3Rpb246ICdjaGFuZ2VGb2N1c2VkU2VjdGlvblR5cGUnfSk7XG4gICAgICAgICAgICBjaGFuZ2VkU2VjdGlvbiA9IHRoaXMuY29udGVudEVsZW1lbnQuY2hpbGRyZW5bc2VjdGlvbkluZGV4XTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXJnZVBhcmFncmFwaEludG9MaXN0SWZTZWN0aW9uVHlwZU1hdGNoOiBmdW5jdGlvbihzMSwgczIpIHtcbiAgICAgICAgdmFyIGxpSXRlbSwgbmV3RWxlbWVudDtcblxuICAgICAgICBpZihzMS50YWdOYW1lICE9PSAnVUwnICYmIHMxLnRhZ05hbWUgIT09ICdPTCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHMyLnRhZ05hbWUgIT09ICdQJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3RWxlbWVudCA9IHMxLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICAgIG5ld0VsZW1lbnQuaW5uZXJIVE1MID0gczEuaW5uZXJIVE1MICsgJzxsaT4nICsgIHMyLmlubmVySFRNTCArICc8L2xpPidcbiAgICAgICAgcmV0dXJuIG5ld0VsZW1lbnQ7XG4gICAgfSxcblxuICAgIG1lcmdlU2ltcGxlVGV4dFNlY3Rpb25zSWZTZWN0aW9uVHlwZU1hdGNoOiBmdW5jdGlvbihzMSwgczIpIHtcbiAgICAgICAgaWYoIXMxIHx8ICFzMikgeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgICAgIHZhciBzMklzRW1wdHkgPSBzMi5pbm5lckhUTUwudHJpbSgpID09PSAnJyxcbiAgICAgICAgICAgIG1lcmdlYWJsZSA9IFsnUCcsICdIMScsICdIMicsICdIMycsICdINCcsICdINSddLFxuICAgICAgICAgICAgbmV3RWxlbWVudDtcblxuICAgICAgICBpZihzMklzRW1wdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBzMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKG1lcmdlYWJsZS5pbmNsdWRlc0FsbChzMS50YWdOYW1lLCBzMi50YWdOYW1lKSkge1xuICAgICAgICAgICAgbmV3RWxlbWVudCA9IHMxLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICAgICAgICBuZXdFbGVtZW50LmlubmVySFRNTCA9IHMxLmlubmVySFRNTCArIHMyLmlubmVySFRNTDtcbiAgICAgICAgICAgIHJldHVybiBuZXdFbGVtZW50O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1lcmdlU2VjdGlvbnM6IGZ1bmN0aW9uKHMxLCBzMikge1xuICAgICAgICB2YXIgc2VjdGlvbkluZGV4ID0gdGhpcy5pbmRleE9mKHMxKSxcbiAgICAgICAgICAgIHMySXNFbXB0eSA9IHMyLmlubmVyVGV4dC50cmltKCkgPT09ICcnLFxuICAgICAgICAgICAgbmV3RWxlbWVudDtcblxuICAgICAgICBuZXdFbGVtZW50ID0gdGhpcy5tZXJnZVBhcmFncmFwaEludG9MaXN0SWZTZWN0aW9uVHlwZU1hdGNoKHMxLCBzMik7XG5cbiAgICAgICAgaWYoIW5ld0VsZW1lbnQpIHtcbiAgICAgICAgICAgIG5ld0VsZW1lbnQgPSB0aGlzLm1lcmdlU2ltcGxlVGV4dFNlY3Rpb25zSWZTZWN0aW9uVHlwZU1hdGNoKHMxLCBzMik7XG4gICAgICAgIH1cblxuICAgICAgICBpZihuZXdFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnNldENvbnRlbnQobmV3RWxlbWVudC5vdXRlckhUTUwsIHsgc3RhcnRTZWN0aW9uOiBzMSwgZW5kU2VjdGlvbjogczIgfSk7XG5cbiAgICAgICAgICAgIGlmKHMySXNFbXB0eSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGxhY2VDYXJldEludG9TZWN0aW9uKHRoaXMuY29udGVudEVsZW1lbnQuY2hpbGRyZW5bc2VjdGlvbkluZGV4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVwbGFjZVNlY3Rpb25XaXRoSFRNTDogZnVuY3Rpb24ob2xkU2VjdGlvbiwgb3V0ZXJIVE1MLCBhcmdzKSB7XG4gICAgICAgIGFyZ3MgPSBhcmdzIHx8IHt9O1xuICAgICAgICBhcmdzLnNlY3Rpb24gPSBvbGRTZWN0aW9uO1xuICAgICAgICB0aGlzLnNldENvbnRlbnQob3V0ZXJIVE1MLCBhcmdzKTtcbiAgICB9LFxuXG4gICAgY29udGVudDogZnVuY3Rpb24oY29udGVudCwgYXJncykge1xuICAgICAgICBpZih0eXBlb2YgY29udGVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbnRlbnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldENvbnRlbnQoY29udGVudCwgYXJncyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0Q29udGVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJlbmRlcmVkQ29udGVudCgpO1xuICAgIH0sXG5cbiAgICBnZXRSZW5kZXJlZENvbnRlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJycsXG4gICAgICAgIHNlY3Rpb24gPSB0aGlzLmNvbnRlbnRFbGVtZW50LmNoaWxkcmVuWzBdO1xuXG4gICAgICAgIHdoaWxlKHNlY3Rpb24pIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLl9jbGVhbnVwSFRNTEZyb21FZGl0b3JTcGVjaWZpY01hcmt1cEZvclNlY3Rpb25IVE1MKHNlY3Rpb24ub3V0ZXJIVE1MKTtcbiAgICAgICAgICAgIHNlY3Rpb24gPSBzZWN0aW9uLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgZ2V0T3JpZ2luYWxDb250ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnLFxuICAgICAgICAgICAgc2VjdGlvbiA9IHRoaXMuY29udGVudEVsZW1lbnQuY2hpbGRyZW5bMF07XG5cbiAgICAgICAgd2hpbGUoc2VjdGlvbikge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuX2NsZWFudXBIVE1MRnJvbUVkaXRvclNwZWNpZmljTWFya3VwRm9yU2VjdGlvbkhUTUwoc2VjdGlvbi5vcmlnaW5hbEhUTUwpO1xuICAgICAgICAgICAgc2VjdGlvbiA9IHNlY3Rpb24ubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhcHBseUNoYW5nZXNldDogZnVuY3Rpb24oY2hhbmdlc2V0LCBhdHRyKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIHRvdGFsT2xkQ29udGVudExlbmd0aCA9IDA7XG4gICAgICAgIHZhciBjaGFuZ2VzZXRDdXJzb3JPbGRWZXJzaW9uID0gMDtcbiAgICAgICAgdmFyIGNoYW5nZXNldEN1cnNvck5ld1ZlcnNpb24gPSAwO1xuICAgICAgICB2YXIgbGVuZ3RoT2ZVbmNoYW5nZWRTZWN0aW9uID0gMDtcbiAgICAgICAgdmFyIGxlbmd0aE9mUmVtYWluaW5nQ29udGVudCA9IDA7XG4gICAgICAgIHZhciBjaGFuZ2VzU3RhcnRBZnRlciA9IDA7XG4gICAgICAgIHZhciBjaGFuZ2VzRW5kQWZ0ZXJJbk9sZFZlcnNpb24gPSAwO1xuICAgICAgICB2YXIgdXBkYXRlU3RhcnRTZWN0aW9uID0gdGhpcy5jb250ZW50RWxlbWVudC5jaGlsZHJlblswXTtcblxuICAgICAgICBmb3IoOyBpPGNoYW5nZXNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYoY2hhbmdlc2V0W2ldLmNvbnN0cnVjdG9yLm5hbWUgIT09ICdSZXRhaW4nKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoYW5nZXNTdGFydEFmdGVyICs9IGNoYW5nZXNldFtpXS5sZW5ndGg7XG4gICAgICAgICAgICBjaGFuZ2VzZXRDdXJzb3JPbGRWZXJzaW9uICs9IGNoYW5nZXNldFtpXS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSgobGVuZ3RoT2ZVbmNoYW5nZWRTZWN0aW9uICsgdGhpcy5fY2xlYW51cEhUTUxGcm9tRWRpdG9yU3BlY2lmaWNNYXJrdXBGb3JTZWN0aW9uSFRNTCh1cGRhdGVTdGFydFNlY3Rpb24ub3JpZ2luYWxIVE1MKS5sZW5ndGgpIDw9IGNoYW5nZXNTdGFydEFmdGVyKSB7XG4gICAgICAgICAgICBpZighdXBkYXRlU3RhcnRTZWN0aW9uLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxlbmd0aE9mVW5jaGFuZ2VkU2VjdGlvbiArPSB0aGlzLl9jbGVhbnVwSFRNTEZyb21FZGl0b3JTcGVjaWZpY01hcmt1cEZvclNlY3Rpb25IVE1MKHVwZGF0ZVN0YXJ0U2VjdGlvbi5vcmlnaW5hbEhUTUwpLmxlbmd0aDtcblxuICAgICAgICAgICAgdXBkYXRlU3RhcnRTZWN0aW9uID0gdXBkYXRlU3RhcnRTZWN0aW9uLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hhbmdlc2V0Q3Vyc29yTmV3VmVyc2lvbiA9IGNoYW5nZXNldEN1cnNvck9sZFZlcnNpb247XG5cbiAgICAgICAgZm9yKDsgaTxjaGFuZ2VzZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNoYW5nZXNldEN1cnNvck9sZFZlcnNpb24gKz0gY2hhbmdlc2V0W2ldLmlucHV0O1xuICAgICAgICAgICAgY2hhbmdlc2V0Q3Vyc29yTmV3VmVyc2lvbiArPSBjaGFuZ2VzZXRbaV0ub3V0cHV0O1xuXG4gICAgICAgICAgICBpZihjaGFuZ2VzZXRbaV0uY29uc3RydWN0b3IubmFtZSA9PT0gJ1NraXAnKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlc0VuZEFmdGVySW5PbGRWZXJzaW9uID0gY2hhbmdlc2V0Q3Vyc29yT2xkVmVyc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1cGRhdGVFbmRTZWN0aW9uID0gdXBkYXRlU3RhcnRTZWN0aW9uO1xuICAgICAgICB2YXIgdG1wQ2hhbmdlc0VuZFBvc2l0aW9uID0gbGVuZ3RoT2ZVbmNoYW5nZWRTZWN0aW9uO1xuXG4gICAgICAgIHdoaWxlKCh0bXBDaGFuZ2VzRW5kUG9zaXRpb24gKyB0aGlzLl9jbGVhbnVwSFRNTEZyb21FZGl0b3JTcGVjaWZpY01hcmt1cEZvclNlY3Rpb25IVE1MKHVwZGF0ZUVuZFNlY3Rpb24ub3JpZ2luYWxIVE1MKS5sZW5ndGgpIDwgY2hhbmdlc0VuZEFmdGVySW5PbGRWZXJzaW9uKSB7XG4gICAgICAgICAgICB0bXBDaGFuZ2VzRW5kUG9zaXRpb24gKz0gdGhpcy5fY2xlYW51cEhUTUxGcm9tRWRpdG9yU3BlY2lmaWNNYXJrdXBGb3JTZWN0aW9uSFRNTCh1cGRhdGVFbmRTZWN0aW9uLm9yaWdpbmFsSFRNTCkubGVuZ3RoO1xuICAgICAgICAgICAgdXBkYXRlRW5kU2VjdGlvbiA9IHVwZGF0ZUVuZFNlY3Rpb24ubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb2xkQ29udGVudCA9ICcnO1xuICAgICAgICB2YXIgdG1wU2VjdGlvbiA9IHVwZGF0ZVN0YXJ0U2VjdGlvbjtcblxuICAgICAgICB3aGlsZSh0bXBTZWN0aW9uICE9PSB1cGRhdGVFbmRTZWN0aW9uKSB7XG4gICAgICAgICAgICBvbGRDb250ZW50ICs9IHRoaXMuX2NsZWFudXBIVE1MRnJvbUVkaXRvclNwZWNpZmljTWFya3VwRm9yU2VjdGlvbkhUTUwodG1wU2VjdGlvbi5vcmlnaW5hbEhUTUwpO1xuICAgICAgICAgICAgdG1wU2VjdGlvbiA9IHRtcFNlY3Rpb24ubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBvbGRDb250ZW50ICs9IHRoaXMuX2NsZWFudXBIVE1MRnJvbUVkaXRvclNwZWNpZmljTWFya3VwRm9yU2VjdGlvbkhUTUwodXBkYXRlRW5kU2VjdGlvbi5vcmlnaW5hbEhUTUwpO1xuXG4gICAgICAgIHRtcFNlY3Rpb24gPSB0bXBTZWN0aW9uLm5leHRTaWJsaW5nO1xuXG4gICAgICAgIHdoaWxlKHRtcFNlY3Rpb24pIHtcbiAgICAgICAgICAgIGxlbmd0aE9mUmVtYWluaW5nQ29udGVudCArPSB0aGlzLl9jbGVhbnVwSFRNTEZyb21FZGl0b3JTcGVjaWZpY01hcmt1cEZvclNlY3Rpb25IVE1MKHRtcFNlY3Rpb24ub3JpZ2luYWxIVE1MKS5sZW5ndGg7XG4gICAgICAgICAgICB0bXBTZWN0aW9uID0gdG1wU2VjdGlvbi5uZXh0U2libGluZztcbiAgICAgICAgfVxuXG4gICAgICAgIHRvdGFsT2xkQ29udGVudExlbmd0aCA9IGxlbmd0aE9mVW5jaGFuZ2VkU2VjdGlvbiArIG9sZENvbnRlbnQubGVuZ3RoICsgbGVuZ3RoT2ZSZW1haW5pbmdDb250ZW50O1xuXG4gICAgICAgIGlmKHRvdGFsT2xkQ29udGVudExlbmd0aCAhPT0gY2hhbmdlc2V0LmlucHV0TGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyAnYXBwbHlDaGFuZ2VzZXQ6IHRoZSBnaXZlbiBjaGFuZ2VzZXQgZG9lcyBub3QgbWF0Y2ggdGhlIGNvbnRlbnQgbGVuZ3RoISEnO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2xpY2UgPSAoY2FuZ2VzZXQsIHN0YXJ0LCBlbmQpID0+IHtcbiAgICAgICAgICAgIGxldCBwcm9jZXNzZWQgPSAwO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IENoYW5nZXNldC5jcmVhdGUoKTtcblxuICAgICAgICAgICAgZm9yKGxldCBvcCBvZiBjaGFuZ2VzZXQpIHtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudE9wU3RhcnQgPSBwcm9jZXNzZWQ7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRPcEVuZCA9IHByb2Nlc3NlZCArIG9wLmlucHV0O1xuXG4gICAgICAgICAgICAgICAgaWYoY3VycmVudE9wU3RhcnQgPCBzdGFydCAmJiBjdXJyZW50T3BFbmQgPiBzdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBpZihvcC5jb25zdHJ1Y3Rvci5uYW1lICE9PSAnUmV0YWluJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ1JldGFpbiBvcGVyYXRpb24gZXhwZWN0ZWQgd2hlbiBleHRyYWN0aW5nIHRoZSBjaGFuZ2VzIGxvY2FsIHRvIGEgc2VjdGlvbidcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5yZXRhaW4ob3AuaW5wdXQgLSAoc3RhcnQgLSBjdXJyZW50T3BTdGFydCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZihjdXJyZW50T3BTdGFydCA+PSBzdGFydCAmJiBjdXJyZW50T3BFbmQgPD0gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5vcHMucHVzaChvcCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKGN1cnJlbnRPcFN0YXJ0ID49IHN0YXJ0ICYmIGN1cnJlbnRPcFN0YXJ0IDwgZW5kICYmIGVuZCA8IGN1cnJlbnRPcEVuZCkge1xuICAgICAgICAgICAgICAgICAgICBpZihvcC5jb25zdHJ1Y3Rvci5uYW1lICE9PSAnUmV0YWluJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ1JldGFpbiBvcGVyYXRpb24gZXhwZWN0ZWQgd2hlbiBleHRyYWN0aW5nIHRoZSBjaGFuZ2VzIGxvY2FsIHRvIGEgc2VjdGlvbic7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucmV0YWluKG9wLmlucHV0IC0gKGN1cnJlbnRPcEVuZC1lbmQpKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZihjdXJyZW50T3BTdGFydCA+IGVuZCkge1xuICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHByb2Nlc3NlZCArPSBvcC5pbnB1dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5lbmQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2NhbENoYW5nZXNldCA9IHNsaWNlKGNoYW5nZXNldCwgbGVuZ3RoT2ZVbmNoYW5nZWRTZWN0aW9uLCBsZW5ndGhPZlVuY2hhbmdlZFNlY3Rpb24rb2xkQ29udGVudC5sZW5ndGgpO1xuICAgICAgICBsb2NhbENoYW5nZXNldC5hZGRlbmR1bSA9IGNoYW5nZXNldC5hZGRlbmR1bTtcbiAgICAgICAgbG9jYWxDaGFuZ2VzZXQucmVtb3ZlbmR1bSA9IGNoYW5nZXNldC5yZW1vdmVuZHVtO1xuXG4gICAgICAgIHZhciBuZXdDb250ZW50ID0gbG9jYWxDaGFuZ2VzZXQuYXBwbHkob2xkQ29udGVudCk7XG5cbiAgICAgICAgdGhpcy5zZXRDb250ZW50KG5ld0NvbnRlbnQsIHtcbiAgICAgICAgICAgIC4uLmF0dHIsXG4gICAgICAgICAgICBzdGFydFNlY3Rpb246IHVwZGF0ZVN0YXJ0U2VjdGlvbixcbiAgICAgICAgICAgIGVuZFNlY3Rpb246IHVwZGF0ZUVuZFNlY3Rpb25cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHNldENvbnRlbnQ6IGZ1bmN0aW9uKGNvbnRlbnQsIGFyZ3MpIHtcbiAgICAgICAgYXJncyA9IGFyZ3MgfHwge307XG5cbiAgICAgICAgdmFyIGluc2VydGVkQ29udGVudCA9IGFyZ3MuaW5wdXRFdmVudCAmJiBhcmdzLmlucHV0RXZlbnQuZGF0YSxcbiAgICAgICAgICAgIG1vZGlmaWNhdGlvbkxvZ0VudHJ5LFxuICAgICAgICAgICAgY3VycmVudENhcmV0UG9zaXRpb24sXG4gICAgICAgICAgICBiZWZvcmVTdGF0ZUNhcmV0UG9zaXRpb24sXG4gICAgICAgICAgICBzY3JvbGxQb3NpdGlvbiA9IHRoaXMuc2F2ZVNjcm9sbFBvc2l0aW9uKGFyZ3Muc2VjdGlvbik7XG5cbiAgICAgICAgaWYodGhpcy5jYXJldC5pc1dpdGhpbkVsZW1lbnQodGhpcy5jb250ZW50RWxlbWVudCkgJiYgYXJncy5wb3NpdGlvbkNhcmV0QXRUaGVFbmRPZlNlY3Rpb25XaXRoSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY3VycmVudENhcmV0UG9zaXRpb24gPSB0aGlzLmNhcmV0LnNhdmVTZWxlY3Rpb24odGhpcy5jb250ZW50RWxlbWVudCwgaW5zZXJ0ZWRDb250ZW50KSxcbiAgICAgICAgICAgIGJlZm9yZVN0YXRlQ2FyZXRQb3NpdGlvbiA9IHRoaXMuY2FyZXRQb3NpdGlvbnNbdGhpcy5jYXJldFBvc2l0aW9ucy5sZW5ndGgtMV07XG4gICAgICAgIH1cblxuICAgICAgICBhcmdzLm1vZGlmaWNhdGlvbkxvZ0VudHJ5ID0gYXJncy5tb2RpZmljYXRpb25Mb2dFbnRyeSB8fCBuZXcgTW9kaWZpY2F0aW9uTG9nRW50cnkoKTtcbiAgICAgICAgYXJncy5tb2RpZmljYXRpb25Mb2dFbnRyeS5tb2RMb2dGbGFncyA9IHRoaXMubW9kTG9nRmxhZ3M7XG5cbiAgICAgICAgYXJncy5tb2RpZmljYXRpb25Mb2dFbnRyeS5hY3RvciA9IGFyZ3MuYWN0b3JcblxuICAgICAgICB0aGlzLmNhcmV0UG9zaXRpb25zLnB1c2goYXJncy5jYXJldFBvc2l0aW9uIHx8IGN1cnJlbnRDYXJldFBvc2l0aW9uKTtcblxuICAgICAgICBtb2RpZmljYXRpb25Mb2dFbnRyeSA9IHRoaXMuZG9jdW1lbnR1cGRhdGVyLnVwZGF0ZUhUTUwoY29udGVudCwgdGhpcy5mb2N1c2VkU2VjdGlvbigpLCB7IC4uLmFyZ3MsIGNhcmV0OiB0aGlzLmNhcmV0IH0pO1xuXG4gICAgICAgIGlmKG1vZGlmaWNhdGlvbkxvZ0VudHJ5LmZvY3VzZWRTZWN0aW9uSGFzQmVlbk1vZGlmaWVkICYmIGFyZ3MucG9zaXRpb25DYXJldEF0VGhlRW5kT2ZTZWN0aW9uV2l0aEluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmKG1vZGlmaWNhdGlvbkxvZ0VudHJ5LmNoYW5nZVNlY3Rpb25UeXBlKSB7XG4gICAgICAgICAgICAgICAgYXJncy5hY3Rpb24gPSAnY2hhbmdlRm9jdXNlZFNlY3Rpb25UeXBlJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIWFyZ3MuY2FyZXRQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIGlmKCFtb2RpZmljYXRpb25Mb2dFbnRyeS5mb2N1c2VkU2VjdGlvbkRPTVdhc05vdE1vZGlmaWVkIHx8ICEoY3VycmVudENhcmV0UG9zaXRpb24gJiYgIGN1cnJlbnRDYXJldFBvc2l0aW9uLnNlbGVjdGlvbklzQ29sbGFwc2VkKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKG1vZGlmaWNhdGlvbkxvZ0VudHJ5Lmluc2VydGVkQmVmb3JlU2VsZWN0aW9uUmFuZ2VTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYXJldC5yYW5nZVN0YXJ0ICs9IG1vZGlmaWNhdGlvbkxvZ0VudHJ5Lmluc2VydGVkQmVmb3JlU2VsZWN0aW9uUmFuZ2VTdGFydDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmKG1vZGlmaWNhdGlvbkxvZ0VudHJ5Lmluc2VydGVkQmVmb3JlU2VsZWN0aW9uUmFuZ2VFbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FyZXQucmFuZ2VFbmQgKz0gbW9kaWZpY2F0aW9uTG9nRW50cnkuaW5zZXJ0ZWRCZWZvcmVTZWxlY3Rpb25SYW5nZUVuZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FyZXQucmVzdG9yZVNlbGVjdGlvbihtb2RpZmljYXRpb25Mb2dFbnRyeS5kZWxldGVkQ2hhcnNCeU1hcmt1cFRyYW5zZm9ybWF0aW9ucywgJ1RyeURPTVN0cmF0ZWd5Rmlyc3QnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZihtb2RpZmljYXRpb25Mb2dFbnRyeS5mb2N1c2VkU2VjdGlvblJlcGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9jdXNTZWN0aW9uKG1vZGlmaWNhdGlvbkxvZ0VudHJ5LmZvY3VzZWRTZWN0aW9uUmVwbGFjZW1lbnQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKGFyZ3MucG9zaXRpb25DYXJldEF0VGhlRW5kT2ZTZWN0aW9uV2l0aEluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2FyZXQucG9zaXRpb25BdFRoZUJlZ2lubmluZ09mKHRoaXMuc2VjdGlvbkF0KGFyZ3MucG9zaXRpb25DYXJldEF0VGhlRW5kT2ZTZWN0aW9uV2l0aEluZGV4KSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihhcmdzLmNhcmV0UG9zaXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuY2FyZXQucmVzdG9yZVNlbGVjdGlvblZpYU9mZnNldFN0cmF0ZWd5KDAsIGFyZ3MuY2FyZXRQb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlc3RvcmVTY3JvbGxQb3N0aW9uKG1vZGlmaWNhdGlvbkxvZ0VudHJ5LmZvY3VzZWRTZWN0aW9uUmVwbGFjZW1lbnQsIHNjcm9sbFBvc2l0aW9uKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZUZvb3Rub3Rlc051bWJlcmluZygpO1xuICAgICAgICB0aGlzLnVwZGF0ZVJlZmVyZW5jZU51bWJlcmluZygpO1xuICAgICAgICB0aGlzLnVwZGF0ZUlubGluZUVxdWF0aW9uTnVtYmVyaW5nKG1vZGlmaWNhdGlvbkxvZ0VudHJ5KTtcblxuICAgICAgICBtb2RpZmljYXRpb25Mb2dFbnRyeS5iZWZvcmVTdGF0ZUNhcmV0UG9zaXRpb24gPSBiZWZvcmVTdGF0ZUNhcmV0UG9zaXRpb247XG4gICAgICAgIG1vZGlmaWNhdGlvbkxvZ0VudHJ5LmFmdGVyU3RhdGVDYXJldFBvc2l0aW9uID0gYXJncy5jYXJldFBvc2l0aW9uIHx8IGN1cnJlbnRDYXJldFBvc2l0aW9uO1xuICAgICAgICBtb2RpZmljYXRpb25Mb2dFbnRyeS50YWdzID0gYXJncy5tb2RpZmljYXRpb25Mb2dUYWdzO1xuXG4gICAgICAgIG1vZGlmaWNhdGlvbkxvZ0VudHJ5LndvcmRDb3VudCA9IHRoaXMuZ2V0V29yZENvdW50KCk7XG5cbiAgICAgICAgdGhpcy5zaG93SW5wdXRUb29sdGlwSWZDb250ZW50SXNFbXB0eSgpO1xuXG4gICAgICAgIHRoaXMuZm9jdXNTZWN0aW9uKHRoaXMuc2VjdGlvbkF0Q2FyZXRQb3N0aW9uKCksIGFyZ3MpO1xuICAgICAgICB0aGlzLl9yZW1vdmVFbXB0eVNlY3Rpb25zRXhjZXB0T2ZGb2N1c2VkU2VjdGlvbihtb2RpZmljYXRpb25Mb2dFbnRyeSk7XG4gICAgICAgIHRoaXMubm90aWZ5U3Vic2NyaWJlcnMobW9kaWZpY2F0aW9uTG9nRW50cnkpO1xuXG4gICAgICAgIHJldHVybiBtb2RpZmljYXRpb25Mb2dFbnRyeTtcbiAgICB9LFxuXG4gICAgc2hvd0lucHV0VG9vbHRpcElmQ29udGVudElzRW1wdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZih0aGlzLl9pbml0RG9uZSAmJiB0aGlzLmNvbnRlbnRFbGVtZW50LmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiB0aGlzLmNvbnRlbnRFbGVtZW50LmlubmVyVGV4dC50cmltKCkgPT09ICcnICYmIHRoaXMuY29udGVudEVsZW1lbnQuY2hpbGRyZW5bMF0udGFnTmFtZSA9PT0gJ1AnKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lckVsZW1lbnQuaW5zZXJ0QmVmb3JlKHRoaXMuaGludEVsLCB0aGlzLmNvbnRlbnRFbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGludEVsLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldFdvcmRDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAwO1xuXG4gICAgICAgIGZvcihsZXQgaT0wOyBpPHRoaXMuY29udGVudEVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLmNvbnRlbnRFbGVtZW50LmNoaWxkcmVuW2ldLndvcmRDb3VudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIHNhdmVTY3JvbGxQb3NpdGlvbjogZnVuY3Rpb24oc2VjdGlvbikge1xuICAgICAgICB2YXIgbmVzdGVkQ29kZUVsLFxuICAgICAgICAgICAgaXNEaWFTZWN0aW9uID0gc2VjdGlvbiAmJiBzZWN0aW9uLmNsYXNzTGlzdCAmJiBzZWN0aW9uLmNsYXNzTGlzdC5jb250YWlucygnbTJkaWEnKSxcbiAgICAgICAgICAgIGlzQ29kZVNlY3Rpb24gPSBzZWN0aW9uICYmIHNlY3Rpb24udGFnTmFtZSA9PT0gJ1BSRSc7XG5cbiAgICAgICAgaWYoaXNEaWFTZWN0aW9uIHx8IGlzQ29kZVNlY3Rpb24pIHtcbiAgICAgICAgICAgIG5lc3RlZENvZGVFbCA9IHNlY3Rpb24ucXVlcnlTZWxlY3RvcignY29kZScpO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IHdpbmRvdy5zY3JvbGxYLFxuICAgICAgICAgICAgICAgIHk6IHdpbmRvdy5zY3JvbGxZLFxuICAgICAgICAgICAgICAgIGNvZGVTY3JvbGxYOiBuZXN0ZWRDb2RlRWwgJiYgbmVzdGVkQ29kZUVsLnNjcm9sbExlZnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZXN0b3JlU2Nyb2xsUG9zdGlvbjogZnVuY3Rpb24oc2VjdGlvbiwgc2Nyb2xsUG9zaXRpb24pIHtcbiAgICAgICAgdmFyIG5lc3RlZENvZGVFbDtcbiAgICAgICAgaWYoc2Nyb2xsUG9zaXRpb24pIHtcbiAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbyhzY3JvbGxQb3NpdGlvbi54LCBzY3JvbGxQb3NpdGlvbi55KTtcbiAgICAgICAgICAgIGlmKHNjcm9sbFBvc2l0aW9uLmNvZGVTY3JvbGxYICYmIHNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBuZXN0ZWRDb2RlRWwgPSBzZWN0aW9uLnF1ZXJ5U2VsZWN0b3IoJ2NvZGUnKVxuICAgICAgICAgICAgICAgIG5lc3RlZENvZGVFbC5zY3JvbGxUbyhzY3JvbGxQb3NpdGlvbi5jb2RlU2Nyb2xsWCwgbmVzdGVkQ29kZUVsLnNjcm9sbFkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdXBkYXRlRm9vdG5vdGVzTnVtYmVyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFsbEZvb3Rub3RlcyA9IHRoaXMuY29udGVudEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmZvb3Rub3RlJyk7XG4gICAgICAgIGZvcih2YXIgaT0wOyBpPGFsbEZvb3Rub3Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYoYWxsRm9vdG5vdGVzW2ldLmlubmVyVGV4dCAhPT0gKGkrMSkudG9TdHJpbmcoKSkge1xuICAgICAgICAgICAgICAgIGFsbEZvb3Rub3Rlc1tpXS5pbm5lclRleHQgPSAoaSsxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB1cGRhdGVSZWZlcmVuY2VOdW1iZXJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVmcyA9IHRoaXMuY29udGVudEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnJlZmVyZW5jZScpO1xuXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHJlZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMucmVmZXJlbmNlLnVwZGF0ZVJlZkVsZW1lbnQocmVmc1tpXSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdXBkYXRlSW5saW5lRXF1YXRpb25OdW1iZXJpbmc6IGZ1bmN0aW9uKG1vZGlmaWNhdGlvbkxvZ0VudHJ5KSB7XG4gICAgICAgIHZhciBlcXMgPSB0aGlzLmNvbnRlbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lubGluZWVxdWF0aW9uJyksXG4gICAgICAgICAgICBsYXRleCwgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgZm9yKHZhciBpPTA7IGk8ZXFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgZXEgPSBlcXNbaV1cbiAgICAgICAgICAgIGVxLmlubmVySFRNTCA9ICcnO1xuICAgICAgICAgICAgbGF0ZXggPSB1dGlscy5hdHRyaWJ1dGVTYXZlU3RyaW5nVG9TdHJpbmcoZXEuZGF0YXNldC5sYXRleGVxdWF0aW9uKVxuXG4gICAgICAgICAgICBlcS5vbmNsaWNrID0gZXEub25jbGljayB8fCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jYXJldC5wb3NpdGlvbkFmdGVyKHV0aWxzLmdldEZpcnN0UGFyZW50V2l0aFRhZ05hbWUoZS50YXJnZXQpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBrYXRleC5yZW5kZXIobGF0ZXgsIGVxLCB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93T25FcnJvcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheU1vZGU6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIGVxLmlubmVySFRNTCA9ICc8c3BhbiBjbGFzcz1cImVycm9yXCI+aW52YWxpZCBMYVRlWCBlcXVhdGlvbjwvc3Bhbj4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNob3VsZFNlY3Rpb25CZVJlbW92ZWRJZlVuZm9jdXNlZDogZnVuY3Rpb24oc2VjdGlvbikge1xuICAgICAgICByZXR1cm4gc2VjdGlvbi5pbm5lclRleHQudHJpbSgpID09PSAnJyAmJlxuICAgICAgICAgICAgICAgIXNlY3Rpb24uY2xhc3NMaXN0LmZpbmQoYyA9PiBjLnN0YXJ0c1dpdGgoJ2ZvY3VzZWQtYnktYXBpLWFjdG9yJykpICYmXG4gICAgICAgICAgICAgICAhKHRoaXMuaHRtbFJhem9yLmdldFJ1bGVCeUVsZW1lbnQoc2VjdGlvbikuZGVsZXRlSWZFbXB0eSA9PT0gZmFsc2UpO1xuICAgIH0sXG5cbiAgICBkZWxldGVOb25Db2xsYXBzZWRTZWxlY3Rpb25Db250ZW50OiBmdW5jdGlvbihzZWwpIHtcbiAgICAgICAgc2VsID0gc2VsIHx8IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblxuICAgICAgICBpZighc2VsKSByZXR1cm47XG5cbiAgICAgICAgdmFyIHMxID0gdGhpcy5zZWN0aW9uQnlDaGlsZE5vZGUoc2VsLmFuY2hvck5vZGUpLFxuICAgICAgICAgICAgczIgPSB0aGlzLnNlY3Rpb25CeUNoaWxkTm9kZShzZWwuZm9jdXNOb2RlKSxcbiAgICAgICAgICAgIGkxID0gdGhpcy5pbmRleE9mKHMxKSxcbiAgICAgICAgICAgIGkyID0gdGhpcy5pbmRleE9mKHMyKSxcbiAgICAgICAgICAgIHRtcCwgbmV3RWxlbWVudDtcblxuICAgICAgICBpZihpMSA9PT0gdW5kZWZpbmVkIHx8IGkyID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgICAgICBpZihpMSA+IGkyKSB7XG4gICAgICAgICAgICB0bXAgPSBzMTsgczEgPSBzMjsgczIgPSB0bXA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBoYXZlIHRvIGtlZXAgdGhlIHNlY3Rpb25zIGluIGJldHdlZW4gdGhlIHNlbGVjdGlvbiBpbiBvcmRlclxuICAgICAgICAvLyB0byBjYWNsdWxhdGUgdGhlIG1vZGlmaWNhdGlvbkxvZ0VudHJ5LiBUaGV5IHdpbGwgYmUgcmVtb3ZlZCBieVxuICAgICAgICAvLyB0aGUgc2V0Q29udGVudCBmdW5jdGlvbiB3aGljaCBhbHNvIGNhbGN1bGF0ZXMgdGhlIExvZ0VudHJ5LlxuICAgICAgICB0aGlzLl9kZWxldGVTZWxlY3RlZFRleHRCdXRLZWVwQWxsU2VsZWN0ZWRTZWN0aW9ucyhzMSwgczIsIHNlbCk7XG5cbiAgICAgICAgbmV3RWxlbWVudCA9IHMxLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICAgIG5ld0VsZW1lbnQuaW5uZXJIVE1MID0gczEuaW5uZXJIVE1MICsgczIuaW5uZXJIVE1MO1xuXG4gICAgICAgIHRoaXMuc2V0Q29udGVudChuZXdFbGVtZW50Lm91dGVySFRNTCwge3N0YXJ0U2VjdGlvbjogczEsIGVuZFNlY3Rpb246IHMyfSk7XG5cbiAgICAgICAgaWYoIXRoaXMuc2VjdGlvbkF0Q2FyZXRQb3N0aW9uKCkpIHtcbiAgICAgICAgICAgIHRoaXMucGxhY2VDYXJldEludG9TZWN0aW9uKHRoaXMuY29udGVudEVsZW1lbnQubGFzdENoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0Q29udGVudEVkaXRhYmxlKHRydWUpO1xuICAgIH0sXG5cbiAgICBzZXRGaWxlUGVyc2lzdEhhbmRsZXI6IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgICAgT2JqZWN0LnZhbHVlcyh0aGlzLnN1cHBvcnRlZFNlY3Rpb25UeXBlcylcbiAgICAgICAgICAgIC5maWx0ZXIoc2VjdGlvbiA9PiBzZWN0aW9uLnBlcnNpc3RGaWxlKVxuICAgICAgICAgICAgLmZvckVhY2goc2VjdGlvbiA9PiB7XG4gICAgICAgICAgICAgICAgc2VjdGlvbi5wZXJzaXN0RmlsZSA9IGhhbmRsZXI7XG4gICAgICAgIH0pXG4gICAgfSxcblxuICAgIGFkZFJlZmVyZW5jZURhdGE6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdGhpcy5yZWZlcmVuY2UuYWRkUmVmZXJlbmNlRGF0YShkYXRhKTtcbiAgICAgICAgdGhpcy51cGRhdGVSZWZlcmVuY2VOdW1iZXJpbmcoKTtcblxuICAgICAgICBpZih0aGlzLmNvbnRlbnRFbGVtZW50LmNoaWxkcmVuWzBdKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmaWNhdGlvbkxvZ0VudHJ5ID0gbmV3IE1vZGlmaWNhdGlvbkxvZ0VudHJ5KCk7XG4gICAgICAgICAgICB0aGlzLm1vZGlmaWNhdGlvbkxvZ0VudHJ5LnJldGFpblNlY3Rpb24odGhpcy5jb250ZW50RWxlbWVudC5jaGlsZHJlblswXSk7XG4gICAgICAgICAgICB0aGlzLm1vZGlmaWNhdGlvbkxvZ0VudHJ5LnJldGFpbkFsbFNlY3Rpb25zQWZ0ZXIodGhpcy5jb250ZW50RWxlbWVudC5jaGlsZHJlblswXSk7XG4gICAgICAgICAgICB0aGlzLm1vZGlmaWNhdGlvbkxvZ0VudHJ5Lm1pZ2h0SW5jbHVkZVJlZmVyZW5jZVVwZGF0ZXMgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlTdWJzY3JpYmVycyh0aGlzLm1vZGlmaWNhdGlvbkxvZ0VudHJ5KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfcmVtb3ZlRW1wdHlTZWN0aW9uc0V4Y2VwdE9mRm9jdXNlZFNlY3Rpb246IGZ1bmN0aW9uKGZpbmFsaXplZE1vZGlmaWNhdGlvbkxvZ0VudHJ5KSB7XG4gICAgICAgIHZhciBzZWN0aW9ucyA9IHRoaXMuY29udGVudEVsZW1lbnQuY2hpbGRyZW4sXG4gICAgICAgICAgICB0b0JlRGVsZXRlZCA9IFtdLCBpbmRleENvcnJlY3Rpb24gPSAwLCBvbGRNb2RMb2csIGRlbGV0ZWRTZWN0aW9uO1xuXG4gICAgICAgIGlmKHNlY3Rpb25zLmxlbmd0aCA9PT0gMSkgcmV0dXJuO1xuXG4gICAgICAgIGZvcihsZXQgaT0wOyBpPHNlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZih0aGlzLnNob3VsZFNlY3Rpb25CZVJlbW92ZWRJZlVuZm9jdXNlZChzZWN0aW9uc1tpXSkgJiZcbiAgICAgICAgICAgICAgIHNlY3Rpb25zW2ldICE9PSB0aGlzLmZvY3VzZWRTZWN0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICAgdG9CZURlbGV0ZWQucHVzaCh7c2VjdGlvbjogc2VjdGlvbnNbaV0sIGluZGV4OiBpfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IobGV0IGk9MDsgaTx0b0JlRGVsZXRlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGVsZXRlZFNlY3Rpb24gPSB0aGlzLmNvbnRlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHRvQmVEZWxldGVkW2ldLnNlY3Rpb24pO1xuICAgICAgICAgICAgb2xkTW9kTG9nID0gZmluYWxpemVkTW9kaWZpY2F0aW9uTG9nRW50cnkuZGVsZXRlU2VjdGlvbkF0KHRvQmVEZWxldGVkW2kraW5kZXhDb3JyZWN0aW9uXS5pbmRleCwgZGVsZXRlZFNlY3Rpb24pO1xuICAgICAgICAgICAgaWYob2xkTW9kTG9nLnR5cGUgPT09ICdpbnNlcnQnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXhDb3JyZWN0aW9uLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNlY3Rpb25UeXBlU2VsZWN0b3IuZGlzcGxheU5leHRUbyh0aGlzLmZvY3VzZWRTZWN0aW9uKCkpO1xuICAgIH0sXG5cbiAgICAvLyBFeGFtcGxlOiB0aGUgcGlwZXMgKFwifFwiKSBzaG93IHdoZXJlIHRoZSBzZWxlY3Rpb24gc3RhcnRzL2VuZHNcbiAgICAvLyBjb250ZW50IGJlZm9yZSBleGVjdXRpb246IDxwPnNlY3Rpb24gfG9uZTwvcD48cD5zZWN0aW9uIHR3bzwvcD48cD5zZWN0aW9uIHRocmVlPC9wPjxwPnNlY3Rpb24gfGZvdXI8L3A+XG4gICAgLy8gY29udGVudCBhZnRlciBleGVjdXRpb246IDxwPnNlY3Rpb24gfHw8L3A+PHA+PC9wPjxwPjwvcD48cD5mb3VyPC9wPlxuICAgIF9kZWxldGVTZWxlY3RlZFRleHRCdXRLZWVwQWxsU2VsZWN0ZWRTZWN0aW9uczogZnVuY3Rpb24oczEsIHMyLCBzZWwpIHtcbiAgICAgICAgdmFyIGluQmV0d2VlblNlY3Rpb25zID0gW10sXG4gICAgICAgICAgICBpMSA9IHRoaXMuaW5kZXhPZihzMSksXG4gICAgICAgICAgICBpMiA9IHRoaXMuaW5kZXhPZihzMiksXG4gICAgICAgICAgICBjZWMgPSB0aGlzLmNvbnRlbnRFbGVtZW50LmNoaWxkcmVuLFxuICAgICAgICAgICAgdG1wLCBpLCByYW5nZSwgc2VsZWN0aW9uLCBsYXN0SW5zZXJ0ZWREdW1teVNlY3Rpb24sIGNsb25lZFJhbmdlO1xuXG4gICAgICAgIGlmKGkxID4gaTIpIHtcbiAgICAgICAgICAgIHRtcCA9IHMxOyBzMSA9IHMyOyBzMiA9IHRtcDtcbiAgICAgICAgICAgIHRtcCA9IGkxOyBpMSA9IGkyOyBpMiA9IHRtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHMxLnN1bW1hcml6ZWRDb250ZW50TGVuZ3RoID0gdW5kZWZpbmVkO1xuICAgICAgICBzMi5zdW1tYXJpemVkQ29udGVudExlbmd0aCA9IHVuZGVmaW5lZDtcblxuICAgICAgICBmb3IoaT1pMSsxIDsgaTxpMjsgaSsrKSB7XG4gICAgICAgICAgICB0bXAgPSBjZWNbaV0uY2xvbmVOb2RlKGZhbHNlKTtcbiAgICAgICAgICAgIHRtcC5vcmlnaW5hbEhUTUwgPSBjZWNbaV0ub3JpZ2luYWxIVE1MO1xuICAgICAgICAgICAgdG1wLnN1bW1hcml6ZWRDb250ZW50TGVuZ3RoID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLm1vZExvZ0ZsYWdzKS5mb3JFYWNoKGZ1bmN0aW9uKGZsYWcpIHtcbiAgICAgICAgICAgICAgICB0bXBbJ29yaWdpbmFsSFRNTENvbnRhaW5zJyArIGZsYWddID0gY2VjW2ldWydvcmlnaW5hbEhUTUxDb250YWlucycgKyBmbGFnXTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpbkJldHdlZW5TZWN0aW9ucy5wdXNoKHRtcCk7XG4gICAgICAgIH1cblxuICAgICAgICByYW5nZSA9IHNlbC5nZXRSYW5nZUF0KDApO1xuICAgICAgICBjbG9uZWRSYW5nZSA9IHJhbmdlLmNsb25lUmFuZ2UoKTtcbiAgICAgICAgcmFuZ2UuZGVsZXRlQ29udGVudHMoKTtcbiAgICAgICAgLy8gY2xvbmVkUmFuZ2UuY29sbGFwc2U7ID8/IHdoeSBub3QgY2xvbmVkUmFuZ2UuY29sbGFwc2UoKVxuICAgICAgICBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKGNsb25lZFJhbmdlKTtcblxuICAgICAgICBsYXN0SW5zZXJ0ZWREdW1teVNlY3Rpb24gPSBzMjtcbiAgICAgICAgd2hpbGUoaW5CZXR3ZWVuU2VjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdG1wID0gaW5CZXR3ZWVuU2VjdGlvbnMucG9wKCk7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRFbGVtZW50Lmluc2VydEJlZm9yZSh0bXAsIGxhc3RJbnNlcnRlZER1bW15U2VjdGlvbik7XG4gICAgICAgICAgICBsYXN0SW5zZXJ0ZWREdW1teVNlY3Rpb24gPSB0bXA7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2NsZWFudXBIVE1MRnJvbUVkaXRvclNwZWNpZmljTWFya3VwRm9yU2VjdGlvbkhUTUw6IGZ1bmN0aW9uKEhUTUwpIHtcbiAgICAgICAgcmV0dXJuIEhUTUwucmVwbGFjZSgvXjwoW2EtekEtWjAtOVxcLV0rPylcXHMoLio/KT4vLCAobWF0Y2gsIHRhZ05hbWUsIGF0dHJpYnV0ZXMpID0+IHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgLm1hdGNoKC8oW2EtekEtWjAtOVxcLV0rPVwiLio/XCIpfFthLXpBLVowLTlcXC1dKi9nKVxuICAgICAgICAgICAgICAgIC5tYXAoeCA9PiB4LnRyaW0oKSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKHggPT4geCAhPT0gJycpXG4gICAgICAgICAgICAgICAgLm1hcChhdHRyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYXR0ciA9IGF0dHIuc3BsaXQoJz0nKVxuXG4gICAgICAgICAgICAgICAgICAgIGlmKGF0dHJbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJbMV0gPSBhdHRyWzFdLnJlcGxhY2UoL14oXCJ8JykvZywgJycpLnJlcGxhY2UoLyhcInwnKSQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZihhdHRyWzBdID09PSAnY2xhc3MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyWzFdID0gYXR0clsxXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zcGxpdCgnICcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChjID0+IGMudHJpbSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoYyA9PiBjICE9PSAnZm9jdXNlZCcgJiYgIWMuc3RhcnRzV2l0aCgnZm9jdXNlZC1ieS1hcGktYWN0b3InKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuam9pbignICcpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZihhdHRyWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyWzFdID0gYFwiJHthdHRyWzFdLnRyaW0oKX1cImBcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhdHRyLmpvaW4oJz0nKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmZpbHRlcihhdHRyID0+ICFhdHRyLm1hdGNoKC9jb250ZW50ZWRpdGFibGU9XCJ0cnVlXCIvKSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGF0dHIgPT4gYXR0ciAhPT0gJ2NsYXNzPScpXG4gICAgICAgICAgICAgICAgLmpvaW4oJyAnKVxuXG5cbiAgICAgICAgICAgIHJldHVybiBhdHRyaWJ1dGVzICE9PSAnJyA/XG4gICAgICAgICAgICAgICAgYDwke3RhZ05hbWV9ICR7YXR0cmlidXRlc30+YCA6XG4gICAgICAgICAgICAgICAgYDwke3RhZ05hbWV9PmBcbiAgICAgICAgfSkucmVwbGFjZUFsbCgnJm5ic3A7JywgJyAnKTtcbiAgICB9LFxuXG4gICAgX2NsZWFudXBNb2RpZmljYXRpb25Mb2dGcm9tRWRpdG9yU3BlY2lmaWNNYXJrdXA6IGZ1bmN0aW9uKG1vZGlmaWNhdGlvbkxvZ0VudHJ5KSB7XG4gICAgICAgIG1vZGlmaWNhdGlvbkxvZ0VudHJ5LmxvZy5mb3JFYWNoKGxvZyA9PiB7XG4gICAgICAgICAgICBpZihsb2cub2xkU2VjdGlvbkhUTUwpIHtcbiAgICAgICAgICAgICAgICBsb2cub2xkU2VjdGlvbkhUTUwgPSB0aGlzLl9jbGVhbnVwSFRNTEZyb21FZGl0b3JTcGVjaWZpY01hcmt1cEZvclNlY3Rpb25IVE1MKGxvZy5vbGRTZWN0aW9uSFRNTCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihsb2cubmV3U2VjdGlvbkhUTUwpIHtcbiAgICAgICAgICAgICAgICBsb2cubmV3U2VjdGlvbkhUTUwgPSB0aGlzLl9jbGVhbnVwSFRNTEZyb21FZGl0b3JTcGVjaWZpY01hcmt1cEZvclNlY3Rpb25IVE1MKGxvZy5uZXdTZWN0aW9uSFRNTCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihsb2cuc2VjdGlvbkhUTUwpIHtcbiAgICAgICAgICAgICAgICBsb2cuc2VjdGlvbkhUTUwgPSB0aGlzLl9jbGVhbnVwSFRNTEZyb21FZGl0b3JTcGVjaWZpY01hcmt1cEZvclNlY3Rpb25IVE1MKGxvZy5zZWN0aW9uSFRNTCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFZGl0b3I7XG4iLCJmdW5jdGlvbiBLZXlQcmVzc0hhbmRsZXIoZWRpdG9yKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBhc3RlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBwYXN0ZURhdGE7XG4gICAgICAgIGVkaXRvci5jYXJldC5lbnN1cmVFeHBhbmRlZFNlbGVjdGlvbklzV2l0aGluRWxlbWVudChlZGl0b3IuY29udGVudEVsZW1lbnQpO1xuXG4gICAgICAgIGlmKHNlbGYuZWRpdG9yLmFyZU11bHRpcGxlU2VjdGlvbnNTZWxlY3RlZCgpKSB7XG4gICAgICAgICAgICBzZWxmLmVkaXRvci5kZWxldGVOb25Db2xsYXBzZWRTZWxlY3Rpb25Db250ZW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZigoZWRpdG9yLmNhcmV0LmdldENvbnRleHRFbGVtZW50KCdjb2RlJykgJiYgZWRpdG9yLmNhcmV0LmdldENvbnRleHRFbGVtZW50KCdwcmUnKSlcbiAgICAgICAgICAgfHwgZWRpdG9yLmNhcmV0LmdldENvbnRleHRFbGVtZW50KCdjYXB0aW9uJylcbiAgICAgICAgICAgfHwgZWRpdG9yLmNhcmV0LmdldENvbnRleHRFbGVtZW50KCdjaXRlc3JjJykpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICBwYXN0ZURhdGEgPSBlLmNsaXBib2FyZERhdGEuZ2V0RGF0YSgndGV4dC9wbGFpbicpLnJlcGxhY2UoLzwvZywgJyZsdDsnKS5yZXBsYWNlKC8+L2csICcmZ3Q7Jyk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBkb2N1bWVudC5leGVjQ29tbWFuZCgnaW5zZXJ0aHRtbCcsIGZhbHNlLCBwYXN0ZURhdGEpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgc2VjdGlvbiwgaGFuZGxlRW50ZXJLZXk7XG5cbiAgICAgICAgaWYoIWUubWV0YUtleSAmJiAhZS5jdHJsS2V5KSB7XG4gICAgICAgICAgICBpZihlLmtleSA9PT0gJyAnKSAgICAgICAgICAgICAgeyAhZWRpdG9yLmlzQ29udGVudEVkaXRhYmxlKCkgJiYgZS5wcmV2ZW50RGVmYXVsdCgpOyB9XG5cbiAgICAgICAgICAgIGlmKGUua2V5ID09PSAnQmFja3NwYWNlJykge1xuICAgICAgICAgICAgICAgIHNlY3Rpb24gPSBlZGl0b3Iuc2VjdGlvbkJ5Q2hpbGROb2RlKGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBlZGl0b3IuY2FyZXQuZW5zdXJlRXhwYW5kZWRTZWxlY3Rpb25Jc1dpdGhpbkVsZW1lbnQoZWRpdG9yLmNvbnRlbnRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICBpZihzZWN0aW9uICYmIHNlY3Rpb24ub25LZXlCYWNrc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VjdGlvbi5vbktleUJhY2tzcGFjZShlLCBlZGl0b3IpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaGFuZGxlQmFja3NwYWNlKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoZS5rZXkgPT09ICdBcnJvd1VwJykge1xuICAgICAgICAgICAgICAgIHNlY3Rpb24gPSBlZGl0b3Iuc2VjdGlvbkJ5Q2hpbGROb2RlKGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBpZihzZWN0aW9uICYmIHNlY3Rpb24ub25LZXlVcCkge1xuICAgICAgICAgICAgICAgICAgICBzZWN0aW9uLm9uS2V5VXAoZSwgZWRpdG9yKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlZGl0b3IubW92ZUNhcmV0T25lU2VjdGlvblVwKCk7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGUua2V5ID09PSAnQXJyb3dEb3duJykge1xuICAgICAgICAgICAgICAgIHNlY3Rpb24gPSBlZGl0b3Iuc2VjdGlvbkJ5Q2hpbGROb2RlKGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBpZihzZWN0aW9uICYmIHNlY3Rpb24ub25LZXlEb3duKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlY3Rpb24ub25LZXlEb3duKGUsIGVkaXRvcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLm1vdmVDYXJldE9uZVNlY3Rpb25Eb3duKCk7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGUua2V5ID09PSAnRW50ZXInKSB7XG4gICAgICAgICAgICAgICAgc2VjdGlvbiA9IGVkaXRvci5zZWN0aW9uQnlDaGlsZE5vZGUoZS50YXJnZXQpO1xuICAgICAgICAgICAgICAgIGhhbmRsZUVudGVyS2V5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaGFuZGxlU2hpZnRFbnRlcihlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHNlY3Rpb24gJiYgc2VjdGlvbi5vbktleUVudGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWN0aW9uLm9uS2V5RW50ZXIoZSwgZWRpdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5jYXJldC5pbnNlcnRMaW5lQnJlYWsoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKGUuaXNDb21wb3NpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZS50YXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgQ29tcG9zaXRpb25FdmVudCgnY29tcG9zaXRpb25lbmQnKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBoYW5kbGVFbnRlcktleSgpIH0sIDEwMCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRW50ZXJLZXkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGUua2V5ID09PSAnVGFiJykge1xuICAgICAgICAgICAgICAgIHNlY3Rpb24gPSBlZGl0b3Iuc2VjdGlvbkJ5Q2hpbGROb2RlKGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBpZihzZWN0aW9uICYmIHNlY3Rpb24ub25LZXlUYWIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VjdGlvbi5vbktleVRhYihlLCBlZGl0b3IpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZihzZWN0aW9uICYmIHNlY3Rpb24ubmV4dFNpYmxpbmcgJiYgIWUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnBsYWNlQ2FyZXRJbnRvU2VjdGlvbihzZWN0aW9uLm5leHRTaWJsaW5nKVxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKHNlY3Rpb24gJiYgc2VjdGlvbi5wcmV2aW91c1NpYmxpbmcgJiYgZS5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgICAgICBlZGl0b3IucGxhY2VDYXJldEludG9TZWN0aW9uKHNlY3Rpb24ucHJldmlvdXNTaWJsaW5nKVxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihlLmtleSA9PT0gJyAnICYmICEoZS5pc0NvbXBvc2luZyB8fCBlLmtleUNvZGUgPT09IDIyOSkpIHtcbiAgICAgICAgICAgICAgICBzZWN0aW9uID0gZWRpdG9yLnNlY3Rpb25CeUNoaWxkTm9kZShlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgaWYoc2VjdGlvbiAmJiAhc2VsZi5lZGl0b3IuY2FyZXQuaXNQcmVjZWRpbmdDaGFyYWN0ZXJXaGl0ZXNwYWNlKHNlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKCdpbnNlcnRUZXh0JywgZmFsc2UsIHNlbGYuZWRpdG9yLmh0bWxSYXpvci50ZW1wcm9hcnlQcnVuZVByb3RlY3RlZFdoaXRlc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2RvIG5vdCBoYW5kbGUgdGhlIGtleXMgYmVsb3cgaWYgQ01EIG9yIENvbnRyb2xcbiAgICAgICAgICAgIC8vaXMgbm90IHByZXNzZWQgYXQgdGhlIHNhbWUgdGltZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoZS5rZXkgPT09ICdFbnRlcicpICAgICAgICAgICAgIHsgc2VsZi5oYW5kbGVTaGlmdEVudGVyKGUpOyB9XG4gICAgICAgIGVsc2UgaWYoZS5rZXkgPT09ICdBcnJvd1VwJykgICAgICB7IGVkaXRvci5tb3ZlRm9jdXNlZFNlY3Rpb25VcCgpOyBlLnByZXZlbnREZWZhdWx0KCk7IH1cbiAgICAgICAgZWxzZSBpZihlLmtleSA9PT0gJ0Fycm93RG93bicpICAgIHsgZWRpdG9yLm1vdmVGb2N1c2VkU2VjdGlvbkRvd24oKTsgZS5wcmV2ZW50RGVmYXVsdCgpOyB9XG4gICAgICAgIGVsc2UgaWYoZS5rZXkgPT09ICdpJykgICAgICAgICAgICB7IGVkaXRvci50ZXh0RW5yaWNobWVudENvbnRyb2wuc2hvdyh0cnVlKTsgZS5wcmV2ZW50RGVmYXVsdCgpOyB9XG4gICAgICAgIGVsc2UgaWYoZS5rZXkgPT09ICdhJykgICAgICAgICAgICB7IHNlbGYuaGFuZGxlQ21kQShlKTsgfVxuICAgICAgICBlbHNlIGlmKGUua2V5ID09PSAneicpICAgICAgICAgICAgeyBlZGl0b3IudW5kbygpOyBlLnByZXZlbnREZWZhdWx0KCk7IH1cbiAgICAgICAgZWxzZSBpZihlLmtleSA9PT0gJ3knKSAgICAgICAgICAgIHsgZWRpdG9yLnJlZG8oKTsgZS5wcmV2ZW50RGVmYXVsdCgpOyB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VjdGlvbiA9IGVkaXRvci5zZWN0aW9uQnlDaGlsZE5vZGUoZS50YXJnZXQpO1xuICAgICAgICAgICAgaWYoc2VjdGlvbiAmJiBzZWN0aW9uLm9uS2V5Q29tYmluYXRpb24pIHtcbiAgICAgICAgICAgICAgICBzZWN0aW9uLm9uS2V5Q29tYmluYXRpb24oZSwgZWRpdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xufVxuXG5LZXlQcmVzc0hhbmRsZXIucHJvdG90eXBlID0ge1xuXG4gICAgaGFuZGxlU2hpZnRFbnRlcjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIHNlY3Rpb24gPSB0aGlzLmVkaXRvci5zZWN0aW9uQnlDaGlsZE5vZGUoZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgdGhpcy5lZGl0b3IuYWRkTmV3U2VjdGlvbk5leHRUbyhzZWN0aW9uKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuXG4gICAgaGFuZGxlQmFja3NwYWNlOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpLCBzMSwgczI7XG5cbiAgICAgICAgaWYoIXNlbCkgcmV0dXJuOyAvL25vIGNhcmV0IHBvc2l0aW9uZWQsIG5vIGRlbGV0aW9uIHJlcXVpcmVkXG5cbiAgICAgICAgaWYodGhpcy5lZGl0b3IuY2FyZXQuaXNDb2xsYXBzZWRBbmRQb3NpdGlvbmVkQXRUaGVCZWdpbm5pbmdPZih0aGlzLmVkaXRvci5mb2N1c2VkU2VjdGlvbigpKSkge1xuICAgICAgICAgICAgczIgPSB0aGlzLmVkaXRvci5zZWN0aW9uQnlDaGlsZE5vZGUoc2VsLmFuY2hvck5vZGUpO1xuICAgICAgICAgICAgczEgPSBzMi5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICB0aGlzLmVkaXRvci5tZXJnZVNlY3Rpb25zKHMxLCBzMik7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5lZGl0b3IuYXJlTXVsdGlwbGVTZWN0aW9uc1NlbGVjdGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLmRlbGV0ZU5vbkNvbGxhcHNlZFNlbGVjdGlvbkNvbnRlbnQoc2VsKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmb3Igc29tZSByZWFzb24gdGhlcmUgaXMgYSBlZGdlIGNhc2UgaW4gd2hpY2ggdGhlIGJhY2tzcGFjZSBkb2Vzbid0XG4gICAgICAgIC8vIHRyaWdnZXIgYSBzZWxlY3Rpb24gY2hhbmdlIGFuZCBzbyB0aGUgY29udHJvbGxzIHdpbGwgbm90IGJlZW4gaGlkZGVuXG4gICAgICAgIC8vIGJ5IHRoZSBoYW5kbGVyIGludGVkZWQgdG8gZG8gdGhpcy5cbiAgICAgICAgdGhpcy5lZGl0b3IudGV4dEVucmljaG1lbnRDb250cm9sLmhpZGUoKTtcbiAgICB9LFxuXG4gICAgaGFuZGxlQ21kQTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIGVsVGFnID0gZXZlbnQudGFyZ2V0ICYmIGV2ZW50LnRhcmdldC50YWdOYW1lO1xuICAgICAgICB2YXIgbmF0aXZlRXZlbnRIYW5kbGluZ1RhZyA9IFsnVEVYVEFSRUEnLCAnSU5QVVQnXVxuXG4gICAgICAgIGlmKCFuYXRpdmVFdmVudEhhbmRsaW5nVGFnLmluY2x1ZGVzKGVsVGFnKSkge1xuICAgICAgICAgICAgdGhpcy5lZGl0b3Iuc2VsZWN0RXZlcnl0aGluZygpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBLZXlQcmVzc0hhbmRsZXI7XG4iLCJ2YXIgdXVpZCA9IHJlcXVpcmUoJ3V1aWQvdjEnKTtcbnZhciBsb29rdXBSZWZzID0gcmVxdWlyZSgnLi4vLi4vbGliL2xvb2t1cF9yZWZzJyk7XG52YXIgbG9va3VwVVJMID0gcmVxdWlyZSgnLi4vLi4vbGliL2xvb2t1cF9yZWZzL2xvb2t1cF9ieV91cmwnKTtcbnZhciB0aHJvdHRsZSA9IHJlcXVpcmUoJy4uLy4uL2xpYi90aHJvdHRsZS90aHJvdHRsZScpO1xuXG52YXIgUmVmZXJlbmNlID0gZnVuY3Rpb24oc3RvcmUsIGVkaXRvcikge1xuICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcbiAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbn1cblxuUmVmZXJlbmNlLnByb3RvdHlwZSA9IHtcblxuICAgIGFkZFJlZmVyZW5jZURhdGE6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdGhpcy5zdG9yZS5hZGRSZWZlcmVuY2VEYXRhKGRhdGEpO1xuICAgIH0sXG5cbiAgICBzdG9yZUV4dGVybmFsUmVmRGF0YTogZnVuY3Rpb24oaWQsIGF0dHIpIHtcbiAgICAgICAgdGhpcy5zdG9yZS5zZXQoaWQsIGF0dHIpO1xuICAgICAgICB0aGlzLmVkaXRvci5yZWZlcmVuY2VJbnNlcnRlZFN1YnNjcmliZXJzLmZvckVhY2goKGNiKSA9PiB7XG4gICAgICAgICAgICBjYihpZCwgYXR0cik7XG4gICAgICAgIH0pXG4gICAgfSxcblxuICAgIGdldEV4dGVybmFsUmVmRGF0YTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmUuZ2V0KGlkKTtcbiAgICB9LFxuXG4gICAgZ2V0QWxsRXh0ZXJuYWxSZWZzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmUuYWxsKHRydWUpO1xuICAgIH0sXG5cbiAgICB1cGRhdGVSZWZFbGVtZW50OiBmdW5jdGlvbihyZWYpIHtcbiAgICAgICAgaWYocmVmLmdldEF0dHJpYnV0ZSgnZGF0YS1leHRlcm5hbCcpICE9PSAndHJ1ZScpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW50ZXJuYWxSZWZFbGVtZW50KHJlZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUV4dGVybmFsUmVmRWxlbWVudChyZWYpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIEFyZ3VtZW50OiBBIERPTSBFbGVtZW50IHdoaWNoIGlzIGEgY2xpbGQgZWxlbWVudCBvZiB0aGUgZWRpdG9yJ3MgY29udGVudFxuICAgIC8vIGVsZW1lbnQuIFRoZSBlbGVtZW50IHNob3VsZCBoYXZlIHRoZSBcImRhdGEtcmVmXCIgYXR0cmlidXRlIHJlcHJlc2VudGluZyB0aGUgaWRcbiAgICAvLyBvZiBhbiBleHRlcm5hbCByZWZlcmVuY2UgKGV4dGVybmFsIHJlZmVyZW5jZXMgYXJlIGJvb2tzLCBwYXBlcnMpLlxuICAgIC8vIFRoZSBmdW5jdGlvbiB3aWxsIHVwZGF0ZSB0aGUgaW5uZXJIVE1MIG9mIHRoZSBwYXNzZWQgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAgdXBkYXRlRXh0ZXJuYWxSZWZFbGVtZW50OiBmdW5jdGlvbihyZWYpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCB0bXBDb250ZW50LCByZWZrZXksIHJlZmVyZW5jZWUgPSB0aGlzLmdldEV4dGVybmFsUmVmRGF0YShyZWYuZ2V0QXR0cmlidXRlKCdkYXRhLXJlZicpKTtcblxuICAgICAgICBpZighcmVmZXJlbmNlZSkge1xuICAgICAgICAgICAgcmVmLmNsYXNzTGlzdC5hZGQoJ3dhcm5pbmcnKTtcbiAgICAgICAgICAgIHJlZi5pbm5lckhUTUwgPSAnWzxpPm5vdCBmb3VuZDwvaT5dJztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZmtleSA9IHJlZmVyZW5jZWUuYXV0aG9yLnNwbGl0KCcgJykucmVkdWNlKGZ1bmN0aW9uKGEsIGUpIHtyZXR1cm4gYSArIChlWzBdIHx8ICcnKX0sICcnKTtcbiAgICAgICAgcmVma2V5ICs9ICctJztcbiAgICAgICAgcmVma2V5ICs9IHJlZmVyZW5jZWUudGl0bGUuc3BsaXQoJyAnKS5yZWR1Y2UoZnVuY3Rpb24oYSwgZSkge3JldHVybiBhICsgKGVbMF0gfHwgJycpfSwgJycpO1xuICAgICAgICByZWZrZXkgKz0gJy0nO1xuICAgICAgICByZWZrZXkgKz0gcmVmZXJlbmNlZS55ZWFyO1xuXG4gICAgICAgIHRtcENvbnRlbnQgPSAnWzxpPicgKyByZWZrZXkgKyAnPC9pPl0nO1xuXG4gICAgICAgIHJlZi5vbmNsaWNrID0gZnVuY3Rpb24oKSB7c2VsZi5zaG93RWRpdEV4dGVybmFsUmVmRGlhbG9nKHRoaXMpfTtcblxuICAgICAgICBpZihyZWZlcmVuY2VlLmF1dGhvci50cmltKCkgPT09ICcnIHx8XG4gICAgICAgICAgIHJlZmVyZW5jZWUudGl0bGUudHJpbSgpID09PSAnJykge1xuICAgICAgICAgICAgcmVmLmNsYXNzTGlzdC5hZGQoJ3dhcm5pbmcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHJlZi5pbm5lckhUTUwgIT09IHRtcENvbnRlbnQpIHtcbiAgICAgICAgICAgIHJlZi5pbm5lckhUTUwgPSB0bXBDb250ZW50O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIEFjY29yZGluZyB0byB1cGRhdGVFeHRlcm5hbFJlZkVsZW1lbnQgYnV0IGZvciBpbnRlcm5hbCByZWZzLCBsaWtlIHRhYmxlcyxcbiAgICAvLyBmaWd1cmVzLCBzZWN0aW9uc1xuICAgIHVwZGF0ZUludGVybmFsUmVmRWxlbWVudDogZnVuY3Rpb24ocmVmKSB7XG4gICAgICAgIHZhciByZWZlcmVuY2VlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocmVmLmdldEF0dHJpYnV0ZSgnZGF0YS1yZWYnKSksXG4gICAgICAgICAgICB0bXBDb250ZW50LCBpbmRleFByZWZpeCA9ICcnLCBhbGxTZWxlY3RvcjtcblxuICAgICAgICBpZihyZWZlcmVuY2VlKSB7XG4gICAgICAgICAgICBhbGxTZWxlY3RvciA9IHJlZmVyZW5jZWUudGFnTmFtZTtcblxuICAgICAgICAgICAgaWYocmVmZXJlbmNlZS50YWdOYW1lID09PSAnRklHVVJFJyB8fCByZWZlcmVuY2VlLnRhZ05hbWUgPT09ICdNRVJNQUlEJykge1xuICAgICAgICAgICAgICAgIGFsbFNlbGVjdG9yID0gJ0ZJR1VSRSwgTUVSTUFJRCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHJlZmVyZW5jZWUudGFnTmFtZSA9PSAnUFJFJykge1xuICAgICAgICAgICAgICAgIGFsbFNlbGVjdG9yID0gJ3ByZS5jb2RlJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVmZXJlbmNlZUluZGV4ID0gdGhpcy5lZGl0b3IuY29udGVudEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChhbGxTZWxlY3RvcikuaW5kZXhPZihyZWZlcmVuY2VlKTtcblxuICAgICAgICAgICAgaWYocmVmZXJlbmNlZS50YWdOYW1lID09PSAnRklHVVJFJykge1xuICAgICAgICAgICAgICAgIGluZGV4UHJlZml4ID0gJ2ZpZy0nICsgKHJlZmVyZW5jZWVJbmRleCsxKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZihyZWZlcmVuY2VlLnRhZ05hbWUgPT09ICdUQUJMRScpIHtcbiAgICAgICAgICAgICAgICBpbmRleFByZWZpeCA9ICd0YWJsZS0nICsgKHJlZmVyZW5jZWVJbmRleCsxKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZihyZWZlcmVuY2VlLnRhZ05hbWUgPT09ICdQUkUnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXhQcmVmaXggPSAnbGlzdGluZy0nICsgKHJlZmVyZW5jZWVJbmRleCsxKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZihyZWZlcmVuY2VlLmNsYXNzTGlzdC5jb250YWlucygnZm9ybXVsYScpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXhQcmVmaXggPSAnZXEtJyArIChyZWZlcmVuY2VlSW5kZXgrMSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYocmVmZXJlbmNlZS5jbGFzc0xpc3QuY29udGFpbnMoJ21lcm1haWQnKSkge1xuICAgICAgICAgICAgICAgIGluZGV4UHJlZml4ID0gJ2ZpZy0nICsgKHJlZmVyZW5jZWVJbmRleCsxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYocmVmZXJlbmNlZS50YWdOYW1lID09PSAnSDInIHx8IHJlZmVyZW5jZWUudGFnTmFtZSA9PT0gJ0gzJyB8fCByZWZlcmVuY2VlLnRhZ05hbWUgPT09ICdINCcgfHwgcmVmZXJlbmNlZS50YWdOYW1lID09PSAnSDUnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXhQcmVmaXggPSAnc2VjdGlvbjogJyArIHJlZmVyZW5jZWUuaW5uZXJIVE1MO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0bXBDb250ZW50ID0gJ1s8aT48YSBocmVmPVwiIycgKyByZWZlcmVuY2VlLmlkICsgJ1wiPicgKyBpbmRleFByZWZpeCArICc8L2E+PC9pPl0nO1xuXG4gICAgICAgICAgICBpZihyZWYuaW5uZXJIVE1MICE9PSB0bXBDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgcmVmLmlubmVySFRNTCA9IHRtcENvbnRlbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlZi5jbGFzc0xpc3QucmVtb3ZlKCd3YXJuaW5nJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWYuaW5uZXJIVE1MID0gJ1tyZWYgbm90IGZvdW5kXSc7XG4gICAgICAgICAgICByZWYuY2xhc3NMaXN0LmFkZCgnd2FybmluZycpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldFJlZkNhcHRpb25IVE1MOiBmdW5jdGlvbihyZWZlcmVuY2VFbCkge1xuICAgICAgICB2YXIgcmVmSWQgPSByZWZlcmVuY2VFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmVmJyk7XG4gICAgICAgIGlmKHJlZmVyZW5jZUVsLmdldEF0dHJpYnV0ZSgnZGF0YS1leHRlcm5hbCcpID09PSAndHJ1ZScpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEV4dGVybmFsUmVmQ2FwdGlvbkhUTUwocmVmSWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW50ZXJuYWxSZWZDYXB0aW9uSFRNTChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChyZWZJZCkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldFZhbHVlc0ZvckNyb3NzUmVmZXJlbmNlU2VsZWN0Qm94OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICAgICAgaW50ZXJuYWxzID0gdGhpcy5lZGl0b3IuY29udGVudEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnZmlndXJlLCB0YWJsZSwgaDIsIGgzLCBoNCwgaDUsIHByZS5jb2RlLCAuZm9ybXVsYSwgLm1lcm1haWQnKTtcblxuICAgICAgICBpbnRlcm5hbHMgPSBpbnRlcm5hbHMuZmlsdGVyKGZ1bmN0aW9uKGludCkge1xuICAgICAgICAgICAgaWYoaW50LnRhZ05hbWUgPT09ICdGSUdVUkUnICYmICFpbnQucXVlcnlTZWxlY3RvcignZmlnY2FwdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihpbnQudGFnTmFtZSA9PT0gJ1RBQkxFJyAmJiAhaW50LnF1ZXJ5U2VsZWN0b3IoJ2NhcHRpb24nKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoaW50LnRhZ05hbWUgPT09ICdQUkUnICYmICFpbnQucXVlcnlTZWxlY3RvcignY2FwdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihpbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdmb3JtdWxhJykgJiYgIWludC5xdWVyeVNlbGVjdG9yKCdjYXB0aW9uJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGludC5jbGFzc0xpc3QuY29udGFpbnMoJ21lcm1haWQnKSAmJiAhaW50LnF1ZXJ5U2VsZWN0b3IoJ2NhcHRpb24nKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPGludGVybmFscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goW2ludGVybmFsc1tpXS5pZCwgdGhpcy5nZXRJbnRlcm5hbFJlZkNhcHRpb25IVE1MKGludGVybmFsc1tpXSldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGdldFZhbHVlc0ZvckV4aXN0aW5nUmVmZXJlbmNlU2VsZWN0Qm94OiBhc3luYyBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICAgICAgYWxsUmVmcyA9IGF3YWl0IHRoaXMuc3RvcmUuYWxsQXN5bmModHJ1ZSksXG4gICAgICAgICAgICBleHRlcm5hbHMgPSBPYmplY3Qua2V5cyhhbGxSZWZzKTtcblxuICAgICAgICBmb3IodmFyIGo9MDsgajxleHRlcm5hbHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFtleHRlcm5hbHNbal0sIHRoaXMuZ2V0RXh0ZXJuYWxSZWZDYXB0aW9uSFRNTChleHRlcm5hbHNbal0sIGFsbFJlZnMpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhcmVFeGlzdGluZ1JlZmVyZW5jZXNBdmFpbGFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYWxsUmVmcyA9IHRoaXMuZ2V0QWxsRXh0ZXJuYWxSZWZzKCk7XG5cbiAgICAgICAgcmV0dXJuIGFsbFJlZnMgJiYgT2JqZWN0LmtleXMoYWxsUmVmcykubGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvLyByZXR1cm5zIHRoZSBjYXB0aW9uIHRvIGRpc3BsYXkgaW4gdGhlIHJlZmVyZW5jZSBzZWxlY3QgYm94LlxuICAgIGdldEludGVybmFsUmVmQ2FwdGlvbkhUTUw6IGZ1bmN0aW9uKHJlZmVyZWVFbCkge1xuICAgICAgICBpZighcmVmZXJlZUVsKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1tyZWYgbm90IGZvdW5kXSc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG1wQ2FwdGlvbixcbiAgICAgICAgICAgIGFsbFNlbGVjdG9yID0gcmVmZXJlZUVsLnRhZ05hbWU7XG5cbiAgICAgICAgaWYocmVmZXJlZUVsLnRhZ05hbWUgPT09ICdGSUdVUkUnIHx8IHJlZmVyZWVFbC50YWdOYW1lID09PSAgJ01FUk1BSUQnKSB7XG4gICAgICAgICAgICBhbGxTZWxlY3RvciA9ICdGSUdVUkUsIE1FUk1BSUQnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYocmVmZXJlZUVsLnRhZ05hbWUgPT09ICdQUkUnKSB7XG4gICAgICAgICAgICBhbGxTZWxlY3RvciA9ICdwcmUuY29kZSc7XG4gICAgICAgIH1cblxuICAgICAgICByZWZlcmVuY2VlSW5kZXggPSB0aGlzLmVkaXRvci5jb250ZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKGFsbFNlbGVjdG9yKS5pbmRleE9mKHJlZmVyZWVFbCk7XG5cbiAgICAgICAgaWYocmVmZXJlZUVsLnRhZ05hbWUgPT09ICdGSUdVUkUnKSB7XG4gICAgICAgICAgICB0bXBDYXB0aW9uID0gcmVmZXJlZUVsLnF1ZXJ5U2VsZWN0b3IoJ2ZpZ2NhcHRpb24nKS5pbm5lckhUTUw7XG4gICAgICAgICAgICByZXR1cm4gJzxiPkltYWdlPC9iPiAnICsgKHJlZmVyZW5jZWVJbmRleCsxKSArICc6ICcgKyB0bXBDYXB0aW9uO1xuICAgICAgICB9IGVsc2UgaWYocmVmZXJlZUVsLnRhZ05hbWUgPT09ICdUQUJMRScpIHtcbiAgICAgICAgICAgIHRtcENhcHRpb24gPSByZWZlcmVlRWwucXVlcnlTZWxlY3RvcignY2FwdGlvbicpLmlubmVySFRNTDtcbiAgICAgICAgICAgIHJldHVybiAnPGI+VGFibGU8L2I+ICcgKyAocmVmZXJlbmNlZUluZGV4KzEpICsgJzogJyArIHRtcENhcHRpb247XG4gICAgICAgIH0gZWxzZSBpZihyZWZlcmVlRWwudGFnTmFtZSA9PT0gJ0gyJyB8fCByZWZlcmVlRWwudGFnTmFtZSA9PT0gJ0gzJyB8fCByZWZlcmVlRWwudGFnTmFtZSA9PT0gJ0g0JyB8fCByZWZlcmVlRWwudGFnTmFtZSA9PT0gJ0g1Jykge1xuICAgICAgICAgICAgcmV0dXJuICc8Yj5TZWN0aW9uPC9iPjogJyArIHJlZmVyZWVFbC5pbm5lckhUTUw7XG4gICAgICAgIH0gZWxzZSBpZihyZWZlcmVlRWwudGFnTmFtZSA9PT0gJ1BSRScpIHtcbiAgICAgICAgICAgIHRtcENhcHRpb24gPSByZWZlcmVlRWwucXVlcnlTZWxlY3RvcignY2FwdGlvbicpLmlubmVySFRNTDtcbiAgICAgICAgICAgIHJldHVybiAnPGI+TGlzdGluZzwvYj4gJyArIChyZWZlcmVuY2VlSW5kZXgrMSkgKyAnOiAnICsgdG1wQ2FwdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmKHJlZmVyZWVFbC5jbGFzc0xpc3QuY29udGFpbnMoJ2Zvcm11bGEnKSkge1xuICAgICAgICAgICAgdG1wQ2FwdGlvbiA9IHJlZmVyZWVFbC5xdWVyeVNlbGVjdG9yKCdjYXB0aW9uJykuaW5uZXJIVE1MO1xuICAgICAgICAgICAgcmV0dXJuICc8Yj5FcXVhdGlvbjwvYj4gJyArIChyZWZlcmVuY2VlSW5kZXgrMSkgKyAnOiAnICsgdG1wQ2FwdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmKHJlZmVyZWVFbC5jbGFzc0xpc3QuY29udGFpbnMoJ21lcm1haWQnKSkge1xuICAgICAgICAgICAgdG1wQ2FwdGlvbiA9IHJlZmVyZWVFbC5xdWVyeVNlbGVjdG9yKCdjYXB0aW9uJykuaW5uZXJIVE1MO1xuICAgICAgICAgICAgcmV0dXJuICc8Yj5JbWFnZTwvYj4gJyArIChyZWZlcmVuY2VlSW5kZXgrMSkgKyAnOiAnICsgdG1wQ2FwdGlvbjtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyByZXR1cm5zIHRoZSBjYXB0aW9uIHRvIGRpc3BsYXkgaW4gdGhlIHJlZmVyZW5jZSBzZWxlY3QgYm94LlxuICAgIGdldEV4dGVybmFsUmVmQ2FwdGlvbkhUTUw6IGZ1bmN0aW9uKHJlZmVyZWVJZCwgYWxsUmVmcykge1xuICAgICAgICB2YXIgcmVmID0gKGFsbFJlZnMgfHwgdGhpcy5nZXRBbGxFeHRlcm5hbFJlZnMoKSlbcmVmZXJlZUlkXTtcbiAgICAgICAgaWYoIXJlZikgeyByZXR1cm4gJycgfVxuICAgICAgICByZXR1cm4gW3JlZi5hdXRob3IsIHJlZi50aXRsZSwgKHJlZi5wdWJsaXNoZXIgfHwgcmVmLmpvdXJuYWwpLCByZWYueWVhcl0uZmlsdGVyKGZ1bmN0aW9uIChmKSB7IHJldHVybiBmICE9PSAnJyAmJiBmIH0pLmpvaW4oJyAtICcpO1xuICAgIH0sXG5cbiAgICBpbnNlcnRJbnRlcm5hbFJlZmVyZW5jZTogZnVuY3Rpb24oZm9ybURhdGEpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZCgncmVmZXJlbmNlJyk7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdkYXRhLXJlZicsIGZvcm1EYXRhLnJlZik7XG5cbiAgICAgICAgaWYodGhpcy5nZXRFeHRlcm5hbFJlZkRhdGEoZm9ybURhdGEucmVmKSkge1xuICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtZXh0ZXJuYWwnLCAndHJ1ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5lZGl0b3IuY2FyZXQuaW5zZXJ0Tm9kZShub2RlKTtcbiAgICB9LFxuXG4gICAgaW5zZXJ0RXh0ZXJuYWxSZWZlcmVuY2U6IGZ1bmN0aW9uKGZvcm1EYXRhKSB7XG4gICAgICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpLFxuICAgICAgICAgICAgcmVmSWQgPSB1dWlkKCksXG4gICAgICAgICAgICBzZWxmID0gdGhpcztcblxuICAgICAgICBub2RlLmNsYXNzTGlzdC5hZGQoJ3JlZmVyZW5jZScpO1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJywgZmFsc2UpO1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnZGF0YS1leHRlcm5hbCcsICd0cnVlJyk7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdkYXRhLXJlZicsIHJlZklkKTtcbiAgICAgICAgbm9kZS5vbmNsaWNrID0gZnVuY3Rpb24oKSB7c2VsZi5zaG93RWRpdEV4dGVybmFsUmVmRGlhbG9nKHRoaXMpfTtcbiAgICAgICAgdGhpcy5zdG9yZUV4dGVybmFsUmVmRGF0YShyZWZJZCwgZm9ybURhdGEpO1xuICAgICAgICB0aGlzLmVkaXRvci5jYXJldC5pbnNlcnROb2RlKG5vZGUpO1xuICAgIH0sXG5cbiAgICBzaG93RWRpdEV4dGVybmFsUmVmRGlhbG9nOiBmdW5jdGlvbihyZWZOb2RlKSB7XG4gICAgICAgIHZhciByZWZJZCA9IHJlZk5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLXJlZicpLFxuICAgICAgICAgICAgcmVmID0gdGhpcy5nZXRFeHRlcm5hbFJlZkRhdGEocmVmSWQpLFxuICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgaWYoIXJlZikgeyByZXR1cm4gfVxuXG4gICAgICAgIHNlbGYuZWRpdG9yLnVuZm9jdXNTZWN0aW9uKCk7XG5cbiAgICAgICAgc2VsZi5lZGl0b3IuZGlzcGxheU1vZGFsKHNlbGYuZ2V0RXh0ZXJuYWxSZWZEaWFsb2dBdHRyaWJ1dGVzKHJlZiwgcmVmSWQpLCBmdW5jdGlvbihmb3JtRGF0YSkge1xuICAgICAgICAgICAgdmFyIHNlY3Rpb24gPSBzZWxmLmVkaXRvci5zZWN0aW9uQnlDaGlsZE5vZGUocmVmTm9kZSk7XG4gICAgICAgICAgICBpZihzZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgc2VjdGlvbi5mb3JjZVVwZGF0ZU9uSW5wdXRQcm9jZXNzc2luZ0VuYWJsZW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLnN0b3JlRXh0ZXJuYWxSZWZEYXRhKHJlZklkLCBmb3JtRGF0YSk7XG4gICAgICAgICAgICBzZWxmLmVkaXRvci51bmZyZWV6ZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgc2VsZi5lZGl0b3IudGV4dEVucmljaG1lbnRDb250cm9sLmhpZGUoKTtcblxuICAgICAgICAgICAgc2VsZi5lZGl0b3IucmVmZXJlbmNlLnVwZGF0ZVJlZkVsZW1lbnQocmVmTm9kZSk7XG4gICAgICAgICAgICBzZWxmLmVkaXRvci51bmZvY3VzU2VjdGlvbigpO1xuICAgICAgICAgICAgc2VsZi5lZGl0b3IuY2FyZXQuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuZWRpdG9yLnNlY3Rpb25UeXBlU2VsZWN0b3IuaGlkZSgpO1xuICAgICAgICAgICAgfSwgNTApXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBnZXRFeHRlcm5hbFJlZkRpYWxvZ0F0dHJpYnV0ZXM6IGZ1bmN0aW9uKGRhdGFSZWNvcmQsIHJlZklkKSB7XG4gICAgICAgIGRhdGFSZWNvcmQgPSBkYXRhUmVjb3JkIHx8IHt9O1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB2YXIgcmVmZXJlbmNlVHlwZXMgPSB7XG4gICAgICAgICAgICAnQXJ0aWNsZSc6IHtcbiAgICAgICAgICAgICAgICByZXF1aXJlZDogWydhdXRob3InLCAndGl0bGUnLCAnam91cm5hbCcsICd5ZWFyJ10sXG4gICAgICAgICAgICAgICAgb3B0aW9uYWw6IFsndm9sdW1lJywgJ251bWJlcicsICdwYWdlcycsICdtb250aCcsICdzdWJ0aXRsZSddXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ0Jvb2snOiB7XG4gICAgICAgICAgICAgICAgcmVxdWlyZWQ6IFsnYXV0aG9yJywgJ3RpdGxlJywgJ3B1Ymxpc2hlcicsICd5ZWFyJ10sXG4gICAgICAgICAgICAgICAgb3B0aW9uYWw6IFsnZWRpdG9yJywgJ3ZvbHVtZScsICdudW1iZXInLCAnc2VyaWVzJywgJ2VkaXRpb24nLCAnbW9udGgnLCAnc3VidGl0bGUnXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdDb25mZXJlbmNlL0lucHJvY2VlZGluZ3MnOiB7XG4gICAgICAgICAgICAgICAgcmVxdWlyZWQ6IFsnYXV0aG9yJywgJ3RpdGxlJywgJ2Jvb2t0aXRsZScsICd5ZWFyJ10sXG4gICAgICAgICAgICAgICAgb3B0aW9uYWw6IFsnZWRpdG9yJywgJ3ZvbHVtZScsICdudW1iZXInLCAnc2VyaWVzJywgJ3BhZ2VzJywgJ21vbnRoJywgJ29yZ2FuaXphdGlvbiddXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ0luYm9vayc6IHtcbiAgICAgICAgICAgICAgICByZXF1aXJlZDogWyd0aXRsZScsICdwdWJsaXNoZXInLCAneWVhciddLFxuICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBbJ2F1dGhvcicsICdlZGl0b3InLCAnY2hhcHRlcicsICdwYWdlcycsICdzdWJ0aXRsZSddXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ01hbnVhbCc6IHtcbiAgICAgICAgICAgICAgICByZXF1aXJlZDogWyd0aXRsZSddLFxuICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBbJ2F1dGhvcicsICdvcmdhbml6YXRpb24nLCAnZWRpdGlvbicsICdtb250aCcsICd5ZWFyJywgJ3N1YnRpdGxlJ11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnTWFzdGVyc3RoZXNpcyc6IHtcbiAgICAgICAgICAgICAgICByZXF1aXJlZDogWydhdXRob3InLCAndGl0bGUnLCAnc2Nob29sJywgJ3llYXInXSxcbiAgICAgICAgICAgICAgICBvcHRpb25hbDogWydtb250aCcsICdzdWJ0aXRsZSddXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ1BoZHRoZXNpcyc6IHtcbiAgICAgICAgICAgICAgICByZXF1aXJlZDogWydhdXRob3InLCAndGl0bGUnLCAnc2Nob29sJywgJ3llYXInXSxcbiAgICAgICAgICAgICAgICBvcHRpb25hbDogWydtb250aCcsICdzdWJ0aXRsZSddXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ1Byb2NlZWRpbmdzJzoge1xuICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBbJ3RpdGxlJywgJ3llYXInXSxcbiAgICAgICAgICAgICAgICBvcHRpb25hbDogWydlZGl0b3InLCAndm9sdW1lJywgJ251bWJlcicsICdzZXJpZXMnLCAnbW9udGgnLCAnb3JnYW5pemF0aW9uJywgJ3N1YnRpdGxlJ11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnVGVjaHJlcG9ydCc6IHtcbiAgICAgICAgICAgICAgICByZXF1aXJlZDogWydhdXRob3InLCAndGl0bGUnLCAnaW5zdGl0dXRpb24nLCAneWVhciddLFxuICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBbJ3R5cGUnLCAnbnVtYmVyJywgJ21vbnRoJywgJ3N1YnRpdGxlJ11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnV2Vic2l0ZSc6IHtcbiAgICAgICAgICAgICAgICByZXF1aXJlZDogWyd1cmwnXSxcbiAgICAgICAgICAgICAgICBvcHRpb25hbDogWydhdXRob3InLCAnZGF0ZScsICdtb250aCcsICd5ZWFyJywgJ3RpdGxlJ11cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhbGxvd2VkVHlwZVZhbHVlcyA9IE9iamVjdC5rZXlzKHJlZmVyZW5jZVR5cGVzKVxuICAgICAgICAgICAgLm1hcChydCA9PiBbXG4gICAgICAgICAgICAgICAgcnQsXG4gICAgICAgICAgICAgICAgcnQsXG4gICAgICAgICAgICAgICAgJ1R5cGU6ICcgKyBydFxuICAgICAgICAgICAgXSlcblxuICAgICAgICB2YXIgaGFuZGxlVXJsRmllbGRDaGFuZ2UgPSBhc3luYyBmdW5jdGlvbiAoZm9ybURhdGEsIGRGcm9tLCB0cmlnZ2VyRWxlbWVudCwgYWxsRXhpc3RpbmdSZWZzLCB1cmwpIHtcblxuICAgICAgICAgICAgdmFyIHVybCA9IHVybCB8fCBmb3JtRGF0YS51cmw7XG4gICAgICAgICAgICB2YXIgZmllbGRzID0gWyd1cmwnLCAnYXV0aG9yJywgJ3RpdGxlJywgJ3llYXInLCAnbW9udGgnXVxuXG4gICAgICAgICAgICBpZihsb29rdXBVUkwuaXNWYWxpZElEKHVybCkpIHtcbiAgICAgICAgICAgICAgICBmaWVsZHMuZm9yRWFjaChmaWVsZCA9PiBkRnJvbS5zZXRUb29sdGlwKGZpZWxkLCAnV2FpdCBmb3IgaXQgLi4uJywgJycsICd0b29sdGlwLWxvYWRpbmcnKSlcblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1cmxNZXRhID0gYXdhaXQgbG9va3VwVVJMLmZldGNoSlNPTih1cmwpO1xuXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHVybE1ldGEpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmaWVsZCA9IGRGcm9tLmZpZWxkcy5maW5kKGYgPT4gZi5uYW1lID09IGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihmaWVsZCAmJiBmaWVsZC5kb21FbGVtZW50ICYmIGZpZWxkLmRvbUVsZW1lbnQuc2V0VmFsdWUgJiYgZm9ybURhdGFbZmllbGQubmFtZV0gIT09IHVybE1ldGFba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkLmRvbUVsZW1lbnQuc2V0VmFsdWUodXJsTWV0YVtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZHMuZm9yRWFjaChmaWVsZCA9PiBkRnJvbS5yZXNldFRvb2x0aXAoZmllbGQpKTtcbiAgICAgICAgICAgICAgICAgICAgZEZyb20ucmVzZXRUb29sdGlwKCdsb29rdXBJZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoYW5kbGVMb29rdXBJZEZpZWxkQ2hhbmdlID0gZnVuY3Rpb24oZm9ybURhdGEsIGRGcm9tLCB0cmlnZ2VyRWxlbWVudCwgYWxsRXhpc3RpbmdSZWZzKSB7XG4gICAgICAgICAgICBkRnJvbS5zZXRUb29sdGlwKCdsb29rdXBJZCcsICdXYWl0IGZvciBpdCAuLi4nLCAnJywgJ3Rvb2x0aXAtbG9hZGluZycpXG5cbiAgICAgICAgICAgIGNvbnN0IHNpbWlsYXJSZWYgPSBhbGxFeGlzdGluZ1JlZnMuZmluZChyZWYgPT4gKHJlZi5sb29rdXBJZCAmJiByZWYubG9va3VwSWQudHJpbSgpLnRvTG93ZXJDYXNlKCkgPT09IGZvcm1EYXRhLmxvb2t1cElkLnRyaW0oKS50b0xvd2VyQ2FzZSgpKSlcblxuICAgICAgICAgICAgaWYoZm9ybURhdGEubG9va3VwSWRcbiAgICAgICAgICAgICAgICAmJiBzaW1pbGFyUmVmXG4gICAgICAgICAgICAgICAgJiYgKCFyZWZJZCB8fCByZWZJZCAhPT0gc2ltaWxhclJlZi5pZCkpIHtcbiAgICAgICAgICAgICAgICBkRnJvbS5zZXRUb29sdGlwRXJyb3IoJ2xvb2t1cElkJywgJ1lvdSBhbHJlYWR5IHJlZmVyZW5jZWQgdGhpcyBkb2N1bWVudCBiZWZvcmUuIFlvdSBjYW4gZmluZCBpdCBpbiB0aGUgXCJGaW5kIFJlZmVyZW5jZVwiIHRhYiBvZiB0aGlzIGRpYWxvZy4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBlcnJvclRleHQgPSAnU29tZXRoaW5nIHdlbnQgd3JvbmcuIE1heWJlIHRoZSBwcm92aWRlZCBET0kgLyBJU0JOIC8gV2Vic2l0ZSBVUkwgLyBhclhpdiBJRCBkb2VzIG5vdCBleGlzdHM/JztcblxuICAgICAgICAgICAgbG9va3VwUmVmcy5mZXRjaEpTT04oZm9ybURhdGEubG9va3VwSWQpXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdlcnJvciB3aGVuIGZldGNoaW5nIHJlZiBkYXRhJywgZXJyKVxuICAgICAgICAgICAgICAgICAgICBpZihlcnIgaW5zdGFuY2VvZiBsb29rdXBSZWZzLmVycm9ycy5JbnZhbGlkSUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRGcm9tLnNldFRvb2x0aXBXYXJuaW5nKCdsb29rdXBJZCcsICdJdCBuZWVkcyB0byBiZSBhIHZhbGlkIERPSSBvciBJU0JOJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihlcnIgaW5zdGFuY2VvZiBsb29rdXBSZWZzLmVycm9ycy5FbXB0eUlEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkRnJvbS5yZXNldFRvb2x0aXAoJ2xvb2t1cElkJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihlcnIgaW5zdGFuY2VvZiBsb29rdXBSZWZzLmVycm9ycy5Ob3RGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZEZyb20uc2V0VG9vbHRpcEVycm9yKCdsb29rdXBJZCcsICdObyBkYXRhIGZvdW5kIGZvciB0aGUgZ2l2ZW4gRE9JIC8gSVNCTicpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZEZyb20uc2V0VG9vbHRpcEVycm9yKCdsb29rdXBJZCcsIGVycm9yVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkRnJvbS5zZXRUb29sdGlwKCdsb29rdXBJZCcsICdNb25zdGVyV3JpdGVyIGZpbGxlZCBvdXQgYWxsIHRoZSBpbmZvcm1hdGlvbiBpdCBjb3VsZCBmaW5kLiBZb3UgY2FuIHN0aWxsIGNvbXBsZXRlIG9yIGNoYW5nZSB0aGUgZGF0YSBiZWxvdy4nLCAnJiMxMDAwMzsnLCAndG9vbHRpcC1zdWNjZXNzJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGRhdGEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmaWVsZE5hbWUgPT4gZEZyb20uZmllbGRzLmZpbmQoZiA9PiBmLm5hbWUgPT0gZmllbGROYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZpZWxkID0+IGZpZWxkICYmIGZpZWxkLmRvbUVsZW1lbnQgJiYgZmllbGQuZG9tRWxlbWVudC5zZXRWYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaChmaWVsZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGZvcm1EYXRhW2ZpZWxkLm5hbWVdICE9PSBkYXRhW2ZpZWxkLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZC5kb21FbGVtZW50LnNldFZhbHVlKGRhdGFbZmllbGQubmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGV4ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZEZyb20uc2V0VG9vbHRpcEVycm9yKCdsb29rdXBJZCcsIGVycm9yVGV4dCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoYW5kbGVUaXRsZUZpZWxkQ2hhbmdlID0gZnVuY3Rpb24gKGZvcm1EYXRhLCBkRnJvbSwgdHJpZ2dlckVsZW1lbnQsIGFsbEV4aXN0aW5nUmVmcykge1xuICAgICAgICAgICAgY29uc3Qgc2ltaWxhclJlZiA9IGFsbEV4aXN0aW5nUmVmcy5maW5kKHJlZiA9PiAocmVmLnRpdGxlICYmIHJlZi50aXRsZS50cmltKCkudG9Mb3dlckNhc2UoKSA9PT0gZm9ybURhdGEudGl0bGUudHJpbSgpLnRvTG93ZXJDYXNlKCkpKVxuXG4gICAgICAgICAgICBpZihmb3JtRGF0YS50aXRsZVxuICAgICAgICAgICAgICAgICYmIHNpbWlsYXJSZWZcbiAgICAgICAgICAgICAgICAmJiAoIXJlZklkIHx8IHJlZklkICE9PSBzaW1pbGFyUmVmLmlkKSkge1xuICAgICAgICAgICAgICAgIGRGcm9tLnNldFRvb2x0aXBXYXJuaW5nKCd0aXRsZScsICdZb3UgYWxyZWFkeSByZWZlcmVuY2VkIGEgZG9jdW1lbnQgd2l0aCB0aGUgc2FtZSB0aXRsZS4gQ29uc2lkZXIgdG8gY2hvb3NlIGl0IGluIHRoZSBcIkZpbmQgUmVmZXJlbmNlXCIgdGFiIG9mIHRoaXMgZGlhbG9nLicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZEZyb20ucmVzZXRUb29sdGlwKCd0aXRsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9uRm9ybUNoYW5nZSA9IHRocm90dGxlKDEwMCwgZnVuY3Rpb24gKGZvcm1EYXRhLCBkRnJvbSwgdHJpZ2dlckVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmKCF0cmlnZ2VyRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGFsbEV4aXN0aW5nUmVmcyA9IE9iamVjdC52YWx1ZXMoc2VsZi5nZXRBbGxFeHRlcm5hbFJlZnMoKSk7XG5cbiAgICAgICAgICAgIGlmKHRyaWdnZXJFbGVtZW50Lm5hbWUgPT09ICdsb29rdXBJZCcpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVMb29rdXBJZEZpZWxkQ2hhbmdlKGZvcm1EYXRhLCBkRnJvbSwgdHJpZ2dlckVsZW1lbnQsIGFsbEV4aXN0aW5nUmVmcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYodHJpZ2dlckVsZW1lbnQubmFtZSA9PT0gJ3RpdGxlJykge1xuICAgICAgICAgICAgICAgIGhhbmRsZVRpdGxlRmllbGRDaGFuZ2UoZm9ybURhdGEsIGRGcm9tLCB0cmlnZ2VyRWxlbWVudCwgYWxsRXhpc3RpbmdSZWZzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZih0cmlnZ2VyRWxlbWVudC5uYW1lID09PSAndXJsJykge1xuICAgICAgICAgICAgICAgIGhhbmRsZVVybEZpZWxkQ2hhbmdlKGZvcm1EYXRhLCBkRnJvbSwgdHJpZ2dlckVsZW1lbnQsIGFsbEV4aXN0aW5nUmVmcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7bmFtZTogJ2xvb2t1cElkJywgZGlzcGxheU5hbWU6ICdBdXRvbWF0aWNhbGx5IEZldGNoIGFuZCBGaWxsIE91dCBJbmZvcm1hdGlvbiBCeTonLCB0b29sdGlwOiB7IHRleHQ6ICdJbnNlcnQgYSB2YWxpZCBET0ksIElTQk4sIGFyWGl2IElEIG9yIHRoZSBVUkwgb2YgYSB3ZWJzaXRlIHlvdSB3YW50IHRvIGNpdGUuIE1vbnN0ZXJXcml0ZXIgd2lsbCB0cnkgdG8gZmluZCBhbGwgdGhlIGluZm9ybWF0aW9uIG9uIHRoZSBpbnRlcm5ldCBmb3IgeW91LicsIGluSW5wdXQ6IHRydWUgfSwgYXV0b2NvbXBsZXRlOiAnb2ZmJywgcGxhY2Vob2xkZXI6ICdJU0JOIC8gRE9JIC8gYXJYaXYgSUQgLyBXZWJzaXRlIFVSTCcsIG9uRm9ybUNoYW5nZTogb25Gb3JtQ2hhbmdlIH0sXG4gICAgICAgICAgICB7bmFtZTogJ3R5cGUnLCBkaXNwbGF5TmFtZTogJ01hbnVhbGx5IFNwZWNpZnkgSW5mb3JtYXRpb246JywgZGVmYXVsdFZhbHVlOiAnQXJ0aWNsZScsIGFsbG93ZWRWYWx1ZXM6IGFsbG93ZWRUeXBlVmFsdWVzIH0sXG4gICAgICAgICAgICB7bmFtZTogJ3VybCcsIHBsYWNlaG9sZGVyOiAnV2Vic2l0ZSBVUkwnLCB0b29sdGlwOiAnVGhlIGFkZHJlc3Mgb2YgdGhlIHdlYnNpdGUuJ30sXG4gICAgICAgICAgICB7bmFtZTogJ2RhdGUnLCBwbGFjZWhvbGRlcjogJ0xvb2t1cCBEYXRlJywgdG9vbHRpcDogJ1RoZSBkYXRlIHdoZW4geW91IGFjY2Vzc2VkIHRoZSB3ZWJzaXRlLiBUaGlzIGlzIHVzYWxseSB0b2RheXMgZGF0ZS4nLCBkZWZhdWx0VmFsdWU6ICgpID0+IChuZXcgRGF0ZSgpKS5nZXRGdWxsWWVhcigpICsgJy0nICsgKChuZXcgRGF0ZSgpKS5nZXRNb250aCgpICsgMSkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpICsgJy0nICsgKChuZXcgRGF0ZSgpKS5nZXREYXRlKCkpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKSB9LFxuICAgICAgICAgICAge25hbWU6ICdhdXRob3InLCBwbGFjZWhvbGRlcjogJ0F1dGhvcihzKScsIHRvb2x0aXA6ICdBbGwgYXV0aG9ycyBzZXBhcmF0ZWQgYnkgdGhlIHdvcmQgXCJhbmRcIi4gQ29tbWEgaXMgdXNlZCB0byBkaXN0aW5ndWlzaCBmaXJzdCBhbmQgbGFzdCBuYW1lLiBlLmcgXCJXb2xmLCBPbGl2ZXIgYW5kIEJhcm5ldHQsIFBoaWxsaXBcIi4nfSxcbiAgICAgICAgICAgIHtuYW1lOiAndGl0bGUnLCBwbGFjZWhvbGRlcjogJ1RpdGxlJywgdG9vbHRpcDogJ1RoZSB0aXRsZSBvZiB0aGUgcmVmZXJlbmNlLid9LFxuICAgICAgICAgICAge25hbWU6ICdzdWJ0aXRsZScsIHBsYWNlaG9sZGVyOiAnU3VidGl0bGUnLCB0b29sdGlwOiAnVGhlIHN1YiB0aXRsZSBvZiB0aGUgcmVmZXJlbmNlLid9LFxuICAgICAgICAgICAge25hbWU6ICdib29rdGl0bGUnLCBwbGFjZWhvbGRlcjogJ0Jvb2sgVGl0bGUnLCB0b29sdGlwOiAnVGhlIHRpdGxlIG9mIHRoZSBib29rLid9LFxuICAgICAgICAgICAge25hbWU6ICdvcmdhbml6YXRpb24nLCBwbGFjZWhvbGRlcjogJ09yZ2FuaXphdGlvbicsIHRvb2x0aXA6ICdUaGUgb3JnYW5pemF0aW9uIHRoYXQgb3JnYW5pemVzIHRoZSBjb25mZXJlbmNlIG9yIHB1Ymxpc2hlcyB0aGUgd29yay4nfSxcbiAgICAgICAgICAgIHtuYW1lOiAnam91cm5hbCcsIHBsYWNlaG9sZGVyOiAnSm91cm5hbCcsIHRvb2x0aXA6ICdUaGUgam91cm5hbCB0aGF0IHB1Ymxpc2hlZCB0aGUgYXJ0aWNsZS4nfSxcbiAgICAgICAgICAgIHtuYW1lOiAncHVibGlzaGVyJywgcGxhY2Vob2xkZXI6ICdQdWJsaXNoZXInLCB0b29sdGlwOiAnVGhlIHB1Ymxpc2hlciBvZiB0aGUgd29yay4nfSxcbiAgICAgICAgICAgIHtuYW1lOiAnc2Nob29sJywgcGxhY2Vob2xkZXI6ICdTY2hvb2wnLCB0b29sdGlwOiAnVGhlIGluc3RpdHV0aW9uIGluIHdoaWNoIHRoZSBhdXRob3IgaXMgZW5yb2xsZWQuJ30sXG4gICAgICAgICAgICB7bmFtZTogJ2luc3RpdHV0aW9uJywgcGxhY2Vob2xkZXI6ICdJbnN0aXR1dGlvbicsIHRvb2x0aXA6ICdUaGUgaW5zdGl0dXRpb24gdGhhdCBzcG9uc29ycyB0aGUgcmVzZWFyY2ggd29yay4nfSxcbiAgICAgICAgICAgIHtuYW1lOiAnZWRpdG9yJywgcGxhY2Vob2xkZXI6ICdFZGl0b3IocyknLCB0b29sdGlwOiAnQWxsIGVkaXRvcnMgc2VwYXJhdGVkIGJ5IHRoZSB3b3JkIFwiYW5kXCIuIENvbW1hIGlzIHVzZWQgdG8gZGlzdGluZ3Vpc2ggZmlyc3QgYW5kIGxhc3QgbmFtZS4gZS5nIFwiV29sZiwgT2xpdmVyIGFuZCBCYXJuZXR0LCBQaGlsbGlwJ30sXG4gICAgICAgICAgICB7bmFtZTogJ3NlcmllcycsIHBsYWNlaG9sZGVyOiAnU2VyaWVzJywgdG9vbHRpcDogJ1RoZSBzZXJpZXMgbmFtZSBvZiB0aGUgYm9vay93b3JrJ30sXG4gICAgICAgICAgICB7bmFtZTogJ3llYXInLCBwbGFjZWhvbGRlcjogJ1llYXInLCB0b29sdGlwOiAnVGhlIHllYXIgb2YgdGhlIHB1YmxpY2F0aW9uIGNvbnNpc3Rpbmcgb2YgZm91ciBkaWdpdHMgKGUuZy4gXCIyMDIwXCIpLid9LFxuICAgICAgICAgICAge25hbWU6ICdtb250aCcsIHBsYWNlaG9sZGVyOiAnTW9udGgnLCB0b29sdGlwOiAnVGhlIG1vbnRoIG9mIHRoZSBwdWJsaWNhdGlvbi4gVXNlIHRoZSB0aHJlZSBsZXR0ZXIgYWJicmV2aWF0aW9uOiBKYW4uIEZlYi4gTWFyLiBBcHIuIE1heS4gSnVuLiBKdWwuIEF1Zy4gU2VwLiBPY3QuIE5vdi4gRGVjLid9LFxuICAgICAgICAgICAge25hbWU6ICdlZGl0aW9uJywgcGxhY2Vob2xkZXI6ICdFZGl0aW9uJywgdG9vbHRpcDogJ1RoZSBlZGl0aW9uIG9mIHRoZSBwdWJsaWNhdGlvbiAoZS5nLiBcIlNlY29uZFwiKS4gVGhlIGZpcnN0IGxldHRlciBzaG91bGQgYmUgY2FwaXRhbGl6ZWQuJ30sXG4gICAgICAgICAgICB7bmFtZTogJ3ZvbHVtZScsIHBsYWNlaG9sZGVyOiAnVm9sdW1lJywgdG9vbHRpcDogJ1RoZSB2b2x1bWUgb2YgdGhlIHB1YmxpY2F0aW9uLid9LFxuICAgICAgICAgICAge25hbWU6ICdudW1iZXInLCBwbGFjZWhvbGRlcjogJ051bWJlcicsIHRvb2x0aXA6ICdUaGUgd29ya1xcJ3MgbnVtYmVyIHdpdGhpbiBhIHNlcmllcy4nfSxcbiAgICAgICAgICAgIHtuYW1lOiAnY2hhcHRlcicsIHBsYWNlaG9sZGVyOiAnQ2hhcHRlcicsIHRvb2x0aXA6ICdBIGNoYXB0ZXIgaWYgeW91IHJlZmVyZW5jZSB0byBhIHBhcnRpY3VsYXIgcGFydCBvZiB0aGUgd29yay4nfSxcbiAgICAgICAgICAgIHtuYW1lOiAncGFnZXMnLCBwbGFjZWhvbGRlcjogJ1BhZ2VzJywgdG9vbHRpcDogJ1RoZSBwYWdlIG51bWJlcihzKSBpZiB5b3UgcmVmZXJlbmNlIHRvIGEgcGFydGljdWxhciBwYXJ0IG9mIHRoZSB3b3JrIChlLmcuIFwiMjMtNTBcIiBvciBcIjQxNyw0MjMsNTkwLTYwMVwiIG9yIDUwKykuJ30sXG4gICAgICAgIF0ubWFwKGZpZWxkID0+XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGZpZWxkLCB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiAoZGF0YVJlY29yZFtmaWVsZC5uYW1lXSB8fCBmaWVsZC5kZWZhdWx0VmFsdWUgfHwgJycpLFxuICAgICAgICAgICAgICAgIGlzQWN0aXZlOiBmdW5jdGlvbihmb3JtRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZihmaWVsZC5uYW1lID09PSAndHlwZScgfHwgZmllbGQubmFtZSA9PT0gJ2xvb2t1cElkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZighcmVmZXJlbmNlVHlwZXNbZm9ybURhdGEudHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmKHJlZmVyZW5jZVR5cGVzW2Zvcm1EYXRhLnR5cGVdLnJlcXVpcmVkLmluY2x1ZGVzKGZpZWxkLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmKHJlZmVyZW5jZVR5cGVzW2Zvcm1EYXRhLnR5cGVdLm9wdGlvbmFsLmluY2x1ZGVzKGZpZWxkLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgIH0sXG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVmZXJlbmNlO1xuIiwiY29uc3QgcmVmZXJlbmNlU291cmNlc0NvbmZpZyA9IFtcbiAgICB7IGlkLCBkaXNwbGF5TmFtZSwgaXNWYWxpZFJlY29yZCwgcmVuZGVyRW50cnksIGZpZWxkcywgc3luYyB9ID0gcmVxdWlyZSgnLi96b3Rlcm9fb25saW5lJyksXG4gICAgeyBpZCwgZGlzcGxheU5hbWUsIGlzVmFsaWRSZWNvcmQsIHJlbmRlckVudHJ5LCBmaWVsZHMsIHN5bmMgfSA9IHJlcXVpcmUoJy4vem90ZXJvX2Rlc2t0b3AnKVxuXVxuXG5hc3luYyBmdW5jdGlvbiBzYXZlUmVmZXJlbmNlU291cmNlcyhmb3JtRGF0YSwgUmVmZXJlbmNlU3RvcmUpIHtcbiAgICBhd2FpdCBSZWZlcmVuY2VTdG9yZS5kZWxldGVBbGxTb3VyY2VzKClcbiAgICBhd2FpdCBQcm9taXNlLmFsbChmb3JtRGF0YVsncmVmZXJlbmNlLXNvdXJjZXMnXS5tYXAoYXN5bmMgcnMgPT4ge1xuICAgICAgICBhd2FpdCBSZWZlcmVuY2VTdG9yZS5hZGRTb3VyY2UocnMpXG4gICAgfSkpXG5cbiAgICBhd2FpdCBSZWZlcmVuY2VTdG9yZS5jbGVhbnVwUmVmZXJlbmNlc0Zyb21Tb3VyY2VzKClcbn1cblxuY29uc3Qgc3luY0FsbFNvdXJjZXMgPSBhc3luYyBmdW5jdGlvbihSZWZlcmVuY2VTdG9yZSkge1xuICAgIGNvbnN0IHJlZmVyZW5jZVNvdXJjZXMgPSBhd2FpdCBSZWZlcmVuY2VTdG9yZS5nZXRBbGxTb3VyY2VzKClcblxuICAgIHJlZmVyZW5jZVNvdXJjZXMuZm9yRWFjaChyY0Zvcm1EYXRhID0+IHtcbiAgICAgICAgY29uc3QgcnNjID0gcmVmZXJlbmNlU291cmNlc0NvbmZpZy5maW5kKHJzID0+IHJzLmlkID09PSByY0Zvcm1EYXRhLnR5cGUpXG5cbiAgICAgICAgaWYocnNjICYmIHJzYy5zeW5jKSB7XG4gICAgICAgICAgICByc2Muc3luYyhyY0Zvcm1EYXRhLCBSZWZlcmVuY2VTdG9yZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdObyByZWZlcmVuY2Ugc291cmNlIGltcGxlbWVudGF0aW9uIGZvciAnICsgcmNGb3JtRGF0YS50eXBlICsgJyBmb3VuZCcpXG4gICAgICAgIH1cbiAgICB9KVxufVxuXG5jb25zdCBnZXRSZWZlcmVuY2VTb3VyY2VzRmllbGRzID0gYXN5bmMgZnVuY3Rpb24oUmVmZXJlbmNlU3RvcmUpIHtcbiAgICBjb25zdCByZWZlcmVuY2VTb3VyY2VzID0gYXdhaXQgUmVmZXJlbmNlU3RvcmUuZ2V0QWxsU291cmNlcygpXG5cbiAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgICB0YWI6ICdSZWZlcmVuY2UgU291cmNlcycsXG4gICAgICAgICAgICBpc0FjdGl2ZTogZm9ybURhdGEgPT4gIWZvcm1EYXRhWydyZWZlcmVuY2Utc291cmNlcyddIHx8ICFmb3JtRGF0YVsncmVmZXJlbmNlLXNvdXJjZXMnXS5sZW5ndGgsXG4gICAgICAgICAgICByZW5kZXI6IChlbCwgZm9ybURhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdpbnRlZ3JhdGlvbi1pbmZvJyk7XG4gICAgICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gJ05vIGludGVncmF0aW9uKHMpIGNvbmZpZ3VyZWQuIENsaWNrIHRoZSBcIkNvbmZpZ3VyZSBOZXcgSW50ZWdyYXRpb25cIiBidXR0b24gYmVsb3cgdG8gZG8gc28uJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAncmVmZXJlbmNlLXNvdXJjZXMnLFxuICAgICAgICAgICAgbmV3QnV0dG9uTGFiZWw6ICdDb25maWd1cmUgTmV3IFJlZmVyZW5jZSBTb3VyY2UnLFxuICAgICAgICAgICAgdGFiOiAnUmVmZXJlbmNlIFNvdXJjZXMnLFxuICAgICAgICAgICAgaXNWYWxpZFJlY29yZDogKGZvcm1EYXRhLCBkRm9ybSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJzYyA9IHJlZmVyZW5jZVNvdXJjZXNDb25maWcuZmluZChycyA9PiBycy5pZCA9PT0gZm9ybURhdGEudHlwZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcnNjICYmIHJzYy5pc1ZhbGlkUmVjb3JkKGZvcm1EYXRhLCBkRm9ybSwgUmVmZXJlbmNlU3RvcmUpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVuZGVyRW50cnk6IChmb3JtRGF0YSwgZEZvcm0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByc2MgPSByZWZlcmVuY2VTb3VyY2VzQ29uZmlnLmZpbmQocnMgPT4gcnMuaWQgPT09IGZvcm1EYXRhLnR5cGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJzYyAmJiByc2MucmVuZGVyRW50cnkoZm9ybURhdGEsIGRGb3JtKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogcmVmZXJlbmNlU291cmNlcyxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiBmb3JtRGF0YSA9PiBzYXZlUmVmZXJlbmNlU291cmNlcyhmb3JtRGF0YSwgUmVmZXJlbmNlU3RvcmUpLFxuICAgICAgICAgICAgYXJyYXlPZjogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3R5cGUnLFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZTogJ1NvdXJjZTonLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd2VkVmFsdWVzOiByZWZlcmVuY2VTb3VyY2VzQ29uZmlnLm1hcChpID0+IFtpLmlkLCBpLmRpc3BsYXlOYW1lXSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAuLi5yZWZlcmVuY2VTb3VyY2VzQ29uZmlnLmZsYXRNYXAoaSA9PiBpLmZpZWxkcylcbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgIF1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZ2V0UmVmZXJlbmNlU291cmNlc0ZpZWxkcyxcbiAgICBzeW5jQWxsU291cmNlc1xufSIsImNvbnN0IHRocm90dGxlID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL3Rocm90dGxlL3Rocm90dGxlJylcblxuY29uc3QgdHJhbnNmb3JtUmVzcG9uc2VJdGVtID0gZnVuY3Rpb24oaXRlbSwgbGlicmFyeUlELCBDb2xsZWN0aW9uSUQpIHtcbiAgICBjb25zdCB0eXBlTWFwID0ge1xuICAgICAgICAnYXJ0aWNsZS1qb3VybmFsJzogJ0FydGljbGUnLFxuICAgICAgICAnYXJ0aWNsZSc6ICdBcnRpY2xlJyxcbiAgICAgICAgJ2FydGljbGUtbWFnYXppbmUnOiAnQXJ0aWNsZScsXG4gICAgICAgICdhcnRpY2xlLW5ld3NwYXBlcic6ICdBcnRpY2xlJyxcbiAgICAgICAgJ2JpbGwnOiAnQXJ0aWNsZScsXG4gICAgICAgICdib29rJzogJ0Jvb2snLFxuICAgICAgICAnYnJvYWRjYXN0JzogJ0FydGljbGUnLFxuICAgICAgICAnY2hhcHRlcic6ICdJbmJvb2snLFxuICAgICAgICAnY2xhc3NpYyc6ICdBcnRpY2xlJyxcbiAgICAgICAgJ2NvbGxlY3Rpb24nOiAnQXJ0aWNsZScsXG4gICAgICAgICdkYXRhc2V0JzogJ0FydGljbGUnLFxuICAgICAgICAnZG9jdW1lbnQnOiAnQXJ0aWNsZScsXG4gICAgICAgICdlbnRyeSc6ICdBcnRpY2xlJyxcbiAgICAgICAgJ2VudHJ5LWRpY3Rpb25hcnknOiAnQXJ0aWNsZScsXG4gICAgICAgICdlbnRyeS1lbmN5Y2xvcGVkaWEnOiAnV2Vic2l0ZScsXG4gICAgICAgICdldmVudCc6ICdBcnRpY2xlJyxcbiAgICAgICAgJ2ZpZ3VyZSc6ICdBcnRpY2xlJyxcbiAgICAgICAgJ2dyYXBoaWMnOiAnQXJ0aWNsZScsXG4gICAgICAgICdoZWFyaW5nJzogJ0FydGljbGUnLFxuICAgICAgICAnaW50ZXJ2aWV3JzogJ0FydGljbGUnLFxuICAgICAgICAnbGVnYWxfY2FzZSc6ICdBcnRpY2xlJyxcbiAgICAgICAgJ2xlZ2lzbGF0aW9uJzogJ0FydGljbGUnLFxuICAgICAgICAnbWFudXNjcmlwdCc6ICdBcnRpY2xlJyxcbiAgICAgICAgJ21hcCc6ICdBcnRpY2xlJyxcbiAgICAgICAgJ21vdGlvbl9waWN0dXJlJzogJ0FydGljbGUnLFxuICAgICAgICAnbXVzaWNhbF9zY29yZSc6ICdBcnRpY2xlJyxcbiAgICAgICAgJ3BhbXBobGV0JzogJ0FydGljbGUnLFxuICAgICAgICAncGFwZXItY29uZmVyZW5jZSc6ICdDb25mZXJlbmNlL0lucHJvY2VlZGluZ3MnLFxuICAgICAgICAncGF0ZW50JzogJ0FydGljbGUnLFxuICAgICAgICAncGVyZm9ybWFuY2UnOiAnQXJ0aWNsZScsXG4gICAgICAgICdwZXJpb2RpY2FsJzogJ0FydGljbGUnLFxuICAgICAgICAncGVyc29uYWxfY29tbXVuaWNhdGlvbic6ICdBcnRpY2xlJyxcbiAgICAgICAgJ3Bvc3QnOiAnV2Vic2l0ZScsXG4gICAgICAgICdwb3N0LXdlYmxvZyc6ICdXZWJzaXRlJyxcbiAgICAgICAgJ3JlZ3VsYXRpb24nOiAnQXJ0aWNsZScsXG4gICAgICAgICdyZXBvcnQnOiAnQXJ0aWNsZScsXG4gICAgICAgICdyZXZpZXcnOiAnQXJ0aWNsZScsXG4gICAgICAgICdyZXZpZXctYm9vayc6ICdBcnRpY2xlJyxcbiAgICAgICAgJ3NvZnR3YXJlJzogJ0FydGljbGUnLFxuICAgICAgICAnc29uZyc6ICdBcnRpY2xlJyxcbiAgICAgICAgJ3NwZWVjaCc6ICdBcnRpY2xlJyxcbiAgICAgICAgJ3N0YW5kYXJkJzogJ0FydGljbGUnLFxuICAgICAgICAndGhlc2lzJzogJ01hc3RlcnN0aGVzaXMnLFxuICAgICAgICAndHJlYXR5JzogJ0FydGljbGUnLFxuICAgICAgICAnd2VicGFnZSc6ICdXZWJzaXRlJ1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnZlcnROYW1lVmFsdWUgPSBuYW1lRW50cnkgPT4ge1xuICAgICAgICByZXR1cm4gW25hbWVFbnRyeS5mYW1pbHksIG5hbWVFbnRyeS5naXZlbl1cbiAgICAgICAgICAgIC5maWx0ZXIoZiA9PiBmICYmIGYudHJpbSlcbiAgICAgICAgICAgIC5tYXAoZiA9PiBmLnRyaW0oKSlcbiAgICAgICAgICAgIC5maWx0ZXIoZiA9PiBmICE9PSAnJylcbiAgICAgICAgICAgIC5qb2luKCcsICcpXG4gICAgfVxuXG4gICAgY29uc3QgdHJ5VG9QYXJzZURhdGUgPSBkYXRlUGFydHMgPT4ge1xuICAgICAgICBpZihkYXRlUGFydHMgJiYgZGF0ZVBhcnRzWydkYXRlLXBhcnRzJ10gJiYgZGF0ZVBhcnRzWydkYXRlLXBhcnRzJ11bMF0pIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlUGFydHNbJ2RhdGUtcGFydHMnXVswXS5qb2luKCctJylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHRyeVRvUGFyc2VZZWFyID0gZGF0ZVBhcnRzID0+IHtcbiAgICAgICAgaWYoZGF0ZVBhcnRzICYmIGRhdGVQYXJ0c1snZGF0ZS1wYXJ0cyddICYmIGRhdGVQYXJ0c1snZGF0ZS1wYXJ0cyddWzBdICYmIGRhdGVQYXJ0c1snZGF0ZS1wYXJ0cyddWzBdWzBdKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0ZVBhcnRzWydkYXRlLXBhcnRzJ11bMF1bMF0udG9TdHJpbmcoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdHJ5VG9QYXJzZU1vbnRoID0gZGF0ZVBhcnRzID0+IHtcbiAgICAgICAgaWYoZGF0ZVBhcnRzICYmIGRhdGVQYXJ0c1snZGF0ZS1wYXJ0cyddICYmIGRhdGVQYXJ0c1snZGF0ZS1wYXJ0cyddWzBdICYmIGRhdGVQYXJ0c1snZGF0ZS1wYXJ0cyddWzBdWzFdKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0ZVBhcnRzWydkYXRlLXBhcnRzJ11bMF1bMV0udG9TdHJpbmcoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbG9va3VwSWQ6IGl0ZW0uSVNCTiB8fCBpdGVtLkRPSSxcbiAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgIHR5cGU6IHR5cGVNYXBbaXRlbS50eXBlXSB8fCAnQXJ0aWNsZScsXG4gICAgICAgIHJlZmVyZW5jZVNvdXJjZTogYHpvdGVyby1kZXNrdG9wLSR7bGlicmFyeUlEfS0ke0NvbGxlY3Rpb25JRH1gLFxuICAgICAgICB0aXRsZTogaXRlbS50aXRsZSxcbiAgICAgICAgYXV0aG9yOiBpdGVtLmF1dGhvciAmJiBpdGVtLmF1dGhvci5tYXAoY29udmVydE5hbWVWYWx1ZSkuam9pbignIGFuZCAnKSxcbiAgICAgICAgcGFnZXM6IGl0ZW1bJ251bWJlci1vZi1wYWdlcyddLFxuICAgICAgICB2b2x1bWU6IGl0ZW0udmFsdW1lLFxuICAgICAgICB1cmw6IGl0ZW0uVVJMLFxuICAgICAgICBwdWJsaXNoZXI6IGl0ZW0ucHVibGlzaGVyLFxuICAgICAgICBlZGl0aW9uOiBpdGVtLmVkaXRpb24sXG4gICAgICAgIGRhdGU6IHRyeVRvUGFyc2VEYXRlKGl0ZW0uYWNjZXNzZWQpLFxuICAgICAgICB5ZWFyOiB0cnlUb1BhcnNlWWVhcihpdGVtLmlzc3VlZCksXG4gICAgICAgIG1vbnRoOiB0cnlUb1BhcnNlTW9udGgoaXRlbS5pc3N1ZWQpLFxuICAgICAgICBlZGl0b3I6IGl0ZW0uZWRpdG9yICYmIGl0ZW0uZWRpdG9yLm1hcChjb252ZXJ0TmFtZVZhbHVlKS5qb2luKCcgYW5kICcpLFxuICAgIH1cbn1cblxuY29uc3QgcmVuZGVyRW50cnkgPSBmdW5jdGlvbihlbnRyeSkge1xuICAgIGlmKGVudHJ5LnR5cGUgPT09ICd6b3Rlcm8tZGVza3RvcCcpIHtcbiAgICAgICAgcmV0dXJuIGBab3Rlcm8gRGVzdGtvcGBcbiAgICB9XG59XG5cbmNvbnN0IGlzVmFsaWRSZWNvcmQgPSB0aHJvdHRsZSgxMDAsIGFzeW5jIGZ1bmN0aW9uKGZvcm1EYXRhLCBkRnJvbSwgUmVmZXJlbmNlU3RvcmUpIHtcbiAgICB3aW5kb3cuc3RvcmUgPSBSZWZlcmVuY2VTdG9yZVxuICAgIGlmKGZvcm1EYXRhLnR5cGUgPT09ICd6b3Rlcm8tZGVza3RvcCcgJiYgZm9ybURhdGFbJ3pvdGVyby1kZXNrdG9wLWxpYnJhcnlJRCddKSB7XG4gICAgICAgIHZhciBpdGVtUmVzcG9uc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkRnJvbS5zZXRUb29sdGlwKCd6b3Rlcm8tZGVza3RvcC1saWJyYXJ5SUQnLCAnV2FpdCBmb3IgaXQgLi4uJywgJycsICd0b29sdGlwLWxvYWRpbmcnKVxuICAgICAgICAgICAgZEZyb20uc2V0VG9vbHRpcCgnem90ZXJvLWRlc2t0b3AtY29sbGVjdGlvbklEJywgJ1dhaXQgZm9yIGl0IC4uLicsICcnLCAndG9vbHRpcC1sb2FkaW5nJylcblxuICAgICAgICAgICAgaWYoZm9ybURhdGFbJ3pvdGVyby1kZXNrdG9wLWNvbGxlY3Rpb25JRCddID09PSAnbm8tY29sbGVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpdGVtUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgaHR0cDovLzEyNy4wLjAuMToyMzExOS9iZXR0ZXItYmlidGV4L2V4cG9ydC9saWJyYXJ5Py8ke2Zvcm1EYXRhWyd6b3Rlcm8tZGVza3RvcC1saWJyYXJ5SUQnXX0vbGlicmFyeS5jc2xqc29uYClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlbVJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYGh0dHA6Ly8xMjcuMC4wLjE6MjMxMTkvYmV0dGVyLWJpYnRleC9jb2xsZWN0aW9uPy8ke2Zvcm1EYXRhWyd6b3Rlcm8tZGVza3RvcC1saWJyYXJ5SUQnXX0vJHtmb3JtRGF0YVsnem90ZXJvLWRlc2t0b3AtY29sbGVjdGlvbklEJ119LmNzbGpzb25gKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBpdGVtcyA9IGF3YWl0IGl0ZW1SZXNwb25zZS5qc29uKCk7XG5cbiAgICAgICAgICAgIGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgUmVmZXJlbmNlU3RvcmUuc2V0KGB6b3Rlcm8tZGVza3RvcC1pdGVtLSR7Zm9ybURhdGFbJ3pvdGVyby1kZXNrdG9wLWxpYnJhcnlJRCddfS0ke2Zvcm1EYXRhWyd6b3Rlcm8tZGVza3RvcC1jb2xsZWN0aW9uSUQnXX0tJHtpdGVtLmlkfWAsIHRyYW5zZm9ybVJlc3BvbnNlSXRlbShpdGVtLCBmb3JtRGF0YVsnem90ZXJvLWRlc2t0b3AtbGlicmFyeUlEJ10sIGZvcm1EYXRhWyd6b3Rlcm8tZGVza3RvcC1jb2xsZWN0aW9uSUQnXSkpXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICBkRnJvbS5yZXNldFRvb2x0aXBzKFsnem90ZXJvLWRlc2t0b3AtbGlicmFyeUlEJywgJ3pvdGVyby1kZXNrdG9wLWNvbGxlY3Rpb25JRCddKVxuXG4gICAgICAgICAgICBjb25zdCBoaW50RmllbGQgPSBmb3JtRGF0YVsnem90ZXJvLWRlc2t0b3AtY29sbGVjdGlvbklEJ10gPT09ICduby1jb2xsZWN0aW9uJyA/ICd6b3Rlcm8tZGVza3RvcC1saWJyYXJ5SUQnIDogJ3pvdGVyby1kZXNrdG9wLWNvbGxlY3Rpb25JRCdcbiAgICAgICAgICAgIGNvbnN0IGhpbnRGaWVsZFR5cGUgPSBmb3JtRGF0YVsnem90ZXJvLWRlc2t0b3AtY29sbGVjdGlvbklEJ10gPT09ICduby1jb2xsZWN0aW9uJyA/ICdsaWJyYXJ5JyA6ICdjb2xsZWN0aW9uJ1xuXG4gICAgICAgICAgICBpZighaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZEZyb20uc2V0VG9vbHRpcFdhcm5pbmcoaGludEZpZWxkLCBgTm8gaXRlbXMgZm91bmQgaW4gdGhpcyAke2hpbnRGaWVsZFR5cGV9IWApXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRGcm9tLnNldFRvb2x0aXBTdWNjZXNzKGhpbnRGaWVsZCwgYCR7aXRlbXMubGVuZ3RofSBpdGVtcyBmb3VuZC5gKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgZEZyb20uc2V0VG9vbHRpcEVycm9yKCd6b3Rlcm8tZGVza3RvcC1saWJyYXJ5SUQnLCBgU29tZXRoaW5nIHdlbnQgd3JvbmcgZmV0Y2hpbmcgaXRlbXMgZnJvbSBab3Rlcm8uYClcbiAgICAgICAgICAgIGRGcm9tLnNldFRvb2x0aXBFcnJvcignem90ZXJvLWRlc2t0b3AtY29sbGVjdGlvbklEJywgYFNvbWV0aGluZyB3ZW50IHdyb25nIGZldGNoaW5nIGl0ZW1zIGZyb20gWm90ZXJvLmApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgIH1cbn0pXG5cbmNvbnN0IHN5bmMgPSBhc3luYyBmdW5jdGlvbihmb3JtRGF0YSwgUmVmZXJlbmNlU3RvcmUpIHtcbiAgICBpZihmb3JtRGF0YS50eXBlID09PSAnem90ZXJvLWRlc2t0b3AnICYmIGZvcm1EYXRhWyd6b3Rlcm8tZGVza3RvcC1saWJyYXJ5SUQnXSkge1xuICAgICAgICB2YXIgaXRlbVJlc3BvbnNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYoZm9ybURhdGFbJ3pvdGVyby1kZXNrdG9wLWNvbGxlY3Rpb25JRCddID09PSAnbm8tY29sbGVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpdGVtUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgaHR0cDovLzEyNy4wLjAuMToyMzExOS9iZXR0ZXItYmlidGV4L2V4cG9ydC9saWJyYXJ5Py8ke2Zvcm1EYXRhWyd6b3Rlcm8tZGVza3RvcC1saWJyYXJ5SUQnXX0vbGlicmFyeS5jc2xqc29uYClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlbVJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYGh0dHA6Ly8xMjcuMC4wLjE6MjMxMTkvYmV0dGVyLWJpYnRleC9jb2xsZWN0aW9uPy8ke2Zvcm1EYXRhWyd6b3Rlcm8tZGVza3RvcC1saWJyYXJ5SUQnXX0vJHtmb3JtRGF0YVsnem90ZXJvLWRlc2t0b3AtY29sbGVjdGlvbklEJ119LmNzbGpzb25gKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBpdGVtcyA9IGF3YWl0IGl0ZW1SZXNwb25zZS5qc29uKCk7XG5cbiAgICAgICAgICAgIGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgUmVmZXJlbmNlU3RvcmUuc2V0KGB6b3Rlcm8tZGVza3RvcC1pdGVtLSR7Zm9ybURhdGFbJ3pvdGVyby1kZXNrdG9wLWxpYnJhcnlJRCddfS0ke2Zvcm1EYXRhWyd6b3Rlcm8tZGVza3RvcC1jb2xsZWN0aW9uSUQnXX0tJHtpdGVtLmlkfWAsIHRyYW5zZm9ybVJlc3BvbnNlSXRlbShpdGVtLCBmb3JtRGF0YVsnem90ZXJvLWRlc2t0b3AtbGlicmFyeUlEJ10sIGZvcm1EYXRhWyd6b3Rlcm8tZGVza3RvcC1jb2xsZWN0aW9uSUQnXSkpXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IGZldGNoTGlicmFyaWVzID0gdGhyb3R0bGUoMTAwLCBhc3luYyBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzcG9uc2U7XG5cbiAgICB0cnkge1xuICAgICAgICByZXNwb25zZSA9IGF3YWl0IGZldGNoKGBodHRwOi8vbG9jYWxob3N0OjIzMTE5L2JldHRlci1iaWJ0ZXgvanNvbi1ycGNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsganNvbnJwYzogXCIyLjBcIiwgbWV0aG9kOiBcInVzZXIuZ3JvdXBzXCIsIHBhcmFtczogW3RydWVdIH0pLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pXG4gICAgfSBjYXRjaChleCkge1xuICAgICAgICB0aHJvdyB7IG1lc3NhZ2U6ICdNYWtlIHN1cmUgeW91IGhhdmUgc3RhcnRldCB0aGUgWm90ZXJvIGRlc2t0b3AgYXBwJyB9XG4gICAgfVxuXG4gICAgaWYocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgdGhyb3cgeyBtZXNzYWdlOiAnTWFrZSBzdXJlIHlvdSBoYXZlIHRoZSBcIkJldHRlciBCaWJUZVggZm9yIFpvdGVyb1wiIGFkZC1vbiBpbnN0YWxsZWQgaW4gWm90ZXJvLiBZb3UgY2FuIGRvd25sb2FkIGl0IGhlcmU6IGh0dHBzOi8vcmV0b3JxdWUucmUvem90ZXJvLWJldHRlci1iaWJ0ZXgvaW5zdGFsbGF0aW9uLycgfVxuICAgIH0gZWxzZSBpZihyZXNwb25zZS5zdGF0dXMgPT09IDUwMCkge1xuICAgICAgICB0aHJvdyB7IG1lc3NhZ2U6ICdNYWtlIHN1cmUgeW91IGhhdmUgYXQgbGVhc3QgdmVyc2lvbiA8Yj42LjcuMTwvYj4gb2YgXCJCZXR0ZXIgQmliVGVYIGZvciBab3Rlcm9cIiBpbnN0YWxsZWQuIFlvdSBjYW4gZG93bmxvYWQgaXQgaGVyZTogaHR0cHM6Ly9yZXRvcnF1ZS5yZS96b3Rlcm8tYmV0dGVyLWJpYnRleC9pbnN0YWxsYXRpb24vJyB9XG4gICAgfVxuXG4gICAgaWYocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgdGhyb3cgeyBtZXNzYWdlOiAnU29tZXRoaW5nIHdlbnQgd3JvbmcgZmV0Y2hpbmcgaXRlbXMgZnJvbSBab3Rlcm8nIH1cbiAgICB9XG5cbiAgICB2YXIganNvblJlc3BvbnNlID0gKGF3YWl0IHJlc3BvbnNlLmpzb24oKSlcblxuICAgIGlmKCFqc29uUmVzcG9uc2UucmVzdWx0KSB7XG4gICAgICAgIHRocm93IHsgbWVzc2FnZTogJ1NvbWV0aGluZyB3ZW50IHdyb25nIGZldGNoaW5nIGl0ZW1zIGZyb20gWm90ZXJvLiBQbGVhc2Ugc2VuZCB0aGUgZm9sbG93aW5nIGVycm9yIHRlc3QgdG8gaW5mb0Btb25zdGVyd3JpdGVyLmFwcDogJyArIEpTT04uc3RyaW5naWZ5KGpzb25SZXNwb25zZS5lcnJvcikgfVxuICAgIH1cblxuICAgIGlmKGpzb25SZXNwb25zZS5yZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IHsgbWVzc2FnZTogJ05vIGxpYnJhcmllcyBhdmFpbGFibGUhJyB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGpzb25SZXNwb25zZS5yZXN1bHRcbn0pXG5cbmNvbnN0IG9uVmFsdWVzQ2FsY3VsYXRpb25GYWlsZWRNZXNzYWdlID0gZnVuY3Rpb24oZnJvbURhdGEsIGVycikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGxldmVsOiBlcnIubGV2ZWwgfHwgJ2Vycm9yJyxcbiAgICAgICAgdGV4dDogZXJyLm1lc3NhZ2UgfHwgJ1NvbWV0aGluZyB3ZW50IHdyb25nIGZldGNoaW5nIGl0ZW1zIGZyb20gWm90ZXJvLidcbiAgICB9XG59XG5cbmNvbnN0IGZpZWxkcyA9IFtcbiAgICB7XG4gICAgICAgIG5hbWU6ICd6b3Rlcm8tZGVza3RvcC1saWJyYXJ5SUQnLFxuICAgICAgICBkaXNwbGF5TmFtZTogJ0xpYnJhcnknLFxuICAgICAgICB0b29sdGlwOiAnQ2hvb3NlIGEgbGlicmFyeSBmcm9tIHlvdXIgbG9jYWwgWm90ZXJvIGluc3RhbGxhdGlvbicsXG4gICAgICAgIGlzQWN0aXZlOiBmb3JtRGF0YSA9PiBmb3JtRGF0YVsndHlwZSddID09PSAnem90ZXJvLWRlc2t0b3AnLFxuICAgICAgICBvblZhbHVlc0NhbGN1bGF0aW9uRmFpbGVkTWVzc2FnZSxcbiAgICAgICAgYWxsb3dlZFZhbHVlczogYXN5bmMgKCkgPT4gKGF3YWl0IGZldGNoTGlicmFyaWVzKCkpLm1hcChsaWIgPT4gW2xpYi5pZCwgbGliLm5hbWVdKSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ3pvdGVyby1kZXNrdG9wLWNvbGxlY3Rpb25JRCcsXG4gICAgICAgIGRpc3BsYXlOYW1lOiAnQ29sbGVjdGlvbicsXG4gICAgICAgIHJlbG9hZE9uQ2hhbmdlT2Y6IFsnem90ZXJvLWRlc2t0b3AtbGlicmFyeUlEJ10sXG4gICAgICAgIHRvb2x0aXA6ICdDaG9vc2UgYSBjb2xsZWN0aW9uIGZyb20geW91ciBsb2NhbCBab3Rlcm8gaW5zdGFsbGF0aW9uJyxcbiAgICAgICAgaXNBY3RpdmU6IGZvcm1EYXRhID0+IGZvcm1EYXRhWyd0eXBlJ10gPT09ICd6b3Rlcm8tZGVza3RvcCcsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogJ25vLWNvbGxlY3Rpb24nLFxuICAgICAgICBvblZhbHVlc0NhbGN1bGF0aW9uRmFpbGVkTWVzc2FnZSxcbiAgICAgICAgYWxsb3dlZFZhbHVlczogYXN5bmMgZm9ybURhdGEgPT4ge1xuICAgICAgICAgICAgaWYoIWZvcm1EYXRhWyd6b3Rlcm8tZGVza3RvcC1saWJyYXJ5SUQnXSkge1xuICAgICAgICAgICAgICAgIHRocm93IHsgbWVzc2FnZTogJ0Nob29zZSBhIGxpYnJhcnkgZmlyc3QhJyB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBsaWJyYXJpZXMgPSBhd2FpdCBmZXRjaExpYnJhcmllcygpXG4gICAgICAgICAgICB2YXIgbGlicmFyeSA9IGxpYnJhcmllcy5maW5kKGxpYiA9PiBsaWIuaWQudG9TdHJpbmcoKSA9PT0gZm9ybURhdGFbJ3pvdGVyby1kZXNrdG9wLWxpYnJhcnlJRCddKVxuXG4gICAgICAgICAgICBpZighbGlicmFyeS5jb2xsZWN0aW9ucyB8fCAhbGlicmFyeS5jb2xsZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB7IG1lc3NhZ2U6ICdObyBjb2xsZWN0aW9ucyBhdmFpbGFibGUgaW4gdGhlIGNob29zZW4gbGlicmFyeSEnIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBbJ25vLWNvbGxlY3Rpb24nLCAnRW50aXJlIExpYnJhcnknXSxcbiAgICAgICAgICAgICAgICAuLi5saWJyYXJ5LmNvbGxlY3Rpb25zLm1hcChjb2wgPT4gWyBjb2wua2V5LCBjb2wubmFtZSBdKVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgIH1cbl1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgaWQ6ICd6b3Rlcm8tZGVza3RvcCcsXG4gICAgZGlzcGxheU5hbWU6ICdab3Rlcm8gKERlc2t0b3AgdmlhIEJldHRlciBCaWJUZVggQWRkLU9uKScsXG4gICAgaXNWYWxpZFJlY29yZCxcbiAgICByZW5kZXJFbnRyeSxcbiAgICBmaWVsZHMsXG4gICAgc3luY1xufSIsImNvbnN0IHRocm90dGxlID0gcmVxdWlyZSgnLi8uLi8uLi8uLi9saWIvdGhyb3R0bGUvdGhyb3R0bGUnKVxuY29uc3QgeyBab3Rlcm9PbmxpbmUgfSA9IHJlcXVpcmUoJy4vLi4vLi4vLi4vbGliL3pvdGVyby1jbGllbnQnKVxudmFyIGxhdGVzdExvYWRlZEdyb3VwcyA9IFtdLCBjbGllbnRzV2l0aG91dFN0b3JlID0ge31cblxuY29uc3QgaXNWYWxpZFJlY29yZCA9IHRocm90dGxlKDEwMCwgYXN5bmMgZnVuY3Rpb24oZm9ybURhdGEsIGRGcm9tLCBSZWZlcmVuY2VTdG9yZSkge1xuICAgIGlmKGZvcm1EYXRhLnR5cGUgPT09ICd6b3Rlcm8tb25saW5lJykge1xuICAgICAgICBjb25zdCBpc0dyb3VwID0gZm9ybURhdGFbJ3pvdGVyby1vbmxpbmUtdXNlck9yR3JvdXAnXSA9PT0gJ2dyb3VwJ1xuXG4gICAgICAgIGlmKGZvcm1EYXRhWyd6b3Rlcm8tb25saW5lLWFwaUtleSddLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgICAgIGRGcm9tLnNldFRvb2x0aXBXYXJuaW5nKCd6b3Rlcm8tb25saW5lLWFwaUtleScsICdBbiBab3Rlcm8gQVBJIGtleSBpcyBuZWVkZWQuIFlvdSBjYW4gY3JlYXRlIGFuIEFQSSBrZXkgaGVyZTogaHR0cHM6Ly93d3cuem90ZXJvLm9yZy9zZXR0aW5ncy9rZXlzJylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoaXNHcm91cCAmJiBmb3JtRGF0YVsnem90ZXJvLW9ubGluZS1ncm91cElEJ10gPT09ICcnKSB7XG4gICAgICAgICAgICBkRnJvbS5zZXRUb29sdGlwV2FybmluZygnem90ZXJvLW9ubGluZS1ncm91cElEJywgJ0Nob29zZSBhIGdyb3VwIGZyb20gd2hpY2ggeW91IHdhbnQgdG8gcmV0cmlldmUgcmVmZXJlbmNlcyBmcm9tLiBJZiB5b3UgZG8gbm90IHdhbnQgdG8gcmV0cmlldmUgcmVmZXJlbmNlcyBmcm9tIGEgWm90ZXJvIGdyb3VwIGNob29zZSBcIlVzZXJcIiBpbiBcIlVzZXIgb3IgR3JvdXAgU2NvcGVkIEludGVncmF0aW9uXCInKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZEZyb20uc2V0VG9vbHRpcCgnem90ZXJvLW9ubGluZS1hcGlLZXknLCAnV2FpdCBmb3IgaXQgLi4uJywgJycsICd0b29sdGlwLWxvYWRpbmcnKVxuXG4gICAgICAgICAgICBjb25zdCB6b3Rlcm9PbmxpbmVDbGllbnQgPSBuZXcgWm90ZXJvT25saW5lKGZvcm1EYXRhWyd6b3Rlcm8tb25saW5lLWFwaUtleSddLCBSZWZlcmVuY2VTdG9yZSlcbiAgICAgICAgICAgIGF3YWl0IHpvdGVyb09ubGluZUNsaWVudC5sb2FkVXNlckluZm8oKVxuXG4gICAgICAgICAgICBjb25zdCBpdGVtQ291bnQgPSAoaXNHcm91cCA/XG4gICAgICAgICAgICAgICAgYXdhaXQgem90ZXJvT25saW5lQ2xpZW50Lml0ZW1zQnlHcm91cElEKGZvcm1EYXRhWyd6b3Rlcm8tb25saW5lLWdyb3VwSUQnXSkgOlxuICAgICAgICAgICAgICAgIGF3YWl0IHpvdGVyb09ubGluZUNsaWVudC5pdGVtcygpKS5sZW5ndGhcblxuICAgICAgICAgICAgZEZyb20ucmVzZXRUb29sdGlwcyhbJ3pvdGVyby1vbmxpbmUtZ3JvdXBJRCcsICd6b3Rlcm8tb25saW5lLWFwaUtleSddKVxuXG4gICAgICAgICAgICBpZihpdGVtQ291bnQpIHtcbiAgICAgICAgICAgICAgICBkRnJvbS5zZXRUb29sdGlwU3VjY2Vzcygnem90ZXJvLW9ubGluZS1hcGlLZXknLCBgJHtpdGVtQ291bnR9IGl0ZW1zIGhhdmUgYmVlbiBmZXRjaGVkIGZyb20gWm90ZXJvYClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZEZyb20uc2V0VG9vbHRpcFdhcm5pbmcoJ3pvdGVyby1vbmxpbmUtYXBpS2V5JywgJ0l0IHNlZW1zIGxpa2UgdGhpcyB1c2VyIG9yIGdyb3VwIGRvZXMgbm90IGhhcyBhbnkgaXRlbXMgc2F2ZWQnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZXJyKVxuICAgICAgICAgICAgY29uc3QgZXJyb3JUZXh0ID0gYFRoZXJlIHdhcyBhbiBlcnJvciBjb25uZWN0aW5nIHRvIFpvdGVyby4gTWFrZSBzdXJlICR7aXNHcm91cCA/ICdHcm91cCcgOiAnVXNlcid9IElEIGFuZCBBUEkgS2V5IGFyZSBjb3JyZWN0IWBcbiAgICAgICAgICAgIGRGcm9tLnNldFRvb2x0aXBFcnJvcignem90ZXJvLW9ubGluZS1hcGlLZXknLCBlcnJvclRleHQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgIH1cbn0pXG5cbmNvbnN0IHN5bmMgPSBhc3luYyBmdW5jdGlvbihmb3JtRGF0YSwgUmVmZXJlbmNlU3RvcmUpIHtcbiAgICBpZihmb3JtRGF0YS50eXBlID09PSAnem90ZXJvLW9ubGluZScpIHtcbiAgICAgICAgY29uc3QgaXNHcm91cCA9IGZvcm1EYXRhWyd6b3Rlcm8tb25saW5lLXVzZXJPckdyb3VwJ10gPT09ICdncm91cCdcblxuICAgICAgICBpZihmb3JtRGF0YVsnem90ZXJvLW9ubGluZS1hcGlLZXknXS50cmltKCkgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGlzR3JvdXAgJiYgZm9ybURhdGFbJ3pvdGVyby1vbmxpbmUtZ3JvdXBJRCddID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgem90ZXJvT25saW5lQ2xpZW50ID0gbmV3IFpvdGVyb09ubGluZShmb3JtRGF0YVsnem90ZXJvLW9ubGluZS1hcGlLZXknXSwgUmVmZXJlbmNlU3RvcmUpXG4gICAgICAgICAgICBhd2FpdCB6b3Rlcm9PbmxpbmVDbGllbnQubG9hZFVzZXJJbmZvKClcblxuICAgICAgICAgICAgaWYoaXNHcm91cCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHpvdGVyb09ubGluZUNsaWVudC5pdGVtc0J5R3JvdXBJRChmb3JtRGF0YVsnem90ZXJvLW9ubGluZS1ncm91cElEJ10pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGF3YWl0IHpvdGVyb09ubGluZUNsaWVudC5pdGVtcygpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgZ2V0Q2xpZW50V2l0aG91dFN0b3JlID0gYXN5bmMgZnVuY3Rpb24oYXBpS2V5KSB7XG4gICAgaWYoIWNsaWVudHNXaXRob3V0U3RvcmVbYXBpS2V5XSkge1xuICAgICAgICBjbGllbnRzV2l0aG91dFN0b3JlW2FwaUtleV0gPSBbXVxuICAgICAgICBjbGllbnRzV2l0aG91dFN0b3JlW2FwaUtleV1bMF0gPSBuZXcgWm90ZXJvT25saW5lKGFwaUtleSlcbiAgICAgICAgY2xpZW50c1dpdGhvdXRTdG9yZVthcGlLZXldWzFdID0gY2xpZW50c1dpdGhvdXRTdG9yZVthcGlLZXldWzBdLmxvYWRVc2VySW5mbygpXG4gICAgfVxuXG4gICAgYXdhaXQgY2xpZW50c1dpdGhvdXRTdG9yZVthcGlLZXldWzFdXG5cbiAgICByZXR1cm4gY2xpZW50c1dpdGhvdXRTdG9yZVthcGlLZXldWzBdXG59XG5cbmNvbnN0IHJlbmRlckVudHJ5ID0gZnVuY3Rpb24oZW50cnkpIHtcbiAgICBpZihlbnRyeS50eXBlID09PSAnem90ZXJvLW9ubGluZScpIHtcbiAgICAgICAgY29uc3QgaXNHcm91cCA9IGVudHJ5Wyd6b3Rlcm8tb25saW5lLXVzZXJPckdyb3VwJ10gPT09ICdncm91cCdcbiAgICAgICAgY29uc3QgdXNlck9yR3JvdXAgPSBlbnRyeVsnem90ZXJvLW9ubGluZS11c2VyT3JHcm91cCddLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgZW50cnlbJ3pvdGVyby1vbmxpbmUtdXNlck9yR3JvdXAnXS5zbGljZSgxKVxuICAgICAgICB2YXIgZGlzcGxheU5hbWUgPSAnJ1xuXG4gICAgICAgIGlmKCFpc0dyb3VwKSB7XG4gICAgICAgICAgICBkaXNwbGF5TmFtZSA9IGVudHJ5Wyd6b3Rlcm8tb25saW5lLXVzZXJOYW1lJ11cbiAgICAgICAgfSBlbHNlIGlmKGlzR3JvdXApIHtcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lID0gZW50cnlbJ3pvdGVyby1vbmxpbmUtZ3JvdXBOYW1lJ11cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBgWm90ZXJvLm9yZyAoT25saW5lKSAtICR7dXNlck9yR3JvdXB9OiAke2Rpc3BsYXlOYW1lfWBcbiAgICB9XG59XG5cbmNvbnN0IGZpZWxkcyA9IFtcbiAgICB7XG4gICAgICAgIG5hbWU6ICd6b3Rlcm8tb25saW5lLXVzZXJPckdyb3VwJyxcbiAgICAgICAgZGlzcGxheU5hbWU6ICdab3Rlcm8gTGlicmFyeSBUeXBlOicsXG4gICAgICAgIGlzQWN0aXZlOiBmb3JtRGF0YSA9PiBmb3JtRGF0YVsndHlwZSddID09PSAnem90ZXJvLW9ubGluZScsXG4gICAgICAgIGFsbG93ZWRWYWx1ZXM6IFtbJ3VzZXInLCAnVXNlciddLCBbJ2dyb3VwJywgJ0dyb3VwJ11dLFxuICAgICAgICBkZWZhdWx0VmFsdWU6ICd1c2VyJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ3pvdGVyby1vbmxpbmUtYXBpS2V5JyxcbiAgICAgICAgaXNBY3RpdmU6IGZvcm1EYXRhID0+IGZvcm1EYXRhWyd0eXBlJ10gPT09ICd6b3Rlcm8tb25saW5lJyxcbiAgICAgICAgZGlzcGxheU5hbWU6ICdBUEkgS2V5OicsXG4gICAgICAgIGlucHV0VHlwZTogJ3Bhc3N3b3JkJyxcbiAgICAgICAgdG9vbHRpcDogJ1lvdSBjYW4gY3JlYXRlIGFuIEFQSSBrZXkgaGVyZTogaHR0cHM6Ly93d3cuem90ZXJvLm9yZy9zZXR0aW5ncy9rZXlzJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ3pvdGVyby1vbmxpbmUtdXNlcklEJyxcbiAgICAgICAgcmVsb2FkT25DaGFuZ2VPZjogWyd6b3Rlcm8tb25saW5lLWFwaUtleSddLFxuICAgICAgICBjYWxjdWxhdGU6IGFzeW5jIGZvcm1EYXRhID0+IHtcbiAgICAgICAgICAgIGlmKCFmb3JtRGF0YSB8fCAhZm9ybURhdGFbJ3pvdGVyby1vbmxpbmUtYXBpS2V5J10gfHwgZm9ybURhdGFbJ3pvdGVyby1vbmxpbmUtYXBpS2V5J10gPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBnZXRDbGllbnRXaXRob3V0U3RvcmUoZm9ybURhdGFbJ3pvdGVyby1vbmxpbmUtYXBpS2V5J10pXG4gICAgICAgICAgICByZXR1cm4gY2xpZW50LnVzZXJJRFxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICd6b3Rlcm8tb25saW5lLXVzZXJOYW1lJyxcbiAgICAgICAgcmVsb2FkT25DaGFuZ2VPZjogWyd6b3Rlcm8tb25saW5lLWFwaUtleSddLFxuICAgICAgICBjYWxjdWxhdGU6IGFzeW5jIGZvcm1EYXRhID0+IHtcbiAgICAgICAgICAgIGlmKCFmb3JtRGF0YSB8fCAhZm9ybURhdGFbJ3pvdGVyby1vbmxpbmUtYXBpS2V5J10gfHwgZm9ybURhdGFbJ3pvdGVyby1vbmxpbmUtYXBpS2V5J10gPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBnZXRDbGllbnRXaXRob3V0U3RvcmUoZm9ybURhdGFbJ3pvdGVyby1vbmxpbmUtYXBpS2V5J10pXG4gICAgICAgICAgICByZXR1cm4gY2xpZW50LnVzZXJOYW1lXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ3pvdGVyby1vbmxpbmUtZ3JvdXBOYW1lJyxcbiAgICAgICAgcmVsb2FkT25DaGFuZ2VPZjogWyd6b3Rlcm8tb25saW5lLWFwaUtleScsICd6b3Rlcm8tb25saW5lLXVzZXJPckdyb3VwJywgJ3pvdGVyby1vbmxpbmUtZ3JvdXBJRCddLFxuICAgICAgICBjYWxjdWxhdGU6IGZvcm1EYXRhID0+IHtcbiAgICAgICAgICAgIGlmKCFsYXRlc3RMb2FkZWRHcm91cHNcbiAgICAgICAgICAgICAgICB8fCAhbGF0ZXN0TG9hZGVkR3JvdXBzLmZpbmRcbiAgICAgICAgICAgICAgICB8fCAhZm9ybURhdGFcbiAgICAgICAgICAgICAgICB8fCAhZm9ybURhdGFbJ3pvdGVyby1vbmxpbmUtZ3JvdXBJRCddXG4gICAgICAgICAgICAgICAgfHwgZm9ybURhdGFbJ3pvdGVyby1vbmxpbmUtdXNlck9yR3JvdXAnXSA9PT0gJ3VzZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBncm91cCA9IGxhdGVzdExvYWRlZEdyb3Vwcy5maW5kKGdyID0+IGdyLmlkLnRvU3RyaW5nKCkgPT09IGZvcm1EYXRhWyd6b3Rlcm8tb25saW5lLWdyb3VwSUQnXS50b1N0cmluZygpKVxuXG4gICAgICAgICAgICBpZihncm91cCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBncm91cC5uYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ3pvdGVyby1vbmxpbmUtZ3JvdXBJRCcsXG4gICAgICAgIGRpc3BsYXlOYW1lOiAnR3JvdXAnLFxuICAgICAgICB0b29sdGlwOiAnSWYgeW91IHdhbnQgdG8gY2l0ZSByZWZlcmVuY2VzIHdoaWNoIGFyZSBtYW5hZ2VkIGluIGEgWm90ZXJvIGdyb3VwLCBzZWxlY3QgdGhlIGdyb3VwIGhlcmUuIElmIG5vdCwgc2VsZWN0IFwiVXNlclwiIGluIFwiVXNlciBvciBHcm91cCBTY29wZWQgSW50ZWdyYXRpb25cIicsXG4gICAgICAgIGlzQWN0aXZlOiBmb3JtRGF0YSA9PiBmb3JtRGF0YVsndHlwZSddID09PSAnem90ZXJvLW9ubGluZScgJiYgZm9ybURhdGFbJ3pvdGVyby1vbmxpbmUtdXNlck9yR3JvdXAnXSA9PT0gJ2dyb3VwJyxcbiAgICAgICAgcmVsb2FkT25DaGFuZ2VPZjogWyd6b3Rlcm8tb25saW5lLWFwaUtleScsICd6b3Rlcm8tb25saW5lLXVzZXJPckdyb3VwJ10sXG4gICAgICAgIGFsbG93ZWRWYWx1ZXM6IGFzeW5jIGZvcm1EYXRhID0+IHtcbiAgICAgICAgICAgIGlmKCFmb3JtRGF0YVxuICAgICAgICAgICAgICAgIHx8ICFmb3JtRGF0YVsnem90ZXJvLW9ubGluZS1hcGlLZXknXVxuICAgICAgICAgICAgICAgIHx8IGZvcm1EYXRhWyd6b3Rlcm8tb25saW5lLWFwaUtleSddLnRyaW0oKSA9PT0gJydcbiAgICAgICAgICAgICAgICB8fCBmb3JtRGF0YVsnem90ZXJvLW9ubGluZS11c2VyT3JHcm91cCddICE9PSAnZ3JvdXAnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IGdldENsaWVudFdpdGhvdXRTdG9yZShmb3JtRGF0YVsnem90ZXJvLW9ubGluZS1hcGlLZXknXSlcbiAgICAgICAgICAgIGxhdGVzdExvYWRlZEdyb3VwcyA9IGF3YWl0IGNsaWVudC5ncm91cHMoKVxuXG4gICAgICAgICAgICByZXR1cm4gbGF0ZXN0TG9hZGVkR3JvdXBzLm1hcChyID0+IFtyLmlkLCByLm5hbWVdKVxuICAgICAgICB9LFxuICAgIH1cbl1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgaWQ6ICd6b3Rlcm8tb25saW5lJyxcbiAgICBkaXNwbGF5TmFtZTogJ1pvdGVyby5vcmcgKENsb3VkIFZlcnNpb24pJyxcbiAgICBpc1ZhbGlkUmVjb3JkLFxuICAgIHJlbmRlckVudHJ5LFxuICAgIGZpZWxkcyxcbiAgICBzeW5jXG59IiwiY29uc3QgdGhyb3R0bGUgPSByZXF1aXJlKCcuLi8uLi9saWIvdGhyb3R0bGUvdGhyb3R0bGUnKTtcbmNvbnN0IGVzY2FwZUlEID0gaWQgPT4gaWQucmVwbGFjZSgvW15hLXpBLVowLTlcXC1dL2csIFwieFwiKTtcblxuY2xhc3MgU2ltcGxlUGVyc2l0ZW5jeURyaXZlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IHt9XG4gICAgfVxuXG4gICAgYXN5bmMgc2V0KGlkLCBhdHRyKSB7XG4gICAgICAgIHRoaXMuZGF0YVtpZF0gPSB7IGlkLCAuLi5hdHRyIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVtpZF1cbiAgICB9XG5cbiAgICBhc3luYyBhbGwoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuZGF0YSlcbiAgICB9XG5cbiAgICBhc3luYyBnZXQoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVtpZF1cbiAgICB9XG5cbiAgICBhc3luYyBkZWxldGVBbGwoKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IHt9XG4gICAgfVxufVxuXG5jbGFzcyBSZWZlcmVuY2VTdG9yZSB7XG5cbiAgICBzdGF0aWMgY2l0ZWRJbkN1cnJlbnREb2N1bWVudCgpIHtcbiAgICAgICAgaWYoZG9jdW1lbnQgJiYgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50XG4gICAgICAgICAgICAgICAgLnF1ZXJ5U2VsZWN0b3JBbGwoJy5yZWZlcmVuY2VbZGF0YS1leHRlcm5hbD1cInRydWVcIl0nKVxuICAgICAgICAgICAgICAgIC5tYXAoZWwgPT4gZWwuZGF0YXNldC5yZWYpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW11cbiAgICB9XG5cbiAgICBzdGF0aWMgaXNDaXRlZEluQ3VycmVudERvY3VtZW50KGlkKSB7XG4gICAgICAgIHJldHVybiBSZWZlcmVuY2VTdG9yZS5jaXRlZEluQ3VycmVudERvY3VtZW50KCkuaW5jbHVkZXMoaWQpXG4gICAgfVxuXG4gICAgLy9GSVhNRTogbWFrZSB0aGlzIGNhbGN1bGF0ZWQgYXR0cmlidXRlIG9mIGZvcm1EYXRhXG4gICAgc3RhdGljIGdldFNvdXJjZUlEKGZvcm1EYXRhKSB7XG4gICAgICAgIGlmKGZvcm1EYXRhWyd0eXBlJ10gPT09ICd6b3Rlcm8tb25saW5lJykge1xuICAgICAgICAgICAgaWYoZm9ybURhdGFbJ3pvdGVyby1vbmxpbmUtdXNlck9yR3JvdXAnXSA9PT0gJ3VzZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGB6b3Rlcm8tb25saW5lLXVzZXItJHtmb3JtRGF0YVsnem90ZXJvLW9ubGluZS11c2VySUQnXX1gXG4gICAgICAgICAgICB9IGVsc2UgaWYoZm9ybURhdGFbJ3pvdGVyby1vbmxpbmUtdXNlck9yR3JvdXAnXSA9PT0gJ2dyb3VwJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBgem90ZXJvLW9ubGluZS1ncm91cC0ke2Zvcm1EYXRhWyd6b3Rlcm8tb25saW5lLWdyb3VwSUQnXX1gXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZihmb3JtRGF0YVsndHlwZSddID09PSAnem90ZXJvLWRlc2t0b3AnKSB7XG4gICAgICAgICAgICByZXR1cm4gYHpvdGVyby1kZXNrdG9wLSR7Zm9ybURhdGFbJ3pvdGVyby1kZXNrdG9wLWxpYnJhcnlJRCddfS0ke2Zvcm1EYXRhWyd6b3Rlcm8tZGVza3RvcC1jb2xsZWN0aW9uSUQnXX1gXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvcihjb250ZW50SWQsIFBlcnNpdGVuY3lEcml2ZXIgPSBTaW1wbGVQZXJzaXRlbmN5RHJpdmVyKSB7XG4gICAgICAgIHRoaXMuY29udGVudElkID0gY29udGVudElkXG4gICAgICAgIHRoaXMuZGF0YSA9IHt9XG4gICAgICAgIHRoaXMucGVyc2lzdGVudFJlZmVyZW5jZVN0b3JlID0gbmV3IFBlcnNpdGVuY3lEcml2ZXIoJ3JlZmVyZW5jZScpXG4gICAgICAgIHRoaXMucGVyc2lzdGVudFJlZmVyZW5jZVNvdXJjZVN0b3JlID0gbmV3IFBlcnNpdGVuY3lEcml2ZXIoJ3JlZmVyZW5jZV9zb3VyY2VzJylcbiAgICB9XG5cbiAgICBpbml0Q2FjaGUgPSB0aHJvdHRsZSgxMDAsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgYWxsUmVmc0Zyb21TdG9yZSA9IGF3YWl0IHRoaXMucGVyc2lzdGVudFJlZmVyZW5jZVN0b3JlLmFsbCh7IHVwZGF0ZWRTaW5jZTogdGhpcy5sYXN0Q2FjaGVVcGRhdGUgfSlcbiAgICAgICAgdGhpcy5sYXN0Q2FjaGVVcGRhdGUgPSBEYXRlLm5vdygpXG5cbiAgICAgICAgYWxsUmVmc0Zyb21TdG9yZVxuICAgICAgICAgICAgLmZpbHRlcihyID0+IChyLmNvbnRlbnRJZCA9PT0gdGhpcy5jb250ZW50SWQgfHwgci5yZWZlcmVuY2VTb3VyY2UgIT09ICdpbnRlcm4nKSlcbiAgICAgICAgICAgIC5mb3JFYWNoKHIgPT4geyB0aGlzLmRhdGFbci5pZF0gPSByIH0pXG4gICAgfSlcblxuICAgIHNldChpZCwgYXR0cikge1xuICAgICAgICBpZCA9IGVzY2FwZUlEKGlkKVxuXG4gICAgICAgIHZhciBmaWx0ZXJlZEF0dHIgPSB7XG4gICAgICAgICAgICAuLi5hdHRyLFxuICAgICAgICAgICAgY29udGVudElkOiB0aGlzLmNvbnRlbnRJZCxcbiAgICAgICAgICAgIGxvb2t1cElkOiAoYXR0ci5sb29rdXBJZCB8fCAnJykudHJpbSgpLFxuICAgICAgICAgICAgdXJsOiAoYXR0ci51cmwgfHwgJycpLnRyaW0oKSxcbiAgICAgICAgICAgIGRhdGU6IChhdHRyLmRhdGUgfHwgJycpLnRyaW0oKSxcbiAgICAgICAgICAgIHR5cGU6IChhdHRyLnR5cGUgfHwgJycpLnRyaW0oKSxcbiAgICAgICAgICAgIGF1dGhvcjogKGF0dHIuYXV0aG9yIHx8ICcnKS50cmltKCksXG4gICAgICAgICAgICB0aXRsZTogKGF0dHIudGl0bGUgfHwgJycpLnRyaW0oKSxcbiAgICAgICAgICAgIHN1YnRpdGxlOiAoYXR0ci5zdWJ0aXRsZSB8fCAnJykudHJpbSgpLFxuICAgICAgICAgICAgYm9va3RpdGxlOiAoYXR0ci5ib29rdGl0bGUgfHwgJycpLnRyaW0oKSxcbiAgICAgICAgICAgIG9yZ2FuaXphdGlvbjogKGF0dHIub3JnYW5pemF0aW9uIHx8ICcnKS50cmltKCksXG4gICAgICAgICAgICBqb3VybmFsOiAoYXR0ci5qb3VybmFsIHx8ICcnKS50cmltKCksXG4gICAgICAgICAgICBwdWJsaXNoZXI6IChhdHRyLnB1Ymxpc2hlciB8fCAnJykudHJpbSgpLFxuICAgICAgICAgICAgc2Nob29sOiAoYXR0ci5zY2hvb2wgfHwgJycpLnRyaW0oKSxcbiAgICAgICAgICAgIGluc3RpdHV0aW9uOiAoYXR0ci5pbnN0aXR1dGlvbiB8fCAnJykudHJpbSgpLFxuICAgICAgICAgICAgZWRpdG9yOiAoYXR0ci5lZGl0b3IgfHwgJycpLnRyaW0oKSxcbiAgICAgICAgICAgIHNlcmllczogKGF0dHIuc2VyaWVzIHx8ICcnKS50cmltKCksXG4gICAgICAgICAgICB5ZWFyOiAoYXR0ci55ZWFyIHx8ICcnKS50cmltKCksXG4gICAgICAgICAgICBtb250aDogKGF0dHIubW9udGggfHwgJycpLnRyaW0oKSxcbiAgICAgICAgICAgIGVkaXRpb246IChhdHRyLmVkaXRpb24gfHwgJycpLnRyaW0oKSxcbiAgICAgICAgICAgIHZvbHVtZTogKGF0dHIudm9sdW1lIHx8ICcnKS50cmltKCksXG4gICAgICAgICAgICBudW1iZXI6IChhdHRyLm51bWJlciB8fCAnJykudHJpbSgpLFxuICAgICAgICAgICAgY2hhcHRlcjogKGF0dHIuY2hhcHRlciB8fCAnJykudHJpbSgpLFxuICAgICAgICAgICAgcGFnZXM6IChhdHRyLnBhZ2VzIHx8ICcnKS50cmltKCksXG4gICAgICAgICAgICBfZGVsZXRlZDogZmFsc2UsXG4gICAgICAgICAgICBpZDogaWRcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGF0YVtpZF0gPSBmaWx0ZXJlZEF0dHJcblxuICAgICAgICByZXR1cm4gdGhpcy5wZXJzaXN0ZW50UmVmZXJlbmNlU3RvcmUuc2V0KGlkLCBmaWx0ZXJlZEF0dHIpXG4gICAgfVxuXG4gICAgZ2V0KGlkKSB7XG4gICAgICAgIGlkID0gZXNjYXBlSUQoaWQpXG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVtpZF1cbiAgICB9XG5cbiAgICBkZWxldGUoaWQpIHtcbiAgICAgICAgaWQgPSBlc2NhcGVJRChpZClcblxuICAgICAgICB0aGlzLmRhdGFbaWRdLl9kZWxldGVkID0gdHJ1ZVxuXG4gICAgICAgIHRoaXMucGVyc2lzdGVudFJlZmVyZW5jZVN0b3JlLmdldChpZCkudGhlbihpdGVtID0+IHtcbiAgICAgICAgICAgIHRoaXMucGVyc2lzdGVudFJlZmVyZW5jZVN0b3JlLnNldChpZCwge1xuICAgICAgICAgICAgICAgIC4uLml0ZW0sXG4gICAgICAgICAgICAgICAgX2RlbGV0ZWQ6IHRydWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgYWxsKHdpdGhJRCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge31cblxuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmRhdGEpLmZvckVhY2gocmVmSWQgPT4ge1xuICAgICAgICAgICAgaWYoIXRoaXMuaXNSZWZFbXB0eShyZWZJZCkgJiYgKCF0aGlzLmRhdGFbcmVmSWRdLl9kZWxldGVkIHx8IFJlZmVyZW5jZVN0b3JlLmlzQ2l0ZWRJbkN1cnJlbnREb2N1bWVudChyZWZJZCkpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W3JlZklkXSA9IHRoaXMuZGF0YVtyZWZJZF1cblxuICAgICAgICAgICAgICAgIGlmKHdpdGhJRCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbcmVmSWRdLmlkID0gcmVmSWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYWRkUmVmZXJlbmNlRGF0YShkYXRhKSB7XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGRhdGEpLmZvckVhY2gocmVmUmVjb3JkID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0KHJlZlJlY29yZFswXSwgcmVmUmVjb3JkWzFdKTtcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBhc3luYyBhbGxBc3luYyh3aXRoSUQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9XG5cbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5kYXRhKS5mb3JFYWNoKHJlZklkID0+IHtcbiAgICAgICAgICAgIGlmKCF0aGlzLmlzUmVmRW1wdHkocmVmSWQpICYmICghdGhpcy5kYXRhW3JlZklkXS5fZGVsZXRlZCB8fCBSZWZlcmVuY2VTdG9yZS5pc0NpdGVkSW5DdXJyZW50RG9jdW1lbnQocmVmSWQpKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtyZWZJZF0gPSB0aGlzLmRhdGFbcmVmSWRdXG5cbiAgICAgICAgICAgICAgICBpZih3aXRoSUQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3JlZklkXS5pZCA9IHJlZklkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGlzUmVmRW1wdHkoaWQpIHtcbiAgICAgICAgaWQgPSBlc2NhcGVJRChpZClcblxuICAgICAgICB2YXIgcmVjb3JkID0gdGhpcy5kYXRhW2lkXTtcblxuICAgICAgICByZXR1cm4gcmVjb3JkLmF1dGhvciA9PT0gJydcbiAgICAgICAgICAgICYmIHJlY29yZC50aXRsZSA9PT0gJydcbiAgICAgICAgICAgICYmIHJlY29yZC51cmwgPT09ICcnO1xuICAgIH1cblxuICAgIGFzeW5jIGRlbGV0ZUFsbFNvdXJjZXMoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMucGVyc2lzdGVudFJlZmVyZW5jZVNvdXJjZVN0b3JlLmRlbGV0ZUFsbCgpXG4gICAgfVxuXG4gICAgYXN5bmMgYWRkU291cmNlKGF0dHIpIHtcbiAgICAgICAgY29uc3QgaWQgPSBSZWZlcmVuY2VTdG9yZS5nZXRTb3VyY2VJRChhdHRyKVxuXG4gICAgICAgIGlmKCFpZCkge1xuICAgICAgICAgICAgdGhyb3cgXCJ1bmFibGUgdG8gc2F2ZSByZWZlcmVuY2Ugc291cmNlXCJcbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IHRoaXMucGVyc2lzdGVudFJlZmVyZW5jZVNvdXJjZVN0b3JlLnNldChpZCwgYXR0cilcblxuICAgICAgICBjb25zdCBhbGxyZWZzID0gKGF3YWl0IHRoaXMucGVyc2lzdGVudFJlZmVyZW5jZVN0b3JlLmFsbCgpKVxuICAgICAgICAgICAgLmZpbHRlcihyID0+IHIuaWQgJiYgci5pZC5zdGFydHNXaXRoKGB6b3Rlcm8tb25saW5lLWl0ZW0tJHtpZC5zcGxpdCgnLScpWzNdfWApICYmIHIuX2RlbGV0ZWQpXG5cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoYWxscmVmcy5tYXAoaXRlbSA9PiB0aGlzLnNldChpdGVtLmlkLCBpdGVtKSkpXG4gICAgfVxuXG4gICAgYXN5bmMgY2xlYW51cFJlZmVyZW5jZXNGcm9tU291cmNlcygpIHtcbiAgICAgICAgY29uc3QgYWxsU291cmNlSWRzID0gKGF3YWl0IHRoaXMuZ2V0QWxsU291cmNlcygpKS5tYXAoc3JjID0+IHNyYy5pZClcbiAgICAgICAgY29uc3QgYWxsUmVmcyA9IHRoaXMuYWxsKHRydWUpXG5cbiAgICAgICAgY29uc3QgcmVmc1RvQmVEZWxldGVkID0gT2JqZWN0LnZhbHVlcyhhbGxSZWZzKVxuICAgICAgICAgICAgLmZpbHRlcihyZWYgPT4ge1xuICAgICAgICAgICAgICAgIGlmKCFyZWYucmVmZXJlbmNlU291cmNlIHx8IHJlZi5yZWZlcmVuY2VTb3VyY2UgPT09ICdpbnRlcm4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiAhYWxsU291cmNlSWRzLmZpbmQoc3JjSWQgPT4gc3JjSWQgPT09IHJlZi5yZWZlcmVuY2VTb3VyY2UpXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIHJlZnNUb0JlRGVsZXRlZC5mb3JFYWNoKHJlZiA9PiB7XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZShyZWYuaWQpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0QWxsU291cmNlcygpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucGVyc2lzdGVudFJlZmVyZW5jZVNvdXJjZVN0b3JlLmFsbCgpXG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlZmVyZW5jZVN0b3JlOyIsInZhciB1dGlscyA9IHJlcXVpcmUoJy4uL2xpYi9waXhlbHNjaHVic2VyL3V0aWxzJyksXG4gICAgRGVjbGFyYXRpdkZvcm0gPSByZXF1aXJlKCcuLi9saWIvZGVjbGFyYXRpdl9mb3Jtcy9zcmMvZGVjbGFyYXRpdl9mb3JtJyk7XG5cbmZ1bmN0aW9uIFNlY3Rpb25UeXBlU2VsZWN0b3JDb250cm9sKG9uQ2hhbmdlQ2FsbGJhY2ssIG9uQ2hhbmdlQ2FsbGJhY2tDb250ZXh0LCBlZGl0b3IpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICB0aGlzLnNlY3Rpb25UeXBlU2VsZWN0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLnNlY3Rpb25UeXBlU2VsZWN0b3IuaWQgPSAnc2VjdGlvblR5cGVTZWxlY3Rvcic7XG5cbiAgICB0aGlzLnNlY3Rpb25UeXBlU2VsZWN0b3IuaW5uZXJIVE1MID0gJzxzcGFuIGNsYXNzPVwib3B0aW9uLWJ0biBkZWxldGUtb3B0aW9uLWJ0blwiIGRhdGEtb3B0aW9uLWZvcj1cImltZ1wiPjxpIGNsYXNzPVwiZmFzIGZhLXRyYXNoXCI+PC9pPjwvc3Bhbj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwib3B0aW9uLWJ0biBkZWxldGUtb3B0aW9uLWJ0blwiIGRhdGEtb3B0aW9uLWZvcj1cInRhYmxlXCI+PGkgY2xhc3M9XCJmYXMgZmEtdHJhc2hcIj48L2k+PC9zcGFuPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJvcHRpb24tYnRuIGRlbGV0ZS1vcHRpb24tYnRuXCIgZGF0YS1vcHRpb24tZm9yPVwiY29kZVwiPjxpIGNsYXNzPVwiZmFzIGZhLXRyYXNoXCI+PC9pPjwvc3Bhbj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwib3B0aW9uLWJ0biBkZWxldGUtb3B0aW9uLWJ0blwiIGRhdGEtb3B0aW9uLWZvcj1cInRvY1wiPjxpIGNsYXNzPVwiZmFzIGZhLXRyYXNoXCI+PC9pPjwvc3Bhbj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwib3B0aW9uLWJ0biBkZWxldGUtb3B0aW9uLWJ0blwiIGRhdGEtb3B0aW9uLWZvcj1cImJxdW90ZVwiPjxpIGNsYXNzPVwiZmFzIGZhLXRyYXNoXCI+PC9pPjwvc3Bhbj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwib3B0aW9uLWJ0biBkZWxldGUtb3B0aW9uLWJ0blwiIGRhdGEtb3B0aW9uLWZvcj1cImJpYmxpb2dyYXBoaWVcIj48aSBjbGFzcz1cImZhcyBmYS10cmFzaFwiPjwvaT48L3NwYW4+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cIm9wdGlvbi1idG4gZGVsZXRlLW9wdGlvbi1idG5cIiBkYXRhLW9wdGlvbi1mb3I9XCJmb290bm90ZXNcIj48aSBjbGFzcz1cImZhcyBmYS10cmFzaFwiPjwvaT48L3NwYW4+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cIm9wdGlvbi1idG4gZGVsZXRlLW9wdGlvbi1idG5cIiBkYXRhLW9wdGlvbi1mb3I9XCJmb3JtdWxhXCI+PGkgY2xhc3M9XCJmYXMgZmEtdHJhc2hcIj48L2k+PC9zcGFuPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJvcHRpb24tYnRuIGRlbGV0ZS1vcHRpb24tYnRuXCIgZGF0YS1vcHRpb24tZm9yPVwibWVybWFpZFwiPjxpIGNsYXNzPVwiZmFzIGZhLXRyYXNoXCI+PC9pPjwvc3Bhbj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwib3B0aW9uLWJ0biBjb25maWctb3B0aW9uLWJ0blwiIGRhdGEtb3B0aW9uLWZvcj1cImNvZGVcIj48aSBjbGFzcz1cImZhcyBmYS1jb2dcIj48L2k+PC9zcGFuPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJvcHRpb24tYnRuIGNvbmZpZy1vcHRpb24tYnRuXCIgZGF0YS1vcHRpb24tZm9yPVwidGFibGVcIj48aSBjbGFzcz1cImZhcyBmYS1jb2dcIj48L2k+PC9zcGFuPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJvcHRpb24tYnRuIGNvbmZpZy1vcHRpb24tYnRuXCIgZGF0YS1vcHRpb24tZm9yPVwiaW1nXCI+PGkgY2xhc3M9XCJmYXMgZmEtY29nXCI+PC9pPjwvc3Bhbj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwib3B0aW9uLWJ0biBjb25maWctb3B0aW9uLWJ0blwiIGRhdGEtb3B0aW9uLWZvcj1cImJxdW90ZVwiPjxpIGNsYXNzPVwiZmFzIGZhLWNvZ1wiPjwvaT48L3NwYW4+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cIm9wdGlvbi1idG4gY29uZmlnLW9wdGlvbi1idG5cIiBkYXRhLW9wdGlvbi1mb3I9XCJiaWJsaW9ncmFwaGllXCI+PGkgY2xhc3M9XCJmYXMgZmEtY29nXCI+PC9pPjwvc3Bhbj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwib3B0aW9uLWJ0biBjb25maWctb3B0aW9uLWJ0blwiIGRhdGEtb3B0aW9uLWZvcj1cImZvb3Rub3Rlc1wiPjxpIGNsYXNzPVwiZmFzIGZhLWNvZ1wiPjwvaT48L3NwYW4+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cIm9wdGlvbi1idG4gY29uZmlnLW9wdGlvbi1idG5cIiBkYXRhLW9wdGlvbi1mb3I9XCJmb3JtdWxhXCI+PGkgY2xhc3M9XCJmYXMgZmEtY29nXCI+PC9pPjwvc3Bhbj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwib3B0aW9uLWJ0biBjb25maWctb3B0aW9uLWJ0blwiIGRhdGEtb3B0aW9uLWZvcj1cIm1lcm1haWRcIj48aSBjbGFzcz1cImZhcyBmYS1jb2dcIj48L2k+PC9zcGFuPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJvcHRpb24tYnRuIGNvbmZpZy1vcHRpb24tYnRuXCIgZGF0YS1vcHRpb24tZm9yPVwiaDJcIj48aSBjbGFzcz1cImZhcyBmYS1jb2dcIj48L2k+PC9zcGFuPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJzZWN0aW9uVHlwZUJ0blwiIGRhdGEtdHlwZT1cImgxXCI+dGl0bGU8L3NwYW4+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cInNlY3Rpb25UeXBlQnRuXCIgZGF0YS10eXBlPVwiaDJcIiB1bmFubm90YXRlZC1jYXB0aW9uPVwiaDFcIiB1bmFjdGl2ZS1jYXB0aW9uPVwiaGVhZGluZy0xXCI+aGVhZGluZy0xPC9zcGFuPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJzZWN0aW9uVHlwZUJ0blwiIGRhdGEtdHlwZT1cImgzXCIgdW5hbm5vdGF0ZWQtY2FwdGlvbj1cImgyXCIgdW5hY3RpdmUtY2FwdGlvbj1cImhlYWRpbmctMlwiPmhlYWRpbmctMjwvc3Bhbj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwic2VjdGlvblR5cGVCdG5cIiBkYXRhLXR5cGU9XCJoNFwiIHVuYW5ub3RhdGVkLWNhcHRpb249XCJoM1wiIHVuYWN0aXZlLWNhcHRpb249XCJoZWFkaW5nLTNcIj5oZWFkaW5nLTM8L3NwYW4+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cInNlY3Rpb25UeXBlQnRuXCIgZGF0YS10eXBlPVwiaDVcIiB1bmFubm90YXRlZC1jYXB0aW9uPVwiaDRcIiB1bmFjdGl2ZS1jYXB0aW9uPVwiaGVhZGluZy00XCI+aGVhZGluZy00PC9zcGFuPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJzZWN0aW9uVHlwZUJ0blwiIGRhdGEtdHlwZT1cInBcIj5wYXJhZ3JhcGg8L3NwYW4+JytcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwic2VjdGlvblR5cGVCdG4gbm90Q2hhbmdlYWJsZVwiIGRhdGEtdHlwZT1cImJxdW90ZVwiIHVuYW5ub3RhdGVkLWNhcHRpb249XCJxdW90ZVwiIHVuYWN0aXZlLWNhcHRpb249XCJibG9ja3F1b3RlXCI+YmxvY2txdW90ZTwvc3Bhbj4nK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJzZWN0aW9uVHlwZUJ0biBub3RDaGFuZ2VhYmxlXCIgZGF0YS10eXBlPVwidGFibGVcIj50YWJsZTwvc3Bhbj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwic2VjdGlvblR5cGVCdG5cIiBkYXRhLXR5cGU9XCJjb2RlXCIgZGF0YS1zZWN0aW9uLXRhZz1cInByZVwiIHVuYW5ub3RhdGVkLWNhcHRpb249XCJjb2RlXCI+Y29kZTwvc3Bhbj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwic2VjdGlvblR5cGVCdG4gbm90Q2hhbmdlYWJsZVwiIGRhdGEtdHlwZT1cInVsXCIgdW5hbm5vdGF0ZWQtY2FwdGlvbj1cImxpc3RcIiB1bmFjdGl2ZS1jYXB0aW9uPVwidW5vcmRlcmVkLWxpc3RcIj51bm9yZGVyZWQtbGlzdDwvc3Bhbj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwic2VjdGlvblR5cGVCdG4gbm90Q2hhbmdlYWJsZVwiIGRhdGEtdHlwZT1cIm9sXCIgdW5hbm5vdGF0ZWQtY2FwdGlvbj1cImxpc3RcIiB1bmFjdGl2ZS1jYXB0aW9uPVwib3JkZXJlZC1saXN0XCI+b3JkZXJlZC1saXN0PC9zcGFuPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJzZWN0aW9uVHlwZUJ0biBub3RDaGFuZ2VhYmxlXCIgZGF0YS10eXBlPVwiaW1nXCIgZGF0YS1zZWN0aW9uLXRhZz1cImZpZ3VyZVwiPmltYWdlPC9zcGFuPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJzZWN0aW9uVHlwZUJ0biBub3RDaGFuZ2VhYmxlXCIgZGF0YS10eXBlPVwiZm9ybXVsYVwiPmZvcm11bGE8L3NwYW4+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cInNlY3Rpb25UeXBlQnRuIG5vdENoYW5nZWFibGVcIiBkYXRhLXR5cGU9XCJtZXJtYWlkXCI+bWVybWFpZDwvc3Bhbj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwic2VjdGlvblR5cGVCdG4gbm90Q2hhbmdlYWJsZVwiIGRhdGEtdHlwZT1cInRvY1wiIGRhdGEtc2VjdGlvbi10YWc9XCJuYXZcIj50b2M8L3NwYW4+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cInNlY3Rpb25UeXBlQnRuIG5vdENoYW5nZWFibGVcIiBkYXRhLXR5cGU9XCJiaWJsaW9ncmFwaGllXCIgdW5hbm5vdGF0ZWQtY2FwdGlvbj1cImJpYlwiIHVuYWN0aXZlLWNhcHRpb249XCJiaWJsaW9ncmFwaGllXCI+YmlibGlvZ3JhcGhpZTwvc3Bhbj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwic2VjdGlvblR5cGVCdG5cIiBkYXRhLXR5cGU9XCJoMihhYnN0cmFjdClcIj5hYnN0cmFjdDwvc3Bhbj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwic2VjdGlvblR5cGVCdG5cIiBkYXRhLXR5cGU9XCJoMihkZWNsYXJhdGlvbilcIj5kZWNsYXJhdGlvbjwvc3Bhbj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwic2VjdGlvblR5cGVCdG5cIiBkYXRhLXR5cGU9XCJoMihhcHBlbmRpeClcIj5hcHBlbmRpeDwvc3Bhbj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwic2VjdGlvblR5cGVCdG5cIiBkYXRhLXR5cGU9XCJoMihhY2tub3dsZWRnZW1lbnQpXCI+YWNrbm93bGVkZ2VtZW50PC9zcGFuPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJzZWN0aW9uVHlwZUJ0biBub3RDaGFuZ2VhYmxlXCIgZGF0YS10eXBlPVwiZm9vdG5vdGVzXCI+Zm9vdG5vdGVzPC9zcGFuPic7XG5cbiAgICB0aGlzLmJ1dHRvbnMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLnNlY3Rpb25UeXBlU2VsZWN0b3IuY2hpbGRyZW4pO1xuXG4gICAgdGhpcy5zZWN0aW9uVHlwZVNlbGVjdG9yLm9ubW91c2VvdmVyID0gZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgaXNUeXBlQnRuID0gZS50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdzZWN0aW9uVHlwZUJ0bicpO1xuXG4gICAgICAgIGlmKGUudGFyZ2V0LmlkID09PSAnc2VjdGlvblR5cGVTZWxlY3RvcicpIHsgcmV0dXJuIH1cblxuICAgICAgICBzZWxmLmJ1dHRvbnMuZm9yRWFjaChmdW5jdGlvbihiKSB7XG4gICAgICAgICAgICBpc1R5cGVCdG4gPyBiLmNsYXNzTGlzdC5hZGQoJ2hvdmVyJykgOiBiLmNsYXNzTGlzdC5yZW1vdmUoJ2hvdmVyJyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuc2VjdGlvblR5cGVTZWxlY3Rvci5vbm1vdXNlbGVhdmUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuYnV0dG9ucy5mb3JFYWNoKGZ1bmN0aW9uKGIpIHsgYi5jbGFzc0xpc3QucmVtb3ZlKCdob3ZlcicpIH0pO1xuICAgIH1cblxuICAgIHRoaXMuYnV0dG9ucy5maWx0ZXIoZnVuY3Rpb24oYnRuKSB7XG4gICAgICAgIHJldHVybiBidG4uY2xhc3NMaXN0LmNvbnRhaW5zKCdkZWxldGUtb3B0aW9uLWJ0bicpO1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24oYnRuKSB7XG4gICAgICAgIGJ0bi5vbmNsaWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZihzZWxmLmVkaXRvcikge1xuICAgICAgICAgICAgICAgIGlmKHNlbGYuc2VjdGlvbkVsZW1lbnQub25VbmZvY3VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2VjdGlvbkVsZW1lbnQub25VbmZvY3VzKHNlbGYuZWRpdG9yKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNlbGYuZWRpdG9yLnJlbW92ZVNlY3Rpb24oc2VsZi5zZWN0aW9uRWxlbWVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYuc2VjdGlvbkVsZW1lbnQucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChzZWxmLnNlY3Rpb25FbGVtZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5oaWRlKCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuYnV0dG9ucy5maWx0ZXIoZnVuY3Rpb24oYnRuKSB7XG4gICAgICAgIHJldHVybiBidG4uY2xhc3NMaXN0LmNvbnRhaW5zKCdjb25maWctb3B0aW9uLWJ0bicpO1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24oYnRuKSB7XG4gICAgICAgIGJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGlmKHNlbGYuc2VjdGlvbkVsZW1lbnQuc2VjdGlvblR5cGUgJiYgc2VsZi5zZWN0aW9uRWxlbWVudC5zZWN0aW9uVHlwZS5nZXRPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZvcm0gPSBuZXcgRGVjbGFyYXRpdkZvcm0oe2ZpZWxkczogc2VsZi5zZWN0aW9uRWxlbWVudC5zZWN0aW9uVHlwZS5nZXRPcHRpb25zKHNlbGYuc2VjdGlvbkVsZW1lbnQpfSwgZnVuY3Rpb24oZm9ybURhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWN0aW9uRWxlbWVudC5zZWN0aW9uVHlwZS5vbk9wdGlvbnNDaGFuZ2UoZm9ybURhdGEsIHNlbGYuZWRpdG9yKVxuICAgICAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZm9ybS5vcGVuSW5Nb2RhbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMuc2VjdGlvblR5cGVTZWxlY3Rvci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIGNsaWNrZWRCdXR0b24gPSBlLnRhcmdldCxcbiAgICAgICAgICAgIGN1cnJlbnRTZWN0aW9uQnRuID0gY2xpY2tlZEJ1dHRvbi5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3IoJy5zZWN0aW9uVHlwZUJ0bi5hY3RpdmUnKSxcbiAgICAgICAgICAgIGN1cnJlbnRTZWN0aW9uSXNDaGFuZ2VhYmxlID0gY3VycmVudFNlY3Rpb25CdG4gJiYgIWN1cnJlbnRTZWN0aW9uQnRuLmNsYXNzTGlzdC5jb250YWlucygnbm90Q2hhbmdlYWJsZScpLFxuICAgICAgICAgICAgYW5ub3RhdGlvbiwgc2VjdGlvblR5cGVOYW1lO1xuXG4gICAgICAgIGlmKGNsaWNrZWRCdXR0b24uZGF0YXNldC50eXBlICYmIGN1cnJlbnRTZWN0aW9uSXNDaGFuZ2VhYmxlKSB7XG4gICAgICAgICAgICBzZWN0aW9uVHlwZU5hbWUgPSBjbGlja2VkQnV0dG9uLmRhdGFzZXQudHlwZS5zcGxpdCgvXFwofFxcKS8pWzBdO1xuICAgICAgICAgICAgYW5ub3RhdGlvbiA9IGNsaWNrZWRCdXR0b24uZGF0YXNldC50eXBlLnNwbGl0KC9cXCh8XFwpLylbMV07XG4gICAgICAgICAgICBvbkNoYW5nZUNhbGxiYWNrLmFwcGx5KG9uQ2hhbmdlQ2FsbGJhY2tDb250ZXh0LCBbc2VjdGlvblR5cGVOYW1lLCBhbm5vdGF0aW9uXSk7XG4gICAgICAgICAgICBzZWxmLnNldEFjdGl2ZVNlbGVjdGlvbihjbGlja2VkQnV0dG9uLmRhdGFzZXQuc2VjdGlvblRhZyB8fCBjbGlja2VkQnV0dG9uLmRhdGFzZXQudHlwZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5zZWN0aW9uVHlwZVNlbGVjdG9yKTtcbn1cblxuU2VjdGlvblR5cGVTZWxlY3RvckNvbnRyb2wucHJvdG90eXBlID0ge1xuICAgIGdldFNlY3Rpb25UeXBlQnlTZWN0aW9uVGFnOiBmdW5jdGlvbihzZWN0aW9uVGFnKSB7XG4gICAgICAgIHZhciBidG4gPSB0aGlzLmJ1dHRvbnMuZmluZChmdW5jdGlvbiAoYnRuKSB7XG4gICAgICAgICAgICByZXR1cm4gYnRuLmRhdGFzZXQuc2VjdGlvblRhZyA9PT0gc2VjdGlvblRhZyB8fCBidG4uZGF0YXNldC50eXBlID09PSBzZWN0aW9uVGFnO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gYnRuICYmIGJ0bi5kYXRhc2V0ICYmIGJ0bi5kYXRhc2V0LnR5cGU7XG4gICAgfSxcblxuICAgIHNldEFjdGl2ZVNlbGVjdGlvbjogZnVuY3Rpb24oc2VjdGlvblRhZykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICB1bmFubm90YXRlZENhcHRpb24sXG4gICAgICAgICAgICB1bmFjdGl2ZUNhcHRpb24sXG4gICAgICAgICAgICBjYXB0aW9uQW5ub3RhdGlvbixcbiAgICAgICAgICAgIGFjdGl2ZUJ0bjtcblxuICAgICAgICB0aGlzLmJ1dHRvbnMuZm9yRWFjaChmdW5jdGlvbihidG4pIHtcbiAgICAgICAgICAgIGJ0bi5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgICAgICAgIGJ0bi5jbGFzc0xpc3QucmVtb3ZlKCd1bnVzYWJsZScpO1xuICAgICAgICAgICAgdmFyIHRhZ05hbWUgPSBidG4uZGF0YXNldC5zZWN0aW9uVGFnIHx8IGJ0bi5kYXRhc2V0LnR5cGU7XG5cbiAgICAgICAgICAgIHVuYW5ub3RhdGVkQ2FwdGlvbiA9IGJ0bi5nZXRBdHRyaWJ1dGUoJ3VuYW5ub3RhdGVkLWNhcHRpb24nKTtcbiAgICAgICAgICAgIHVuYWN0aXZlQ2FwdGlvbiA9IGJ0bi5nZXRBdHRyaWJ1dGUoJ3VuYWN0aXZlLWNhcHRpb24nKTtcblxuICAgICAgICAgICAgaWYodW5hbm5vdGF0ZWRDYXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgYnRuLmlubmVySFRNTCA9IHVuYW5ub3RhdGVkQ2FwdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYodGFnTmFtZSA9PT0gc2VjdGlvblRhZyB8fCBidG4uZGF0YXNldC5vcHRpb25Gb3IgPT09IHNlbGYuZ2V0U2VjdGlvblR5cGVCeVNlY3Rpb25UYWcoc2VjdGlvblRhZykpIHtcbiAgICAgICAgICAgICAgICBidG4uY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgYWN0aXZlQnRuID0gYnRuO1xuICAgICAgICAgICAgICAgIGlmKHVuYW5ub3RhdGVkQ2FwdGlvbiAmJlxuICAgICAgICAgICAgICAgICAgIHNlbGYuc2VjdGlvbkVsZW1lbnQgJiZcbiAgICAgICAgICAgICAgICAgICBzZWxmLnNlY3Rpb25FbGVtZW50LnNlY3Rpb25UeXBlICYmXG4gICAgICAgICAgICAgICAgICAgc2VsZi5zZWN0aW9uRWxlbWVudC5zZWN0aW9uVHlwZS5nZXRTZWN0aW9uVHlwZUNhcHRpb25Bbm5vdGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhcHRpb25Bbm5vdGF0aW9uID0gc2VsZi5zZWN0aW9uRWxlbWVudC5zZWN0aW9uVHlwZS5nZXRTZWN0aW9uVHlwZUNhcHRpb25Bbm5vdGF0aW9uKHNlbGYuc2VjdGlvbkVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodW5hY3RpdmVDYXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgYnRuLmlubmVySFRNTCA9IHVuYWN0aXZlQ2FwdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoY2FwdGlvbkFubm90YXRpb24pIHtcbiAgICAgICAgICAgICAgICBidG4uaW5uZXJIVE1MID0gdW5hbm5vdGF0ZWRDYXB0aW9uICsgJzxzcGFuIGNsYXNzPVwiYW5ub3RhdGlvblwiPignICsgY2FwdGlvbkFubm90YXRpb24gKyAnKTxzcGFuPic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhcHRpb25Bbm5vdGF0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdW5hY3RpdmVDYXB0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZihhY3RpdmVCdG4uY2xhc3NMaXN0LmNvbnRhaW5zKCdub3RDaGFuZ2VhYmxlJykpIHtcbiAgICAgICAgICAgIHRoaXMuYnV0dG9ucy5mb3JFYWNoKGZ1bmN0aW9uKGJ0bikge1xuICAgICAgICAgICAgICAgIGlmKGJ0biAhPT0gYWN0aXZlQnRuKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ0bi5jbGFzc0xpc3QuYWRkKCd1bnVzYWJsZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGhpZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VjdGlvblR5cGVTZWxlY3RvckVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2VjdGlvblR5cGVTZWxlY3RvcicpO1xuICAgICAgICBzZWN0aW9uVHlwZVNlbGVjdG9yRWxlbWVudC5zdHlsZS5sZWZ0ID0gLTEwMDAgKyAncHgnO1xuICAgICAgICBzZWN0aW9uVHlwZVNlbGVjdG9yRWxlbWVudC5zdHlsZS50b3AgPSAtMTAwMCArICdweCc7XG4gICAgfSxcblxuICAgIHVwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWN0aW9uRWxlbWVudCA9IHNlbGYuZWRpdG9yLmZvY3VzZWRTZWN0aW9uKCk7XG4gICAgICAgIGlmKHNlY3Rpb25FbGVtZW50ICYmIHNlY3Rpb25FbGVtZW50LnRhZ05hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QWN0aXZlU2VsZWN0aW9uKHNlY3Rpb25FbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZGlzcGxheU5leHRUbzogZnVuY3Rpb24oc2VjdGlvbkVsZW1lbnQsIHNraXBBbmltYXRpb24pIHtcbiAgICAgICAgaWYoIXNlY3Rpb25FbGVtZW50KSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgc2VjdGlvblBvc2l0aW9uID0gdXRpbHMuZ2V0RWxlbWVudFBvc2l0aW9uKHNlY3Rpb25FbGVtZW50KSxcbiAgICAgICAgICAgIHNlY3Rpb25UeXBlU2VsZWN0b3JFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NlY3Rpb25UeXBlU2VsZWN0b3InKSxcbiAgICAgICAgICAgIHNlY3Rpb25FbGVtZW50VG9wTWFyZ2luID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoc2VjdGlvbkVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoJ21hcmdpbi10b3AnKS5yZXBsYWNlKCdweCcsICcnKSksXG4gICAgICAgICAgICBwb3NYID0gc2VjdGlvblBvc2l0aW9uLngsXG4gICAgICAgICAgICBwb3NZID0gc2VjdGlvblBvc2l0aW9uLnksXG4gICAgICAgICAgICBtaW5ZID0gd2luZG93LnNjcm9sbFkgKyBzZWN0aW9uRWxlbWVudFRvcE1hcmdpbiArIDUsIC8vYWRkIDVweCBzbyB0aGF0IHRoZXJlIGlzIGEgc21hbGwgcm9vbSBiZXR3ZWVuIHRoZSBlbmQgb2YgdGhlIGJyb3dzZXIgc2NyZWVuIGFuZCB0aGUgc2VsZWN0b3IgYnV0dG9uXG4gICAgICAgICAgICBtYXhZID0gc2VjdGlvbkVsZW1lbnQub2Zmc2V0SGVpZ2h0ICsgc2VjdGlvbkVsZW1lbnQub2Zmc2V0VG9wIC0gc2VjdGlvblR5cGVTZWxlY3RvckVsZW1lbnQuY2hpbGRyZW5bMF0ub2Zmc2V0SGVpZ2h0IC0gMzAsXG4gICAgICAgICAgICBleGVjdXRlVXBkYXRlO1xuXG4gICAgICAgIHBvc1kgPSBwb3NZIDwgbWluWSA/IG1pblkgOiBwb3NZO1xuICAgICAgICBwb3NZID0gcG9zWSA+IG1heFkgPyBtYXhZIDogcG9zWTtcblxuICAgICAgICB0aGlzLnNlY3Rpb25FbGVtZW50ID0gc2VjdGlvbkVsZW1lbnQ7XG4gICAgICAgIHRoaXMuc2V0QWN0aXZlU2VsZWN0aW9uKHNlY3Rpb25FbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSk7XG5cbiAgICAgICAgaWYodGhpcy5kaXNwbGF5U2VjdGlvblR5cGVTZWxlY3RvclRpbWVvdXQpXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kaXNwbGF5U2VjdGlvblR5cGVTZWxlY3RvclRpbWVvdXQpO1xuXG4gICAgICAgIGV4ZWN1dGVVcGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlY3Rpb25UeXBlU2VsZWN0b3JFbGVtZW50LnN0eWxlLmxlZnQgPSBwb3NYICsgJ3B4JztcbiAgICAgICAgICAgIHNlY3Rpb25UeXBlU2VsZWN0b3JFbGVtZW50LnN0eWxlLnRvcCA9IHBvc1kgKyAncHgnO1xuICAgICAgICAgICAgaWYodXRpbHMuZ2V0RGlzdGFuY2VUb1JpZ2h0V2luZG93Qm9yZGVyKHNlbGYuZWRpdG9yLmNvbnRhaW5lckVsZW1lbnQpIDwgMTUwKSB7XG4gICAgICAgICAgICAgICAgc2VjdGlvblR5cGVTZWxlY3RvckVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnbGVzc1NwYWNlJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlY3Rpb25UeXBlU2VsZWN0b3JFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2xlc3NTcGFjZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoc2tpcEFuaW1hdGlvbikge1xuICAgICAgICAgICAgZXhlY3V0ZVVwZGF0ZSgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXlTZWN0aW9uVHlwZVNlbGVjdG9yVGltZW91dCA9IHNldFRpbWVvdXQoZXhlY3V0ZVVwZGF0ZSwgMTApO1xuICAgICAgICB9XG5cbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2VjdGlvblR5cGVTZWxlY3RvckNvbnRyb2w7XG4iLCJ2YXIgdXVpZCA9IHJlcXVpcmUoJ3V1aWQvdjEnKTtcblxuZnVuY3Rpb24gZ2V0U2VjdGlvbkVsZW1lbnQoKSB7XG4gICAgdmFyICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2JpYmxpb2dyYXBoaWUnKSxcbiAgICAgICAgIGhlYWRpbmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoMicpLFxuICAgICAgICAgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2JpYmxpb2dyYXBoaWUnKTtcbiAgICBoZWFkaW5nLmNsYXNzTGlzdC5hZGQoJ2JpYmxpb2dyYXBoaWUtaGVhZGluZycpO1xuICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZCgnYmlibGlvZ3JhcGhpZS1jb250ZW50Jyk7XG5cbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScsICdmYWxzZScpO1xuICAgIGhlYWRpbmcuc2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnLCAndHJ1ZScpO1xuICAgIGNvbnRlbnQuc2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnLCAnZmFsc2UnKTtcblxuICAgIGhlYWRpbmcuaW5uZXJIVE1MID0gJ0JpYmxpb2dyYXBoeSc7XG5cbiAgICBlbC5zZWN0aW9uVHlwZSA9IG1vZHVsZS5leHBvcnRzO1xuICAgIGVsLm9uRm9jdXMgPSBtb2R1bGUuZXhwb3J0cy5vbkZvY3VzO1xuICAgIGVsLm9uS2V5QmFja3NwYWNlID0gbW9kdWxlLmV4cG9ydHMub25LZXlCYWNrc3BhY2U7XG5cbiAgICBlbC5hcHBlbmRDaGlsZChoZWFkaW5nKTtcbiAgICBlbC5hcHBlbmRDaGlsZChjb250ZW50KTtcblxuICAgIHJldHVybiBlbDtcbn1cblxuT2JqZWN0LmFzc2lnbihtb2R1bGUuZXhwb3J0cywge1xuXG4gICAgbmFtZTogJ2JpYmxpb2dyYXBoaWUnLFxuXG4gICAgcHJlZmVycmVkQ2FyZXRQb3NpdGlvbmluZzogJ2VuZCcsXG5cbiAgICBlZGl0YWJsZUVsZW1lbnRTZWxlY3RvcjogJ2gyJyxcblxuICAgIGNvbnRlbnRSdWxlczoge1xuICAgICAgICAnYmlibGlvZ3JhcGhpZSc6IHtcbiAgICAgICAgICAgIHRhZ05hbWU6ICdiaWJsaW9ncmFwaGllJyxcbiAgICAgICAgICAgIGFsbG93ZWRBdHRyaWJ1dGVzOiBbJ2NsYXNzJywgJ2NvbnRlbnRlZGl0YWJsZSddLFxuICAgICAgICAgICAgYWxsb3dlZENsYXNzTmFtZXM6IFsnZm9jdXNlZCddLFxuICAgICAgICAgICAgYWxsb3dlZENoaWxkcmVuOiBbJ2JpYmxpb2dyYXBoaWUtaGVhZGluZycsICdiaWJsaW9ncmFwaGllLWNvbnRlbnQnXSxcbiAgICAgICAgICAgIGFsbG93ZWRUb0JlUm9vdDogdHJ1ZSxcbiAgICAgICAgICAgIGRlbGV0ZUlmRW1wdHk6IGZhbHNlLFxuICAgICAgICAgICAgZG9Ob3RCcmVha091dFJvb3RFbGVtZW50czogdHJ1ZSxcbiAgICAgICAgICAgIGJ1aWxkRW1wdHlFbGVtZW50OiBnZXRTZWN0aW9uRWxlbWVudFxuICAgICAgICB9LFxuXG4gICAgICAgICdiaWJsaW9ncmFwaGllLWhlYWRpbmcnOiB7XG4gICAgICAgICAgICB0YWdOYW1lOiAnaDInLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAnYmlibGlvZ3JhcGhpZS1oZWFkaW5nJyxcbiAgICAgICAgICAgIGFsbG93ZWRBdHRyaWJ1dGVzOiBbJ2lkJywgJ2NsYXNzJywgJ2NvbnRlbnRlZGl0YWJsZScsICd1bm51bWJlcmVkLWhlYWRpbmcnXSxcbiAgICAgICAgICAgIGFsbG93ZWRDbGFzc05hbWVzOiBbJ2JpYmxpb2dyYXBoaWUtaGVhZGluZyddLFxuICAgICAgICAgICAgYWxsb3dlZENoaWxkcmVuOiBbJyN0ZXh0J10sXG4gICAgICAgICAgICBwcnVuZVNwYWNlczogdHJ1ZSxcbiAgICAgICAgICAgIGJ1aWxkQXR0cmlidXRlczogW1xuICAgICAgICAgICAgICAgIHtuYW1lOiAnaWQnLCBidWlsZDogZnVuY3Rpb24oKSB7cmV0dXJuIHV1aWQoKX19LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAndW5udW1iZXJlZC1oZWFkaW5nJywgYnVpbGQ6IGZ1bmN0aW9uKCkge3JldHVybiAnWWVzJ319XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG5cbiAgICAgICAgJ2JpYmxpb2dyYXBoaWUtY29udGVudCc6IHtcbiAgICAgICAgICAgIHRhZ05hbWU6ICdkaXYnLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAnYmlibGlvZ3JhcGhpZS1jb250ZW50JyxcbiAgICAgICAgICAgIGFsbG93ZWRBdHRyaWJ1dGVzOiBbJ2NsYXNzJywgJ2NvbnRlbnRlZGl0YWJsZSddLFxuICAgICAgICAgICAgYWxsb3dlZENsYXNzTmFtZXM6IFsnYmlibGlvZ3JhcGhpZS1jb250ZW50J10sXG4gICAgICAgICAgICBhbGxvd2VkQ2hpbGRyZW46IFsnYmlibGlvZ3JhcGhpZS1lbnRyeSddLFxuICAgICAgICB9LFxuXG4gICAgICAgICdiaWJsaW9ncmFwaGllLWVudHJ5Jzoge1xuICAgICAgICAgICAgdGFnTmFtZTogJ2RpdicsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdlbnRyeScsXG4gICAgICAgICAgICBhbGxvd2VkQXR0cmlidXRlczogWydjbGFzcyddLFxuICAgICAgICAgICAgYWxsb3dlZENsYXNzTmFtZXM6IFsnZW50cnknLCAnbm90ZSddLFxuICAgICAgICAgICAgYWxsb3dlZENoaWxkcmVuOiBbJyN0ZXh0J10sXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZW5yaWNobWVudHM6IFtdLFxuXG4gICAgZ2V0U2VjdGlvbkVsZW1lbnQ6IGdldFNlY3Rpb25FbGVtZW50LFxuXG4gICAgZ2V0T3B0aW9uczogZnVuY3Rpb24oc2VjdGlvbkVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnbnVtYmVyZWRIZWFkaW5nJyxcbiAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZTogJ1Nob3VsZCB0aGUgaGVhZGluZyBiZSBudW1iZXJlZCcsXG4gICAgICAgICAgICAgICAgYWxsb3dlZFZhbHVlczogWydZZXMnLCAnTm8nXSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IHNlY3Rpb25FbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2gyJykuZ2V0QXR0cmlidXRlKCd1bm51bWJlcmVkLWhlYWRpbmcnKSA9PT0gJ1llcycgPyAnTm8nIDogJ1llcydcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG5cbiAgICBvbk9wdGlvbnNDaGFuZ2U6IGZ1bmN0aW9uKG9wdCwgZWRpdG9yKSB7XG4gICAgICAgIHZhciBzZWN0aW9uID0gZWRpdG9yLmZvY3VzZWRTZWN0aW9uKCk7XG4gICAgICAgIGlmKG9wdC5udW1iZXJlZEhlYWRpbmcgPT09ICdZZXMnIHx8IG9wdC5udW1iZXJlZEhlYWRpbmcgPT09ICdObycpIHtcbiAgICAgICAgICAgIHNlY3Rpb24ucXVlcnlTZWxlY3RvcignaDInKS5zZXRBdHRyaWJ1dGUoJ3VubnVtYmVyZWQtaGVhZGluZycsIG9wdC5udW1iZXJlZEhlYWRpbmcgPT09ICdZZXMnID8gJ05vJyA6ICdZZXMnKTtcbiAgICAgICAgICAgIHNlbGYuZWRpdG9yLnJlcGxhY2VTZWN0aW9uV2l0aEhUTUwoc2VjdGlvbiwgc2VjdGlvbi5vdXRlckhUTUwpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG9uRWRpdG9yQ29udGVudENoYW5nZWQ6IGZ1bmN0aW9uKG1vZGlmaWNhdGlvbkxvZykge1xuICAgICAgICBpZighbW9kaWZpY2F0aW9uTG9nLm1pZ2h0SW5jbHVkZVJlZmVyZW5jZVVwZGF0ZXMgJiYgIW1vZGlmaWNhdGlvbkxvZy5taWdodEluY2x1ZGVCaWJsaW9ncmFwaGllVXBkYXRlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJpYnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdiaWJsaW9ncmFwaGllIC5iaWJsaW9ncmFwaGllLWNvbnRlbnQnKSxcbiAgICAgICAgICAgIHJlZnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcucmVmZXJlbmNlW2RhdGEtZXh0ZXJuYWxdJykubWFwKGZ1bmN0aW9uKHIpIHsgcmV0dXJuIHIuZ2V0QXR0cmlidXRlKCdkYXRhLXJlZicpfSkudW5pcXVlKCksXG4gICAgICAgICAgICBhbGxSZWZzID0gbW9kdWxlLmV4cG9ydHMuZWRpdG9yLnJlZmVyZW5jZS5nZXRBbGxFeHRlcm5hbFJlZnMoKSwgcmVmRGF0YTtcblxuICAgICAgICBiaWJzLmZvckVhY2goZnVuY3Rpb24oYmliKSB7XG4gICAgICAgICAgICBiaWIuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgICAgICBpZihyZWZzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJpYi5pbm5lckhUTUwgKz0gJzxkaXYgY2xhc3M9XCJlbnRyeSBub3RlXCI+SW5zZXJ0IHJlZmVyZW5jZXMgdG8gc2VlIHRoZW0gaGVyZS48L2Rpdj4nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZWZzLmZvckVhY2goZnVuY3Rpb24ocmVmSWQpIHtcbiAgICAgICAgICAgICAgICByZWZEYXRhID0gYWxsUmVmc1tyZWZJZF07XG5cbiAgICAgICAgICAgICAgICBpZihyZWZEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0bXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgdG1wLmNsYXNzTGlzdC5hZGQoJ2VudHJ5JylcbiAgICAgICAgICAgICAgICAgICAgdG1wLnNldEF0dHJpYnV0ZSgnZGF0YS1yZWYnLCByZWZJZCk7XG4gICAgICAgICAgICAgICAgICAgIHRtcC5pbm5lckhUTUwgPSBbcmVmRGF0YS51cmwsIHJlZkRhdGEuYXV0aG9yLCByZWZEYXRhLnRpdGxlLCByZWZEYXRhLnllYXIsIChyZWZEYXRhLnB1Ymxpc2hlciB8fCByZWZEYXRhLmpvdXJuYWwpXS5maWx0ZXIoZnVuY3Rpb24oeCkge3JldHVybiB4fSkuam9pbignIC0gJyk7XG4gICAgICAgICAgICAgICAgICAgIHRtcC5vbmNsaWNrID0gZnVuY3Rpb24oKSB7IG1vZHVsZS5leHBvcnRzLmVkaXRvci5yZWZlcmVuY2Uuc2hvd0VkaXRFeHRlcm5hbFJlZkRpYWxvZyh0bXApIH07XG4gICAgICAgICAgICAgICAgICAgIGJpYi5hcHBlbmRDaGlsZCh0bXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgb25LZXlCYWNrc3BhY2U6IGZ1bmN0aW9uKGUsIGVkaXRvcikge1xuICAgICAgICB2YXIgaGVhZGluZyA9IGVkaXRvci5jYXJldC5nZXRDb250ZXh0RWxlbWVudCgnaDInLCB3aW5kb3cuZ2V0U2VsZWN0aW9uKCksIFtdKSxcbiAgICAgICAgICAgIHNlY3Rpb25JbmRleCA9IGVkaXRvci5pbmRleE9mKGVkaXRvci5mb2N1c2VkU2VjdGlvbigpKTtcblxuICAgICAgICBpZighaGVhZGluZyB8fCBlZGl0b3IuY2FyZXQuaXNDb2xsYXBzZWRBbmRQb3NpdGlvbmVkQXRUaGVCZWdpbm5pbmdPZihoZWFkaW5nLCBmYWxzZSkpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSBlbHNlIGlmKGhlYWRpbmcuaW5uZXJUZXh0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ2RlbGV0ZScpO1xuICAgICAgICAgICAgZWRpdG9yLmNhcmV0LnBvc2l0aW9uSW4oZWRpdG9yLnNlY3Rpb25BdChzZWN0aW9uSW5kZXgpLnF1ZXJ5U2VsZWN0b3IoJ2gyJykpO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9IGVsc2UgaWYoaGVhZGluZy5pbm5lclRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgb25Gb2N1czogZnVuY3Rpb24oZWwsIGVkaXRvciwgYXJncykge1xuICAgICAgICB2YXIgaGVhZGluZyA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ2gyJyksXG4gICAgICAgICAgICBpc0NhcmV0SW5zaWRlU2VjdGlvbiA9IChlZGl0b3Iuc2VjdGlvbkF0Q2FyZXRQb3N0aW9uKCkgPT09IGVsICYmIGVkaXRvci5jYXJldC5nZXRDb250ZXh0RWxlbWVudCgnaDInKSksXG4gICAgICAgICAgICBoYXNCZWVuRm9jdXNlZEFmdGVyU2VjdGlvblR5cGVDaGFuZ2UgPSBhcmdzLmFjdGlvbiA9PT0gJ2NoYW5nZUZvY3VzZWRTZWN0aW9uVHlwZSc7XG5cbiAgICAgICAgaWYoaGFzQmVlbkZvY3VzZWRBZnRlclNlY3Rpb25UeXBlQ2hhbmdlIHx8ICFpc0NhcmV0SW5zaWRlU2VjdGlvbikge1xuICAgICAgICAgICAgaGVhZGluZyAmJiBlZGl0b3IuY2FyZXQucG9zaXRpb25JbihoZWFkaW5nKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZXRFZGl0b3I6IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufSk7XG4iLCJ2YXIgdXVpZCA9IHJlcXVpcmUoJ3V1aWQvdjEnKTtcblxudmFyIGdldFNlY3Rpb25FbGVtZW50ID0gZnVuY3Rpb24oZXhpc3RpbmdTZWN0aW9uQ29udGVudCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2JxdW90ZScpLFxuICAgICAgICBibG9ja3F1b3RlRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdibG9ja3F1b3RlJyksXG4gICAgICAgIGNhcHRpb25FbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NpdGVzcmMnKTtcblxuICAgIGVsLnNldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJywgJ2ZhbHNlJylcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2Rpc3BsYXktY2l0ZXNyYycsICdZZXMnKTtcbiAgICBlbC5pZCA9IHV1aWQoKTtcbiAgICBlbC5zZXRDb250ZW50ZWRpdGFibGUgPSBtb2R1bGUuZXhwb3J0cy5zZXRDb250ZW50ZWRpdGFibGU7XG4gICAgZWwuc2VjdGlvblR5cGUgPSBtb2R1bGUuZXhwb3J0cztcblxuICAgIGJsb2NrcXVvdGVFbC5pbm5lckhUTUwgPSBleGlzdGluZ1NlY3Rpb25Db250ZW50O1xuICAgIGJsb2NrcXVvdGVFbC5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScsICd0cnVlJyk7XG5cbiAgICBjYXB0aW9uRWwuaW5uZXJIVE1MID0gJ2NpdGF0aW9uIHNvdXJjZSc7XG5cbiAgICBlbC5hcHBlbmRDaGlsZChibG9ja3F1b3RlRWwpO1xuICAgIGVsLmFwcGVuZENoaWxkKGNhcHRpb25FbCk7XG5cbiAgICByZXR1cm4gZWw7XG59XG5cbk9iamVjdC5hc3NpZ24obW9kdWxlLmV4cG9ydHMsIHtcblxuICAgIG5hbWU6ICdicXVvdGUnLFxuXG4gICAgdGFnVHJhbnNmb3JtYXRpb25zOiB7XG4gICAgICAnL2JxdW90ZS9ibG9ja3F1b3RlL2Rpdic6ICcjY29udGVudCcsXG4gICAgICAnL2JxdW90ZS9ibG9ja3F1b3RlL3NwYW4nOiAnI2NvbnRlbnQnLFxuICAgICAgJy9icXVvdGUvYmxvY2txdW90ZSc6ICcjdGV4dC1jb250ZW50JyxcbiAgICB9LFxuXG4gICAgY29udGVudFJ1bGVzOiB7XG4gICAgICAgICdicXVvdGUnOiB7XG4gICAgICAgICAgICB0YWdOYW1lOiAnYnF1b3RlJyxcbiAgICAgICAgICAgIGFsbG93ZWRBdHRyaWJ1dGVzOiBbJ2NsYXNzJywgJ2NvbnRlbnRlZGl0YWJsZScsICdkaXNwbGF5LWNhcHRpb24nLCAnaWQnLCAncmVmZXJlbmNlJ10sXG4gICAgICAgICAgICBhbGxvd2VkQ2xhc3NOYW1lczogWydmb2N1c2VkJ10sXG4gICAgICAgICAgICBhbGxvd2VkQ2hpbGRyZW46IFsnYmxvY2txdW90ZScsICdjaXRlc3JjJ10sXG4gICAgICAgICAgICBhbGxvd2VkVG9CZVJvb3Q6IHRydWUsXG4gICAgICAgICAgICBidWlsZEVtcHR5RWxlbWVudDogZ2V0U2VjdGlvbkVsZW1lbnQsXG4gICAgICAgICAgICBkZWxldGVJZkVtcHR5OiBmYWxzZSxcbiAgICAgICAgICAgIGJ1aWxkQXR0cmlidXRlczogW1xuICAgICAgICAgICAgICB7bmFtZTogJ2lkJywgYnVpbGQ6IGZ1bmN0aW9uKCkge3JldHVybiB1dWlkKCl9fSxcbiAgICAgICAgICAgICAge25hbWU6ICdkaXNwbGF5LWNhcHRpb24nLCBidWlsZDogZnVuY3Rpb24oKSB7cmV0dXJuICdZZXMnfX1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgJ2Jsb2NrcXVvdGUnOiB7XG4gICAgICAgICAgICB0YWdOYW1lOiAnYmxvY2txdW90ZScsXG4gICAgICAgICAgICBhbGxvd2VkU3VjY2Vzc29yczogWydjaXRlc3JjJ10sXG4gICAgICAgICAgICBhbGxvd2VkQXR0cmlidXRlczogWydjb250ZW50ZWRpdGFibGUnXSxcbiAgICAgICAgICAgIGFsbG93ZWRDaGlsZHJlbjogWycjdGV4dCddLFxuICAgICAgICB9LFxuICAgICAgICAnY2l0ZXNyYyc6IHtcbiAgICAgICAgICAgIHRhZ05hbWU6ICdjaXRlc3JjJyxcbiAgICAgICAgICAgIGFsbG93ZWRDaGlsZHJlbjogWycjdGV4dCcsICdyZWZlcmVuY2UnLCAgJ2lubGluZWVxdWF0aW9uJ10sXG4gICAgICAgICAgICBkZWxldGVJZkVtcHR5OiBmYWxzZSxcbiAgICAgICAgICAgIHBydW5lU3BhY2VzOiB0cnVlLFxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGVucmljaG1lbnRzOiBbXSxcblxuICAgIGdldE9wdGlvbnM6IGZ1bmN0aW9uKHNlY3Rpb25FbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5hbWU6ICdkaXNwbGF5Q2FwdGlvbicsXG4gICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiAnRGlzcGxheSBTb3VyY2UnLFxuICAgICAgICAgICAgICBhbGxvd2VkVmFsdWVzOiBbJ1llcycsICdObyddLFxuICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IHNlY3Rpb25FbGVtZW50LmdldEF0dHJpYnV0ZSgnZGlzcGxheS1jYXB0aW9uJykgfHwgJ1llcydcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG5cbiAgICBvbk9wdGlvbnNDaGFuZ2U6IGZ1bmN0aW9uKG9wdCwgZWRpdG9yKSB7XG4gICAgICAgIHZhciBzZWN0aW9uID0gZWRpdG9yLmZvY3VzZWRTZWN0aW9uKCk7XG5cbiAgICAgICAgaWYoc2VjdGlvbikge1xuICAgICAgICAgICAgaWYob3B0LmRpc3BsYXlDYXB0aW9uID09PSAnWWVzJyB8fCBvcHQuZGlzcGxheUNhcHRpb24gPT09ICdObycpIHtcbiAgICAgICAgICAgICAgICBzZWN0aW9uLnNldEF0dHJpYnV0ZSgnZGlzcGxheS1jYXB0aW9uJywgb3B0LmRpc3BsYXlDYXB0aW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWRpdG9yLnJlcGxhY2VTZWN0aW9uV2l0aEhUTUwoc2VjdGlvbiwgc2VjdGlvbi5vdXRlckhUTUwpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldFNlY3Rpb25FbGVtZW50OiBnZXRTZWN0aW9uRWxlbWVudCxcbn0pXG4iLCJ2YXIgSFRNTFJhem9yID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL2h0bWxfcmF6b3IvaHRtbF9yYXpvcicpLFxuICAgIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL3BpeGVsc2NodWJzZXIvdXRpbHMnKSxcbiAgICBzaGFyZWQgPSByZXF1aXJlKCcuLi9zaGFyZWQvc2hhcmVkJyksXG4gICAgcHJpbXNqcyA9IHJlcXVpcmUoJ3ByaXNtanMnKSxcbiAgICBwcm9nTGFuZ3VhZ2VzID0gW1wiWE1MXCIsIFwiSFRNTFwiLCBcIk1hdGhNTFwiLCBcIlNWR1wiLCBcIkNTU1wiLCBcImNsaWtlXCIsIFwiSmF2YVNjcmlwdFwiXSxcbiAgICBwcm9nTGFuZ3VhZ2VzU2hvcnQgPSB7J0phdmFTY3JpcHQnOiAnSlMnfSxcbiAgICBkZWZhdWx0TGFuZ3VhZ2UgPSAnSmF2YVNjcmlwdCcsXG4gICAgdXVpZCA9IHJlcXVpcmUoJ3V1aWQvdjEnKTtcblxudmFyIGdldFNlY3Rpb25FbGVtZW50ID0gZnVuY3Rpb24oZXhpc3RpbmdTZWN0aW9uQ29udGVudCwgcGFyYW1zKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncHJlJyksXG4gICAgICAgIGNvZGVFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NvZGUnKSxcbiAgICAgICAgY2FwdGlvbkVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FwdGlvbicpLFxuICAgICAgICBjYXBpdGFsaXplZExhbmdhdWdlO1xuXG4gICAgZWwuY2xhc3NMaXN0LmFkZCgnY29kZScpO1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJywgJ2ZhbHNlJylcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2Rpc3BsYXktY2FwdGlvbicsICdZZXMnKTtcbiAgICBlbC5pZCA9IHV1aWQoKTtcbiAgICBlbC5vbktleVVwID0gbW9kdWxlLmV4cG9ydHMub25LZXlVcDtcbiAgICBlbC5vbktleURvd24gPSBtb2R1bGUuZXhwb3J0cy5vbktleURvd247XG4gICAgZWwub25LZXlFbnRlciA9IG1vZHVsZS5leHBvcnRzLm9uS2V5RW50ZXI7XG4gICAgZWwub25LZXlUYWIgPSBtb2R1bGUuZXhwb3J0cy5vbktleVRhYjtcbiAgICBlbC5vbktleUJhY2tzcGFjZSA9IG1vZHVsZS5leHBvcnRzLm9uS2V5QmFja3NwYWNlO1xuICAgIGVsLm9uTWFya3VwQ2xlYW5pbmdGaW5zaGVkID0gbW9kdWxlLmV4cG9ydHMub25NYXJrdXBDbGVhbmluZ0ZpbnNoZWQ7XG4gICAgZWwuc2V0Q29udGVudGVkaXRhYmxlID0gbW9kdWxlLmV4cG9ydHMuc2V0Q29udGVudGVkaXRhYmxlO1xuICAgIGVsLnNlY3Rpb25UeXBlID0gbW9kdWxlLmV4cG9ydHM7XG5cbiAgICBjb2RlRWwuaW5uZXJIVE1MID0gZXhpc3RpbmdTZWN0aW9uQ29udGVudDtcbiAgICBjb2RlRWwuc2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnLCAndHJ1ZScpO1xuXG4gICAgY2FwdGlvbkVsLmlubmVySFRNTCA9ICdsaXN0aW5nIHRpdGxlJztcblxuICAgIGVsLmFwcGVuZENoaWxkKGNvZGVFbCk7XG4gICAgZWwuYXBwZW5kQ2hpbGQoY2FwdGlvbkVsKTtcblxuICAgIGlmKHBhcmFtcyAmJiBwYXJhbXNbMF0pIHtcbiAgICAgICAgcGFyYW1zWzBdID0gcGFyYW1zWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNhcGl0YWxpemVkTGFuZ2F1Z2UgPSBwcm9nTGFuZ3VhZ2VzLmZpbmQoZnVuY3Rpb24obGFuKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFuLnRvTG93ZXJDYXNlKCkgPT09IHBhcmFtc1swXTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY2FwaXRhbGl6ZWRMYW5nYXVnZSA9IGNhcGl0YWxpemVkTGFuZ2F1Z2UgfHwgZGVmYXVsdExhbmd1YWdlO1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnbGFuZ3VhZ2UnLCBjYXBpdGFsaXplZExhbmdhdWdlKTtcblxuICAgIHJldHVybiBlbDtcbn1cblxuT2JqZWN0LmFzc2lnbihtb2R1bGUuZXhwb3J0cywge1xuXG4gICAgbmFtZTogJ2NvZGUnLFxuXG4gICAgdGFnVHJhbnNmb3JtYXRpb25zOiB7XG4gICAgICAnL3ByZS9jb2RlL2Rpdic6ICcjY29udGVudCcsXG4gICAgICAnL3ByZS9jb2RlL3NwYW4nOiAnI2NvbnRlbnQnLFxuICAgICAgJy9wcmUvY29kZSc6ICcjdGV4dC1jb250ZW50JyxcbiAgICB9LFxuXG4gICAgY29udGVudFJ1bGVzOiB7XG4gICAgICAgICdwcmUnOiB7XG4gICAgICAgICAgICB0YWdOYW1lOiAncHJlJyxcbiAgICAgICAgICAgIGFsbG93ZWRBdHRyaWJ1dGVzOiBbJ2NsYXNzJywgJ2xhbmd1YWdlJywgJ2NvbnRlbnRlZGl0YWJsZScsICdkaXNwbGF5LWNhcHRpb24nLCAnaWQnXSxcbiAgICAgICAgICAgIGFsbG93ZWRDbGFzc05hbWVzOiBbJ2ZvY3VzZWQnLCAnY29kZSddLFxuICAgICAgICAgICAgYWxsb3dlZENoaWxkcmVuOiBbJ2NvZGUnLCAnY2FwdGlvbiddLFxuICAgICAgICAgICAgYWxsb3dlZFRvQmVSb290OiB0cnVlLFxuICAgICAgICAgICAgYnVpbGRFbXB0eUVsZW1lbnQ6IGdldFNlY3Rpb25FbGVtZW50LFxuICAgICAgICAgICAgZGVsZXRlSWZFbXB0eTogZmFsc2UsXG4gICAgICAgICAgICBidWlsZEF0dHJpYnV0ZXM6IFtcbiAgICAgICAgICAgICAge25hbWU6ICdpZCcsIGJ1aWxkOiBmdW5jdGlvbigpIHtyZXR1cm4gdXVpZCgpfX0sXG4gICAgICAgICAgICAgIHtuYW1lOiAnbGFuZ3VhZ2UnLCBidWlsZDogZnVuY3Rpb24oKSB7cmV0dXJuIGRlZmF1bHRMYW5ndWFnZX19LFxuICAgICAgICAgICAgICB7bmFtZTogJ2Rpc3BsYXktY2FwdGlvbicsIGJ1aWxkOiBmdW5jdGlvbigpIHtyZXR1cm4gJ1llcyd9fVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICAnY29kZSc6IHtcbiAgICAgICAgICAgIHRhZ05hbWU6ICdjb2RlJyxcbiAgICAgICAgICAgIGFsbG93ZWRTdWNjZXNzb3JzOiBbJ2NhcHRpb24nXSxcbiAgICAgICAgICAgIGFsbG93ZWRBdHRyaWJ1dGVzOiBbJ2NvbnRlbnRlZGl0YWJsZSddLFxuICAgICAgICAgICAgYWxsb3dlZENoaWxkcmVuOiBbJyN0ZXh0J10sXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZW5yaWNobWVudHM6IFtdLFxuXG4gICAgZ2V0T3B0aW9uczogZnVuY3Rpb24oc2VjdGlvbkVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbmFtZTogJ2xhbmd1YWdlJyxcbiAgICAgICAgICAgICAgZGlzcGxheU5hbWU6ICdTeW50YXggSGlnaGxpZ2h0aW5nIGZvcicsXG4gICAgICAgICAgICAgIGFsbG93ZWRWYWx1ZXM6IHByb2dMYW5ndWFnZXMsXG4gICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogc2VjdGlvbkVsZW1lbnQuZ2V0QXR0cmlidXRlKCdsYW5ndWFnZScpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBuYW1lOiAnZGlzcGxheUNhcHRpb24nLFxuICAgICAgICAgICAgICBkaXNwbGF5TmFtZTogJ0Rpc3BsYXkgTGlzdGluZyBDYXB0aW9uJyxcbiAgICAgICAgICAgICAgYWxsb3dlZFZhbHVlczogWydZZXMnLCAnTm8nXSxcbiAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBzZWN0aW9uRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2Rpc3BsYXktY2FwdGlvbicpIHx8ICdZZXMnXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuXG4gICAgb25PcHRpb25zQ2hhbmdlOiBmdW5jdGlvbihvcHQsIGVkaXRvcikge1xuICAgICAgICB2YXIgc2VjdGlvbiA9IGVkaXRvci5mb2N1c2VkU2VjdGlvbigpO1xuXG4gICAgICAgIGlmKHNlY3Rpb24pIHtcbiAgICAgICAgICAgIGlmKG9wdFsnbGFuZ3VhZ2UnXSkge1xuICAgICAgICAgICAgICAgIHNlY3Rpb24uc2V0QXR0cmlidXRlKCdsYW5ndWFnZScsIG9wdFsnbGFuZ3VhZ2UnXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKG9wdC5kaXNwbGF5Q2FwdGlvbiA9PT0gJ1llcycgfHwgb3B0LmRpc3BsYXlDYXB0aW9uID09PSAnTm8nKSB7XG4gICAgICAgICAgICAgICAgc2VjdGlvbi5zZXRBdHRyaWJ1dGUoJ2Rpc3BsYXktY2FwdGlvbicsIG9wdC5kaXNwbGF5Q2FwdGlvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVkaXRvci5yZXBsYWNlU2VjdGlvbldpdGhIVE1MKHNlY3Rpb24sIHNlY3Rpb24ub3V0ZXJIVE1MKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRTZWN0aW9uRWxlbWVudDogZ2V0U2VjdGlvbkVsZW1lbnQsXG5cbiAgICBvbk1hcmt1cENsZWFuaW5nRmluc2hlZDogZnVuY3Rpb24oc2VjdGlvbkVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGNvZGVFbCA9IHNlY3Rpb25FbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2NvZGUnKSwgY29udGVudCwgbGFuO1xuXG4gICAgICAgIGlmKCFjb2RlRWwpIHsgcmV0dXJuIH1cblxuICAgICAgICBjb250ZW50ID0gY29kZUVsLmlubmVySFRNTDtcbiAgICAgICAgbGFuID0gc2VjdGlvbkVsZW1lbnQuZ2V0QXR0cmlidXRlKCdsYW5ndWFnZScpO1xuXG4gICAgICAgIGlmKCFsYW4gfHwgbGFuID09PSAndHJ1ZScpIHtcbiAgICAgICAgICAgIGxhbiA9IGRlZmF1bHRMYW5ndWFnZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhbiA9IGxhbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb250ZW50ID0gSFRNTFJhem9yLnByb3RvdHlwZS5zdHJpcChjb250ZW50KTtcbiAgICAgICAgY29udGVudCA9IHByaW1zanMuaGlnaGxpZ2h0KGNvbnRlbnQsIHByaW1zanMubGFuZ3VhZ2VzW2xhbl0sIGxhbik7XG4gICAgICAgIHNlY3Rpb25FbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2NvZGUnKS5pbm5lckhUTUwgPSBjb250ZW50O1xuICAgIH0sXG5cbiAgICBnZXRTZWN0aW9uVHlwZUNhcHRpb25Bbm5vdGF0aW9uOiBmdW5jdGlvbihzZWN0aW9uRWxlbWVudCkge1xuICAgICAgICB2YXIgbGFuID0gc2VjdGlvbkVsZW1lbnQuZ2V0QXR0cmlidXRlKCdsYW5ndWFnZScpO1xuXG4gICAgICAgIGlmKHByb2dMYW5ndWFnZXNTaG9ydFtsYW5dKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvZ0xhbmd1YWdlc1Nob3J0W2xhbl07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGFuO1xuICAgIH0sXG5cbiAgICBvbktleVRhYjogZnVuY3Rpb24oZSkge1xuICAgICAgICBkb2N1bWVudC5leGVjQ29tbWFuZCgnaW5zZXJ0VGV4dCcsIGZhbHNlLCAnICAnKTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG5cbiAgICBzZXRDb250ZW50ZWRpdGFibGU6IGZ1bmN0aW9uKHNob3VsZEJlRWRpdGFibGUsIHNlY3Rpb24pIHtcbiAgICAgICAgdmFyIGVsID0gc2VjdGlvbi5xdWVyeVNlbGVjdG9yKCdjb2RlJylcbiAgICAgICAgaWYoZWwpIHtcbiAgICAgICAgICAgIGlmKHNob3VsZEJlRWRpdGFibGUpIHtcbiAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG9uS2V5VXA6IHNoYXJlZC5vbktleVVwRm9yRnJlZXN0eWxlU2VjdGlvbnMsXG4gICAgb25LZXlEb3duOiBzaGFyZWQub25LZXlEb3duRm9yRnJlZXN0eWxlU2VjdGlvbnMsXG4gICAgb25LZXlCYWNrc3BhY2U6IGZ1bmN0aW9uKGUsIGVkaXRvcikge1xuICAgICAgICB2YXIgY2FwdGlvbiA9IGVkaXRvci5jYXJldC5nZXRDb250ZXh0RWxlbWVudCgnY2FwdGlvbicsIHdpbmRvdy5nZXRTZWxlY3Rpb24oKSwgW10pLFxuICAgICAgICAgICAgc2VjdGlvbkVsLCBzZWN0aW9uSW5kZXg7XG5cbiAgICAgICAgaWYoY2FwdGlvbikge1xuICAgICAgICAgICAgaWYoY2FwdGlvbi5pbm5lclRleHQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgc2VjdGlvbkVsID0gY2FwdGlvbi5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgIHNlY3Rpb25JbmRleCA9IGVkaXRvci5pbmRleE9mKHNlY3Rpb25FbCk7XG5cbiAgICAgICAgICAgICAgICBpZihzZWN0aW9uSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ2RlbGV0ZScpO1xuXG4gICAgICAgICAgICAgICAgICAgIHNlY3Rpb25FbCA9IGVkaXRvci5zZWN0aW9uQXQoc2VjdGlvbkluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgY2FwdGlvbiA9IHNlY3Rpb25FbCAmJiBzZWN0aW9uRWwucXVlcnlTZWxlY3RvcignY2FwdGlvbicpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKGNhcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5jYXJldC5wb3NpdGlvbkluKGNhcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZighY2FwdGlvbi5pbm5lclRleHQgfHwgY2FwdGlvbi5pbm5lclRleHQubGVuZ3RoID09PSAwIHx8IGVkaXRvci5jYXJldC5pc0NvbGxhcHNlZEFuZFBvc2l0aW9uZWRBdFRoZUJlZ2lubmluZ09mKGNhcHRpb24sIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNoYXJlZC5vbktleUJhY2tzcGFjZUZvckJhY2tzcGFjZURlbGV0YWJsZVNlY3Rpb25zKGUsIGVkaXRvcilcbiAgICAgICAgfVxuICAgIH0sXG4gICAgb25LZXlFbnRlcjogc2hhcmVkLm9uS2V5RW50ZXJGb3JGcmVlc3R5bGVTZWN0aW9uc1xufSlcbiIsInZhciB1dWlkID0gcmVxdWlyZSgndXVpZC92MScpLFxudXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvcGl4ZWxzY2h1YnNlci91dGlscycpO1xuXG5mdW5jdGlvbiBnZXRTZWN0aW9uRWxlbWVudCgpIHtcbiAgICB2YXIgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9vdG5vdGVzJyksXG4gICAgICAgICBoZWFkaW5nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDInKSxcbiAgICAgICAgIGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlbC5jbGFzc0xpc3QuYWRkKCdmb290bm90ZXMnKTtcblxuICAgIGhlYWRpbmcuY2xhc3NMaXN0LmFkZCgnZm9vdG5vdGVzLWhlYWRpbmcnKTtcbiAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoJ2Zvb3Rub3Rlcy1jb250ZW50Jyk7XG5cbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScsICdmYWxzZScpO1xuICAgIGhlYWRpbmcuc2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnLCAndHJ1ZScpO1xuICAgIGNvbnRlbnQuc2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnLCAnZmFsc2UnKTtcblxuICAgIGhlYWRpbmcuaW5uZXJIVE1MID0gJ0Zvb3Rub3Rlcyc7XG5cbiAgICBlbC5vbktleUJhY2tzcGFjZSA9IG1vZHVsZS5leHBvcnRzLm9uS2V5QmFja3NwYWNlO1xuICAgIGVsLnNlY3Rpb25UeXBlID0gbW9kdWxlLmV4cG9ydHM7XG5cbiAgICBlbC5hcHBlbmRDaGlsZChoZWFkaW5nKTtcbiAgICBlbC5hcHBlbmRDaGlsZChjb250ZW50KTtcblxuICAgIHJldHVybiBlbDtcbn1cblxuT2JqZWN0LmFzc2lnbihtb2R1bGUuZXhwb3J0cywge1xuXG4gICAgbmFtZTogJ2Zvb3Rub3RlcycsXG5cbiAgICBlZGl0YWJsZUVsZW1lbnRTZWxlY3RvcjogJ2gyJyxcblxuICAgIHByZWZlcnJlZENhcmV0UG9zaXRpb25pbmc6ICdlbmQnLFxuXG4gICAgY29udGVudFJ1bGVzOiB7XG4gICAgICAgICdmb290bm90ZXMnOiB7XG4gICAgICAgICAgICB0YWdOYW1lOiAnZm9vdG5vdGVzJyxcbiAgICAgICAgICAgIGFsbG93ZWRBdHRyaWJ1dGVzOiBbJ2NsYXNzJywgJ2NvbnRlbnRlZGl0YWJsZSddLFxuICAgICAgICAgICAgYWxsb3dlZENsYXNzTmFtZXM6IFsnZm9jdXNlZCddLFxuICAgICAgICAgICAgYWxsb3dlZENoaWxkcmVuOiBbJ2Zvb3Rub3Rlcy1oZWFkaW5nJywgJ2Zvb3Rub3Rlcy1jb250ZW50J10sXG4gICAgICAgICAgICBhbGxvd2VkVG9CZVJvb3Q6IHRydWUsXG4gICAgICAgICAgICBkZWxldGVJZkVtcHR5OiBmYWxzZSxcbiAgICAgICAgICAgIGRvTm90QnJlYWtPdXRSb290RWxlbWVudHM6IHRydWUsXG4gICAgICAgICAgICBidWlsZEVtcHR5RWxlbWVudDogZ2V0U2VjdGlvbkVsZW1lbnRcbiAgICAgICAgfSxcblxuICAgICAgICAnZm9vdG5vdGVzLWhlYWRpbmcnOiB7XG4gICAgICAgICAgICB0YWdOYW1lOiAnaDInLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAnZm9vdG5vdGVzLWhlYWRpbmcnLFxuICAgICAgICAgICAgYWxsb3dlZEF0dHJpYnV0ZXM6IFsnaWQnLCAnY2xhc3MnLCAnY29udGVudGVkaXRhYmxlJywgJ3VubnVtYmVyZWQtaGVhZGluZyddLFxuICAgICAgICAgICAgYWxsb3dlZENsYXNzTmFtZXM6IFsnZm9vdG5vdGVzLWhlYWRpbmcnXSxcbiAgICAgICAgICAgIGFsbG93ZWRDaGlsZHJlbjogWycjdGV4dCddLFxuICAgICAgICAgICAgcHJ1bmVTcGFjZXM6IHRydWUsXG4gICAgICAgICAgICBidWlsZEF0dHJpYnV0ZXM6IFtcbiAgICAgICAgICAgICAgICB7bmFtZTogJ2lkJywgYnVpbGQ6IGZ1bmN0aW9uKCkge3JldHVybiB1dWlkKCl9fSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ3VubnVtYmVyZWQtaGVhZGluZycsIGJ1aWxkOiBmdW5jdGlvbigpIHtyZXR1cm4gJ1llcyd9fVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuXG4gICAgICAgICdmb290bm90ZXMtY29udGVudCc6IHtcbiAgICAgICAgICAgIHRhZ05hbWU6ICdkaXYnLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAnZm9vdG5vdGVzLWNvbnRlbnQnLFxuICAgICAgICAgICAgYWxsb3dlZEF0dHJpYnV0ZXM6IFsnY2xhc3MnLCAnY29udGVudGVkaXRhYmxlJ10sXG4gICAgICAgICAgICBhbGxvd2VkQ2xhc3NOYW1lczogWydmb290bm90ZXMtY29udGVudCddLFxuICAgICAgICAgICAgYWxsb3dlZENoaWxkcmVuOiBbJ2Zvb3Rub3Rlcy1lbnRyeSddLFxuICAgICAgICB9LFxuXG4gICAgICAgICdmb290bm90ZXMtZW50cnknOiB7XG4gICAgICAgICAgICB0YWdOYW1lOiAnZGl2JyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2VudHJ5JyxcbiAgICAgICAgICAgIGFsbG93ZWRBdHRyaWJ1dGVzOiBbJ2NsYXNzJ10sXG4gICAgICAgICAgICBhbGxvd2VkQ2xhc3NOYW1lczogWydlbnRyeScsICdub3RlJ10sXG4gICAgICAgICAgICBhbGxvd2VkQ2hpbGRyZW46IFsnI3RleHQnXSxcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBlbnJpY2htZW50czogW10sXG5cbiAgICBnZXRTZWN0aW9uRWxlbWVudDogZ2V0U2VjdGlvbkVsZW1lbnQsXG5cbiAgICBnZXRPcHRpb25zOiBmdW5jdGlvbihzZWN0aW9uRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdudW1iZXJlZEhlYWRpbmcnLFxuICAgICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiAnU2hvdWxkIHRoZSBoZWFkaW5nIGJlIG51bWJlcmVkJyxcbiAgICAgICAgICAgICAgICBhbGxvd2VkVmFsdWVzOiBbJ1llcycsICdObyddLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogc2VjdGlvbkVsZW1lbnQucXVlcnlTZWxlY3RvcignaDInKS5nZXRBdHRyaWJ1dGUoJ3VubnVtYmVyZWQtaGVhZGluZycpID09PSAnWWVzJyA/ICdObycgOiAnWWVzJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcblxuICAgIG9uT3B0aW9uc0NoYW5nZTogZnVuY3Rpb24ob3B0LCBlZGl0b3IpIHtcbiAgICAgICAgdmFyIHNlY3Rpb24gPSBlZGl0b3IuZm9jdXNlZFNlY3Rpb24oKTtcbiAgICAgICAgaWYob3B0Lm51bWJlcmVkSGVhZGluZyA9PT0gJ1llcycgfHwgb3B0Lm51bWJlcmVkSGVhZGluZyA9PT0gJ05vJykge1xuICAgICAgICAgICAgc2VjdGlvbi5xdWVyeVNlbGVjdG9yKCdoMicpLnNldEF0dHJpYnV0ZSgndW5udW1iZXJlZC1oZWFkaW5nJywgb3B0Lm51bWJlcmVkSGVhZGluZyA9PT0gJ1llcycgPyAnTm8nIDogJ1llcycpO1xuICAgICAgICAgICAgc2VsZi5lZGl0b3IucmVwbGFjZVNlY3Rpb25XaXRoSFRNTChzZWN0aW9uLCBzZWN0aW9uLm91dGVySFRNTCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgb25FZGl0b3JDb250ZW50Q2hhbmdlZDogZnVuY3Rpb24obW9kaWZpY2F0aW9uTG9nKSB7XG4gICAgICAgIGlmKCFtb2RpZmljYXRpb25Mb2cubWlnaHRJbmNsdWRlRm9vdG5vdGVVcGRhdGVzICYmICFtb2RpZmljYXRpb25Mb2cubWlnaHRJbmNsdWRlRm9vdG5vdGVzU2VjdGlvblVwZGF0ZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBub3Rlc1NlY3Rpb25zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnZm9vdG5vdGVzIC5mb290bm90ZXMtY29udGVudCcpLFxuICAgICAgICAgICAgbm90ZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZm9vdG5vdGUnKSxcbiAgICAgICAgICAgIG5vdGVJbmRleCwgdG1wO1xuXG4gICAgICAgIG5vdGVzU2VjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihub3Rlc1NlY3Rpb24pIHtcbiAgICAgICAgICAgIG5vdGVzU2VjdGlvbi5pbm5lckhUTUwgPSAnJztcblxuICAgICAgICAgICAgaWYobm90ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbm90ZXNTZWN0aW9uLmlubmVySFRNTCArPSAnPGRpdiBjbGFzcz1cImVudHJ5IG5vdGVcIj5JbnNlcnQgZm9vdG5vdGVzIHRvIHNlZSB0aGVtIGhlcmUuPC9kaXY+JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm90ZUluZGV4ID0gMDtcblxuICAgICAgICAgICAgbm90ZXMuZm9yRWFjaChmdW5jdGlvbihub3RlKSB7XG4gICAgICAgICAgICAgICAgbm90ZUluZGV4Kys7XG4gICAgICAgICAgICAgICAgdG1wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgdG1wLmNsYXNzTGlzdC5hZGQoJ2VudHJ5JylcbiAgICAgICAgICAgICAgICB0bXAuaW5uZXJIVE1MID0gbm90ZUluZGV4ICsgJykgJyArIHV0aWxzLmF0dHJpYnV0ZVNhdmVTdHJpbmdUb0hUTUxFbmNvZGVkKG5vdGUuZ2V0QXR0cmlidXRlKCdkYXRhLW5vdGUnKSk7XG4gICAgICAgICAgICAgICAgdG1wLm9uY2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMuc2hvd0Zvb3Rub3RlRWRpdERpYWxvZyhub3RlKTtcblxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbm90ZXNTZWN0aW9uLmFwcGVuZENoaWxkKHRtcCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHNob3dGb290bm90ZUVkaXREaWFsb2c6IGZ1bmN0aW9uKG5vdGUpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgc2VjdGlvbiA9IHNlbGYuZWRpdG9yLnNlY3Rpb25CeUNoaWxkTm9kZShub3RlKSxcbiAgICAgICAgICAgIG5vdGVJbmRleCxcbiAgICAgICAgICAgIGFyZ3MgPSBbe1xuICAgICAgICAgICAgbmFtZTogJ25vdGUnLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICdmb290bm90ZScsXG4gICAgICAgICAgICBkaXNwbGF5TmFtZTogJ0Zvb3Rub3RlJyxcbiAgICAgICAgICAgIGxhcmdldGV4dDogdHJ1ZSxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogdXRpbHMuYXR0cmlidXRlU2F2ZVN0cmluZ1RvU3RyaW5nKG5vdGUuZGF0YXNldC5ub3RlKVxuICAgICAgICB9XTtcblxuICAgICAgICBpZighc2VjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5lZGl0b3IuZGlzcGxheU1vZGFsKGFyZ3MsIGZ1bmN0aW9uKGZvcm1EYXRhKSB7XG4gICAgICAgICAgICBub3RlSW5kZXggPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZm9vdG5vdGUnKS5pbmRleE9mKG5vdGUpLFxuICAgICAgICAgICAgc2VsZi5lZGl0b3IudW5mcmVlemVTZWxlY3Rpb24oZmFsc2UpO1xuICAgICAgICAgICAgbm90ZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5mb290bm90ZScpW25vdGVJbmRleF07XG4gICAgICAgICAgICBzZWN0aW9uID0gc2VsZi5lZGl0b3Iuc2VjdGlvbkJ5Q2hpbGROb2RlKG5vdGUpO1xuXG4gICAgICAgICAgICBpZighZm9ybURhdGEubm90ZSkgcmV0dXJuO1xuICAgICAgICAgICAgaWYodHlwZW9mIGZvcm1EYXRhLm5vdGUgIT09ICdzdHJpbmcnKSByZXR1cm47XG4gICAgICAgICAgICBpZihmb3JtRGF0YS5ub3RlLnRyaW0oKSA9PT0gJycpIHJldHVybjtcbiAgICAgICAgICAgIG5vdGUuc2V0QXR0cmlidXRlKCdkYXRhLW5vdGUnLCB1dGlscy5zdHJpbmdUb0F0dHJpYnV0ZVNhdmVTdHJpbmcoZm9ybURhdGEubm90ZSkpO1xuXG4gICAgICAgICAgICBzZWxmLmVkaXRvci5yZXBsYWNlU2VjdGlvbldpdGhIVE1MKHNlY3Rpb24sIHNlY3Rpb24ub3V0ZXJIVE1MKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIG9uS2V5QmFja3NwYWNlOiBmdW5jdGlvbihlLCBlZGl0b3IpIHtcbiAgICAgICAgdmFyIGhlYWRpbmcgPSBlZGl0b3IuY2FyZXQuZ2V0Q29udGV4dEVsZW1lbnQoJ2gyJywgd2luZG93LmdldFNlbGVjdGlvbigpLCBbXSksXG4gICAgICAgICAgICBzZWN0aW9uSW5kZXggPSBlZGl0b3IuaW5kZXhPZihlZGl0b3IuZm9jdXNlZFNlY3Rpb24oKSk7XG5cbiAgICAgICAgaWYoIWhlYWRpbmcgfHwgZWRpdG9yLmNhcmV0LmlzQ29sbGFwc2VkQW5kUG9zaXRpb25lZEF0VGhlQmVnaW5uaW5nT2YoaGVhZGluZywgZmFsc2UpKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0gZWxzZSBpZihoZWFkaW5nLmlubmVyVGV4dC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKCdkZWxldGUnKTtcbiAgICAgICAgICAgIGVkaXRvci5jYXJldC5wb3NpdGlvbkluKGVkaXRvci5zZWN0aW9uQXQoc2VjdGlvbkluZGV4KS5xdWVyeVNlbGVjdG9yKCdoMicpKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSBlbHNlIGlmKGhlYWRpbmcuaW5uZXJUZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG9uRm9jdXM6IGZ1bmN0aW9uKGVsLCBlZGl0b3IsIGFyZ3MpIHtcbiAgICAgICAgdmFyIHRvQ0hlYWRpbmcgPSBlbC5xdWVyeVNlbGVjdG9yKCdoMicpLFxuICAgICAgICAgICAgaXNDYXJldEluc2lkZVNlY3Rpb24gPSAoZWRpdG9yLnNlY3Rpb25BdENhcmV0UG9zdGlvbigpID09PSBlbCAmJiBlZGl0b3IuY2FyZXQuZ2V0Q29udGV4dEVsZW1lbnQoJ2gyJykpLFxuICAgICAgICAgICAgaGFzQmVlbkZvY3VzZWRBZnRlclNlY3Rpb25UeXBlQ2hhbmdlID0gYXJncy5hY3Rpb24gPT09ICdjaGFuZ2VGb2N1c2VkU2VjdGlvblR5cGUnO1xuXG4gICAgICAgIGlmKGhhc0JlZW5Gb2N1c2VkQWZ0ZXJTZWN0aW9uVHlwZUNoYW5nZSB8fCAhaXNDYXJldEluc2lkZVNlY3Rpb24pIHtcbiAgICAgICAgICAgIHRvQ0hlYWRpbmcgJiYgZWRpdG9yLmNhcmV0LnBvc2l0aW9uSW4odG9DSGVhZGluZyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0RWRpdG9yOiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn0pO1xuIiwidmFyIGNvZGUyZGlhID0gcmVxdWlyZSgnLi4vc2hhcmVkL2NvZGUyZGlhX3NlY3Rpb25fdHlwZScpLFxuICAgIC8vIGthdGV4ID0gcmVxdWlyZSgna2F0ZXgnKSwgLy8gbWFrZSBzdXJlIHRvIGxvYWQgPHNjcmlwdCBzcmM9XCIuL2thdGV4LmpzXCIgZGVmZXI+PC9zY3JpcHQ+IGluIHlvdXIgaHRtbFxuICAgIGxhdGV4ID0gcmVxdWlyZSgncHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWxhdGV4JyksXG4gICAgcmVuZGVyO1xuXG5yZW5kZXIgPSBmdW5jdGlvbihyZW5kZXJFbCwgY29udGVudCkge1xuICAgIGlmKGNvbnRlbnQudHJpbSgpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZW5kZXJFbC5pbm5lckhUTUwgPSAnV3JpdGUgYSBMYVRlWCBmb3JtdWxhIGludG8gdGhlIGlucHV0IGZpZWxkIGFib3ZlIDxzcGFuIGNsYXNzPVwiYXJyb3dcIj4mIzEwNTQ4Ozwvc3Bhbj4nO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbmRlckVsLmlubmVySFRNTCA9ICcnO1xuICAgICAgICBrYXRleC5yZW5kZXIoY29udGVudCwgcmVuZGVyRWwsIHtcbiAgICAgICAgICAgIHRocm93T25FcnJvcjogZmFsc2UsXG4gICAgICAgICAgICBkaXNwbGF5TW9kZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29kZTJkaWEocmVuZGVyLCAnZm9ybXVsYScsICdsYXRleCcsICdlcXVhdGlvbiBjYXB0aW9uJylcbiIsInZhciB1dWlkID0gcmVxdWlyZSgndXVpZC92MScpLFxuICAgIHBhcmFncmFwaFNlY3Rpb25UeXBlID0gcmVxdWlyZSgnLi4vcGFyYWdyYXBoL3BhcmFncmFwaF9zZWN0aW9uX3R5cGUnKTtcblxudmFyIGdldFNlY3Rpb25FbGVtZW50ID0gZnVuY3Rpb24oZXhpc3RpbmdTZWN0aW9uQ29udGVudCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2gxJyk7XG4gICAgZWwuaW5uZXJIVE1MID0gZXhpc3RpbmdTZWN0aW9uQ29udGVudCB8fCAnJztcbiAgICBlbC5pZCA9IHV1aWQoKTtcbiAgICBlbC5vbktleVVwID0gbW9kdWxlLmV4cG9ydHMub25LZXlVcDtcbiAgICBlbC5vbktleURvd24gPSBtb2R1bGUuZXhwb3J0cy5vbktleURvd247XG4gICAgZWwub25LZXlFbnRlciA9IG1vZHVsZS5leHBvcnRzLm9uS2V5RW50ZXI7XG4gICAgcmV0dXJuIGVsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIG5hbWU6ICdoMScsXG5cbiAgICBjb250ZW50UnVsZXM6IHtcbiAgICAgICAgJ2gxJzoge1xuICAgICAgICAgICAgdGFnTmFtZTogJ2gxJyxcbiAgICAgICAgICAgIGFsbG93ZWRBdHRyaWJ1dGVzOiBbJ2NsYXNzJywgJ2lkJ10sXG4gICAgICAgICAgICBhbGxvd2VkQ2hpbGRyZW46IFsnI3RleHQnLCAnaW5saW5lZXF1YXRpb24nXSxcbiAgICAgICAgICAgIGFsbG93ZWRDbGFzc05hbWVzOiBbJ2ZvY3VzZWQnXSxcbiAgICAgICAgICAgIHBydW5lU3BhY2VzOiB0cnVlLFxuICAgICAgICAgICAgYWxsb3dlZFRvQmVSb290OiB0cnVlLFxuICAgICAgICAgICAgYnVpbGRFbXB0eUVsZW1lbnQ6IGdldFNlY3Rpb25FbGVtZW50LFxuICAgICAgICAgICAgYnVpbGRBdHRyaWJ1dGVzOiBbe25hbWU6ICdpZCcsIGJ1aWxkOiBmdW5jdGlvbigpIHtyZXR1cm4gdXVpZCgpfX1dXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZW5yaWNobWVudHM6IFtdLFxuXG4gICAgb25LZXlVcDogcGFyYWdyYXBoU2VjdGlvblR5cGUub25LZXlVcCxcbiAgICBvbktleURvd246IHBhcmFncmFwaFNlY3Rpb25UeXBlLm9uS2V5RG93bixcbiAgICBvbktleUVudGVyOiBmdW5jdGlvbihlLCBlZGl0b3IpIHtcbiAgICAgICAgaWYoZWRpdG9yLmNhcmV0LmlzQ29sbGFwc2VkQW5kUG9zaXRpb25lZEF0VGhlQmVnaW5uaW5nT2YoZWRpdG9yLmZvY3VzZWRTZWN0aW9uKCkpKSB7XG4gICAgICAgICAgICBpZihlZGl0b3IuZm9jdXNlZFNlY3Rpb24oKSkge1xuICAgICAgICAgICAgICAgIGVkaXRvci5hZGROZXdTZWN0aW9uTmV4dFRvKGVkaXRvci5mb2N1c2VkU2VjdGlvbigpLCAnYmVmb3JlJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVkaXRvci5jYXJldC5pbnNlcnRMaW5lQnJlYWsoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuXG4gICAgZ2V0U2VjdGlvbkVsZW1lbnQ6IGdldFNlY3Rpb25FbGVtZW50LFxufVxuIiwidmFyIHV1aWQgPSByZXF1aXJlKCd1dWlkL3YxJyksXG4gICAgcGFyYWdyYXBoU2VjdGlvblR5cGUgPSByZXF1aXJlKCcuLi9wYXJhZ3JhcGgvcGFyYWdyYXBoX3NlY3Rpb25fdHlwZScpLFxuICAgIGgxU2VjdGlvblR5cGUgPSByZXF1aXJlKCcuL2hlYWRpbmcxLmpzJyk7XG5cbnZhciBnZXRTZWN0aW9uRWxlbWVudCA9IGZ1bmN0aW9uKGV4aXN0aW5nU2VjdGlvbkNvbnRlbnQsIHBhcmFtcykge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2gyJyk7XG5cbiAgICBpZihwYXJhbXMgJiYgKHBhcmFtcy5pbmNsdWRlcygnYWJzdHJhY3QnKSB8fCBwYXJhbXMuaW5jbHVkZXMoJ0Fic3RyYWN0JykpKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgncm9sZScsICdBYnN0cmFjdCcpXG4gICAgfSBlbHNlIGlmKHBhcmFtcyAmJiAocGFyYW1zLmluY2x1ZGVzKCdkZWNsYXJhdGlvbicpIHx8IHBhcmFtcy5pbmNsdWRlcygnRGVjbGFyYXRpb24nKSkpIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdyb2xlJywgJ0RlY2xhcmF0aW9uJylcbiAgICB9IGVsc2UgaWYocGFyYW1zICYmIChwYXJhbXMuaW5jbHVkZXMoJ2FwcGVuZGl4JykgfHwgcGFyYW1zLmluY2x1ZGVzKCdBcHBlbmRpeCcpKSkge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnQXBwZW5kaXgnKVxuICAgIH0gZWxzZSBpZihwYXJhbXMgJiYgKHBhcmFtcy5pbmNsdWRlcygnYWNrbm93bGVkZ2VtZW50JykgfHwgcGFyYW1zLmluY2x1ZGVzKCdBY2tub3dsZWRnZW1lbnQnKSkpIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdyb2xlJywgJ0Fja25vd2xlZGdlbWVudCcpXG4gICAgfVxuXG4gICAgZWwuaW5uZXJIVE1MID0gZXhpc3RpbmdTZWN0aW9uQ29udGVudCB8fCAnJztcbiAgICBlbC5vbktleVVwID0gbW9kdWxlLmV4cG9ydHMub25LZXlVcDtcbiAgICBlbC5vbktleURvd24gPSBtb2R1bGUuZXhwb3J0cy5vbktleURvd247XG4gICAgZWwub25LZXlFbnRlciA9IG1vZHVsZS5leHBvcnRzLm9uS2V5RW50ZXI7XG4gICAgZWwuaWQgPSB1dWlkKCk7XG4gICAgZWwuc2VjdGlvblR5cGUgPSBtb2R1bGUuZXhwb3J0cztcbiAgICByZXR1cm4gZWw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgbmFtZTogJ2gyJyxcblxuICAgIGNvbnRlbnRSdWxlczoge1xuICAgICAgICAnaDInOiB7XG4gICAgICAgICAgICB0YWdOYW1lOiAnaDInLFxuICAgICAgICAgICAgYWxsb3dlZEF0dHJpYnV0ZXM6IFsnY2xhc3MnLCAnaWQnLCAncm9sZSddLFxuICAgICAgICAgICAgYWxsb3dlZENoaWxkcmVuOiBbJyN0ZXh0JywgJ2lubGluZWVxdWF0aW9uJ10sXG4gICAgICAgICAgICBhbGxvd2VkQ2xhc3NOYW1lczogWydmb2N1c2VkJ10sXG4gICAgICAgICAgICBwcnVuZVNwYWNlczogdHJ1ZSxcbiAgICAgICAgICAgIGFsbG93ZWRUb0JlUm9vdDogdHJ1ZSxcbiAgICAgICAgICAgIGJ1aWxkRW1wdHlFbGVtZW50OiBnZXRTZWN0aW9uRWxlbWVudCxcbiAgICAgICAgICAgIGJ1aWxkQXR0cmlidXRlczogW3tuYW1lOiAnaWQnLCBidWlsZDogZnVuY3Rpb24oKSB7cmV0dXJuIHV1aWQoKX19XVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGVucmljaG1lbnRzOiBbXSxcblxuICAgIGdldE9wdGlvbnM6IGZ1bmN0aW9uKHNlY3Rpb25FbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5hbWU6ICdyb2xlJyxcbiAgICAgICAgICAgICAgZGlzcGxheU5hbWU6ICdBc3NpZ24gYSBzcGVjaWFsIHJvbGUgdG8gdGhlIGhlYWRpbmcnLFxuICAgICAgICAgICAgICBhbGxvd2VkVmFsdWVzOiBbJ05vbmUnLCAnQWJzdHJhY3QnLCAnRGVjbGFyYXRpb24nLCAnQXBwZW5kaXgnLCAnQWNrbm93bGVkZ2VtZW50J10sXG4gICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogc2VjdGlvbkVsZW1lbnQuZ2V0QXR0cmlidXRlKCdyb2xlJykgfHwgJ05vbmUnXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuXG4gICAgb25PcHRpb25zQ2hhbmdlOiBmdW5jdGlvbihvcHQsIGVkaXRvcikge1xuICAgICAgICB2YXIgc2VjdGlvbiA9IGVkaXRvci5mb2N1c2VkU2VjdGlvbigpO1xuXG4gICAgICAgIGlmKHNlY3Rpb24pIHtcbiAgICAgICAgICAgIGlmKG9wdFsncm9sZSddKSB7XG4gICAgICAgICAgICAgICAgc2VjdGlvbi5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCBvcHRbJ3JvbGUnXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVkaXRvci5yZXBsYWNlU2VjdGlvbldpdGhIVE1MKHNlY3Rpb24sIHNlY3Rpb24ub3V0ZXJIVE1MKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRTZWN0aW9uVHlwZUNhcHRpb25Bbm5vdGF0aW9uOiBmdW5jdGlvbihzZWN0aW9uRWxlbWVudCkge1xuICAgICAgICB2YXIgcm9sZSA9IHNlY3Rpb25FbGVtZW50LmdldEF0dHJpYnV0ZSgncm9sZScpO1xuICAgICAgICBpZihyb2xlID09PSAnTm9uZScpIHtcbiAgICAgICAgICAgIHJvbGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYocm9sZSA9PT0gJ0Fja25vd2xlZGdlbWVudCcpIHtcbiAgICAgICAgICAgIHJldHVybiAnQWNrLidcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHJvbGUgPT09ICdEZWNsYXJhdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiAnRGVjbC4nXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcm9sZTtcbiAgICB9LFxuXG4gICAgb25LZXlVcDogcGFyYWdyYXBoU2VjdGlvblR5cGUub25LZXlVcCxcbiAgICBvbktleURvd246IHBhcmFncmFwaFNlY3Rpb25UeXBlLm9uS2V5RG93bixcbiAgICBvbktleUVudGVyOiBoMVNlY3Rpb25UeXBlLm9uS2V5RW50ZXIsXG5cbiAgICBnZXRTZWN0aW9uRWxlbWVudDogZ2V0U2VjdGlvbkVsZW1lbnQsXG59XG4iLCJ2YXIgdXVpZCA9IHJlcXVpcmUoJ3V1aWQvdjEnKSxcbiAgICBwYXJhZ3JhcGhTZWN0aW9uVHlwZSA9IHJlcXVpcmUoJy4uL3BhcmFncmFwaC9wYXJhZ3JhcGhfc2VjdGlvbl90eXBlJyksXG4gICAgaDFTZWN0aW9uVHlwZSA9IHJlcXVpcmUoJy4vaGVhZGluZzEuanMnKTtcblxudmFyIGdldFNlY3Rpb25FbGVtZW50ID0gZnVuY3Rpb24oZXhpc3RpbmdTZWN0aW9uQ29udGVudCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2gzJyk7XG4gICAgZWwuaW5uZXJIVE1MID0gZXhpc3RpbmdTZWN0aW9uQ29udGVudCB8fCAnJztcbiAgICBlbC5vbktleVVwID0gbW9kdWxlLmV4cG9ydHMub25LZXlVcDtcbiAgICBlbC5vbktleURvd24gPSBtb2R1bGUuZXhwb3J0cy5vbktleURvd247XG4gICAgZWwub25LZXlFbnRlciA9IG1vZHVsZS5leHBvcnRzLm9uS2V5RW50ZXI7XG4gICAgZWwuaWQgPSB1dWlkKCk7XG4gICAgcmV0dXJuIGVsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIG5hbWU6ICdoMycsXG5cbiAgICBjb250ZW50UnVsZXM6IHtcbiAgICAgICAgJ2gzJzoge1xuICAgICAgICAgICAgdGFnTmFtZTogJ2gzJyxcbiAgICAgICAgICAgIGFsbG93ZWRBdHRyaWJ1dGVzOiBbJ2NsYXNzJywgJ2lkJ10sXG4gICAgICAgICAgICBhbGxvd2VkQ2hpbGRyZW46IFsnI3RleHQnLCAnaW5saW5lZXF1YXRpb24nXSxcbiAgICAgICAgICAgIGFsbG93ZWRDbGFzc05hbWVzOiBbJ2ZvY3VzZWQnXSxcbiAgICAgICAgICAgIHBydW5lU3BhY2VzOiB0cnVlLFxuICAgICAgICAgICAgYWxsb3dlZFRvQmVSb290OiB0cnVlLFxuICAgICAgICAgICAgYnVpbGRFbXB0eUVsZW1lbnQ6IGdldFNlY3Rpb25FbGVtZW50LFxuICAgICAgICAgICAgYnVpbGRBdHRyaWJ1dGVzOiBbe25hbWU6ICdpZCcsIGJ1aWxkOiBmdW5jdGlvbigpIHtyZXR1cm4gdXVpZCgpfX1dXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZW5yaWNobWVudHM6IFtdLFxuXG4gICAgb25LZXlVcDogcGFyYWdyYXBoU2VjdGlvblR5cGUub25LZXlVcCxcbiAgICBvbktleURvd246IHBhcmFncmFwaFNlY3Rpb25UeXBlLm9uS2V5RG93bixcbiAgICBvbktleUVudGVyOiBoMVNlY3Rpb25UeXBlLm9uS2V5RW50ZXIsXG5cbiAgICBnZXRTZWN0aW9uRWxlbWVudDogZ2V0U2VjdGlvbkVsZW1lbnQsXG59XG4iLCJ2YXIgdXVpZCA9IHJlcXVpcmUoJ3V1aWQvdjEnKSxcbiAgICBwYXJhZ3JhcGhTZWN0aW9uVHlwZSA9IHJlcXVpcmUoJy4uL3BhcmFncmFwaC9wYXJhZ3JhcGhfc2VjdGlvbl90eXBlJyksXG4gICAgaDFTZWN0aW9uVHlwZSA9IHJlcXVpcmUoJy4vaGVhZGluZzEuanMnKTtcblxudmFyIGdldFNlY3Rpb25FbGVtZW50ID0gZnVuY3Rpb24oZXhpc3RpbmdTZWN0aW9uQ29udGVudCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2g0Jyk7XG4gICAgZWwuaW5uZXJIVE1MID0gZXhpc3RpbmdTZWN0aW9uQ29udGVudCB8fCAnJztcbiAgICBlbC5vbktleVVwID0gbW9kdWxlLmV4cG9ydHMub25LZXlVcDtcbiAgICBlbC5vbktleURvd24gPSBtb2R1bGUuZXhwb3J0cy5vbktleURvd247XG4gICAgZWwub25LZXlFbnRlciA9IG1vZHVsZS5leHBvcnRzLm9uS2V5RW50ZXI7XG4gICAgZWwuaWQgPSB1dWlkKCk7XG4gICAgcmV0dXJuIGVsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIG5hbWU6ICdoNCcsXG5cbiAgICBjb250ZW50UnVsZXM6IHtcbiAgICAgICAgJ2g0Jzoge1xuICAgICAgICAgICAgdGFnTmFtZTogJ2g0JyxcbiAgICAgICAgICAgIGFsbG93ZWRBdHRyaWJ1dGVzOiBbJ2NsYXNzJywgJ2lkJ10sXG4gICAgICAgICAgICBhbGxvd2VkQ2hpbGRyZW46IFsnI3RleHQnLCAnaW5saW5lZXF1YXRpb24nXSxcbiAgICAgICAgICAgIGFsbG93ZWRDbGFzc05hbWVzOiBbJ2ZvY3VzZWQnXSxcbiAgICAgICAgICAgIHBydW5lU3BhY2VzOiB0cnVlLFxuICAgICAgICAgICAgYWxsb3dlZFRvQmVSb290OiB0cnVlLFxuICAgICAgICAgICAgYnVpbGRFbXB0eUVsZW1lbnQ6IGdldFNlY3Rpb25FbGVtZW50LFxuICAgICAgICAgICAgYnVpbGRBdHRyaWJ1dGVzOiBbe25hbWU6ICdpZCcsIGJ1aWxkOiBmdW5jdGlvbigpIHtyZXR1cm4gdXVpZCgpfX1dXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZW5yaWNobWVudHM6IFtdLFxuXG4gICAgb25LZXlVcDogcGFyYWdyYXBoU2VjdGlvblR5cGUub25LZXlVcCxcbiAgICBvbktleURvd246IHBhcmFncmFwaFNlY3Rpb25UeXBlLm9uS2V5RG93bixcbiAgICBvbktleUVudGVyOiBoMVNlY3Rpb25UeXBlLm9uS2V5RW50ZXIsXG5cbiAgICBnZXRTZWN0aW9uRWxlbWVudDogZ2V0U2VjdGlvbkVsZW1lbnQsXG59XG4iLCJ2YXIgdXVpZCA9IHJlcXVpcmUoJ3V1aWQvdjEnKSxcbiAgICBwYXJhZ3JhcGhTZWN0aW9uVHlwZSA9IHJlcXVpcmUoJy4uL3BhcmFncmFwaC9wYXJhZ3JhcGhfc2VjdGlvbl90eXBlJyksXG4gICAgaDFTZWN0aW9uVHlwZSA9IHJlcXVpcmUoJy4vaGVhZGluZzEuanMnKTtcblxudmFyIGdldFNlY3Rpb25FbGVtZW50ID0gZnVuY3Rpb24oZXhpc3RpbmdTZWN0aW9uQ29udGVudCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2g1Jyk7XG4gICAgZWwuaW5uZXJIVE1MID0gZXhpc3RpbmdTZWN0aW9uQ29udGVudCB8fCAnJztcbiAgICBlbC5vbktleVVwID0gbW9kdWxlLmV4cG9ydHMub25LZXlVcDtcbiAgICBlbC5vbktleURvd24gPSBtb2R1bGUuZXhwb3J0cy5vbktleURvd247XG4gICAgZWwub25LZXlFbnRlciA9IG1vZHVsZS5leHBvcnRzLm9uS2V5RW50ZXI7XG4gICAgZWwuaWQgPSB1dWlkKCk7XG4gICAgcmV0dXJuIGVsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIG5hbWU6ICdoNScsXG5cbiAgICBjb250ZW50UnVsZXM6IHtcbiAgICAgICAgJ2g1Jzoge1xuICAgICAgICAgICAgdGFnTmFtZTogJ2g1JyxcbiAgICAgICAgICAgIGFsbG93ZWRBdHRyaWJ1dGVzOiBbJ2NsYXNzJywgJ2lkJ10sXG4gICAgICAgICAgICBhbGxvd2VkQ2hpbGRyZW46IFsnI3RleHQnLCAnaW5saW5lZXF1YXRpb24nXSxcbiAgICAgICAgICAgIGFsbG93ZWRDbGFzc05hbWVzOiBbJ2ZvY3VzZWQnXSxcbiAgICAgICAgICAgIHBydW5lU3BhY2VzOiB0cnVlLFxuICAgICAgICAgICAgYWxsb3dlZFRvQmVSb290OiB0cnVlLFxuICAgICAgICAgICAgYnVpbGRFbXB0eUVsZW1lbnQ6IGdldFNlY3Rpb25FbGVtZW50LFxuICAgICAgICAgICAgYnVpbGRBdHRyaWJ1dGVzOiBbe25hbWU6ICdpZCcsIGJ1aWxkOiBmdW5jdGlvbigpIHtyZXR1cm4gdXVpZCgpfX1dXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZW5yaWNobWVudHM6IFtdLFxuXG4gICAgb25LZXlVcDogcGFyYWdyYXBoU2VjdGlvblR5cGUub25LZXlVcCxcbiAgICBvbktleURvd246IHBhcmFncmFwaFNlY3Rpb25UeXBlLm9uS2V5RG93bixcbiAgICBvbktleUVudGVyOiBoMVNlY3Rpb25UeXBlLm9uS2V5RW50ZXIsXG5cbiAgICBnZXRTZWN0aW9uRWxlbWVudDogZ2V0U2VjdGlvbkVsZW1lbnQsXG59XG4iLCJ2YXIgY2hvb3NlRmlsZUJ0bkNvdW50ZXIgPSAwLFxuICAgIGltYWdlU2VjdGlvblR5cGUsXG4gICAgdXVpZCA9IHJlcXVpcmUoJ3V1aWQvdjEnKTtcblxudmFyIGJ1aWxkRW1wdHlJbWdQbGFjZWhvZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGltZ1BsYWNlaG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpLFxuICAgICAgICBlbXB0eUltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaScpLFxuICAgICAgICBjaG9vc2VGaWxlTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpLFxuICAgICAgICBjaG9vc2VGaWxlQnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKSxcbiAgICAgICAgY2hvb3NlRmlsZUJ0bklkID0gJ2Nob29zZUZpbGVCdG4nICsgY2hvb3NlRmlsZUJ0bkNvdW50ZXIrKztcblxuICAgIGVtcHR5SW1hZ2UuY2xhc3NMaXN0LmFkZCgnZW1wdHktaW1hZ2UnKTtcbiAgICBjaG9vc2VGaWxlQnRuLmNsYXNzTGlzdC5hZGQoJ2Nob29zZS1pbWctYnRuJyk7XG4gICAgY2hvb3NlRmlsZUJ0bi5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnZmlsZScpO1xuICAgIGNob29zZUZpbGVCdG4uc2V0QXR0cmlidXRlKCdpZCcsIGNob29zZUZpbGVCdG5JZCk7XG5cbiAgICBjaG9vc2VGaWxlTGFiZWwuY2xhc3NMaXN0LmFkZCgnY2hvb3NlLWltZy1idG4tbGFiZWwnKTtcbiAgICBjaG9vc2VGaWxlTGFiZWwuaW5uZXJIVE1MID0gJ0NsaWNrIHRvIEltcG9ydCBJbWFnZSAob3IgZHJhZyBhbmQgZHJvcCBpdCknO1xuXG4gICAgaW1nUGxhY2Vob2xkZXIuc2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnLCBmYWxzZSk7XG4gICAgaW1nUGxhY2Vob2xkZXIuY2xhc3NMaXN0LmFkZCgnaW1hZ2UtaW1nLXBsYWNlaG9sZGVyJyk7XG4gICAgaW1nUGxhY2Vob2xkZXIuYXBwZW5kQ2hpbGQoY2hvb3NlRmlsZUxhYmVsKTtcbiAgICBpbWdQbGFjZWhvbGRlci5hcHBlbmRDaGlsZChjaG9vc2VGaWxlQnRuKTtcbiAgICBpbWdQbGFjZWhvbGRlci5hcHBlbmRDaGlsZChlbXB0eUltYWdlKTtcblxuICAgIHZhciBnZXRJbWFnZU9yUGxhY2Vob2xkZXJCeUFDaGlsZCA9IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIGlmKCFjaGlsZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoY2hpbGQuY2xhc3NMaXN0LmNvbnRhaW5zKCdpbWFnZS1pbWctcGxhY2Vob2xkZXInKSB8fCBjaGlsZC50YWdOYW1lID09PSAnSU1HJykge1xuICAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0SW1hZ2VPclBsYWNlaG9sZGVyQnlBQ2hpbGQoY2hpbGQucGFyZW50RWxlbWVudCk7XG4gICAgfVxuXG4gICAgaW1nUGxhY2Vob2xkZXIub25jbGljayA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYoaW1hZ2VTZWN0aW9uVHlwZSkge1xuICAgICAgICAgICAgaW1hZ2VTZWN0aW9uVHlwZS5lZGl0b3IuZm9jdXNTZWN0aW9uKGUudGFyZ2V0LnBhcmVudEVsZW1lbnQpXG4gICAgICAgIH1cblxuICAgICAgICBjaG9vc2VGaWxlQnRuLmNsaWNrKClcbiAgICB9XG5cbiAgICBpbWdQbGFjZWhvbGRlci5vbmRyb3AgPSBjaG9vc2VGaWxlQnRuLm9uY2hhbmdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgdmFyIGN1cnJlbnRJbWcgPSBnZXRJbWFnZU9yUGxhY2Vob2xkZXJCeUFDaGlsZChlLnRhcmdldCksXG4gICAgICAgICAgICBzZWN0aW9uRWxlbWVudCA9IGN1cnJlbnRJbWcucGFyZW50Tm9kZTtcblxuICAgICAgICBpZighc2VjdGlvbkVsZW1lbnQgfHwgIWRvY3VtZW50LmJvZHkuY29udGFpbnMoc2VjdGlvbkVsZW1lbnQpKSB7XG4gICAgICAgICAgICBzZWN0aW9uRWxlbWVudCA9IGltYWdlU2VjdGlvblR5cGUuZWRpdG9yLmZvY3VzZWRTZWN0aW9uKCk7XG4gICAgICAgICAgICBjdXJyZW50SW1nID0gc2VjdGlvbkVsZW1lbnQucXVlcnlTZWxlY3RvcignaW1nJykgfHwgc2VjdGlvbkVsZW1lbnQucXVlcnlTZWxlY3RvcignLmltYWdlLWltZy1wbGFjZWhvbGRlcicpXG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50SW1nLmNsYXNzTGlzdC5yZW1vdmUoJ2RyYWdvdmVyJyk7XG5cbiAgICAgICAgdmFyIGZpbGVzID0gZS50YXJnZXQuZmlsZXMgfHwgZS5kYXRhVHJhbnNmZXIuZmlsZXM7XG5cbiAgICAgICAgdmFyIGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgICAgICB2YXIgcGVyc2lzdFJlc3VsdCA9IGltYWdlU2VjdGlvblR5cGUucGVyc2lzdEZpbGUoZmlsZXNbMF0pO1xuXG4gICAgICAgIGlmKHBlcnNpc3RSZXN1bHQudGhlbikge1xuICAgICAgICAgICAgcGVyc2lzdFJlc3VsdC50aGVuKHVybCA9PiBpbWcuc3JjID0gdXJsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGltZy5zcmMgPSBwZXJzaXN0UmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudEltZy5wYXJlbnRFbGVtZW50LnJlcGxhY2VDaGlsZChpbWcsIGN1cnJlbnRJbWcpO1xuICAgICAgICBpbWcub25kcm9wID0gY3VycmVudEltZy5vbmRyb3A7XG4gICAgICAgIGltZy5vbmRyYWdvdmVyID0gY3VycmVudEltZy5vbmRyYWdvdmVyO1xuICAgICAgICBpbWcub25kcmFnbGVhdmUgPSBjdXJyZW50SW1nLm9uZHJhZ2xlYXZlO1xuICAgICAgICBpbWcub25jbGljayA9IGltZ1BsYWNlaG9sZGVyLm9uY2xpY2tcblxuICAgICAgICBzZWN0aW9uRWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnaW1hZ2UtdXBsb2FkJywge2J1YmJsZXM6IHRydWUsIGRldGFpbDoge3VybDogaW1nLnNyY319KSk7XG4gICAgICAgIHNlY3Rpb25FbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdpbnB1dCcsIHtidWJibGVzOiB0cnVlfSkpO1xuICAgIH1cblxuICAgIGltZ1BsYWNlaG9sZGVyLm9uZHJhZ292ZXIgPSBmdW5jdGlvbihlKSB7IGdldEltYWdlT3JQbGFjZWhvbGRlckJ5QUNoaWxkKGUudGFyZ2V0KS5jbGFzc0xpc3QuYWRkKCdkcmFnb3ZlcicpOyBlLnByZXZlbnREZWZhdWx0KCk7IH1cbiAgICBpbWdQbGFjZWhvbGRlci5vbmRyYWdsZWF2ZSA9IGZ1bmN0aW9uKGUpIHsgZ2V0SW1hZ2VPclBsYWNlaG9sZGVyQnlBQ2hpbGQoZS50YXJnZXQpLmNsYXNzTGlzdC5yZW1vdmUoJ2RyYWdvdmVyJyk7IGUucHJldmVudERlZmF1bHQoKTsgfVxuXG4gICAgcmV0dXJuIGltZ1BsYWNlaG9sZGVyO1xufVxuXG52YXIgZ2V0U2VjdGlvbkVsZW1lbnQgPSBmdW5jdGlvbihleGlzdGluZ1NlY3Rpb25Db250ZW50KSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZmlndXJlJyksXG4gICAgICAgIGNhcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmaWdjYXB0aW9uJyk7XG5cbiAgICBlbC5pZCA9IHV1aWQoKTtcbiAgICBlbC5zZWN0aW9uVHlwZSA9IGltYWdlU2VjdGlvblR5cGU7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdkaXNwbGF5LWNhcHRpb24nLCAnWWVzJyk7XG4gICAgY2FwdGlvbi5pbm5lckhUTUwgPSAnaW1hZ2UgdGl0bGUnO1xuICAgIGVsLmFwcGVuZENoaWxkKGJ1aWxkRW1wdHlJbWdQbGFjZWhvZGVyKCkpO1xuICAgIGVsLmFwcGVuZENoaWxkKGNhcHRpb24pO1xuICAgIGVsLm9uS2V5QmFja3NwYWNlID0gaW1hZ2VTZWN0aW9uVHlwZS5vbktleUJhY2tzcGFjZTtcbiAgICBlbC5vbktleUVudGVyID0gaW1hZ2VTZWN0aW9uVHlwZS5vbktleUVudGVyO1xuXG4gICAgcmV0dXJuIGVsO1xufVxuXG5pbWFnZVNlY3Rpb25UeXBlID0ge1xuXG4gICAgbmFtZTogJ2ltZycsXG5cbiAgICBjb250ZW50UnVsZXM6IHtcbiAgICAgICAgJ2ltYWdlJzoge1xuICAgICAgICAgICAgdGFnTmFtZTogJ2ZpZ3VyZScsXG4gICAgICAgICAgICBhbGxvd2VkQXR0cmlidXRlczogWydjbGFzcycsICdkaXNwbGF5LWNhcHRpb24nLCAnaWQnXSxcbiAgICAgICAgICAgIGFsbG93ZWRDbGFzc05hbWVzOiBbJ2ZvY3VzZWQnXSxcbiAgICAgICAgICAgIGFsbG93ZWRDaGlsZHJlbjogWydpbWFnZS1pbWcnLCAnaW1hZ2UtY2FwdGlvbicsICdpbWFnZS1pbWctcGxhY2Vob2xkZXInXSxcbiAgICAgICAgICAgIGNoaWxkcmVuQ2FyZGluYWxpdHk6IHsnaW1hZ2UtY2FwdGlvbic6IHttYXg6IDF9LCAnaW1hZ2UtaW1nLXBsYWNlaG9sZGVyJzoge21heDogMX19LFxuICAgICAgICAgICAgYWxsb3dlZFRvQmVSb290OiB0cnVlLFxuICAgICAgICAgICAgZGVsZXRlSWZFbXB0eTogZmFsc2UsXG4gICAgICAgICAgICBidWlsZEVtcHR5RWxlbWVudDogZ2V0U2VjdGlvbkVsZW1lbnQsXG4gICAgICAgICAgICBidWlsZEF0dHJpYnV0ZXM6IFtcbiAgICAgICAgICAgICAgICB7bmFtZTogJ2lkJywgYnVpbGQ6IGZ1bmN0aW9uKCkge3JldHVybiB1dWlkKCl9fSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ2Rpc3BsYXktY2FwdGlvbicsIGJ1aWxkOiBmdW5jdGlvbigpIHtyZXR1cm4gJ1llcyd9fVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICAnaW1hZ2UtaW1nJzoge1xuICAgICAgICAgICAgdGFnTmFtZTogJ2ltZycsXG4gICAgICAgICAgICBhbGxvd2VkQXR0cmlidXRlczogWydzcmMnXSxcbiAgICAgICAgICAgIGFsbG93ZWRTdWNjZXNzb3JzOiBbJ2ltYWdlLWNhcHRpb24nXSxcbiAgICAgICAgICAgIGFsbG93ZWRDaGlsZHJlbjogW11cbiAgICAgICAgfSxcbiAgICAgICAgJ2ltYWdlLWltZy1wbGFjZWhvbGRlcic6IHtcbiAgICAgICAgICAgIHRhZ05hbWU6ICdzcGFuJyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2ltYWdlLWltZy1wbGFjZWhvbGRlcicsXG4gICAgICAgICAgICBhbGxvd2VkQXR0cmlidXRlczogWydjbGFzcycsICdjb250ZW50ZWRpdGFibGUnXSxcbiAgICAgICAgICAgIGFsbG93ZWRDbGFzc05hbWVzOiBbJ2ltYWdlLWltZy1wbGFjZWhvbGRlciddLFxuICAgICAgICAgICAgYWxsb3dlZFN1Y2Nlc3NvcnM6IFsnaW1hZ2UtY2FwdGlvbiddLFxuICAgICAgICAgICAgYWxsb3dlZENoaWxkcmVuOiBbJ2VtcHR5LWltYWdlJywgJ2Nob29zZS1pbWctYnRuJywgJ2Nob29zZS1pbWctYnRuLWxhYmVsJ10sXG4gICAgICAgICAgICBkZWxldGVJZkVtcHR5OiBmYWxzZSxcbiAgICAgICAgICAgIGJ1aWxkRW1wdHlFbGVtZW50OiBidWlsZEVtcHR5SW1nUGxhY2Vob2RlclxuICAgICAgICB9LFxuICAgICAgICAnZW1wdHktaW1hZ2UnOiB7XG4gICAgICAgICAgICB0YWdOYW1lOiAnaScsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdlbXB0eS1pbWFnZScsXG4gICAgICAgICAgICBhbGxvd2VkQXR0cmlidXRlczogWydjbGFzcyddLFxuICAgICAgICAgICAgYWxsb3dlZENsYXNzTmFtZXM6IFsnZW1wdHktaW1hZ2UnXSxcbiAgICAgICAgICAgIGFsbG93ZWRDaGlsZHJlbjogW10sXG4gICAgICAgICAgICBkZWxldGVJZkVtcHR5OiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgICAgJ2Nob29zZS1pbWctYnRuJzoge1xuICAgICAgICAgICAgdGFnTmFtZTogJ2lucHV0JyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2Nob29zZS1pbWctYnRuJyxcbiAgICAgICAgICAgIGFsbG93ZWRBdHRyaWJ1dGVzOiBbJ2NsYXNzJywgJ3R5cGUnLCAnaWQnXSxcbiAgICAgICAgICAgIGFsbG93ZWRDbGFzc05hbWVzOiBbJ2Nob29zZS1pbWctYnRuJ10sXG4gICAgICAgICAgICBkZWxldGVJZkVtcHR5OiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICAnY2hvb3NlLWltZy1idG4tbGFiZWwnOiB7XG4gICAgICAgICAgICB0YWdOYW1lOiAnbGFiZWwnLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAnY2hvb3NlLWltZy1idG4tbGFiZWwnLFxuICAgICAgICAgICAgYWxsb3dlZENsYXNzTmFtZXM6IFsnY2hvb3NlLWltZy1idG4tbGFiZWwnXSxcbiAgICAgICAgICAgIGFsbG93ZWRBdHRyaWJ1dGVzOiBbJ2NsYXNzJ10sXG4gICAgICAgICAgICBhbGxvd2VkQ2hpbGRyZW46IFsnI3RleHQnXVxuICAgICAgICB9LFxuICAgICAgICAnaW1hZ2UtY2FwdGlvbic6IHtcbiAgICAgICAgICAgIHRhZ05hbWU6ICdmaWdjYXB0aW9uJyxcbiAgICAgICAgICAgIGFsbG93ZWRDaGlsZHJlbjogWycjdGV4dCcsICdyZWZlcmVuY2UnLCAnaW5saW5lZXF1YXRpb24nXSxcbiAgICAgICAgICAgIGFsbG93ZWRQcmVkZWNlc3NvcnM6IFsnaW1hZ2UtaW1nLXBsYWNlaG9sZGVyJywgJ2ltYWdlLWltZyddLFxuICAgICAgICAgICAgZGVsZXRlSWZFbXB0eTogZmFsc2UsXG4gICAgICAgICAgICBwcnVuZVNwYWNlczogdHJ1ZVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGVucmljaG1lbnRzOiBbXSxcblxuICAgIGdldE9wdGlvbnM6IGZ1bmN0aW9uKHNlY3Rpb25FbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5hbWU6ICdkaXNwbGF5Q2FwdGlvbicsXG4gICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiAnRGlzcGxheSBJbWFnZSBDYXB0aW9uJyxcbiAgICAgICAgICAgICAgYWxsb3dlZFZhbHVlczogWydZZXMnLCAnTm8nXSxcbiAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBzZWN0aW9uRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2Rpc3BsYXktY2FwdGlvbicpXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuXG4gICAgb25PcHRpb25zQ2hhbmdlOiBmdW5jdGlvbihvcHQsIGVkaXRvcikge1xuICAgICAgICB2YXIgc2VjdGlvbiA9IGVkaXRvci5mb2N1c2VkU2VjdGlvbigpO1xuICAgICAgICBpZihvcHQuZGlzcGxheUNhcHRpb24gPT09ICdZZXMnIHx8IG9wdC5kaXNwbGF5Q2FwdGlvbiA9PT0gJ05vJykge1xuICAgICAgICAgICAgc2VjdGlvbi5zZXRBdHRyaWJ1dGUoJ2Rpc3BsYXktY2FwdGlvbicsIG9wdC5kaXNwbGF5Q2FwdGlvbik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0RWRpdG9yOiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBwZXJzaXN0RmlsZTogZnVuY3Rpb24oYmxvYikge1xuICAgICAgICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICB9LFxuXG4gICAgb25LZXlCYWNrc3BhY2U6IGZ1bmN0aW9uKGUsIGVkaXRvcikge1xuICAgICAgICB2YXIgY2FwdGlvbiA9IGVkaXRvci5jYXJldC5nZXRDb250ZXh0RWxlbWVudCgnZmlnY2FwdGlvbicpO1xuICAgICAgICBpZihjYXB0aW9uLmlubmVyVGV4dCA9PT0gJycpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvbktleUVudGVyOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuXG4gICAgb25Gb2N1czogZnVuY3Rpb24oZWwsIGVkaXRvciwgYXJncykge1xuICAgICAgICB2YXIgY2FwdGlvbiA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ2ZpZ2NhcHRpb24nKSxcbiAgICAgICAgICAgIGlzQ2FyZXRJbnNpZGVTZWN0aW9uID0gKGVkaXRvci5zZWN0aW9uQXRDYXJldFBvc3Rpb24oKSA9PT0gZWwgJiYgZWRpdG9yLmNhcmV0LmdldENvbnRleHRFbGVtZW50KCdmaWdjYXB0aW9uJykpLFxuICAgICAgICAgICAgaGFzQmVlbkZvY3VzZWRBZnRlclNlY3Rpb25UeXBlQ2hhbmdlID0gYXJncy5hY3Rpb24gPT09ICdjaGFuZ2VGb2N1c2VkU2VjdGlvblR5cGUnO1xuXG4gICAgICAgIGlmKGhhc0JlZW5Gb2N1c2VkQWZ0ZXJTZWN0aW9uVHlwZUNoYW5nZSB8fCAhaXNDYXJldEluc2lkZVNlY3Rpb24pIHtcbiAgICAgICAgICAgIGNhcHRpb24gJiYgZWRpdG9yLmNhcmV0LnBvc2l0aW9uSW4oY2FwdGlvbik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0U2VjdGlvbkVsZW1lbnQ6IGdldFNlY3Rpb25FbGVtZW50XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW1hZ2VTZWN0aW9uVHlwZTtcbiIsInZhciBzaGFyZWQgPSByZXF1aXJlKCcuLi9zaGFyZWQvc2hhcmVkJyk7XG52YXIgdW5vcmRlcmVkTGlzdFNlY3Rpb25UeXBlID0gcmVxdWlyZSgnLi91bm9yZGVyZWRfbGlzdF9zZWN0aW9uX3R5cGUnKTtcblxudmFyIGdldFNlY3Rpb25FbGVtZW50ID0gZnVuY3Rpb24oZXhpc3RpbmdTZWN0aW9uQ29udGVudCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29sJyk7XG4gICAgZWwub25LZXlVcCA9IG1vZHVsZS5leHBvcnRzLm9uS2V5VXA7XG4gICAgZWwub25LZXlEb3duID0gbW9kdWxlLmV4cG9ydHMub25LZXlEb3duO1xuICAgIGVsLm9uS2V5RW50ZXIgPSBtb2R1bGUuZXhwb3J0cy5vbktleUVudGVyO1xuICAgIGVsLm9uS2V5VGFiID0gbW9kdWxlLmV4cG9ydHMub25LZXlUYWI7XG4gICAgZWwub25LZXlCYWNrc3BhY2UgPSBtb2R1bGUuZXhwb3J0cy5vbktleUJhY2tzcGFjZTtcbiAgICBlbC5pbm5lckhUTUwgPSAnPGxpPicgKyBleGlzdGluZ1NlY3Rpb25Db250ZW50ICsgJzwvbGk+JztcbiAgICByZXR1cm4gZWw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgbmFtZTogJ29sJyxcblxuICAgIGNvbnRlbnRSdWxlczoge1xuICAgICAgICAnb2wnOiB7XG4gICAgICAgICAgICB0YWdOYW1lOiAnb2wnLFxuICAgICAgICAgICAgYWxsb3dlZEF0dHJpYnV0ZXM6IFsnY2xhc3MnXSxcbiAgICAgICAgICAgIGFsbG93ZWRDbGFzc05hbWVzOiBbJ2ZvY3VzZWQnXSxcbiAgICAgICAgICAgIGFsbG93ZWRDaGlsZHJlbjogWydsaScsICdvbCddLFxuICAgICAgICAgICAgYWxsb3dlZFRvQmVSb290OiB0cnVlLFxuICAgICAgICAgICAgYnVpbGRFbXB0eUVsZW1lbnQ6IGdldFNlY3Rpb25FbGVtZW50XG4gICAgICAgIH0sXG4gICAgICAgICdsaSc6IHtcbiAgICAgICAgICAgIHRhZ05hbWU6ICdsaScsXG4gICAgICAgICAgICBwcnVuZVNwYWNlczogdHJ1ZSxcbiAgICAgICAgICAgIGRvTm90QnJlYWtPdXRSb290RWxlbWVudHM6IHRydWUsXG4gICAgICAgICAgICBhbGxvd2VkQ2hpbGRyZW46IFsnI3RleHQnLCAnbGluaycsICdiJywgJ2knLCAndScsICdyZWZlcmVuY2UnLCAnZm9vdG5vdGUnLCAnaW5saW5lY29kZScsICdpbmxpbmVlcXVhdGlvbiddLFxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGVucmljaG1lbnRzOiBbXSxcblxuICAgIGdldFNlY3Rpb25FbGVtZW50OiBnZXRTZWN0aW9uRWxlbWVudCxcbiAgICBpbmRlbnRGb2N1c2VkTGlzdEl0ZW06IHVub3JkZXJlZExpc3RTZWN0aW9uVHlwZS5pbmRlbnRGb2N1c2VkTGlzdEl0ZW0sXG4gICAgb25LZXlVcDogdW5vcmRlcmVkTGlzdFNlY3Rpb25UeXBlLm9uS2V5VXAsXG4gICAgb25LZXlEb3duOiB1bm9yZGVyZWRMaXN0U2VjdGlvblR5cGUub25LZXlEb3duLFxuICAgIG9uS2V5QmFja3NwYWNlOiB1bm9yZGVyZWRMaXN0U2VjdGlvblR5cGUub25LZXlCYWNrc3BhY2UsXG4gICAgb25LZXlFbnRlcjogZnVuY3Rpb24oZSkge30sXG4gICAgb25LZXlUYWI6IHVub3JkZXJlZExpc3RTZWN0aW9uVHlwZS5vbktleVRhYlxufVxuIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4uL3NoYXJlZC9zaGFyZWQnKSxcbiAgICBwYXJhZ3JhcGhTZWN0aW9uVHlwZSA9IHJlcXVpcmUoJy4uL3BhcmFncmFwaC9wYXJhZ3JhcGhfc2VjdGlvbl90eXBlJyk7XG5cbnZhciBnZXRTZWN0aW9uRWxlbWVudCA9IGZ1bmN0aW9uKGV4aXN0aW5nU2VjdGlvbkNvbnRlbnQpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xuICAgIGVsLm9uS2V5VXAgPSBtb2R1bGUuZXhwb3J0cy5vbktleVVwO1xuICAgIGVsLm9uS2V5RG93biA9IG1vZHVsZS5leHBvcnRzLm9uS2V5RG93bjtcbiAgICBlbC5vbktleUVudGVyID0gbW9kdWxlLmV4cG9ydHMub25LZXlFbnRlcjtcbiAgICBlbC5vbktleVRhYiA9IG1vZHVsZS5leHBvcnRzLm9uS2V5VGFiO1xuICAgIGVsLm9uS2V5QmFja3NwYWNlID0gbW9kdWxlLmV4cG9ydHMub25LZXlCYWNrc3BhY2U7XG4gICAgZWwuaW5uZXJIVE1MID0gJzxsaT4nICsgZXhpc3RpbmdTZWN0aW9uQ29udGVudCArICc8L2xpPic7XG4gICAgcmV0dXJuIGVsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIG5hbWU6ICd1bCcsXG5cbiAgICBjb250ZW50UnVsZXM6IHtcbiAgICAgICAgJ3VsJzoge1xuICAgICAgICAgICAgdGFnTmFtZTogJ3VsJyxcbiAgICAgICAgICAgIGFsbG93ZWRBdHRyaWJ1dGVzOiBbJ2NsYXNzJ10sXG4gICAgICAgICAgICBhbGxvd2VkQ2xhc3NOYW1lczogWydmb2N1c2VkJ10sXG4gICAgICAgICAgICBhbGxvd2VkQ2hpbGRyZW46IFsnbGknLCAndWwnXSxcbiAgICAgICAgICAgIGFsbG93ZWRUb0JlUm9vdDogdHJ1ZSxcbiAgICAgICAgICAgIGJ1aWxkRW1wdHlFbGVtZW50OiBnZXRTZWN0aW9uRWxlbWVudFxuICAgICAgICB9LFxuICAgICAgICAvLyBUaGUgbGkgY29udGVudCBydWxlcyBhcmUgZGVmaW5lZCBpbiB0aGUgb3JkZXJlZCBsaXN0IHNlY3Rpb24gdHlwZVxuICAgICAgICAvLyAnbGknOiB7fVxuICAgIH0sXG5cbiAgICBlbnJpY2htZW50czogW10sXG5cbiAgICBnZXRTZWN0aW9uRWxlbWVudDogZ2V0U2VjdGlvbkVsZW1lbnQsXG5cbiAgICBvbktleVVwOiBwYXJhZ3JhcGhTZWN0aW9uVHlwZS5vbktleVVwLFxuICAgIG9uS2V5RG93bjogcGFyYWdyYXBoU2VjdGlvblR5cGUub25LZXlEb3duLFxuXG4gICAgb25LZXlCYWNrc3BhY2U6IGZ1bmN0aW9uKGUsIGVkaXRvcikge1xuICAgICAgICB2YXIgZm9jdXNlZFNlY3Rpb24gPSBlZGl0b3IuZm9jdXNlZFNlY3Rpb24oKSxcbiAgICAgICAgICAgIHVwcGVyU2VjdGlvbixcbiAgICAgICAgICAgIGFsbExpc3RJdGVtcyxcbiAgICAgICAgICAgIHRhcmdldExpc3RJdGVtID0gZWRpdG9yLmNhcmV0LmdldENvbnRleHRFbGVtZW50KCdsaScpLFxuICAgICAgICAgICAgdGFyZ2V0TGlzdEl0ZW1JbmRleCxcbiAgICAgICAgICAgIHVwcGVyTGlzdEl0ZW07XG5cbiAgICAgICAgaWYodGFyZ2V0TGlzdEl0ZW0gJiYgdGFyZ2V0TGlzdEl0ZW0uaW5uZXJUZXh0LnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgICAgIHVwcGVyU2VjdGlvbiA9IGZvY3VzZWRTZWN0aW9uLnByZXZpb3VzU2libGluZyxcbiAgICAgICAgICAgIGFsbExpc3RJdGVtcyA9IGZvY3VzZWRTZWN0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJ2xpJyksXG4gICAgICAgICAgICB0YXJnZXRMaXN0SXRlbUluZGV4ID0gYWxsTGlzdEl0ZW1zLmluZGV4T2YodGFyZ2V0TGlzdEl0ZW0pLFxuICAgICAgICAgICAgdXBwZXJMaXN0SXRlbSA9IGFsbExpc3RJdGVtc1t0YXJnZXRMaXN0SXRlbUluZGV4LTFdO1xuXG4gICAgICAgICAgICBpZih1cHBlckxpc3RJdGVtKSB7XG4gICAgICAgICAgICAgICAgZWRpdG9yLmNhcmV0LnBvc2l0aW9uSW4odXBwZXJMaXN0SXRlbSk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0TGlzdEl0ZW0ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgZWRpdG9yLnJlcGxhY2VTZWN0aW9uV2l0aEhUTUwoZm9jdXNlZFNlY3Rpb24sIGZvY3VzZWRTZWN0aW9uLm91dGVySFRNTCk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmKHVwcGVyU2VjdGlvbikge1xuICAgICAgICAgICAgICAgIHRhcmdldExpc3RJdGVtLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIGVkaXRvci5yZXBsYWNlU2VjdGlvbldpdGhIVE1MKGZvY3VzZWRTZWN0aW9uLCBmb2N1c2VkU2VjdGlvbi5vdXRlckhUTUwpO1xuICAgICAgICAgICAgICAgIGVkaXRvci5jYXJldC5wb3NpdGlvbkluKHVwcGVyU2VjdGlvbik7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgb25LZXlFbnRlcjogZnVuY3Rpb24oZSkge30sXG4gICAgb25LZXlUYWI6IGZ1bmN0aW9uKGUsIGVkaXRvcikgIHtcbiAgICAgICAgaWYoIWUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzLmluZGVudEZvY3VzZWRMaXN0SXRlbShlZGl0b3IpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb2N1bWVudC5leGVjQ29tbWFuZCgnb3V0ZGVudCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG5cbiAgICBpbmRlbnRGb2N1c2VkTGlzdEl0ZW06IGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgICAgICAgdmFyIHRhcmdldExpc3RJdGVtID0gZWRpdG9yLmNhcmV0LmdldENvbnRleHRFbGVtZW50KCdsaScpLFxuICAgICAgICAgICAgcHJldmlvdXNMaXN0SXRlbSwgbmV4dExpc3RJdGVtLCBwYXJlbnRFbGVtZW50LFxuICAgICAgICAgICAgaXNUYXJnZXRMaXN0SXRlbUVtcHR5ID0gdGFyZ2V0TGlzdEl0ZW0uaW5uZXJUZXh0ID09PSAnJztcblxuICAgICAgICBpZih0YXJnZXRMaXN0SXRlbSkge1xuICAgICAgICAgICAgcHJldmlvdXNMaXN0SXRlbSA9IHRhcmdldExpc3RJdGVtLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgIG5leHRMaXN0SXRlbSA9IHRhcmdldExpc3RJdGVtLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgcGFyZW50RWxlbWVudCA9IHRhcmdldExpc3RJdGVtLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBkb2N1bWVudC5leGVjQ29tbWFuZCgnaW5kZW50Jyk7XG5cbiAgICAgICAgaWYoaXNUYXJnZXRMaXN0SXRlbUVtcHR5KSB7XG4gICAgICAgICAgICBpZihwcmV2aW91c0xpc3RJdGVtICYmIHByZXZpb3VzTGlzdEl0ZW0ubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICBlZGl0b3IuY2FyZXQucG9zaXRpb25JbihwcmV2aW91c0xpc3RJdGVtLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZihuZXh0TGlzdEl0ZW0gJiYgbmV4dExpc3RJdGVtLnByZXZpb3VzU2libGluZykge1xuICAgICAgICAgICAgICAgIGVkaXRvci5jYXJldC5wb3NpdGlvbkluKG5leHRMaXN0SXRlbS5wcmV2aW91c1NpYmxpbmcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmKCFwcmV2aW91c0xpc3RJdGVtICYmICFuZXh0TGlzdEl0ZW0gJiYgcGFyZW50RWxlbWVudCAmJiBwYXJlbnRFbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICBlZGl0b3IuY2FyZXQucG9zaXRpb25JbihwYXJlbnRFbGVtZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuIiwidmFyIGNvZGUyZGlhID0gcmVxdWlyZSgnLi4vc2hhcmVkL2NvZGUyZGlhX3NlY3Rpb25fdHlwZScpLFxuICAgIC8vIG1lcm1haWQgPSByZXF1aXJlKCdtZXJtYWlkJyksIC8vIG1ha2Ugc3VyZSB0byBsb2FkIDxzY3JpcHQgc3JjPVwiLi9tZXJtYWlkLmpzXCIgZGVmZXI+PC9zY3JpcHQ+IGluIHlvdXIgaHRtbFxuICAgIHJlbmRlcjtcblxuZnVuY3Rpb24gZG9jUmVhZHkoZm4pIHtcbiAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8IGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiaW50ZXJhY3RpdmVcIikge1xuICAgICAgICBzZXRUaW1lb3V0KGZuLCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBmbik7XG4gICAgfVxufVxuXG5kb2NSZWFkeShmdW5jdGlvbigpIHtcbiAgICBtZXJtYWlkLmluaXRpYWxpemUoeyBzdGFydE9uTG9hZDogZmFsc2UsICdmb250LXNpemUnOiAnMTBweCcgfSlcbn0pXG5cbnJlbmRlciA9IGZ1bmN0aW9uKHJlbmRlckVsLCBjb250ZW50KSB7XG4gICAgdmFyIHRtcENvbnRhaW5lciwgaWQ7XG5cbiAgICBpZihjb250ZW50LnRyaW0oKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmVuZGVyRWwuaW5uZXJIVE1MID0gJ1dyaXRlIHNvbWUgbWVybWFpZCBoZXJlIDxzcGFuIGNsYXNzPVwiYXJyb3dcIj4mIzEwNTQ4Ozwvc3Bhbj4nO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbmRlckVsLmlkID0gcmVuZGVyRWwuaWQgfHwgJ3Rlc3QyJztcbiAgICAgICAgaWQgPSAncicgKyByZW5kZXJFbC5wYXJlbnRFbGVtZW50LmlkO1xuICAgICAgICByZW5kZXJFbC5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgcmVuZGVyRWwuY2xhc3NMaXN0LmFkZCgnbWVybWFpZCcpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtZXJtYWlkLnJlbmRlcihpZCwgY29udGVudCwgKHJlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVuZGVyRWwuaW5uZXJIVE1MID0gcmU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIHJlbmRlckVsLmlubmVySFRNTCA9IGV4Lm1lc3NhZ2UucmVwbGFjZSgvXFxuL2csICc8YnIvPicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdG1wQ29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2QnICsgaWQpO1xuICAgICAgICBpZih0bXBDb250YWluZXIpIHtcbiAgICAgICAgICAgIHRtcENvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb2RlMmRpYShyZW5kZXIsICdtZXJtYWlkJywgJ2xhdGV4JywgJ2ltYWdlIHRpdGxlJylcbiIsInZhciBnZXRTZWN0aW9uRWxlbWVudCA9IGZ1bmN0aW9uKGV4aXN0aW5nU2VjdGlvbkNvbnRlbnQpIHtcbiAgICBleGlzdGluZ1NlY3Rpb25Db250ZW50ID0gZXhpc3RpbmdTZWN0aW9uQ29udGVudCB8fCAnJztcbiAgICBleGlzdGluZ1NlY3Rpb25Db250ZW50ID0gZXhpc3RpbmdTZWN0aW9uQ29udGVudC5yZXBsYWNlKC88Y2FwdGlvbj4uKj88XFwvY2FwdGlvbj4vLCAnJyk7XG5cbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gICAgZWwuaW5uZXJIVE1MID0gZXhpc3RpbmdTZWN0aW9uQ29udGVudDtcbiAgICBlbC5vbktleVVwID0gbW9kdWxlLmV4cG9ydHMub25LZXlVcDtcbiAgICBlbC5vbktleURvd24gPSBtb2R1bGUuZXhwb3J0cy5vbktleURvd247XG4gICAgcmV0dXJuIGVsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIG5hbWU6ICdwJyxcblxuICAgIGNvbnRlbnRSdWxlczoge1xuICAgICAgICAncCc6IHtcbiAgICAgICAgICAgIHRhZ05hbWU6ICdwJyxcbiAgICAgICAgICAgIGFsbG93ZWRBdHRyaWJ1dGVzOiBbJ2NsYXNzJ10sXG4gICAgICAgICAgICBhbGxvd2VkQ2xhc3NOYW1lczogWydmb2N1c2VkJ10sXG4gICAgICAgICAgICBhbGxvd2VkQ2hpbGRyZW46IFsnI3RleHQnLCAnYicsICdpJywgJ3UnLCAnbGluaycsICdmb290bm90ZScsICdyZWZlcmVuY2UnLCAnaW5saW5lY29kZScsICdpbmxpbmVlcXVhdGlvbiddLFxuICAgICAgICAgICAgcHJ1bmVTcGFjZXM6IHRydWUsXG4gICAgICAgICAgICBhbGxvd2VkVG9CZVJvb3Q6IHRydWUsXG4gICAgICAgICAgICBidWlsZEVtcHR5RWxlbWVudDogZ2V0U2VjdGlvbkVsZW1lbnRcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBlbnJpY2htZW50czogW10sXG5cbiAgICBvbktleVVwOiBmdW5jdGlvbihlLCBlZGl0b3IpIHtcbiAgICAgICAgaWYoZWRpdG9yLmNhcmV0LmlzQ29sbGFwc2VkQW5kUG9zaXRpb25lZEF0VGhlRmlyc3RMaW5lT2YoZWRpdG9yLmZvY3VzZWRTZWN0aW9uKCkpKSB7XG4gICAgICAgICAgICBlZGl0b3IubW92ZUNhcmV0T25lU2VjdGlvblVwKCdlbmQnKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvbktleURvd246IGZ1bmN0aW9uKGUsIGVkaXRvcikge1xuICAgICAgICBpZihlZGl0b3IuY2FyZXQuaXNDb2xsYXBzZWRBbmRQb3NpdGlvbmVkQXRUaGVMYXN0TGluZU9mKGVkaXRvci5mb2N1c2VkU2VjdGlvbigpKSkge1xuICAgICAgICAgICAgZWRpdG9yLm1vdmVDYXJldE9uZVNlY3Rpb25Eb3duKCdwcmVmZXJyZWRPckJlZ2lubmluZycpO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldFNlY3Rpb25FbGVtZW50OiBnZXRTZWN0aW9uRWxlbWVudCxcbn1cbiIsInZhciBIVE1MUmF6b3IgPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvaHRtbF9yYXpvci9odG1sX3Jhem9yJyksXG4gICAgdGhyb3R0bGUgPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvdGhyb3R0bGUvdGhyb3R0bGUnKSxcbiAgICBjb2RlU2VjdGlvblR5cGUgPSByZXF1aXJlKCcuLi9jb2RlL2NvZGVfc2VjdGlvbl90eXBlJyksXG4gICAgcHJpbXNqcyA9IHJlcXVpcmUoJ3ByaXNtanMnKSxcbiAgICB1dWlkID0gcmVxdWlyZSgndXVpZC92MScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHJlbmRlciwgdGFnTmFtZSwgc3ludGF4SGlnaGxpZ2h0aW5nLCBkZWZhdWx0Q2FwdGlvbikge1xuICAgIHZhciBzZWN0aW9uVHlwZSA9IHt9O1xuXG4gICAgdmFyIGdldFNlY3Rpb25FbGVtZW50ID0gZnVuY3Rpb24oZXhpc3RpbmdTZWN0aW9uQ29udGVudCwgZGlyZWN0aXZlcywgcnVsZSkge1xuICAgICAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHJ1bGUudGFnTmFtZSksXG4gICAgICAgICAgICBwcmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwcmUnKVxuICAgICAgICAgICAgY2FwdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhcHRpb24nKSxcbiAgICAgICAgICAgIGlucHV0RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjb2RlJyk7XG5cbiAgICAgICAgY2FwdGlvbi5jbGFzc0xpc3QuYWRkKCdtMmRpYS1jYXB0aW9uJyk7XG4gICAgICAgIGlucHV0RWwuY2xhc3NMaXN0LmFkZCgnbTJkaWEtY29kZScpO1xuICAgICAgICBwcmUuY2xhc3NMaXN0LmFkZCgnbTJkaWEtcHJlJyk7XG5cbiAgICAgICAgY2FwdGlvbi5pbm5lckhUTUwgPSBydWxlLmRlZmF1bHRDYXB0aW9uIHx8ICdjYXB0aW9uJztcblxuICAgICAgICBwcmUuYXBwZW5kQ2hpbGQoaW5wdXRFbCk7XG4gICAgICAgIGVsLmFwcGVuZENoaWxkKHByZSk7XG4gICAgICAgIGVsLmFwcGVuZENoaWxkKGNhcHRpb24pO1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2Rpc3BsYXktY2FwdGlvbicsICdZZXMnKTtcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChydWxlLnRhZ05hbWUpO1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdtMmRpYScpO1xuICAgICAgICBlbC5pZCA9IHV1aWQoKTtcblxuICAgICAgICBlbC5vbkZvY3VzID0gc2VjdGlvblR5cGUub25Gb2N1cztcbiAgICAgICAgZWwub25LZXlVcCA9IHNlY3Rpb25UeXBlLm9uS2V5VXA7XG4gICAgICAgIGVsLm9uS2V5RG93biA9IHNlY3Rpb25UeXBlLm9uS2V5RG93bjtcbiAgICAgICAgZWwub25LZXlFbnRlciA9IHNlY3Rpb25UeXBlLm9uS2V5RW50ZXI7XG4gICAgICAgIGVsLm9uS2V5VGFiID0gc2VjdGlvblR5cGUub25LZXlUYWI7XG4gICAgICAgIGVsLm9uS2V5QmFja3NwYWNlID0gc2VjdGlvblR5cGUub25LZXlCYWNrc3BhY2U7XG4gICAgICAgIGVsLm9uTWFya3VwQ2xlYW5pbmdGaW5zaGVkID0gc2VjdGlvblR5cGUub25NYXJrdXBDbGVhbmluZ0ZpbnNoZWQ7XG4gICAgICAgIGVsLnNldENvbnRlbnRlZGl0YWJsZSA9IHNlY3Rpb25UeXBlLnNldENvbnRlbnRlZGl0YWJsZTtcbiAgICAgICAgZWwuc2VjdGlvblR5cGUgPSBzZWN0aW9uVHlwZTtcblxuICAgICAgICByZXR1cm4gZWw7XG4gICAgfTtcblxuICAgIE9iamVjdC5hc3NpZ24oc2VjdGlvblR5cGUsIHtcbiAgICAgICAgbmFtZTogdGFnTmFtZSxcblxuICAgICAgICBjb250ZW50UnVsZXM6IHtcbiAgICAgICAgICAgICdtMmRpYS1wcmUnOiB7XG4gICAgICAgICAgICAgICAgdGFnTmFtZTogJ3ByZScsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnbTJkaWEtcHJlJyxcbiAgICAgICAgICAgICAgICBhbGxvd2VkQXR0cmlidXRlczogWydjbGFzcyddLFxuICAgICAgICAgICAgICAgIGFsbG93ZWRDbGFzc05hbWVzOiBbJ20yZGlhLXByZSddLFxuICAgICAgICAgICAgICAgIGFsbG93ZWRDaGlsZHJlbjogWydtMmRpYS1jb2RlJ10sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ20yZGlhLWNvZGUnOiB7XG4gICAgICAgICAgICAgICAgdGFnTmFtZTogJ2NvZGUnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ20yZGlhLWNvZGUnLFxuICAgICAgICAgICAgICAgIGFsbG93ZWRDbGFzc05hbWVzOiBbJ20yZGlhLWNvZGUnXSxcbiAgICAgICAgICAgICAgICBhbGxvd2VkQXR0cmlidXRlczogWydjbGFzcyddLFxuICAgICAgICAgICAgICAgIGFsbG93ZWRDaGlsZHJlbjogWycjdGV4dCddLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdtMmRpYS1jYXB0aW9uJzoge1xuICAgICAgICAgICAgICAgIHRhZ05hbWU6ICdjYXB0aW9uJyxcbiAgICAgICAgICAgICAgICBhbGxvd2VkQXR0cmlidXRlczogWydjbGFzcyddLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ20yZGlhLWNhcHRpb24nLFxuICAgICAgICAgICAgICAgIGFsbG93ZWRDbGFzc05hbWVzOiBbJ20yZGlhLWNhcHRpb24nXSxcbiAgICAgICAgICAgICAgICBhbGxvd2VkQ2hpbGRyZW46IFsnI3RleHQnLCAncmVmZXJlbmNlJywgJ2lubGluZWVxdWF0aW9uJ10sXG4gICAgICAgICAgICAgICAgZGVsZXRlSWZFbXB0eTogZmFsc2UsXG4gICAgICAgICAgICAgICAgcHJ1bmVTcGFjZXM6IHRydWUsXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZW5yaWNobWVudHM6IFtdLFxuXG4gICAgICAgIG9uTWFya3VwQ2xlYW5pbmdGaW5zaGVkOiBmdW5jdGlvbihzZWN0aW9uRWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGNvZGVFbCA9IHNlY3Rpb25FbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2NvZGUnKSxcbiAgICAgICAgICAgICAgICBwcmVFbCA9IHNlY3Rpb25FbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ3ByZScpLFxuICAgICAgICAgICAgICAgIHJlbmRlckVsID0gc2VjdGlvbkVsZW1lbnQucXVlcnlTZWxlY3RvcignLnJlbmRlcicpLFxuICAgICAgICAgICAgICAgIGxhbiA9IHN5bnRheEhpZ2hsaWdodGluZyxcbiAgICAgICAgICAgICAgICBjb250ZW50O1xuXG4gICAgICAgICAgICBpZighY29kZUVsKSB7IHJldHVybiB9XG5cbiAgICAgICAgICAgIGlmKCFyZW5kZXJFbCkge1xuICAgICAgICAgICAgICAgIHJlbmRlckVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgcmVuZGVyRWwuY2xhc3NMaXN0LmFkZCgncmVuZGVyJyk7XG4gICAgICAgICAgICAgICAgcmVuZGVyRWwuc2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgc2VjdGlvbkVsZW1lbnQuaW5zZXJ0QmVmb3JlKHJlbmRlckVsLCBwcmVFbC5uZXh0U2libGluZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb2RlRWwuaW5uZXJIVE1MO1xuICAgICAgICAgICAgY29udGVudCA9IEhUTUxSYXpvci5wcm90b3R5cGUuc3RyaXAoY29udGVudCk7XG5cbiAgICAgICAgICAgIHRocm90dGxlKDcwMCwgXyA9PiByZW5kZXIocmVuZGVyRWwsIGNvbnRlbnQpKSgpXG5cbiAgICAgICAgICAgIGlmKGxhbiAmJiBwcmltc2pzLmxhbmd1YWdlc1tsYW5dKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IHByaW1zanMuaGlnaGxpZ2h0KGNvbnRlbnQsIHByaW1zanMubGFuZ3VhZ2VzW2xhbl0sIGxhbik7XG4gICAgICAgICAgICAgICAgc2VjdGlvbkVsZW1lbnQucXVlcnlTZWxlY3RvcignY29kZScpLmlubmVySFRNTCA9IGNvbnRlbnQ7IFxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uRm9jdXM6IGZ1bmN0aW9uKGVsLCBlZGl0b3IsIGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBpc0NhcmV0SW5zaWRlQ2FwdGlvbiA9IChlZGl0b3Iuc2VjdGlvbkF0Q2FyZXRQb3N0aW9uKCkgPT09IGVsICYmIGVkaXRvci5jYXJldC5nZXRDb250ZXh0RWxlbWVudChbJ2NhcHRpb24nXSkpLFxuICAgICAgICAgICAgICAgIGNvZGUgPSBlbC5xdWVyeVNlbGVjdG9yKCdjb2RlJyk7XG5cbiAgICAgICAgICAgIGlmKCFpc0NhcmV0SW5zaWRlQ2FwdGlvbiAmJiBjb2RlKSB7XG4gICAgICAgICAgICAgICAgZWRpdG9yLmNhcmV0LnBvc2l0aW9uSW4oY29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0T3B0aW9uczogZnVuY3Rpb24oc2VjdGlvbkVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgbmFtZTogJ2Rpc3BsYXlDYXB0aW9uJyxcbiAgICAgICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiAnRGlzcGxheSBDYXB0aW9uJyxcbiAgICAgICAgICAgICAgICAgIGFsbG93ZWRWYWx1ZXM6IFsnWWVzJywgJ05vJ10sXG4gICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IHNlY3Rpb25FbGVtZW50LmdldEF0dHJpYnV0ZSgnZGlzcGxheS1jYXB0aW9uJylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG5cbiAgICAgICAgb25PcHRpb25zQ2hhbmdlOiBmdW5jdGlvbihvcHQsIGVkaXRvcikge1xuICAgICAgICAgICAgdmFyIHNlY3Rpb24gPSBlZGl0b3IuZm9jdXNlZFNlY3Rpb24oKTtcbiAgICAgICAgICAgIGlmKG9wdC5kaXNwbGF5Q2FwdGlvbiA9PT0gJ1llcycgfHwgb3B0LmRpc3BsYXlDYXB0aW9uID09PSAnTm8nKSB7XG4gICAgICAgICAgICAgICAgc2VjdGlvbi5zZXRBdHRyaWJ1dGUoJ2Rpc3BsYXktY2FwdGlvbicsIG9wdC5kaXNwbGF5Q2FwdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25LZXlUYWI6IGNvZGVTZWN0aW9uVHlwZS5vbktleVRhYixcbiAgICAgICAgb25LZXlVcDogY29kZVNlY3Rpb25UeXBlLm9uS2V5VXAsXG4gICAgICAgIG9uS2V5RG93bjogY29kZVNlY3Rpb25UeXBlLm9uS2V5RG93bixcbiAgICAgICAgb25LZXlCYWNrc3BhY2U6IGNvZGVTZWN0aW9uVHlwZS5vbktleUJhY2tzcGFjZSxcbiAgICAgICAgb25LZXlFbnRlcjogY29kZVNlY3Rpb25UeXBlLm9uS2V5RW50ZXIsXG4gICAgICAgIGdldFNlY3Rpb25FbGVtZW50OiBnZXRTZWN0aW9uRWxlbWVudCxcbiAgICB9KTtcblxuICAgIHNlY3Rpb25UeXBlLmNvbnRlbnRSdWxlc1t0YWdOYW1lXSA9IHtcbiAgICAgICAgdGFnTmFtZTogdGFnTmFtZSxcbiAgICAgICAgY2xhc3NOYW1lOiB0YWdOYW1lLFxuICAgICAgICBhbGxvd2VkQXR0cmlidXRlczogWydjbGFzcycsICdkaXNwbGF5LWNhcHRpb24nLCAnaWQnXSxcbiAgICAgICAgYWxsb3dlZENsYXNzTmFtZXM6IFsnZm9jdXNlZCcsIHRhZ05hbWUsICdtMmRpYSddLFxuICAgICAgICBhbGxvd2VkQ2hpbGRyZW46IFsnbTJkaWEtY2FwdGlvbicsICdtMmRpYS1wcmUnXSxcbiAgICAgICAgcHJ1bmVTcGFjZXM6IHRydWUsXG4gICAgICAgIGFsbG93ZWRUb0JlUm9vdDogdHJ1ZSxcbiAgICAgICAgZGVsZXRlSWZFbXB0eTogZmFsc2UsXG4gICAgICAgIGJ1aWxkRW1wdHlFbGVtZW50OiBzZWN0aW9uVHlwZS5nZXRTZWN0aW9uRWxlbWVudCxcbiAgICAgICAgZGVmYXVsdENhcHRpb246IGRlZmF1bHRDYXB0aW9uLFxuICAgICAgICBidWlsZEF0dHJpYnV0ZXM6IFtcbiAgICAgICAgICAgIHtuYW1lOiAnZGlzcGxheS1jYXB0aW9uJywgYnVpbGQ6IGZ1bmN0aW9uKCkge3JldHVybiAnWWVzJ319LFxuICAgICAgICAgICAge25hbWU6ICdpZCcsIGJ1aWxkOiBmdW5jdGlvbigpIHtyZXR1cm4gdXVpZCgpfX1cbiAgICAgICAgXVxuICAgIH07XG5cbiAgICBzZWN0aW9uVHlwZS50YWdUcmFuc2Zvcm1hdGlvbnMgPSB7fTtcbiAgICBzZWN0aW9uVHlwZS50YWdUcmFuc2Zvcm1hdGlvbnNbJy8nK3RhZ05hbWUrJy9kaXYucmVuZGVyJ10gPSAnI25vLWNvbnRlbnQnO1xuICAgIHNlY3Rpb25UeXBlLnRhZ1RyYW5zZm9ybWF0aW9uc1snLycrdGFnTmFtZSsnL3ByZS9jb2RlJ10gPSAnI3RleHQtY29udGVudCc7XG5cbiAgICByZXR1cm4gc2VjdGlvblR5cGU7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBvbktleVVwRm9yRnJlZXN0eWxlU2VjdGlvbnM6IGZ1bmN0aW9uKGUsIGVkaXRvcikge1xuICAgICAgICB2YXIgZm9jdXNlZFNlY3Rpb24gPSBlZGl0b3IuZm9jdXNlZFNlY3Rpb24oKSxcbiAgICAgICAgICAgIHVwcGVyU2VjdGlvbiA9IGZvY3VzZWRTZWN0aW9uLnByZXZpb3VzU2libGluZztcblxuICAgICAgICBpZighdXBwZXJTZWN0aW9uKSB7IHJldHVybiB0cnVlOyB9XG5cbiAgICAgICAgaWYoZWRpdG9yLmNhcmV0LmlzQ29sbGFwc2VkQW5kUG9zaXRpb25lZEF0VGhlQmVnaW5uaW5nT2YoZm9jdXNlZFNlY3Rpb24pKSB7XG4gICAgICAgICAgICBlZGl0b3IucGxhY2VDYXJldEludG9TZWN0aW9uKHVwcGVyU2VjdGlvbik7XG5cbiAgICAgICAgICAgIC8vIHRyaWdnZXIgdGhlIHJlbW92YWwgb2YgZW1wdHkgc2VjdGlvbnNcbiAgICAgICAgICAgIGVkaXRvci5yZXBsYWNlU2VjdGlvbldpdGhIVE1MKGZvY3VzZWRTZWN0aW9uLCBmb2N1c2VkU2VjdGlvbi5vdXRlckhUTUwpO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG9uS2V5RG93bkZvckZyZWVzdHlsZVNlY3Rpb25zOiBmdW5jdGlvbihlLCBlZGl0b3IpIHtcbiAgICAgICAgdmFyIGZvY3VzZWRTZWN0aW9uID0gZWRpdG9yLmZvY3VzZWRTZWN0aW9uKCksXG4gICAgICAgICAgICBsb3dlclNlY3Rpb24gPSBmb2N1c2VkU2VjdGlvbi5uZXh0U2libGluZztcblxuICAgICAgICBpZighbG93ZXJTZWN0aW9uKSB7IHJldHVybiB0cnVlOyB9XG5cbiAgICAgICAgaWYoZWRpdG9yLmNhcmV0LmlzQ29sbGFwc2VkQW5kUG9zaXRpb25lZEF0VGhlRW5kT2YoZm9jdXNlZFNlY3Rpb24pKSB7XG4gICAgICAgICAgICBlZGl0b3IucGxhY2VDYXJldEludG9TZWN0aW9uKGxvd2VyU2VjdGlvbik7XG5cbiAgICAgICAgICAgIC8vIHRyaWdnZXIgdGhlIHJlbW92YWwgb2YgZW1wdHkgc2VjdGlvbnNcbiAgICAgICAgICAgIGVkaXRvci5yZXBsYWNlU2VjdGlvbldpdGhIVE1MKGZvY3VzZWRTZWN0aW9uLCBmb2N1c2VkU2VjdGlvbi5vdXRlckhUTUwpO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG9uS2V5RW50ZXJGb3JGcmVlc3R5bGVTZWN0aW9uczogZnVuY3Rpb24oZSwgZWRpdG9yKSB7XG4gICAgICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKCdpbnNlcnRIVE1MJywgZmFsc2UsICcmTmV3TGluZTsnKTtcblxuICAgICAgICB2YXIgY2hhciA9IGVkaXRvci5jYXJldC5nZXRQcmVjZWRpbmdDaGFyYWN0ZXIoZWRpdG9yLmZvY3VzZWRTZWN0aW9uKCkpO1xuICAgICAgICBpZihjaGFyICE9PSAnXFxuJykge1xuICAgICAgICAgICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ2luc2VydEhUTUwnLCBmYWxzZSwgJyZOZXdMaW5lOycpO1xuICAgICAgICB9XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIC8vIFdlIGRvIG5vdCBoYXZlIHRvIHNldCB0aGUgY29udGVudCBvZiB0aGUgZWRpdG9yIGJlY2F1c2UgZXhlY2NvbW1hbmQgdHJpZ2dlcnNcbiAgICAgICAgLy8gYW4gaW5wdXQgZXZlbnQgd2hpY2ggd2lsbCBoYW5kbGUgdGhlIGNvbnRlbnQgY2hhbmdlIG9uIHRoZSBlZGl0b3Igc2l0ZS5cbiAgICB9LFxuXG4gICAgb25LZXlCYWNrc3BhY2VGb3JCYWNrc3BhY2VEZWxldGFibGVTZWN0aW9uczogZnVuY3Rpb24oZSwgZWRpdG9yKSB7XG4gICAgICAgIHZhciBmb2N1c2VkU2VjdGlvbiA9IGVkaXRvci5mb2N1c2VkU2VjdGlvbigpLFxuICAgICAgICAgICAgdXBwZXJTZWN0aW9uID0gZm9jdXNlZFNlY3Rpb24ucHJldmlvdXNTaWJsaW5nO1xuXG4gICAgICAgIGlmKCF1cHBlclNlY3Rpb24pIHsgcmV0dXJuIHRydWU7IH1cblxuICAgICAgICBpZihmb2N1c2VkU2VjdGlvbi5pbm5lclRleHQudHJpbSgpID09PSAnJykge1xuICAgICAgICAgICAgZWRpdG9yLnBsYWNlQ2FyZXRJbnRvU2VjdGlvbih1cHBlclNlY3Rpb24pO1xuXG4gICAgICAgICAgICAvLyB0cmlnZ2VyIHRoZSByZW1vdmFsIG9mIGVtcHR5IHNlY3Rpb25zXG4gICAgICAgICAgICBlZGl0b3IucmVwbGFjZVNlY3Rpb25XaXRoSFRNTChmb2N1c2VkU2VjdGlvbiwgZm9jdXNlZFNlY3Rpb24ub3V0ZXJIVE1MKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsInZhciB1dWlkID0gcmVxdWlyZSgndXVpZC92MScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL3BpeGVsc2NodWJzZXIvdXRpbHMnKTtcbnZhciBsYXN0Rm9jdXNlZENlbGwsIGZvY3VzZWRDZWxsLCBvblVuZm9jdXNUaW1lb3V0O1xuXG52YXIgZ2V0U2VjdGlvbkVsZW1lbnQgPSBmdW5jdGlvbihleGlzdGluZ1NlY3Rpb25Db250ZW50KSB7XG4gICAgdmFyIHRhYmxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RhYmxlJyk7XG4gICAgdGFibGVFbGVtZW50LmlkID0gdXVpZCgpO1xuICAgIHRhYmxlRWxlbWVudC5zZWN0aW9uVHlwZSA9IG1vZHVsZS5leHBvcnRzO1xuICAgIHRhYmxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2Rpc3BsYXktaGVhZGluZycsICdZZXMnKTtcbiAgICB0YWJsZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdkaXNwbGF5LWNhcHRpb24nLCAnWWVzJyk7XG5cbiAgICB0YWJsZUVsZW1lbnQub25LZXlVcCA9IG1vZHVsZS5leHBvcnRzLm9uS2V5VXA7XG4gICAgdGFibGVFbGVtZW50Lm9uS2V5RG93biA9IG1vZHVsZS5leHBvcnRzLm9uS2V5RG93bjtcbiAgICB0YWJsZUVsZW1lbnQub25LZXlUYWIgPSBtb2R1bGUuZXhwb3J0cy5vbktleVRhYjtcbiAgICB0YWJsZUVsZW1lbnQub25LZXlDb21iaW5hdGlvbiA9IG1vZHVsZS5leHBvcnRzLm9uS2V5Q29tYmluYXRpb247XG4gICAgdGFibGVFbGVtZW50Lm9uS2V5QmFja3NwYWNlID0gbW9kdWxlLmV4cG9ydHMub25LZXlCYWNrc3BhY2U7XG4gICAgdGFibGVFbGVtZW50Lm9uS2V5RW50ZXIgPSBtb2R1bGUuZXhwb3J0cy5vbktleUVudGVyO1xuICAgIHRhYmxlRWxlbWVudC5vblNlbGVjdGlvbkNoYW5nZSA9IG1vZHVsZS5leHBvcnRzLm9uU2VsZWN0aW9uQ2hhbmdlO1xuICAgIHRhYmxlRWxlbWVudC5vblVuZm9jdXMgPSBtb2R1bGUuZXhwb3J0cy5vblVuZm9jdXM7XG4gICAgdGFibGVFbGVtZW50Lm9uV2luZG93UmVzaXplID0gbW9kdWxlLmV4cG9ydHMub25XaW5kb3dSZXNpemU7XG5cbiAgICB0YWJsZUVsZW1lbnQuaW5uZXJIVE1MID0gJzx0Ym9keT4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyAgPHRyPjx0ZD48L3RkPjx0ZD48L3RkPjwvdHI+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgIDx0cj48dGQ+PC90ZD48dGQ+PC90ZD48L3RyPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnICA8dHI+PHRkPjwvdGQ+PHRkPjwvdGQ+PC90cj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzwvdGJvZHk+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8Y2FwdGlvbj50YWJsZSB0aXRsZTwvY2FwdGlvbj4nO1xuXG4gICAgcmV0dXJuIHRhYmxlRWxlbWVudDtcbn1cblxudmFyIGdldEFkZFJvd0JlbG93QnV0dG9uID0gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgdmFyIGJ0biA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0YWJsZUFkZFJvd0JlbG93QnRuJyk7XG5cbiAgICBpZihidG4pIHtcbiAgICAgICAgcmV0dXJuIGJ0bjtcbiAgICB9XG5cbiAgICB2YXIgYnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGJ0bi5pZCA9ICd0YWJsZUFkZFJvd0JlbG93QnRuJztcbiAgICBidG4uaW5uZXJIVE1MID0gJzxzdmcgaWQ9XCJMYXllcl8xXCIgZGF0YS1uYW1lPVwiTGF5ZXIgMVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjEyLjY3XCIgaGVpZ2h0PVwiMTkuNjlcIiB2aWV3Qm94PVwiMCAwIDEyLjY3IDE5LjY5XCI+PGRlZnM+PHN0eWxlPi5jbHMtMSwuY2xzLTN7ZmlsbDpub25lO30uY2xzLTF7c3Ryb2tlOiMyMzFmMjA7fS5jbHMtMSwuY2xzLTIsLmNscy0ze3N0cm9rZS1taXRlcmxpbWl0OjEwO30uY2xzLTJ7ZmlsbDojOThjZjhkO30uY2xzLTIsLmNscy0ze3N0cm9rZTojMjk3MDI3O308L3N0eWxlPjwvZGVmcz48cG9seWxpbmUgY2xhc3M9XCJjbHMtMVwiIHBvaW50cz1cIjUuOTggMS4yNiA1Ljk4IDcuMDcgNS45OCAxMi43MiA1Ljk4IDE4LjQyXCIvPjxwYXRoIGNsYXNzPVwiY2xzLTFcIiBkPVwiTTMyNy4zOCw0MTMuNTlcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoLTMyNi44OCAtNDAxLjk0KVwiLz48cmVjdCBjbGFzcz1cImNscy0xXCIgeD1cIjAuNVwiIHk9XCIxLjI2XCIgd2lkdGg9XCIxMC45N1wiIGhlaWdodD1cIjE3LjE3XCIvPjxwb2x5bGluZSBjbGFzcz1cImNscy0xXCIgcG9pbnRzPVwiMTEuNDcgNy4wNyA1Ljk4IDcuMDcgMC41IDcuMDdcIi8+PHBvbHlsaW5lIGNsYXNzPVwiY2xzLTFcIiBwb2ludHM9XCIxMS40NyAxMi43MiA1Ljk4IDEyLjcyIDAuNSAxMi43MlwiLz48cGF0aCBjbGFzcz1cImNscy0yXCIgZD1cIk0zMzkuMDUsNDAyLjQ0YzAsMi4wNywwLDQuMTMtLjA1LDYuMTloLTYuMTN2LTYuMTlaXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKC0zMjYuODggLTQwMS45NClcIi8+PHBhdGggY2xhc3M9XCJjbHMtMlwiIGQ9XCJNMzM5LDQwOC42M2MwLDIuMjUsMCw0LjUtLjA2LDYuNzVoLTYuMDd2LTYuNzVaXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKC0zMjYuODggLTQwMS45NClcIi8+PHBhdGggY2xhc3M9XCJjbHMtMlwiIGQ9XCJNMzM4Ljk0LDQxNS4zOGMwLDEuOTIsMCwzLjgzLDAsNS43NWgtNnYtNS43NVpcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoLTMyNi44OCAtNDAxLjk0KVwiLz48bGluZSBjbGFzcz1cImNscy0zXCIgeDE9XCI1Ljk5XCIgeTE9XCI2LjY5XCIgeDI9XCI1Ljk4XCIgeTI9XCI2LjY5XCIvPjxsaW5lIGNsYXNzPVwiY2xzLTNcIiB4MT1cIjUuOTlcIiB5MT1cIjEzLjQ0XCIgeDI9XCI1Ljk4XCIgeTI9XCIxMy40NFwiLz48L3N2Zz4nO1xuXG4gICAgYnRuLm9ubW91c2Vkb3duID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMuYWRkUm93KHVuZGVmaW5lZCwgZWRpdG9yKTtcbiAgICAgICAgfSwgMTAwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnRuO1xufVxuXG52YXIgZ2V0QWRkUm93QWJvdmVCdXR0b24gPSBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICB2YXIgYnRuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3RhYmxlQWRkUm93QWJvdmVCdG4nKTtcblxuICAgIGlmKGJ0bikge1xuICAgICAgICByZXR1cm4gYnRuO1xuICAgIH1cblxuICAgIHZhciBidG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgYnRuLmlkID0gJ3RhYmxlQWRkUm93QWJvdmVCdG4nO1xuICAgIGJ0bi5pbm5lckhUTUwgPSAnPHN2ZyBpZD1cIkxheWVyXzFcIiBkYXRhLW5hbWU9XCJMYXllciAxXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMTIuMzdcIiBoZWlnaHQ9XCIxOS42OVwiIHZpZXdCb3g9XCIwIDAgMTIuMzcgMTkuNjlcIj48ZGVmcz48c3R5bGU+LmNscy0xLC5jbHMtM3tmaWxsOm5vbmU7fS5jbHMtMXtzdHJva2U6IzIzMWYyMDt9LmNscy0xLC5jbHMtMiwuY2xzLTN7c3Ryb2tlLW1pdGVybGltaXQ6MTA7fS5jbHMtMntmaWxsOiM5OGNmOGQ7fS5jbHMtMiwuY2xzLTN7c3Ryb2tlOiMyOTcwMjc7fTwvc3R5bGU+PC9kZWZzPjxwYXRoIGNsYXNzPVwiY2xzLTFcIiBkPVwiTTMwMC44MywzOTcuNDFcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoLTI5OS45MyAtMzg1Ljc2KVwiLz48cmVjdCBjbGFzcz1cImNscy0xXCIgeD1cIjAuOVwiIHk9XCIxLjI2XCIgd2lkdGg9XCIxMC45N1wiIGhlaWdodD1cIjE3LjE3XCIvPjxwb2x5bGluZSBjbGFzcz1cImNscy0xXCIgcG9pbnRzPVwiNi4zOCAxLjI2IDYuMzggNy4wNyA2LjM4IDEyLjcyIDYuMzggMTguNDJcIi8+PHBvbHlsaW5lIGNsYXNzPVwiY2xzLTFcIiBwb2ludHM9XCIxMS44NyA3LjA3IDYuMzggNy4wNyAwLjkgNy4wN1wiLz48cG9seWxpbmUgY2xhc3M9XCJjbHMtMVwiIHBvaW50cz1cIjExLjg3IDEyLjcyIDYuMzggMTIuNzIgMC45IDEyLjcyXCIvPjxwYXRoIGNsYXNzPVwiY2xzLTJcIiBkPVwiTTMwNi42MSwzODYuMjZjMCwyLjA2LDAsNC4xMy0uMDUsNi4xOWgtNi4xM3YtNi4xOVpcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoLTI5OS45MyAtMzg1Ljc2KVwiLz48cGF0aCBjbGFzcz1cImNscy0yXCIgZD1cIk0zMDYuNTYsMzkyLjQ1cTAsMy4zOC0uMDUsNi43NWgtNi4wOHYtNi43NVpcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoLTI5OS45MyAtMzg1Ljc2KVwiLz48cGF0aCBjbGFzcz1cImNscy0yXCIgZD1cIk0zMDYuNTEsMzk5LjJjMCwxLjkyLDAsMy44MywwLDUuNzVoLTZWMzk5LjJaXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKC0yOTkuOTMgLTM4NS43NilcIi8+PGxpbmUgY2xhc3M9XCJjbHMtM1wiIHgxPVwiMC41XCIgeTE9XCI2LjY5XCIgeDI9XCIwLjQ5XCIgeTI9XCI2LjY5XCIvPjxsaW5lIGNsYXNzPVwiY2xzLTNcIiB4MT1cIjAuNVwiIHkxPVwiMTMuNDRcIiB4Mj1cIjAuNDlcIiB5Mj1cIjEzLjQ0XCIvPjwvc3ZnPic7XG5cbiAgICBidG4ub25tb3VzZWRvd24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cy5hZGRSb3codW5kZWZpbmVkLCBlZGl0b3IsIHRydWUpO1xuICAgICAgICB9LCAxMDApO1xuICAgIH1cblxuICAgIHJldHVybiBidG47XG59XG5cbnZhciBnZXREZWxldGVSb3dCdXR0b24gPSBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICB2YXIgYnRuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3RhYmxlRGVsZXRlUm93QnRuJyk7XG5cbiAgICBpZihidG4pIHtcbiAgICAgICAgcmV0dXJuIGJ0bjtcbiAgICB9XG5cbiAgICB2YXIgYnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGJ0bi5pZCA9ICd0YWJsZURlbGV0ZVJvd0J0bic7XG4gICAgYnRuLmlubmVySFRNTCA9ICc8c3ZnIGRhdGEtbmFtZT1cIkxheWVyIDFcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIxNy45NlwiIGhlaWdodD1cIjE5LjY5XCIgdmlld0JveD1cIjAgMCAxNy45NiAxOS42OVwiPjxkZWZzPjwvZGVmcz48cmVjdCBjbGFzcz1cImNscy0xLXJlZFwiIHg9XCIwLjVcIiB5PVwiMS4zNlwiIHdpZHRoPVwiMTYuOTZcIiBoZWlnaHQ9XCIxNi45NlwiLz48cGF0aCBjbGFzcz1cImNscy0xLXJlZFwiIGQ9XCJNMzE2LjU3LDM5M1wiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgtMjk1LjY2IC0zODUuNzYpXCIvPjxwb2x5bGluZSBjbGFzcz1cImNscy0xLXJlZFwiIHBvaW50cz1cIjAuNSA3LjI3IDUuOTkgNy4yNyAxMS45MSA3LjI3IDE3LjQ3IDcuMjdcIi8+PHBvbHlsaW5lIGNsYXNzPVwiY2xzLTEtcmVkXCIgcG9pbnRzPVwiMC41IDEyLjYyIDUuOTkgMTIuNjIgMTEuOTEgMTIuNjIgMTcuNDcgMTIuNjJcIi8+PHBvbHlsaW5lIGNsYXNzPVwiY2xzLTEtcmVkXCIgcG9pbnRzPVwiNS45OSAxLjM2IDUuOTkgNy4yNyA1Ljk5IDEyLjYyIDUuOTkgMTguMzJcIi8+PHBvbHlsaW5lIGNsYXNzPVwiY2xzLTEtcmVkXCIgcG9pbnRzPVwiMTEuOTEgMS4zNiAxMS45MSA3LjI3IDExLjkxIDEyLjYyIDExLjkxIDE4LjMyXCIvPjxwYXRoIGNsYXNzPVwiY2xzLTItcmVkXCIgZD1cIk0zMDcuODYsMzg2LjI2YzAsMi4wNiwwLDQuMTMtLjA1LDYuMTloLTYuMTN2LTYuMTlaXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKC0yOTUuNjYgLTM4NS43NilcIi8+PHBhdGggY2xhc3M9XCJjbHMtMi1yZWRcIiBkPVwiTTMwNy44MSwzOTIuNDVxMCwzLjM4LS4wNSw2Ljc1aC02LjA4di02Ljc1WlwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgtMjk1LjY2IC0zODUuNzYpXCIvPjxwYXRoIGNsYXNzPVwiY2xzLTItcmVkXCIgZD1cIk0zMDcuNzYsMzk5LjJjMCwxLjkyLDAsMy44My0uMDUsNS43NWgtNlYzOTkuMlpcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoLTI5NS42NiAtMzg1Ljc2KVwiLz48bGluZSBjbGFzcz1cImNscy0yLXJlZFwiIHgxPVwiNi4wMlwiIHkxPVwiNi42OVwiIHgyPVwiNi4wMVwiIHkyPVwiNi42OVwiLz48bGluZSBjbGFzcz1cImNscy0yLXJlZFwiIHgxPVwiNi4wMlwiIHkxPVwiMTMuNDRcIiB4Mj1cIjYuMDFcIiB5Mj1cIjEzLjQ0XCIvPjwvc3ZnPic7XG5cbiAgICBidG4ub25tb3VzZWRvd24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cy5kZWxldGVSb3codW5kZWZpbmVkLCBlZGl0b3IpO1xuICAgICAgICB9LCAxMDApO1xuICAgIH1cblxuICAgIHJldHVybiBidG47XG59XG5cbnZhciBnZXRBZGRDb2x1bW5MZWZ0QnV0dG9uID0gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgdmFyIGJ0biA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0YWJsZUFkZENvbHVtbkxlZnRCdG4nKTtcblxuICAgIGlmKGJ0bikge1xuICAgICAgICByZXR1cm4gYnRuO1xuICAgIH1cblxuICAgIHZhciBidG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgYnRuLmlkID0gJ3RhYmxlQWRkQ29sdW1uTGVmdEJ0bic7XG4gICAgYnRuLmlubmVySFRNTCA9ICc8c3ZnIGlkPVwiTGF5ZXJfMVwiIGRhdGEtbmFtZT1cIkxheWVyIDFcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIxMi4zN1wiIGhlaWdodD1cIjE5LjY5XCIgdmlld0JveD1cIjAgMCAxMi4zNyAxOS42OVwiPjxkZWZzPjxzdHlsZT4uY2xzLTEsLmNscy0ze2ZpbGw6bm9uZTt9LmNscy0xe3N0cm9rZTojMjMxZjIwO30uY2xzLTEsLmNscy0yLC5jbHMtM3tzdHJva2UtbWl0ZXJsaW1pdDoxMDt9LmNscy0ye2ZpbGw6Izk4Y2Y4ZDt9LmNscy0yLC5jbHMtM3tzdHJva2U6IzI5NzAyNzt9PC9zdHlsZT48L2RlZnM+PHBhdGggY2xhc3M9XCJjbHMtMVwiIGQ9XCJNMzAwLjgzLDM5Ny40MVwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgtMjk5LjkzIC0zODUuNzYpXCIvPjxyZWN0IGNsYXNzPVwiY2xzLTFcIiB4PVwiMC45XCIgeT1cIjEuMjZcIiB3aWR0aD1cIjEwLjk3XCIgaGVpZ2h0PVwiMTcuMTdcIi8+PHBvbHlsaW5lIGNsYXNzPVwiY2xzLTFcIiBwb2ludHM9XCI2LjM4IDEuMjYgNi4zOCA3LjA3IDYuMzggMTIuNzIgNi4zOCAxOC40MlwiLz48cG9seWxpbmUgY2xhc3M9XCJjbHMtMVwiIHBvaW50cz1cIjExLjg3IDcuMDcgNi4zOCA3LjA3IDAuOSA3LjA3XCIvPjxwb2x5bGluZSBjbGFzcz1cImNscy0xXCIgcG9pbnRzPVwiMTEuODcgMTIuNzIgNi4zOCAxMi43MiAwLjkgMTIuNzJcIi8+PHBhdGggY2xhc3M9XCJjbHMtMlwiIGQ9XCJNMzA2LjYxLDM4Ni4yNmMwLDIuMDYsMCw0LjEzLS4wNSw2LjE5aC02LjEzdi02LjE5WlwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgtMjk5LjkzIC0zODUuNzYpXCIvPjxwYXRoIGNsYXNzPVwiY2xzLTJcIiBkPVwiTTMwNi41NiwzOTIuNDVxMCwzLjM4LS4wNSw2Ljc1aC02LjA4di02Ljc1WlwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgtMjk5LjkzIC0zODUuNzYpXCIvPjxwYXRoIGNsYXNzPVwiY2xzLTJcIiBkPVwiTTMwNi41MSwzOTkuMmMwLDEuOTIsMCwzLjgzLDAsNS43NWgtNlYzOTkuMlpcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoLTI5OS45MyAtMzg1Ljc2KVwiLz48bGluZSBjbGFzcz1cImNscy0zXCIgeDE9XCIwLjVcIiB5MT1cIjYuNjlcIiB4Mj1cIjAuNDlcIiB5Mj1cIjYuNjlcIi8+PGxpbmUgY2xhc3M9XCJjbHMtM1wiIHgxPVwiMC41XCIgeTE9XCIxMy40NFwiIHgyPVwiMC40OVwiIHkyPVwiMTMuNDRcIi8+PC9zdmc+JztcblxuICAgIGJ0bi5vbm1vdXNlZG93biA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzLmFkZENvbHVtbih1bmRlZmluZWQsIGVkaXRvciwgdHJ1ZSk7XG4gICAgICAgIH0sIDEwMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ0bjtcbn1cblxudmFyIGdldEFkZENvbHVtblJpZ2h0QnV0dG9uID0gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgdmFyIGJ0biA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0YWJsZUFkZENvbHVtblJpZ2h0QnRuJyk7XG5cbiAgICBpZihidG4pIHtcbiAgICAgICAgcmV0dXJuIGJ0bjtcbiAgICB9XG5cbiAgICB2YXIgYnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGJ0bi5pZCA9ICd0YWJsZUFkZENvbHVtblJpZ2h0QnRuJztcbiAgICBidG4uaW5uZXJIVE1MID0gJzxzdmcgaWQ9XCJMYXllcl8xXCIgZGF0YS1uYW1lPVwiTGF5ZXIgMVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjEyLjY3XCIgaGVpZ2h0PVwiMTkuNjlcIiB2aWV3Qm94PVwiMCAwIDEyLjY3IDE5LjY5XCI+PGRlZnM+PHN0eWxlPi5jbHMtMSwuY2xzLTN7ZmlsbDpub25lO30uY2xzLTF7c3Ryb2tlOiMyMzFmMjA7fS5jbHMtMSwuY2xzLTIsLmNscy0ze3N0cm9rZS1taXRlcmxpbWl0OjEwO30uY2xzLTJ7ZmlsbDojOThjZjhkO30uY2xzLTIsLmNscy0ze3N0cm9rZTojMjk3MDI3O308L3N0eWxlPjwvZGVmcz48cG9seWxpbmUgY2xhc3M9XCJjbHMtMVwiIHBvaW50cz1cIjUuOTggMS4yNiA1Ljk4IDcuMDcgNS45OCAxMi43MiA1Ljk4IDE4LjQyXCIvPjxwYXRoIGNsYXNzPVwiY2xzLTFcIiBkPVwiTTMyNy4zOCw0MTMuNTlcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoLTMyNi44OCAtNDAxLjk0KVwiLz48cmVjdCBjbGFzcz1cImNscy0xXCIgeD1cIjAuNVwiIHk9XCIxLjI2XCIgd2lkdGg9XCIxMC45N1wiIGhlaWdodD1cIjE3LjE3XCIvPjxwb2x5bGluZSBjbGFzcz1cImNscy0xXCIgcG9pbnRzPVwiMTEuNDcgNy4wNyA1Ljk4IDcuMDcgMC41IDcuMDdcIi8+PHBvbHlsaW5lIGNsYXNzPVwiY2xzLTFcIiBwb2ludHM9XCIxMS40NyAxMi43MiA1Ljk4IDEyLjcyIDAuNSAxMi43MlwiLz48cGF0aCBjbGFzcz1cImNscy0yXCIgZD1cIk0zMzkuMDUsNDAyLjQ0YzAsMi4wNywwLDQuMTMtLjA1LDYuMTloLTYuMTN2LTYuMTlaXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKC0zMjYuODggLTQwMS45NClcIi8+PHBhdGggY2xhc3M9XCJjbHMtMlwiIGQ9XCJNMzM5LDQwOC42M2MwLDIuMjUsMCw0LjUtLjA2LDYuNzVoLTYuMDd2LTYuNzVaXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKC0zMjYuODggLTQwMS45NClcIi8+PHBhdGggY2xhc3M9XCJjbHMtMlwiIGQ9XCJNMzM4Ljk0LDQxNS4zOGMwLDEuOTIsMCwzLjgzLDAsNS43NWgtNnYtNS43NVpcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoLTMyNi44OCAtNDAxLjk0KVwiLz48bGluZSBjbGFzcz1cImNscy0zXCIgeDE9XCI1Ljk5XCIgeTE9XCI2LjY5XCIgeDI9XCI1Ljk4XCIgeTI9XCI2LjY5XCIvPjxsaW5lIGNsYXNzPVwiY2xzLTNcIiB4MT1cIjUuOTlcIiB5MT1cIjEzLjQ0XCIgeDI9XCI1Ljk4XCIgeTI9XCIxMy40NFwiLz48L3N2Zz4nO1xuXG4gICAgYnRuLm9ubW91c2Vkb3duID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMuYWRkQ29sdW1uKHVuZGVmaW5lZCwgZWRpdG9yKTtcbiAgICAgICAgfSwgMTAwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnRuO1xufVxuXG52YXIgZ2V0RGVsZXRlQ29sdW1uQnV0dG9uID0gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgdmFyIGJ0biA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0YWJsZURlbGV0ZUNvbHVtbkJ0bicpO1xuXG4gICAgaWYoYnRuKSB7XG4gICAgICAgIHJldHVybiBidG47XG4gICAgfVxuXG4gICAgdmFyIGJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICBidG4uaWQgPSAndGFibGVEZWxldGVDb2x1bW5CdG4nO1xuICAgIGJ0bi5pbm5lckhUTUwgPSAnPHN2ZyBkYXRhLW5hbWU9XCJMYXllciAxXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMTcuOTZcIiBoZWlnaHQ9XCIxOS42OVwiIHZpZXdCb3g9XCIwIDAgMTcuOTYgMTkuNjlcIj48ZGVmcz48L2RlZnM+PHJlY3QgY2xhc3M9XCJjbHMtMS1yZWRcIiB4PVwiMC41XCIgeT1cIjEuMzZcIiB3aWR0aD1cIjE2Ljk2XCIgaGVpZ2h0PVwiMTYuOTZcIi8+PHBhdGggY2xhc3M9XCJjbHMtMS1yZWRcIiBkPVwiTTMxNi41NywzOTNcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoLTI5NS42NiAtMzg1Ljc2KVwiLz48cG9seWxpbmUgY2xhc3M9XCJjbHMtMS1yZWRcIiBwb2ludHM9XCIwLjUgNy4yNyA1Ljk5IDcuMjcgMTEuOTEgNy4yNyAxNy40NyA3LjI3XCIvPjxwb2x5bGluZSBjbGFzcz1cImNscy0xLXJlZFwiIHBvaW50cz1cIjAuNSAxMi42MiA1Ljk5IDEyLjYyIDExLjkxIDEyLjYyIDE3LjQ3IDEyLjYyXCIvPjxwb2x5bGluZSBjbGFzcz1cImNscy0xLXJlZFwiIHBvaW50cz1cIjUuOTkgMS4zNiA1Ljk5IDcuMjcgNS45OSAxMi42MiA1Ljk5IDE4LjMyXCIvPjxwb2x5bGluZSBjbGFzcz1cImNscy0xLXJlZFwiIHBvaW50cz1cIjExLjkxIDEuMzYgMTEuOTEgNy4yNyAxMS45MSAxMi42MiAxMS45MSAxOC4zMlwiLz48cGF0aCBjbGFzcz1cImNscy0yLXJlZFwiIGQ9XCJNMzA3Ljg2LDM4Ni4yNmMwLDIuMDYsMCw0LjEzLS4wNSw2LjE5aC02LjEzdi02LjE5WlwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgtMjk1LjY2IC0zODUuNzYpXCIvPjxwYXRoIGNsYXNzPVwiY2xzLTItcmVkXCIgZD1cIk0zMDcuODEsMzkyLjQ1cTAsMy4zOC0uMDUsNi43NWgtNi4wOHYtNi43NVpcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoLTI5NS42NiAtMzg1Ljc2KVwiLz48cGF0aCBjbGFzcz1cImNscy0yLXJlZFwiIGQ9XCJNMzA3Ljc2LDM5OS4yYzAsMS45MiwwLDMuODMtLjA1LDUuNzVoLTZWMzk5LjJaXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKC0yOTUuNjYgLTM4NS43NilcIi8+PGxpbmUgY2xhc3M9XCJjbHMtMi1yZWRcIiB4MT1cIjYuMDJcIiB5MT1cIjYuNjlcIiB4Mj1cIjYuMDFcIiB5Mj1cIjYuNjlcIi8+PGxpbmUgY2xhc3M9XCJjbHMtMi1yZWRcIiB4MT1cIjYuMDJcIiB5MT1cIjEzLjQ0XCIgeDI9XCI2LjAxXCIgeTI9XCIxMy40NFwiLz48L3N2Zz4nO1xuXG4gICAgYnRuLm9ubW91c2Vkb3duID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMuZGVsZXRlQ29sdW1uKHVuZGVmaW5lZCwgZWRpdG9yKTtcbiAgICAgICAgfSwgMTAwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnRuO1xufVxuXG52YXIgZ2V0SG9yaXpvbnRhbENvbnRyb2xzQmFyID0gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgdmFyIGJhciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNob3Jpem9udGFsVGFibGVDb250cm9sc0JhcicpO1xuXG4gICAgaWYoYmFyKSB7XG4gICAgICAgIHJldHVybiBiYXI7XG4gICAgfVxuXG4gICAgYmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgYmFyLmlkID0gJ2hvcml6b250YWxUYWJsZUNvbnRyb2xzQmFyJztcbiAgICBiYXIuY2xhc3NMaXN0LmFkZCgndGFibGVDb250cm9sc0JhcicpO1xuXG4gICAgdmFyIGFycm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgYXJyb3cuY2xhc3NMaXN0LmFkZCgnYXJyb3cnKVxuXG4gICAgYmFyLmFwcGVuZENoaWxkKGdldEFkZENvbHVtbkxlZnRCdXR0b24oZWRpdG9yKSk7XG4gICAgYmFyLmFwcGVuZENoaWxkKGdldERlbGV0ZUNvbHVtbkJ1dHRvbihlZGl0b3IpKTtcbiAgICBiYXIuYXBwZW5kQ2hpbGQoZ2V0QWRkQ29sdW1uUmlnaHRCdXR0b24oZWRpdG9yKSk7XG4gICAgYmFyLmFwcGVuZENoaWxkKGFycm93KTtcblxuICAgIGJhci5vbmNsaWNrID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGJhcik7XG5cbiAgICByZXR1cm4gYmFyO1xufVxuXG52YXIgZ2V0VmVydGljYWxDb250cm9sc0JhciA9IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIHZhciBiYXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdmVydGljYWxUYWJsZUNvbnRyb2xzQmFyJyk7XG5cbiAgICBpZihiYXIpIHtcbiAgICAgICAgcmV0dXJuIGJhcjtcbiAgICB9XG5cbiAgICBiYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBiYXIuaWQgPSAndmVydGljYWxUYWJsZUNvbnRyb2xzQmFyJztcbiAgICBiYXIuY2xhc3NMaXN0LmFkZCgndGFibGVDb250cm9sc0JhcicpXG5cbiAgICB2YXIgYXJyb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBhcnJvdy5jbGFzc0xpc3QuYWRkKCdhcnJvdycpXG5cbiAgICBiYXIuYXBwZW5kQ2hpbGQoZ2V0QWRkUm93QWJvdmVCdXR0b24oZWRpdG9yKSk7XG4gICAgYmFyLmFwcGVuZENoaWxkKGdldERlbGV0ZVJvd0J1dHRvbihlZGl0b3IpKTtcbiAgICBiYXIuYXBwZW5kQ2hpbGQoZ2V0QWRkUm93QmVsb3dCdXR0b24oZWRpdG9yKSk7XG4gICAgYmFyLmFwcGVuZENoaWxkKGFycm93KTtcblxuICAgIGJhci5vbmNsaWNrID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGJhcik7XG5cbiAgICByZXR1cm4gYmFyO1xufVxuXG5PYmplY3QuYXNzaWduKG1vZHVsZS5leHBvcnRzLCB7XG5cbiAgICBuYW1lOiAndGFibGUnLFxuXG4gICAgY29udGVudFJ1bGVzOiB7XG4gICAgICAgICd0YWJsZSc6IHtcbiAgICAgICAgICAgIHRhZ05hbWU6ICd0YWJsZScsXG4gICAgICAgICAgICBhbGxvd2VkQXR0cmlidXRlczogWydjbGFzcycsICdkaXNwbGF5LWhlYWRpbmcnLCAnZGlzcGxheS1jYXB0aW9uJywgJ2lkJ10sXG4gICAgICAgICAgICBhbGxvd2VkQ2xhc3NOYW1lczogWydmb2N1c2VkJ10sXG4gICAgICAgICAgICBhbGxvd2VkQ2hpbGRyZW46IFsndGJvZHknLCAnY2FwdGlvbiddLFxuICAgICAgICAgICAgY2hpbGRyZW5DYXJkaW5hbGl0eTogeydjYXB0aW9uJzoge21heDogMX19LFxuICAgICAgICAgICAgYWxsb3dlZFRvQmVSb290OiB0cnVlLFxuICAgICAgICAgICAgZGVsZXRlSWZFbXB0eTogZmFsc2UsXG4gICAgICAgICAgICBidWlsZEVtcHR5RWxlbWVudDogZ2V0U2VjdGlvbkVsZW1lbnQsXG4gICAgICAgICAgICBidWlsZEF0dHJpYnV0ZXM6IFtcbiAgICAgICAgICAgICAgICB7bmFtZTogJ2lkJywgYnVpbGQ6IGZ1bmN0aW9uKCkge3JldHVybiB1dWlkKCl9fSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ2Rpc3BsYXktaGVhZGluZycsIGJ1aWxkOiBmdW5jdGlvbigpIHtyZXR1cm4gJ1llcyd9fSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ2Rpc3BsYXktY2FwdGlvbicsIGJ1aWxkOiBmdW5jdGlvbigpIHtyZXR1cm4gJ1llcyd9fVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICAnY2FwdGlvbic6IHtcbiAgICAgICAgICAgIHRhZ05hbWU6ICdjYXB0aW9uJyxcbiAgICAgICAgICAgIGFsbG93ZWRDaGlsZHJlbjogWycjdGV4dCcsICdyZWZlcmVuY2UnLCAnaW5saW5lZXF1YXRpb24nXSxcbiAgICAgICAgICAgIGRlbGV0ZUlmRW1wdHk6IGZhbHNlLFxuICAgICAgICAgICAgcHJ1bmVTcGFjZXM6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgICd0Ym9keSc6IHtcbiAgICAgICAgICAgIHRhZ05hbWU6ICd0Ym9keScsXG4gICAgICAgICAgICBhbGxvd2VkU3VjY2Vzc29yczogWydjYXB0aW9uJ10sXG4gICAgICAgICAgICBhbGxvd2VkQ2hpbGRyZW46IFsndHInXSxcbiAgICAgICAgfSxcbiAgICAgICAgJ3RyJzoge1xuICAgICAgICAgICAgdGFnTmFtZTogJ3RyJyxcbiAgICAgICAgICAgIGFsbG93ZWRDaGlsZHJlbjogWyd0ZCddLFxuICAgICAgICB9LFxuICAgICAgICAndGQnOiB7XG4gICAgICAgICAgICB0YWdOYW1lOiAndGQnLFxuICAgICAgICAgICAgYWxsb3dlZENoaWxkcmVuOiBbJyN0ZXh0JywgJ2InLCAnaScsICd1JywgJ2xpbmsnLCAnZm9vdG5vdGUnLCAncmVmZXJlbmNlJywgJ2lubGluZWNvZGUnLCAnaW5saW5lZXF1YXRpb24nXSxcbiAgICAgICAgICAgIGRvTm90QnJlYWtPdXRSb290RWxlbWVudHM6IHRydWUsXG4gICAgICAgICAgICBwcnVuZVNwYWNlczogdHJ1ZVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldE9wdGlvbnM6IGZ1bmN0aW9uKHNlY3Rpb25FbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5hbWU6ICdkaXNwbGF5SGVhZGluZycsXG4gICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiAnRGlzcGxheSBIZWFkIFJvdycsXG4gICAgICAgICAgICAgIGFsbG93ZWRWYWx1ZXM6IFsnWWVzJywgJ05vJ10sXG4gICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogc2VjdGlvbkVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkaXNwbGF5LWhlYWRpbmcnKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbmFtZTogJ2Rpc3BsYXlDYXB0aW9uJyxcbiAgICAgICAgICAgICAgZGlzcGxheU5hbWU6ICdEaXNwbGF5IFRhYmxlIENhcHRpb24nLFxuICAgICAgICAgICAgICBhbGxvd2VkVmFsdWVzOiBbJ1llcycsICdObyddLFxuICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IHNlY3Rpb25FbGVtZW50LmdldEF0dHJpYnV0ZSgnZGlzcGxheS1jYXB0aW9uJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG5cbiAgICBvbkZvY3VzOiBmdW5jdGlvbihlbCwgZWRpdG9yLCBhcmdzKSB7XG4gICAgICAgIHZhciB0ZCA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ3RkJyksXG4gICAgICAgICAgICBpc0NhcmV0SW5zaWRlVGFibGUgPSAoZWRpdG9yLnNlY3Rpb25BdENhcmV0UG9zdGlvbigpID09PSBlbCAmJiBlZGl0b3IuY2FyZXQuZ2V0Q29udGV4dEVsZW1lbnQoWyd0ZCcsICdjYXB0aW9uJ10pKSxcbiAgICAgICAgICAgIGhhc0JlZW5Gb2N1c2VkQWZ0ZXJTZWN0aW9uVHlwZUNoYW5nZSA9IGFyZ3MuYWN0aW9uID09PSAnY2hhbmdlRm9jdXNlZFNlY3Rpb25UeXBlJztcblxuICAgICAgICBpZihoYXNCZWVuRm9jdXNlZEFmdGVyU2VjdGlvblR5cGVDaGFuZ2UgfHwgIWlzQ2FyZXRJbnNpZGVUYWJsZSkge1xuICAgICAgICAgICAgdGQgJiYgZWRpdG9yLmNhcmV0LnBvc2l0aW9uSW4odGQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG9uT3B0aW9uc0NoYW5nZTogZnVuY3Rpb24ob3B0LCBlZGl0b3IpIHtcbiAgICAgICAgdmFyIHNlY3Rpb24gPSBlZGl0b3IuZm9jdXNlZFNlY3Rpb24oKTtcbiAgICAgICAgaWYob3B0LmRpc3BsYXlIZWFkaW5nID09PSAnWWVzJyB8fCBvcHQuZGlzcGxheUhlYWRpbmcgPT09ICdObycpIHtcbiAgICAgICAgICAgIHNlY3Rpb24uc2V0QXR0cmlidXRlKCdkaXNwbGF5LWhlYWRpbmcnLCBvcHQuZGlzcGxheUhlYWRpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYob3B0LmRpc3BsYXlDYXB0aW9uID09PSAnWWVzJyB8fCBvcHQuZGlzcGxheUNhcHRpb24gPT09ICdObycpIHtcbiAgICAgICAgICAgIHNlY3Rpb24uc2V0QXR0cmlidXRlKCdkaXNwbGF5LWNhcHRpb24nLCBvcHQuZGlzcGxheUNhcHRpb24pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldFZlcnRpY2FsTmVpZ2hib3JGaWVsZDogZnVuY3Rpb24odGQsIGxvd2VyTmVpZ2hib3IpIHtcbiAgICAgICAgaWYoIXRkKSB7IHJldHVybiB9XG5cbiAgICAgICAgdmFyIHhJbmRleCA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwodGQucGFyZW50RWxlbWVudC5jaGlsZHJlbiwgdGQpLFxuICAgICAgICAgICAgbmVpZ2hib3JSb3cgPSB0ZC5wYXJlbnROb2RlICYmIHRkLnBhcmVudE5vZGVbKGxvd2VyTmVpZ2hib3IgPyAnbmV4dFNpYmxpbmcnIDogJ3ByZXZpb3VzU2libGluZycpXSxcbiAgICAgICAgICAgIGNvbHNwYW4sIHRtcEZpZWxkO1xuXG4gICAgICAgIGlmKCFuZWlnaGJvclJvdykgeyByZXR1cm4gfVxuXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPD14SW5kZXg7KSB7XG4gICAgICAgICAgICBjb2xzcGFuID0gcGFyc2VJbnQobmVpZ2hib3JSb3cuY2hpbGRyZW5baV0uZ2V0QXR0cmlidXRlKCdjb2xzcGFuJykpIHx8IDE7XG4gICAgICAgICAgICB0bXBGaWVsZCA9IG5laWdoYm9yUm93LmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaSArPSBjb2xzcGFuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRtcEZpZWxkO1xuICAgIH0sXG5cbiAgICBnZXROZXh0RmllbGQ6IGZ1bmN0aW9uKHRkKSB7XG4gICAgICAgIGlmKHRkLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGQubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0ZC5wYXJlbnRFbGVtZW50ICYmXG4gICAgICAgICAgIHRkLnBhcmVudEVsZW1lbnQubmV4dFNpYmxpbmcgJiZcbiAgICAgICAgICAgdGQucGFyZW50RWxlbWVudC5uZXh0U2libGluZy5jaGlsZHJlbiAmJlxuICAgICAgICAgICB0ZC5wYXJlbnRFbGVtZW50Lm5leHRTaWJsaW5nLmNoaWxkcmVuWzBdICYmXG4gICAgICAgICAgIHRkLnBhcmVudEVsZW1lbnQubmV4dFNpYmxpbmcuY2hpbGRyZW5bMF0udGFnTmFtZSA9PT0gJ1REJykge1xuICAgICAgICAgICAgIHJldHVybiB0ZC5wYXJlbnRFbGVtZW50Lm5leHRTaWJsaW5nLmNoaWxkcmVuWzBdO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldFByZXZpb3VzRmllbGQ6IGZ1bmN0aW9uKHRkKSB7XG4gICAgICAgIGlmKHRkLnByZXZpb3VzU2libGluZykge1xuICAgICAgICAgICAgcmV0dXJuIHRkLnByZXZpb3VzU2libGluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRkLnBhcmVudEVsZW1lbnQgJiZcbiAgICAgICAgICAgdGQucGFyZW50RWxlbWVudC5wcmV2aW91c1NpYmxpbmcgJiZcbiAgICAgICAgICAgdGQucGFyZW50RWxlbWVudC5wcmV2aW91c1NpYmxpbmcuY2hpbGRyZW4gJiZcbiAgICAgICAgICAgdGQucGFyZW50RWxlbWVudC5wcmV2aW91c1NpYmxpbmcuY2hpbGRyZW5bdGQucGFyZW50RWxlbWVudC5wcmV2aW91c1NpYmxpbmcuY2hpbGRyZW4ubGVuZ3RoLTFdICYmXG4gICAgICAgICAgIHRkLnBhcmVudEVsZW1lbnQucHJldmlvdXNTaWJsaW5nLmNoaWxkcmVuW3RkLnBhcmVudEVsZW1lbnQucHJldmlvdXNTaWJsaW5nLmNoaWxkcmVuLmxlbmd0aC0xXS50YWdOYW1lID09PSAnVEQnKSB7XG4gICAgICAgICAgICAgcmV0dXJuIHRkLnBhcmVudEVsZW1lbnQucHJldmlvdXNTaWJsaW5nLmNoaWxkcmVuW3RkLnBhcmVudEVsZW1lbnQucHJldmlvdXNTaWJsaW5nLmNoaWxkcmVuLmxlbmd0aC0xXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvbktleVVwOiBmdW5jdGlvbihlLCBlZGl0b3IpIHtcbiAgICAgICAgdmFyIHRhcmdldEZpZWxkID0gbW9kdWxlLmV4cG9ydHMuZ2V0VmVydGljYWxOZWlnaGJvckZpZWxkKGVkaXRvci5jYXJldC5nZXRDb250ZXh0RWxlbWVudCgndGQnKSk7XG5cbiAgICAgICAgaWYodGFyZ2V0RmllbGQpIHtcbiAgICAgICAgICAgIGVkaXRvci5jYXJldC5wb3NpdGlvbkluKHRhcmdldEZpZWxkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVkaXRvci5wbGFjZUNhcmV0SW50b1NlY3Rpb24oZWRpdG9yLmZvY3VzZWRTZWN0aW9uKCkucHJldmlvdXNTaWJsaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuXG4gICAgb25LZXlEb3duOiBmdW5jdGlvbihlLCBlZGl0b3IpIHtcbiAgICAgICAgdmFyIHRhcmdldEZpZWxkID0gbW9kdWxlLmV4cG9ydHMuZ2V0VmVydGljYWxOZWlnaGJvckZpZWxkKGVkaXRvci5jYXJldC5nZXRDb250ZXh0RWxlbWVudCgndGQnKSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYodGFyZ2V0RmllbGQpIHtcbiAgICAgICAgICAgIGVkaXRvci5jYXJldC5wb3NpdGlvbkluKHRhcmdldEZpZWxkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVkaXRvci5wbGFjZUNhcmV0SW50b1NlY3Rpb24oZWRpdG9yLmZvY3VzZWRTZWN0aW9uKCkubmV4dFNpYmxpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG5cbiAgICBvbktleVRhYjogZnVuY3Rpb24oZSwgZWRpdG9yKSB7XG5cbiAgICAgICAgdmFyIGdldFRhcmdldEZpZWxkID0gZS5zaGlmdEtleSA/IG1vZHVsZS5leHBvcnRzLmdldFByZXZpb3VzRmllbGQ6IG1vZHVsZS5leHBvcnRzLmdldE5leHRGaWVsZCxcbiAgICAgICAgICAgIHRhcmdldEZpZWxkID0gZ2V0VGFyZ2V0RmllbGQoZWRpdG9yLmNhcmV0LmdldENvbnRleHRFbGVtZW50KCd0ZCcpKTtcblxuICAgICAgICBpZih0YXJnZXRGaWVsZCkge1xuICAgICAgICAgICAgZWRpdG9yLmNhcmV0LnBvc2l0aW9uSW4odGFyZ2V0RmllbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG5cbiAgICBvbktleUVudGVyOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuXG4gICAgb25XaW5kb3dSZXNpemU6IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cy5vblNlbGVjdGlvbkNoYW5nZShlZGl0b3IsIHRydWUpO1xuICAgIH0sXG5cbiAgICBvblNlbGVjdGlvbkNoYW5nZTogZnVuY3Rpb24oZWRpdG9yLCBmb3JjZSkge1xuICAgICAgICB2YXIgY2VsbCA9IGVkaXRvci5jYXJldC5nZXRDb250ZXh0RWxlbWVudCgndGQnKTtcblxuICAgICAgICBpZighY2VsbCkge1xuICAgICAgICAgICAgdGhpcy5vblVuZm9jdXMoZWRpdG9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0YWJsZSA9IGNlbGwucGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG5cbiAgICAgICAgaWYoZm9jdXNlZENlbGwgIT09IGNlbGwgfHwgZm9yY2UpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQob25VbmZvY3VzVGltZW91dCk7XG4gICAgICAgICAgICB2YXIgaGJhciA9IGdldEhvcml6b250YWxDb250cm9sc0JhcihlZGl0b3IpO1xuICAgICAgICAgICAgdmFyIHZiYXIgPSBnZXRWZXJ0aWNhbENvbnRyb2xzQmFyKGVkaXRvcik7XG4gICAgICAgICAgICB2YXIgdGFibGVQb3MgPSB1dGlscy5nZXRFbGVtZW50UG9zaXRpb24odGFibGUpO1xuICAgICAgICAgICAgdmFyIGNlbGxQb3MgPSB1dGlscy5nZXRFbGVtZW50UG9zaXRpb24oY2VsbCk7XG5cbiAgICAgICAgICAgIGhiYXIuc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgICAgICAgICBoYmFyLnN0eWxlLnRvcCA9ICh0YWJsZVBvcy55IC0gMzIpICsgJ3B4JztcbiAgICAgICAgICAgIGhiYXIuc3R5bGUubGVmdCA9IE1hdGguZmxvb3IoY2VsbFBvcy54ICsgKChjZWxsLm9mZnNldFdpZHRoLzIpLShoYmFyLm9mZnNldFdpZHRoLzIpKSkgKyAncHgnO1xuXG4gICAgICAgICAgICB2YmFyLnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICAgICAgdmJhci5zdHlsZS50b3AgPSBNYXRoLmZsb29yKGNlbGxQb3MueSArICgoY2VsbC5vZmZzZXRIZWlnaHQvMiktKHZiYXIub2Zmc2V0SGVpZ2h0LzIpKSkgKyAncHgnO1xuICAgICAgICAgICAgdmJhci5zdHlsZS5sZWZ0ID0gKHRhYmxlUG9zLnggLSAzMCkgKyAncHgnO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9jdXNlZENlbGwgPSBjZWxsO1xuICAgIH0sXG5cbiAgICBvblVuZm9jdXM6IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgICB2YXIgaGJhciA9IGdldEhvcml6b250YWxDb250cm9sc0JhcihlZGl0b3IpO1xuICAgICAgICB2YXIgdmJhciA9IGdldFZlcnRpY2FsQ29udHJvbHNCYXIoZWRpdG9yKTtcblxuICAgICAgICBsYXN0Rm9jdXNlZENlbGwgPSBmb2N1c2VkQ2VsbDtcbiAgICAgICAgZm9jdXNlZENlbGwgPSBudWxsO1xuXG4gICAgICAgIGhiYXIuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgIHZiYXIuc3R5bGUub3BhY2l0eSA9IDA7XG5cbiAgICAgICAgb25VbmZvY3VzVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaGJhci5zdHlsZS50b3AgPSAtMTAwMCArICdweCc7XG4gICAgICAgICAgICBoYmFyLnN0eWxlLmxlZnQgPSAtMTAwMCArICdweCc7XG5cbiAgICAgICAgICAgIHZiYXIuc3R5bGUudG9wID0gLTEwMDAgKyAncHgnO1xuICAgICAgICAgICAgdmJhci5zdHlsZS5sZWZ0ID0gLTEwMDAgKyAncHgnO1xuICAgICAgICB9LCAxMDApO1xuICAgIH0sXG5cbiAgICBvbktleUNvbWJpbmF0aW9uOiBmdW5jdGlvbihlLCBlZGl0b3IpIHtcbiAgICAgICAgaWYoKGUubWV0YUtleSB8fCBlLmN0cmxLZXkpICYmICFlLnNoaWZ0S2V5ICYmIGUua2V5ID09PSAncicpIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzLmFkZFJvdyhlZGl0b3IuY2FyZXQuZ2V0Q29udGV4dEVsZW1lbnQoJ3RkJyksIGVkaXRvcik7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0gZWxzZSBpZigoZS5tZXRhS2V5IHx8IGUuY3RybEtleSkgJiYgIWUuc2hpZnRLZXkgJiYgZS5rZXkgPT09ICdlJykge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMuYWRkQ29sdW1uKGVkaXRvci5jYXJldC5nZXRDb250ZXh0RWxlbWVudCgndGQnKSwgZWRpdG9yKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSBlbHNlIGlmKChlLm1ldGFLZXkgfHwgZS5jdHJsS2V5KSAmJiBlLnNoaWZ0S2V5ICYmIChlLmtleSA9PT0gJ2UnIHx8IGUua2V5ID09PSAnRScpICkge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMuZGVsZXRlQ29sdW1uKGVkaXRvci5jYXJldC5nZXRDb250ZXh0RWxlbWVudCgndGQnKSwgZWRpdG9yKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSBlbHNlIGlmKChlLm1ldGFLZXkgfHwgZS5jdHJsS2V5KSAmJiBlLnNoaWZ0S2V5ICYmIChlLmtleSA9PT0gJ3InIHx8IGUua2V5ID09PSAnUicpICkge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMuZGVsZXRlUm93KGVkaXRvci5jYXJldC5nZXRDb250ZXh0RWxlbWVudCgndGQnKSwgZWRpdG9yKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBhZGRSb3c6IGZ1bmN0aW9uKGNvbnRleHRFbGVtZW50LCBlZGl0b3IsIGluc2VydEJlZm9yZSkge1xuICAgICAgICB2YXIgc2VsO1xuICAgICAgICBpZighY29udGV4dEVsZW1lbnQgJiYgIWVkaXRvcikgeyByZXR1cm4gfVxuXG4gICAgICAgIGNvbnRleHRFbGVtZW50ID0gY29udGV4dEVsZW1lbnQgfHwgbGFzdEZvY3VzZWRDZWxsIHx8IGVkaXRvci5jYXJldC5nZXRDb250ZXh0RWxlbWVudCgndGQnKTtcblxuICAgICAgICBpZighY29udGV4dEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGlmKHNlbC5hbmNob3JOb2RlID09PSBzZWwuZm9jdXNOb2RlICYmXG4gICAgICAgICAgICAgICBzZWwuYW5jaG9yTm9kZS50YWdOYW1lICYmXG4gICAgICAgICAgICAgICBzZWwuYW5jaG9yTm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0Ym9keScpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0RWxlbWVudCA9IHNlbC5hbmNob3JOb2RlLmNoaWxkcmVuW3NlbC5hbmNob3JPZmZzZXRdLmNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbGNvdW50ID0gY29udGV4dEVsZW1lbnQucGFyZW50Tm9kZS5jaGlsZHJlbi5sZW5ndGgsXG4gICAgICAgICAgICBjdXJyZW50VHIgPSBjb250ZXh0RWxlbWVudC5wYXJlbnROb2RlLFxuICAgICAgICAgICAgdGJvZHkgPSBjdXJyZW50VHIucGFyZW50Tm9kZSxcbiAgICAgICAgICAgIHRhYmxlID0gZWRpdG9yLnNlY3Rpb25CeUNoaWxkTm9kZSh0Ym9keSksXG4gICAgICAgICAgICBuZXdUciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XG5cbiAgICAgICAgZm9yKGxldCBpPTA7IGk8Y29sY291bnQ7IGkrKykge1xuICAgICAgICAgICAgbmV3VHIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0Ym9keS5pbnNlcnRCZWZvcmUobmV3VHIsIGluc2VydEJlZm9yZSA/IGN1cnJlbnRUciA6IGN1cnJlbnRUci5uZXh0U2libGluZyk7XG4gICAgICAgIGVkaXRvci5yZXBsYWNlU2VjdGlvbldpdGhIVE1MKHRhYmxlLCB0YWJsZS5vdXRlckhUTUwpO1xuICAgIH0sXG5cbiAgICBhZGRDb2x1bW46IGZ1bmN0aW9uKGNvbnRleHRFbGVtZW50LCBlZGl0b3IsIGluc2VydExlZnQpIHtcbiAgICAgICAgdmFyIHNlbDtcbiAgICAgICAgaWYoIWNvbnRleHRFbGVtZW50ICYmICFlZGl0b3IpIHsgcmV0dXJuIH1cbiAgICAgICAgY29udGV4dEVsZW1lbnQgPSBjb250ZXh0RWxlbWVudCB8fCBsYXN0Rm9jdXNlZENlbGwgfHwgZWRpdG9yLmNhcmV0LmdldENvbnRleHRFbGVtZW50KCd0ZCcpO1xuXG4gICAgICAgIGlmKCFjb250ZXh0RWxlbWVudCkge1xuICAgICAgICAgICAgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgaWYoc2VsLmFuY2hvck5vZGUgPT09IHNlbC5mb2N1c05vZGUgJiZcbiAgICAgICAgICAgICAgIHNlbC5hbmNob3JOb2RlLnRhZ05hbWUgJiZcbiAgICAgICAgICAgICAgIHNlbC5hbmNob3JOb2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RyJykge1xuICAgICAgICAgICAgICAgIGNvbnRleHRFbGVtZW50ID0gc2VsLmFuY2hvck5vZGUuY2hpbGRyZW5bc2VsLmFuY2hvck9mZnNldF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29sSW5kZXggPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGNvbnRleHRFbGVtZW50LnBhcmVudE5vZGUuY2hpbGRyZW4sIGNvbnRleHRFbGVtZW50KSxcbiAgICAgICAgICAgIHRhYmxlUm93cyA9IGNvbnRleHRFbGVtZW50LnBhcmVudE5vZGUucGFyZW50Tm9kZS5jaGlsZHJlbixcbiAgICAgICAgICAgIHRhYmxlID0gY29udGV4dEVsZW1lbnQucGFyZW50Tm9kZS5wYXJlbnROb2RlLnBhcmVudE5vZGU7XG5cbiAgICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbCh0YWJsZVJvd3MsIGZ1bmN0aW9uKHRyKSB7XG4gICAgICAgICAgICB0ci5pbnNlcnRCZWZvcmUoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKSwgaW5zZXJ0TGVmdCA/IHRyLmNoaWxkcmVuW2NvbEluZGV4XSA6IHRyLmNoaWxkcmVuW2NvbEluZGV4XS5uZXh0U2libGluZylcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZWRpdG9yLnJlcGxhY2VTZWN0aW9uV2l0aEhUTUwodGFibGUsIHRhYmxlLm91dGVySFRNTCk7XG4gICAgfSxcblxuICAgIGRlbGV0ZUNvbHVtbjogZnVuY3Rpb24oY29udGV4dEVsZW1lbnQsIGVkaXRvcikge1xuICAgICAgICB2YXIgc2VsO1xuXG4gICAgICAgIGlmKCFjb250ZXh0RWxlbWVudCAmJiAhZWRpdG9yKSB7IHJldHVybiB9XG5cbiAgICAgICAgY29udGV4dEVsZW1lbnQgPSBjb250ZXh0RWxlbWVudCB8fCBsYXN0Rm9jdXNlZENlbGwgfHwgZWRpdG9yLmNhcmV0LmdldENvbnRleHRFbGVtZW50KCd0ZCcpO1xuXG4gICAgICAgIGlmKCFjb250ZXh0RWxlbWVudCkge1xuICAgICAgICAgICAgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgaWYoc2VsLmFuY2hvck5vZGUgPT09IHNlbC5mb2N1c05vZGUgJiZcbiAgICAgICAgICAgICAgIHNlbC5hbmNob3JOb2RlLnRhZ05hbWUgJiZcbiAgICAgICAgICAgICAgIHNlbC5hbmNob3JOb2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RyJykge1xuICAgICAgICAgICAgICAgIGNvbnRleHRFbGVtZW50ID0gc2VsLmFuY2hvck5vZGUuY2hpbGRyZW5bc2VsLmFuY2hvck9mZnNldF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29sdW1ucyA9IGNvbnRleHRFbGVtZW50LnBhcmVudE5vZGUuY2hpbGRyZW4sXG4gICAgICAgICAgICBjb2xJbmRleCA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoY29sdW1ucywgY29udGV4dEVsZW1lbnQpLFxuICAgICAgICAgICAgdGFibGVSb3dzID0gY29udGV4dEVsZW1lbnQucGFyZW50Tm9kZS5wYXJlbnROb2RlLmNoaWxkcmVuLFxuICAgICAgICAgICAgdGFibGUgPSBjb250ZXh0RWxlbWVudC5wYXJlbnROb2RlLnBhcmVudE5vZGUucGFyZW50Tm9kZTtcblxuICAgICAgICBpZihjb2x1bW5zLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKHRhYmxlUm93cywgZnVuY3Rpb24odHIpIHtcbiAgICAgICAgICAgIHRyLnJlbW92ZUNoaWxkKHRyLmNoaWxkcmVuW2NvbEluZGV4XSlcbiAgICAgICAgfSk7XG4gICAgICAgIGVkaXRvci5yZXBsYWNlU2VjdGlvbldpdGhIVE1MKHRhYmxlLCB0YWJsZS5vdXRlckhUTUwpO1xuICAgIH0sXG5cbiAgICBkZWxldGVSb3c6IGZ1bmN0aW9uKGNvbnRleHRFbGVtZW50LCBlZGl0b3IpIHtcbiAgICAgICAgdmFyIHNlbCwgdGFibGU7XG5cbiAgICAgICAgaWYoIWNvbnRleHRFbGVtZW50ICYmICFlZGl0b3IpIHsgcmV0dXJuIH1cblxuICAgICAgICBjb250ZXh0RWxlbWVudCA9IGNvbnRleHRFbGVtZW50IHx8IGxhc3RGb2N1c2VkQ2VsbCB8fCBlZGl0b3IuY2FyZXQuZ2V0Q29udGV4dEVsZW1lbnQoJ3RkJyk7XG4gICAgICAgIGNvbnRleHRFbGVtZW50ID0gY29udGV4dEVsZW1lbnQucGFyZW50RWxlbWVudDtcblxuICAgICAgICBpZighY29udGV4dEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGlmKHNlbC5hbmNob3JOb2RlID09PSBzZWwuZm9jdXNOb2RlICYmXG4gICAgICAgICAgICAgICBzZWwuYW5jaG9yTm9kZS50YWdOYW1lICYmXG4gICAgICAgICAgICAgICBzZWwuYW5jaG9yTm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0Ym9keScpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0RWxlbWVudCA9IHNlbC5hbmNob3JOb2RlLmNoaWxkcmVuW3NlbC5hbmNob3JPZmZzZXRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGFibGUgPSBjb250ZXh0RWxlbWVudC5wYXJlbnROb2RlLnBhcmVudE5vZGU7XG5cbiAgICAgICAgaWYoY29udGV4dEVsZW1lbnQucGFyZW50Tm9kZS5jaGlsZHJlbi5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dEVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgIGVkaXRvci5yZXBsYWNlU2VjdGlvbldpdGhIVE1MKHRhYmxlLCB0YWJsZS5vdXRlckhUTUwpO1xuICAgIH0sXG5cbiAgICBvbktleUJhY2tzcGFjZTogZnVuY3Rpb24oZSwgZWRpdG9yKSB7XG4gICAgICAgIHZhciBzZWwsXG4gICAgICAgICAgICB0YWJsZSA9IGVkaXRvci5jYXJldC5nZXRDb250ZXh0RWxlbWVudCgndGFibGUnKSxcbiAgICAgICAgICAgIGNhcHRpb24gPSBlZGl0b3IuY2FyZXQuZ2V0Q29udGV4dEVsZW1lbnQoJ2NhcHRpb24nLCB3aW5kb3cuZ2V0U2VsZWN0aW9uKCksIFtdKSxcbiAgICAgICAgICAgIHRkID0gZWRpdG9yLmNhcmV0LmdldENvbnRleHRFbGVtZW50KCd0ZCcsIHdpbmRvdy5nZXRTZWxlY3Rpb24oKSwgW10pLFxuICAgICAgICAgICAgaW5DYXB0aW9uID0gISFjYXB0aW9uLFxuICAgICAgICAgICAgZWwgPSB0ZCB8fCBjYXB0aW9uLFxuICAgICAgICAgICAgdGFibGVJZCA9IHRhYmxlLmlkLFxuICAgICAgICAgICAgdHIsIHRySW5kZXgsIHRkSW5kZXg7XG5cbiAgICAgICAgaWYoIWVsKSByZXR1cm47XG5cbiAgICAgICAgaWYoZWwuaW5uZXJUZXh0ICYmIGVsLmlubmVyVGV4dC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGlmKCFpbkNhcHRpb24pIHtcbiAgICAgICAgICAgICAgICB0ciA9IHRkLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgdGRJbmRleCA9IHRyLmNoaWxkcmVuLmluZGV4T2YodGQpO1xuICAgICAgICAgICAgICAgIHRySW5kZXggPSB0ci5wYXJlbnRFbGVtZW50LmNoaWxkcmVuLmluZGV4T2YodHIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkb2N1bWVudC5leGVjQ29tbWFuZCgnZGVsZXRlJyk7XG5cbiAgICAgICAgICAgIHRhYmxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGFibGVJZCk7XG5cbiAgICAgICAgICAgIGlmKCFpbkNhcHRpb24pIHtcbiAgICAgICAgICAgICAgICBlbCA9IHRhYmxlLnF1ZXJ5U2VsZWN0b3IoJ3Rib2R5JykuY2hpbGRyZW5bdHJJbmRleF0uY2hpbGRyZW5bdGRJbmRleF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsID0gdGFibGUucXVlcnlTZWxlY3RvcignY2FwdGlvbicpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVkaXRvci5jYXJldC5wb3NpdGlvbkluKGVsKTtcblxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9IGVsc2UgaWYoIWVsLmlubmVyVGV4dCB8fCBlbC5pbm5lclRleHQubGVuZ3RoID09PSAwIHx8IGVkaXRvci5jYXJldC5pc0NvbGxhcHNlZEFuZFBvc2l0aW9uZWRBdFRoZUJlZ2lubmluZ09mKGNhcHRpb24sIGZhbHNlKSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldFNlY3Rpb25FbGVtZW50OiBnZXRTZWN0aW9uRWxlbWVudFxufSlcbiIsInZhciBidWlsZFRvQyA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi90b2NfYnVpbGRlci90b2NfYnVpbGRlcicpLFxuICAgIGJpYlNlY3Rpb25UeXBlID0gcmVxdWlyZSgnLi4vYmlibGlvZ3JhcGhpZS9iaWJsaW9ncmFwaGllX3NlY3Rpb25fdHlwZScpLFxuICAgIHV1aWQgPSByZXF1aXJlKCd1dWlkL3YxJyk7XG5cbmZ1bmN0aW9uIGdldFNlY3Rpb25FbGVtZW50KCkge1xuICAgIHZhciAgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCduYXYnKSxcbiAgICAgICAgIGhlYWRpbmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoMicpO1xuXG4gICAgaGVhZGluZy5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScsICd0cnVlJyk7XG4gICAgaGVhZGluZy5jbGFzc0xpc3QuYWRkKCd0b2MtaGVhZGluZycpO1xuICAgIGhlYWRpbmcuY2xhc3NMaXN0LmFkZCgnbm8tdG9jLWxpc3RpbmcnKTtcbiAgICBoZWFkaW5nLmlubmVySFRNTCA9ICdUYWJsZSBvZiBDb250ZW50cyc7XG5cbiAgICBlbC5vbktleUJhY2tzcGFjZSA9IG1vZHVsZS5leHBvcnRzLm9uS2V5QmFja3NwYWNlO1xuICAgIGVsLnNlY3Rpb25UeXBlID0gbW9kdWxlLmV4cG9ydHM7XG4gICAgZWwuY2xhc3NMaXN0LmFkZCgndG9jJyk7XG4gICAgZWwuYXBwZW5kQ2hpbGQoaGVhZGluZyk7XG5cbiAgICByZXR1cm4gZWw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgbmFtZTogJ3RvYycsXG5cbiAgICBwcmVmZXJyZWRDYXJldFBvc2l0aW9uaW5nOiAnZW5kJyxcblxuICAgIGNvbnRlbnRSdWxlczoge1xuICAgICAgICAndG9jJzoge1xuICAgICAgICAgICAgdGFnTmFtZTogJ25hdicsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICd0b2MnLFxuICAgICAgICAgICAgYWxsb3dlZEF0dHJpYnV0ZXM6IFsnY2xhc3MnLCAnY29udGVudGVkaXRhYmxlJ10sXG4gICAgICAgICAgICBhbGxvd2VkQ2xhc3NOYW1lczogWydmb2N1c2VkJywgJ3RvYyddLFxuICAgICAgICAgICAgYWxsb3dlZENoaWxkcmVuOiBbJ3RvYy1oZWFkaW5nJ10sXG4gICAgICAgICAgICBhbGxvd2VkVG9CZVJvb3Q6IHRydWUsXG4gICAgICAgICAgICBkZWxldGVJZkVtcHR5OiBmYWxzZSxcbiAgICAgICAgICAgIGJ1aWxkRW1wdHlFbGVtZW50OiBnZXRTZWN0aW9uRWxlbWVudFxuICAgICAgICB9LFxuICAgICAgICAndG9jLWhlYWRpbmcnOiB7XG4gICAgICAgICAgICB0YWdOYW1lOiAnaDInLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAndG9jLWhlYWRpbmcnLFxuICAgICAgICAgICAgYWxsb3dlZEF0dHJpYnV0ZXM6IFsnaWQnLCAnY2xhc3MnLCAnY29udGVudGVkaXRhYmxlJywgJ3VubnVtYmVyZWQtaGVhZGluZyddLFxuICAgICAgICAgICAgYWxsb3dlZENsYXNzTmFtZXM6IFsndG9jLWhlYWRpbmcnLCAnbm8tdG9jLWxpc3RpbmcnXSxcbiAgICAgICAgICAgIGFsbG93ZWRDaGlsZHJlbjogWycjdGV4dCddLFxuICAgICAgICAgICAgcHJ1bmVTcGFjZXM6IHRydWUsXG4gICAgICAgICAgICBidWlsZEF0dHJpYnV0ZXM6IFtcbiAgICAgICAgICAgICAgICB7bmFtZTogJ2lkJywgYnVpbGQ6IGZ1bmN0aW9uKCkge3JldHVybiB1dWlkKCl9fSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ3VubnVtYmVyZWQtaGVhZGluZycsIGJ1aWxkOiBmdW5jdGlvbigpIHtyZXR1cm4gJ1llcyd9fVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgIH0sXG5cbiAgICBlbnJpY2htZW50czogW10sXG5cbiAgICBnZXRTZWN0aW9uRWxlbWVudDogZ2V0U2VjdGlvbkVsZW1lbnQsXG5cbiAgICBvbktleUJhY2tzcGFjZTogYmliU2VjdGlvblR5cGUub25LZXlCYWNrc3BhY2UsXG5cbiAgICBvbkZvY3VzOiBmdW5jdGlvbihlbCwgZWRpdG9yLCBhcmdzKSB7XG4gICAgICAgIHZhciB0b0NIZWFkaW5nID0gZWwucXVlcnlTZWxlY3RvcignaDInKSxcbiAgICAgICAgICAgIGlzQ2FyZXRJbnNpZGVTZWN0aW9uID0gKGVkaXRvci5zZWN0aW9uQXRDYXJldFBvc3Rpb24oKSA9PT0gZWwgJiYgZWRpdG9yLmNhcmV0LmdldENvbnRleHRFbGVtZW50KCdoMicpKSxcbiAgICAgICAgICAgIGhhc0JlZW5Gb2N1c2VkQWZ0ZXJTZWN0aW9uVHlwZUNoYW5nZSA9IGFyZ3MuYWN0aW9uID09PSAnY2hhbmdlRm9jdXNlZFNlY3Rpb25UeXBlJztcblxuICAgICAgICBpZihoYXNCZWVuRm9jdXNlZEFmdGVyU2VjdGlvblR5cGVDaGFuZ2UgfHwgIWlzQ2FyZXRJbnNpZGVTZWN0aW9uKSB7XG4gICAgICAgICAgICB0b0NIZWFkaW5nICYmIGVkaXRvci5jYXJldC5wb3NpdGlvbkluKHRvQ0hlYWRpbmcpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG9uRWRpdG9yQ29udGVudENoYW5nZWQ6IGZ1bmN0aW9uKG1vZGlmaWNhdGlvbkxvZykge1xuICAgICAgICBpZighbW9kaWZpY2F0aW9uTG9nLm1pZ2h0SW5jbHVkZUhlYWRpbmdVcGRhdGVzICYmICFtb2RpZmljYXRpb25Mb2cubWlnaHRJbmNsdWRlVGFibGVPZkNvbnRlbnRVcGRhdGVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG9jU2VjdGlvbnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCduYXYudG9jJyksXG4gICAgICAgICAgICBuZXdDb250ZW50LCB0bXBFbCwgdG9jO1xuXG4gICAgICAgIGlmKHRvY1NlY3Rpb25zLmxlbmd0aCA9PT0gMCkgeyByZXR1cm47IH1cblxuICAgICAgICB0b2MgPSBidWlsZFRvQyhkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuc3RydWN0dXJlZC10ZXh0LWVkaXRvcicpLCB7d2l0aExpbmtzOiB0cnVlLCBzdGFydE51bWJlcmluZ0F0TGV2ZWw6IDJ9KTtcbiAgICAgICAgdG9jLnF1ZXJ5U2VsZWN0b3JBbGwoJ29sLCBsaScpLmZvckVhY2goZnVuY3Rpb24oZW50cnkpIHsgZW50cnkuY2xhc3NMaXN0LmFkZCgndG9jJykgfSk7XG4gICAgICAgIHRvYy5jbGFzc0xpc3QuYWRkKCd0b2MnKTtcblxuICAgICAgICBpZih0b2MuaW5uZXJIVE1MID09PSAnJykge1xuICAgICAgICAgICAgbmV3Q29udGVudCA9ICc8c3BhbiBjbGFzcz1cImhpbnRcIj5JbnNlcnQgc29tZSBoZWFkaW5ncyBpbnRvIHlvdXIgZG9jdW1lbnQgdG8gc2VlIGEgdGFibGUgb2YgY29udGVudHMgaGVyZS48L3NwYW4+JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0NvbnRlbnQgPSB0b2Mub3V0ZXJIVE1MO1xuICAgICAgICB9XG5cbiAgICAgICAgdG9jU2VjdGlvbnMuZm9yRWFjaChmdW5jdGlvbih0b2NTZWN0aW9uKSB7XG4gICAgICAgICAgICB0b2NTZWN0aW9uLnN1bW1hcml6ZWRDb250ZW50TGVuZ3RoID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdG1wRWwgPSB0b2NTZWN0aW9uLnF1ZXJ5U2VsZWN0b3IoJy50b2MtY29udGVudCcpO1xuXG4gICAgICAgICAgICBpZighdG1wRWwpIHtcbiAgICAgICAgICAgICAgICB0bXBFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgICAgICB0bXBFbC5jbGFzc0xpc3QuYWRkKCd0b2MtY29udGVudCcpO1xuICAgICAgICAgICAgICAgIHRvY1NlY3Rpb24uYXBwZW5kQ2hpbGQodG1wRWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0bXBFbC5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScsICdmYWxzZScpO1xuXG4gICAgICAgICAgICBpZih0bXBFbC5pbm5lckhUTUwgIT09IG5ld0NvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICB0bXBFbC5pbm5lckhUTUwgPSBuZXdDb250ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDYXJldCA9IHJlcXVpcmUoJy4vY2FyZXQnKSxcbiAgICBIVE1MUmF6b3IgPSByZXF1aXJlKCcuLi9saWIvaHRtbF9yYXpvci9odG1sX3Jhem9yJyksXG4gICAgdXRpbHMgPSByZXF1aXJlKCcuLi9saWIvcGl4ZWxzY2h1YnNlci91dGlscycpLFxuICAgIC8vIGthdGV4ID0gcmVxdWlyZSgna2F0ZXgnKSwgLy8gbWFrZSBzdXJlIHRvIGxvYWQgPHNjcmlwdCBzcmM9XCIuL2thdGV4LmpzXCIgZGVmZXI+PC9zY3JpcHQ+IGluIHlvdXIgaHRtbFxuICAgIGxhdGV4Q2hlYXRzaGVldCA9IHJlcXVpcmUoJy4uL2Fzc2V0cy9sYXRleF9jaGVhdHNoZWV0JyksXG4gICAgRGVjbGFyYXRpdkZvcm0gPSByZXF1aXJlKCcuLi9saWIvZGVjbGFyYXRpdl9mb3Jtcy9zcmMvZGVjbGFyYXRpdl9mb3JtJyksXG4gICAgeyBnZXRSZWZlcmVuY2VTb3VyY2VzRmllbGRzLCBzeW5jQWxsU291cmNlcyB9ID0gcmVxdWlyZSgnLi9yZWZlcmVuY2VzL3JlZmVyZW5jZV9zb3VyY2VzJylcblxuZnVuY3Rpb24gVGV4dEVucmljaG1lbnRDb250cm9sKGVkaXRvcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMuY2FyZXQgPSBuZXcgQ2FyZXQoZWRpdG9yKTtcbiAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICB0aGlzLnZpc2libGUgPSBmYWxzZTtcbiAgICB0aGlzLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmRvbUVsZW1lbnQuY2xhc3NOYW1lICs9ICcgdGV4dEVucmljaG1lbnRDb250cm9sJztcbiAgICB0aGlzLmhpZGUoKTtcblxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5kb21FbGVtZW50KTtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIgKFwia2V5ZG93blwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZihlLmNvZGUgPT09ICdFc2NhcGUnKSB7XG4gICAgICAgICAgICBzZWxmLmVkaXRvci51bmZyZWV6ZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgc2VsZi5oaWRlKHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG5cbiAgICB0aGlzLmVucmljaG1lbnRzID0gW1xuICAgICAgICB7Y2xhc3NOYW1lOiAnaXRhbGljJywgICAgIGNvbW1hbmQ6ICdpdGFsaWMnLCAgICAgICAgZGlwbGF5TmFtZTogJzxpPkk8L2k+JywgYWxsb3dlZENvbnRleHQ6IFsncCcsICd0YWJsZScsICdvbCcsICd1bCddLCBub3RBbGxvd2VkQ29udGV4dDogWydjYXB0aW9uJywgJ25hdiddfSxcbiAgICAgICAge2NsYXNzTmFtZTogJ2JvbGQnLCAgICAgICBjb21tYW5kOiAnYm9sZCcsICAgICAgICAgIGRpcGxheU5hbWU6ICc8Yj5CPC9iPicsIGFsbG93ZWRDb250ZXh0OiBbJ3AnLCAndGFibGUnLCAnb2wnLCAndWwnXSwgbm90QWxsb3dlZENvbnRleHQ6IFsnY2FwdGlvbicsICduYXYnXX0sXG4gICAgICAgIHtjbGFzc05hbWU6ICd1bmRlcmxpbmUnLCAgY29tbWFuZDogJ3VuZGVybGluZScsICAgICBkaXBsYXlOYW1lOiAnPHU+VTwvdT4nLCBhbGxvd2VkQ29udGV4dDogWydwJywgJ3RhYmxlJywgJ29sJywgJ3VsJ10sIG5vdEFsbG93ZWRDb250ZXh0OiBbJ2NhcHRpb24nLCAnbmF2J119LFxuICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICdjb2RlJyxcbiAgICAgICAgICAgIGRpcGxheU5hbWU6ICc8Y29kZSBjbGFzcz1cImNvZGUtdGV4dC1lbnJpY2htZW50LWJ1dHRvblwiPjxpIGNsYXNzPVwiZmFzIGZhLWNvZGVcIj48L2k+PC9jb2RlPicsXG4gICAgICAgICAgICBhbGxvd2VkQ29udGV4dDogWydwJywgJ3RhYmxlJywgJ29sJywgJ3VsJ10sXG4gICAgICAgICAgICBub3RBbGxvd2VkQ29udGV4dDogWydjYXB0aW9uJywgJ25hdiddLFxuICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpLFxuICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHNlbC5nZXRSYW5nZUF0KDApLFxuICAgICAgICAgICAgICAgICAgICBuZXdFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5saW5lY29kZScpLFxuICAgICAgICAgICAgICAgICAgICBzZWN0aW9uID0gc2VsZi5lZGl0b3IuZm9jdXNlZFNlY3Rpb24oKSxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dEVsID0gc2VsZi5jYXJldC5nZXRDb250ZXh0RWxlbWVudCgnaW5saW5lY29kZScpLFxuICAgICAgICAgICAgICAgICAgICBhbGxDb2Rlc0luU2VjdGlvbiwgY29udGVudCwgdGV4dE5vZGVMZWZ0LCB0ZXh0Tm9kZVJpZ2h0O1xuXG4gICAgICAgICAgICAgICAgaWYoY29udGV4dEVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSByYW5nZS5leHRyYWN0Q29udGVudHMoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHNlbC5nZXRSYW5nZUF0KDApO1xuXG4gICAgICAgICAgICAgICAgICAgIHRleHROb2RlTGVmdCA9IHNlbC5mb2N1c05vZGU7XG4gICAgICAgICAgICAgICAgICAgIHRleHROb2RlUmlnaHQgPSB0ZXh0Tm9kZUxlZnQuc3BsaXRUZXh0KHNlbC5mb2N1c09mZnNldCk7XG5cbiAgICAgICAgICAgICAgICAgICAgbmV3RWxlbWVudC5hcHBlbmRDaGlsZCh0ZXh0Tm9kZVJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dEVsLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld0VsZW1lbnQsIGNvbnRleHRFbC5uZXh0U2libGluZyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRFbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjb250ZW50LCBjb250ZXh0RWwubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0VsZW1lbnQuYXBwZW5kQ2hpbGQocmFuZ2UuZXh0cmFjdENvbnRlbnRzKCkpO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5pbnNlcnROb2RlKG5ld0VsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGFsbENvZGVzSW5TZWN0aW9uID0gc2VjdGlvbi5xdWVyeVNlbGVjdG9yQWxsKCdpbmxpbmVjb2RlJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpPTA7IGk8YWxsQ29kZXNJblNlY3Rpb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gYWxsQ29kZXNJblNlY3Rpb25baV0ubmV4dFNpYmxpbmc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG5leHQgJiYgbmV4dC50YWdOYW1lID09PSAnSU5MSU5FQ09ERScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxDb2Rlc0luU2VjdGlvbltpXS5pbm5lckhUTUwgKz0gbmV4dC5pbm5lckhUTUw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxDb2Rlc0luU2VjdGlvbiA9IHNlY3Rpb24ucXVlcnlTZWxlY3RvckFsbCgnaW5saW5lY29kZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGk9LTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG5leHQgJiYgbmV4dC5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUgJiYgbmV4dC50ZXh0Q29udGVudCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0LnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbENvZGVzSW5TZWN0aW9uID0gc2VjdGlvbi5xdWVyeVNlbGVjdG9yQWxsKCdpbmxpbmVjb2RlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaT0tMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNlbGYuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICdsaW5rJyxcbiAgICAgICAgICAgIGNvbW1hbmQ6ICdjcmVhdGVMaW5rJyxcbiAgICAgICAgICAgIGRpcGxheU5hbWU6ICc8aSBjbGFzcz1cImZhcyBmYS1saW5rIGZhLXhzXCI+PC9pPicsXG4gICAgICAgICAgICBhbGxvd2VkQ29udGV4dDogWydwJywgJ3RhYmxlJywgJ29sJywgJ3VsJ10sXG4gICAgICAgICAgICBub3RBbGxvd2VkQ29udGV4dDogWydhJywgJ2NhcHRpb24nLCAnbmF2J10sXG4gICAgICAgICAgICBhcmd1bWVudHM6IFt7bmFtZTogJ3VybCcsIHBsYWNlaG9sZGVyOiAnaHR0cDovLy4uLicsIGRpc3BsYXlOYW1lOiAnVVJMJywgdHlwZTogJ3RleHQnfV1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAndW5saW5rJyxcbiAgICAgICAgICAgIHJhbmdlUmVxdWlyZTogZmFsc2UsXG4gICAgICAgICAgICBkaXBsYXlOYW1lOiAnPGkgY2xhc3M9XCJmYXMgZmEtdW5saW5rIGZhLXhzXCI+PC9pPicsXG4gICAgICAgICAgICBhbGxvd2VkQ29udGV4dDogJ2EnLFxuICAgICAgICAgICAgbm90QWxsb3dlZENvbnRleHQ6IFsnbmF2J10sXG4gICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKGNvbnRleHRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IGNvbnRleHRFbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvbnRleHRFbGVtZW50LmZpcnN0Q2hpbGQpIHBhcmVudC5pbnNlcnRCZWZvcmUoY29udGV4dEVsZW1lbnQuZmlyc3RDaGlsZCwgY29udGV4dEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChjb250ZXh0RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgc2VsZi5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJhbmdlUmVxdWlyZTogZmFsc2UsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICd2aXNpdC1saW5rJyxcbiAgICAgICAgICAgIGRpcGxheU5hbWU6ICc8aSBjbGFzcz1cImZhcyBmYS1leHRlcm5hbC1saW5rLWFsdCBmYS14c1wiPjwvaT4nLFxuICAgICAgICAgICAgYWxsb3dlZENvbnRleHQ6ICdhJyxcbiAgICAgICAgICAgIG5vdEFsbG93ZWRDb250ZXh0OiBbJ25hdiddLFxuICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbihjb250ZXh0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGlmKG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goJ01vbnN0ZXJXcml0ZXInKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJlZml4ID0gJydcbiAgICAgICAgICAgICAgICAgICAgaWYoIWNvbnRleHRFbGVtZW50LmdldEF0dHJpYnV0ZSgnaHJlZicpLm1hdGNoKC9eaHR0cHM/OlxcL1xcLy9pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4ID0gJ2h0dHBzOi8vJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlcXVpcmUoJ2VsZWN0cm9uJykuc2hlbGwub3BlbkV4dGVybmFsKHByZWZpeCArIGNvbnRleHRFbGVtZW50LmdldEF0dHJpYnV0ZSgnaHJlZicpKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5vcGVuKGNvbnRleHRFbGVtZW50LmdldEF0dHJpYnV0ZSgnaHJlZicpKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAnZWRpdC1mb290bm90ZScsXG4gICAgICAgICAgICByYW5nZVJlcXVpcmU6IGZhbHNlLFxuICAgICAgICAgICAgZGlwbGF5TmFtZTogJzxpIGNsYXNzPVwiZmFzIGZhLWVkaXQgZmEteHNcIj48L2k+JyxcbiAgICAgICAgICAgIGFsbG93ZWRDb250ZXh0OiAnLmZvb3Rub3RlJyxcbiAgICAgICAgICAgIG5vdEFsbG93ZWRDb250ZXh0OiBbJ2NhcHRpb24nXSxcbiAgICAgICAgICAgIGFyZ3VtZW50czogW3tcbiAgICAgICAgICAgICAgICBuYW1lOiAnbm90ZScsXG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICdmb290bm90ZScsXG4gICAgICAgICAgICAgICAgZGlzcGxheU5hbWU6ICdGb290bm90ZScsXG4gICAgICAgICAgICAgICAgbGFyZ2V0ZXh0OiB0cnVlLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZnVuY3Rpb24oY29udGV4dEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoIShjb250ZXh0RWxlbWVudCAmJiBjb250ZXh0RWxlbWVudC5kYXRhc2V0ICYmIGNvbnRleHRFbGVtZW50LmRhdGFzZXQubm90ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1dGlscy5hdHRyaWJ1dGVTYXZlU3RyaW5nVG9TdHJpbmcoKG5ldyBIVE1MUmF6b3IpLnN0cmlwKGNvbnRleHRFbGVtZW50LmRhdGFzZXQubm90ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbihjb250ZXh0RWxlbWVudCwgYXJnVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZighYXJnVmFsdWUubm90ZSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBhcmdWYWx1ZS5ub3RlICE9PSAnc3RyaW5nJykgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmKGFyZ1ZhbHVlLm5vdGUudHJpbSgpID09PSAnJykgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgY29udGV4dEVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLW5vdGUnLCB1dGlscy5zdHJpbmdUb0F0dHJpYnV0ZVNhdmVTdHJpbmcoYXJnVmFsdWUubm90ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICdmb290bm90ZS1jb250ZW50JyxcbiAgICAgICAgICAgIHJhbmdlUmVxdWlyZTogZmFsc2UsXG4gICAgICAgICAgICBkaXBsYXlOYW1lOiBmdW5jdGlvbihjb250ZXh0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0RWxlbWVudC5pbm5lclRleHQgKyAnOiAnICsgdXRpbHMuYXR0cmlidXRlU2F2ZVN0cmluZ1RvSFRNTEVuY29kZWQoY29udGV4dEVsZW1lbnQuZGF0YXNldC5ub3RlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhbGxvd2VkQ29udGV4dDogJy5mb290bm90ZScsXG4gICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkge31cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgcmFuZ2VSZXF1aXJlOiBmYWxzZSxcbiAgICAgICAgICAgIGluc2VydEFjdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2Zvb3Rub3RlJyxcbiAgICAgICAgICAgIGRpcGxheU5hbWU6ICdmbjxzdXA+Kjwvc3VwPicsXG4gICAgICAgICAgICBhbGxvd2VkQ29udGV4dDogWydwJywgJ3RhYmxlJywgJ29sJywgJ3VsJ10sXG4gICAgICAgICAgICBub3RBbGxvd2VkQ29udGV4dDogWydjYXB0aW9uJywgJ25hdiddLFxuICAgICAgICAgICAgYXJndW1lbnRzOiBbe25hbWU6ICdub3RlJywgcGxhY2Vob2xkZXI6ICdmb290bm90ZScsIGRpc3BsYXlOYW1lOiAnRm9vdG5vdGUnLCBsYXJnZXRleHQ6IHRydWV9XSxcbiAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oY29udGV4dEVsZW1lbnQsIGFyZ1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYoIWFyZ1ZhbHVlLm5vdGUpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZih0eXBlb2YgYXJnVmFsdWUubm90ZSAhPT0gJ3N0cmluZycpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZihhcmdWYWx1ZS5ub3RlLnRyaW0oKSA9PT0gJycpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuXG4gICAgICAgICAgICAgICAgbm9kZS5jbGFzc0xpc3QuYWRkKCdmb290bm90ZScpO1xuICAgICAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdkYXRhLW5vdGUnLCB1dGlscy5zdHJpbmdUb0F0dHJpYnV0ZVNhdmVTdHJpbmcoYXJnVmFsdWUubm90ZSkpO1xuICAgICAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgc2VsZi5jYXJldC5pbnNlcnROb2RlKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICByYW5nZVJlcXVpcmU6IGZhbHNlLFxuICAgICAgICAgICAgaW5zZXJ0QWN0aW9uOiB0cnVlLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAncmVmJyxcbiAgICAgICAgICAgIGRpcGxheU5hbWU6ICdyZWYnLFxuICAgICAgICAgICAgYWxsb3dlZENvbnRleHQ6IFsncCcsICd0YWJsZScsICdvbCcsICd1bCcsICdjaXRlc3JjJywgJ2NhcHRpb24nLCAnZmlnY2FwdGlvbiddLFxuICAgICAgICAgICAgbm90QWxsb3dlZENvbnRleHQ6IFsnYScsICdibG9ja3F1b3RlJywgJ2NvZGUnXSxcbiAgICAgICAgICAgIG5vdEZvY3VzRmlyc3RJbnB1dDogdHJ1ZSxcbiAgICAgICAgICAgIGFyZ3VtZW50czogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dlZFZhbHVlczogZnVuY3Rpb24oKSB7IHJldHVybiBzZWxmLmVkaXRvci5yZWZlcmVuY2UuZ2V0VmFsdWVzRm9yQ3Jvc3NSZWZlcmVuY2VTZWxlY3RCb3goKSB9LFxuICAgICAgICAgICAgICAgICAgICBpc0FjdGl2ZTogZnVuY3Rpb24oKSB7IHJldHVybiBzZWxmLmVkaXRvci5yZWZlcmVuY2UuZ2V0VmFsdWVzRm9yQ3Jvc3NSZWZlcmVuY2VTZWxlY3RCb3goKS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2Nyb3NzLXJlZicsXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiAnUmVmZXJlbmNlIGEgcGFydCBvZiB5b3VyIGRvY3VtZW50IChmaWd1cmVzLCB0YWJsZXMsIC4uLik6JyxcbiAgICAgICAgICAgICAgICAgICAgdGFiOiAnQ3Jvc3MtUmVmZXJlbmNlJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbm8tY3Jvc3MtcmVmLWF2YWlsYWJsZS1oaW50JyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJzxkaXYgY2xhc3M9XCJuby1kYXRhLWhpbnRcIj48ZGl2IGNsYXNzPVwibm8tZGF0YS1pY29uXCI+PC9kaXY+PGRpdiBjbGFzcz1cIm5vLWRhdGEtbWVzc2FnZS1oZWFkaW5nXCI+Tm8gQ3Jvc3MtUmVmZXJlbmNlcyBBdmFpbGFibGUhPC9kaXY+PGRpdiBjbGFzcz1cIm5vLWRhdGEtbWVzc2FnZVwiPk9uY2UgeW91IGhhdmUgaW5zZXJ0ZWQgYSBoZWFkaW5nLCB0YWJsZSwgaW1hZ2UsIGV0Yy4gaW50byB5b3VyIGRvY3VtZW50LCB5b3Ugd2lsbCBiZSBhYmxlIHRvIHJlZmVyZW5jZS9zZWxlY3QgaXQgaGVyZS48L2Rpdj48L2Rpdj4nLFxuICAgICAgICAgICAgICAgICAgICBpc0FjdGl2ZTogZnVuY3Rpb24oKSB7IHJldHVybiAhc2VsZi5lZGl0b3IucmVmZXJlbmNlLmdldFZhbHVlc0ZvckNyb3NzUmVmZXJlbmNlU2VsZWN0Qm94KCkubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgICAgIHRhYjogJ0Nyb3NzLVJlZmVyZW5jZSdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmVsb2FkT25DaGFuZ2VPZjogWydmZXRjaC1yZWYtYnRuJywgJ21hbmFnZS1yZWYtYnRuJ10sXG4gICAgICAgICAgICAgICAgICAgIGFsbG93ZWRWYWx1ZXM6IGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VsZi5lZGl0b3IucmVmZXJlbmNlLmdldFZhbHVlc0ZvckV4aXN0aW5nUmVmZXJlbmNlU2VsZWN0Qm94KCkgfSxcbiAgICAgICAgICAgICAgICAgICAgaXNBY3RpdmU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VsZi5lZGl0b3IucmVmZXJlbmNlLmFyZUV4aXN0aW5nUmVmZXJlbmNlc0F2YWlsYWJsZSgpIH0sXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdleGlzdGluZy1yZWYnLFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZTogJ1JlZmVyZW5jZSB3b3JrIHlvdVxcJ3ZlIHJlZmVyZW5jZWQgYmVmb3JlOicsXG4gICAgICAgICAgICAgICAgICAgIHRhYjogJ0ZpbmQgUmVmZXJlbmNlJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbm8tZXhpc3RpbmctcmVmZXJlbmNlLWF2YWlsYWJsZS1oaW50JyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJzxkaXYgY2xhc3M9XCJuby1kYXRhLWhpbnRcIj48ZGl2IGNsYXNzPVwibm8tZGF0YS1pY29uXCI+PC9kaXY+PGRpdiBjbGFzcz1cIm5vLWRhdGEtbWVzc2FnZS1oZWFkaW5nXCI+Tm8gUmVmZXJlbmNlcyBBdmFpbGFibGUhPC9kaXY+PGRpdiBjbGFzcz1cIm5vLWRhdGEtbWVzc2FnZVwiPlNlbGVjdCB0aGUgdGFiIFwiQWRkIFJlZmVyZW5jZVwiIHRvIGluc2VydCBhIG5ldyByZWZlcmVuY2UuIFRoZSBuZXh0IHRpbWUgeW91IHdhbnQgdG8gcmVmZXJlbmNlIHRoZSBzYW1lIHdvcmssIGl0IHdpbGwgc2hvdyB1cCBoZXJlLjwvZGl2PjwvZGl2PicsXG4gICAgICAgICAgICAgICAgICAgIGlzQWN0aXZlOiBmdW5jdGlvbigpIHsgcmV0dXJuICFzZWxmLmVkaXRvci5yZWZlcmVuY2UuYXJlRXhpc3RpbmdSZWZlcmVuY2VzQXZhaWxhYmxlKCkgfSxcbiAgICAgICAgICAgICAgICAgICAgdGFiOiAnRmluZCBSZWZlcmVuY2UnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdmZXRjaC1yZWYtYnRuJyxcbiAgICAgICAgICAgICAgICAgICAgaXNBY3RpdmU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VsZi5lZGl0b3IucmVmZXJlbmNlLmFyZUV4aXN0aW5nUmVmZXJlbmNlc0F2YWlsYWJsZSgpIH0sXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24oZG9tLCBmb3JtRGF0YSwgZGxGcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb20uaW5uZXJIVE1MID0gJydcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFkZFJlZlNyY0J0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkUmVmU3JjQnRuLmNsYXNzTGlzdC5hZGQoJ2ZldGNoLWV4dGVybmFsLXJlZi1idG4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFJlZlNyY0J0bi5pbm5lckhUTUwgPSAnRmV0Y2ggTmV3ZXN0IERhdGEgRnJvbSBSZWZlcmVuY2UgU291cmNlcyc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFJlZlNyY0J0bi5vbmNsaWNrID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYWRkUmVmU3JjQnRuLmNsYXNzTGlzdC5jb250YWlucygnZmV0Y2gtZXh0ZXJuYWwtcmVmLWJ0bi1sb2FkaW5nJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4dFJlZkZpZWxkID0gZGxGcm9tLmZpZWxkcy5maW5kKGZpZWxkID0+IGZpZWxkLm5hbWUgPT09ICdleGlzdGluZy1yZWYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRSZWZGaWVsZC5kb21FbGVtZW50LnNldExvYWRpbmdTdGF0dXMoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFJlZlNyY0J0bi5jbGFzc0xpc3QuYWRkKCdmZXRjaC1leHRlcm5hbC1yZWYtYnRuLWxvYWRpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBzeW5jQWxsU291cmNlcyhzZWxmLmVkaXRvci5yZWZlcmVuY2Uuc3RvcmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHNlbGYuZWRpdG9yLnJlZmVyZW5jZS5zdG9yZS5pbml0Q2FjaGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBzZWxmLmVkaXRvci5yZWZlcmVuY2Uuc3RvcmUuY2xlYW51cFJlZmVyZW5jZXNGcm9tU291cmNlcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgMTAwMCkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0UmVmRmllbGQuZG9tRWxlbWVudC5zZXRMb2FkaW5nU3RhdHVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkUmVmU3JjQnRuLmNsYXNzTGlzdC5yZW1vdmUoJ2ZldGNoLWV4dGVybmFsLXJlZi1idG4tbG9hZGluZycpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tLm9uQ2hhbmdlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBkb20uYXBwZW5kQ2hpbGQoYWRkUmVmU3JjQnRuKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdGFiOiAnRmluZCBSZWZlcmVuY2UnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbWFuYWdlLXJlZi1idG4nLFxuICAgICAgICAgICAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uKGRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tLmlubmVySFRNTCA9ICcnXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhZGRSZWZTcmNCdG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFJlZlNyY0J0bi5jbGFzc0xpc3QuYWRkKCdhZGQtZXh0ZXJuYWwtcmVmLWJ0bicpXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRSZWZTcmNCdG4uaW5uZXJIVE1MID0gJ01hbmFnZSBSZWZlcmVuY2UgU291cmNlcyAoWm90ZXJvKSdcblxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkUmVmU3JjQnRuLm9uY2xpY2sgPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWZlcmVuY2VTb3VyY2VzRmllbGRzID0gYXdhaXQgZ2V0UmVmZXJlbmNlU291cmNlc0ZpZWxkcyhzZWxmLmVkaXRvci5yZWZlcmVuY2Uuc3RvcmUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29uZmlnRm9ybSA9IG5ldyBEZWNsYXJhdGl2Rm9ybShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBmaWVsZHM6IFsuLi5yZWZlcmVuY2VTb3VyY2VzRmllbGRzXSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKSA9PiB7IGRvbS5vbkNoYW5nZSh0cnVlKSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKSA9PiB7IGRvbS5vbkNoYW5nZSh0cnVlKSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQmFjayB0byBSZWZlcmVuY2VzJylcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ0Zvcm0ub3BlbkluTW9kYWwoKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBkb20uYXBwZW5kQ2hpbGQoYWRkUmVmU3JjQnRuKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdGFiOiAnRmluZCBSZWZlcmVuY2UnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLi4uKCFzZWxmLmVkaXRvci5yZWZlcmVuY2UgPyBbXSA6IHNlbGYuZWRpdG9yLnJlZmVyZW5jZS5nZXRFeHRlcm5hbFJlZkRpYWxvZ0F0dHJpYnV0ZXMoKS5tYXAoZmllbGQgPT4gT2JqZWN0LmFzc2lnbihmaWVsZCwgeyB0YWI6ICdBZGQgUmVmZXJlbmNlJyB9KSkpXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbihjb250ZXh0RWxlbWVudCwgZm9ybURhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVmID0gZm9ybURhdGEgJiYgKGZvcm1EYXRhWydjcm9zcy1yZWYnXSB8fCBmb3JtRGF0YVsnZXhpc3RpbmctcmVmJ10pO1xuICAgICAgICAgICAgICAgIGlmKGZvcm1EYXRhLmFjdGl2ZVRhYiA9PT0gJ0FkZCBSZWZlcmVuY2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZWRpdG9yLnJlZmVyZW5jZS5pbnNlcnRFeHRlcm5hbFJlZmVyZW5jZShmb3JtRGF0YSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKHJlZikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmVkaXRvci5yZWZlcmVuY2UuaW5zZXJ0SW50ZXJuYWxSZWZlcmVuY2Uoe3JlZjogcmVmfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICByYW5nZVJlcXVpcmU6IGZhbHNlLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAnZWRpdC1yZWYnLFxuICAgICAgICAgICAgZGlwbGF5TmFtZTogJzxpIGNsYXNzPVwiZmFzIGZhLWVkaXQgZmEteHNcIj48L2k+JyxcbiAgICAgICAgICAgIGFsbG93ZWRDb250ZXh0OiAnLnJlZmVyZW5jZScsXG4gICAgICAgICAgICBzaG91bGRCZURpc3BsYXllZDogZnVuY3Rpb24oY29udGV4dEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWV4dGVybmFsJykgPT09ICd0cnVlJztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKGNvbnRleHRFbGVtZW50LCBmb3JtRGF0YSkge1xuICAgICAgICAgICAgICAgIHNlbGYuZWRpdG9yLnJlZmVyZW5jZS5zaG93RWRpdEV4dGVybmFsUmVmRGlhbG9nKGNvbnRleHRFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAncmVmZXJlbmNlLWNhcHRpb24nLFxuICAgICAgICAgICAgcmFuZ2VSZXF1aXJlOiBmYWxzZSxcbiAgICAgICAgICAgIGRpcGxheU5hbWU6IGZ1bmN0aW9uKGNvbnRleHRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhcHRpb24gPSBzZWxmLmVkaXRvci5yZWZlcmVuY2UuZ2V0UmVmQ2FwdGlvbkhUTUwoY29udGV4dEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGNhcHRpb24gPSBjYXB0aW9uLnJlcGxhY2UoL1xcPGJcXD4vZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFw8XFwvYlxcPi9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXDwvZywgJyZsdDsnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcPi9nLCAnJmd0OycpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXB0aW9uO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNob3VsZEJlRGlzcGxheWVkOiBmdW5jdGlvbihjb250ZXh0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBjYXB0aW9uID0gc2VsZi5lZGl0b3IucmVmZXJlbmNlLmdldFJlZkNhcHRpb25IVE1MKGNvbnRleHRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FwdGlvbiAmJiBjYXB0aW9uLmxlbmd0aCAhPT0gMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFsbG93ZWRDb250ZXh0OiAnLnJlZmVyZW5jZScsXG4gICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkge31cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgcmFuZ2VSZXF1aXJlOiBmYWxzZSxcbiAgICAgICAgICAgIGluc2VydEFjdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2lubGluZWVxdWF0aW9uJyxcbiAgICAgICAgICAgIGRpcGxheU5hbWU6ICcmcmFkaWM7JyxcbiAgICAgICAgICAgIGFsbG93ZWRDb250ZXh0OiBbJ3AnLCAndGFibGUnLCAnb2wnLCAndWwnLCAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnY2FwdGlvbicsICdmaWdjYXB0aW9uJywgJ2NpdGVzcmMnXSxcbiAgICAgICAgICAgIG5vdEFsbG93ZWRDb250ZXh0OiBbJ25hdicsICdhJywgJ2lubGluZWNvZGUnLCAnY29kZSddLFxuICAgICAgICAgICAgYXJndW1lbnRzOiBbXG4gICAgICAgICAgICAgICAge25hbWU6ICdsYXRleGVxdWF0aW9uJywgcGxhY2Vob2xkZXI6ICdMYVRlWCBFcXVhdGlvbicsIGRpc3BsYXlOYW1lOiAnTGFUZVggRXF1YXRpb24nLCB0b29sdGlwOiBsYXRleENoZWF0c2hlZXR9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheU5hbWU6ICdQcmV2aWV3JyxcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcDogJ0l0IHNob3dzIHlvdSBob3cgdGhlIExhVGVYIGVxdWF0aW9uIHdpbGwgYmUgcmVuZGVyZWQnLFxuICAgICAgICAgICAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uKGVsZW1lbnQsIGZvcm1EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihmb3JtRGF0YSAmJiBmb3JtRGF0YS5sYXRleGVxdWF0aW9uICYmIGZvcm1EYXRhLmxhdGV4ZXF1YXRpb24udHJpbSgpICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGthdGV4LnJlbmRlcihmb3JtRGF0YS5sYXRleGVxdWF0aW9uLCBlbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd09uRXJyb3I6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5TW9kZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSAnPHNwYW4gY2xhc3M9XCJlcnJvclwiPmludmFsaWQgTGFUZVggZXF1YXRpb248L3NwYW4+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJ0luc2VydCBhIExhVGVYIGluIHRoZSBpbnB1dCBmaWVsZCBhYm92ZSB0byBzZWUgdGhlIGVxdWF0aW9uIGhlcmUuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKGNvbnRleHRFbGVtZW50LCBhcmdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmKCFhcmdWYWx1ZS5sYXRleGVxdWF0aW9uKSByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYodHlwZW9mIGFyZ1ZhbHVlLmxhdGV4ZXF1YXRpb24gIT09ICdzdHJpbmcnKSByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYoYXJnVmFsdWUubGF0ZXhlcXVhdGlvbi50cmltKCkgPT09ICcnKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICB2YXIgZXEgPSB1dGlscy5zdHJpbmdUb0F0dHJpYnV0ZVNhdmVTdHJpbmcoYXJnVmFsdWUubGF0ZXhlcXVhdGlvbilcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lubGluZWVxdWF0aW9uJyk7XG5cbiAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnZGF0YS1sYXRleGVxdWF0aW9uJywgZXEpO1xuICAgICAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICBzZWxmLmNhcmV0Lmluc2VydE5vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgc2VsZi5jYXJldC5pbnNlcnROb2RlKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcgJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICdlZGl0LWlubGluZWVxdWF0aW9uJyxcbiAgICAgICAgICAgIHJhbmdlUmVxdWlyZTogZmFsc2UsXG4gICAgICAgICAgICBkaXBsYXlOYW1lOiAnPGkgY2xhc3M9XCJmYXMgZmEtZWRpdCBmYS14c1wiPjwvaT4nLFxuICAgICAgICAgICAgYWxsb3dlZENvbnRleHQ6ICdpbmxpbmVlcXVhdGlvbicsXG4gICAgICAgICAgICBub3RBbGxvd2VkQ29udGV4dDogW10sXG4gICAgICAgICAgICBhcmd1bWVudHM6IFt7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2xhdGV4ZXF1YXRpb24nLFxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiAnTGFUZVggRXF1YXRpb24nLFxuICAgICAgICAgICAgICAgIHRvb2x0aXA6IGxhdGV4Q2hlYXRzaGVldCxcbiAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZTogJ0xhVGVYIEVxdWF0aW9uJyxcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IGZ1bmN0aW9uKGNvbnRleHRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKCEoY29udGV4dEVsZW1lbnQgJiYgY29udGV4dEVsZW1lbnQuZGF0YXNldCAmJiBjb250ZXh0RWxlbWVudC5kYXRhc2V0LmxhdGV4ZXF1YXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXRpbHMuYXR0cmlidXRlU2F2ZVN0cmluZ1RvU3RyaW5nKGNvbnRleHRFbGVtZW50LmRhdGFzZXQubGF0ZXhlcXVhdGlvbik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZGlzcGxheU5hbWU6ICdQcmV2aWV3OicsXG4gICAgICAgICAgICAgICAgdG9vbHRpcDogJ0l0IHNob3dzIHlvdSBob3cgdGhlIExhVGVYIGVxdWF0aW9uIHdpbGwgYmUgcmVuZGVyZWQnLFxuICAgICAgICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24oZWxlbWVudCwgZm9ybURhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoZm9ybURhdGEgJiYgZm9ybURhdGEubGF0ZXhlcXVhdGlvbiAmJiBmb3JtRGF0YS5sYXRleGVxdWF0aW9uLnRyaW0oKSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2F0ZXgucmVuZGVyKGZvcm1EYXRhLmxhdGV4ZXF1YXRpb24sIGVsZW1lbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dPbkVycm9yOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5TW9kZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSAnPHNwYW4gY2xhc3M9XCJlcnJvclwiPmludmFsaWQgTGFUZVggZXF1YXRpb248L3NwYW4+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbihjb250ZXh0RWxlbWVudCwgYXJnVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZighYXJnVmFsdWUubGF0ZXhlcXVhdGlvbikgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBhcmdWYWx1ZS5sYXRleGVxdWF0aW9uICE9PSAnc3RyaW5nJykgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmKGFyZ1ZhbHVlLmxhdGV4ZXF1YXRpb24udHJpbSgpID09PSAnJykgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgdmFyIHNlY3Rpb24gPSBzZWxmLmVkaXRvci5mb2N1c2VkU2VjdGlvbigpO1xuICAgICAgICAgICAgICAgIGNvbnRleHRFbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1sYXRleGVxdWF0aW9uJywgdXRpbHMuc3RyaW5nVG9BdHRyaWJ1dGVTYXZlU3RyaW5nKGFyZ1ZhbHVlLmxhdGV4ZXF1YXRpb24pKTtcbiAgICAgICAgICAgICAgICBzZWxmLmVkaXRvci5yZXBsYWNlU2VjdGlvbldpdGhIVE1MKHNlY3Rpb24sIHNlY3Rpb24ub3V0ZXJIVE1MKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAnaW5saW5lZXF1YXRpb24tY29udGVudCcsXG4gICAgICAgICAgICByYW5nZVJlcXVpcmU6IGZhbHNlLFxuICAgICAgICAgICAgZGlwbGF5TmFtZTogZnVuY3Rpb24oY29udGV4dEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbHMuYXR0cmlidXRlU2F2ZVN0cmluZ1RvSFRNTEVuY29kZWQoY29udGV4dEVsZW1lbnQuZGF0YXNldC5sYXRleGVxdWF0aW9uKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhbGxvd2VkQ29udGV4dDogJ2lubGluZWVxdWF0aW9uJyxcbiAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7fVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICByYW5nZVJlcXVpcmU6IHRydWUsXG4gICAgICAgICAgICBpbnNlcnRBY3Rpb246IGZhbHNlLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAnZW5yaWNobWVudC1pbmZvJyxcbiAgICAgICAgICAgIGFsbG93ZWRDb250ZXh0OiAnJyxcbiAgICAgICAgICAgIGRpcGxheU5hbWU6IGZ1bmN0aW9uKGNvbnRleHRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB2YXIgd29yZENvdW50ID0gdGV4dC5zcGxpdCgvW1xcc1xcLjpcXD9cXCEnXS8pXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIodyA9PiB3LnRyaW0oKS5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgICAgICAubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBjaGFyQ291bnQgPSB0ZXh0Lmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIHJldHVybiBgJHt3b3JkQ291bnR9IC8gJHtjaGFyQ291bnR9YDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkge31cbiAgICAgICAgfSxcbiAgICBdO1xuXG4gICAgdGhpcy5jYXJldC5zdWJzY3JpYmVTZWxlY3Rpb25DaGFuZ2UoZnVuY3Rpb24oc2VsZWN0aW9uKSB7XG4gICAgICAgIHZhciBlbnJpY2htZW50cyA9IHNlbGYuZ2V0TWVhbmluZ2Z1bEVucmljaG1lbnRzKCk7XG5cbiAgICAgICAgZW5yaWNobWVudHMubGVuZ3RoICE9PSAwID9cbiAgICAgICAgICAgIHNlbGYuc2hvdyhmYWxzZSwgZW5yaWNobWVudHMpIDpcbiAgICAgICAgICAgIHNlbGYuaGlkZSgpO1xuICAgIH0pXG59XG5cblRleHRFbnJpY2htZW50Q29udHJvbC5wcm90b3R5cGUgPSB7XG5cbiAgICBpc1Zpc2libGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpYmxlO1xuICAgIH0sXG5cbiAgICBhZGRFbnJpY2htZW50czogZnVuY3Rpb24oZW5yaWNobWVudHMpIHtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGhpcy5lbnJpY2htZW50cywgZW5yaWNobWVudHMpO1xuICAgIH0sXG5cbiAgICBoaWRlOiBmdW5jdGlvbihmb3JjZSkge1xuICAgICAgICBpZihmb3JjZSB8fCAhdGhpcy5wcmV2ZW50RW5yaWNobWVudENvbnRyb2xsVG9CZUhpZGRlbikge1xuICAgICAgICAgICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB0aGlzLmRvbUVsZW1lbnQuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgICAgICB0aGlzLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzaG93OiBmdW5jdGlvbihpc0luc2VydEJ0blByZXNzZWQsIGVucmljaG1lbnRzKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIGVsID0gdGhpcy5kb21FbGVtZW50LFxuICAgICAgICAgICAgdG1wQnRuLCBzZWN0aW9uO1xuXG4gICAgICAgIGVucmljaG1lbnRzID0gZW5yaWNobWVudHMgfHwgdGhpcy5nZXRNZWFuaW5nZnVsRW5yaWNobWVudHMoaXNJbnNlcnRCdG5QcmVzc2VkKTtcblxuICAgICAgICBpZihlbnJpY2htZW50cy5sZW5ndGggPT09IDAgJiYgIWlzSW5zZXJ0QnRuUHJlc3NlZCkgcmV0dXJuO1xuXG4gICAgICAgIGlmKGVucmljaG1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZW5yaWNobWVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgZGlwbGF5TmFtZTogJ05vdGhpbmcgdG8gZG8gaGVyZSEnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2VucmljaG1lbnQtaW5mbycsXG4gICAgICAgICAgICAgICAgYWxsb3dlZENvbnRleHQ6ICcnLFxuICAgICAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBkaXBsYXlOYW1lOiAnPGkgY2xhc3M9XCJmYXMgZmEtaW5mbyBmYS14c1wiPjwvaT4nLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2VucmljaG1lbnQtbW9yZS1pbmZvLWJ0bicsXG4gICAgICAgICAgICAgICAgYWxsb3dlZENvbnRleHQ6ICdib2R5JyxcbiAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFt7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdTb21lIHBhcnRzIG9mIHRoZSBkb2N1bWVudCAobGlrZSBoZWFkaW5ncykgZG9uXFwndCBhbGxvdyB0byBpbnNlcnQgZm9vdG5vdGVzIG9yIHJlZmVyZW5jZXMgYXMgdGhleSBtaWdodCBub3QgbWFrZSBtdWNoIHNlbmNlIHRoZXJlLjxici8+PGJyLz5QbGVhc2UgZ2l2ZSB1cyBzb21lIDxhIGhyZWY9XCJtYWlsdG86aW5mb0Btb25zdGVyd3JpdGVyLmFwcD9zdWJqZWN0PUZlZWRiYWNrXCI+ZmVlZGJhY2s8L2E+IGlmIHlvdSBoYXZlIGFuIHVzZSBjYXNlIHdoaWNoIHJlcXVpcmVzIHRoaXMgdG8gYmUgY2hhbmdlZC4gPGJyLz48YnIvPkJUVy4gd2Ugd291bGQgJiN4MUY0OTY7dG8gaGVhciBob3cgeW91IGxpa2UgTW9uc3RlcldyaXRlciBpbiBnZW5lcmFsISdcbiAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkge31cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZWwuaW5uZXJIVE1MID0gJzxzcGFuIGNsYXNzPVwidGV4dEVucmljaG1lbnRDb250cm9sQXJyb3dcIj48L3NwYW4+JztcbiAgICAgICAgZW5yaWNobWVudHMuZm9yRWFjaChmdW5jdGlvbihlbnJpY2htZW50KSB7XG5cbiAgICAgICAgICAgIHRtcEJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIHRtcEJ0bi5jbGFzc05hbWUgPSBlbnJpY2htZW50LmNsYXNzTmFtZTtcblxuICAgICAgICAgICAgdG1wQnRuLmlubmVySFRNTCA9ICAodHlwZW9mIGVucmljaG1lbnQuZGlwbGF5TmFtZSA9PT0gJ2Z1bmN0aW9uJykgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5yaWNobWVudC5kaXBsYXlOYW1lKGVucmljaG1lbnQuY29udGV4dEVsZW1lbnQpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVucmljaG1lbnQuZGlwbGF5TmFtZTtcblxuICAgICAgICAgICAgdG1wQnRuLm9ubW91c2Vkb3duID0gZnVuY3Rpb24gKGUpIHtcblxuICAgICAgICAgICAgICAgIGlmKCFlbnJpY2htZW50LmFyZ3VtZW50cyAmJiBlbnJpY2htZW50LmNvbW1hbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoZW5yaWNobWVudC5jb21tYW5kKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoIWVucmljaG1lbnQuYXJndW1lbnRzICYmIGVucmljaG1lbnQuYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGVucmljaG1lbnQuYWN0aW9uKHNlbGYuY2FyZXQuZ2V0Q29udGV4dEVsZW1lbnQoZW5yaWNobWVudC5hbGxvd2VkQ29udGV4dCksIHVuZGVmaW5lZCwgc2VsZik7XG4gICAgICAgICAgICAgICAgICAgIHNlY3Rpb24gPSBzZWxmLmVkaXRvci5mb2N1c2VkU2VjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmVkaXRvci5yZXBsYWNlU2VjdGlvbldpdGhIVE1MKHNlY3Rpb24sIHNlY3Rpb24ub3V0ZXJIVE1MKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoZW5yaWNobWVudC5hcmd1bWVudHMubGVuZ3RoID09PSAxICYmIGVucmljaG1lbnQuYXJndW1lbnRzWzBdLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmRpc3BsYXlTaW5nbGVBcmd1bWVudFRleHRJbnB1dChlbnJpY2htZW50KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmRpc3BsYXlBcmd1bWVudElucHV0KGVucmljaG1lbnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG1wQnRuLm9uY2xpY2sgPSB0bXBCdG4ub25tb3VzZXVwID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgICAgICAgICBlbC5hcHBlbmRDaGlsZCh0bXBCdG4pO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIH0sXG5cbiAgICB1cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjYXJldFBvcyA9IHRoaXMuY2FyZXQuZ2V0UG9zaXRpb24oKSxcbiAgICAgICAgICAgIGVsID0gdGhpcy5kb21FbGVtZW50LFxuICAgICAgICAgICAgeE9mZnNldCA9IChjYXJldFBvcy53aWR0aCA+IDExID8gMCA6IC0xMSksXG4gICAgICAgICAgICBvcmlnaW5hbERpc3BsYXkgPSBlbC5zdHlsZS5kaXNwbGF5O1xuXG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGVsLnN0eWxlLmxlZnQgPSAoY2FyZXRQb3MueCArIHhPZmZzZXQpICsgJ3B4JztcbiAgICAgICAgZWwuc3R5bGUudG9wID0gKGNhcmV0UG9zLnkgLSAzMikgKyAncHgnO1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gb3JpZ2luYWxEaXNwbGF5O1xuICAgIH0sXG5cbiAgICB1cGRhdGVQb3NpdGlvbklmVmlzaWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmKHRoaXMudmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVQb3NpdGlvbigpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGRpc3BsYXlBcmd1bWVudElucHV0OiBmdW5jdGlvbihlbnJpY2htZW50KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcywgc2VjdGlvbjtcblxuICAgICAgICB2YXIgYXJncyA9IGVucmljaG1lbnQuYXJndW1lbnRzLm1hcChmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgIGlmKHR5cGVvZiBhcmcuZGVmYXVsdFZhbHVlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG5ld0FyZyA9IHt9O1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihuZXdBcmcsIGFyZyk7XG4gICAgICAgICAgICBuZXdBcmcuZGVmYXVsdFZhbHVlID0gYXJnLmRlZmF1bHRWYWx1ZShlbnJpY2htZW50LmNvbnRleHRFbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybiBuZXdBcmc7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNlbGYuZWRpdG9yLmRpc3BsYXlNb2RhbChhcmdzLCBmdW5jdGlvbihmb3JtRGF0YSkge1xuICAgICAgICAgICAgc2VsZi5lZGl0b3IudW5mcmVlemVTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHNlbGYuaGlkZSgpO1xuXG4gICAgICAgICAgICBlbnJpY2htZW50LmFjdGlvbihzZWxmLmNhcmV0LmdldENvbnRleHRFbGVtZW50KGVucmljaG1lbnQuYWxsb3dlZENvbnRleHQpLCBmb3JtRGF0YSwgc2VsZik7XG4gICAgICAgICAgICBzZWN0aW9uID0gc2VsZi5lZGl0b3IuZm9jdXNlZFNlY3Rpb24oKTtcbiAgICAgICAgICAgIHNlbGYuZWRpdG9yLnJlcGxhY2VTZWN0aW9uV2l0aEhUTUwoc2VjdGlvbiwgc2VjdGlvbi5vdXRlckhUTUwpO1xuICAgICAgICB9LCBlbnJpY2htZW50Lm5vdEZvY3VzRmlyc3RJbnB1dCk7XG4gICAgfSxcblxuICAgIGRpc3BsYXlTaW5nbGVBcmd1bWVudFRleHRJbnB1dDogZnVuY3Rpb24oZW5yaWNobWVudCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBhcmd1bWVudCA9IGVucmljaG1lbnQuYXJndW1lbnRzWzBdLFxuICAgICAgICAgICAgZWwgPSB0aGlzLmRvbUVsZW1lbnQsXG4gICAgICAgICAgICBhdHRySW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpLFxuICAgICAgICAgICAgb2tCdG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyksXG4gICAgICAgICAgICBjYWNoZWRDb250ZXh0RWxlbWVudCA9IGVucmljaG1lbnQuY29udGV4dEVsZW1lbnQsXG4gICAgICAgICAgICBzZWN0aW9uO1xuXG4gICAgICAgIGF0dHJJbnB1dC5wbGFjZWhvbGRlciA9IGFyZ3VtZW50LnBsYWNlaG9sZGVyO1xuICAgICAgICBva0J0bi5pbm5lckhUTUwgPSAnT0snO1xuICAgICAgICBva0J0bi5jbGFzc05hbWUgPSAnY29uZmlybUxpbmsnO1xuXG4gICAgICAgIGlmKHR5cGVvZiBhcmd1bWVudC52YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgYXR0cklucHV0LnZhbHVlID0gYXJndW1lbnQudmFsdWUoY2FjaGVkQ29udGV4dEVsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXR0cklucHV0LnZhbHVlID0gYXJndW1lbnQudmFsdWUgfHwgJyc7XG4gICAgICAgIH1cblxuICAgICAgICBhdHRySW5wdXQub25tb3VzZWRvd24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vc2ltdWxhdGUgdGhlIHRleHQgZm9jdXMsIGJlY2F1c2UgaXQgc2hvdWxkIHN0aWxsIGJlIHZpc2libGUgd2hhdFxuICAgICAgICAgICAgLy90ZXh0IGlzIHNsZWN0ZWQgZXZlbiB3aGVuIHRoZSBmb3VjcyBjaGFuZ2VzIHRvIHRoZSBpbnB1dCBmaWVsZFxuICAgICAgICAgICAgc2VsZi5lZGl0b3IuZnJlZXplU2VsZWN0aW9uKHtcbiAgICAgICAgICAgICAgICAndW5mcmVlemVPbkNsaWNrc091dHNpdGVPZic6IGVsLFxuICAgICAgICAgICAgICAgICd1bmZyZWV6ZUNhbGxiYWNrJzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucHJldmVudEVucmljaG1lbnRDb250cm9sbFRvQmVIaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5oaWRlKClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxmLnByZXZlbnRFbnJpY2htZW50Q29udHJvbGxUb0JlSGlkZGVuID0gdHJ1ZTtcblxuICAgICAgICAgICAgYXR0cklucHV0LmZvY3VzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBva0J0bi5vbm1vdXNlZG93biA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5lZGl0b3IudW5mcmVlemVTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGlmKGVucmljaG1lbnQuY29tbWFuZCkge1xuICAgICAgICAgICAgICAgIGlmKCFkb2N1bWVudC5leGVjQ29tbWFuZChlbnJpY2htZW50LmNvbW1hbmQsIGZhbHNlLCBhdHRySW5wdXQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5nZXRSYW5nZUF0KDApLmNvbGxhcHNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmKGVucmljaG1lbnQuYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJWYWx1ZSA9IHt9O1xuICAgICAgICAgICAgICAgIGF0dHJWYWx1ZVthcmd1bWVudC5uYW1lXSA9IGF0dHJJbnB1dC52YWx1ZTtcbiAgICAgICAgICAgICAgICBlbnJpY2htZW50LmFjdGlvbihzZWxmLmNhcmV0LmdldENvbnRleHRFbGVtZW50KGVucmljaG1lbnQuYWxsb3dlZENvbnRleHQpLCBhdHRyVmFsdWUsIHNlbGYpO1xuICAgICAgICAgICAgICAgIHNlY3Rpb24gPSBzZWxmLmVkaXRvci5mb2N1c2VkU2VjdGlvbigpO1xuICAgICAgICAgICAgICAgIHNlbGYuZWRpdG9yLnJlcGxhY2VTZWN0aW9uV2l0aEhUTUwoc2VjdGlvbiwgc2VjdGlvbi5vdXRlckhUTUwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLmhpZGUoKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF0dHJJbnB1dC5vbmtleWRvd24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZihlLmtleUNvZGUgPT09IDEzKSB7IC8vIEVudGVyXG4gICAgICAgICAgICAgICAgb2tCdG4ub25tb3VzZWRvd24oKTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBlbC5pbm5lckhUTUwgPSAnPHNwYW4gY2xhc3M9XCJ0ZXh0RW5yaWNobWVudENvbnRyb2xBcnJvd1wiPjwvc3Bhbj4nO1xuICAgICAgICBlbC5hcHBlbmRDaGlsZChhdHRySW5wdXQpO1xuICAgICAgICBlbC5hcHBlbmRDaGlsZChva0J0bik7XG5cbiAgICAgICAgYXR0cklucHV0Lm9ubW91c2Vkb3duKCk7XG4gICAgfSxcblxuICAgIGdldE1lYW5pbmdmdWxFbnJpY2htZW50czogZnVuY3Rpb24oaXNJbnNlcnRCdG5QcmVzc2VkLCBzZWxlY3Rpb24pIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgdGFuZ2VudE5vZGVzID0gc2VsZi5jYXJldC5nZXRUYW5nZXROb2RlcygpO1xuXG4gICAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbiB8fCB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgICAgdmFyIGNvbGxhcHNlZE1hdGNoID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYodHlwZW9mIGUucmFuZ2VSZXF1aXJlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGUucmFuZ2VSZXF1aXJlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICFlLnJhbmdlUmVxdWlyZSB8fCAhc2VsZWN0aW9uLmlzQ29sbGFwc2VkID09PSBlLnJhbmdlUmVxdWlyZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb250ZXh0TWF0Y2ggPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZighZS5hbGxvd2VkQ29udGV4dCkgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgIGlmKGUubm90QWxsb3dlZENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBpZihzZWxmLmNhcmV0LmdldENvbnRleHRFbGVtZW50KGUubm90QWxsb3dlZENvbnRleHQsIHNlbGVjdGlvbiwgdGFuZ2VudE5vZGVzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlLmNvbnRleHRFbGVtZW50ID0gc2VsZi5jYXJldC5nZXRDb250ZXh0RWxlbWVudChlLmFsbG93ZWRDb250ZXh0LCBzZWxlY3Rpb24sIHRhbmdlbnROb2Rlcyk7XG4gICAgICAgICAgICByZXR1cm4gISFlLmNvbnRleHRFbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluc2VydEFjdGlvbk1hdGNoID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYoaXNJbnNlcnRCdG5QcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGlvbi5pc0NvbGxhcHNlZCAmJiBlLmluc2VydEFjdGlvbiA9PT0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUuaW5zZXJ0QWN0aW9uICE9PSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVucmljaG1lbnRNYXRjaCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmKCFlLnNob3VsZEJlRGlzcGxheWVkKSB7IHJldHVybiB0cnVlIH1cblxuICAgICAgICAgICAgcmV0dXJuIGUuc2hvdWxkQmVEaXNwbGF5ZWQoc2VsZi5jYXJldC5nZXRDb250ZXh0RWxlbWVudChlLmFsbG93ZWRDb250ZXh0LCBzZWxlY3Rpb24sIHRhbmdlbnROb2RlcykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZW5yaWNobWVudHMuZmlsdGVyKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xsYXBzZWRNYXRjaChlKSAmJlxuICAgICAgICAgICAgICAgICAgIGNvbnRleHRNYXRjaChlKSAmJlxuICAgICAgICAgICAgICAgICAgIGluc2VydEFjdGlvbk1hdGNoKGUpICYmXG4gICAgICAgICAgICAgICAgICAgZW5yaWNobWVudE1hdGNoKGUpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVGV4dEVucmljaG1lbnRDb250cm9sO1xuIiwidmFyIENoYW5nZXNldCA9IHJlcXVpcmUoJy4vQ2hhbmdlc2V0JylcbiAgLCBSZXRhaW4gPSByZXF1aXJlKCcuL29wZXJhdGlvbnMvUmV0YWluJylcbiAgLCBTa2lwID0gcmVxdWlyZSgnLi9vcGVyYXRpb25zL1NraXAnKVxuICAsIEluc2VydCA9IHJlcXVpcmUoJy4vb3BlcmF0aW9ucy9JbnNlcnQnKVxuXG5mdW5jdGlvbiBCdWlsZGVyKCkge1xuICB0aGlzLm9wcyA9IFtdXG4gIHRoaXMuYWRkZW5kdW0gPSAnJ1xuICB0aGlzLnJlbW92ZW5kdW0gPSAnJ1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1aWxkZXJcblxuQnVpbGRlci5wcm90b3R5cGUua2VlcCA9XG5CdWlsZGVyLnByb3RvdHlwZS5yZXRhaW4gPSBmdW5jdGlvbihsZW4pIHtcbiAgdGhpcy5vcHMucHVzaChuZXcgUmV0YWluKGxlbikpXG4gIHJldHVybiB0aGlzXG59XG5cbkJ1aWxkZXIucHJvdG90eXBlLmRlbGV0ZSA9XG5CdWlsZGVyLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24oc3RyKSB7XG4gIHRoaXMucmVtb3ZlbmR1bSArPSBzdHJcbiAgdGhpcy5vcHMucHVzaChuZXcgU2tpcChzdHIubGVuZ3RoKSlcbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVpbGRlci5wcm90b3R5cGUuYWRkID1cbkJ1aWxkZXIucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKHN0cikge1xuICB0aGlzLmFkZGVuZHVtICs9IHN0clxuICB0aGlzLm9wcy5wdXNoKG5ldyBJbnNlcnQoc3RyLmxlbmd0aCkpXG4gIHJldHVybiB0aGlzXG59XG5cbkJ1aWxkZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY3MgPSBuZXcgQ2hhbmdlc2V0KHRoaXMub3BzKVxuICBjcy5hZGRlbmR1bSA9IHRoaXMuYWRkZW5kdW1cbiAgY3MucmVtb3ZlbmR1bSA9IHRoaXMucmVtb3ZlbmR1bVxuICByZXR1cm4gY3Ncbn1cbiIsIi8qIVxuICogY2hhbmdlc2V0c1xuICogQSBDaGFuZ2VzZXQgbGlicmFyeSBpbmNvcnBvcmF0aW5nIG9wZXJhdGlvbmFsIHRyYW5zZm9ybWF0aW9uIChPVClcbiAqIENvcHlyaWdodCAyMDEyIGJ5IE1hcmNlbCBLbGVociA8bWtsZWhyQGdteC5uZXQ+XG4gKlxuICogKE1JVCBMSUNFTlNFKVxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKipcbiAqIEEgc2VxdWVuY2Ugb2YgY29uc2VjdXRpdmUgb3BlcmF0aW9uc1xuICpcbiAqIEBwYXJhbSBvcHMuLiA8T3BlcmF0aW9uPiBhbGwgcGFzc2VkIG9wZXJhdGlvbnMgd2lsbCBiZSBhZGRlZCB0byB0aGUgY2hhbmdlc2V0XG4gKi9cbmZ1bmN0aW9uIENoYW5nZXNldChvcHMvKm9yIG9wcy4uKi8pIHtcbiAgdGhpcy5hZGRlbmR1bSA9IFwiXCJcbiAgdGhpcy5yZW1vdmVuZHVtID0gXCJcIlxuICB0aGlzLmlucHV0TGVuZ3RoID0gMFxuICB0aGlzLm91dHB1dExlbmd0aCA9IDBcblxuICBpZighQXJyYXkuaXNBcnJheShvcHMpKSBvcHMgPSBhcmd1bWVudHNcbiAgZm9yKHZhciBpPTA7IGk8b3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5wdXNoKG9wc1tpXSlcbiAgICB0aGlzLmlucHV0TGVuZ3RoICs9IG9wc1tpXS5pbnB1dFxuICAgIHRoaXMub3V0cHV0TGVuZ3RoICs9IG9wc1tpXS5vdXRwdXRcbiAgfVxufVxuXG4vLyBUcnVlIGluaGVyaXRhbmNlXG5DaGFuZ2VzZXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBcnJheS5wcm90b3R5cGUsIHtcbiAgY29uc3RydWN0b3I6IHtcbiAgICB2YWx1ZTogQ2hhbmdlc2V0LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9XG59KTtcbm1vZHVsZS5leHBvcnRzID0gQ2hhbmdlc2V0XG5cbnZhciBUZXh0VHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UZXh0VHJhbnNmb3JtJylcbiAgLCBDaGFuZ2VzZXRUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL0NoYW5nZXNldFRyYW5zZm9ybScpXG5cbnZhciBSZXRhaW4gPSByZXF1aXJlKCcuL29wZXJhdGlvbnMvUmV0YWluJylcbiAgLCBTa2lwID0gcmVxdWlyZSgnLi9vcGVyYXRpb25zL1NraXAnKVxuICAsIEluc2VydCA9IHJlcXVpcmUoJy4vb3BlcmF0aW9ucy9JbnNlcnQnKVxuXG52YXIgQnVpbGRlciA9IHJlcXVpcmUoJy4vQnVpbGRlcicpXG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBvcHMgdGhhdCBhcmUgd2l0aGluIHRoZSBwYXNzZWQgcmFuZ2VcbiAqIChvbmx5IG9wLmlucHV0IGlzIGNvdW50ZWQ7IHRodXMgbm90IGNvdW50aW5nIGluc2VydHMgdG8gdGhlIHJhbmdlIGxlbmd0aCwgeWV0IHRoZXkgYXJlIHBhcnQgb2YgdGhlIHJhbmdlKVxuICovXG5DaGFuZ2VzZXQucHJvdG90eXBlLnN1YnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIGxlbikge1xuICB2YXIgcmFuZ2UgPSBbXVxuICAgICwgb3AsIG9wbGVuXG4gICAgLCBsPTBcbiAgZm9yKHZhciBpPTAsIHBvcz0wOyBpPHRoaXMubGVuZ3RoICYmIGwgPCBsZW47IGkrKykge1xuICAgIG9wID0gdGhpc1tpXVxuICAgIGlmKG9wLmlucHV0K3BvcyA+PSBzdGFydCkge1xuICAgICAgaWYob3AuaW5wdXQpIHtcbiAgICAgICAgaWYob3AubGVuZ3RoICE9IEluZmluaXR5KSBvcGxlbiA9IG9wLmxlbmd0aCAtTWF0aC5tYXgoMCwgc3RhcnQtcG9zKSAtTWF0aC5tYXgoMCwgKG9wLmxlbmd0aCtwb3MpLShzdGFydCtsZW4pKVxuICAgICAgICBlbHNlIG9wbGVuID0gbGVuXG4gICAgICAgIGlmIChvcGxlbiAhPT0gMCkgcmFuZ2UucHVzaCggb3AuZGVyaXZlKG9wbGVuKSApIC8vIChEb24ndCBjb3B5IG92ZXIgbW9yZSB0aGFuIGxlbiBwYXJhbSBhbGxvd3MpXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmFuZ2UucHVzaCggb3AuZGVyaXZlKG9wLmxlbmd0aCkgKVxuICAgICAgICBvcGxlbiA9IDBcbiAgICAgIH1cbiAgICAgIGwgKz0gb3BsZW5cbiAgICB9XG4gICAgcG9zICs9IG9wLmlucHV0XG4gIH1cbiAgcmV0dXJuIHJhbmdlXG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIGNoYW5nZXNldHMgKHRoYXQgYXJlIGJhc2VkIG9uIHRoZSBzYW1lIHN0YXRlISkgc28gdGhhdCB0aGUgcmVzdWx0aW5nIGNoYW5nc2VzZXRcbiAqIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXMgYm90aCBvcmlnbmFsIG9uZXMgYXBwbGllZCBvbmUgYWZ0ZXIgdGhlIG90aGVyXG4gKlxuICogQHBhcmFtIG90aGVyQ3MgPENoYW5nZXNldD5cbiAqIEBwYXJhbSBsZWZ0IDxib29sZWFuPiBXaGljaCBvcCB0byBjaG9vc2UgaWYgdGhlcmUncyBhbiBpbnNlcnQgdGllIChJZiB5b3UgdXNlIHRoaXMgZnVuY3Rpb24gaW4gYSBkaXN0cmlidXRlZCwgc3luY2hyb25vdXMgZW52aXJvbm1lbnQsIGJlIHN1cmUgdG8gaW52ZXJ0IHRoaXMgcGFyYW0gb24gdGhlIG90aGVyIHNpdGUsIG90aGVyd2lzZSBpdCBjYW4gYmUgb21pdHRlZCBzYWZlbHkpKVxuICogQHJldHVybnMgPENoYW5nZXNldD5cbiAqL1xuQ2hhbmdlc2V0LnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uKG90aGVyQ3MsIGxlZnQpIHtcbiAgaWYoIShvdGhlckNzIGluc3RhbmNlb2YgQ2hhbmdlc2V0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhICM8Q2hhbmdlc2V0PiwgYnV0IHJlY2VpdmVkICcrb3RoZXJDcy5fX3Byb3RvX18uY29uc3RydWN0b3IubmFtZSlcbiAgfVxuXG4gIGlmKG90aGVyQ3MuaW5wdXRMZW5ndGggIT09IHRoaXMub3V0cHV0TGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2hhbmdlc2V0IGxlbmd0aHMgZm9yIG1lcmdpbmcgZG9uJ3QgbWF0Y2ghIElucHV0IGxlbmd0aCBvZiB5b3VuZ2VyIGNzOiBcIitvdGhlckNzLmlucHV0TGVuZ3RoKycsIG91dHB1dCBsZW5ndGggb2Ygb2xkZXIgY3M6Jyt0aGlzLm91dHB1dExlbmd0aClcbiAgfVxuXG4gIHZhciBuZXdvcHMgPSBbXVxuICAgICwgYWRkUHRyMSA9IDBcbiAgICAsIHJlbVB0cjEgPSAwXG4gICAgLCBhZGRQdHIyID0gMFxuICAgICwgcmVtUHRyMiA9IDBcbiAgICAsIG5ld2FkZGVuZHVtID0gJydcbiAgICAsIG5ld3JlbW92ZW5kdW0gPSAnJ1xuXG4gIHppcCh0aGlzLCBvdGhlckNzLCBmdW5jdGlvbihvcDEsIG9wMikge1xuICAgIC8vIGNvbnNvbGUubG9nKG5ld29wcylcbiAgICAvLyBjb25zb2xlLmxvZyhvcDEsIG9wMilcblxuICAgIC8vIEknbSBkZWxldGluZyBzb21ldGhpbmcgLS0gdGhlIG90aGVyIGNzIGNhbid0IGtub3cgdGhhdCwgc28ganVzdCBvdmVydGFrZSBteSBvcFxuICAgIGlmKG9wMSAmJiAhb3AxLm91dHB1dCkge1xuICAgICAgbmV3b3BzLnB1c2gob3AxLm1lcmdlKCkuY2xvbmUoKSlcbiAgICAgIG5ld3JlbW92ZW5kdW0gKz0gdGhpcy5yZW1vdmVuZHVtLnN1YnN0cihyZW1QdHIxLCBvcDEubGVuZ3RoKSAvLyBvdmVydGFrZSBhZGRlZCBjaGFyc1xuICAgICAgcmVtUHRyMSArPSBvcDEubGVuZ3RoXG4gICAgICBvcDEubGVuZ3RoID0gMCAvLyBkb24ndCBnaW1tZSB0aGF0IG9uZSBhZ2Fpbi5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIG9wMiBpcyBhbiBpbnNlcnRcbiAgICBpZihvcDIgJiYgIW9wMi5pbnB1dCkge1xuICAgICAgbmV3b3BzLnB1c2gob3AyLm1lcmdlKCkuY2xvbmUoKSlcbiAgICAgIG5ld2FkZGVuZHVtICs9IG90aGVyQ3MuYWRkZW5kdW0uc3Vic3RyKGFkZFB0cjIsIG9wMi5sZW5ndGgpIC8vIG92ZXJ0YWtlIGFkZGVkIGNoYXJzXG4gICAgICBhZGRQdHIyICs9IG9wMi5sZW5ndGhcbiAgICAgIG9wMi5sZW5ndGggPSAwIC8vIGRvbid0IGdpbW1lIHRoYXQgb25lIGFnYWluLlxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gb3AyIGlzIGVpdGhlciBhIHJldGFpbiBvciBhIHNraXBcbiAgICBpZihvcDIgJiYgb3AyLmlucHV0ICYmIG9wMSkge1xuICAgICAgLy8gb3AyIHJldGFpbnMgd2hhdGV2ZXIgd2UgZG8gaGVyZSAocmV0YWluIG9yIGluc2VydCksIHNvIGp1c3QgY2xvbmUgbXkgb3BcbiAgICAgIGlmKG9wMi5vdXRwdXQpIHtcbiAgICAgICAgbmV3b3BzLnB1c2gob3AxLm1lcmdlKG9wMikuY2xvbmUoKSlcbiAgICAgICAgaWYoIW9wMS5pbnB1dCkgeyAvLyBvdmVydGFrZSBhZGRlbmR1bVxuICAgICAgICAgIG5ld2FkZGVuZHVtICs9IHRoaXMuYWRkZW5kdW0uc3Vic3RyKGFkZFB0cjEsIG9wMS5sZW5ndGgpXG4gICAgICAgICAgYWRkUHRyMSArPSBvcDEubGVuZ3RoXG4gICAgICAgIH1cbiAgICAgICAgb3AxLmxlbmd0aCA9IDAgLy8gZG9uJ3QgZ2ltbWUgdGhlc2UgYWdhaW5cbiAgICAgICAgb3AyLmxlbmd0aCA9IDBcbiAgICAgIH1lbHNlXG5cbiAgICAgIC8vIG9wMiBkZWxldGVzIG15IHJldGFpbiBoZXJlLCBzbyBqdXN0IGNsb25lIHRoZSBkZWxldGVcbiAgICAgIC8vIChvcDEgY2FuIG9ubHkgYmUgYSByZXRhaW4gYW5kIG5vIHNraXAgaGVyZSwgY2F1c2Ugd2UndmUgaGFuZGxlZCBza2lwcyBhYm92ZSBhbHJlYWR5KVxuICAgICAgaWYoIW9wMi5vdXRwdXQgJiYgb3AxLmlucHV0KSB7XG4gICAgICAgIG5ld29wcy5wdXNoKG9wMi5tZXJnZShvcDEpLmNsb25lKCkpXG4gICAgICAgIG5ld3JlbW92ZW5kdW0gKz0gb3RoZXJDcy5yZW1vdmVuZHVtLnN1YnN0cihyZW1QdHIyLCBvcDIubGVuZ3RoKSAvLyBvdmVydGFrZSBhZGRlZCBjaGFyc1xuICAgICAgICByZW1QdHIyICs9IG9wMi5sZW5ndGhcbiAgICAgICAgb3AxLmxlbmd0aCA9IDAgLy8gZG9uJ3QgZ2ltbWUgdGhlc2UgYWdhaW5cbiAgICAgICAgb3AyLmxlbmd0aCA9IDBcbiAgICAgIH1lbHNlXG5cbiAgICAgIC8vb3RoZXJDcyBkZWxldGVzIHNvbWV0aGluZyBJIGFkZGVkICgtMSkgKzEgPSAwXG4gICAgICB7XG4gICAgICAgIGFkZFB0cjEgKz0gb3AxLmxlbmd0aFxuICAgICAgICBvcDEubGVuZ3RoID0gMCAvLyBkb24ndCBnaW1tZSB0aGVzZSBhZ2FpblxuICAgICAgICBvcDIubGVuZ3RoID0gMFxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ29vcHMnLCBhcmd1bWVudHMpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdvb3BzLiBUaGlzIGNhc2UgaGFzblxcJ3QgYmVlbiBjb25zaWRlcmVkIGJ5IHRoZSBkZXZlbG9wZXIgKGVycm9yIGNvZGU6IFBCQ0FDKScpXG4gIH0uYmluZCh0aGlzKSlcblxuICB2YXIgbmV3Q3MgPSBuZXcgQ2hhbmdlc2V0KG5ld29wcylcbiAgbmV3Q3MuYWRkZW5kdW0gPSBuZXdhZGRlbmR1bVxuICBuZXdDcy5yZW1vdmVuZHVtID0gbmV3cmVtb3ZlbmR1bVxuXG4gIHJldHVybiBuZXdDc1xufVxuXG4vKipcbiAqIEEgcHJpdmF0ZSBhbmQgcXVpdGUgaGFuZHkgZnVuY3Rpb24gdGhhdCBzbGljZXMgb3BzIGludG8gZXF1YWxseSBsb25nIHBpZWNlcyBhbmQgYXBwbGllcyB0aGVtIG9uIGEgbWFwcGluZyBmdW5jdGlvblxuICogdGhhdCBjYW4gZGV0ZXJtaW5lIHRoZSBpdGVyYXRpb24gc3RlcHMgYnkgc2V0dGluZyBvcC5sZW5ndGggdG8gMCBvbiBhbiBvcCAoZXF1YWxzIHVzaW5nIC5uZXh0KCkgaW4gYSB1c3VhbCBpdGVyYXRvcilcbiAqL1xuZnVuY3Rpb24gemlwKGNzMSwgY3MyLCBmdW5jKSB7XG4gIHZhciBvcHN0YWNrMSA9IGNzMS5tYXAoZnVuY3Rpb24ob3ApIHtyZXR1cm4gb3AuY2xvbmUoKX0pIC8vIGNvcHkgb3BzXG4gICAgLCBvcHN0YWNrMiA9IGNzMi5tYXAoZnVuY3Rpb24ob3ApIHtyZXR1cm4gb3AuY2xvbmUoKX0pXG5cbiAgdmFyIG9wMiwgb3AxXG4gIHdoaWxlKG9wc3RhY2sxLmxlbmd0aCB8fCBvcHN0YWNrMi5sZW5ndGgpIHsvLyBpdGVyYXRlIHRocm91Z2ggYWxsIG91dHN0YW5kaW5nIG9wcyBvZiB0aGlzIGNzXG4gICAgb3AxID0gb3BzdGFjazFbMF0/IG9wc3RhY2sxWzBdLmNsb25lKCkgOiBudWxsXG4gICAgb3AyID0gb3BzdGFjazJbMF0/IG9wc3RhY2syWzBdLmNsb25lKCkgOiBudWxsXG5cbiAgICBpZihvcDEpIHtcbiAgICAgIGlmKG9wMikgb3AxID0gb3AxLmRlcml2ZShNYXRoLm1pbihvcDEubGVuZ3RoLCBvcDIubGVuZ3RoKSkgLy8gc2xpY2UgJ2VtIGludG8gZXF1YWxseSBsb25nIHBpZWNlc1xuICAgICAgaWYob3BzdGFjazFbMF0ubGVuZ3RoID4gb3AxLmxlbmd0aCkgb3BzdGFjazFbMF0gPSBvcHN0YWNrMVswXS5kZXJpdmUob3BzdGFjazFbMF0ubGVuZ3RoLW9wMS5sZW5ndGgpXG4gICAgICBlbHNlIG9wc3RhY2sxLnNoaWZ0KClcbiAgICB9XG5cbiAgICBpZihvcDIpIHtcbiAgICAgIGlmKG9wMSkgb3AyID0gb3AyLmRlcml2ZShNYXRoLm1pbihvcDEubGVuZ3RoLCBvcDIubGVuZ3RoKSkgLy8gc2xpY2UgJ2VtIGludG8gZXF1YWxseSBsb25nIHBpZWNlc1xuICAgICAgaWYob3BzdGFjazJbMF0ubGVuZ3RoID4gb3AyLmxlbmd0aCkgb3BzdGFjazJbMF0gPSBvcHN0YWNrMlswXS5kZXJpdmUob3BzdGFjazJbMF0ubGVuZ3RoLW9wMi5sZW5ndGgpXG4gICAgICBlbHNlIG9wc3RhY2syLnNoaWZ0KClcbiAgICB9XG5cbiAgICBmdW5jKG9wMSwgb3AyKVxuXG4gICAgaWYob3AxICYmIG9wMS5sZW5ndGgpIG9wc3RhY2sxLnVuc2hpZnQob3AxKVxuICAgIGlmKG9wMiAmJiBvcDIubGVuZ3RoKSBvcHN0YWNrMi51bnNoaWZ0KG9wMilcbiAgfVxufVxuXG4vKipcbiAqIEluY2x1c2lvbiBUcmFuc2Zvcm1hdGlvbiAoSVQpIG9yIEZvcndhcmQgVHJhbnNmb3JtYXRpb25cbiAqXG4gKiB0cmFuc2Zvcm1zIHRoZSBvcGVyYXRpb25zIG9mIHRoZSBjdXJyZW50IGNoYW5nZXNldCBhZ2FpbnN0IHRoZVxuICogYWxsIG9wZXJhdGlvbnMgaW4gYW5vdGhlciBjaGFuZ2VzZXQgaW4gc3VjaCBhIHdheSB0aGF0IHRoZVxuICogZWZmZWN0cyBvZiB0aGUgbGF0dGVyIGFyZSBlZmZlY3RpdmVseSBpbmNsdWRlZC5cbiAqIFRoaXMgaXMgYmFzaWNhbGx5IGxpa2UgYSBhcHBseWluZyB0aGUgb3RoZXIgY3Mgb24gdGhpcyBvbmUuXG4gKlxuICogQHBhcmFtIG90aGVyQ3MgPENoYW5nZXNldD5cbiAqIEBwYXJhbSBsZWZ0IDxib29sZWFuPiBXaGljaCBvcCB0byBjaG9vc2UgaWYgdGhlcmUncyBhbiBpbnNlcnQgdGllIChJZiB5b3UgdXNlIHRoaXMgZnVuY3Rpb24gaW4gYSBkaXN0cmlidXRlZCwgc3luY2hyb25vdXMgZW52aXJvbm1lbnQsIGJlIHN1cmUgdG8gaW52ZXJ0IHRoaXMgcGFyYW0gb24gdGhlIG90aGVyIHNpdGUsIG90aGVyd2lzZSBpdCBjYW4gYmUgb21pdHRlZCBzYWZlbHkpXG4gKlxuICogQHJldHVybnMgPENoYW5nZXNldD5cbiAqL1xuQ2hhbmdlc2V0LnByb3RvdHlwZS50cmFuc2Zvcm1BZ2FpbnN0ID0gZnVuY3Rpb24ob3RoZXJDcywgbGVmdCkge1xuICBpZighKG90aGVyQ3MgaW5zdGFuY2VvZiBDaGFuZ2VzZXQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBcmd1bWVudCB0byBDaGFuZ2VzZXQjdHJhbnNmb3JtQWdhaW5zdCBtdXN0IGJlIGEgIzxDaGFuZ2VzZXQ+LCBidXQgcmVjZWl2ZWQgJytvdGhlckNzLl9fcHJvdG9fXy5jb25zdHJ1Y3Rvci5uYW1lKVxuICB9XG5cbiAgaWYodGhpcy5pbnB1dExlbmd0aCAhPSBvdGhlckNzLmlucHV0TGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IHRyYW5zZm9ybSBjaGFuZ2VzZXRzIHdpdGggZGlmZmVyaW5nIGlucHV0TGVuZ3RoOiAnK3RoaXMuaW5wdXRMZW5ndGgrJyBhbmQgJytvdGhlckNzLmlucHV0TGVuZ3RoKVxuICB9XG5cbiAgdmFyIHRyYW5zZm9ybWF0aW9uID0gbmV3IENoYW5nZXNldFRyYW5zZm9ybSh0aGlzLCBbbmV3IFJldGFpbihJbmZpbml0eSldKVxuICBvdGhlckNzLmZvckVhY2goZnVuY3Rpb24ob3ApIHtcbiAgICB2YXIgbmV4dE9wID0gdGhpcy5zdWJyYW5nZSh0cmFuc2Zvcm1hdGlvbi5wb3MsIEluZmluaXR5KVswXSAvLyBuZXh0IG9wIG9mIHRoaXMgY3NcbiAgICBpZihuZXh0T3AgJiYgIW5leHRPcC5pbnB1dCAmJiAhb3AuaW5wdXQpIHsgLy8gdHdvIGluc2VydHMgdGllZDsgbGVmdCBicmVha3MgaXRcbiAgICAgIGlmIChsZWZ0KSB0cmFuc2Zvcm1hdGlvbi53cml0ZU91dHB1dCh0cmFuc2Zvcm1hdGlvbi5yZWFkSW5wdXQobmV4dE9wLmxlbmd0aCkpXG4gICAgfVxuICAgIG9wLmFwcGx5KHRyYW5zZm9ybWF0aW9uKVxuICB9LmJpbmQodGhpcykpXG5cbiAgcmV0dXJuIHRyYW5zZm9ybWF0aW9uLnJlc3VsdCgpXG59XG5cbi8qKlxuICogRXhjbHVzaW9uIFRyYW5zZm9ybWF0aW9uIChFVCkgb3IgQmFja3dhcmRzIFRyYW5zZm9ybWF0aW9uXG4gKlxuICogdHJhbnNmb3JtcyBhbGwgb3BlcmF0aW9ucyBpbiB0aGUgY3VycmVudCBjaGFuZ2VzZXQgYWdhaW5zdCB0aGUgb3BlcmF0aW9uc1xuICogaW4gYW5vdGhlciBjaGFuZ2VzZXQgaW4gc3VjaCBhIHdheSB0aGF0IHRoZSBpbXBhY3Qgb2YgdGhlIGxhdHRlciBhcmUgZWZmZWN0aXZlbHkgZXhjbHVkZWRcbiAqXG4gKiBAcGFyYW0gY2hhbmdlc2V0IDxDaGFuZ2VzZXQ+IHRoZSBjaGFuZ2VzZXQgdG8gc3Vic3RyYWN0IGZyb20gdGhpcyBvbmVcbiAqIEBwYXJhbSBsZWZ0IDxib29sZWFuPiBXaGljaCBvcCB0byBjaG9vc2UgaWYgdGhlcmUncyBhbiBpbnNlcnQgdGllIChJZiB5b3UgdXNlIHRoaXMgZnVuY3Rpb24gaW4gYSBkaXN0cmlidXRlZCwgc3luY2hyb25vdXMgZW52aXJvbm1lbnQsIGJlIHN1cmUgdG8gaW52ZXJ0IHRoaXMgcGFyYW0gb24gdGhlIG90aGVyIHNpdGUsIG90aGVyd2lzZSBpdCBjYW4gYmUgb21pdHRlZCBzYWZlbHkpXG4gKiBAcmV0dXJucyA8Q2hhbmdlc2V0PlxuICovXG5DaGFuZ2VzZXQucHJvdG90eXBlLnN1YnN0cmFjdCA9IGZ1bmN0aW9uKGNoYW5nZXNldCwgbGVmdCkge1xuICAvLyBUaGUgY3VycmVudCBvcGVyYXRpb25zIGFzc3VtZSB0aGF0IHRoZSBjaGFuZ2VzIGluXG4gIC8vIGBjaGFuZ2VzZXRgIGhhcHBlbmVkIGJlZm9yZSwgc28gZm9yIGVhY2ggb2YgdGhvc2Ugb3BzXG4gIC8vIHdlIGNyZWF0ZSBhbiBvcGVyYXRpb24gdGhhdCB1bmRvZXMgaXRzIGVmZmVjdCBhbmRcbiAgLy8gdHJhbnNmb3JtIGFsbCBvdXIgb3BlcmF0aW9ucyBvbiB0b3Agb2YgdGhlIGludmVyc2UgY2hhbmdlc1xuICByZXR1cm4gdGhpcy50cmFuc2Zvcm1BZ2FpbnN0KGNoYW5nZXNldC5pbnZlcnQoKSwgbGVmdClcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnZlcnNlIENoYW5nZXNldCBvZiB0aGUgY3VycmVudCBvbmVcbiAqXG4gKiBDaGFuZ2VzZXQuaW52ZXJ0KCkuYXBwbHkoQ2hhbmdlc2V0LmFwcGx5KGRvY3VtZW50KSkgPT0gZG9jdW1lbnRcbiAqL1xuQ2hhbmdlc2V0LnByb3RvdHlwZS5pbnZlcnQgPSBmdW5jdGlvbigpIHtcbiAgLy8gaW52ZXJ0IGFsbCBvcHNcbiAgdmFyIG5ld0NzID0gbmV3IENoYW5nZXNldCh0aGlzLm1hcChmdW5jdGlvbihvcCkge1xuICAgIHJldHVybiBvcC5pbnZlcnQoKVxuICB9KSlcblxuICAvLyByZW1vdmVuZHVtIGJlY29tZXMgYWRkZW5kdW0gYW5kIHZpY2UgdmVyc2FcbiAgbmV3Q3MuYWRkZW5kdW0gPSB0aGlzLnJlbW92ZW5kdW1cbiAgbmV3Q3MucmVtb3ZlbmR1bSA9IHRoaXMuYWRkZW5kdW1cblxuICByZXR1cm4gbmV3Q3Ncbn1cblxuLyoqXG4gKiBBcHBsaWVzIHRoaXMgY2hhbmdlc2V0IG9uIGEgdGV4dFxuICovXG5DaGFuZ2VzZXQucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgLy8gcHJlLXJlcXVpc2l0ZXNcbiAgaWYoaW5wdXQubGVuZ3RoICE9IHRoaXMuaW5wdXRMZW5ndGgpIHRocm93IG5ldyBFcnJvcignSW5wdXQgbGVuZ3RoIGRvZXNuXFwndCBtYXRjaCBleHBlY3RlZCBsZW5ndGguIGV4cGVjdGVkOiAnK3RoaXMuaW5wdXRMZW5ndGgrJzsgYWN0dWFsOiAnK2lucHV0Lmxlbmd0aClcblxuICB2YXIgb3BlcmF0aW9uID0gbmV3IFRleHRUcmFuc2Zvcm0oaW5wdXQsIHRoaXMuYWRkZW5kdW0sIHRoaXMucmVtb3ZlbmR1bSlcblxuICB0aGlzLmZvckVhY2goZnVuY3Rpb24ob3ApIHtcbiAgICAvLyBlYWNoIE9wZXJhdGlvbiBoYXMgYWNjZXNzIHRvIGFsbCBwb2ludGVycyBhcyB3ZWxsIGFzIHRoZSBpbnB1dCwgYWRkZW5kdW0gYW5kIHJlbW92ZW5kdW0gKHRoZSBsYXR0ZXIgYXJlIGltbXV0YWJsZSlcbiAgICBvcC5hcHBseShvcGVyYXRpb24pXG4gIH0uYmluZCh0aGlzKSlcblxuICByZXR1cm4gb3BlcmF0aW9uLnJlc3VsdCgpXG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiBzdHJpbmdzIGRlc2NyaWJpbmcgdGhpcyBjaGFuZ2VzZXQncyBvcGVyYXRpb25zXG4gKi9cbkNoYW5nZXNldC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaiA9IDBcbiAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKG9wKSB7XG4gICAgdmFyIHN0cmluZyA9ICcnXG5cbiAgICBpZighb3AuaW5wdXQpIHsgLy8gaWYgSW5zZXJ0XG4gICAgICBzdHJpbmcgPSB0aGlzLmFkZGVuZHVtLnN1YnN0cihqLG9wLmxlbmd0aClcbiAgICAgIGogKz0gb3AubGVuZ3RoXG4gICAgICByZXR1cm4gc3RyaW5nXG4gICAgfVxuXG4gICAgZm9yKHZhciBpPTA7IGk8b3AubGVuZ3RoOyBpKyspIHN0cmluZyArPSBvcC5zeW1ib2xcbiAgICByZXR1cm4gc3RyaW5nXG4gIH0uYmluZCh0aGlzKSkuam9pbignJylcbn1cblxuLyoqXG4gKiBTZXJpYWxpemVzIHRoZSBnaXZlbiBjaGFuZ2VzZXQgaW4gb3JkZXIgdG8gcmV0dXJuIGEgKGhvcGVmdWxseSkgbW9yZSBjb21wYWN0IHJlcHJlc2VudGF0aW9uXG4gKiB0aGFuIGpzb24gdGhhdCBjYW4gYmUgc2VudCB0aHJvdWdoIGEgbmV0d29yayBvciBzdG9yZWQgaW4gYSBkYXRhYmFzZVxuICpcbiAqIE51bWJlcnMgYXJlIGNvbnZlcnRlZCB0byB0aGUgYmFzZSAzNiwgdW5zYWZlIGNoYXJzIGluIHRoZSB0ZXh0IGFyZSB1cmxlbmNvZGVkXG4gKlxuICogQHBhcmFtIGNzIDxDaGFuZ2VzZXQ+IFRoZSBjaGFuZ2VzZXQgdG8gYmUgc2VyaWFsaXplZFxuICogQHJldHVybnMgPFN0cmluZz4gVGhlIHNlcmlhbGl6ZWQgY2hhbmdlc2V0XG4gKi9cbkNoYW5nZXNldC5wcm90b3R5cGUucGFjayA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGFja2VkID0gdGhpcy5tYXAoZnVuY3Rpb24ob3ApIHtcbiAgICByZXR1cm4gb3AucGFjaygpXG4gIH0pLmpvaW4oJycpXG5cbiAgdmFyIGFkZGVuZHVtID0gdGhpcy5hZGRlbmR1bS5yZXBsYWNlKC8lL2csICclMjUnKS5yZXBsYWNlKC9cXHwvZywgJyU3QycpXG4gICAgLCByZW1vdmVuZHVtID0gdGhpcy5yZW1vdmVuZHVtLnJlcGxhY2UoLyUvZywgJyUyNScpLnJlcGxhY2UoL1xcfC9nLCAnJTdDJylcbiAgcmV0dXJuIHBhY2tlZCsnfCcrYWRkZW5kdW0rJ3wnK3JlbW92ZW5kdW1cbn1cbkNoYW5nZXNldC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMucGFjaygpXG59XG5cbi8qKlxuICogVW5zZXJpYWxpemVzIHRoZSBvdXRwdXQgb2YgY3MudGV4dC5DaGFuZ2VzZXQjdG9TdHJpbmcoKVxuICpcbiAqIEBwYXJhbSBwYWNrZWQgPFN0cmluZz4gVGhlIHNlcmlhbGl6ZWQgY2hhbmdlc2V0XG4gKiBAcGFyYW0gPGNzLkNoYW5nZXNldD5cbiAqL1xuQ2hhbmdlc2V0LnVucGFjayA9IGZ1bmN0aW9uKHBhY2tlZCkge1xuICBpZihwYWNrZWQgPT0gJycpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVucGFjayBmcm9tIGVtcHR5IHN0cmluZycpXG4gIHZhciBjb21wb25lbnRzID0gcGFja2VkLnNwbGl0KCd8JylcbiAgICAsIG9wc3RyaW5nID0gY29tcG9uZW50c1swXVxuICAgICwgYWRkZW5kdW0gPSBjb21wb25lbnRzWzFdLnJlcGxhY2UoLyU3Yy9naSwgJ3wnKS5yZXBsYWNlKC8lMjUvZywgJyUnKVxuICAgICwgcmVtb3ZlbmR1bSA9IGNvbXBvbmVudHNbMl0ucmVwbGFjZSgvJTdjL2dpLCAnfCcpLnJlcGxhY2UoLyUyNS9nLCAnJScpXG5cbiAgdmFyIG1hdGNoZXMgPSBvcHN0cmluZy5tYXRjaCgvWz0rLV0oW149Ky1dKSsvZylcbiAgaWYoIW1hdGNoZXMpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVucGFjayBpbnZhbGlkbHkgc2VyaWFsaXplZCBvcCBzdHJpbmcnKVxuXG4gIHZhciBvcHMgPSBbXVxuICBtYXRjaGVzLmZvckVhY2goZnVuY3Rpb24ocykge1xuICAgIHZhciBzeW1ib2wgPSBzLnN1YnN0cigwLDEpXG4gICAgICAsIGRhdGEgPSBzLnN1YnN0cigxKVxuICAgIGlmKFNraXAucHJvdG90eXBlLnN5bWJvbCA9PSBzeW1ib2wpIHJldHVybiBvcHMucHVzaChTa2lwLnVucGFjayhkYXRhKSlcbiAgICBpZihJbnNlcnQucHJvdG90eXBlLnN5bWJvbCA9PSBzeW1ib2wpIHJldHVybiBvcHMucHVzaChJbnNlcnQudW5wYWNrKGRhdGEpKVxuICAgIGlmKFJldGFpbi5wcm90b3R5cGUuc3ltYm9sID09IHN5bWJvbCkgcmV0dXJuIG9wcy5wdXNoKFJldGFpbi51bnBhY2soZGF0YSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNoYW5nZXNldCByZXByZXNlbnRhdGlvbiBwYXNzZWQgdG8gQ2hhbmdlc2V0LnVucGFjaycpXG4gIH0pXG5cbiAgdmFyIGNzID0gbmV3IENoYW5nZXNldChvcHMpXG4gIGNzLmFkZGVuZHVtID0gYWRkZW5kdW1cbiAgY3MucmVtb3ZlbmR1bSA9IHJlbW92ZW5kdW1cblxuICByZXR1cm4gY3Ncbn1cblxuQ2hhbmdlc2V0LmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IEJ1aWxkZXJcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgQ2hhbmdlc2V0IGNvbnRhaW5pbmcgdGhlIG9wZXJhdGlvbnMgbmVlZGVkIHRvIHRyYW5zZm9ybSB0ZXh0MSBpbnRvIHRleHQyXG4gKlxuICogQHBhcmFtIHRleHQxIDxTdHJpbmc+XG4gKiBAcGFyYW0gdGV4dDIgPFN0cmluZz5cbiAqL1xuQ2hhbmdlc2V0LmZyb21EaWZmID0gZnVuY3Rpb24oZGlmZikge1xuICAvKipcbiAgICogVGhlIGRhdGEgc3RydWN0dXJlIHJlcHJlc2VudGluZyBhIGRpZmYgaXMgYW4gYXJyYXkgb2YgdHVwbGVzOlxuICAgKiBbW0RJRkZfREVMRVRFLCAnSGVsbG8nXSwgW0RJRkZfSU5TRVJULCAnR29vZGJ5ZSddLCBbRElGRl9FUVVBTCwgJyB3b3JsZC4nXV1cbiAgICogd2hpY2ggbWVhbnM6IGRlbGV0ZSAnSGVsbG8nLCBhZGQgJ0dvb2RieWUnIGFuZCBrZWVwICcgd29ybGQuJ1xuICAgKi9cbiAgdmFyIERJRkZfREVMRVRFID0gLTE7XG4gIHZhciBESUZGX0lOU0VSVCA9IDE7XG4gIHZhciBESUZGX0VRVUFMID0gMDtcblxuICB2YXIgb3BzID0gW11cbiAgICAsIHJlbW92ZW5kdW0gPSAnJ1xuICAgICwgYWRkZW5kdW0gPSAnJ1xuXG4gIGRpZmYuZm9yRWFjaChmdW5jdGlvbihkKSB7XG4gICAgaWYgKERJRkZfREVMRVRFID09IGRbMF0pIHtcbiAgICAgIG9wcy5wdXNoKG5ldyBTa2lwKGRbMV0ubGVuZ3RoKSlcbiAgICAgIHJlbW92ZW5kdW0gKz0gZFsxXVxuICAgIH1cblxuICAgIGlmIChESUZGX0lOU0VSVCA9PSBkWzBdKSB7XG4gICAgICBvcHMucHVzaChuZXcgSW5zZXJ0KGRbMV0ubGVuZ3RoKSlcbiAgICAgIGFkZGVuZHVtICs9IGRbMV1cbiAgICB9XG5cbiAgICBpZihESUZGX0VRVUFMID09IGRbMF0pIHtcbiAgICAgIG9wcy5wdXNoKG5ldyBSZXRhaW4oZFsxXS5sZW5ndGgpKVxuICAgIH1cbiAgfSlcblxuICB2YXIgY3MgPSBuZXcgQ2hhbmdlc2V0KG9wcylcbiAgY3MuYWRkZW5kdW0gPSBhZGRlbmR1bVxuICBjcy5yZW1vdmVuZHVtID0gcmVtb3ZlbmR1bVxuICByZXR1cm4gY3Ncbn1cbiIsIi8qIVxuICogY2hhbmdlc2V0c1xuICogQSBDaGFuZ2VzZXQgbGlicmFyeSBpbmNvcnBvcmF0aW5nIG9wZXJhdGlvbmFsIENoYW5nZXNldFRyYW5zZm9ybSAoT1QpXG4gKiBDb3B5cmlnaHQgMjAxMiBieSBNYXJjZWwgS2xlaHIgPG1rbGVockBnbXgubmV0PlxuICpcbiAqIChNSVQgTElDRU5TRSlcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxudmFyIFJldGFpbiA9IHJlcXVpcmUoJy4vb3BlcmF0aW9ucy9SZXRhaW4nKVxuICAsIFNraXAgPSByZXF1aXJlKCcuL29wZXJhdGlvbnMvU2tpcCcpXG4gICwgSW5zZXJ0ID0gcmVxdWlyZSgnLi9vcGVyYXRpb25zL0luc2VydCcpXG4gICwgQ2hhbmdlc2V0ID0gcmVxdWlyZSgnLi9DaGFuZ2VzZXQnKVxuXG5cbmZ1bmN0aW9uIENoYW5nZXNldFRyYW5zZm9ybShpbnB1dENzLCBhZGRlbmR1bSkge1xuICB0aGlzLm91dHB1dCA9IFtdXG4gIHRoaXMuYWRkZW5kdW0gPSBhZGRlbmR1bVxuICB0aGlzLm5ld1JlbW92ZW5kdW0gPSAnJ1xuICB0aGlzLm5ld0FkZGVuZHVtID0gJydcblxuICB0aGlzLmNzID0gaW5wdXRDc1xuICB0aGlzLnBvcyA9IDBcbiAgdGhpcy5hZGRlbmR1bVBvaW50ZXIgPSAwXG4gIHRoaXMucmVtb3ZlbmR1bVBvaW50ZXIgPSAwXG59XG5tb2R1bGUuZXhwb3J0cyA9IENoYW5nZXNldFRyYW5zZm9ybVxuXG5DaGFuZ2VzZXRUcmFuc2Zvcm0ucHJvdG90eXBlLnJlYWRJbnB1dCA9IGZ1bmN0aW9uIChsZW4pIHtcbiAgdmFyIHJldCA9IHRoaXMuY3Muc3VicmFuZ2UodGhpcy5wb3MsIGxlbilcbiAgdGhpcy5wb3MgKz0gbGVuXG4gIHJldHVybiByZXRcbn1cblxuQ2hhbmdlc2V0VHJhbnNmb3JtLnByb3RvdHlwZS5yZWFkQWRkZW5kdW0gPSBmdW5jdGlvbiAobGVuKSB7XG4gIC8vcmV0dXJuIFtuZXcgUmV0YWluKGxlbildXG4gIHZhciByZXQgPSB0aGlzLnN1YnJhbmdlKHRoaXMuYWRkZW5kdW0sIHRoaXMuYWRkZW5kdW1Qb2ludGVyLCBsZW4pXG4gIHRoaXMuYWRkZW5kdW1Qb2ludGVyICs9IGxlblxuICByZXR1cm4gcmV0XG59XG5cbkNoYW5nZXNldFRyYW5zZm9ybS5wcm90b3R5cGUud3JpdGVSZW1vdmVuZHVtID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gIHJhbmdlXG4gICAgLmZpbHRlcihmdW5jdGlvbihvcCkge3JldHVybiAhb3Aub3V0cHV0fSlcbiAgICAuZm9yRWFjaChmdW5jdGlvbihvcCkge1xuICAgICAgdGhpcy5yZW1vdmVuZHVtUG9pbnRlciArPSBvcC5sZW5ndGhcbiAgICB9LmJpbmQodGhpcykpXG59XG5cbkNoYW5nZXNldFRyYW5zZm9ybS5wcm90b3R5cGUud3JpdGVPdXRwdXQgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgdGhpcy5vdXRwdXQgPSB0aGlzLm91dHB1dC5jb25jYXQocmFuZ2UpXG4gIHJhbmdlXG4gICAgLmZpbHRlcihmdW5jdGlvbihvcCkge3JldHVybiAhb3Aub3V0cHV0fSlcbiAgICAuZm9yRWFjaChmdW5jdGlvbihvcCkge1xuICAgICAgdGhpcy5uZXdSZW1vdmVuZHVtICs9IHRoaXMuY3MucmVtb3ZlbmR1bS5zdWJzdHIodGhpcy5yZW1vdmVuZHVtUG9pbnRlciwgb3AubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVuZHVtUG9pbnRlciArPSBvcC5sZW5ndGhcbiAgICB9LmJpbmQodGhpcykpXG59XG5cbkNoYW5nZXNldFRyYW5zZm9ybS5wcm90b3R5cGUuc3VicmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2UsIHN0YXJ0LCBsZW4pIHtcbiAgaWYobGVuKSByZXR1cm4gdGhpcy5jcy5zdWJyYW5nZS5jYWxsKHJhbmdlLCBzdGFydCwgbGVuKVxuICBlbHNlIHJldHVybiByYW5nZS5maWx0ZXIoZnVuY3Rpb24ob3ApeyByZXR1cm4gIW9wLmlucHV0fSlcbn1cblxuQ2hhbmdlc2V0VHJhbnNmb3JtLnByb3RvdHlwZS5yZXN1bHQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy53cml0ZU91dHB1dCh0aGlzLnJlYWRJbnB1dChJbmZpbml0eSkpXG4gIHZhciBuZXdDcyA9IG5ldyBDaGFuZ2VzZXQodGhpcy5vdXRwdXQpXG4gIG5ld0NzLmFkZGVuZHVtID0gdGhpcy5jcy5hZGRlbmR1bVxuICBuZXdDcy5yZW1vdmVuZHVtID0gdGhpcy5uZXdSZW1vdmVuZHVtXG4gIHJldHVybiBuZXdDc1xufVxuIiwiZnVuY3Rpb24gT3BlcmF0b3IoKSB7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gT3BlcmF0b3JcblxuT3BlcmF0b3IucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmRlcml2ZSh0aGlzLmxlbmd0aClcbn1cblxuT3BlcmF0b3IucHJvdG90eXBlLmRlcml2ZSA9IGZ1bmN0aW9uKGxlbikge1xuICByZXR1cm4gbmV3ICh0aGlzLmNvbnN0cnVjdG9yKShsZW4pXG59XG5cbk9wZXJhdG9yLnByb3RvdHlwZS5wYWNrID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnN5bWJvbCArICh0aGlzLmxlbmd0aCkudG9TdHJpbmcoMzYpXG59XG4iLCIvKiFcbiAqIGNoYW5nZXNldHNcbiAqIEEgQ2hhbmdlc2V0IGxpYnJhcnkgaW5jb3Jwb3JhdGluZyBvcGVyYXRpb25hbCBBcHBseSAoT1QpXG4gKiBDb3B5cmlnaHQgMjAxMiBieSBNYXJjZWwgS2xlaHIgPG1rbGVockBnbXgubmV0PlxuICpcbiAqIChNSVQgTElDRU5TRSlcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxudmFyIFJldGFpbiA9IHJlcXVpcmUoJy4vb3BlcmF0aW9ucy9SZXRhaW4nKVxuICAsIFNraXAgPSByZXF1aXJlKCcuL29wZXJhdGlvbnMvU2tpcCcpXG4gICwgSW5zZXJ0ID0gcmVxdWlyZSgnLi9vcGVyYXRpb25zL0luc2VydCcpXG4gICwgSW5zZXJ0ID0gcmVxdWlyZSgnLi9DaGFuZ2VzZXQnKVxuXG5cbmZ1bmN0aW9uIFRleHRUcmFuc2Zvcm0oaW5wdXQsIGFkZGVuZHVtLCByZW1vdmVuZHVtKSB7XG4gIHRoaXMub3V0cHV0ID0gJydcblxuICB0aGlzLmlucHV0ID0gaW5wdXRcbiAgdGhpcy5hZGRlbmR1bSA9IGFkZGVuZHVtXG4gIHRoaXMucmVtb3ZlbmR1bSA9IHJlbW92ZW5kdW1cbiAgdGhpcy5wb3MgPSAwXG4gIHRoaXMuYWRkUG9zID0gMFxuICB0aGlzLnJlbVBvcyA9IDBcbn1cbm1vZHVsZS5leHBvcnRzID0gVGV4dFRyYW5zZm9ybVxuXG5UZXh0VHJhbnNmb3JtLnByb3RvdHlwZS5yZWFkSW5wdXQgPSBmdW5jdGlvbiAobGVuKSB7XG4gIHZhciByZXQgPSB0aGlzLmlucHV0LnN1YnN0cih0aGlzLnBvcywgbGVuKVxuICB0aGlzLnBvcyArPSBsZW5cbiAgcmV0dXJuIHJldFxufVxuXG5UZXh0VHJhbnNmb3JtLnByb3RvdHlwZS5yZWFkQWRkZW5kdW0gPSBmdW5jdGlvbiAobGVuKSB7XG4gIHZhciByZXQgPSB0aGlzLmFkZGVuZHVtLnN1YnN0cih0aGlzLmFkZFBvcywgbGVuKVxuICB0aGlzLmFkZFBvcyArPSBsZW5cbiAgcmV0dXJuIHJldFxufVxuXG5UZXh0VHJhbnNmb3JtLnByb3RvdHlwZS53cml0ZVJlbW92ZW5kdW0gPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgLy92YXIgZXhwZWN0ZWQgPSB0aGlzLnJlbW92ZW5kdW0uc3Vic3RyKHRoaXMucmVtUG9zLCByYW5nZS5sZW5ndGgpXG4gIC8vaWYocmFuZ2UgIT0gZXhwZWN0ZWQpIHRocm93IG5ldyBFcnJvcignUmVtb3ZlZCBjaGFycyBkb25cXCd0IG1hdGNoIHJlbW92ZW5kdW0uIGV4cGVjdGVkOiAnK2V4cGVjdGVkKyc7IGFjdHVhbDogJytyYW5nZSlcbiAgdGhpcy5yZW1Qb3MgKz0gcmFuZ2UubGVuZ3RoXG59XG5cblRleHRUcmFuc2Zvcm0ucHJvdG90eXBlLndyaXRlT3V0cHV0ID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gIHRoaXMub3V0cHV0ICs9IHJhbmdlXG59XG5cblRleHRUcmFuc2Zvcm0ucHJvdG90eXBlLnN1YnJhbmdlID0gZnVuY3Rpb24gKHJhbmdlLCBzdGFydCwgbGVuKSB7XG4gIHJldHVybiByYW5nZS5zdWJzdHIoc3RhcnQsIGxlbilcbn1cblxuVGV4dFRyYW5zZm9ybS5wcm90b3R5cGUucmVzdWx0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMud3JpdGVPdXRwdXQodGhpcy5yZWFkSW5wdXQoSW5maW5pdHkpKVxuICByZXR1cm4gdGhpcy5vdXRwdXRcbn1cbiIsIi8qIVxuICogY2hhbmdlc2V0c1xuICogQSBDaGFuZ2VzZXQgbGlicmFyeSBpbmNvcnBvcmF0aW5nIG9wZXJhdGlvbmFsIHRyYW5zZm9ybWF0aW9uIChPVClcbiAqIENvcHlyaWdodCAyMDEyIGJ5IE1hcmNlbCBLbGVociA8bWtsZWhyQGdteC5uZXQ+XG4gKlxuICogKE1JVCBMSUNFTlNFKVxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG52YXIgQ2hhbmdlc2V0ID0gcmVxdWlyZSgnLi9DaGFuZ2VzZXQnKVxuICAsIFJldGFpbiA9IHJlcXVpcmUoJy4vb3BlcmF0aW9ucy9SZXRhaW4nKVxuICAsIFNraXAgPSByZXF1aXJlKCcuL29wZXJhdGlvbnMvU2tpcCcpXG4gICwgSW5zZXJ0ID0gcmVxdWlyZSgnLi9vcGVyYXRpb25zL0luc2VydCcpXG5cbmV4cG9ydHMuT3BlcmF0b3IgPSByZXF1aXJlKCcuL09wZXJhdG9yJylcbmV4cG9ydHMuQ2hhbmdlc2V0ID0gQ2hhbmdlc2V0XG5leHBvcnRzLkluc2VydCA9IEluc2VydFxuZXhwb3J0cy5SZXRhaW4gPSBSZXRhaW5cbmV4cG9ydHMuU2tpcCA9IFNraXBcblxuaWYoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIHdpbmRvdykgd2luZG93LmNoYW5nZXNldHMgPSBleHBvcnRzXG5cbi8qKlxuICogU2VyaWFsaXplcyB0aGUgZ2l2ZW4gY2hhbmdlc2V0IGluIG9yZGVyIHRvIHJldHVybiBhIChob3BlZnVsbHkpIG1vcmUgY29tcGFjdCByZXByZXNlbnRhdGlvblxuICogdGhhdCBjYW4gYmUgc2VudCB0aHJvdWdoIGEgbmV0d29yayBvciBzdG9yZWQgaW4gYSBkYXRhYmFzZVxuICogQGFsaWFzIGNzLnRleHQuQ2hhbmdlc2V0I3BhY2tcbiAqL1xuZXhwb3J0cy5wYWNrID0gZnVuY3Rpb24oY3MpIHtcbiAgcmV0dXJuIGNzLnBhY2soKVxufVxuXG4vKipcbiAqIFVuc2VyaWFsaXplcyB0aGUgb3V0cHV0IG9mIGNzLnRleHQucGFja1xuICogQGFsaWFzIGNzLnRleHQuQ2hhbmdlc2V0LnVucGFja1xuICovXG5leHBvcnRzLnVucGFjayA9IGZ1bmN0aW9uKHBhY2tlZCkge1xuICByZXR1cm4gQ2hhbmdlc2V0LnVucGFjayhwYWNrZWQpXG59XG5cblxuXG5cbi8qKlxuICogc2hhcmVKUyBvdCB0eXBlIEFQSSBzZXBjIHN1cHBvcnRcbiAqL1xuXG5leHBvcnRzLm5hbWUgPSAnY2hhbmdlc2V0cydcbmV4cG9ydHMudXJsID0gJ2h0dHBzOi8vZ2l0aHViLmNvbS9tYXJjZWxrbGVoci9jaGFuZ2VzZXRzJ1xuXG4vKipcbiAqIGNyZWF0ZShbaW5pdGlhbFRleHRdKVxuICpcbiAqIGNyZWF0ZXMgYSBzbmFwc2hvdCAob3B0aW9uYWxseSB3aXRoIHN1cHBsaWVkIGludGlhbCB0ZXh0KVxuICovXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uKGluaXRUZXh0KSB7XG4gIHJldHVybiBpbml0VGV4dCB8fCAnJ1xufVxuXG4vKipcbiAqIEFwcGx5IGEgY2hhbmdlc2V0IG9uIGEgc25hcHNob3QgY3JlYXRpbmcgYSBuZXcgb25lXG4gKlxuICogVGhlIG9sZCBzbmFwc2hvdCBvYmplY3QgbXVzdG4ndCBiZSB1c2VkIGFmdGVyIGNhbGxpbmcgYXBwbHkgb24gaXRcbiAqIHJldHVybnMgdGhlIHJlc3VsdGluZ1xuICovXG5leHBvcnRzLmFwcGx5ID0gZnVuY3Rpb24oc25hcHNob3QsIG9wKSB7XG4gIG9wID0gZXhwb3J0cy51bnBhY2sob3ApXG4gIHJldHVybiBvcC5hcHBseShzbmFwc2hvdClcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gY2hhbmdlc2V0MSBhZ2FpbnN0IGNoYW5nZXNldDJcbiAqL1xuZXhwb3J0cy50cmFuc2Zvcm0gPSBmdW5jdGlvbiAob3AxLCBvcDIsIHNpZGUpIHtcbiAgb3AxID0gZXhwb3J0cy51bnBhY2sob3AxKVxuICBvcDIgPSBleHBvcnRzLnVucGFjayhvcDIpXG4gIHJldHVybiBleHBvcnRzLnBhY2sob3AxLnRyYW5zZm9ybUFnYWluc3Qob3AyLCAoJ2xlZnQnPT1zaWRlKSkpXG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIGNoYW5nZXNldHMgaW50byBvbmVcbiAqL1xuZXhwb3J0cy5jb21wb3NlID0gZnVuY3Rpb24gKG9wMSwgb3AyKSB7XG4gIG9wMSA9IGV4cG9ydHMudW5wYWNrKG9wMSlcbiAgb3AyID0gZXhwb3J0cy51bnBhY2sob3AyKVxuICByZXR1cm4gZXhwb3J0cy5wYWNrKG9wMS5tZXJnZShvcDIpKVxufVxuXG4vKipcbiAqIEludmVydCBhIGNoYW5nZXNldFxuICovXG5leHBvcnRzLmludmVydCA9IGZ1bmN0aW9uKG9wKSB7XG4gIHJldHVybiBleHBvcnRzLnBhY2soZXhwb3J0cy51bnBhY2sob3ApLmludmVydCgpKVxufVxuIiwiLyohXG4gKiBjaGFuZ2VzZXRzXG4gKiBBIENoYW5nZXNldCBsaWJyYXJ5IGluY29ycG9yYXRpbmcgb3BlcmF0aW9uYWwgdHJhbnNmb3JtYXRpb24gKE9UKVxuICogQ29weXJpZ2h0IDIwMTIgYnkgTWFyY2VsIEtsZWhyIDxta2xlaHJAZ214Lm5ldD5cbiAqXG4gKiAoTUlUIExJQ0VOU0UpXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbnZhciBPcGVyYXRvciA9IHJlcXVpcmUoJy4uL09wZXJhdG9yJylcblxuLyoqXG4gKiBJbnNlcnQgT3BlcmF0b3JcbiAqIERlZmluZWQgYnk6XG4gKiAtIGxlbmd0aFxuICogLSBpbnB1dD0wXG4gKiAtIG91dHB1dD1sZW5ndGhcbiAqXG4gKiBAcGFyYW0gbGVuZ3RoIDxOdW1iZXI+IEhvdyBtYW55IGNoYXJzIHRvIGJlIGluc2VydGVkXG4gKi9cbmZ1bmN0aW9uIEluc2VydChsZW5ndGgpIHtcbiAgdGhpcy5sZW5ndGggPSBsZW5ndGhcbiAgdGhpcy5pbnB1dCA9IDBcbiAgdGhpcy5vdXRwdXQgPSBsZW5ndGhcbn1cblxuLy8gVHJ1ZSBpbmhlcml0YW5jZVxuSW5zZXJ0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoT3BlcmF0b3IucHJvdG90eXBlLCB7XG4gIGNvbnN0cnVjdG9yOiB7XG4gICAgdmFsdWU6IEluc2VydCxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IEluc2VydFxuSW5zZXJ0LnByb3RvdHlwZS5zeW1ib2wgPSAnKydcblxudmFyIFNraXAgPSByZXF1aXJlKCcuL1NraXAnKVxuICAsIFJldGFpbiA9IHJlcXVpcmUoJy4vUmV0YWluJylcblxuSW5zZXJ0LnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKHQpIHtcbiAgdC53cml0ZU91dHB1dCh0LnJlYWRBZGRlbmR1bSh0aGlzLm91dHB1dCkpXG59XG5cbkluc2VydC5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXNcbn1cblxuSW5zZXJ0LnByb3RvdHlwZS5pbnZlcnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBTa2lwKHRoaXMubGVuZ3RoKVxufVxuXG5JbnNlcnQudW5wYWNrID0gZnVuY3Rpb24oZGF0YSkge1xuICByZXR1cm4gbmV3IEluc2VydChwYXJzZUludChkYXRhLCAzNikpXG59XG4iLCIvKiFcbiAqIGNoYW5nZXNldHNcbiAqIEEgQ2hhbmdlc2V0IGxpYnJhcnkgaW5jb3Jwb3JhdGluZyBvcGVyYXRpb25hbCB0cmFuc2Zvcm1hdGlvbiAoT1QpXG4gKiBDb3B5cmlnaHQgMjAxMiBieSBNYXJjZWwgS2xlaHIgPG1rbGVockBnbXgubmV0PlxuICpcbiAqIChNSVQgTElDRU5TRSlcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxudmFyIE9wZXJhdG9yID0gcmVxdWlyZSgnLi4vT3BlcmF0b3InKVxuXG4vKipcbiAqIFJldGFpbiBPcGVyYXRvclxuICogRGVmaW5lZCBieTpcbiAqIC0gbGVuZ3RoXG4gKiAtIGlucHV0PW91dHB1dD1sZW5ndGhcbiAqXG4gKiBAcGFyYW0gbGVuZ3RoIDxOdW1iZXI+IEhvdyBtYW55IGNoYXJzIHRvIHJldGFpblxuICovXG5mdW5jdGlvbiBSZXRhaW4obGVuZ3RoKSB7XG4gIHRoaXMubGVuZ3RoID0gbGVuZ3RoXG4gIHRoaXMuaW5wdXQgPSBsZW5ndGhcbiAgdGhpcy5vdXRwdXQgPSBsZW5ndGhcbn1cblxuLy8gVHJ1ZSBpbmhlcml0YW5jZVxuUmV0YWluLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoT3BlcmF0b3IucHJvdG90eXBlLCB7XG4gIGNvbnN0cnVjdG9yOiB7XG4gICAgdmFsdWU6IFJldGFpbixcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IFJldGFpblxuUmV0YWluLnByb3RvdHlwZS5zeW1ib2wgPSAnPSdcblxuUmV0YWluLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKHQpIHtcbiAgdC53cml0ZU91dHB1dCh0LnJlYWRJbnB1dCh0aGlzLmlucHV0KSlcbn1cblxuUmV0YWluLnByb3RvdHlwZS5pbnZlcnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXNcbn1cblxuUmV0YWluLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uKG9wMikge1xuICByZXR1cm4gdGhpc1xufVxuXG5SZXRhaW4udW5wYWNrID0gZnVuY3Rpb24oZGF0YSkge1xuICByZXR1cm4gbmV3IFJldGFpbihwYXJzZUludChkYXRhLCAzNikpXG59XG4iLCIvKiFcbiAqIGNoYW5nZXNldHNcbiAqIEEgQ2hhbmdlc2V0IGxpYnJhcnkgaW5jb3Jwb3JhdGluZyBvcGVyYXRpb25hbCB0cmFuc2Zvcm1hdGlvbiAoT1QpXG4gKiBDb3B5cmlnaHQgMjAxMiBieSBNYXJjZWwgS2xlaHIgPG1rbGVockBnbXgubmV0PlxuICpcbiAqIChNSVQgTElDRU5TRSlcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxudmFyIE9wZXJhdG9yID0gcmVxdWlyZSgnLi4vT3BlcmF0b3InKVxuXG4vKipcbiAqIFNraXAgT3BlcmF0b3JcbiAqIERlZmluZWQgYnk6XG4gKiAtIGxlbmd0aFxuICogLSBpbnB1dD1sZW5ndGhcbiAqIC0gb3V0cHV0PTBcbiAqXG4gKiBAcGFyYW0gbGVuZ3RoIDxOdW1iZXI+IEhvdyBtYW55IGNoYXJzIHRvIGJlIFNraXBcbiAqL1xuZnVuY3Rpb24gU2tpcChsZW5ndGgpIHtcbiAgdGhpcy5sZW5ndGggPSBsZW5ndGhcbiAgdGhpcy5pbnB1dCA9IGxlbmd0aFxuICB0aGlzLm91dHB1dCA9IDBcbn1cblxuLy8gVHJ1ZSBpbmhlcml0YW5jZVxuU2tpcC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE9wZXJhdG9yLnByb3RvdHlwZSwge1xuICBjb25zdHJ1Y3Rvcjoge1xuICAgIHZhbHVlOiBTa2lwLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9XG59KTtcbm1vZHVsZS5leHBvcnRzID0gU2tpcFxuU2tpcC5wcm90b3R5cGUuc3ltYm9sID0gJy0nXG5cbnZhciBJbnNlcnQgPSByZXF1aXJlKCcuL0luc2VydCcpXG4gICwgUmV0YWluID0gcmVxdWlyZSgnLi9SZXRhaW4nKVxuICAsIENoYW5nZXNldCA9IHJlcXVpcmUoJy4uL0NoYW5nZXNldCcpXG5cblNraXAucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24odCkge1xuICB2YXIgaW5wdXQgPSB0LnJlYWRJbnB1dCh0aGlzLmlucHV0KVxuICB0LndyaXRlUmVtb3ZlbmR1bShpbnB1dClcbiAgdC53cml0ZU91dHB1dCh0LnN1YnJhbmdlKGlucHV0LCAwLCB0aGlzLm91dHB1dCkpIC8vIHJldGFpbiBJbnNlcnRzIGluIG15IHJhbmdlXG59XG5cblNraXAucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24ob3AyKSB7XG4gIHJldHVybiB0aGlzXG59XG5cblNraXAucHJvdG90eXBlLmludmVydCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IEluc2VydCh0aGlzLmxlbmd0aClcbn1cblxuU2tpcC51bnBhY2sgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHJldHVybiBuZXcgU2tpcChwYXJzZUludChkYXRhLCAzNikpXG59XG4iLCIvKipcbiAqIERpZmYgTWF0Y2ggYW5kIFBhdGNoXG4gKlxuICogQ29weXJpZ2h0IDIwMDYgR29vZ2xlIEluYy5cbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9nb29nbGUtZGlmZi1tYXRjaC1wYXRjaC9cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBDb21wdXRlcyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byB0ZXh0cyB0byBjcmVhdGUgYSBwYXRjaC5cbiAqIEFwcGxpZXMgdGhlIHBhdGNoIG9udG8gYW5vdGhlciB0ZXh0LCBhbGxvd2luZyBmb3IgZXJyb3JzLlxuICogQGF1dGhvciBmcmFzZXJAZ29vZ2xlLmNvbSAoTmVpbCBGcmFzZXIpXG4gKi9cblxuLyoqXG4gKiBDbGFzcyBjb250YWluaW5nIHRoZSBkaWZmLCBtYXRjaCBhbmQgcGF0Y2ggbWV0aG9kcy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBkaWZmX21hdGNoX3BhdGNoKCkge1xuXG4gIC8vIERlZmF1bHRzLlxuICAvLyBSZWRlZmluZSB0aGVzZSBpbiB5b3VyIHByb2dyYW0gdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzLlxuXG4gIC8vIE51bWJlciBvZiBzZWNvbmRzIHRvIG1hcCBhIGRpZmYgYmVmb3JlIGdpdmluZyB1cCAoMCBmb3IgaW5maW5pdHkpLlxuICB0aGlzLkRpZmZfVGltZW91dCA9IDEuMDtcbiAgLy8gQ29zdCBvZiBhbiBlbXB0eSBlZGl0IG9wZXJhdGlvbiBpbiB0ZXJtcyBvZiBlZGl0IGNoYXJhY3RlcnMuXG4gIHRoaXMuRGlmZl9FZGl0Q29zdCA9IDQ7XG4gIC8vIFRoZSBzaXplIGJleW9uZCB3aGljaCB0aGUgZG91YmxlLWVuZGVkIGRpZmYgYWN0aXZhdGVzLlxuICAvLyBEb3VibGUtZW5kaW5nIGlzIHR3aWNlIGFzIGZhc3QsIGJ1dCBsZXNzIGFjY3VyYXRlLlxuICB0aGlzLkRpZmZfRHVhbFRocmVzaG9sZCA9IDMyO1xuICAvLyBBdCB3aGF0IHBvaW50IGlzIG5vIG1hdGNoIGRlY2xhcmVkICgwLjAgPSBwZXJmZWN0aW9uLCAxLjAgPSB2ZXJ5IGxvb3NlKS5cbiAgdGhpcy5NYXRjaF9UaHJlc2hvbGQgPSAwLjU7XG4gIC8vIEhvdyBmYXIgdG8gc2VhcmNoIGZvciBhIG1hdGNoICgwID0gZXhhY3QgbG9jYXRpb24sIDEwMDArID0gYnJvYWQgbWF0Y2gpLlxuICAvLyBBIG1hdGNoIHRoaXMgbWFueSBjaGFyYWN0ZXJzIGF3YXkgZnJvbSB0aGUgZXhwZWN0ZWQgbG9jYXRpb24gd2lsbCBhZGRcbiAgLy8gMS4wIHRvIHRoZSBzY29yZSAoMC4wIGlzIGEgcGVyZmVjdCBtYXRjaCkuXG4gIHRoaXMuTWF0Y2hfRGlzdGFuY2UgPSAxMDAwO1xuICAvLyBXaGVuIGRlbGV0aW5nIGEgbGFyZ2UgYmxvY2sgb2YgdGV4dCAob3ZlciB+NjQgY2hhcmFjdGVycyksIGhvdyBjbG9zZSBkb2VzXG4gIC8vIHRoZSBjb250ZW50cyBoYXZlIHRvIG1hdGNoIHRoZSBleHBlY3RlZCBjb250ZW50cy4gKDAuMCA9IHBlcmZlY3Rpb24sXG4gIC8vIDEuMCA9IHZlcnkgbG9vc2UpLiAgTm90ZSB0aGF0IE1hdGNoX1RocmVzaG9sZCBjb250cm9scyBob3cgY2xvc2VseSB0aGVcbiAgLy8gZW5kIHBvaW50cyBvZiBhIGRlbGV0ZSBuZWVkIHRvIG1hdGNoLlxuICB0aGlzLlBhdGNoX0RlbGV0ZVRocmVzaG9sZCA9IDAuNTtcbiAgLy8gQ2h1bmsgc2l6ZSBmb3IgY29udGV4dCBsZW5ndGguXG4gIHRoaXMuUGF0Y2hfTWFyZ2luID0gNDtcblxuICAvKipcbiAgICogQ29tcHV0ZSB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gYW4gaW50LlxuICAgKiBUaGUgbm9ybWFsIGFuc3dlciBmb3IgSmF2YVNjcmlwdCBpcyAzMi5cbiAgICogQHJldHVybiB7bnVtYmVyfSBNYXggYml0c1xuICAgKi9cbiAgZnVuY3Rpb24gZ2V0TWF4Qml0cygpIHtcbiAgICB2YXIgbWF4Yml0cyA9IDA7XG4gICAgdmFyIG9sZGkgPSAxO1xuICAgIHZhciBuZXdpID0gMjtcbiAgICB3aGlsZSAob2xkaSAhPSBuZXdpKSB7XG4gICAgICBtYXhiaXRzKys7XG4gICAgICBvbGRpID0gbmV3aTtcbiAgICAgIG5ld2kgPSBuZXdpIDw8IDE7XG4gICAgfVxuICAgIHJldHVybiBtYXhiaXRzO1xuICB9XG4gIC8vIEhvdyBtYW55IGJpdHMgaW4gYSBudW1iZXI/XG4gIHRoaXMuTWF0Y2hfTWF4Qml0cyA9IGdldE1heEJpdHMoKTtcbn1cblxuXG4vLyAgRElGRiBGVU5DVElPTlNcblxuXG4vKipcbiAqIFRoZSBkYXRhIHN0cnVjdHVyZSByZXByZXNlbnRpbmcgYSBkaWZmIGlzIGFuIGFycmF5IG9mIHR1cGxlczpcbiAqIFtbRElGRl9ERUxFVEUsICdIZWxsbyddLCBbRElGRl9JTlNFUlQsICdHb29kYnllJ10sIFtESUZGX0VRVUFMLCAnIHdvcmxkLiddXVxuICogd2hpY2ggbWVhbnM6IGRlbGV0ZSAnSGVsbG8nLCBhZGQgJ0dvb2RieWUnIGFuZCBrZWVwICcgd29ybGQuJ1xuICovXG52YXIgRElGRl9ERUxFVEUgPSAtMTtcbnZhciBESUZGX0lOU0VSVCA9IDE7XG52YXIgRElGRl9FUVVBTCA9IDA7XG5cblxuLyoqXG4gKiBGaW5kIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHR3byB0ZXh0cy4gIFNpbXBsaWZpZXMgdGhlIHByb2JsZW0gYnkgc3RyaXBwaW5nXG4gKiBhbnkgY29tbW9uIHByZWZpeCBvciBzdWZmaXggb2ZmIHRoZSB0ZXh0cyBiZWZvcmUgZGlmZmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBPbGQgc3RyaW5nIHRvIGJlIGRpZmZlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBOZXcgc3RyaW5nIHRvIGJlIGRpZmZlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0X2NoZWNrbGluZXMgT3B0aW9uYWwgc3BlZWR1cCBmbGFnLiAgSWYgcHJlc2VudCBhbmQgZmFsc2UsXG4gKiAgICAgdGhlbiBkb24ndCBydW4gYSBsaW5lLWxldmVsIGRpZmYgZmlyc3QgdG8gaWRlbnRpZnkgdGhlIGNoYW5nZWQgYXJlYXMuXG4gKiAgICAgRGVmYXVsdHMgdG8gdHJ1ZSwgd2hpY2ggZG9lcyBhIGZhc3Rlciwgc2xpZ2h0bHkgbGVzcyBvcHRpbWFsIGRpZmZcbiAqIEByZXR1cm4ge0FycmF5LjxBcnJheS48bnVtYmVyfHN0cmluZz4+fSBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9tYWluID0gZnVuY3Rpb24odGV4dDEsIHRleHQyLCBvcHRfY2hlY2tsaW5lcykge1xuICAvLyBDaGVjayBmb3IgbnVsbCBpbnB1dHMuXG4gIGlmICh0ZXh0MSA9PSBudWxsIHx8IHRleHQyID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ051bGwgaW5wdXQuIChkaWZmX21haW4pJyk7XG4gIH1cblxuICAvLyBDaGVjayBmb3IgZXF1YWxpdHkgKHNwZWVkdXApLlxuICBpZiAodGV4dDEgPT0gdGV4dDIpIHtcbiAgICByZXR1cm4gW1tESUZGX0VRVUFMLCB0ZXh0MV1dO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRfY2hlY2tsaW5lcyA9PSAndW5kZWZpbmVkJykge1xuICAgIG9wdF9jaGVja2xpbmVzID0gdHJ1ZTtcbiAgfVxuICB2YXIgY2hlY2tsaW5lcyA9IG9wdF9jaGVja2xpbmVzO1xuXG4gIC8vIFRyaW0gb2ZmIGNvbW1vbiBwcmVmaXggKHNwZWVkdXApLlxuICB2YXIgY29tbW9ubGVuZ3RoID0gdGhpcy5kaWZmX2NvbW1vblByZWZpeCh0ZXh0MSwgdGV4dDIpO1xuICB2YXIgY29tbW9ucHJlZml4ID0gdGV4dDEuc3Vic3RyaW5nKDAsIGNvbW1vbmxlbmd0aCk7XG4gIHRleHQxID0gdGV4dDEuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCk7XG4gIHRleHQyID0gdGV4dDIuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCk7XG5cbiAgLy8gVHJpbSBvZmYgY29tbW9uIHN1ZmZpeCAoc3BlZWR1cCkuXG4gIGNvbW1vbmxlbmd0aCA9IHRoaXMuZGlmZl9jb21tb25TdWZmaXgodGV4dDEsIHRleHQyKTtcbiAgdmFyIGNvbW1vbnN1ZmZpeCA9IHRleHQxLnN1YnN0cmluZyh0ZXh0MS5sZW5ndGggLSBjb21tb25sZW5ndGgpO1xuICB0ZXh0MSA9IHRleHQxLnN1YnN0cmluZygwLCB0ZXh0MS5sZW5ndGggLSBjb21tb25sZW5ndGgpO1xuICB0ZXh0MiA9IHRleHQyLnN1YnN0cmluZygwLCB0ZXh0Mi5sZW5ndGggLSBjb21tb25sZW5ndGgpO1xuXG4gIC8vIENvbXB1dGUgdGhlIGRpZmYgb24gdGhlIG1pZGRsZSBibG9jay5cbiAgdmFyIGRpZmZzID0gdGhpcy5kaWZmX2NvbXB1dGUodGV4dDEsIHRleHQyLCBjaGVja2xpbmVzKTtcblxuICAvLyBSZXN0b3JlIHRoZSBwcmVmaXggYW5kIHN1ZmZpeC5cbiAgaWYgKGNvbW1vbnByZWZpeCkge1xuICAgIGRpZmZzLnVuc2hpZnQoW0RJRkZfRVFVQUwsIGNvbW1vbnByZWZpeF0pO1xuICB9XG4gIGlmIChjb21tb25zdWZmaXgpIHtcbiAgICBkaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBjb21tb25zdWZmaXhdKTtcbiAgfVxuICB0aGlzLmRpZmZfY2xlYW51cE1lcmdlKGRpZmZzKTtcbiAgcmV0dXJuIGRpZmZzO1xufTtcblxuXG4vKipcbiAqIEZpbmQgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gdHdvIHRleHRzLiAgQXNzdW1lcyB0aGF0IHRoZSB0ZXh0cyBkbyBub3RcbiAqIGhhdmUgYW55IGNvbW1vbiBwcmVmaXggb3Igc3VmZml4LlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIE9sZCBzdHJpbmcgdG8gYmUgZGlmZmVkLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIE5ldyBzdHJpbmcgdG8gYmUgZGlmZmVkLlxuICogQHBhcmFtIHtib29sZWFufSBjaGVja2xpbmVzIFNwZWVkdXAgZmxhZy4gIElmIGZhbHNlLCB0aGVuIGRvbid0IHJ1biBhXG4gKiAgICAgbGluZS1sZXZlbCBkaWZmIGZpcnN0IHRvIGlkZW50aWZ5IHRoZSBjaGFuZ2VkIGFyZWFzLlxuICogICAgIElmIHRydWUsIHRoZW4gcnVuIGEgZmFzdGVyLCBzbGlnaHRseSBsZXNzIG9wdGltYWwgZGlmZlxuICogQHJldHVybiB7QXJyYXkuPEFycmF5LjxudW1iZXJ8c3RyaW5nPj59IEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICogQHByaXZhdGVcbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jb21wdXRlID0gZnVuY3Rpb24odGV4dDEsIHRleHQyLCBjaGVja2xpbmVzKSB7XG4gIHZhciBkaWZmcztcblxuICBpZiAoIXRleHQxKSB7XG4gICAgLy8gSnVzdCBhZGQgc29tZSB0ZXh0IChzcGVlZHVwKS5cbiAgICByZXR1cm4gW1tESUZGX0lOU0VSVCwgdGV4dDJdXTtcbiAgfVxuXG4gIGlmICghdGV4dDIpIHtcbiAgICAvLyBKdXN0IGRlbGV0ZSBzb21lIHRleHQgKHNwZWVkdXApLlxuICAgIHJldHVybiBbW0RJRkZfREVMRVRFLCB0ZXh0MV1dO1xuICB9XG5cbiAgdmFyIGxvbmd0ZXh0ID0gdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gdGV4dDEgOiB0ZXh0MjtcbiAgdmFyIHNob3J0dGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQyIDogdGV4dDE7XG4gIHZhciBpID0gbG9uZ3RleHQuaW5kZXhPZihzaG9ydHRleHQpO1xuICBpZiAoaSAhPSAtMSkge1xuICAgIC8vIFNob3J0ZXIgdGV4dCBpcyBpbnNpZGUgdGhlIGxvbmdlciB0ZXh0IChzcGVlZHVwKS5cbiAgICBkaWZmcyA9IFtbRElGRl9JTlNFUlQsIGxvbmd0ZXh0LnN1YnN0cmluZygwLCBpKV0sXG4gICAgICAgICAgICAgW0RJRkZfRVFVQUwsIHNob3J0dGV4dF0sXG4gICAgICAgICAgICAgW0RJRkZfSU5TRVJULCBsb25ndGV4dC5zdWJzdHJpbmcoaSArIHNob3J0dGV4dC5sZW5ndGgpXV07XG4gICAgLy8gU3dhcCBpbnNlcnRpb25zIGZvciBkZWxldGlvbnMgaWYgZGlmZiBpcyByZXZlcnNlZC5cbiAgICBpZiAodGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoKSB7XG4gICAgICBkaWZmc1swXVswXSA9IGRpZmZzWzJdWzBdID0gRElGRl9ERUxFVEU7XG4gICAgfVxuICAgIHJldHVybiBkaWZmcztcbiAgfVxuICBsb25ndGV4dCA9IHNob3J0dGV4dCA9IG51bGw7ICAvLyBHYXJiYWdlIGNvbGxlY3QuXG5cbiAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZSBwcm9ibGVtIGNhbiBiZSBzcGxpdCBpbiB0d28uXG4gIHZhciBobSA9IHRoaXMuZGlmZl9oYWxmTWF0Y2godGV4dDEsIHRleHQyKTtcbiAgaWYgKGhtKSB7XG4gICAgLy8gQSBoYWxmLW1hdGNoIHdhcyBmb3VuZCwgc29ydCBvdXQgdGhlIHJldHVybiBkYXRhLlxuICAgIHZhciB0ZXh0MV9hID0gaG1bMF07XG4gICAgdmFyIHRleHQxX2IgPSBobVsxXTtcbiAgICB2YXIgdGV4dDJfYSA9IGhtWzJdO1xuICAgIHZhciB0ZXh0Ml9iID0gaG1bM107XG4gICAgdmFyIG1pZF9jb21tb24gPSBobVs0XTtcbiAgICAvLyBTZW5kIGJvdGggcGFpcnMgb2ZmIGZvciBzZXBhcmF0ZSBwcm9jZXNzaW5nLlxuICAgIHZhciBkaWZmc19hID0gdGhpcy5kaWZmX21haW4odGV4dDFfYSwgdGV4dDJfYSwgY2hlY2tsaW5lcyk7XG4gICAgdmFyIGRpZmZzX2IgPSB0aGlzLmRpZmZfbWFpbih0ZXh0MV9iLCB0ZXh0Ml9iLCBjaGVja2xpbmVzKTtcbiAgICAvLyBNZXJnZSB0aGUgcmVzdWx0cy5cbiAgICByZXR1cm4gZGlmZnNfYS5jb25jYXQoW1tESUZGX0VRVUFMLCBtaWRfY29tbW9uXV0sIGRpZmZzX2IpO1xuICB9XG5cbiAgLy8gUGVyZm9ybSBhIHJlYWwgZGlmZi5cbiAgaWYgKGNoZWNrbGluZXMgJiYgKHRleHQxLmxlbmd0aCA8IDEwMCB8fCB0ZXh0Mi5sZW5ndGggPCAxMDApKSB7XG4gICAgLy8gVG9vIHRyaXZpYWwgZm9yIHRoZSBvdmVyaGVhZC5cbiAgICBjaGVja2xpbmVzID0gZmFsc2U7XG4gIH1cbiAgdmFyIGxpbmVhcnJheTtcbiAgaWYgKGNoZWNrbGluZXMpIHtcbiAgICAvLyBTY2FuIHRoZSB0ZXh0IG9uIGEgbGluZS1ieS1saW5lIGJhc2lzIGZpcnN0LlxuICAgIHZhciBhID0gdGhpcy5kaWZmX2xpbmVzVG9DaGFycyh0ZXh0MSwgdGV4dDIpO1xuICAgIHRleHQxID0gYVswXTtcbiAgICB0ZXh0MiA9IGFbMV07XG4gICAgbGluZWFycmF5ID0gYVsyXTtcbiAgfVxuICBkaWZmcyA9IHRoaXMuZGlmZl9tYXAodGV4dDEsIHRleHQyKTtcbiAgaWYgKCFkaWZmcykge1xuICAgIC8vIE5vIGFjY2VwdGFibGUgcmVzdWx0LlxuICAgIGRpZmZzID0gW1tESUZGX0RFTEVURSwgdGV4dDFdLCBbRElGRl9JTlNFUlQsIHRleHQyXV07XG4gIH1cbiAgaWYgKGNoZWNrbGluZXMpIHtcbiAgICAvLyBDb252ZXJ0IHRoZSBkaWZmIGJhY2sgdG8gb3JpZ2luYWwgdGV4dC5cbiAgICB0aGlzLmRpZmZfY2hhcnNUb0xpbmVzKGRpZmZzLCBsaW5lYXJyYXkpO1xuICAgIC8vIEVsaW1pbmF0ZSBmcmVhayBtYXRjaGVzIChlLmcuIGJsYW5rIGxpbmVzKVxuICAgIHRoaXMuZGlmZl9jbGVhbnVwU2VtYW50aWMoZGlmZnMpO1xuXG4gICAgLy8gUmVkaWZmIGFueSByZXBsYWNlbWVudCBibG9ja3MsIHRoaXMgdGltZSBjaGFyYWN0ZXItYnktY2hhcmFjdGVyLlxuICAgIC8vIEFkZCBhIGR1bW15IGVudHJ5IGF0IHRoZSBlbmQuXG4gICAgZGlmZnMucHVzaChbRElGRl9FUVVBTCwgJyddKTtcbiAgICB2YXIgcG9pbnRlciA9IDA7XG4gICAgdmFyIGNvdW50X2RlbGV0ZSA9IDA7XG4gICAgdmFyIGNvdW50X2luc2VydCA9IDA7XG4gICAgdmFyIHRleHRfZGVsZXRlID0gJyc7XG4gICAgdmFyIHRleHRfaW5zZXJ0ID0gJyc7XG4gICAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGgpIHtcbiAgICAgIHN3aXRjaCAoZGlmZnNbcG9pbnRlcl1bMF0pIHtcbiAgICAgICAgY2FzZSBESUZGX0lOU0VSVDpcbiAgICAgICAgICBjb3VudF9pbnNlcnQrKztcbiAgICAgICAgICB0ZXh0X2luc2VydCArPSBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBESUZGX0RFTEVURTpcbiAgICAgICAgICBjb3VudF9kZWxldGUrKztcbiAgICAgICAgICB0ZXh0X2RlbGV0ZSArPSBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgICAgIC8vIFVwb24gcmVhY2hpbmcgYW4gZXF1YWxpdHksIGNoZWNrIGZvciBwcmlvciByZWR1bmRhbmNpZXMuXG4gICAgICAgICAgaWYgKGNvdW50X2RlbGV0ZSA+PSAxICYmIGNvdW50X2luc2VydCA+PSAxKSB7XG4gICAgICAgICAgICAvLyBEZWxldGUgdGhlIG9mZmVuZGluZyByZWNvcmRzIGFuZCBhZGQgdGhlIG1lcmdlZCBvbmVzLlxuICAgICAgICAgICAgdmFyIGEgPSB0aGlzLmRpZmZfbWFpbih0ZXh0X2RlbGV0ZSwgdGV4dF9pbnNlcnQsIGZhbHNlKTtcbiAgICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50X2RlbGV0ZSArIGNvdW50X2luc2VydCk7XG4gICAgICAgICAgICBwb2ludGVyID0gcG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydDtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBhLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyLCAwLCBhW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvaW50ZXIgPSBwb2ludGVyICsgYS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvdW50X2luc2VydCA9IDA7XG4gICAgICAgICAgY291bnRfZGVsZXRlID0gMDtcbiAgICAgICAgICB0ZXh0X2RlbGV0ZSA9ICcnO1xuICAgICAgICAgIHRleHRfaW5zZXJ0ID0gJyc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgIHBvaW50ZXIrKztcbiAgICB9XG4gICAgZGlmZnMucG9wKCk7ICAvLyBSZW1vdmUgdGhlIGR1bW15IGVudHJ5IGF0IHRoZSBlbmQuXG4gIH1cbiAgcmV0dXJuIGRpZmZzO1xufTtcblxuXG4vKipcbiAqIFNwbGl0IHR3byB0ZXh0cyBpbnRvIGFuIGFycmF5IG9mIHN0cmluZ3MuICBSZWR1Y2UgdGhlIHRleHRzIHRvIGEgc3RyaW5nIG9mXG4gKiBoYXNoZXMgd2hlcmUgZWFjaCBVbmljb2RlIGNoYXJhY3RlciByZXByZXNlbnRzIG9uZSBsaW5lLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIEZpcnN0IHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBTZWNvbmQgc3RyaW5nLlxuICogQHJldHVybiB7QXJyYXkuPHN0cmluZ3xBcnJheS48c3RyaW5nPj59IFRocmVlIGVsZW1lbnQgQXJyYXksIGNvbnRhaW5pbmcgdGhlXG4gKiAgICAgZW5jb2RlZCB0ZXh0MSwgdGhlIGVuY29kZWQgdGV4dDIgYW5kIHRoZSBhcnJheSBvZiB1bmlxdWUgc3RyaW5ncy4gIFRoZVxuICogICAgIHplcm90aCBlbGVtZW50IG9mIHRoZSBhcnJheSBvZiB1bmlxdWUgc3RyaW5ncyBpcyBpbnRlbnRpb25hbGx5IGJsYW5rLlxuICogQHByaXZhdGVcbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9saW5lc1RvQ2hhcnMgPSBmdW5jdGlvbih0ZXh0MSwgdGV4dDIpIHtcbiAgdmFyIGxpbmVBcnJheSA9IFtdOyAgLy8gZS5nLiBsaW5lQXJyYXlbNF0gPT0gJ0hlbGxvXFxuJ1xuICB2YXIgbGluZUhhc2ggPSB7fTsgICAvLyBlLmcuIGxpbmVIYXNoWydIZWxsb1xcbiddID09IDRcblxuICAvLyAnXFx4MDAnIGlzIGEgdmFsaWQgY2hhcmFjdGVyLCBidXQgdmFyaW91cyBkZWJ1Z2dlcnMgZG9uJ3QgbGlrZSBpdC5cbiAgLy8gU28gd2UnbGwgaW5zZXJ0IGEganVuayBlbnRyeSB0byBhdm9pZCBnZW5lcmF0aW5nIGEgbnVsbCBjaGFyYWN0ZXIuXG4gIGxpbmVBcnJheVswXSA9ICcnO1xuXG4gIC8qKlxuICAgKiBTcGxpdCBhIHRleHQgaW50byBhbiBhcnJheSBvZiBzdHJpbmdzLiAgUmVkdWNlIHRoZSB0ZXh0cyB0byBhIHN0cmluZyBvZlxuICAgKiBoYXNoZXMgd2hlcmUgZWFjaCBVbmljb2RlIGNoYXJhY3RlciByZXByZXNlbnRzIG9uZSBsaW5lLlxuICAgKiBNb2RpZmllcyBsaW5lYXJyYXkgYW5kIGxpbmVoYXNoIHRocm91Z2ggYmVpbmcgYSBjbG9zdXJlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBTdHJpbmcgdG8gZW5jb2RlLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEVuY29kZWQgc3RyaW5nLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZGlmZl9saW5lc1RvQ2hhcnNNdW5nZSh0ZXh0KSB7XG4gICAgdmFyIGNoYXJzID0gJyc7XG4gICAgLy8gV2FsayB0aGUgdGV4dCwgcHVsbGluZyBvdXQgYSBzdWJzdHJpbmcgZm9yIGVhY2ggbGluZS5cbiAgICAvLyB0ZXh0LnNwbGl0KCdcXG4nKSB3b3VsZCB3b3VsZCB0ZW1wb3JhcmlseSBkb3VibGUgb3VyIG1lbW9yeSBmb290cHJpbnQuXG4gICAgLy8gTW9kaWZ5aW5nIHRleHQgd291bGQgY3JlYXRlIG1hbnkgbGFyZ2Ugc3RyaW5ncyB0byBnYXJiYWdlIGNvbGxlY3QuXG4gICAgdmFyIGxpbmVTdGFydCA9IDA7XG4gICAgdmFyIGxpbmVFbmQgPSAtMTtcbiAgICAvLyBLZWVwaW5nIG91ciBvd24gbGVuZ3RoIHZhcmlhYmxlIGlzIGZhc3RlciB0aGFuIGxvb2tpbmcgaXQgdXAuXG4gICAgdmFyIGxpbmVBcnJheUxlbmd0aCA9IGxpbmVBcnJheS5sZW5ndGg7XG4gICAgd2hpbGUgKGxpbmVFbmQgPCB0ZXh0Lmxlbmd0aCAtIDEpIHtcbiAgICAgIGxpbmVFbmQgPSB0ZXh0LmluZGV4T2YoJ1xcbicsIGxpbmVTdGFydCk7XG4gICAgICBpZiAobGluZUVuZCA9PSAtMSkge1xuICAgICAgICBsaW5lRW5kID0gdGV4dC5sZW5ndGggLSAxO1xuICAgICAgfVxuICAgICAgdmFyIGxpbmUgPSB0ZXh0LnN1YnN0cmluZyhsaW5lU3RhcnQsIGxpbmVFbmQgKyAxKTtcbiAgICAgIGxpbmVTdGFydCA9IGxpbmVFbmQgKyAxO1xuXG4gICAgICBpZiAobGluZUhhc2guaGFzT3duUHJvcGVydHkgPyBsaW5lSGFzaC5oYXNPd25Qcm9wZXJ0eShsaW5lKSA6XG4gICAgICAgICAgKGxpbmVIYXNoW2xpbmVdICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIGNoYXJzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGluZUhhc2hbbGluZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hhcnMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsaW5lQXJyYXlMZW5ndGgpO1xuICAgICAgICBsaW5lSGFzaFtsaW5lXSA9IGxpbmVBcnJheUxlbmd0aDtcbiAgICAgICAgbGluZUFycmF5W2xpbmVBcnJheUxlbmd0aCsrXSA9IGxpbmU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGFycztcbiAgfVxuXG4gIHZhciBjaGFyczEgPSBkaWZmX2xpbmVzVG9DaGFyc011bmdlKHRleHQxKTtcbiAgdmFyIGNoYXJzMiA9IGRpZmZfbGluZXNUb0NoYXJzTXVuZ2UodGV4dDIpO1xuICByZXR1cm4gW2NoYXJzMSwgY2hhcnMyLCBsaW5lQXJyYXldO1xufTtcblxuXG4vKipcbiAqIFJlaHlkcmF0ZSB0aGUgdGV4dCBpbiBhIGRpZmYgZnJvbSBhIHN0cmluZyBvZiBsaW5lIGhhc2hlcyB0byByZWFsIGxpbmVzIG9mXG4gKiB0ZXh0LlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcnxzdHJpbmc+Pn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBsaW5lQXJyYXkgQXJyYXkgb2YgdW5pcXVlIHN0cmluZ3MuXG4gKiBAcHJpdmF0ZVxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2NoYXJzVG9MaW5lcyA9IGZ1bmN0aW9uKGRpZmZzLCBsaW5lQXJyYXkpIHtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xuICAgIHZhciBjaGFycyA9IGRpZmZzW3hdWzFdO1xuICAgIHZhciB0ZXh0ID0gW107XG4gICAgZm9yICh2YXIgeSA9IDA7IHkgPCBjaGFycy5sZW5ndGg7IHkrKykge1xuICAgICAgdGV4dFt5XSA9IGxpbmVBcnJheVtjaGFycy5jaGFyQ29kZUF0KHkpXTtcbiAgICB9XG4gICAgZGlmZnNbeF1bMV0gPSB0ZXh0LmpvaW4oJycpO1xuICB9XG59O1xuXG5cbi8qKlxuICogRXhwbG9yZSB0aGUgaW50ZXJzZWN0aW9uIHBvaW50cyBiZXR3ZWVuIHRoZSB0d28gdGV4dHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgT2xkIHN0cmluZyB0byBiZSBkaWZmZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgTmV3IHN0cmluZyB0byBiZSBkaWZmZWQuXG4gKiBAcmV0dXJuIHs/QXJyYXkuPEFycmF5LjxudW1iZXJ8c3RyaW5nPj59IEFycmF5IG9mIGRpZmYgdHVwbGVzIG9yIG51bGwgaWYgbm9cbiAqICAgICBkaWZmIGF2YWlsYWJsZS5cbiAqIEBwcml2YXRlXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfbWFwID0gZnVuY3Rpb24odGV4dDEsIHRleHQyKSB7XG4gIC8vIERvbid0IHJ1biBmb3IgdG9vIGxvbmcuXG4gIHZhciBtc19lbmQgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpICsgdGhpcy5EaWZmX1RpbWVvdXQgKiAxMDAwO1xuICAvLyBDYWNoZSB0aGUgdGV4dCBsZW5ndGhzIHRvIHByZXZlbnQgbXVsdGlwbGUgY2FsbHMuXG4gIHZhciB0ZXh0MV9sZW5ndGggPSB0ZXh0MS5sZW5ndGg7XG4gIHZhciB0ZXh0Ml9sZW5ndGggPSB0ZXh0Mi5sZW5ndGg7XG4gIHZhciBtYXhfZCA9IHRleHQxX2xlbmd0aCArIHRleHQyX2xlbmd0aCAtIDE7XG4gIHZhciBkb3VibGVFbmQgPSB0aGlzLkRpZmZfRHVhbFRocmVzaG9sZCAqIDIgPCBtYXhfZDtcbiAgLy8gSmF2YVNjcmlwdCBlZmZpY2llbmN5IG5vdGU6ICh4IDw8IDMyKSArIHkgZG9lc24ndCB3b3JrIHNpbmNlIG51bWJlcnMgYXJlXG4gIC8vIG9ubHkgMzIgYml0LiAgVXNlIHggKyAnLCcgKyB5IHRvIGNyZWF0ZSBhIGhhc2ggaW5zdGVhZC5cbiAgdmFyIHZfbWFwMSA9IFtdO1xuICB2YXIgdl9tYXAyID0gW107XG4gIHZhciB2MSA9IHt9O1xuICB2YXIgdjIgPSB7fTtcbiAgdjFbMV0gPSAwO1xuICB2MlsxXSA9IDA7XG4gIHZhciB4LCB5O1xuICB2YXIgZm9vdHN0ZXA7ICAvLyBVc2VkIHRvIHRyYWNrIG92ZXJsYXBwaW5nIHBhdGhzLlxuICB2YXIgZm9vdHN0ZXBzID0ge307XG4gIHZhciBkb25lID0gZmFsc2U7XG4gIC8vIElmIHRoZSB0b3RhbCBudW1iZXIgb2YgY2hhcmFjdGVycyBpcyBvZGQsIHRoZW4gdGhlIGZyb250IHBhdGggd2lsbCBjb2xsaWRlXG4gIC8vIHdpdGggdGhlIHJldmVyc2UgcGF0aC5cbiAgdmFyIGZyb250ID0gKHRleHQxX2xlbmd0aCArIHRleHQyX2xlbmd0aCkgJSAyO1xuICBmb3IgKHZhciBkID0gMDsgZCA8IG1heF9kOyBkKyspIHtcbiAgICAvLyBCYWlsIG91dCBpZiB0aW1lb3V0IHJlYWNoZWQuXG4gICAgaWYgKHRoaXMuRGlmZl9UaW1lb3V0ID4gMCAmJiAobmV3IERhdGUoKSkuZ2V0VGltZSgpID4gbXNfZW5kKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBXYWxrIHRoZSBmcm9udCBwYXRoIG9uZSBzdGVwLlxuICAgIHZfbWFwMVtkXSA9IHt9O1xuICAgIGZvciAodmFyIGsgPSAtZDsgayA8PSBkOyBrICs9IDIpIHtcbiAgICAgIGlmIChrID09IC1kIHx8IGsgIT0gZCAmJiB2MVtrIC0gMV0gPCB2MVtrICsgMV0pIHtcbiAgICAgICAgeCA9IHYxW2sgKyAxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSB2MVtrIC0gMV0gKyAxO1xuICAgICAgfVxuICAgICAgeSA9IHggLSBrO1xuICAgICAgaWYgKGRvdWJsZUVuZCkge1xuICAgICAgICBmb290c3RlcCA9IHggKyAnLCcgKyB5O1xuICAgICAgICBpZiAoZnJvbnQgJiYgZm9vdHN0ZXBzW2Zvb3RzdGVwXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmcm9udCkge1xuICAgICAgICAgIGZvb3RzdGVwc1tmb290c3RlcF0gPSBkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAoIWRvbmUgJiYgeCA8IHRleHQxX2xlbmd0aCAmJiB5IDwgdGV4dDJfbGVuZ3RoICYmXG4gICAgICAgICAgICAgdGV4dDEuY2hhckF0KHgpID09IHRleHQyLmNoYXJBdCh5KSkge1xuICAgICAgICB4Kys7XG4gICAgICAgIHkrKztcbiAgICAgICAgaWYgKGRvdWJsZUVuZCkge1xuICAgICAgICAgIGZvb3RzdGVwID0geCArICcsJyArIHk7XG4gICAgICAgICAgaWYgKGZyb250ICYmIGZvb3RzdGVwc1tmb290c3RlcF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZnJvbnQpIHtcbiAgICAgICAgICAgIGZvb3RzdGVwc1tmb290c3RlcF0gPSBkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdjFba10gPSB4O1xuICAgICAgdl9tYXAxW2RdW3ggKyAnLCcgKyB5XSA9IHRydWU7XG4gICAgICBpZiAoeCA9PSB0ZXh0MV9sZW5ndGggJiYgeSA9PSB0ZXh0Ml9sZW5ndGgpIHtcbiAgICAgICAgLy8gUmVhY2hlZCB0aGUgZW5kIGluIHNpbmdsZS1wYXRoIG1vZGUuXG4gICAgICAgIHJldHVybiB0aGlzLmRpZmZfcGF0aDEodl9tYXAxLCB0ZXh0MSwgdGV4dDIpO1xuICAgICAgfSBlbHNlIGlmIChkb25lKSB7XG4gICAgICAgIC8vIEZyb250IHBhdGggcmFuIG92ZXIgcmV2ZXJzZSBwYXRoLlxuICAgICAgICB2X21hcDIgPSB2X21hcDIuc2xpY2UoMCwgZm9vdHN0ZXBzW2Zvb3RzdGVwXSArIDEpO1xuICAgICAgICB2YXIgYSA9IHRoaXMuZGlmZl9wYXRoMSh2X21hcDEsIHRleHQxLnN1YnN0cmluZygwLCB4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDIuc3Vic3RyaW5nKDAsIHkpKTtcbiAgICAgICAgcmV0dXJuIGEuY29uY2F0KHRoaXMuZGlmZl9wYXRoMih2X21hcDIsIHRleHQxLnN1YnN0cmluZyh4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Mi5zdWJzdHJpbmcoeSkpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZG91YmxlRW5kKSB7XG4gICAgICAvLyBXYWxrIHRoZSByZXZlcnNlIHBhdGggb25lIHN0ZXAuXG4gICAgICB2X21hcDJbZF0gPSB7fTtcbiAgICAgIGZvciAodmFyIGsgPSAtZDsgayA8PSBkOyBrICs9IDIpIHtcbiAgICAgICAgaWYgKGsgPT0gLWQgfHwgayAhPSBkICYmIHYyW2sgLSAxXSA8IHYyW2sgKyAxXSkge1xuICAgICAgICAgIHggPSB2MltrICsgMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeCA9IHYyW2sgLSAxXSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgeSA9IHggLSBrO1xuICAgICAgICBmb290c3RlcCA9ICh0ZXh0MV9sZW5ndGggLSB4KSArICcsJyArICh0ZXh0Ml9sZW5ndGggLSB5KTtcbiAgICAgICAgaWYgKCFmcm9udCAmJiBmb290c3RlcHNbZm9vdHN0ZXBdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbnQpIHtcbiAgICAgICAgICBmb290c3RlcHNbZm9vdHN0ZXBdID0gZDtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoIWRvbmUgJiYgeCA8IHRleHQxX2xlbmd0aCAmJiB5IDwgdGV4dDJfbGVuZ3RoICYmXG4gICAgICAgICAgICAgICB0ZXh0MS5jaGFyQXQodGV4dDFfbGVuZ3RoIC0geCAtIDEpID09XG4gICAgICAgICAgICAgICB0ZXh0Mi5jaGFyQXQodGV4dDJfbGVuZ3RoIC0geSAtIDEpKSB7XG4gICAgICAgICAgeCsrO1xuICAgICAgICAgIHkrKztcbiAgICAgICAgICBmb290c3RlcCA9ICh0ZXh0MV9sZW5ndGggLSB4KSArICcsJyArICh0ZXh0Ml9sZW5ndGggLSB5KTtcbiAgICAgICAgICBpZiAoIWZyb250ICYmIGZvb3RzdGVwc1tmb290c3RlcF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmcm9udCkge1xuICAgICAgICAgICAgZm9vdHN0ZXBzW2Zvb3RzdGVwXSA9IGQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHYyW2tdID0geDtcbiAgICAgICAgdl9tYXAyW2RdW3ggKyAnLCcgKyB5XSA9IHRydWU7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgLy8gUmV2ZXJzZSBwYXRoIHJhbiBvdmVyIGZyb250IHBhdGguXG4gICAgICAgICAgdl9tYXAxID0gdl9tYXAxLnNsaWNlKDAsIGZvb3RzdGVwc1tmb290c3RlcF0gKyAxKTtcbiAgICAgICAgICB2YXIgYSA9IHRoaXMuZGlmZl9wYXRoMSh2X21hcDEsIHRleHQxLnN1YnN0cmluZygwLCB0ZXh0MV9sZW5ndGggLSB4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Mi5zdWJzdHJpbmcoMCwgdGV4dDJfbGVuZ3RoIC0geSkpO1xuICAgICAgICAgIHJldHVybiBhLmNvbmNhdCh0aGlzLmRpZmZfcGF0aDIodl9tYXAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0MS5zdWJzdHJpbmcodGV4dDFfbGVuZ3RoIC0geCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQyLnN1YnN0cmluZyh0ZXh0Ml9sZW5ndGggLSB5KSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIE51bWJlciBvZiBkaWZmcyBlcXVhbHMgbnVtYmVyIG9mIGNoYXJhY3RlcnMsIG5vIGNvbW1vbmFsaXR5IGF0IGFsbC5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5cbi8qKlxuICogV29yayBmcm9tIHRoZSBtaWRkbGUgYmFjayB0byB0aGUgc3RhcnQgdG8gZGV0ZXJtaW5lIHRoZSBwYXRoLlxuICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gdl9tYXAgQXJyYXkgb2YgcGF0aHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgT2xkIHN0cmluZyBmcmFnbWVudCB0byBiZSBkaWZmZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgTmV3IHN0cmluZyBmcmFnbWVudCB0byBiZSBkaWZmZWQuXG4gKiBAcmV0dXJuIHtBcnJheS48QXJyYXkuPG51bWJlcnxzdHJpbmc+Pn0gQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX3BhdGgxID0gZnVuY3Rpb24odl9tYXAsIHRleHQxLCB0ZXh0Mikge1xuICB2YXIgcGF0aCA9IFtdO1xuICB2YXIgeCA9IHRleHQxLmxlbmd0aDtcbiAgdmFyIHkgPSB0ZXh0Mi5sZW5ndGg7XG4gIC8qKiBAdHlwZSB7P251bWJlcn0gKi9cbiAgdmFyIGxhc3Rfb3AgPSBudWxsO1xuICBmb3IgKHZhciBkID0gdl9tYXAubGVuZ3RoIC0gMjsgZCA+PSAwOyBkLS0pIHtcbiAgICB3aGlsZSAoMSkge1xuICAgICAgaWYgKHZfbWFwW2RdWyh4IC0gMSkgKyAnLCcgKyB5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHgtLTtcbiAgICAgICAgaWYgKGxhc3Rfb3AgPT09IERJRkZfREVMRVRFKSB7XG4gICAgICAgICAgcGF0aFswXVsxXSA9IHRleHQxLmNoYXJBdCh4KSArIHBhdGhbMF1bMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aC51bnNoaWZ0KFtESUZGX0RFTEVURSwgdGV4dDEuY2hhckF0KHgpXSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdF9vcCA9IERJRkZfREVMRVRFO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAodl9tYXBbZF1beCArICcsJyArICh5IC0gMSldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgeS0tO1xuICAgICAgICBpZiAobGFzdF9vcCA9PT0gRElGRl9JTlNFUlQpIHtcbiAgICAgICAgICBwYXRoWzBdWzFdID0gdGV4dDIuY2hhckF0KHkpICsgcGF0aFswXVsxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRoLnVuc2hpZnQoW0RJRkZfSU5TRVJULCB0ZXh0Mi5jaGFyQXQoeSldKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0X29wID0gRElGRl9JTlNFUlQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeC0tO1xuICAgICAgICB5LS07XG4gICAgICAgIGlmICh0ZXh0MS5jaGFyQXQoeCkgIT0gdGV4dDIuY2hhckF0KHkpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBkaWFnb25hbC4gIENhblxcJ3QgaGFwcGVuLiAoZGlmZl9wYXRoMSknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdF9vcCA9PT0gRElGRl9FUVVBTCkge1xuICAgICAgICAgIHBhdGhbMF1bMV0gPSB0ZXh0MS5jaGFyQXQoeCkgKyBwYXRoWzBdWzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGgudW5zaGlmdChbRElGRl9FUVVBTCwgdGV4dDEuY2hhckF0KHgpXSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdF9vcCA9IERJRkZfRVFVQUw7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXRoO1xufTtcblxuXG4vKipcbiAqIFdvcmsgZnJvbSB0aGUgbWlkZGxlIGJhY2sgdG8gdGhlIGVuZCB0byBkZXRlcm1pbmUgdGhlIHBhdGguXG4gKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSB2X21hcCBBcnJheSBvZiBwYXRocy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBPbGQgc3RyaW5nIGZyYWdtZW50IHRvIGJlIGRpZmZlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBOZXcgc3RyaW5nIGZyYWdtZW50IHRvIGJlIGRpZmZlZC5cbiAqIEByZXR1cm4ge0FycmF5LjxBcnJheS48bnVtYmVyfHN0cmluZz4+fSBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqIEBwcml2YXRlXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfcGF0aDIgPSBmdW5jdGlvbih2X21hcCwgdGV4dDEsIHRleHQyKSB7XG4gIHZhciBwYXRoID0gW107XG4gIHZhciBwYXRoTGVuZ3RoID0gMDtcbiAgdmFyIHggPSB0ZXh0MS5sZW5ndGg7XG4gIHZhciB5ID0gdGV4dDIubGVuZ3RoO1xuICAvKiogQHR5cGUgez9udW1iZXJ9ICovXG4gIHZhciBsYXN0X29wID0gbnVsbDtcbiAgZm9yICh2YXIgZCA9IHZfbWFwLmxlbmd0aCAtIDI7IGQgPj0gMDsgZC0tKSB7XG4gICAgd2hpbGUgKDEpIHtcbiAgICAgIGlmICh2X21hcFtkXVsoeCAtIDEpICsgJywnICsgeV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB4LS07XG4gICAgICAgIGlmIChsYXN0X29wID09PSBESUZGX0RFTEVURSkge1xuICAgICAgICAgIHBhdGhbcGF0aExlbmd0aCAtIDFdWzFdICs9IHRleHQxLmNoYXJBdCh0ZXh0MS5sZW5ndGggLSB4IC0gMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aFtwYXRoTGVuZ3RoKytdID1cbiAgICAgICAgICAgICAgW0RJRkZfREVMRVRFLCB0ZXh0MS5jaGFyQXQodGV4dDEubGVuZ3RoIC0geCAtIDEpXTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0X29wID0gRElGRl9ERUxFVEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmICh2X21hcFtkXVt4ICsgJywnICsgKHkgLSAxKV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB5LS07XG4gICAgICAgIGlmIChsYXN0X29wID09PSBESUZGX0lOU0VSVCkge1xuICAgICAgICAgIHBhdGhbcGF0aExlbmd0aCAtIDFdWzFdICs9IHRleHQyLmNoYXJBdCh0ZXh0Mi5sZW5ndGggLSB5IC0gMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aFtwYXRoTGVuZ3RoKytdID1cbiAgICAgICAgICAgICAgW0RJRkZfSU5TRVJULCB0ZXh0Mi5jaGFyQXQodGV4dDIubGVuZ3RoIC0geSAtIDEpXTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0X29wID0gRElGRl9JTlNFUlQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeC0tO1xuICAgICAgICB5LS07XG4gICAgICAgIGlmICh0ZXh0MS5jaGFyQXQodGV4dDEubGVuZ3RoIC0geCAtIDEpICE9XG4gICAgICAgICAgICB0ZXh0Mi5jaGFyQXQodGV4dDIubGVuZ3RoIC0geSAtIDEpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBkaWFnb25hbC4gIENhblxcJ3QgaGFwcGVuLiAoZGlmZl9wYXRoMiknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdF9vcCA9PT0gRElGRl9FUVVBTCkge1xuICAgICAgICAgIHBhdGhbcGF0aExlbmd0aCAtIDFdWzFdICs9IHRleHQxLmNoYXJBdCh0ZXh0MS5sZW5ndGggLSB4IC0gMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aFtwYXRoTGVuZ3RoKytdID1cbiAgICAgICAgICAgICAgW0RJRkZfRVFVQUwsIHRleHQxLmNoYXJBdCh0ZXh0MS5sZW5ndGggLSB4IC0gMSldO1xuICAgICAgICB9XG4gICAgICAgIGxhc3Rfb3AgPSBESUZGX0VRVUFMO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcGF0aDtcbn07XG5cblxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIGNvbW1vbiBwcmVmaXggb2YgdHdvIHN0cmluZ3NcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBGaXJzdCBzdHJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgU2Vjb25kIHN0cmluZy5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGNvbW1vbiB0byB0aGUgc3RhcnQgb2YgZWFjaFxuICogICAgIHN0cmluZy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jb21tb25QcmVmaXggPSBmdW5jdGlvbih0ZXh0MSwgdGV4dDIpIHtcbiAgLy8gUXVpY2sgY2hlY2sgZm9yIGNvbW1vbiBudWxsIGNhc2VzLlxuICBpZiAoIXRleHQxIHx8ICF0ZXh0MiB8fCB0ZXh0MS5jaGFyQXQoMCkgIT0gdGV4dDIuY2hhckF0KDApKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgLy8gQmluYXJ5IHNlYXJjaC5cbiAgLy8gUGVyZm9ybWFuY2UgYW5hbHlzaXM6IGh0dHA6Ly9uZWlsLmZyYXNlci5uYW1lL25ld3MvMjAwNy8xMC8wOS9cbiAgdmFyIHBvaW50ZXJtaW4gPSAwO1xuICB2YXIgcG9pbnRlcm1heCA9IE1hdGgubWluKHRleHQxLmxlbmd0aCwgdGV4dDIubGVuZ3RoKTtcbiAgdmFyIHBvaW50ZXJtaWQgPSBwb2ludGVybWF4O1xuICB2YXIgcG9pbnRlcnN0YXJ0ID0gMDtcbiAgd2hpbGUgKHBvaW50ZXJtaW4gPCBwb2ludGVybWlkKSB7XG4gICAgaWYgKHRleHQxLnN1YnN0cmluZyhwb2ludGVyc3RhcnQsIHBvaW50ZXJtaWQpID09XG4gICAgICAgIHRleHQyLnN1YnN0cmluZyhwb2ludGVyc3RhcnQsIHBvaW50ZXJtaWQpKSB7XG4gICAgICBwb2ludGVybWluID0gcG9pbnRlcm1pZDtcbiAgICAgIHBvaW50ZXJzdGFydCA9IHBvaW50ZXJtaW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50ZXJtYXggPSBwb2ludGVybWlkO1xuICAgIH1cbiAgICBwb2ludGVybWlkID0gTWF0aC5mbG9vcigocG9pbnRlcm1heCAtIHBvaW50ZXJtaW4pIC8gMiArIHBvaW50ZXJtaW4pO1xuICB9XG4gIHJldHVybiBwb2ludGVybWlkO1xufTtcblxuXG4vKipcbiAqIERldGVybWluZSB0aGUgY29tbW9uIHN1ZmZpeCBvZiB0d28gc3RyaW5nc1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIEZpcnN0IHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBTZWNvbmQgc3RyaW5nLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgY29tbW9uIHRvIHRoZSBlbmQgb2YgZWFjaCBzdHJpbmcuXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfY29tbW9uU3VmZml4ID0gZnVuY3Rpb24odGV4dDEsIHRleHQyKSB7XG4gIC8vIFF1aWNrIGNoZWNrIGZvciBjb21tb24gbnVsbCBjYXNlcy5cbiAgaWYgKCF0ZXh0MSB8fCAhdGV4dDIgfHwgdGV4dDEuY2hhckF0KHRleHQxLmxlbmd0aCAtIDEpICE9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQyLmNoYXJBdCh0ZXh0Mi5sZW5ndGggLSAxKSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIC8vIEJpbmFyeSBzZWFyY2guXG4gIC8vIFBlcmZvcm1hbmNlIGFuYWx5c2lzOiBodHRwOi8vbmVpbC5mcmFzZXIubmFtZS9uZXdzLzIwMDcvMTAvMDkvXG4gIHZhciBwb2ludGVybWluID0gMDtcbiAgdmFyIHBvaW50ZXJtYXggPSBNYXRoLm1pbih0ZXh0MS5sZW5ndGgsIHRleHQyLmxlbmd0aCk7XG4gIHZhciBwb2ludGVybWlkID0gcG9pbnRlcm1heDtcbiAgdmFyIHBvaW50ZXJlbmQgPSAwO1xuICB3aGlsZSAocG9pbnRlcm1pbiA8IHBvaW50ZXJtaWQpIHtcbiAgICBpZiAodGV4dDEuc3Vic3RyaW5nKHRleHQxLmxlbmd0aCAtIHBvaW50ZXJtaWQsIHRleHQxLmxlbmd0aCAtIHBvaW50ZXJlbmQpID09XG4gICAgICAgIHRleHQyLnN1YnN0cmluZyh0ZXh0Mi5sZW5ndGggLSBwb2ludGVybWlkLCB0ZXh0Mi5sZW5ndGggLSBwb2ludGVyZW5kKSkge1xuICAgICAgcG9pbnRlcm1pbiA9IHBvaW50ZXJtaWQ7XG4gICAgICBwb2ludGVyZW5kID0gcG9pbnRlcm1pbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRlcm1heCA9IHBvaW50ZXJtaWQ7XG4gICAgfVxuICAgIHBvaW50ZXJtaWQgPSBNYXRoLmZsb29yKChwb2ludGVybWF4IC0gcG9pbnRlcm1pbikgLyAyICsgcG9pbnRlcm1pbik7XG4gIH1cbiAgcmV0dXJuIHBvaW50ZXJtaWQ7XG59O1xuXG5cbi8qKlxuICogRG8gdGhlIHR3byB0ZXh0cyBzaGFyZSBhIHN1YnN0cmluZyB3aGljaCBpcyBhdCBsZWFzdCBoYWxmIHRoZSBsZW5ndGggb2YgdGhlXG4gKiBsb25nZXIgdGV4dD9cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBGaXJzdCBzdHJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgU2Vjb25kIHN0cmluZy5cbiAqIEByZXR1cm4gez9BcnJheS48c3RyaW5nPn0gRml2ZSBlbGVtZW50IEFycmF5LCBjb250YWluaW5nIHRoZSBwcmVmaXggb2ZcbiAqICAgICB0ZXh0MSwgdGhlIHN1ZmZpeCBvZiB0ZXh0MSwgdGhlIHByZWZpeCBvZiB0ZXh0MiwgdGhlIHN1ZmZpeCBvZlxuICogICAgIHRleHQyIGFuZCB0aGUgY29tbW9uIG1pZGRsZS4gIE9yIG51bGwgaWYgdGhlcmUgd2FzIG5vIG1hdGNoLlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2hhbGZNYXRjaCA9IGZ1bmN0aW9uKHRleHQxLCB0ZXh0Mikge1xuICB2YXIgbG9uZ3RleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MSA6IHRleHQyO1xuICB2YXIgc2hvcnR0ZXh0ID0gdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gdGV4dDIgOiB0ZXh0MTtcbiAgaWYgKGxvbmd0ZXh0Lmxlbmd0aCA8IDEwIHx8IHNob3J0dGV4dC5sZW5ndGggPCAxKSB7XG4gICAgcmV0dXJuIG51bGw7ICAvLyBQb2ludGxlc3MuXG4gIH1cbiAgdmFyIGRtcCA9IHRoaXM7ICAvLyAndGhpcycgYmVjb21lcyAnd2luZG93JyBpbiBhIGNsb3N1cmUuXG5cbiAgLyoqXG4gICAqIERvZXMgYSBzdWJzdHJpbmcgb2Ygc2hvcnR0ZXh0IGV4aXN0IHdpdGhpbiBsb25ndGV4dCBzdWNoIHRoYXQgdGhlIHN1YnN0cmluZ1xuICAgKiBpcyBhdCBsZWFzdCBoYWxmIHRoZSBsZW5ndGggb2YgbG9uZ3RleHQ/XG4gICAqIENsb3N1cmUsIGJ1dCBkb2VzIG5vdCByZWZlcmVuY2UgYW55IGV4dGVybmFsIHZhcmlhYmxlcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxvbmd0ZXh0IExvbmdlciBzdHJpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzaG9ydHRleHQgU2hvcnRlciBzdHJpbmcuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpIFN0YXJ0IGluZGV4IG9mIHF1YXJ0ZXIgbGVuZ3RoIHN1YnN0cmluZyB3aXRoaW4gbG9uZ3RleHRcbiAgICogQHJldHVybiB7P0FycmF5LjxzdHJpbmc+fSBGaXZlIGVsZW1lbnQgQXJyYXksIGNvbnRhaW5pbmcgdGhlIHByZWZpeCBvZlxuICAgKiAgICAgbG9uZ3RleHQsIHRoZSBzdWZmaXggb2YgbG9uZ3RleHQsIHRoZSBwcmVmaXggb2Ygc2hvcnR0ZXh0LCB0aGUgc3VmZml4XG4gICAqICAgICBvZiBzaG9ydHRleHQgYW5kIHRoZSBjb21tb24gbWlkZGxlLiAgT3IgbnVsbCBpZiB0aGVyZSB3YXMgbm8gbWF0Y2guXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBkaWZmX2hhbGZNYXRjaEkobG9uZ3RleHQsIHNob3J0dGV4dCwgaSkge1xuICAgIC8vIFN0YXJ0IHdpdGggYSAxLzQgbGVuZ3RoIHN1YnN0cmluZyBhdCBwb3NpdGlvbiBpIGFzIGEgc2VlZC5cbiAgICB2YXIgc2VlZCA9IGxvbmd0ZXh0LnN1YnN0cmluZyhpLCBpICsgTWF0aC5mbG9vcihsb25ndGV4dC5sZW5ndGggLyA0KSk7XG4gICAgdmFyIGogPSAtMTtcbiAgICB2YXIgYmVzdF9jb21tb24gPSAnJztcbiAgICB2YXIgYmVzdF9sb25ndGV4dF9hLCBiZXN0X2xvbmd0ZXh0X2IsIGJlc3Rfc2hvcnR0ZXh0X2EsIGJlc3Rfc2hvcnR0ZXh0X2I7XG4gICAgd2hpbGUgKChqID0gc2hvcnR0ZXh0LmluZGV4T2Yoc2VlZCwgaiArIDEpKSAhPSAtMSkge1xuICAgICAgdmFyIHByZWZpeExlbmd0aCA9IGRtcC5kaWZmX2NvbW1vblByZWZpeChsb25ndGV4dC5zdWJzdHJpbmcoaSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3J0dGV4dC5zdWJzdHJpbmcoaikpO1xuICAgICAgdmFyIHN1ZmZpeExlbmd0aCA9IGRtcC5kaWZmX2NvbW1vblN1ZmZpeChsb25ndGV4dC5zdWJzdHJpbmcoMCwgaSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3J0dGV4dC5zdWJzdHJpbmcoMCwgaikpO1xuICAgICAgaWYgKGJlc3RfY29tbW9uLmxlbmd0aCA8IHN1ZmZpeExlbmd0aCArIHByZWZpeExlbmd0aCkge1xuICAgICAgICBiZXN0X2NvbW1vbiA9IHNob3J0dGV4dC5zdWJzdHJpbmcoaiAtIHN1ZmZpeExlbmd0aCwgaikgK1xuICAgICAgICAgICAgc2hvcnR0ZXh0LnN1YnN0cmluZyhqLCBqICsgcHJlZml4TGVuZ3RoKTtcbiAgICAgICAgYmVzdF9sb25ndGV4dF9hID0gbG9uZ3RleHQuc3Vic3RyaW5nKDAsIGkgLSBzdWZmaXhMZW5ndGgpO1xuICAgICAgICBiZXN0X2xvbmd0ZXh0X2IgPSBsb25ndGV4dC5zdWJzdHJpbmcoaSArIHByZWZpeExlbmd0aCk7XG4gICAgICAgIGJlc3Rfc2hvcnR0ZXh0X2EgPSBzaG9ydHRleHQuc3Vic3RyaW5nKDAsIGogLSBzdWZmaXhMZW5ndGgpO1xuICAgICAgICBiZXN0X3Nob3J0dGV4dF9iID0gc2hvcnR0ZXh0LnN1YnN0cmluZyhqICsgcHJlZml4TGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJlc3RfY29tbW9uLmxlbmd0aCA+PSBsb25ndGV4dC5sZW5ndGggLyAyKSB7XG4gICAgICByZXR1cm4gW2Jlc3RfbG9uZ3RleHRfYSwgYmVzdF9sb25ndGV4dF9iLFxuICAgICAgICAgICAgICBiZXN0X3Nob3J0dGV4dF9hLCBiZXN0X3Nob3J0dGV4dF9iLCBiZXN0X2NvbW1vbl07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZpcnN0IGNoZWNrIGlmIHRoZSBzZWNvbmQgcXVhcnRlciBpcyB0aGUgc2VlZCBmb3IgYSBoYWxmLW1hdGNoLlxuICB2YXIgaG0xID0gZGlmZl9oYWxmTWF0Y2hJKGxvbmd0ZXh0LCBzaG9ydHRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5jZWlsKGxvbmd0ZXh0Lmxlbmd0aCAvIDQpKTtcbiAgLy8gQ2hlY2sgYWdhaW4gYmFzZWQgb24gdGhlIHRoaXJkIHF1YXJ0ZXIuXG4gIHZhciBobTIgPSBkaWZmX2hhbGZNYXRjaEkobG9uZ3RleHQsIHNob3J0dGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmNlaWwobG9uZ3RleHQubGVuZ3RoIC8gMikpO1xuICB2YXIgaG07XG4gIGlmICghaG0xICYmICFobTIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmICghaG0yKSB7XG4gICAgaG0gPSBobTE7XG4gIH0gZWxzZSBpZiAoIWhtMSkge1xuICAgIGhtID0gaG0yO1xuICB9IGVsc2Uge1xuICAgIC8vIEJvdGggbWF0Y2hlZC4gIFNlbGVjdCB0aGUgbG9uZ2VzdC5cbiAgICBobSA9IGhtMVs0XS5sZW5ndGggPiBobTJbNF0ubGVuZ3RoID8gaG0xIDogaG0yO1xuICB9XG5cbiAgLy8gQSBoYWxmLW1hdGNoIHdhcyBmb3VuZCwgc29ydCBvdXQgdGhlIHJldHVybiBkYXRhLlxuICB2YXIgdGV4dDFfYSwgdGV4dDFfYiwgdGV4dDJfYSwgdGV4dDJfYjtcbiAgaWYgKHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCkge1xuICAgIHRleHQxX2EgPSBobVswXTtcbiAgICB0ZXh0MV9iID0gaG1bMV07XG4gICAgdGV4dDJfYSA9IGhtWzJdO1xuICAgIHRleHQyX2IgPSBobVszXTtcbiAgfSBlbHNlIHtcbiAgICB0ZXh0Ml9hID0gaG1bMF07XG4gICAgdGV4dDJfYiA9IGhtWzFdO1xuICAgIHRleHQxX2EgPSBobVsyXTtcbiAgICB0ZXh0MV9iID0gaG1bM107XG4gIH1cbiAgdmFyIG1pZF9jb21tb24gPSBobVs0XTtcbiAgcmV0dXJuIFt0ZXh0MV9hLCB0ZXh0MV9iLCB0ZXh0Ml9hLCB0ZXh0Ml9iLCBtaWRfY29tbW9uXTtcbn07XG5cblxuLyoqXG4gKiBSZWR1Y2UgdGhlIG51bWJlciBvZiBlZGl0cyBieSBlbGltaW5hdGluZyBzZW1hbnRpY2FsbHkgdHJpdmlhbCBlcXVhbGl0aWVzLlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcnxzdHJpbmc+Pn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfY2xlYW51cFNlbWFudGljID0gZnVuY3Rpb24oZGlmZnMpIHtcbiAgdmFyIGNoYW5nZXMgPSBmYWxzZTtcbiAgdmFyIGVxdWFsaXRpZXMgPSBbXTsgIC8vIFN0YWNrIG9mIGluZGljZXMgd2hlcmUgZXF1YWxpdGllcyBhcmUgZm91bmQuXG4gIHZhciBlcXVhbGl0aWVzTGVuZ3RoID0gMDsgIC8vIEtlZXBpbmcgb3VyIG93biBsZW5ndGggdmFyIGlzIGZhc3RlciBpbiBKUy5cbiAgdmFyIGxhc3RlcXVhbGl0eSA9IG51bGw7ICAvLyBBbHdheXMgZXF1YWwgdG8gZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoLTFdWzFdXG4gIHZhciBwb2ludGVyID0gMDsgIC8vIEluZGV4IG9mIGN1cnJlbnQgcG9zaXRpb24uXG4gIC8vIE51bWJlciBvZiBjaGFyYWN0ZXJzIHRoYXQgY2hhbmdlZCBwcmlvciB0byB0aGUgZXF1YWxpdHkuXG4gIHZhciBsZW5ndGhfY2hhbmdlczEgPSAwO1xuICAvLyBOdW1iZXIgb2YgY2hhcmFjdGVycyB0aGF0IGNoYW5nZWQgYWZ0ZXIgdGhlIGVxdWFsaXR5LlxuICB2YXIgbGVuZ3RoX2NoYW5nZXMyID0gMDtcbiAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGgpIHtcbiAgICBpZiAoZGlmZnNbcG9pbnRlcl1bMF0gPT0gRElGRl9FUVVBTCkgeyAgLy8gZXF1YWxpdHkgZm91bmRcbiAgICAgIGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCsrXSA9IHBvaW50ZXI7XG4gICAgICBsZW5ndGhfY2hhbmdlczEgPSBsZW5ndGhfY2hhbmdlczI7XG4gICAgICBsZW5ndGhfY2hhbmdlczIgPSAwO1xuICAgICAgbGFzdGVxdWFsaXR5ID0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgfSBlbHNlIHsgIC8vIGFuIGluc2VydGlvbiBvciBkZWxldGlvblxuICAgICAgbGVuZ3RoX2NoYW5nZXMyICs9IGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aDtcbiAgICAgIGlmIChsYXN0ZXF1YWxpdHkgIT09IG51bGwgJiYgKGxhc3RlcXVhbGl0eS5sZW5ndGggPD0gbGVuZ3RoX2NoYW5nZXMxKSAmJlxuICAgICAgICAgIChsYXN0ZXF1YWxpdHkubGVuZ3RoIDw9IGxlbmd0aF9jaGFuZ2VzMikpIHtcbiAgICAgICAgLy8gRHVwbGljYXRlIHJlY29yZFxuICAgICAgICBkaWZmcy5zcGxpY2UoZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0sIDAsXG4gICAgICAgICAgICAgICAgICAgICBbRElGRl9ERUxFVEUsIGxhc3RlcXVhbGl0eV0pO1xuICAgICAgICAvLyBDaGFuZ2Ugc2Vjb25kIGNvcHkgdG8gaW5zZXJ0LlxuICAgICAgICBkaWZmc1tlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSArIDFdWzBdID0gRElGRl9JTlNFUlQ7XG4gICAgICAgIC8vIFRocm93IGF3YXkgdGhlIGVxdWFsaXR5IHdlIGp1c3QgZGVsZXRlZC5cbiAgICAgICAgZXF1YWxpdGllc0xlbmd0aC0tO1xuICAgICAgICAvLyBUaHJvdyBhd2F5IHRoZSBwcmV2aW91cyBlcXVhbGl0eSAoaXQgbmVlZHMgdG8gYmUgcmVldmFsdWF0ZWQpLlxuICAgICAgICBlcXVhbGl0aWVzTGVuZ3RoLS07XG4gICAgICAgIHBvaW50ZXIgPSBlcXVhbGl0aWVzTGVuZ3RoID4gMCA/IGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdIDogLTE7XG4gICAgICAgIGxlbmd0aF9jaGFuZ2VzMSA9IDA7ICAvLyBSZXNldCB0aGUgY291bnRlcnMuXG4gICAgICAgIGxlbmd0aF9jaGFuZ2VzMiA9IDA7XG4gICAgICAgIGxhc3RlcXVhbGl0eSA9IG51bGw7XG4gICAgICAgIGNoYW5nZXMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBwb2ludGVyKys7XG4gIH1cbiAgaWYgKGNoYW5nZXMpIHtcbiAgICB0aGlzLmRpZmZfY2xlYW51cE1lcmdlKGRpZmZzKTtcbiAgfVxuICB0aGlzLmRpZmZfY2xlYW51cFNlbWFudGljTG9zc2xlc3MoZGlmZnMpO1xufTtcblxuXG4vKipcbiAqIExvb2sgZm9yIHNpbmdsZSBlZGl0cyBzdXJyb3VuZGVkIG9uIGJvdGggc2lkZXMgYnkgZXF1YWxpdGllc1xuICogd2hpY2ggY2FuIGJlIHNoaWZ0ZWQgc2lkZXdheXMgdG8gYWxpZ24gdGhlIGVkaXQgdG8gYSB3b3JkIGJvdW5kYXJ5LlxuICogZS5nOiBUaGUgYzxpbnM+YXQgYzwvaW5zPmFtZS4gLT4gVGhlIDxpbnM+Y2F0IDwvaW5zPmNhbWUuXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyfHN0cmluZz4+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jbGVhbnVwU2VtYW50aWNMb3NzbGVzcyA9IGZ1bmN0aW9uKGRpZmZzKSB7XG4gIC8vIERlZmluZSBzb21lIHJlZ2V4IHBhdHRlcm5zIGZvciBtYXRjaGluZyBib3VuZGFyaWVzLlxuICB2YXIgcHVuY3R1YXRpb24gPSAvW15hLXpBLVowLTldLztcbiAgdmFyIHdoaXRlc3BhY2UgPSAvXFxzLztcbiAgdmFyIGxpbmVicmVhayA9IC9bXFxyXFxuXS87XG4gIHZhciBibGFua2xpbmVFbmQgPSAvXFxuXFxyP1xcbiQvO1xuICB2YXIgYmxhbmtsaW5lU3RhcnQgPSAvXlxccj9cXG5cXHI/XFxuLztcblxuICAvKipcbiAgICogR2l2ZW4gdHdvIHN0cmluZ3MsIGNvbXB1dGUgYSBzY29yZSByZXByZXNlbnRpbmcgd2hldGhlciB0aGUgaW50ZXJuYWxcbiAgICogYm91bmRhcnkgZmFsbHMgb24gbG9naWNhbCBib3VuZGFyaWVzLlxuICAgKiBTY29yZXMgcmFuZ2UgZnJvbSA1IChiZXN0KSB0byAwICh3b3JzdCkuXG4gICAqIENsb3N1cmUsIG1ha2VzIHJlZmVyZW5jZSB0byByZWdleCBwYXR0ZXJucyBkZWZpbmVkIGFib3ZlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb25lIEZpcnN0IHN0cmluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR3byBTZWNvbmQgc3RyaW5nLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzY29yZS5cbiAgICovXG4gIGZ1bmN0aW9uIGRpZmZfY2xlYW51cFNlbWFudGljU2NvcmUob25lLCB0d28pIHtcbiAgICBpZiAoIW9uZSB8fCAhdHdvKSB7XG4gICAgICAvLyBFZGdlcyBhcmUgdGhlIGJlc3QuXG4gICAgICByZXR1cm4gNTtcbiAgICB9XG5cbiAgICAvLyBFYWNoIHBvcnQgb2YgdGhpcyBmdW5jdGlvbiBiZWhhdmVzIHNsaWdodGx5IGRpZmZlcmVudGx5IGR1ZSB0b1xuICAgIC8vIHN1YnRsZSBkaWZmZXJlbmNlcyBpbiBlYWNoIGxhbmd1YWdlJ3MgZGVmaW5pdGlvbiBvZiB0aGluZ3MgbGlrZVxuICAgIC8vICd3aGl0ZXNwYWNlJy4gIFNpbmNlIHRoaXMgZnVuY3Rpb24ncyBwdXJwb3NlIGlzIGxhcmdlbHkgY29zbWV0aWMsXG4gICAgLy8gdGhlIGNob2ljZSBoYXMgYmVlbiBtYWRlIHRvIHVzZSBlYWNoIGxhbmd1YWdlJ3MgbmF0aXZlIGZlYXR1cmVzXG4gICAgLy8gcmF0aGVyIHRoYW4gZm9yY2UgdG90YWwgY29uZm9ybWl0eS5cbiAgICB2YXIgc2NvcmUgPSAwO1xuICAgIC8vIE9uZSBwb2ludCBmb3Igbm9uLWFscGhhbnVtZXJpYy5cbiAgICBpZiAob25lLmNoYXJBdChvbmUubGVuZ3RoIC0gMSkubWF0Y2gocHVuY3R1YXRpb24pIHx8XG4gICAgICAgIHR3by5jaGFyQXQoMCkubWF0Y2gocHVuY3R1YXRpb24pKSB7XG4gICAgICBzY29yZSsrO1xuICAgICAgLy8gVHdvIHBvaW50cyBmb3Igd2hpdGVzcGFjZS5cbiAgICAgIGlmIChvbmUuY2hhckF0KG9uZS5sZW5ndGggLSAxKS5tYXRjaCh3aGl0ZXNwYWNlKSB8fFxuICAgICAgICAgIHR3by5jaGFyQXQoMCkubWF0Y2god2hpdGVzcGFjZSkpIHtcbiAgICAgICAgc2NvcmUrKztcbiAgICAgICAgLy8gVGhyZWUgcG9pbnRzIGZvciBsaW5lIGJyZWFrcy5cbiAgICAgICAgaWYgKG9uZS5jaGFyQXQob25lLmxlbmd0aCAtIDEpLm1hdGNoKGxpbmVicmVhaykgfHxcbiAgICAgICAgICAgIHR3by5jaGFyQXQoMCkubWF0Y2gobGluZWJyZWFrKSkge1xuICAgICAgICAgIHNjb3JlKys7XG4gICAgICAgICAgLy8gRm91ciBwb2ludHMgZm9yIGJsYW5rIGxpbmVzLlxuICAgICAgICAgIGlmIChvbmUubWF0Y2goYmxhbmtsaW5lRW5kKSB8fCB0d28ubWF0Y2goYmxhbmtsaW5lU3RhcnQpKSB7XG4gICAgICAgICAgICBzY29yZSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2NvcmU7XG4gIH1cblxuICB2YXIgcG9pbnRlciA9IDE7XG4gIC8vIEludGVudGlvbmFsbHkgaWdub3JlIHRoZSBmaXJzdCBhbmQgbGFzdCBlbGVtZW50IChkb24ndCBuZWVkIGNoZWNraW5nKS5cbiAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGggLSAxKSB7XG4gICAgaWYgKGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PSBESUZGX0VRVUFMICYmXG4gICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVswXSA9PSBESUZGX0VRVUFMKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgc2luZ2xlIGVkaXQgc3Vycm91bmRlZCBieSBlcXVhbGl0aWVzLlxuICAgICAgdmFyIGVxdWFsaXR5MSA9IGRpZmZzW3BvaW50ZXIgLSAxXVsxXTtcbiAgICAgIHZhciBlZGl0ID0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICB2YXIgZXF1YWxpdHkyID0gZGlmZnNbcG9pbnRlciArIDFdWzFdO1xuXG4gICAgICAvLyBGaXJzdCwgc2hpZnQgdGhlIGVkaXQgYXMgZmFyIGxlZnQgYXMgcG9zc2libGUuXG4gICAgICB2YXIgY29tbW9uT2Zmc2V0ID0gdGhpcy5kaWZmX2NvbW1vblN1ZmZpeChlcXVhbGl0eTEsIGVkaXQpO1xuICAgICAgaWYgKGNvbW1vbk9mZnNldCkge1xuICAgICAgICB2YXIgY29tbW9uU3RyaW5nID0gZWRpdC5zdWJzdHJpbmcoZWRpdC5sZW5ndGggLSBjb21tb25PZmZzZXQpO1xuICAgICAgICBlcXVhbGl0eTEgPSBlcXVhbGl0eTEuc3Vic3RyaW5nKDAsIGVxdWFsaXR5MS5sZW5ndGggLSBjb21tb25PZmZzZXQpO1xuICAgICAgICBlZGl0ID0gY29tbW9uU3RyaW5nICsgZWRpdC5zdWJzdHJpbmcoMCwgZWRpdC5sZW5ndGggLSBjb21tb25PZmZzZXQpO1xuICAgICAgICBlcXVhbGl0eTIgPSBjb21tb25TdHJpbmcgKyBlcXVhbGl0eTI7XG4gICAgICB9XG5cbiAgICAgIC8vIFNlY29uZCwgc3RlcCBjaGFyYWN0ZXIgYnkgY2hhcmFjdGVyIHJpZ2h0LCBsb29raW5nIGZvciB0aGUgYmVzdCBmaXQuXG4gICAgICB2YXIgYmVzdEVxdWFsaXR5MSA9IGVxdWFsaXR5MTtcbiAgICAgIHZhciBiZXN0RWRpdCA9IGVkaXQ7XG4gICAgICB2YXIgYmVzdEVxdWFsaXR5MiA9IGVxdWFsaXR5MjtcbiAgICAgIHZhciBiZXN0U2NvcmUgPSBkaWZmX2NsZWFudXBTZW1hbnRpY1Njb3JlKGVxdWFsaXR5MSwgZWRpdCkgK1xuICAgICAgICAgIGRpZmZfY2xlYW51cFNlbWFudGljU2NvcmUoZWRpdCwgZXF1YWxpdHkyKTtcbiAgICAgIHdoaWxlIChlZGl0LmNoYXJBdCgwKSA9PT0gZXF1YWxpdHkyLmNoYXJBdCgwKSkge1xuICAgICAgICBlcXVhbGl0eTEgKz0gZWRpdC5jaGFyQXQoMCk7XG4gICAgICAgIGVkaXQgPSBlZGl0LnN1YnN0cmluZygxKSArIGVxdWFsaXR5Mi5jaGFyQXQoMCk7XG4gICAgICAgIGVxdWFsaXR5MiA9IGVxdWFsaXR5Mi5zdWJzdHJpbmcoMSk7XG4gICAgICAgIHZhciBzY29yZSA9IGRpZmZfY2xlYW51cFNlbWFudGljU2NvcmUoZXF1YWxpdHkxLCBlZGl0KSArXG4gICAgICAgICAgICBkaWZmX2NsZWFudXBTZW1hbnRpY1Njb3JlKGVkaXQsIGVxdWFsaXR5Mik7XG4gICAgICAgIC8vIFRoZSA+PSBlbmNvdXJhZ2VzIHRyYWlsaW5nIHJhdGhlciB0aGFuIGxlYWRpbmcgd2hpdGVzcGFjZSBvbiBlZGl0cy5cbiAgICAgICAgaWYgKHNjb3JlID49IGJlc3RTY29yZSkge1xuICAgICAgICAgIGJlc3RTY29yZSA9IHNjb3JlO1xuICAgICAgICAgIGJlc3RFcXVhbGl0eTEgPSBlcXVhbGl0eTE7XG4gICAgICAgICAgYmVzdEVkaXQgPSBlZGl0O1xuICAgICAgICAgIGJlc3RFcXVhbGl0eTIgPSBlcXVhbGl0eTI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGRpZmZzW3BvaW50ZXIgLSAxXVsxXSAhPSBiZXN0RXF1YWxpdHkxKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgYW4gaW1wcm92ZW1lbnQsIHNhdmUgaXQgYmFjayB0byB0aGUgZGlmZi5cbiAgICAgICAgaWYgKGJlc3RFcXVhbGl0eTEpIHtcbiAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0gPSBiZXN0RXF1YWxpdHkxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gMSwgMSk7XG4gICAgICAgICAgcG9pbnRlci0tO1xuICAgICAgICB9XG4gICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdID0gYmVzdEVkaXQ7XG4gICAgICAgIGlmIChiZXN0RXF1YWxpdHkyKSB7XG4gICAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzFdID0gYmVzdEVxdWFsaXR5MjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciArIDEsIDEpO1xuICAgICAgICAgIHBvaW50ZXItLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBwb2ludGVyKys7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBSZWR1Y2UgdGhlIG51bWJlciBvZiBlZGl0cyBieSBlbGltaW5hdGluZyBvcGVyYXRpb25hbGx5IHRyaXZpYWwgZXF1YWxpdGllcy5cbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXJ8c3RyaW5nPj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2NsZWFudXBFZmZpY2llbmN5ID0gZnVuY3Rpb24oZGlmZnMpIHtcbiAgdmFyIGNoYW5nZXMgPSBmYWxzZTtcbiAgdmFyIGVxdWFsaXRpZXMgPSBbXTsgIC8vIFN0YWNrIG9mIGluZGljZXMgd2hlcmUgZXF1YWxpdGllcyBhcmUgZm91bmQuXG4gIHZhciBlcXVhbGl0aWVzTGVuZ3RoID0gMDsgIC8vIEtlZXBpbmcgb3VyIG93biBsZW5ndGggdmFyIGlzIGZhc3RlciBpbiBKUy5cbiAgdmFyIGxhc3RlcXVhbGl0eSA9ICcnOyAgLy8gQWx3YXlzIGVxdWFsIHRvIGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aC0xXVsxXVxuICB2YXIgcG9pbnRlciA9IDA7ICAvLyBJbmRleCBvZiBjdXJyZW50IHBvc2l0aW9uLlxuICAvLyBJcyB0aGVyZSBhbiBpbnNlcnRpb24gb3BlcmF0aW9uIGJlZm9yZSB0aGUgbGFzdCBlcXVhbGl0eS5cbiAgdmFyIHByZV9pbnMgPSBmYWxzZTtcbiAgLy8gSXMgdGhlcmUgYSBkZWxldGlvbiBvcGVyYXRpb24gYmVmb3JlIHRoZSBsYXN0IGVxdWFsaXR5LlxuICB2YXIgcHJlX2RlbCA9IGZhbHNlO1xuICAvLyBJcyB0aGVyZSBhbiBpbnNlcnRpb24gb3BlcmF0aW9uIGFmdGVyIHRoZSBsYXN0IGVxdWFsaXR5LlxuICB2YXIgcG9zdF9pbnMgPSBmYWxzZTtcbiAgLy8gSXMgdGhlcmUgYSBkZWxldGlvbiBvcGVyYXRpb24gYWZ0ZXIgdGhlIGxhc3QgZXF1YWxpdHkuXG4gIHZhciBwb3N0X2RlbCA9IGZhbHNlO1xuICB3aGlsZSAocG9pbnRlciA8IGRpZmZzLmxlbmd0aCkge1xuICAgIGlmIChkaWZmc1twb2ludGVyXVswXSA9PSBESUZGX0VRVUFMKSB7ICAvLyBlcXVhbGl0eSBmb3VuZFxuICAgICAgaWYgKGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aCA8IHRoaXMuRGlmZl9FZGl0Q29zdCAmJlxuICAgICAgICAgIChwb3N0X2lucyB8fCBwb3N0X2RlbCkpIHtcbiAgICAgICAgLy8gQ2FuZGlkYXRlIGZvdW5kLlxuICAgICAgICBlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGgrK10gPSBwb2ludGVyO1xuICAgICAgICBwcmVfaW5zID0gcG9zdF9pbnM7XG4gICAgICAgIHByZV9kZWwgPSBwb3N0X2RlbDtcbiAgICAgICAgbGFzdGVxdWFsaXR5ID0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb3QgYSBjYW5kaWRhdGUsIGFuZCBjYW4gbmV2ZXIgYmVjb21lIG9uZS5cbiAgICAgICAgZXF1YWxpdGllc0xlbmd0aCA9IDA7XG4gICAgICAgIGxhc3RlcXVhbGl0eSA9ICcnO1xuICAgICAgfVxuICAgICAgcG9zdF9pbnMgPSBwb3N0X2RlbCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7ICAvLyBhbiBpbnNlcnRpb24gb3IgZGVsZXRpb25cbiAgICAgIGlmIChkaWZmc1twb2ludGVyXVswXSA9PSBESUZGX0RFTEVURSkge1xuICAgICAgICBwb3N0X2RlbCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3N0X2lucyA9IHRydWU7XG4gICAgICB9XG4gICAgICAvKlxuICAgICAgICogRml2ZSB0eXBlcyB0byBiZSBzcGxpdDpcbiAgICAgICAqIDxpbnM+QTwvaW5zPjxkZWw+QjwvZGVsPlhZPGlucz5DPC9pbnM+PGRlbD5EPC9kZWw+XG4gICAgICAgKiA8aW5zPkE8L2lucz5YPGlucz5DPC9pbnM+PGRlbD5EPC9kZWw+XG4gICAgICAgKiA8aW5zPkE8L2lucz48ZGVsPkI8L2RlbD5YPGlucz5DPC9pbnM+XG4gICAgICAgKiA8aW5zPkE8L2RlbD5YPGlucz5DPC9pbnM+PGRlbD5EPC9kZWw+XG4gICAgICAgKiA8aW5zPkE8L2lucz48ZGVsPkI8L2RlbD5YPGRlbD5DPC9kZWw+XG4gICAgICAgKi9cbiAgICAgIGlmIChsYXN0ZXF1YWxpdHkgJiYgKChwcmVfaW5zICYmIHByZV9kZWwgJiYgcG9zdF9pbnMgJiYgcG9zdF9kZWwpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoKGxhc3RlcXVhbGl0eS5sZW5ndGggPCB0aGlzLkRpZmZfRWRpdENvc3QgLyAyKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwcmVfaW5zICsgcHJlX2RlbCArIHBvc3RfaW5zICsgcG9zdF9kZWwpID09IDMpKSkge1xuICAgICAgICAvLyBEdXBsaWNhdGUgcmVjb3JkXG4gICAgICAgIGRpZmZzLnNwbGljZShlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSwgMCxcbiAgICAgICAgICAgICAgICAgICAgIFtESUZGX0RFTEVURSwgbGFzdGVxdWFsaXR5XSk7XG4gICAgICAgIC8vIENoYW5nZSBzZWNvbmQgY29weSB0byBpbnNlcnQuXG4gICAgICAgIGRpZmZzW2VxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdICsgMV1bMF0gPSBESUZGX0lOU0VSVDtcbiAgICAgICAgZXF1YWxpdGllc0xlbmd0aC0tOyAgLy8gVGhyb3cgYXdheSB0aGUgZXF1YWxpdHkgd2UganVzdCBkZWxldGVkO1xuICAgICAgICBsYXN0ZXF1YWxpdHkgPSAnJztcbiAgICAgICAgaWYgKHByZV9pbnMgJiYgcHJlX2RlbCkge1xuICAgICAgICAgIC8vIE5vIGNoYW5nZXMgbWFkZSB3aGljaCBjb3VsZCBhZmZlY3QgcHJldmlvdXMgZW50cnksIGtlZXAgZ29pbmcuXG4gICAgICAgICAgcG9zdF9pbnMgPSBwb3N0X2RlbCA9IHRydWU7XG4gICAgICAgICAgZXF1YWxpdGllc0xlbmd0aCA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXF1YWxpdGllc0xlbmd0aC0tOyAgLy8gVGhyb3cgYXdheSB0aGUgcHJldmlvdXMgZXF1YWxpdHk7XG4gICAgICAgICAgcG9pbnRlciA9IGVxdWFsaXRpZXNMZW5ndGggPiAwID9cbiAgICAgICAgICAgICAgZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0gOiAtMTtcbiAgICAgICAgICBwb3N0X2lucyA9IHBvc3RfZGVsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY2hhbmdlcyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHBvaW50ZXIrKztcbiAgfVxuXG4gIGlmIChjaGFuZ2VzKSB7XG4gICAgdGhpcy5kaWZmX2NsZWFudXBNZXJnZShkaWZmcyk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBSZW9yZGVyIGFuZCBtZXJnZSBsaWtlIGVkaXQgc2VjdGlvbnMuICBNZXJnZSBlcXVhbGl0aWVzLlxuICogQW55IGVkaXQgc2VjdGlvbiBjYW4gbW92ZSBhcyBsb25nIGFzIGl0IGRvZXNuJ3QgY3Jvc3MgYW4gZXF1YWxpdHkuXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyfHN0cmluZz4+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jbGVhbnVwTWVyZ2UgPSBmdW5jdGlvbihkaWZmcykge1xuICBkaWZmcy5wdXNoKFtESUZGX0VRVUFMLCAnJ10pOyAgLy8gQWRkIGEgZHVtbXkgZW50cnkgYXQgdGhlIGVuZC5cbiAgdmFyIHBvaW50ZXIgPSAwO1xuICB2YXIgY291bnRfZGVsZXRlID0gMDtcbiAgdmFyIGNvdW50X2luc2VydCA9IDA7XG4gIHZhciB0ZXh0X2RlbGV0ZSA9ICcnO1xuICB2YXIgdGV4dF9pbnNlcnQgPSAnJztcbiAgdmFyIGNvbW1vbmxlbmd0aDtcbiAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGgpIHtcbiAgICBzd2l0Y2ggKGRpZmZzW3BvaW50ZXJdWzBdKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICBjb3VudF9pbnNlcnQrKztcbiAgICAgICAgdGV4dF9pbnNlcnQgKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxuICAgICAgICBjb3VudF9kZWxldGUrKztcbiAgICAgICAgdGV4dF9kZWxldGUgKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgIC8vIFVwb24gcmVhY2hpbmcgYW4gZXF1YWxpdHksIGNoZWNrIGZvciBwcmlvciByZWR1bmRhbmNpZXMuXG4gICAgICAgIGlmIChjb3VudF9kZWxldGUgIT09IDAgfHwgY291bnRfaW5zZXJ0ICE9PSAwKSB7XG4gICAgICAgICAgaWYgKGNvdW50X2RlbGV0ZSAhPT0gMCAmJiBjb3VudF9pbnNlcnQgIT09IDApIHtcbiAgICAgICAgICAgIC8vIEZhY3RvciBvdXQgYW55IGNvbW1vbiBwcmVmaXhpZXMuXG4gICAgICAgICAgICBjb21tb25sZW5ndGggPSB0aGlzLmRpZmZfY29tbW9uUHJlZml4KHRleHRfaW5zZXJ0LCB0ZXh0X2RlbGV0ZSk7XG4gICAgICAgICAgICBpZiAoY29tbW9ubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgIGlmICgocG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCkgPiAwICYmXG4gICAgICAgICAgICAgICAgICBkaWZmc1twb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0IC0gMV1bMF0gPT1cbiAgICAgICAgICAgICAgICAgIERJRkZfRVFVQUwpIHtcbiAgICAgICAgICAgICAgICBkaWZmc1twb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0IC0gMV1bMV0gKz1cbiAgICAgICAgICAgICAgICAgICAgdGV4dF9pbnNlcnQuc3Vic3RyaW5nKDAsIGNvbW1vbmxlbmd0aCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlmZnMuc3BsaWNlKDAsIDAsIFtESUZGX0VRVUFMLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0X2luc2VydC5zdWJzdHJpbmcoMCwgY29tbW9ubGVuZ3RoKV0pO1xuICAgICAgICAgICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0ZXh0X2luc2VydCA9IHRleHRfaW5zZXJ0LnN1YnN0cmluZyhjb21tb25sZW5ndGgpO1xuICAgICAgICAgICAgICB0ZXh0X2RlbGV0ZSA9IHRleHRfZGVsZXRlLnN1YnN0cmluZyhjb21tb25sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmFjdG9yIG91dCBhbnkgY29tbW9uIHN1ZmZpeGllcy5cbiAgICAgICAgICAgIGNvbW1vbmxlbmd0aCA9IHRoaXMuZGlmZl9jb21tb25TdWZmaXgodGV4dF9pbnNlcnQsIHRleHRfZGVsZXRlKTtcbiAgICAgICAgICAgIGlmIChjb21tb25sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0gPSB0ZXh0X2luc2VydC5zdWJzdHJpbmcodGV4dF9pbnNlcnQubGVuZ3RoIC1cbiAgICAgICAgICAgICAgICAgIGNvbW1vbmxlbmd0aCkgKyBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgICAgICAgICAgdGV4dF9pbnNlcnQgPSB0ZXh0X2luc2VydC5zdWJzdHJpbmcoMCwgdGV4dF9pbnNlcnQubGVuZ3RoIC1cbiAgICAgICAgICAgICAgICAgIGNvbW1vbmxlbmd0aCk7XG4gICAgICAgICAgICAgIHRleHRfZGVsZXRlID0gdGV4dF9kZWxldGUuc3Vic3RyaW5nKDAsIHRleHRfZGVsZXRlLmxlbmd0aCAtXG4gICAgICAgICAgICAgICAgICBjb21tb25sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBEZWxldGUgdGhlIG9mZmVuZGluZyByZWNvcmRzIGFuZCBhZGQgdGhlIG1lcmdlZCBvbmVzLlxuICAgICAgICAgIGlmIChjb3VudF9kZWxldGUgPT09IDApIHtcbiAgICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0LFxuICAgICAgICAgICAgICAgIGNvdW50X2RlbGV0ZSArIGNvdW50X2luc2VydCwgW0RJRkZfSU5TRVJULCB0ZXh0X2luc2VydF0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY291bnRfaW5zZXJ0ID09PSAwKSB7XG4gICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCxcbiAgICAgICAgICAgICAgICBjb3VudF9kZWxldGUgKyBjb3VudF9pbnNlcnQsIFtESUZGX0RFTEVURSwgdGV4dF9kZWxldGVdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSBjb3VudF9kZWxldGUgLSBjb3VudF9pbnNlcnQsXG4gICAgICAgICAgICAgICAgY291bnRfZGVsZXRlICsgY291bnRfaW5zZXJ0LCBbRElGRl9ERUxFVEUsIHRleHRfZGVsZXRlXSxcbiAgICAgICAgICAgICAgICBbRElGRl9JTlNFUlQsIHRleHRfaW5zZXJ0XSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvaW50ZXIgPSBwb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0ICtcbiAgICAgICAgICAgICAgICAgICAgKGNvdW50X2RlbGV0ZSA/IDEgOiAwKSArIChjb3VudF9pbnNlcnQgPyAxIDogMCkgKyAxO1xuICAgICAgICB9IGVsc2UgaWYgKHBvaW50ZXIgIT09IDAgJiYgZGlmZnNbcG9pbnRlciAtIDFdWzBdID09IERJRkZfRVFVQUwpIHtcbiAgICAgICAgICAvLyBNZXJnZSB0aGlzIGVxdWFsaXR5IHdpdGggdGhlIHByZXZpb3VzIG9uZS5cbiAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0gKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIsIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgfVxuICAgICAgICBjb3VudF9pbnNlcnQgPSAwO1xuICAgICAgICBjb3VudF9kZWxldGUgPSAwO1xuICAgICAgICB0ZXh0X2RlbGV0ZSA9ICcnO1xuICAgICAgICB0ZXh0X2luc2VydCA9ICcnO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzFdID09PSAnJykge1xuICAgIGRpZmZzLnBvcCgpOyAgLy8gUmVtb3ZlIHRoZSBkdW1teSBlbnRyeSBhdCB0aGUgZW5kLlxuICB9XG5cbiAgLy8gU2Vjb25kIHBhc3M6IGxvb2sgZm9yIHNpbmdsZSBlZGl0cyBzdXJyb3VuZGVkIG9uIGJvdGggc2lkZXMgYnkgZXF1YWxpdGllc1xuICAvLyB3aGljaCBjYW4gYmUgc2hpZnRlZCBzaWRld2F5cyB0byBlbGltaW5hdGUgYW4gZXF1YWxpdHkuXG4gIC8vIGUuZzogQTxpbnM+QkE8L2lucz5DIC0+IDxpbnM+QUI8L2lucz5BQ1xuICB2YXIgY2hhbmdlcyA9IGZhbHNlO1xuICBwb2ludGVyID0gMTtcbiAgLy8gSW50ZW50aW9uYWxseSBpZ25vcmUgdGhlIGZpcnN0IGFuZCBsYXN0IGVsZW1lbnQgKGRvbid0IG5lZWQgY2hlY2tpbmcpLlxuICB3aGlsZSAocG9pbnRlciA8IGRpZmZzLmxlbmd0aCAtIDEpIHtcbiAgICBpZiAoZGlmZnNbcG9pbnRlciAtIDFdWzBdID09IERJRkZfRVFVQUwgJiZcbiAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzBdID09IERJRkZfRVFVQUwpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBzaW5nbGUgZWRpdCBzdXJyb3VuZGVkIGJ5IGVxdWFsaXRpZXMuXG4gICAgICBpZiAoZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aCAtXG4gICAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdLmxlbmd0aCkgPT0gZGlmZnNbcG9pbnRlciAtIDFdWzFdKSB7XG4gICAgICAgIC8vIFNoaWZ0IHRoZSBlZGl0IG92ZXIgdGhlIHByZXZpb3VzIGVxdWFsaXR5LlxuICAgICAgICBkaWZmc1twb2ludGVyXVsxXSA9IGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArXG4gICAgICAgICAgICBkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoMCwgZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0ubGVuZ3RoKTtcbiAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzFdID0gZGlmZnNbcG9pbnRlciAtIDFdWzFdICsgZGlmZnNbcG9pbnRlciArIDFdWzFdO1xuICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciAtIDEsIDEpO1xuICAgICAgICBjaGFuZ2VzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKDAsIGRpZmZzW3BvaW50ZXIgKyAxXVsxXS5sZW5ndGgpID09XG4gICAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzFdKSB7XG4gICAgICAgIC8vIFNoaWZ0IHRoZSBlZGl0IG92ZXIgdGhlIG5leHQgZXF1YWxpdHkuXG4gICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArPSBkaWZmc1twb2ludGVyICsgMV1bMV07XG4gICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdID1cbiAgICAgICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZyhkaWZmc1twb2ludGVyICsgMV1bMV0ubGVuZ3RoKSArXG4gICAgICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMV07XG4gICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyICsgMSwgMSk7XG4gICAgICAgIGNoYW5nZXMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBwb2ludGVyKys7XG4gIH1cbiAgLy8gSWYgc2hpZnRzIHdlcmUgbWFkZSwgdGhlIGRpZmYgbmVlZHMgcmVvcmRlcmluZyBhbmQgYW5vdGhlciBzaGlmdCBzd2VlcC5cbiAgaWYgKGNoYW5nZXMpIHtcbiAgICB0aGlzLmRpZmZfY2xlYW51cE1lcmdlKGRpZmZzKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIGxvYyBpcyBhIGxvY2F0aW9uIGluIHRleHQxLCBjb21wdXRlIGFuZCByZXR1cm4gdGhlIGVxdWl2YWxlbnQgbG9jYXRpb24gaW5cbiAqIHRleHQyLlxuICogZS5nLiAnVGhlIGNhdCcgdnMgJ1RoZSBiaWcgY2F0JywgMS0+MSwgNS0+OFxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcnxzdHJpbmc+Pn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gbG9jIExvY2F0aW9uIHdpdGhpbiB0ZXh0MS5cbiAqIEByZXR1cm4ge251bWJlcn0gTG9jYXRpb24gd2l0aGluIHRleHQyLlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX3hJbmRleCA9IGZ1bmN0aW9uKGRpZmZzLCBsb2MpIHtcbiAgdmFyIGNoYXJzMSA9IDA7XG4gIHZhciBjaGFyczIgPSAwO1xuICB2YXIgbGFzdF9jaGFyczEgPSAwO1xuICB2YXIgbGFzdF9jaGFyczIgPSAwO1xuICB2YXIgeDtcbiAgZm9yICh4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgaWYgKGRpZmZzW3hdWzBdICE9PSBESUZGX0lOU0VSVCkgeyAgLy8gRXF1YWxpdHkgb3IgZGVsZXRpb24uXG4gICAgICBjaGFyczEgKz0gZGlmZnNbeF1bMV0ubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAoZGlmZnNbeF1bMF0gIT09IERJRkZfREVMRVRFKSB7ICAvLyBFcXVhbGl0eSBvciBpbnNlcnRpb24uXG4gICAgICBjaGFyczIgKz0gZGlmZnNbeF1bMV0ubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAoY2hhcnMxID4gbG9jKSB7ICAvLyBPdmVyc2hvdCB0aGUgbG9jYXRpb24uXG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbGFzdF9jaGFyczEgPSBjaGFyczE7XG4gICAgbGFzdF9jaGFyczIgPSBjaGFyczI7XG4gIH1cbiAgLy8gV2FzIHRoZSBsb2NhdGlvbiB3YXMgZGVsZXRlZD9cbiAgaWYgKGRpZmZzLmxlbmd0aCAhPSB4ICYmIGRpZmZzW3hdWzBdID09PSBESUZGX0RFTEVURSkge1xuICAgIHJldHVybiBsYXN0X2NoYXJzMjtcbiAgfVxuICAvLyBBZGQgdGhlIHJlbWFpbmluZyBjaGFyYWN0ZXIgbGVuZ3RoLlxuICByZXR1cm4gbGFzdF9jaGFyczIgKyAobG9jIC0gbGFzdF9jaGFyczEpO1xufTtcblxuXG4vKipcbiAqIENvbnZlcnQgYSBkaWZmIGFycmF5IGludG8gYSBwcmV0dHkgSFRNTCByZXBvcnQuXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyfHN0cmluZz4+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqIEByZXR1cm4ge3N0cmluZ30gSFRNTCByZXByZXNlbnRhdGlvbi5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9wcmV0dHlIdG1sID0gZnVuY3Rpb24oZGlmZnMpIHtcbiAgdmFyIGh0bWwgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICBmb3IgKHZhciB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgdmFyIG9wID0gZGlmZnNbeF1bMF07ICAgIC8vIE9wZXJhdGlvbiAoaW5zZXJ0LCBkZWxldGUsIGVxdWFsKVxuICAgIHZhciBkYXRhID0gZGlmZnNbeF1bMV07ICAvLyBUZXh0IG9mIGNoYW5nZS5cbiAgICB2YXIgdGV4dCA9IGRhdGEucmVwbGFjZSgvJi9nLCAnJmFtcDsnKS5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAgICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKS5yZXBsYWNlKC9cXG4vZywgJyZwYXJhOzxCUj4nKTtcbiAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICBodG1sW3hdID0gJzxJTlMgU1RZTEU9XCJiYWNrZ3JvdW5kOiNFNkZGRTY7XCIgVElUTEU9XCJpPScgKyBpICsgJ1wiPicgK1xuICAgICAgICAgICAgICAgIHRleHQgKyAnPC9JTlM+JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxuICAgICAgICBodG1sW3hdID0gJzxERUwgU1RZTEU9XCJiYWNrZ3JvdW5kOiNGRkU2RTY7XCIgVElUTEU9XCJpPScgKyBpICsgJ1wiPicgK1xuICAgICAgICAgICAgICAgIHRleHQgKyAnPC9ERUw+JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgIGh0bWxbeF0gPSAnPFNQQU4gVElUTEU9XCJpPScgKyBpICsgJ1wiPicgKyB0ZXh0ICsgJzwvU1BBTj4nO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKG9wICE9PSBESUZGX0RFTEVURSkge1xuICAgICAgaSArPSBkYXRhLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGh0bWwuam9pbignJyk7XG59O1xuXG5cbi8qKlxuICogQ29tcHV0ZSBhbmQgcmV0dXJuIHRoZSBzb3VyY2UgdGV4dCAoYWxsIGVxdWFsaXRpZXMgYW5kIGRlbGV0aW9ucykuXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyfHN0cmluZz4+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqIEByZXR1cm4ge3N0cmluZ30gU291cmNlIHRleHQuXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfdGV4dDEgPSBmdW5jdGlvbihkaWZmcykge1xuICB2YXIgdGV4dCA9IFtdO1xuICBmb3IgKHZhciB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgaWYgKGRpZmZzW3hdWzBdICE9PSBESUZGX0lOU0VSVCkge1xuICAgICAgdGV4dFt4XSA9IGRpZmZzW3hdWzFdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGV4dC5qb2luKCcnKTtcbn07XG5cblxuLyoqXG4gKiBDb21wdXRlIGFuZCByZXR1cm4gdGhlIGRlc3RpbmF0aW9uIHRleHQgKGFsbCBlcXVhbGl0aWVzIGFuZCBpbnNlcnRpb25zKS5cbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXJ8c3RyaW5nPj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICogQHJldHVybiB7c3RyaW5nfSBEZXN0aW5hdGlvbiB0ZXh0LlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX3RleHQyID0gZnVuY3Rpb24oZGlmZnMpIHtcbiAgdmFyIHRleHQgPSBbXTtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xuICAgIGlmIChkaWZmc1t4XVswXSAhPT0gRElGRl9ERUxFVEUpIHtcbiAgICAgIHRleHRbeF0gPSBkaWZmc1t4XVsxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRleHQuam9pbignJyk7XG59O1xuXG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgTGV2ZW5zaHRlaW4gZGlzdGFuY2U7IHRoZSBudW1iZXIgb2YgaW5zZXJ0ZWQsIGRlbGV0ZWQgb3JcbiAqIHN1YnN0aXR1dGVkIGNoYXJhY3RlcnMuXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyfHN0cmluZz4+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqIEByZXR1cm4ge251bWJlcn0gTnVtYmVyIG9mIGNoYW5nZXMuXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfbGV2ZW5zaHRlaW4gPSBmdW5jdGlvbihkaWZmcykge1xuICB2YXIgbGV2ZW5zaHRlaW4gPSAwO1xuICB2YXIgaW5zZXJ0aW9ucyA9IDA7XG4gIHZhciBkZWxldGlvbnMgPSAwO1xuICBmb3IgKHZhciB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgdmFyIG9wID0gZGlmZnNbeF1bMF07XG4gICAgdmFyIGRhdGEgPSBkaWZmc1t4XVsxXTtcbiAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICBpbnNlcnRpb25zICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XG4gICAgICAgIGRlbGV0aW9ucyArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgIC8vIEEgZGVsZXRpb24gYW5kIGFuIGluc2VydGlvbiBpcyBvbmUgc3Vic3RpdHV0aW9uLlxuICAgICAgICBsZXZlbnNodGVpbiArPSBNYXRoLm1heChpbnNlcnRpb25zLCBkZWxldGlvbnMpO1xuICAgICAgICBpbnNlcnRpb25zID0gMDtcbiAgICAgICAgZGVsZXRpb25zID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGxldmVuc2h0ZWluICs9IE1hdGgubWF4KGluc2VydGlvbnMsIGRlbGV0aW9ucyk7XG4gIHJldHVybiBsZXZlbnNodGVpbjtcbn07XG5cblxuLyoqXG4gKiBDcnVzaCB0aGUgZGlmZiBpbnRvIGFuIGVuY29kZWQgc3RyaW5nIHdoaWNoIGRlc2NyaWJlcyB0aGUgb3BlcmF0aW9uc1xuICogcmVxdWlyZWQgdG8gdHJhbnNmb3JtIHRleHQxIGludG8gdGV4dDIuXG4gKiBFLmcuID0zXFx0LTJcXHQraW5nICAtPiBLZWVwIDMgY2hhcnMsIGRlbGV0ZSAyIGNoYXJzLCBpbnNlcnQgJ2luZycuXG4gKiBPcGVyYXRpb25zIGFyZSB0YWItc2VwYXJhdGVkLiAgSW5zZXJ0ZWQgdGV4dCBpcyBlc2NhcGVkIHVzaW5nICV4eCBub3RhdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXJ8c3RyaW5nPj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICogQHJldHVybiB7c3RyaW5nfSBEZWx0YSB0ZXh0LlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX3RvRGVsdGEgPSBmdW5jdGlvbihkaWZmcykge1xuICB2YXIgdGV4dCA9IFtdO1xuICBmb3IgKHZhciB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgc3dpdGNoIChkaWZmc1t4XVswXSkge1xuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcbiAgICAgICAgdGV4dFt4XSA9ICcrJyArIGVuY29kZVVSSShkaWZmc1t4XVsxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0RFTEVURTpcbiAgICAgICAgdGV4dFt4XSA9ICctJyArIGRpZmZzW3hdWzFdLmxlbmd0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgIHRleHRbeF0gPSAnPScgKyBkaWZmc1t4XVsxXS5sZW5ndGg7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICAvLyBPcGVyYSBkb2Vzbid0IGtub3cgaG93IHRvIGVuY29kZSBjaGFyIDAuXG4gIHJldHVybiB0ZXh0LmpvaW4oJ1xcdCcpLnJlcGxhY2UoL1xceDAwL2csICclMDAnKS5yZXBsYWNlKC8lMjAvZywgJyAnKTtcbn07XG5cblxuLyoqXG4gKiBHaXZlbiB0aGUgb3JpZ2luYWwgdGV4dDEsIGFuZCBhbiBlbmNvZGVkIHN0cmluZyB3aGljaCBkZXNjcmliZXMgdGhlXG4gKiBvcGVyYXRpb25zIHJlcXVpcmVkIHRvIHRyYW5zZm9ybSB0ZXh0MSBpbnRvIHRleHQyLCBjb21wdXRlIHRoZSBmdWxsIGRpZmYuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgU291cmNlIHN0cmluZyBmb3IgdGhlIGRpZmYuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVsdGEgRGVsdGEgdGV4dC5cbiAqIEByZXR1cm4ge0FycmF5LjxBcnJheS48bnVtYmVyfHN0cmluZz4+fSBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBpbnZhbGlkIGlucHV0LlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2Zyb21EZWx0YSA9IGZ1bmN0aW9uKHRleHQxLCBkZWx0YSkge1xuICB2YXIgZGlmZnMgPSBbXTtcbiAgdmFyIGRpZmZzTGVuZ3RoID0gMDsgIC8vIEtlZXBpbmcgb3VyIG93biBsZW5ndGggdmFyIGlzIGZhc3RlciBpbiBKUy5cbiAgdmFyIHBvaW50ZXIgPSAwOyAgLy8gQ3Vyc29yIGluIHRleHQxXG4gIC8vIE9wZXJhIGRvZXNuJ3Qga25vdyBob3cgdG8gZGVjb2RlIGNoYXIgMC5cbiAgZGVsdGEgPSBkZWx0YS5yZXBsYWNlKC8lMDAvZywgJ1xcMCcpO1xuICB2YXIgdG9rZW5zID0gZGVsdGEuc3BsaXQoL1xcdC9nKTtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCB0b2tlbnMubGVuZ3RoOyB4KyspIHtcbiAgICAvLyBFYWNoIHRva2VuIGJlZ2lucyB3aXRoIGEgb25lIGNoYXJhY3RlciBwYXJhbWV0ZXIgd2hpY2ggc3BlY2lmaWVzIHRoZVxuICAgIC8vIG9wZXJhdGlvbiBvZiB0aGlzIHRva2VuIChkZWxldGUsIGluc2VydCwgZXF1YWxpdHkpLlxuICAgIHZhciBwYXJhbSA9IHRva2Vuc1t4XS5zdWJzdHJpbmcoMSk7XG4gICAgc3dpdGNoICh0b2tlbnNbeF0uY2hhckF0KDApKSB7XG4gICAgICBjYXNlICcrJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkaWZmc1tkaWZmc0xlbmd0aCsrXSA9IFtESUZGX0lOU0VSVCwgZGVjb2RlVVJJKHBhcmFtKV07XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgLy8gTWFsZm9ybWVkIFVSSSBzZXF1ZW5jZS5cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgZXNjYXBlIGluIGRpZmZfZnJvbURlbHRhOiAnICsgcGFyYW0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnLSc6XG4gICAgICAgIC8vIEZhbGwgdGhyb3VnaC5cbiAgICAgIGNhc2UgJz0nOlxuICAgICAgICB2YXIgbiA9IHBhcnNlSW50KHBhcmFtLCAxMCk7XG4gICAgICAgIGlmIChpc05hTihuKSB8fCBuIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBudW1iZXIgaW4gZGlmZl9mcm9tRGVsdGE6ICcgKyBwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRleHQgPSB0ZXh0MS5zdWJzdHJpbmcocG9pbnRlciwgcG9pbnRlciArPSBuKTtcbiAgICAgICAgaWYgKHRva2Vuc1t4XS5jaGFyQXQoMCkgPT0gJz0nKSB7XG4gICAgICAgICAgZGlmZnNbZGlmZnNMZW5ndGgrK10gPSBbRElGRl9FUVVBTCwgdGV4dF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGlmZnNbZGlmZnNMZW5ndGgrK10gPSBbRElGRl9ERUxFVEUsIHRleHRdO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gQmxhbmsgdG9rZW5zIGFyZSBvayAoZnJvbSBhIHRyYWlsaW5nIFxcdCkuXG4gICAgICAgIC8vIEFueXRoaW5nIGVsc2UgaXMgYW4gZXJyb3IuXG4gICAgICAgIGlmICh0b2tlbnNbeF0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGlmZiBvcGVyYXRpb24gaW4gZGlmZl9mcm9tRGVsdGE6ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnNbeF0pO1xuICAgICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChwb2ludGVyICE9IHRleHQxLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRGVsdGEgbGVuZ3RoICgnICsgcG9pbnRlciArXG4gICAgICAgICcpIGRvZXMgbm90IGVxdWFsIHNvdXJjZSB0ZXh0IGxlbmd0aCAoJyArIHRleHQxLmxlbmd0aCArICcpLicpO1xuICB9XG4gIHJldHVybiBkaWZmcztcbn07XG5cblxuLy8gIE1BVENIIEZVTkNUSU9OU1xuXG5cbi8qKlxuICogTG9jYXRlIHRoZSBiZXN0IGluc3RhbmNlIG9mICdwYXR0ZXJuJyBpbiAndGV4dCcgbmVhciAnbG9jJy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIHNlYXJjaC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gbG9jIFRoZSBsb2NhdGlvbiB0byBzZWFyY2ggYXJvdW5kLlxuICogQHJldHVybiB7bnVtYmVyfSBCZXN0IG1hdGNoIGluZGV4IG9yIC0xLlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5tYXRjaF9tYWluID0gZnVuY3Rpb24odGV4dCwgcGF0dGVybiwgbG9jKSB7XG4gIC8vIENoZWNrIGZvciBudWxsIGlucHV0cy5cbiAgaWYgKHRleHQgPT0gbnVsbCB8fCBwYXR0ZXJuID09IG51bGwgfHwgbG9jID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ051bGwgaW5wdXQuIChtYXRjaF9tYWluKScpO1xuICB9XG5cbiAgbG9jID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obG9jLCB0ZXh0Lmxlbmd0aCkpO1xuICBpZiAodGV4dCA9PSBwYXR0ZXJuKSB7XG4gICAgLy8gU2hvcnRjdXQgKHBvdGVudGlhbGx5IG5vdCBndWFyYW50ZWVkIGJ5IHRoZSBhbGdvcml0aG0pXG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSBpZiAoIXRleHQubGVuZ3RoKSB7XG4gICAgLy8gTm90aGluZyB0byBtYXRjaC5cbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAodGV4dC5zdWJzdHJpbmcobG9jLCBsb2MgKyBwYXR0ZXJuLmxlbmd0aCkgPT0gcGF0dGVybikge1xuICAgIC8vIFBlcmZlY3QgbWF0Y2ggYXQgdGhlIHBlcmZlY3Qgc3BvdCEgIChJbmNsdWRlcyBjYXNlIG9mIG51bGwgcGF0dGVybilcbiAgICByZXR1cm4gbG9jO1xuICB9IGVsc2Uge1xuICAgIC8vIERvIGEgZnV6enkgY29tcGFyZS5cbiAgICByZXR1cm4gdGhpcy5tYXRjaF9iaXRhcCh0ZXh0LCBwYXR0ZXJuLCBsb2MpO1xuICB9XG59O1xuXG5cbi8qKlxuICogTG9jYXRlIHRoZSBiZXN0IGluc3RhbmNlIG9mICdwYXR0ZXJuJyBpbiAndGV4dCcgbmVhciAnbG9jJyB1c2luZyB0aGVcbiAqIEJpdGFwIGFsZ29yaXRobS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIHNlYXJjaC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gbG9jIFRoZSBsb2NhdGlvbiB0byBzZWFyY2ggYXJvdW5kLlxuICogQHJldHVybiB7bnVtYmVyfSBCZXN0IG1hdGNoIGluZGV4IG9yIC0xLlxuICogQHByaXZhdGVcbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUubWF0Y2hfYml0YXAgPSBmdW5jdGlvbih0ZXh0LCBwYXR0ZXJuLCBsb2MpIHtcbiAgaWYgKHBhdHRlcm4ubGVuZ3RoID4gdGhpcy5NYXRjaF9NYXhCaXRzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYXR0ZXJuIHRvbyBsb25nIGZvciB0aGlzIGJyb3dzZXIuJyk7XG4gIH1cblxuICAvLyBJbml0aWFsaXNlIHRoZSBhbHBoYWJldC5cbiAgdmFyIHMgPSB0aGlzLm1hdGNoX2FscGhhYmV0KHBhdHRlcm4pO1xuXG4gIHZhciBkbXAgPSB0aGlzOyAgLy8gJ3RoaXMnIGJlY29tZXMgJ3dpbmRvdycgaW4gYSBjbG9zdXJlLlxuXG4gIC8qKlxuICAgKiBDb21wdXRlIGFuZCByZXR1cm4gdGhlIHNjb3JlIGZvciBhIG1hdGNoIHdpdGggZSBlcnJvcnMgYW5kIHggbG9jYXRpb24uXG4gICAqIEFjY2Vzc2VzIGxvYyBhbmQgcGF0dGVybiB0aHJvdWdoIGJlaW5nIGEgY2xvc3VyZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGUgTnVtYmVyIG9mIGVycm9ycyBpbiBtYXRjaC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggTG9jYXRpb24gb2YgbWF0Y2guXG4gICAqIEByZXR1cm4ge251bWJlcn0gT3ZlcmFsbCBzY29yZSBmb3IgbWF0Y2ggKDAuMCA9IGdvb2QsIDEuMCA9IGJhZCkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBtYXRjaF9iaXRhcFNjb3JlKGUsIHgpIHtcbiAgICB2YXIgYWNjdXJhY3kgPSBlIC8gcGF0dGVybi5sZW5ndGg7XG4gICAgdmFyIHByb3hpbWl0eSA9IE1hdGguYWJzKGxvYyAtIHgpO1xuICAgIGlmICghZG1wLk1hdGNoX0Rpc3RhbmNlKSB7XG4gICAgICAvLyBEb2RnZSBkaXZpZGUgYnkgemVybyBlcnJvci5cbiAgICAgIHJldHVybiBwcm94aW1pdHkgPyAxLjAgOiBhY2N1cmFjeTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY3VyYWN5ICsgKHByb3hpbWl0eSAvIGRtcC5NYXRjaF9EaXN0YW5jZSk7XG4gIH1cblxuICAvLyBIaWdoZXN0IHNjb3JlIGJleW9uZCB3aGljaCB3ZSBnaXZlIHVwLlxuICB2YXIgc2NvcmVfdGhyZXNob2xkID0gdGhpcy5NYXRjaF9UaHJlc2hvbGQ7XG4gIC8vIElzIHRoZXJlIGEgbmVhcmJ5IGV4YWN0IG1hdGNoPyAoc3BlZWR1cClcbiAgdmFyIGJlc3RfbG9jID0gdGV4dC5pbmRleE9mKHBhdHRlcm4sIGxvYyk7XG4gIGlmIChiZXN0X2xvYyAhPSAtMSkge1xuICAgIHNjb3JlX3RocmVzaG9sZCA9IE1hdGgubWluKG1hdGNoX2JpdGFwU2NvcmUoMCwgYmVzdF9sb2MpLCBzY29yZV90aHJlc2hvbGQpO1xuICAgIC8vIFdoYXQgYWJvdXQgaW4gdGhlIG90aGVyIGRpcmVjdGlvbj8gKHNwZWVkdXApXG4gICAgYmVzdF9sb2MgPSB0ZXh0Lmxhc3RJbmRleE9mKHBhdHRlcm4sIGxvYyArIHBhdHRlcm4ubGVuZ3RoKTtcbiAgICBpZiAoYmVzdF9sb2MgIT0gLTEpIHtcbiAgICAgIHNjb3JlX3RocmVzaG9sZCA9XG4gICAgICAgICAgTWF0aC5taW4obWF0Y2hfYml0YXBTY29yZSgwLCBiZXN0X2xvYyksIHNjb3JlX3RocmVzaG9sZCk7XG4gICAgfVxuICB9XG5cbiAgLy8gSW5pdGlhbGlzZSB0aGUgYml0IGFycmF5cy5cbiAgdmFyIG1hdGNobWFzayA9IDEgPDwgKHBhdHRlcm4ubGVuZ3RoIC0gMSk7XG4gIGJlc3RfbG9jID0gLTE7XG5cbiAgdmFyIGJpbl9taW4sIGJpbl9taWQ7XG4gIHZhciBiaW5fbWF4ID0gcGF0dGVybi5sZW5ndGggKyB0ZXh0Lmxlbmd0aDtcbiAgdmFyIGxhc3RfcmQ7XG4gIGZvciAodmFyIGQgPSAwOyBkIDwgcGF0dGVybi5sZW5ndGg7IGQrKykge1xuICAgIC8vIFNjYW4gZm9yIHRoZSBiZXN0IG1hdGNoOyBlYWNoIGl0ZXJhdGlvbiBhbGxvd3MgZm9yIG9uZSBtb3JlIGVycm9yLlxuICAgIC8vIFJ1biBhIGJpbmFyeSBzZWFyY2ggdG8gZGV0ZXJtaW5lIGhvdyBmYXIgZnJvbSAnbG9jJyB3ZSBjYW4gc3RyYXkgYXQgdGhpc1xuICAgIC8vIGVycm9yIGxldmVsLlxuICAgIGJpbl9taW4gPSAwO1xuICAgIGJpbl9taWQgPSBiaW5fbWF4O1xuICAgIHdoaWxlIChiaW5fbWluIDwgYmluX21pZCkge1xuICAgICAgaWYgKG1hdGNoX2JpdGFwU2NvcmUoZCwgbG9jICsgYmluX21pZCkgPD0gc2NvcmVfdGhyZXNob2xkKSB7XG4gICAgICAgIGJpbl9taW4gPSBiaW5fbWlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmluX21heCA9IGJpbl9taWQ7XG4gICAgICB9XG4gICAgICBiaW5fbWlkID0gTWF0aC5mbG9vcigoYmluX21heCAtIGJpbl9taW4pIC8gMiArIGJpbl9taW4pO1xuICAgIH1cbiAgICAvLyBVc2UgdGhlIHJlc3VsdCBmcm9tIHRoaXMgaXRlcmF0aW9uIGFzIHRoZSBtYXhpbXVtIGZvciB0aGUgbmV4dC5cbiAgICBiaW5fbWF4ID0gYmluX21pZDtcbiAgICB2YXIgc3RhcnQgPSBNYXRoLm1heCgxLCBsb2MgLSBiaW5fbWlkICsgMSk7XG4gICAgdmFyIGZpbmlzaCA9IE1hdGgubWluKGxvYyArIGJpbl9taWQsIHRleHQubGVuZ3RoKSArIHBhdHRlcm4ubGVuZ3RoO1xuXG4gICAgdmFyIHJkID0gQXJyYXkoZmluaXNoICsgMik7XG4gICAgcmRbZmluaXNoICsgMV0gPSAoMSA8PCBkKSAtIDE7XG4gICAgZm9yICh2YXIgaiA9IGZpbmlzaDsgaiA+PSBzdGFydDsgai0tKSB7XG4gICAgICAvLyBUaGUgYWxwaGFiZXQgKHMpIGlzIGEgc3BhcnNlIGhhc2gsIHNvIHRoZSBmb2xsb3dpbmcgbGluZSBnZW5lcmF0ZXNcbiAgICAgIC8vIHdhcm5pbmdzLlxuICAgICAgdmFyIGNoYXJNYXRjaCA9IHNbdGV4dC5jaGFyQXQoaiAtIDEpXTtcbiAgICAgIGlmIChkID09PSAwKSB7ICAvLyBGaXJzdCBwYXNzOiBleGFjdCBtYXRjaC5cbiAgICAgICAgcmRbal0gPSAoKHJkW2ogKyAxXSA8PCAxKSB8IDEpICYgY2hhck1hdGNoO1xuICAgICAgfSBlbHNlIHsgIC8vIFN1YnNlcXVlbnQgcGFzc2VzOiBmdXp6eSBtYXRjaC5cbiAgICAgICAgcmRbal0gPSAoKHJkW2ogKyAxXSA8PCAxKSB8IDEpICYgY2hhck1hdGNoIHxcbiAgICAgICAgICAgICAgICAoKChsYXN0X3JkW2ogKyAxXSB8IGxhc3RfcmRbal0pIDw8IDEpIHwgMSkgfFxuICAgICAgICAgICAgICAgIGxhc3RfcmRbaiArIDFdO1xuICAgICAgfVxuICAgICAgaWYgKHJkW2pdICYgbWF0Y2htYXNrKSB7XG4gICAgICAgIHZhciBzY29yZSA9IG1hdGNoX2JpdGFwU2NvcmUoZCwgaiAtIDEpO1xuICAgICAgICAvLyBUaGlzIG1hdGNoIHdpbGwgYWxtb3N0IGNlcnRhaW5seSBiZSBiZXR0ZXIgdGhhbiBhbnkgZXhpc3RpbmcgbWF0Y2guXG4gICAgICAgIC8vIEJ1dCBjaGVjayBhbnl3YXkuXG4gICAgICAgIGlmIChzY29yZSA8PSBzY29yZV90aHJlc2hvbGQpIHtcbiAgICAgICAgICAvLyBUb2xkIHlvdSBzby5cbiAgICAgICAgICBzY29yZV90aHJlc2hvbGQgPSBzY29yZTtcbiAgICAgICAgICBiZXN0X2xvYyA9IGogLSAxO1xuICAgICAgICAgIGlmIChiZXN0X2xvYyA+IGxvYykge1xuICAgICAgICAgICAgLy8gV2hlbiBwYXNzaW5nIGxvYywgZG9uJ3QgZXhjZWVkIG91ciBjdXJyZW50IGRpc3RhbmNlIGZyb20gbG9jLlxuICAgICAgICAgICAgc3RhcnQgPSBNYXRoLm1heCgxLCAyICogbG9jIC0gYmVzdF9sb2MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBBbHJlYWR5IHBhc3NlZCBsb2MsIGRvd25oaWxsIGZyb20gaGVyZSBvbiBpbi5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBObyBob3BlIGZvciBhIChiZXR0ZXIpIG1hdGNoIGF0IGdyZWF0ZXIgZXJyb3IgbGV2ZWxzLlxuICAgIGlmIChtYXRjaF9iaXRhcFNjb3JlKGQgKyAxLCBsb2MpID4gc2NvcmVfdGhyZXNob2xkKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbGFzdF9yZCA9IHJkO1xuICB9XG4gIHJldHVybiBiZXN0X2xvYztcbn07XG5cblxuLyoqXG4gKiBJbml0aWFsaXNlIHRoZSBhbHBoYWJldCBmb3IgdGhlIEJpdGFwIGFsZ29yaXRobS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuIFRoZSB0ZXh0IHRvIGVuY29kZS5cbiAqIEByZXR1cm4ge09iamVjdH0gSGFzaCBvZiBjaGFyYWN0ZXIgbG9jYXRpb25zLlxuICogQHByaXZhdGVcbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUubWF0Y2hfYWxwaGFiZXQgPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIHZhciBzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0dGVybi5sZW5ndGg7IGkrKykge1xuICAgIHNbcGF0dGVybi5jaGFyQXQoaSldID0gMDtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdHRlcm4ubGVuZ3RoOyBpKyspIHtcbiAgICBzW3BhdHRlcm4uY2hhckF0KGkpXSB8PSAxIDw8IChwYXR0ZXJuLmxlbmd0aCAtIGkgLSAxKTtcbiAgfVxuICByZXR1cm4gcztcbn07XG5cblxuLy8gIFBBVENIIEZVTkNUSU9OU1xuXG5cbi8qKlxuICogSW5jcmVhc2UgdGhlIGNvbnRleHQgdW50aWwgaXQgaXMgdW5pcXVlLFxuICogYnV0IGRvbid0IGxldCB0aGUgcGF0dGVybiBleHBhbmQgYmV5b25kIE1hdGNoX01heEJpdHMuXG4gKiBAcGFyYW0ge3BhdGNoX29ian0gcGF0Y2ggVGhlIHBhdGNoIHRvIGdyb3cuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBTb3VyY2UgdGV4dC5cbiAqIEBwcml2YXRlXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLnBhdGNoX2FkZENvbnRleHQgPSBmdW5jdGlvbihwYXRjaCwgdGV4dCkge1xuICBpZiAodGV4dC5sZW5ndGggPT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcGF0dGVybiA9IHRleHQuc3Vic3RyaW5nKHBhdGNoLnN0YXJ0MiwgcGF0Y2guc3RhcnQyICsgcGF0Y2gubGVuZ3RoMSk7XG4gIHZhciBwYWRkaW5nID0gMDtcblxuICAvLyBMb29rIGZvciB0aGUgZmlyc3QgYW5kIGxhc3QgbWF0Y2hlcyBvZiBwYXR0ZXJuIGluIHRleHQuICBJZiB0d28gZGlmZmVyZW50XG4gIC8vIG1hdGNoZXMgYXJlIGZvdW5kLCBpbmNyZWFzZSB0aGUgcGF0dGVybiBsZW5ndGguXG4gIHdoaWxlICh0ZXh0LmluZGV4T2YocGF0dGVybikgIT0gdGV4dC5sYXN0SW5kZXhPZihwYXR0ZXJuKSAmJlxuICAgICAgICAgcGF0dGVybi5sZW5ndGggPCB0aGlzLk1hdGNoX01heEJpdHMgLSB0aGlzLlBhdGNoX01hcmdpbiAtXG4gICAgICAgICB0aGlzLlBhdGNoX01hcmdpbikge1xuICAgIHBhZGRpbmcgKz0gdGhpcy5QYXRjaF9NYXJnaW47XG4gICAgcGF0dGVybiA9IHRleHQuc3Vic3RyaW5nKHBhdGNoLnN0YXJ0MiAtIHBhZGRpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoLnN0YXJ0MiArIHBhdGNoLmxlbmd0aDEgKyBwYWRkaW5nKTtcbiAgfVxuICAvLyBBZGQgb25lIGNodW5rIGZvciBnb29kIGx1Y2suXG4gIHBhZGRpbmcgKz0gdGhpcy5QYXRjaF9NYXJnaW47XG5cbiAgLy8gQWRkIHRoZSBwcmVmaXguXG4gIHZhciBwcmVmaXggPSB0ZXh0LnN1YnN0cmluZyhwYXRjaC5zdGFydDIgLSBwYWRkaW5nLCBwYXRjaC5zdGFydDIpO1xuICBpZiAocHJlZml4KSB7XG4gICAgcGF0Y2guZGlmZnMudW5zaGlmdChbRElGRl9FUVVBTCwgcHJlZml4XSk7XG4gIH1cbiAgLy8gQWRkIHRoZSBzdWZmaXguXG4gIHZhciBzdWZmaXggPSB0ZXh0LnN1YnN0cmluZyhwYXRjaC5zdGFydDIgKyBwYXRjaC5sZW5ndGgxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2guc3RhcnQyICsgcGF0Y2gubGVuZ3RoMSArIHBhZGRpbmcpO1xuICBpZiAoc3VmZml4KSB7XG4gICAgcGF0Y2guZGlmZnMucHVzaChbRElGRl9FUVVBTCwgc3VmZml4XSk7XG4gIH1cblxuICAvLyBSb2xsIGJhY2sgdGhlIHN0YXJ0IHBvaW50cy5cbiAgcGF0Y2guc3RhcnQxIC09IHByZWZpeC5sZW5ndGg7XG4gIHBhdGNoLnN0YXJ0MiAtPSBwcmVmaXgubGVuZ3RoO1xuICAvLyBFeHRlbmQgdGhlIGxlbmd0aHMuXG4gIHBhdGNoLmxlbmd0aDEgKz0gcHJlZml4Lmxlbmd0aCArIHN1ZmZpeC5sZW5ndGg7XG4gIHBhdGNoLmxlbmd0aDIgKz0gcHJlZml4Lmxlbmd0aCArIHN1ZmZpeC5sZW5ndGg7XG59O1xuXG5cbi8qKlxuICogQ29tcHV0ZSBhIGxpc3Qgb2YgcGF0Y2hlcyB0byB0dXJuIHRleHQxIGludG8gdGV4dDIuXG4gKiBVc2UgZGlmZnMgaWYgcHJvdmlkZWQsIG90aGVyd2lzZSBjb21wdXRlIGl0IG91cnNlbHZlcy5cbiAqIFRoZXJlIGFyZSBmb3VyIHdheXMgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uLCBkZXBlbmRpbmcgb24gd2hhdCBkYXRhIGlzXG4gKiBhdmFpbGFibGUgdG8gdGhlIGNhbGxlcjpcbiAqIE1ldGhvZCAxOlxuICogYSA9IHRleHQxLCBiID0gdGV4dDJcbiAqIE1ldGhvZCAyOlxuICogYSA9IGRpZmZzXG4gKiBNZXRob2QgMyAob3B0aW1hbCk6XG4gKiBhID0gdGV4dDEsIGIgPSBkaWZmc1xuICogTWV0aG9kIDQgKGRlcHJlY2F0ZWQsIHVzZSBtZXRob2QgMyk6XG4gKiBhID0gdGV4dDEsIGIgPSB0ZXh0MiwgYyA9IGRpZmZzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPEFycmF5LjxudW1iZXJ8c3RyaW5nPj59IGEgdGV4dDEgKG1ldGhvZHMgMSwzLDQpIG9yXG4gKiBBcnJheSBvZiBkaWZmIHR1cGxlcyBmb3IgdGV4dDEgdG8gdGV4dDIgKG1ldGhvZCAyKS5cbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxBcnJheS48bnVtYmVyfHN0cmluZz4+fSBvcHRfYiB0ZXh0MiAobWV0aG9kcyAxLDQpIG9yXG4gKiBBcnJheSBvZiBkaWZmIHR1cGxlcyBmb3IgdGV4dDEgdG8gdGV4dDIgKG1ldGhvZCAzKSBvciB1bmRlZmluZWQgKG1ldGhvZCAyKS5cbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxBcnJheS48bnVtYmVyfHN0cmluZz4+fSBvcHRfYyBBcnJheSBvZiBkaWZmIHR1cGxlcyBmb3JcbiAqIHRleHQxIHRvIHRleHQyIChtZXRob2QgNCkgb3IgdW5kZWZpbmVkIChtZXRob2RzIDEsMiwzKS5cbiAqIEByZXR1cm4ge0FycmF5LjxwYXRjaF9vYmo+fSBBcnJheSBvZiBwYXRjaCBvYmplY3RzLlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5wYXRjaF9tYWtlID0gZnVuY3Rpb24oYSwgb3B0X2IsIG9wdF9jKSB7XG4gIHZhciB0ZXh0MSwgZGlmZnM7XG4gIGlmICh0eXBlb2YgYSA9PSAnc3RyaW5nJyAmJiB0eXBlb2Ygb3B0X2IgPT0gJ3N0cmluZycgJiZcbiAgICAgIHR5cGVvZiBvcHRfYyA9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIE1ldGhvZCAxOiB0ZXh0MSwgdGV4dDJcbiAgICAvLyBDb21wdXRlIGRpZmZzIGZyb20gdGV4dDEgYW5kIHRleHQyLlxuICAgIHRleHQxID0gYTtcbiAgICBkaWZmcyA9IHRoaXMuZGlmZl9tYWluKHRleHQxLCBvcHRfYiwgdHJ1ZSk7XG4gICAgaWYgKGRpZmZzLmxlbmd0aCA+IDIpIHtcbiAgICAgIHRoaXMuZGlmZl9jbGVhbnVwU2VtYW50aWMoZGlmZnMpO1xuICAgICAgdGhpcy5kaWZmX2NsZWFudXBFZmZpY2llbmN5KGRpZmZzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYSAmJiB0eXBlb2YgYSA9PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb3B0X2IgPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIHR5cGVvZiBvcHRfYyA9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIE1ldGhvZCAyOiBkaWZmc1xuICAgIC8vIENvbXB1dGUgdGV4dDEgZnJvbSBkaWZmcy5cbiAgICBkaWZmcyA9IGE7XG4gICAgdGV4dDEgPSB0aGlzLmRpZmZfdGV4dDEoZGlmZnMpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhID09ICdzdHJpbmcnICYmIG9wdF9iICYmIHR5cGVvZiBvcHRfYiA9PSAnb2JqZWN0JyAmJlxuICAgICAgdHlwZW9mIG9wdF9jID09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gTWV0aG9kIDM6IHRleHQxLCBkaWZmc1xuICAgIHRleHQxID0gYTtcbiAgICBkaWZmcyA9IG9wdF9iO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhID09ICdzdHJpbmcnICYmIHR5cGVvZiBvcHRfYiA9PSAnc3RyaW5nJyAmJlxuICAgICAgb3B0X2MgJiYgdHlwZW9mIG9wdF9jID09ICdvYmplY3QnKSB7XG4gICAgLy8gTWV0aG9kIDQ6IHRleHQxLCB0ZXh0MiwgZGlmZnNcbiAgICAvLyB0ZXh0MiBpcyBub3QgdXNlZC5cbiAgICB0ZXh0MSA9IGE7XG4gICAgZGlmZnMgPSBvcHRfYztcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gY2FsbCBmb3JtYXQgdG8gcGF0Y2hfbWFrZS4nKTtcbiAgfVxuXG4gIGlmIChkaWZmcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107ICAvLyBHZXQgcmlkIG9mIHRoZSBudWxsIGNhc2UuXG4gIH1cbiAgdmFyIHBhdGNoZXMgPSBbXTtcbiAgdmFyIHBhdGNoID0gbmV3IHBhdGNoX29iaigpO1xuICB2YXIgcGF0Y2hEaWZmTGVuZ3RoID0gMDsgIC8vIEtlZXBpbmcgb3VyIG93biBsZW5ndGggdmFyIGlzIGZhc3RlciBpbiBKUy5cbiAgdmFyIGNoYXJfY291bnQxID0gMDsgIC8vIE51bWJlciBvZiBjaGFyYWN0ZXJzIGludG8gdGhlIHRleHQxIHN0cmluZy5cbiAgdmFyIGNoYXJfY291bnQyID0gMDsgIC8vIE51bWJlciBvZiBjaGFyYWN0ZXJzIGludG8gdGhlIHRleHQyIHN0cmluZy5cbiAgLy8gU3RhcnQgd2l0aCB0ZXh0MSAocHJlcGF0Y2hfdGV4dCkgYW5kIGFwcGx5IHRoZSBkaWZmcyB1bnRpbCB3ZSBhcnJpdmUgYXRcbiAgLy8gdGV4dDIgKHBvc3RwYXRjaF90ZXh0KS4gIFdlIHJlY3JlYXRlIHRoZSBwYXRjaGVzIG9uZSBieSBvbmUgdG8gZGV0ZXJtaW5lXG4gIC8vIGNvbnRleHQgaW5mby5cbiAgdmFyIHByZXBhdGNoX3RleHQgPSB0ZXh0MTtcbiAgdmFyIHBvc3RwYXRjaF90ZXh0ID0gdGV4dDE7XG4gIGZvciAodmFyIHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICB2YXIgZGlmZl90eXBlID0gZGlmZnNbeF1bMF07XG4gICAgdmFyIGRpZmZfdGV4dCA9IGRpZmZzW3hdWzFdO1xuXG4gICAgaWYgKCFwYXRjaERpZmZMZW5ndGggJiYgZGlmZl90eXBlICE9PSBESUZGX0VRVUFMKSB7XG4gICAgICAvLyBBIG5ldyBwYXRjaCBzdGFydHMgaGVyZS5cbiAgICAgIHBhdGNoLnN0YXJ0MSA9IGNoYXJfY291bnQxO1xuICAgICAgcGF0Y2guc3RhcnQyID0gY2hhcl9jb3VudDI7XG4gICAgfVxuXG4gICAgc3dpdGNoIChkaWZmX3R5cGUpIHtcbiAgICAgIGNhc2UgRElGRl9JTlNFUlQ6XG4gICAgICAgIHBhdGNoLmRpZmZzW3BhdGNoRGlmZkxlbmd0aCsrXSA9IGRpZmZzW3hdO1xuICAgICAgICBwYXRjaC5sZW5ndGgyICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgIHBvc3RwYXRjaF90ZXh0ID0gcG9zdHBhdGNoX3RleHQuc3Vic3RyaW5nKDAsIGNoYXJfY291bnQyKSArIGRpZmZfdGV4dCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgcG9zdHBhdGNoX3RleHQuc3Vic3RyaW5nKGNoYXJfY291bnQyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxuICAgICAgICBwYXRjaC5sZW5ndGgxICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgIHBhdGNoLmRpZmZzW3BhdGNoRGlmZkxlbmd0aCsrXSA9IGRpZmZzW3hdO1xuICAgICAgICBwb3N0cGF0Y2hfdGV4dCA9IHBvc3RwYXRjaF90ZXh0LnN1YnN0cmluZygwLCBjaGFyX2NvdW50MikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RwYXRjaF90ZXh0LnN1YnN0cmluZyhjaGFyX2NvdW50MiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZfdGV4dC5sZW5ndGgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9FUVVBTDpcbiAgICAgICAgaWYgKGRpZmZfdGV4dC5sZW5ndGggPD0gMiAqIHRoaXMuUGF0Y2hfTWFyZ2luICYmXG4gICAgICAgICAgICBwYXRjaERpZmZMZW5ndGggJiYgZGlmZnMubGVuZ3RoICE9IHggKyAxKSB7XG4gICAgICAgICAgLy8gU21hbGwgZXF1YWxpdHkgaW5zaWRlIGEgcGF0Y2guXG4gICAgICAgICAgcGF0Y2guZGlmZnNbcGF0Y2hEaWZmTGVuZ3RoKytdID0gZGlmZnNbeF07XG4gICAgICAgICAgcGF0Y2gubGVuZ3RoMSArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgICAgICAgIHBhdGNoLmxlbmd0aDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIGlmIChkaWZmX3RleHQubGVuZ3RoID49IDIgKiB0aGlzLlBhdGNoX01hcmdpbikge1xuICAgICAgICAgIC8vIFRpbWUgZm9yIGEgbmV3IHBhdGNoLlxuICAgICAgICAgIGlmIChwYXRjaERpZmZMZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucGF0Y2hfYWRkQ29udGV4dChwYXRjaCwgcHJlcGF0Y2hfdGV4dCk7XG4gICAgICAgICAgICBwYXRjaGVzLnB1c2gocGF0Y2gpO1xuICAgICAgICAgICAgcGF0Y2ggPSBuZXcgcGF0Y2hfb2JqKCk7XG4gICAgICAgICAgICBwYXRjaERpZmZMZW5ndGggPSAwO1xuICAgICAgICAgICAgLy8gVW5saWtlIFVuaWRpZmYsIG91ciBwYXRjaCBsaXN0cyBoYXZlIGEgcm9sbGluZyBjb250ZXh0LlxuICAgICAgICAgICAgLy8gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2dvb2dsZS1kaWZmLW1hdGNoLXBhdGNoL3dpa2kvVW5pZGlmZlxuICAgICAgICAgICAgLy8gVXBkYXRlIHByZXBhdGNoIHRleHQgJiBwb3MgdG8gcmVmbGVjdCB0aGUgYXBwbGljYXRpb24gb2YgdGhlXG4gICAgICAgICAgICAvLyBqdXN0IGNvbXBsZXRlZCBwYXRjaC5cbiAgICAgICAgICAgIHByZXBhdGNoX3RleHQgPSBwb3N0cGF0Y2hfdGV4dDtcbiAgICAgICAgICAgIGNoYXJfY291bnQxID0gY2hhcl9jb3VudDI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB0aGUgY3VycmVudCBjaGFyYWN0ZXIgY291bnQuXG4gICAgaWYgKGRpZmZfdHlwZSAhPT0gRElGRl9JTlNFUlQpIHtcbiAgICAgIGNoYXJfY291bnQxICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgfVxuICAgIGlmIChkaWZmX3R5cGUgIT09IERJRkZfREVMRVRFKSB7XG4gICAgICBjaGFyX2NvdW50MiArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgIH1cbiAgfVxuICAvLyBQaWNrIHVwIHRoZSBsZWZ0b3ZlciBwYXRjaCBpZiBub3QgZW1wdHkuXG4gIGlmIChwYXRjaERpZmZMZW5ndGgpIHtcbiAgICB0aGlzLnBhdGNoX2FkZENvbnRleHQocGF0Y2gsIHByZXBhdGNoX3RleHQpO1xuICAgIHBhdGNoZXMucHVzaChwYXRjaCk7XG4gIH1cblxuICByZXR1cm4gcGF0Y2hlcztcbn07XG5cblxuLyoqXG4gKiBHaXZlbiBhbiBhcnJheSBvZiBwYXRjaGVzLCByZXR1cm4gYW5vdGhlciBhcnJheSB0aGF0IGlzIGlkZW50aWNhbC5cbiAqIEBwYXJhbSB7QXJyYXkuPHBhdGNoX29iaj59IHBhdGNoZXMgQXJyYXkgb2YgcGF0Y2ggb2JqZWN0cy5cbiAqIEByZXR1cm4ge0FycmF5LjxwYXRjaF9vYmo+fSBBcnJheSBvZiBwYXRjaCBvYmplY3RzLlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5wYXRjaF9kZWVwQ29weSA9IGZ1bmN0aW9uKHBhdGNoZXMpIHtcbiAgLy8gTWFraW5nIGRlZXAgY29waWVzIGlzIGhhcmQgaW4gSmF2YVNjcmlwdC5cbiAgdmFyIHBhdGNoZXNDb3B5ID0gW107XG4gIGZvciAodmFyIHggPSAwOyB4IDwgcGF0Y2hlcy5sZW5ndGg7IHgrKykge1xuICAgIHZhciBwYXRjaCA9IHBhdGNoZXNbeF07XG4gICAgdmFyIHBhdGNoQ29weSA9IG5ldyBwYXRjaF9vYmooKTtcbiAgICBwYXRjaENvcHkuZGlmZnMgPSBbXTtcbiAgICBmb3IgKHZhciB5ID0gMDsgeSA8IHBhdGNoLmRpZmZzLmxlbmd0aDsgeSsrKSB7XG4gICAgICBwYXRjaENvcHkuZGlmZnNbeV0gPSBwYXRjaC5kaWZmc1t5XS5zbGljZSgpO1xuICAgIH1cbiAgICBwYXRjaENvcHkuc3RhcnQxID0gcGF0Y2guc3RhcnQxO1xuICAgIHBhdGNoQ29weS5zdGFydDIgPSBwYXRjaC5zdGFydDI7XG4gICAgcGF0Y2hDb3B5Lmxlbmd0aDEgPSBwYXRjaC5sZW5ndGgxO1xuICAgIHBhdGNoQ29weS5sZW5ndGgyID0gcGF0Y2gubGVuZ3RoMjtcbiAgICBwYXRjaGVzQ29weVt4XSA9IHBhdGNoQ29weTtcbiAgfVxuICByZXR1cm4gcGF0Y2hlc0NvcHk7XG59O1xuXG5cbi8qKlxuICogTWVyZ2UgYSBzZXQgb2YgcGF0Y2hlcyBvbnRvIHRoZSB0ZXh0LiAgUmV0dXJuIGEgcGF0Y2hlZCB0ZXh0LCBhcyB3ZWxsXG4gKiBhcyBhIGxpc3Qgb2YgdHJ1ZS9mYWxzZSB2YWx1ZXMgaW5kaWNhdGluZyB3aGljaCBwYXRjaGVzIHdlcmUgYXBwbGllZC5cbiAqIEBwYXJhbSB7QXJyYXkuPHBhdGNoX29iaj59IHBhdGNoZXMgQXJyYXkgb2YgcGF0Y2ggb2JqZWN0cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IE9sZCB0ZXh0LlxuICogQHJldHVybiB7QXJyYXkuPHN0cmluZ3xBcnJheS48Ym9vbGVhbj4+fSBUd28gZWxlbWVudCBBcnJheSwgY29udGFpbmluZyB0aGVcbiAqICAgICAgbmV3IHRleHQgYW5kIGFuIGFycmF5IG9mIGJvb2xlYW4gdmFsdWVzLlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5wYXRjaF9hcHBseSA9IGZ1bmN0aW9uKHBhdGNoZXMsIHRleHQpIHtcbiAgaWYgKHBhdGNoZXMubGVuZ3RoID09IDApIHtcbiAgICByZXR1cm4gW3RleHQsIFtdXTtcbiAgfVxuXG4gIC8vIERlZXAgY29weSB0aGUgcGF0Y2hlcyBzbyB0aGF0IG5vIGNoYW5nZXMgYXJlIG1hZGUgdG8gb3JpZ2luYWxzLlxuICBwYXRjaGVzID0gdGhpcy5wYXRjaF9kZWVwQ29weShwYXRjaGVzKTtcblxuICB2YXIgbnVsbFBhZGRpbmcgPSB0aGlzLnBhdGNoX2FkZFBhZGRpbmcocGF0Y2hlcyk7XG4gIHRleHQgPSBudWxsUGFkZGluZyArIHRleHQgKyBudWxsUGFkZGluZztcblxuICB0aGlzLnBhdGNoX3NwbGl0TWF4KHBhdGNoZXMpO1xuICAvLyBkZWx0YSBrZWVwcyB0cmFjayBvZiB0aGUgb2Zmc2V0IGJldHdlZW4gdGhlIGV4cGVjdGVkIGFuZCBhY3R1YWwgbG9jYXRpb25cbiAgLy8gb2YgdGhlIHByZXZpb3VzIHBhdGNoLiAgSWYgdGhlcmUgYXJlIHBhdGNoZXMgZXhwZWN0ZWQgYXQgcG9zaXRpb25zIDEwIGFuZFxuICAvLyAyMCwgYnV0IHRoZSBmaXJzdCBwYXRjaCB3YXMgZm91bmQgYXQgMTIsIGRlbHRhIGlzIDIgYW5kIHRoZSBzZWNvbmQgcGF0Y2hcbiAgLy8gaGFzIGFuIGVmZmVjdGl2ZSBleHBlY3RlZCBwb3NpdGlvbiBvZiAyMi5cbiAgdmFyIGRlbHRhID0gMDtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBwYXRjaGVzLmxlbmd0aDsgeCsrKSB7XG4gICAgdmFyIGV4cGVjdGVkX2xvYyA9IHBhdGNoZXNbeF0uc3RhcnQyICsgZGVsdGE7XG4gICAgdmFyIHRleHQxID0gdGhpcy5kaWZmX3RleHQxKHBhdGNoZXNbeF0uZGlmZnMpO1xuICAgIHZhciBzdGFydF9sb2M7XG4gICAgdmFyIGVuZF9sb2MgPSAtMTtcbiAgICBpZiAodGV4dDEubGVuZ3RoID4gdGhpcy5NYXRjaF9NYXhCaXRzKSB7XG4gICAgICAvLyBwYXRjaF9zcGxpdE1heCB3aWxsIG9ubHkgcHJvdmlkZSBhbiBvdmVyc2l6ZWQgcGF0dGVybiBpbiB0aGUgY2FzZSBvZlxuICAgICAgLy8gYSBtb25zdGVyIGRlbGV0ZS5cbiAgICAgIHN0YXJ0X2xvYyA9IHRoaXMubWF0Y2hfbWFpbih0ZXh0LCB0ZXh0MS5zdWJzdHJpbmcoMCwgdGhpcy5NYXRjaF9NYXhCaXRzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZF9sb2MpO1xuICAgICAgaWYgKHN0YXJ0X2xvYyAhPSAtMSkge1xuICAgICAgICBlbmRfbG9jID0gdGhpcy5tYXRjaF9tYWluKHRleHQsXG4gICAgICAgICAgICB0ZXh0MS5zdWJzdHJpbmcodGV4dDEubGVuZ3RoIC0gdGhpcy5NYXRjaF9NYXhCaXRzKSxcbiAgICAgICAgICAgIGV4cGVjdGVkX2xvYyArIHRleHQxLmxlbmd0aCAtIHRoaXMuTWF0Y2hfTWF4Qml0cyk7XG4gICAgICAgIGlmIChlbmRfbG9jID09IC0xIHx8IHN0YXJ0X2xvYyA+PSBlbmRfbG9jKSB7XG4gICAgICAgICAgLy8gQ2FuJ3QgZmluZCB2YWxpZCB0cmFpbGluZyBjb250ZXh0LiAgRHJvcCB0aGlzIHBhdGNoLlxuICAgICAgICAgIHN0YXJ0X2xvYyA9IC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0X2xvYyA9IHRoaXMubWF0Y2hfbWFpbih0ZXh0LCB0ZXh0MSwgZXhwZWN0ZWRfbG9jKTtcbiAgICB9XG4gICAgaWYgKHN0YXJ0X2xvYyA9PSAtMSkge1xuICAgICAgLy8gTm8gbWF0Y2ggZm91bmQuICA6KFxuICAgICAgcmVzdWx0c1t4XSA9IGZhbHNlO1xuICAgICAgLy8gU3VidHJhY3QgdGhlIGRlbHRhIGZvciB0aGlzIGZhaWxlZCBwYXRjaCBmcm9tIHN1YnNlcXVlbnQgcGF0Y2hlcy5cbiAgICAgIGRlbHRhIC09IHBhdGNoZXNbeF0ubGVuZ3RoMiAtIHBhdGNoZXNbeF0ubGVuZ3RoMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm91bmQgYSBtYXRjaC4gIDopXG4gICAgICByZXN1bHRzW3hdID0gdHJ1ZTtcbiAgICAgIGRlbHRhID0gc3RhcnRfbG9jIC0gZXhwZWN0ZWRfbG9jO1xuICAgICAgdmFyIHRleHQyO1xuICAgICAgaWYgKGVuZF9sb2MgPT0gLTEpIHtcbiAgICAgICAgdGV4dDIgPSB0ZXh0LnN1YnN0cmluZyhzdGFydF9sb2MsIHN0YXJ0X2xvYyArIHRleHQxLmxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0MiA9IHRleHQuc3Vic3RyaW5nKHN0YXJ0X2xvYywgZW5kX2xvYyArIHRoaXMuTWF0Y2hfTWF4Qml0cyk7XG4gICAgICB9XG4gICAgICBpZiAodGV4dDEgPT0gdGV4dDIpIHtcbiAgICAgICAgLy8gUGVyZmVjdCBtYXRjaCwganVzdCBzaG92ZSB0aGUgcmVwbGFjZW1lbnQgdGV4dCBpbi5cbiAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHN0YXJ0X2xvYykgK1xuICAgICAgICAgICAgICAgdGhpcy5kaWZmX3RleHQyKHBhdGNoZXNbeF0uZGlmZnMpICtcbiAgICAgICAgICAgICAgIHRleHQuc3Vic3RyaW5nKHN0YXJ0X2xvYyArIHRleHQxLmxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJbXBlcmZlY3QgbWF0Y2guICBSdW4gYSBkaWZmIHRvIGdldCBhIGZyYW1ld29yayBvZiBlcXVpdmFsZW50XG4gICAgICAgIC8vIGluZGljZXMuXG4gICAgICAgIHZhciBkaWZmcyA9IHRoaXMuZGlmZl9tYWluKHRleHQxLCB0ZXh0MiwgZmFsc2UpO1xuICAgICAgICBpZiAodGV4dDEubGVuZ3RoID4gdGhpcy5NYXRjaF9NYXhCaXRzICYmXG4gICAgICAgICAgICB0aGlzLmRpZmZfbGV2ZW5zaHRlaW4oZGlmZnMpIC8gdGV4dDEubGVuZ3RoID5cbiAgICAgICAgICAgIHRoaXMuUGF0Y2hfRGVsZXRlVGhyZXNob2xkKSB7XG4gICAgICAgICAgLy8gVGhlIGVuZCBwb2ludHMgbWF0Y2gsIGJ1dCB0aGUgY29udGVudCBpcyB1bmFjY2VwdGFibHkgYmFkLlxuICAgICAgICAgIHJlc3VsdHNbeF0gPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRpZmZfY2xlYW51cFNlbWFudGljTG9zc2xlc3MoZGlmZnMpO1xuICAgICAgICAgIHZhciBpbmRleDEgPSAwO1xuICAgICAgICAgIHZhciBpbmRleDI7XG4gICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBwYXRjaGVzW3hdLmRpZmZzLmxlbmd0aDsgeSsrKSB7XG4gICAgICAgICAgICB2YXIgbW9kID0gcGF0Y2hlc1t4XS5kaWZmc1t5XTtcbiAgICAgICAgICAgIGlmIChtb2RbMF0gIT09IERJRkZfRVFVQUwpIHtcbiAgICAgICAgICAgICAgaW5kZXgyID0gdGhpcy5kaWZmX3hJbmRleChkaWZmcywgaW5kZXgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb2RbMF0gPT09IERJRkZfSU5TRVJUKSB7ICAvLyBJbnNlcnRpb25cbiAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHN0YXJ0X2xvYyArIGluZGV4MikgKyBtb2RbMV0gK1xuICAgICAgICAgICAgICAgICAgICAgdGV4dC5zdWJzdHJpbmcoc3RhcnRfbG9jICsgaW5kZXgyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobW9kWzBdID09PSBESUZGX0RFTEVURSkgeyAgLy8gRGVsZXRpb25cbiAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHN0YXJ0X2xvYyArIGluZGV4MikgK1xuICAgICAgICAgICAgICAgICAgICAgdGV4dC5zdWJzdHJpbmcoc3RhcnRfbG9jICsgdGhpcy5kaWZmX3hJbmRleChkaWZmcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDEgKyBtb2RbMV0ubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW9kWzBdICE9PSBESUZGX0RFTEVURSkge1xuICAgICAgICAgICAgICBpbmRleDEgKz0gbW9kWzFdLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gU3RyaXAgdGhlIHBhZGRpbmcgb2ZmLlxuICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcobnVsbFBhZGRpbmcubGVuZ3RoLCB0ZXh0Lmxlbmd0aCAtIG51bGxQYWRkaW5nLmxlbmd0aCk7XG4gIHJldHVybiBbdGV4dCwgcmVzdWx0c107XG59O1xuXG5cbi8qKlxuICogQWRkIHNvbWUgcGFkZGluZyBvbiB0ZXh0IHN0YXJ0IGFuZCBlbmQgc28gdGhhdCBlZGdlcyBjYW4gbWF0Y2ggc29tZXRoaW5nLlxuICogSW50ZW5kZWQgdG8gYmUgY2FsbGVkIG9ubHkgZnJvbSB3aXRoaW4gcGF0Y2hfYXBwbHkuXG4gKiBAcGFyYW0ge0FycmF5LjxwYXRjaF9vYmo+fSBwYXRjaGVzIEFycmF5IG9mIHBhdGNoIG9iamVjdHMuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBwYWRkaW5nIHN0cmluZyBhZGRlZCB0byBlYWNoIHNpZGUuXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLnBhdGNoX2FkZFBhZGRpbmcgPSBmdW5jdGlvbihwYXRjaGVzKSB7XG4gIHZhciBwYWRkaW5nTGVuZ3RoID0gdGhpcy5QYXRjaF9NYXJnaW47XG4gIHZhciBudWxsUGFkZGluZyA9ICcnO1xuICBmb3IgKHZhciB4ID0gMTsgeCA8PSBwYWRkaW5nTGVuZ3RoOyB4KyspIHtcbiAgICBudWxsUGFkZGluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHgpO1xuICB9XG5cbiAgLy8gQnVtcCBhbGwgdGhlIHBhdGNoZXMgZm9yd2FyZC5cbiAgZm9yICh2YXIgeCA9IDA7IHggPCBwYXRjaGVzLmxlbmd0aDsgeCsrKSB7XG4gICAgcGF0Y2hlc1t4XS5zdGFydDEgKz0gcGFkZGluZ0xlbmd0aDtcbiAgICBwYXRjaGVzW3hdLnN0YXJ0MiArPSBwYWRkaW5nTGVuZ3RoO1xuICB9XG5cbiAgLy8gQWRkIHNvbWUgcGFkZGluZyBvbiBzdGFydCBvZiBmaXJzdCBkaWZmLlxuICB2YXIgcGF0Y2ggPSBwYXRjaGVzWzBdO1xuICB2YXIgZGlmZnMgPSBwYXRjaC5kaWZmcztcbiAgaWYgKGRpZmZzLmxlbmd0aCA9PSAwIHx8IGRpZmZzWzBdWzBdICE9IERJRkZfRVFVQUwpIHtcbiAgICAvLyBBZGQgbnVsbFBhZGRpbmcgZXF1YWxpdHkuXG4gICAgZGlmZnMudW5zaGlmdChbRElGRl9FUVVBTCwgbnVsbFBhZGRpbmddKTtcbiAgICBwYXRjaC5zdGFydDEgLT0gcGFkZGluZ0xlbmd0aDsgIC8vIFNob3VsZCBiZSAwLlxuICAgIHBhdGNoLnN0YXJ0MiAtPSBwYWRkaW5nTGVuZ3RoOyAgLy8gU2hvdWxkIGJlIDAuXG4gICAgcGF0Y2gubGVuZ3RoMSArPSBwYWRkaW5nTGVuZ3RoO1xuICAgIHBhdGNoLmxlbmd0aDIgKz0gcGFkZGluZ0xlbmd0aDtcbiAgfSBlbHNlIGlmIChwYWRkaW5nTGVuZ3RoID4gZGlmZnNbMF1bMV0ubGVuZ3RoKSB7XG4gICAgLy8gR3JvdyBmaXJzdCBlcXVhbGl0eS5cbiAgICB2YXIgZXh0cmFMZW5ndGggPSBwYWRkaW5nTGVuZ3RoIC0gZGlmZnNbMF1bMV0ubGVuZ3RoO1xuICAgIGRpZmZzWzBdWzFdID0gbnVsbFBhZGRpbmcuc3Vic3RyaW5nKGRpZmZzWzBdWzFdLmxlbmd0aCkgKyBkaWZmc1swXVsxXTtcbiAgICBwYXRjaC5zdGFydDEgLT0gZXh0cmFMZW5ndGg7XG4gICAgcGF0Y2guc3RhcnQyIC09IGV4dHJhTGVuZ3RoO1xuICAgIHBhdGNoLmxlbmd0aDEgKz0gZXh0cmFMZW5ndGg7XG4gICAgcGF0Y2gubGVuZ3RoMiArPSBleHRyYUxlbmd0aDtcbiAgfVxuXG4gIC8vIEFkZCBzb21lIHBhZGRpbmcgb24gZW5kIG9mIGxhc3QgZGlmZi5cbiAgcGF0Y2ggPSBwYXRjaGVzW3BhdGNoZXMubGVuZ3RoIC0gMV07XG4gIGRpZmZzID0gcGF0Y2guZGlmZnM7XG4gIGlmIChkaWZmcy5sZW5ndGggPT0gMCB8fCBkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVswXSAhPSBESUZGX0VRVUFMKSB7XG4gICAgLy8gQWRkIG51bGxQYWRkaW5nIGVxdWFsaXR5LlxuICAgIGRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIG51bGxQYWRkaW5nXSk7XG4gICAgcGF0Y2gubGVuZ3RoMSArPSBwYWRkaW5nTGVuZ3RoO1xuICAgIHBhdGNoLmxlbmd0aDIgKz0gcGFkZGluZ0xlbmd0aDtcbiAgfSBlbHNlIGlmIChwYWRkaW5nTGVuZ3RoID4gZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0ubGVuZ3RoKSB7XG4gICAgLy8gR3JvdyBsYXN0IGVxdWFsaXR5LlxuICAgIHZhciBleHRyYUxlbmd0aCA9IHBhZGRpbmdMZW5ndGggLSBkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVsxXS5sZW5ndGg7XG4gICAgZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0gKz0gbnVsbFBhZGRpbmcuc3Vic3RyaW5nKDAsIGV4dHJhTGVuZ3RoKTtcbiAgICBwYXRjaC5sZW5ndGgxICs9IGV4dHJhTGVuZ3RoO1xuICAgIHBhdGNoLmxlbmd0aDIgKz0gZXh0cmFMZW5ndGg7XG4gIH1cblxuICByZXR1cm4gbnVsbFBhZGRpbmc7XG59O1xuXG5cbi8qKlxuICogTG9vayB0aHJvdWdoIHRoZSBwYXRjaGVzIGFuZCBicmVhayB1cCBhbnkgd2hpY2ggYXJlIGxvbmdlciB0aGFuIHRoZSBtYXhpbXVtXG4gKiBsaW1pdCBvZiB0aGUgbWF0Y2ggYWxnb3JpdGhtLlxuICogQHBhcmFtIHtBcnJheS48cGF0Y2hfb2JqPn0gcGF0Y2hlcyBBcnJheSBvZiBwYXRjaCBvYmplY3RzLlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5wYXRjaF9zcGxpdE1heCA9IGZ1bmN0aW9uKHBhdGNoZXMpIHtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBwYXRjaGVzLmxlbmd0aDsgeCsrKSB7XG4gICAgaWYgKHBhdGNoZXNbeF0ubGVuZ3RoMSA+IHRoaXMuTWF0Y2hfTWF4Qml0cykge1xuICAgICAgdmFyIGJpZ3BhdGNoID0gcGF0Y2hlc1t4XTtcbiAgICAgIC8vIFJlbW92ZSB0aGUgYmlnIG9sZCBwYXRjaC5cbiAgICAgIHBhdGNoZXMuc3BsaWNlKHgtLSwgMSk7XG4gICAgICB2YXIgcGF0Y2hfc2l6ZSA9IHRoaXMuTWF0Y2hfTWF4Qml0cztcbiAgICAgIHZhciBzdGFydDEgPSBiaWdwYXRjaC5zdGFydDE7XG4gICAgICB2YXIgc3RhcnQyID0gYmlncGF0Y2guc3RhcnQyO1xuICAgICAgdmFyIHByZWNvbnRleHQgPSAnJztcbiAgICAgIHdoaWxlIChiaWdwYXRjaC5kaWZmcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgLy8gQ3JlYXRlIG9uZSBvZiBzZXZlcmFsIHNtYWxsZXIgcGF0Y2hlcy5cbiAgICAgICAgdmFyIHBhdGNoID0gbmV3IHBhdGNoX29iaigpO1xuICAgICAgICB2YXIgZW1wdHkgPSB0cnVlO1xuICAgICAgICBwYXRjaC5zdGFydDEgPSBzdGFydDEgLSBwcmVjb250ZXh0Lmxlbmd0aDtcbiAgICAgICAgcGF0Y2guc3RhcnQyID0gc3RhcnQyIC0gcHJlY29udGV4dC5sZW5ndGg7XG4gICAgICAgIGlmIChwcmVjb250ZXh0ICE9PSAnJykge1xuICAgICAgICAgIHBhdGNoLmxlbmd0aDEgPSBwYXRjaC5sZW5ndGgyID0gcHJlY29udGV4dC5sZW5ndGg7XG4gICAgICAgICAgcGF0Y2guZGlmZnMucHVzaChbRElGRl9FUVVBTCwgcHJlY29udGV4dF0pO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChiaWdwYXRjaC5kaWZmcy5sZW5ndGggIT09IDAgJiZcbiAgICAgICAgICAgICAgIHBhdGNoLmxlbmd0aDEgPCBwYXRjaF9zaXplIC0gdGhpcy5QYXRjaF9NYXJnaW4pIHtcbiAgICAgICAgICB2YXIgZGlmZl90eXBlID0gYmlncGF0Y2guZGlmZnNbMF1bMF07XG4gICAgICAgICAgdmFyIGRpZmZfdGV4dCA9IGJpZ3BhdGNoLmRpZmZzWzBdWzFdO1xuICAgICAgICAgIGlmIChkaWZmX3R5cGUgPT09IERJRkZfSU5TRVJUKSB7XG4gICAgICAgICAgICAvLyBJbnNlcnRpb25zIGFyZSBoYXJtbGVzcy5cbiAgICAgICAgICAgIHBhdGNoLmxlbmd0aDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIHN0YXJ0MiArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgICAgICAgICAgcGF0Y2guZGlmZnMucHVzaChiaWdwYXRjaC5kaWZmcy5zaGlmdCgpKTtcbiAgICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChkaWZmX3R5cGUgPT09IERJRkZfREVMRVRFICYmIHBhdGNoLmRpZmZzLmxlbmd0aCA9PSAxICYmXG4gICAgICAgICAgICAgICAgICAgICBwYXRjaC5kaWZmc1swXVswXSA9PSBESUZGX0VRVUFMICYmXG4gICAgICAgICAgICAgICAgICAgICBkaWZmX3RleHQubGVuZ3RoID4gMiAqIHBhdGNoX3NpemUpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBsYXJnZSBkZWxldGlvbi4gIExldCBpdCBwYXNzIGluIG9uZSBjaHVuay5cbiAgICAgICAgICAgIHBhdGNoLmxlbmd0aDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIHN0YXJ0MSArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgICAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgIHBhdGNoLmRpZmZzLnB1c2goW2RpZmZfdHlwZSwgZGlmZl90ZXh0XSk7XG4gICAgICAgICAgICBiaWdwYXRjaC5kaWZmcy5zaGlmdCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBEZWxldGlvbiBvciBlcXVhbGl0eS4gIE9ubHkgdGFrZSBhcyBtdWNoIGFzIHdlIGNhbiBzdG9tYWNoLlxuICAgICAgICAgICAgZGlmZl90ZXh0ID0gZGlmZl90ZXh0LnN1YnN0cmluZygwLCBwYXRjaF9zaXplIC0gcGF0Y2gubGVuZ3RoMSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuUGF0Y2hfTWFyZ2luKTtcbiAgICAgICAgICAgIHBhdGNoLmxlbmd0aDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIHN0YXJ0MSArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGRpZmZfdHlwZSA9PT0gRElGRl9FUVVBTCkge1xuICAgICAgICAgICAgICBwYXRjaC5sZW5ndGgyICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgIHN0YXJ0MiArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhdGNoLmRpZmZzLnB1c2goW2RpZmZfdHlwZSwgZGlmZl90ZXh0XSk7XG4gICAgICAgICAgICBpZiAoZGlmZl90ZXh0ID09IGJpZ3BhdGNoLmRpZmZzWzBdWzFdKSB7XG4gICAgICAgICAgICAgIGJpZ3BhdGNoLmRpZmZzLnNoaWZ0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBiaWdwYXRjaC5kaWZmc1swXVsxXSA9XG4gICAgICAgICAgICAgICAgICBiaWdwYXRjaC5kaWZmc1swXVsxXS5zdWJzdHJpbmcoZGlmZl90ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGhlYWQgY29udGV4dCBmb3IgdGhlIG5leHQgcGF0Y2guXG4gICAgICAgIHByZWNvbnRleHQgPSB0aGlzLmRpZmZfdGV4dDIocGF0Y2guZGlmZnMpO1xuICAgICAgICBwcmVjb250ZXh0ID1cbiAgICAgICAgICAgIHByZWNvbnRleHQuc3Vic3RyaW5nKHByZWNvbnRleHQubGVuZ3RoIC0gdGhpcy5QYXRjaF9NYXJnaW4pO1xuICAgICAgICAvLyBBcHBlbmQgdGhlIGVuZCBjb250ZXh0IGZvciB0aGlzIHBhdGNoLlxuICAgICAgICB2YXIgcG9zdGNvbnRleHQgPSB0aGlzLmRpZmZfdGV4dDEoYmlncGF0Y2guZGlmZnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3Vic3RyaW5nKDAsIHRoaXMuUGF0Y2hfTWFyZ2luKTtcbiAgICAgICAgaWYgKHBvc3Rjb250ZXh0ICE9PSAnJykge1xuICAgICAgICAgIHBhdGNoLmxlbmd0aDEgKz0gcG9zdGNvbnRleHQubGVuZ3RoO1xuICAgICAgICAgIHBhdGNoLmxlbmd0aDIgKz0gcG9zdGNvbnRleHQubGVuZ3RoO1xuICAgICAgICAgIGlmIChwYXRjaC5kaWZmcy5sZW5ndGggIT09IDAgJiZcbiAgICAgICAgICAgICAgcGF0Y2guZGlmZnNbcGF0Y2guZGlmZnMubGVuZ3RoIC0gMV1bMF0gPT09IERJRkZfRVFVQUwpIHtcbiAgICAgICAgICAgIHBhdGNoLmRpZmZzW3BhdGNoLmRpZmZzLmxlbmd0aCAtIDFdWzFdICs9IHBvc3Rjb250ZXh0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBwb3N0Y29udGV4dF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVtcHR5KSB7XG4gICAgICAgICAgcGF0Y2hlcy5zcGxpY2UoKyt4LCAwLCBwYXRjaCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBUYWtlIGEgbGlzdCBvZiBwYXRjaGVzIGFuZCByZXR1cm4gYSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uLlxuICogQHBhcmFtIHtBcnJheS48cGF0Y2hfb2JqPn0gcGF0Y2hlcyBBcnJheSBvZiBwYXRjaCBvYmplY3RzLlxuICogQHJldHVybiB7c3RyaW5nfSBUZXh0IHJlcHJlc2VudGF0aW9uIG9mIHBhdGNoZXMuXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLnBhdGNoX3RvVGV4dCA9IGZ1bmN0aW9uKHBhdGNoZXMpIHtcbiAgdmFyIHRleHQgPSBbXTtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBwYXRjaGVzLmxlbmd0aDsgeCsrKSB7XG4gICAgdGV4dFt4XSA9IHBhdGNoZXNbeF07XG4gIH1cbiAgcmV0dXJuIHRleHQuam9pbignJyk7XG59O1xuXG5cbi8qKlxuICogUGFyc2UgYSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHBhdGNoZXMgYW5kIHJldHVybiBhIGxpc3Qgb2YgcGF0Y2ggb2JqZWN0cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0bGluZSBUZXh0IHJlcHJlc2VudGF0aW9uIG9mIHBhdGNoZXMuXG4gKiBAcmV0dXJuIHtBcnJheS48cGF0Y2hfb2JqPn0gQXJyYXkgb2YgcGF0Y2ggb2JqZWN0cy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBpbnZhbGlkIGlucHV0LlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5wYXRjaF9mcm9tVGV4dCA9IGZ1bmN0aW9uKHRleHRsaW5lKSB7XG4gIHZhciBwYXRjaGVzID0gW107XG4gIGlmICghdGV4dGxpbmUpIHtcbiAgICByZXR1cm4gcGF0Y2hlcztcbiAgfVxuICAvLyBPcGVyYSBkb2Vzbid0IGtub3cgaG93IHRvIGRlY29kZSBjaGFyIDAuXG4gIHRleHRsaW5lID0gdGV4dGxpbmUucmVwbGFjZSgvJTAwL2csICdcXDAnKTtcbiAgdmFyIHRleHQgPSB0ZXh0bGluZS5zcGxpdCgnXFxuJyk7XG4gIHZhciB0ZXh0UG9pbnRlciA9IDA7XG4gIHdoaWxlICh0ZXh0UG9pbnRlciA8IHRleHQubGVuZ3RoKSB7XG4gICAgdmFyIG0gPSB0ZXh0W3RleHRQb2ludGVyXS5tYXRjaCgvXkBAIC0oXFxkKyksPyhcXGQqKSBcXCsoXFxkKyksPyhcXGQqKSBAQCQvKTtcbiAgICBpZiAoIW0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYXRjaCBzdHJpbmc6ICcgKyB0ZXh0W3RleHRQb2ludGVyXSk7XG4gICAgfVxuICAgIHZhciBwYXRjaCA9IG5ldyBwYXRjaF9vYmooKTtcbiAgICBwYXRjaGVzLnB1c2gocGF0Y2gpO1xuICAgIHBhdGNoLnN0YXJ0MSA9IHBhcnNlSW50KG1bMV0sIDEwKTtcbiAgICBpZiAobVsyXSA9PT0gJycpIHtcbiAgICAgIHBhdGNoLnN0YXJ0MS0tO1xuICAgICAgcGF0Y2gubGVuZ3RoMSA9IDE7XG4gICAgfSBlbHNlIGlmIChtWzJdID09ICcwJykge1xuICAgICAgcGF0Y2gubGVuZ3RoMSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGNoLnN0YXJ0MS0tO1xuICAgICAgcGF0Y2gubGVuZ3RoMSA9IHBhcnNlSW50KG1bMl0sIDEwKTtcbiAgICB9XG5cbiAgICBwYXRjaC5zdGFydDIgPSBwYXJzZUludChtWzNdLCAxMCk7XG4gICAgaWYgKG1bNF0gPT09ICcnKSB7XG4gICAgICBwYXRjaC5zdGFydDItLTtcbiAgICAgIHBhdGNoLmxlbmd0aDIgPSAxO1xuICAgIH0gZWxzZSBpZiAobVs0XSA9PSAnMCcpIHtcbiAgICAgIHBhdGNoLmxlbmd0aDIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRjaC5zdGFydDItLTtcbiAgICAgIHBhdGNoLmxlbmd0aDIgPSBwYXJzZUludChtWzRdLCAxMCk7XG4gICAgfVxuICAgIHRleHRQb2ludGVyKys7XG5cbiAgICB3aGlsZSAodGV4dFBvaW50ZXIgPCB0ZXh0Lmxlbmd0aCkge1xuICAgICAgdmFyIHNpZ24gPSB0ZXh0W3RleHRQb2ludGVyXS5jaGFyQXQoMCk7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbGluZSA9IGRlY29kZVVSSSh0ZXh0W3RleHRQb2ludGVyXS5zdWJzdHJpbmcoMSkpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgLy8gTWFsZm9ybWVkIFVSSSBzZXF1ZW5jZS5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGVzY2FwZSBpbiBwYXRjaF9mcm9tVGV4dDogJyArIGxpbmUpO1xuICAgICAgfVxuICAgICAgaWYgKHNpZ24gPT0gJy0nKSB7XG4gICAgICAgIC8vIERlbGV0aW9uLlxuICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0RFTEVURSwgbGluZV0pO1xuICAgICAgfSBlbHNlIGlmIChzaWduID09ICcrJykge1xuICAgICAgICAvLyBJbnNlcnRpb24uXG4gICAgICAgIHBhdGNoLmRpZmZzLnB1c2goW0RJRkZfSU5TRVJULCBsaW5lXSk7XG4gICAgICB9IGVsc2UgaWYgKHNpZ24gPT0gJyAnKSB7XG4gICAgICAgIC8vIE1pbm9yIGVxdWFsaXR5LlxuICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBsaW5lXSk7XG4gICAgICB9IGVsc2UgaWYgKHNpZ24gPT0gJ0AnKSB7XG4gICAgICAgIC8vIFN0YXJ0IG9mIG5leHQgcGF0Y2guXG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChzaWduID09PSAnJykge1xuICAgICAgICAvLyBCbGFuayBsaW5lPyAgV2hhdGV2ZXIuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXVEY/XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYXRjaCBtb2RlIFwiJyArIHNpZ24gKyAnXCIgaW46ICcgKyBsaW5lKTtcbiAgICAgIH1cbiAgICAgIHRleHRQb2ludGVyKys7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXRjaGVzO1xufTtcblxuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBvbmUgcGF0Y2ggb3BlcmF0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIHBhdGNoX29iaigpIHtcbiAgLyoqIEB0eXBlIHtBcnJheS48QXJyYXkuPG51bWJlcnxzdHJpbmc+Pn0gKi9cbiAgdGhpcy5kaWZmcyA9IFtdO1xuICAvKiogQHR5cGUgez9udW1iZXJ9ICovXG4gIHRoaXMuc3RhcnQxID0gbnVsbDtcbiAgLyoqIEB0eXBlIHs/bnVtYmVyfSAqL1xuICB0aGlzLnN0YXJ0MiA9IG51bGw7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB0aGlzLmxlbmd0aDEgPSAwO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdGhpcy5sZW5ndGgyID0gMDtcbn1cblxuXG4vKipcbiAqIEVtbXVsYXRlIEdOVSBkaWZmJ3MgZm9ybWF0LlxuICogSGVhZGVyOiBAQCAtMzgyLDggKzQ4MSw5IEBAXG4gKiBJbmRpY2llcyBhcmUgcHJpbnRlZCBhcyAxLWJhc2VkLCBub3QgMC1iYXNlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIEdOVSBkaWZmIHN0cmluZy5cbiAqL1xucGF0Y2hfb2JqLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY29vcmRzMSwgY29vcmRzMjtcbiAgaWYgKHRoaXMubGVuZ3RoMSA9PT0gMCkge1xuICAgIGNvb3JkczEgPSB0aGlzLnN0YXJ0MSArICcsMCc7XG4gIH0gZWxzZSBpZiAodGhpcy5sZW5ndGgxID09IDEpIHtcbiAgICBjb29yZHMxID0gdGhpcy5zdGFydDEgKyAxO1xuICB9IGVsc2Uge1xuICAgIGNvb3JkczEgPSAodGhpcy5zdGFydDEgKyAxKSArICcsJyArIHRoaXMubGVuZ3RoMTtcbiAgfVxuICBpZiAodGhpcy5sZW5ndGgyID09PSAwKSB7XG4gICAgY29vcmRzMiA9IHRoaXMuc3RhcnQyICsgJywwJztcbiAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aDIgPT0gMSkge1xuICAgIGNvb3JkczIgPSB0aGlzLnN0YXJ0MiArIDE7XG4gIH0gZWxzZSB7XG4gICAgY29vcmRzMiA9ICh0aGlzLnN0YXJ0MiArIDEpICsgJywnICsgdGhpcy5sZW5ndGgyO1xuICB9XG4gIHZhciB0ZXh0ID0gWydAQCAtJyArIGNvb3JkczEgKyAnICsnICsgY29vcmRzMiArICcgQEBcXG4nXTtcbiAgdmFyIG9wO1xuICAvLyBFc2NhcGUgdGhlIGJvZHkgb2YgdGhlIHBhdGNoIHdpdGggJXh4IG5vdGF0aW9uLlxuICBmb3IgKHZhciB4ID0gMDsgeCA8IHRoaXMuZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICBzd2l0Y2ggKHRoaXMuZGlmZnNbeF1bMF0pIHtcbiAgICAgIGNhc2UgRElGRl9JTlNFUlQ6XG4gICAgICAgIG9wID0gJysnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XG4gICAgICAgIG9wID0gJy0nO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9FUVVBTDpcbiAgICAgICAgb3AgPSAnICc7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0ZXh0W3ggKyAxXSA9IG9wICsgZW5jb2RlVVJJKHRoaXMuZGlmZnNbeF1bMV0pICsgJ1xcbic7XG4gIH1cbiAgLy8gT3BlcmEgZG9lc24ndCBrbm93IGhvdyB0byBlbmNvZGUgY2hhciAwLlxuICByZXR1cm4gdGV4dC5qb2luKCcnKS5yZXBsYWNlKC9cXHgwMC9nLCAnJTAwJykucmVwbGFjZSgvJTIwL2csICcgJyk7XG59O1xuXG5cbi8vIEV4cG9ydCB0aGVzZSBnbG9iYWwgdmFyaWFibGVzIHNvIHRoYXQgdGhleSBzdXJ2aXZlIEdvb2dsZSdzIEpTIGNvbXBpbGVyLlxuLypjaGFuZ2VkIGJ5IGxmYm9yamFzOiBjaGFuZ2VkIGB3aW5kb3dgIGZvciBgZXhwb3J0c2AgdG8gbWFrZSBpdCBzdWl0YWJsZSBmb3IgdGhlIG5vZGUuanMgbW9kdWxlIGNvbnZlbnRpb25zKi9cbmV4cG9ydHNbJ2RpZmZfbWF0Y2hfcGF0Y2gnXSA9IGRpZmZfbWF0Y2hfcGF0Y2g7XG5leHBvcnRzWydwYXRjaF9vYmonXSA9IHBhdGNoX29iajtcbmV4cG9ydHNbJ0RJRkZfREVMRVRFJ10gPSBESUZGX0RFTEVURTtcbmV4cG9ydHNbJ0RJRkZfSU5TRVJUJ10gPSBESUZGX0lOU0VSVDtcbmV4cG9ydHNbJ0RJRkZfRVFVQUwnXSA9IERJRkZfRVFVQUw7XG4iLCJpbXBvcnQgeyBDaGFuZ2VzZXQgfSBmcm9tICdjaGFuZ2VzZXRzJztcbmltcG9ydCBFZGl0b3IgZnJvbSAnc3RydWN0dXJlZC10ZXh0LWVkaXRvci9zcmMvZWRpdG9yJztcbmltcG9ydCBMaW5rZWRSZWNvcmRzIGZyb20gJy4uLy4uL3NyYy9icm93c2VyX3Nkay9pbmRleCc7XG5pbXBvcnQgTG9uZ1RleHRDaGFuZ2UgZnJvbSAnLi4vLi4vc3JjL2F0dHJpYnV0ZXMvbG9uZ190ZXh0L2xvbmdfdGV4dF9jaGFuZ2UnO1xuaW1wb3J0IEtleVZhbHVlQ2hhbmdlIGZyb20gJy4uLy4uL3NyYy9hdHRyaWJ1dGVzL2tleV92YWx1ZS9rZXlfdmFsdWVfY2hhbmdlJztcbmltcG9ydCBMb25nVGV4dEF0dHJpYnV0ZSBmcm9tICcuLi8uLi9zcmMvYXR0cmlidXRlcy9sb25nX3RleHQvY2xpZW50JztcbmltcG9ydCBLZXlWYWx1ZUF0dHJpYnV0ZSBmcm9tICcuLi8uLi9zcmMvYXR0cmlidXRlcy9rZXlfdmFsdWUvY2xpZW50JztcblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGFzeW5jIChldmVudCkgPT4ge1xuICBjb25zdCBlZGl0b3IgPSBuZXcgRWRpdG9yKCd2YWx1ZScpO1xuICBjb25zdCBsaW5rZWRSZWNvcmRzID0gbmV3IExpbmtlZFJlY29yZHMobmV3IFVSTCgnaHR0cDovLzEwLjYwLjMuMjE4OjMwMDAnKSk7XG5cbiAgLy8gY29uc3QgY29udGVudCA9IGF3YWl0IGxpbmtlZFJlY29yZHMuQXR0cmlidXRlLmNyZWF0ZSgnbG9uZ1RleHQnLCAnaW5pdGFsJyk7XG4gIC8vIGNvbnNvbGUubG9nKCdOZXcgQ29udGVudElkJywgY29udGVudC5pZCk7XG4gIC8vIGNvbnN0IGNvbnRlbnRJZCA9IGNvbnRlbnQuaWQ7XG5cbiAgY29uc3QgY29udGVudElkID0gJ2wtMzlkNWFiMDctYjU3MS00ZDNiLWFiZjAtMmE1OTc0ZmU0MWRmJztcblxuICBsZXQgeyBjb250ZW50OiBjb250ZW50QXR0cmlidXRlLCByZWZlcm5jZXM6IFsgcmVmZXJlbmNlc0F0dHJpYnV0ZSBdIH0gPSA8e1xuICAgIGNvbnRlbnQ6IExvbmdUZXh0QXR0cmlidXRlLFxuICAgIHJlZmVybmNlczogS2V5VmFsdWVBdHRyaWJ1dGVbXSxcbiAgICByZWZlcmVuY2VTb3VyY2VzOiBLZXlWYWx1ZUF0dHJpYnV0ZVtdXG4gIH0+IDx1bmtub3duPiBhd2FpdCBsaW5rZWRSZWNvcmRzLkF0dHJpYnV0ZS5maW5kQWxsKHtcbiAgICBjb250ZW50OiBjb250ZW50SWQsXG4gICAgcmVmZXJuY2VzOiBbXG4gICAgICBbJ2lzQScsICdyZWZlcmVuY2VTdG9yZSddLFxuICAgICAgWydiZWxvbmdzVG8nLCBjb250ZW50SWRdLFxuICAgIF0sXG4gICAgcmVmZXJlbmNlU291cmNlczogW1xuICAgICAgWydpc0EnLCAncmVmZXJlbmNlU291cmNlU3RvcmUnXSxcbiAgICAgIFsnYmVsb25nc1RvJywgY29udGVudElkXSxcbiAgICAgIFsnYmVsb25nc1RvJywgJ3Vzci14eCddLFxuICAgIF1cbiAgfSk7XG5cbiAgaWYgKCFyZWZlcmVuY2VzQXR0cmlidXRlKSB7XG4gICAgcmVmZXJlbmNlc0F0dHJpYnV0ZSA9IGF3YWl0IGxpbmtlZFJlY29yZHMuQXR0cmlidXRlLmNyZWF0ZSgna2V5VmFsdWUnLCB7fSkgYXMgS2V5VmFsdWVBdHRyaWJ1dGU7XG4gICAgYXdhaXQgbGlua2VkUmVjb3Jkcy5GYWN0LmNyZWF0ZUFsbChbXG4gICAgICBbcmVmZXJlbmNlc0F0dHJpYnV0ZS5pZCwgJ2lzQScsICdyZWZlcmVuY2VTdG9yZSddLFxuICAgICAgW3JlZmVyZW5jZXNBdHRyaWJ1dGUuaWQsICdiZWxvbmdzVG8nLCBjb250ZW50SWRdXG4gICAgXSk7XG4gIH1cblxuICBlZGl0b3Iuc2V0Q29udGVudChhd2FpdCBjb250ZW50QXR0cmlidXRlLmdldFZhbHVlKCkpO1xuICBlZGl0b3IuYWRkUmVmZXJlbmNlRGF0YShhd2FpdCByZWZlcmVuY2VzQXR0cmlidXRlLmdldFZhbHVlKCkpO1xuXG4gIHJlZmVyZW5jZXNBdHRyaWJ1dGUuc3Vic2NyaWJlKGFzeW5jIChjaGFuZ2VzZXQpID0+IHtcbiAgICBjb25zdCBuZXdEYXRhID0ge307XG5cbiAgICBjaGFuZ2VzZXQuY2hhbmdlLmZvckVhY2goKHtrZXksIHZhbHVlfSkgPT4ge1xuICAgICAgbmV3RGF0YVtrZXldID0gdmFsdWU7XG4gICAgfSk7XG5cbiAgICBlZGl0b3IuYWRkUmVmZXJlbmNlRGF0YShuZXdEYXRhKTtcbiAgfSk7XG5cbiAgZWRpdG9yLnN1YnNjcmliZVJlZmVyZW5jZUluc2VydGlvbihhc3luYyAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgIHJlZmVyZW5jZXNBdHRyaWJ1dGUhLmNoYW5nZShuZXcgS2V5VmFsdWVDaGFuZ2UoW3sga2V5LCB2YWx1ZSB9XSkpO1xuICB9KTtcblxuICBjb250ZW50QXR0cmlidXRlLnN1YnNjcmliZShhc3luYyAoY2hhbmdlc2V0LCBjaGFuZ2VJbmZvKSA9PiB7XG4gICAgY29uc3QgYXR0ciA9IHsgYWN0b3I6IHsgaWQ6IGNoYW5nZUluZm8uYWN0b3JJZCB9IH07XG5cbiAgICB0cnkge1xuICAgICAgZWRpdG9yLmFwcGx5Q2hhbmdlc2V0KGNoYW5nZXNldC5jaGFuZ2VzZXQsIGF0dHIpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBjb25zb2xlLmxvZygnZmFpbGVkIHRvIGFwcGx5IGNoYW5nZXNldCB0byBFRElUT1IgY29udGVudC4gRmFsbGluZyBiYWNrIHRvIHJlcGxhY2UgdGhlIHdob2xlIGVkaXRvcnMgY29udGVudCcsIGV4KTtcbiAgICAgIGVkaXRvci5zZXRDb250ZW50KGF3YWl0IGNvbnRlbnRBdHRyaWJ1dGUuZ2V0VmFsdWUoKSwgYXR0cik7XG4gICAgfVxuICB9KTtcblxuICBlZGl0b3Iuc3Vic2NyaWJlKGFzeW5jIChtb2RpZmljYXRpb25Mb2cpID0+IHtcbiAgICBpZiAoIW1vZGlmaWNhdGlvbkxvZy5hY3Rvcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgY29udGVudEF0dHJpYnV0ZS5jaGFuZ2UobmV3IExvbmdUZXh0Q2hhbmdlKG1vZGlmaWNhdGlvbkxvZy50b0NoYW5nZXNldChDaGFuZ2VzZXQpKSk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBjb25zb2xlLmxvZygnZmFpbGVkIHRvIGFwcGx5IGNoYW5nZXNldCB0byBBVFRSSUJVVEUuIEZhbGxpbmcgYmFjayB0byByZXBsYWNlIHdob2xlIGF0dHJpYnV0ZSBjb250ZW50JywgZXgpO1xuICAgICAgICBhd2FpdCBjb250ZW50QXR0cmlidXRlLnNldChlZGl0b3IuZ2V0T3JpZ2luYWxDb250ZW50KCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59KTtcbiIsImV4cG9ydCBpbnRlcmZhY2UgSXNTdWJzY3JpYmFibGUge1xuICBzdWJzY3JpYmUodXJsOiBzdHJpbmcsIGNoYW5uZWw6IHN0cmluZywgaGFuZGxlcjogKGRhdGE6IGFueSkgPT4gYW55KTtcbiAgdW5zdWJzY3JpYmVBbGwoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VydmVyU2lkZUV2ZW50cyBpbXBsZW1lbnRzIElzU3Vic2NyaWJhYmxlIHtcbiAgc3Vic2NyaXB0aW9ucyA9IHt9O1xuXG4gIGNvbm5ldGlvbnMgPSB7fTtcblxuICBpc1BhdXNlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIG1lc3NhZ2VzV2hpbGVQYXVzZWQ6IHsgY2I6IChkYXRhOiBhbnkpID0+IGFueSwgZGF0YTogYW55IH1bXSA9IFtdO1xuXG4gIHRhYklkOiBzdHJpbmcgPSAoTWF0aC5yYW5kb20oKSArIDEpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNyk7XG5cbiAgcHVibGljIGdldEV2ZW50U291cmNlQXN5bmModXJsOiBVUkwpIHtcbiAgICBpZiAoIXVybC5zZWFyY2hQYXJhbXMuaGFzKCd0YWJJZCcpKSB7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZCgndGFiSWQnLCB0aGlzLnRhYklkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3Qgc291cmNlID0gbmV3IEV2ZW50U291cmNlKHVybC50b1N0cmluZygpKTtcblxuICAgICAgc291cmNlLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICBzb3VyY2Uub25vcGVuID0gKCkgPT4gcmVzb2x2ZShzb3VyY2UpO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHN1YnNjcmliZSh1cmw6IHN0cmluZywgY2hhbm5lbDogc3RyaW5nLCBoYW5kbGVyOiAoZGF0YTogYW55KSA9PiBhbnkpIHtcbiAgICBjb25zdCBwYXJzZWRVcmw6IFVSTCA9IG5ldyBVUkwodXJsKTtcbiAgICBjb25zdCBzdWJJZCA9IGAke3BhcnNlZFVybC5vcmlnaW59LSR7Y2hhbm5lbH1gO1xuXG4gICAgaWYgKCFwYXJzZWRVcmwuc2VhcmNoUGFyYW1zLmhhcygndGFiSWQnKSkge1xuICAgICAgcGFyc2VkVXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoJ3RhYklkJywgdGhpcy50YWJJZCk7XG4gICAgfVxuXG4gICAgYXdhaXQgdGhpcy5lbnN1cmVDb25uZWN0aW9uKHBhcnNlZFVybC5vcmlnaW4pO1xuICAgIGF3YWl0IGZldGNoKHBhcnNlZFVybC50b1N0cmluZygpKTtcblxuICAgIHRoaXMuc3Vic2NyaXB0aW9uc1tzdWJJZF0gPSB0aGlzLnN1YnNjcmlwdGlvbnNbc3ViSWRdIHx8IFtdO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9uc1tzdWJJZF0ucHVzaChoYW5kbGVyKTtcbiAgfVxuXG4gIHB1YmxpYyB1bnN1YnNjcmliZUFsbCgpIHtcbiAgICBPYmplY3QudmFsdWVzKHRoaXMuY29ubmV0aW9ucykuZm9yRWFjaCgoY29ubmVjdGlvbjogYW55KSA9PiB7XG4gICAgICBjb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmNvbm5ldGlvbnMgPSB7fTtcbiAgfVxuXG4gIHB1YmxpYyBwYXVzZU5vdGlmaWNhdGlvbigpIHtcbiAgICB0aGlzLmlzUGF1c2VkID0gdHJ1ZTtcbiAgfVxuXG4gIHB1YmxpYyB1bnBhdXNlTm90aWZpY2F0aW9uKCkge1xuICAgIHRoaXMubWVzc2FnZXNXaGlsZVBhdXNlZC5mb3JFYWNoKCh7IGNiLCBkYXRhIH0pID0+IHtcbiAgICAgIGNiKGRhdGEpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5tZXNzYWdlc1doaWxlUGF1c2VkID0gW107XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGVuc3VyZUNvbm5lY3Rpb24ob3JpZ2luKSB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChvcmlnaW4pO1xuICAgIHVybC5wYXRobmFtZSA9ICcvc2VydmVyLXNlbnQtZXZlbnRzJztcblxuICAgIGlmICghdGhpcy5jb25uZXRpb25zW3VybC5vcmlnaW5dKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmNvbm5ldGlvbnNbdXJsLm9yaWdpbl0gPSBhd2FpdCB0aGlzLmdldEV2ZW50U291cmNlQXN5bmModXJsKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIHRoaXMuY29ubmV0aW9uc1t1cmwub3JpZ2luXSA9IGF3YWl0IHRoaXMuZ2V0RXZlbnRTb3VyY2VBc3luYyh1cmwpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbm5ldGlvbnNbdXJsLm9yaWdpbl0ub25tZXNzYWdlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgICAgICBjb25zdCB7IHNzZUNoYW5uZWwgfSA9IGRhdGE7XG5cbiAgICAgICAgaWYgKCFzc2VDaGFubmVsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIGRhdGEuc3NlQ2hhbm5lbDtcblxuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb25zID0gdGhpcy5zdWJzY3JpcHRpb25zW2Ake3VybC5vcmlnaW59LSR7c3NlQ2hhbm5lbH1gXTtcblxuICAgICAgICBpZiAoc3Vic2NyaXB0aW9ucykge1xuICAgICAgICAgIHN1YnNjcmlwdGlvbnMuZm9yRWFjaCgoY2IpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUGF1c2VkKSB7XG4gICAgICAgICAgICAgIHRoaXMubWVzc2FnZXNXaGlsZVBhdXNlZC5wdXNoKHsgY2IsIGRhdGEgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjYihkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jb25uZXRpb25zW29yaWdpbl07XG4gIH1cbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9uby1jeWNsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgY2xhc3MtbWV0aG9kcy11c2UtdGhpcyAqL1xuXG5pbXBvcnQgeyB2NCBhcyB1dWlkIH0gZnJvbSAndXVpZCc7XG5pbXBvcnQgTGlua2VkUmVjb3JkcyBmcm9tICcuLi8uLi9icm93c2VyX3Nkay9pbmRleCc7XG5pbXBvcnQgU2VyaWFsaXplZENoYW5nZVdpdGhNZXRhZGF0YSBmcm9tICcuL3NlcmlhbGl6ZWRfY2hhbmdlX3dpdGhfbWV0YWRhdGEnO1xuaW1wb3J0IElzU2VyaWFsaXphYmxlIGZyb20gJy4vaXNfc2VyaWFsaXphYmxlJztcbmltcG9ydCB7IElzU3Vic2NyaWJhYmxlIH0gZnJvbSAnLi4vLi4vLi4vbGliL3NlcnZlci1zaWRlLWV2ZW50cy9jbGllbnQnO1xuXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBBYnN0cmFjdEF0dHJpYnV0ZUNsaWVudCA8VHlwZSwgVHlwZWRDaGFuZ2UgZXh0ZW5kcyBJc1NlcmlhbGl6YWJsZSA+IHtcbiAgbGlua2VkUmVjb3JkczogTGlua2VkUmVjb3JkcztcblxuICBzZXJ2ZXJTaWRlRXZlbnRzOiBJc1N1YnNjcmliYWJsZTtcblxuICBpZD86IHN0cmluZztcblxuICBhY3RvcklkOiBzdHJpbmc7XG5cbiAgY2xpZW50SWQ6IHN0cmluZztcblxuICBzZXJ2ZXJVUkw6IFVSTDtcblxuICBvYnNlcnZlcnM6IEZ1bmN0aW9uW107XG5cbiAgaXNJbml0aWFsaXplZDogYm9vbGVhbjtcblxuICB2ZXJzaW9uOiBzdHJpbmc7IC8vIFRPRE86IHNob3VsZCBiZSBudW1iZXJcblxuICB2YWx1ZTogVHlwZTtcblxuICBjb25zdHJ1Y3RvcihsaW5rZWRSZWNvcmRzOiBMaW5rZWRSZWNvcmRzLCBzZXJ2ZXJTaWRlRXZlbnRzOiBJc1N1YnNjcmliYWJsZSwgaWQ/OiBzdHJpbmcpIHtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5saW5rZWRSZWNvcmRzID0gbGlua2VkUmVjb3JkcztcbiAgICB0aGlzLnNlcnZlclNpZGVFdmVudHMgPSBzZXJ2ZXJTaWRlRXZlbnRzO1xuICAgIHRoaXMuc2VydmVyVVJMID0gbGlua2VkUmVjb3Jkcy5zZXJ2ZXJVUkw7XG4gICAgdGhpcy5vYnNlcnZlcnMgPSBbXTtcblxuICAgIC8vIGJlY2F1c2UgdGhlIHNhbWUgdXNlciBjYW4gYmUgbG9nZ2VkIG9uIHR3byBicm93c2Vycy9sYXB0b3BzLCB3ZSBuZWVkXG4gICAgLy8gYSBjbGllbnRJZCBhbmQgYW4gYWN0b3JJZFxuICAgIHRoaXMuY2xpZW50SWQgPSBsaW5rZWRSZWNvcmRzLmNsaWVudElkO1xuICAgIHRoaXMuYWN0b3JJZCA9IGxpbmtlZFJlY29yZHMuYWN0b3JJZDtcblxuICAgIHRoaXMudmVyc2lvbiA9ICcwJztcbiAgICB0aGlzLnZhbHVlID0gdGhpcy5nZXREZWZhdWx0VmFsdWUoKTtcbiAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZ2V0RGF0YVR5cGVOYW1lKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZ2V0RGF0YVR5cGVOYW1lIG5lZWRzIHRvIGJlIGltcGxlbWVudGVkIGluIGNoaWxkIGNsYXNzJyk7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGlzQXR0cmlidXRlSWQoaWQ6IHN0cmluZykge1xuICAgIHJldHVybiBpZC5zcGxpdCgnLScpWzBdID09PSB0aGlzLnByb3RvdHlwZS5nZXREYXRhVHlwZVByZWZpeCgpO1xuICB9XG5cbiAgcHVibGljIGFic3RyYWN0IGdldERhdGFUeXBlUHJlZml4KCk7XG4gIHB1YmxpYyBhYnN0cmFjdCBnZXREZWZhdWx0VmFsdWUoKSA6IFR5cGU7XG4gIHB1YmxpYyBhYnN0cmFjdCBkZXNlcmlhbGl6ZVZhbHVlKHNlcmlhbGl6ZWRWYWx1ZTogc3RyaW5nKSA6IFR5cGU7XG5cbiAgcHJvdGVjdGVkIGFic3RyYWN0IHJhd1NldChuZXdWYWx1ZTogVHlwZSk6IHZvaWQ7XG4gIHByb3RlY3RlZCBhYnN0cmFjdCByYXdDaGFuZ2UoZGVsdGE6IFR5cGVkQ2hhbmdlKTogdm9pZDtcbiAgcHJvdGVjdGVkIGFic3RyYWN0IG9uU2VydmVyTWVzc2FnZShwYXlsb2FkOiBTZXJpYWxpemVkQ2hhbmdlV2l0aE1ldGFkYXRhPFR5cGVkQ2hhbmdlPik7XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBvbkxvYWQoKTtcblxuICBwdWJsaWMgYXN5bmMgY3JlYXRlKHZhbHVlOiBUeXBlKSB7XG4gICAgaWYgKHRoaXMuaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNyZWF0ZSBhdHRyaWJ1dGUgYmVjYXVzZSBpdCBoYXMgYW4gaWQgYXNzaWduZWQgKCR7dGhpcy5pZH0pYCk7XG4gICAgfVxuXG4gICAgdGhpcy5pZCA9IGAke3RoaXMuZ2V0RGF0YVR5cGVQcmVmaXgoKX0tJHt1dWlkKCl9YDtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy53aXRoQ29ubmVjdGlvbkxvc3RIYW5kbGVyKCgpID0+IGZldGNoKGAke3RoaXMubGlua2VkUmVjb3Jkcy5zZXJ2ZXJVUkx9YXR0cmlidXRlcy8ke3RoaXMuaWR9YCwge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBjbGllbnRJZDogdGhpcy5jbGllbnRJZCxcbiAgICAgICAgYWN0b3JJZDogdGhpcy5hY3RvcklkLFxuICAgICAgICB2YWx1ZSxcbiAgICAgIH0pLFxuICAgIH0pKTtcblxuICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgY29tbXVuaWNhdGluZyB3aXRoIHRoZSBzZXJ2ZXIgd2hlbiBjcmVhdGluZyBhdHRyaWJ1dGUuJyk7XG4gICAgfVxuXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICB0aGlzLmhhbmRsZUV4cGlyZWRMb2dpblNlc3Npb24oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgY3JlYXRpbmcgYXR0cmlidXRlOiAke2F3YWl0IHJlc3BvbnNlLnRleHQoKX1gKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZUJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgYXdhaXQgdGhpcy5sb2FkKHJlc3BvbnNlQm9keSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0KCkgOiBQcm9taXNlPHsgdmFsdWU6IFR5cGUsIGNoYW5nZUlkOiBzdHJpbmcsIGFjdG9ySWQ6IHN0cmluZyB9PiB7XG4gICAgYXdhaXQgdGhpcy5sb2FkKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IHRoaXMudmFsdWUsXG4gICAgICBjaGFuZ2VJZDogdGhpcy52ZXJzaW9uLFxuICAgICAgYWN0b3JJZDogdGhpcy5hY3RvcklkLFxuICAgIH07XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0VmFsdWUoKSA6IFByb21pc2U8VHlwZT4ge1xuICAgIGF3YWl0IHRoaXMubG9hZCgpO1xuXG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgc2V0KG5ld1ZhbHVlOiBUeXBlKSA6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMubG9hZCgpO1xuXG4gICAgaWYgKG5ld1ZhbHVlID09PSB0aGlzLnZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYXdhaXQgdGhpcy5yYXdTZXQobmV3VmFsdWUpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGNoYW5nZShjaGFuZ2U6IFR5cGVkQ2hhbmdlKSA6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMubG9hZCgpO1xuICAgIGF3YWl0IHRoaXMucmF3Q2hhbmdlKGNoYW5nZSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgc3Vic2NyaWJlKG9ic2VydmVyOiBGdW5jdGlvbikge1xuICAgIGF3YWl0IHRoaXMubG9hZCgpO1xuICAgIHRoaXMub2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpO1xuICB9XG5cbiAgcHVibGljIGhhbmRsZUV4cGlyZWRMb2dpblNlc3Npb24oKSB7XG4gICAgY29uc3Qgd2luOiBXaW5kb3cgPSB3aW5kb3c7XG4gICAgd2luLmxvY2F0aW9uID0gJy9sb2dpbic7XG4gIH1cblxuICBwdWJsaWMgaGFuZGxlQ29ubmVjdGlvbkVycm9yKGVycm9yKSB7XG4gICAgY29uc29sZS5sb2coJ0Nvbm5lY3Rpb24gTG9zdCcsIGVycm9yKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyB3aXRoQ29ubmVjdGlvbkxvc3RIYW5kbGVyKGZuOiAoKSA9PiBQcm9taXNlPGFueT4pIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IGZuKCk7XG4gICAgfSBjYXRjaCAoZXg6IGFueSkge1xuICAgICAgaWYgKGV4Lm1lc3NhZ2UgPT09ICdGYWlsZWQgdG8gZmV0Y2gnKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlQ29ubmVjdGlvbkVycm9yKGV4KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBsb2FkKHNlcnZlclN0YXRlPzogeyBjaGFuZ2VJZDogc3RyaW5nLCB2YWx1ZTogc3RyaW5nIH0pIHtcbiAgICBsZXQgcmVzdWx0ID0gc2VydmVyU3RhdGU7XG5cbiAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBsb2FkIGFuIGF0dHJpYnV0ZSB3aXRob3V0IGlkJyk7XG4gICAgfVxuXG4gICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZTtcblxuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICBjb25zdCB1cmwgPSBgJHt0aGlzLnNlcnZlclVSTH1hdHRyaWJ1dGVzLyR7dGhpcy5pZH0/Y2xpZW50SWQ9JHt0aGlzLmNsaWVudElkfSZhY3RvcklkPSR7dGhpcy5hY3RvcklkfWA7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMud2l0aENvbm5lY3Rpb25Mb3N0SGFuZGxlcigoKSA9PiBmZXRjaCh1cmwpKTtcblxuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRXhwaXJlZExvZ2luU2Vzc2lvbigpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGpzb25Cb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIGNoYW5nZUlkOiBqc29uQm9keS5jaGFuZ2VJZCxcbiAgICAgICAgdmFsdWU6IGpzb25Cb2R5LnZhbHVlLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLnZlcnNpb24gPSByZXN1bHQuY2hhbmdlSWQ7XG4gICAgdGhpcy52YWx1ZSA9IHRoaXMuZGVzZXJpYWxpemVWYWx1ZSh0eXBlb2YgcmVzdWx0LnZhbHVlID09PSAnc3RyaW5nJyA/IHJlc3VsdC52YWx1ZSA6IEpTT04uc3RyaW5naWZ5KHJlc3VsdC52YWx1ZSkpO1xuICAgIHRoaXMub25Mb2FkKCk7XG4gICAgdGhpcy5ub3RpZnlTdWJzY3JpYmVycyh1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG5cbiAgICBjb25zdCB1cmwgPSBgJHt0aGlzLnNlcnZlclVSTH1hdHRyaWJ1dGVzLyR7dGhpcy5pZH0vY2hhbmdlcz9jbGllbnRJZD0ke3RoaXMuY2xpZW50SWR9JmFjdG9ySWQ9JHt0aGlzLmFjdG9ySWR9YDtcbiAgICBhd2FpdCB0aGlzLnNlcnZlclNpZGVFdmVudHMuc3Vic2NyaWJlKHVybCwgdGhpcy5pZCwgKHBhcnNlZERhdGEpID0+IHtcbiAgICAgIGlmIChwYXJzZWREYXRhLmF0dHJpYnV0ZUlkICE9PSB0aGlzLmlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vblNlcnZlck1lc3NhZ2UocGFyc2VkRGF0YSk7XG4gICAgfSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgc2VuZFRvU2VydmVyKGNoYW5nZTogU2VyaWFsaXplZENoYW5nZVdpdGhNZXRhZGF0YTxUeXBlZENoYW5nZT4pIHtcbiAgICBjb25zdCB1cmwgPSBgJHt0aGlzLnNlcnZlclVSTH1hdHRyaWJ1dGVzLyR7dGhpcy5pZH0/Y2xpZW50SWQ9JHt0aGlzLmNsaWVudElkfSZhY3RvcklkPSR7dGhpcy5hY3RvcklkfWA7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLndpdGhDb25uZWN0aW9uTG9zdEhhbmRsZXIoKCkgPT4gZmV0Y2godXJsLCB7XG4gICAgICBtZXRob2Q6ICdQQVRDSCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGNoYW5nZS50b0pTT04oKSksXG4gICAgfSkpO1xuXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICB0aGlzLmhhbmRsZUV4cGlyZWRMb2dpblNlc3Npb24oKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgbm90aWZ5U3Vic2NyaWJlcnMoY2hhbmdlPzogVHlwZWRDaGFuZ2UsIGZ1bGxDaGFuZ2VJbmZvPzogeyBhY3RvcklkOiBzdHJpbmcgfSkge1xuICAgIHRoaXMub2JzZXJ2ZXJzLmZvckVhY2goKGNhbGxiYWNrKSA9PiB7XG4gICAgICBjYWxsYmFjayhjaGFuZ2UsIGZ1bGxDaGFuZ2VJbmZvKTtcbiAgICB9KTtcbiAgfVxufVxuIiwiaW1wb3J0IElzU2VyaWFsaXphYmxlIGZyb20gJy4vaXNfc2VyaWFsaXphYmxlJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VyaWFsaXplZENoYW5nZVdpdGhNZXRhZGF0YTxDaGFuZ2UgZXh0ZW5kcyBJc1NlcmlhbGl6YWJsZT4ge1xuICBwdWJsaWMgYXR0cmlidXRlSWQ6IHN0cmluZztcblxuICBwdWJsaWMgYWN0b3JJZDogc3RyaW5nO1xuXG4gIHB1YmxpYyBjbGllbnRJZDogc3RyaW5nO1xuXG4gIHB1YmxpYyBjaGFuZ2U6IENoYW5nZTtcblxuICBjb25zdHJ1Y3RvcihhdHRyaWJ1dGVJZDogc3RyaW5nLCBhY3RvcklkOiBzdHJpbmcsIGNsaWVudElkOiBzdHJpbmcsIGNoYW5nZTogQ2hhbmdlKSB7XG4gICAgdGhpcy5hdHRyaWJ1dGVJZCA9IGF0dHJpYnV0ZUlkO1xuICAgIHRoaXMuYWN0b3JJZCA9IGFjdG9ySWQ7XG4gICAgdGhpcy5jbGllbnRJZCA9IGNsaWVudElkO1xuICAgIHRoaXMuY2hhbmdlID0gY2hhbmdlO1xuICB9XG5cbiAgdG9KU09OKCk6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGF0dHJpYnV0ZUlkOiB0aGlzLmF0dHJpYnV0ZUlkLFxuICAgICAgY2hhbmdlOiB0aGlzLmNoYW5nZS50b0pTT04oKSxcbiAgICAgIGFjdG9ySWQ6IHRoaXMuYWN0b3JJZCxcbiAgICAgIGNsaWVudElkOiB0aGlzLmNsaWVudElkLFxuICAgIH07XG4gIH1cbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvbiAqL1xuLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L25vLWN5Y2xlICovXG4vKiBlc2xpbnQtZGlzYWJsZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzICovXG5pbXBvcnQgQWJzdHJhY3RBdHRyaWJ1dGVDbGllbnQgZnJvbSAnLi4vLi4vYWJzdHJhY3QvYWJzdHJhY3RfYXR0cmlidXRlX2NsaWVudCc7XG5pbXBvcnQgU2VyaWFsaXplZENoYW5nZVdpdGhNZXRhZGF0YSBmcm9tICcuLi8uLi9hYnN0cmFjdC9zZXJpYWxpemVkX2NoYW5nZV93aXRoX21ldGFkYXRhJztcbmltcG9ydCBLZXlWYWx1ZUNoYW5nZSwgeyBBdG9taWNDaGFuZ2UgfSBmcm9tICcuLi9rZXlfdmFsdWVfY2hhbmdlJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS2V5VmFsdWVBdHRyaWJ1dGUgZXh0ZW5kcyBBYnN0cmFjdEF0dHJpYnV0ZUNsaWVudDxvYmplY3QsIEtleVZhbHVlQ2hhbmdlPiB7XG4gIHB1YmxpYyBzdGF0aWMgZ2V0RGF0YVR5cGVQcmVmaXgoKSA6IHN0cmluZyB7XG4gICAgcmV0dXJuICdrdic7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGdldERhdGFUeXBlTmFtZSgpIDogc3RyaW5nIHtcbiAgICByZXR1cm4gJ2tleVZhbHVlJztcbiAgfVxuXG4gIHB1YmxpYyBnZXREYXRhVHlwZVByZWZpeCgpIDogc3RyaW5nIHtcbiAgICByZXR1cm4gS2V5VmFsdWVBdHRyaWJ1dGUuZ2V0RGF0YVR5cGVQcmVmaXgoKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXREYXRhVHlwZU5hbWUoKSA6IHN0cmluZyB7XG4gICAgcmV0dXJuIEtleVZhbHVlQXR0cmlidXRlLmdldERhdGFUeXBlTmFtZSgpO1xuICB9XG5cbiAgcHVibGljIGdldERlZmF1bHRWYWx1ZSgpIDogb2JqZWN0IHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICBwdWJsaWMgZGVzZXJpYWxpemVWYWx1ZShzZXJpYWxpemVkVmFsdWU6IHN0cmluZykgOiBvYmplY3Qge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHNlcmlhbGl6ZWRWYWx1ZSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgcmF3U2V0KG5ld1ZhbHVlOiBvYmplY3QpIHtcbiAgICBsZXQgY2hhbmdlczogQXRvbWljQ2hhbmdlW10gPSBbXTtcblxuICAgIE9iamVjdC5lbnRyaWVzKHRoaXMudmFsdWUpLmZvckVhY2goKFtrZXldKSA9PiB7XG4gICAgICBjaGFuZ2VzLnB1c2goeyBrZXksIHZhbHVlOiBudWxsIH0pO1xuICAgIH0pO1xuXG4gICAgT2JqZWN0LmVudHJpZXMobmV3VmFsdWUpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgY2hhbmdlcyA9IGNoYW5nZXMuZmlsdGVyKChjaCkgPT4gY2gua2V5ICE9PSBrZXkpO1xuICAgICAgY2hhbmdlcy5wdXNoKHsga2V5LCB2YWx1ZSB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMuY2hhbmdlKG5ldyBLZXlWYWx1ZUNoYW5nZShjaGFuZ2VzKSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgcmF3Q2hhbmdlKGNoYW5nZTogS2V5VmFsdWVDaGFuZ2UpIHtcbiAgICB0aGlzLnRyYW5zbWl0Q2hhbmdlKG5ldyBLZXlWYWx1ZUNoYW5nZShjaGFuZ2UuY2hhbmdlLCB0aGlzLnZlcnNpb24pKTtcbiAgICB0aGlzLnZhbHVlID0gY2hhbmdlLmFwcGx5KHRoaXMudmFsdWUpO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uTG9hZCgpIHtcbiAgfVxuXG4gIHByb3RlY3RlZCBvblNlcnZlck1lc3NhZ2UoY2hhbmdlV2l0aE1ldGFkYXRhOiBTZXJpYWxpemVkQ2hhbmdlV2l0aE1ldGFkYXRhPEtleVZhbHVlQ2hhbmdlPikge1xuICAgIGNvbnN0IGNoYW5nZSA9IG5ldyBLZXlWYWx1ZUNoYW5nZShcbiAgICAgIGNoYW5nZVdpdGhNZXRhZGF0YS5jaGFuZ2UgYXMgdW5rbm93biBhcyBBdG9taWNDaGFuZ2VbXSxcbiAgICAgIGNoYW5nZVdpdGhNZXRhZGF0YS5jaGFuZ2UuY2hhbmdlSWQsXG4gICAgKTtcblxuICAgIGlmIChjaGFuZ2VXaXRoTWV0YWRhdGEuY2xpZW50SWQgPT09IHRoaXMuY2xpZW50SWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnZhbHVlID0gY2hhbmdlLmFwcGx5KHRoaXMudmFsdWUpO1xuICAgIHRoaXMudmVyc2lvbiA9IGNoYW5nZS5jaGFuZ2VJZDtcblxuICAgIHRoaXMubm90aWZ5U3Vic2NyaWJlcnMoY2hhbmdlLCBjaGFuZ2VXaXRoTWV0YWRhdGEpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHRyYW5zbWl0Q2hhbmdlKGNoYW5nZXNldDogS2V5VmFsdWVDaGFuZ2UpIHtcbiAgICBpZiAoIXRoaXMuaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2hhbmdlIGNhbiBub3QgYmUgdHJhbnNtaXR0ZWQgYmVjYXVzZSBhdHRyaWJ1dGUgZG9lcyBub3QgaGFzIGFuIGlkJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZW5kVG9TZXJ2ZXIobmV3IFNlcmlhbGl6ZWRDaGFuZ2VXaXRoTWV0YWRhdGE8S2V5VmFsdWVDaGFuZ2U+KFxuICAgICAgdGhpcy5pZCxcbiAgICAgIHRoaXMuYWN0b3JJZCxcbiAgICAgIHRoaXMuY2xpZW50SWQsXG4gICAgICBjaGFuZ2VzZXQsXG4gICAgKSk7XG4gIH1cbn1cbiIsImV4cG9ydCB0eXBlIEF0b21pY0NoYW5nZSA9IHtcbiAga2V5OiBzdHJpbmcsXG4gIHZhbHVlOiBzdHJpbmcgfCBudWxsLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS2V5VmFsdWVDaGFuZ2Uge1xuICBwdWJsaWMgY2hhbmdlSWQ6IHN0cmluZztcblxuICBwdWJsaWMgY2hhbmdlOiBBdG9taWNDaGFuZ2VbXTtcblxuICBwdWJsaWMgc3RhdGljIGZyb21KU09OKGlucHV0OiBhbnksIGNoYW5nZUlkPzogc3RyaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBLZXlWYWx1ZUNoYW5nZShpbnB1dCBhcyBBdG9taWNDaGFuZ2VbXSwgY2hhbmdlSWQpO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBmcm9tU3RyaW5nKGlucHV0OiBzdHJpbmcpIDogS2V5VmFsdWVDaGFuZ2Uge1xuICAgIHJldHVybiBuZXcgS2V5VmFsdWVDaGFuZ2UoSlNPTi5wYXJzZShpbnB1dCkpO1xuICB9XG5cbiAgY29uc3RydWN0b3IoY2hhbmdlc2V0OiBBdG9taWNDaGFuZ2VbXSwgY2hhbmdlSWQ/OiBzdHJpbmcpIHtcbiAgICB0aGlzLmNoYW5nZUlkID0gY2hhbmdlSWQgPz8gJ3VuY29tbWl0ZWQnO1xuICAgIHRoaXMuY2hhbmdlID0gY2hhbmdlc2V0O1xuICB9XG5cbiAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuY2hhbmdlKTtcbiAgfVxuXG4gIHB1YmxpYyB0b0pTT04oKTogb2JqZWN0IHtcbiAgICByZXR1cm4gdGhpcy5jaGFuZ2U7XG4gIH1cblxuICBwdWJsaWMgYXBwbHkoaW5wdXQ6IG9iamVjdCk6IG9iamVjdCB7XG4gICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShpbnB1dCkpO1xuXG4gICAgdGhpcy5jaGFuZ2UuZm9yRWFjaCgoYUNoYW5nZSkgPT4ge1xuICAgICAgaWYgKGFDaGFuZ2UudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgZGVsZXRlIHJlc3VsdFthQ2hhbmdlLmtleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbYUNoYW5nZS5rZXldID0gYUNoYW5nZS52YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBwdWJsaWMgbWVyZ2Uob3RoZXI6IEtleVZhbHVlQ2hhbmdlKTogS2V5VmFsdWVDaGFuZ2Uge1xuICAgIGxldCBtZXJnZWRDaGFuZ2VzOiBBdG9taWNDaGFuZ2VbXSA9IFtdO1xuXG4gICAgdGhpcy5jaGFuZ2UuZm9yRWFjaCgoY2gpID0+IHtcbiAgICAgIG1lcmdlZENoYW5nZXMgPSBtZXJnZWRDaGFuZ2VzLmZpbHRlcigoeCkgPT4geC5rZXkgIT09IGNoLmtleSk7XG4gICAgICBtZXJnZWRDaGFuZ2VzLnB1c2goY2gpO1xuICAgIH0pO1xuXG4gICAgb3RoZXIuY2hhbmdlLmZvckVhY2goKGNoKSA9PiB7XG4gICAgICBtZXJnZWRDaGFuZ2VzID0gbWVyZ2VkQ2hhbmdlcy5maWx0ZXIoKHgpID0+IHgua2V5ICE9PSBjaC5rZXkpO1xuICAgICAgbWVyZ2VkQ2hhbmdlcy5wdXNoKGNoKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBuZXcgS2V5VmFsdWVDaGFuZ2UobWVyZ2VkQ2hhbmdlcyk7XG4gIH1cbn1cbiIsImltcG9ydCBMb25nVGV4dENoYW5nZSBmcm9tICcuLi9sb25nX3RleHRfY2hhbmdlJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hhbmdlQnVmZmVyIHtcbiAgdmFsdWU/OiBMb25nVGV4dENoYW5nZTtcblxuICBpbkZsaWdodE9wPzogTG9uZ1RleHRDaGFuZ2U7XG5cbiAgYWRkKGNoYW5nZXNldDogTG9uZ1RleHRDaGFuZ2UpOiB2b2lkIHtcbiAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZSA/IHRoaXMudmFsdWUubWVyZ2UoY2hhbmdlc2V0KSA6IGNoYW5nZXNldDtcbiAgfVxuXG4gIC8vIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIHRyYW5zZm9ybWVkIHZlcnNpb24gb2YgdGhlIGZvcmVpZ25DaGFuZ2Ugd2hpY2hcbiAgLy8gZml0cyBpbnRvIHRoZSBjdXJyZW50IGNsaWVudCBzdGF0ZS4gVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIHRoZSBjbGllbnRcbiAgLy8gY291bGQgaGF2ZSBzb21lIGNoYW5nZXMgd2hpY2ggaGFzIG5vdCBiZWVuIHNlbmQgdG8gdGhlIHNlcnZlciB5ZXQuIFNvLCB0aGVcbiAgLy8gc2VydmVyIGRvbid0IGtub3cgYWJvdXQgdGhlc2UgY2hhbmdlcyBhbmQgdGhlIGNoYW5nZXMgY29tbWluZyBmcm9tIHRoZSBzZXJ2ZXJcbiAgLy8gd291bGQgbm90IGZpdCBpbnRvIHRoZSBjbGllbnQgc3RhdGUuXG4gIHRyYW5zZm9ybUFnYWluc3QoXG4gICAgZm9yZWlnbkNoYW5nZTogTG9uZ1RleHRDaGFuZ2UsXG4gICAgY2hhbmdlSW5UcmFuc21pc3Npb24/OiBMb25nVGV4dENoYW5nZSxcbiAgKSA6IExvbmdUZXh0Q2hhbmdlIHtcbiAgICBpZiAoIWNoYW5nZUluVHJhbnNtaXNzaW9uKSB7XG4gICAgICByZXR1cm4gZm9yZWlnbkNoYW5nZTtcbiAgICB9XG5cbiAgICB0aGlzLmluRmxpZ2h0T3AgPSB0aGlzLmluRmxpZ2h0T3AgfHwgY2hhbmdlSW5UcmFuc21pc3Npb247XG5cbiAgICBjb25zdCBjMiA9IGZvcmVpZ25DaGFuZ2UudHJhbnNmb3JtQWdhaW5zdCh0aGlzLmluRmxpZ2h0T3AsIHRydWUpO1xuICAgIHRoaXMuaW5GbGlnaHRPcCA9IHRoaXMuaW5GbGlnaHRPcD8udHJhbnNmb3JtQWdhaW5zdChmb3JlaWduQ2hhbmdlLCBmYWxzZSk7XG5cbiAgICBpZiAoIXRoaXMudmFsdWUpIHJldHVybiBjMjtcblxuICAgIC8vIGluc3RlYWQgb2YgdXNpbmcgYSBicmlkZ2Ugd2UgdXNlIGMyIHRvIHRyYW5zZm9ybSB0aGVcbiAgICAvLyBmb3JlaWduQ2hhbmdlIChjaGFuZ2UgZnJvbSBzZXJ2ZXIpIGludG8gdGhlIGNsaWVudCBzdGF0ZS5cbiAgICBjb25zdCBjMSA9IGMyLnRyYW5zZm9ybUFnYWluc3QodGhpcy52YWx1ZSwgdHJ1ZSk7XG5cbiAgICAvLyBcIk9uY2Ugd2UgaGF2ZSB0aGlzIGluZmVycmVkIG9wZXJhdGlvbiwgYzIsIHdlIGNhbiB1c2UgaXRcbiAgICAvLyB0byB0cmFuc2Zvcm0gdGhlIGJ1ZmZlciAoYikgXCJkb3duXCIgb25lIHN0ZXBcIlxuICAgIHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlPy50cmFuc2Zvcm1BZ2FpbnN0KGMyLCBmYWxzZSk7XG5cbiAgICByZXR1cm4gYzE7XG4gIH1cblxuICBjbGVhcigpIHtcbiAgICB0aGlzLnZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaW5GbGlnaHRPcCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGdldFZhbHVlKCk6IExvbmdUZXh0Q2hhbmdlIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgfVxufVxuIiwiLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L25vLWN5Y2xlICovXG4vKiBlc2xpbnQtZGlzYWJsZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzICovXG5cbmltcG9ydCBBYnN0cmFjdEF0dHJpYnV0ZUNsaWVudCBmcm9tICcuLi8uLi9hYnN0cmFjdC9hYnN0cmFjdF9hdHRyaWJ1dGVfY2xpZW50JztcbmltcG9ydCBTZXJpYWxpemVkQ2hhbmdlV2l0aE1ldGFkYXRhIGZyb20gJy4uLy4uL2Fic3RyYWN0L3NlcmlhbGl6ZWRfY2hhbmdlX3dpdGhfbWV0YWRhdGEnO1xuaW1wb3J0IExvbmdUZXh0Q2hhbmdlIGZyb20gJy4uL2xvbmdfdGV4dF9jaGFuZ2UnO1xuaW1wb3J0IENoYW5nZUJ1ZmZlciBmcm9tICcuL2J1ZmZlcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvbmdUZXh0QXR0cmlidXRlIGV4dGVuZHMgQWJzdHJhY3RBdHRyaWJ1dGVDbGllbnQ8c3RyaW5nLCBMb25nVGV4dENoYW5nZT4ge1xuICBidWZmZXI6IENoYW5nZUJ1ZmZlciA9IG5ldyBDaGFuZ2VCdWZmZXIoKTtcblxuICBjaGFuZ2VJblRyYW5zbWlzc2lvbj86IFNlcmlhbGl6ZWRDaGFuZ2VXaXRoTWV0YWRhdGE8TG9uZ1RleHRDaGFuZ2U+ID0gdW5kZWZpbmVkO1xuXG4gIHB1YmxpYyBzdGF0aWMgZ2V0RGF0YVR5cGVQcmVmaXgoKSA6IHN0cmluZyB7XG4gICAgcmV0dXJuICdsJztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZ2V0RGF0YVR5cGVOYW1lKCkgOiBzdHJpbmcge1xuICAgIHJldHVybiAnbG9uZ1RleHQnO1xuICB9XG5cbiAgcHVibGljIGdldERhdGFUeXBlUHJlZml4KCkgOiBzdHJpbmcge1xuICAgIHJldHVybiAnbCc7XG4gIH1cblxuICBwdWJsaWMgZ2V0RGF0YVR5cGVOYW1lKCkgOiBzdHJpbmcge1xuICAgIHJldHVybiBMb25nVGV4dEF0dHJpYnV0ZS5nZXREYXRhVHlwZU5hbWUoKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXREZWZhdWx0VmFsdWUoKSA6IHN0cmluZyB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgcHVibGljIGRlc2VyaWFsaXplVmFsdWUoc2VyaWFsaXplZFZhbHVlOiBzdHJpbmcpIDogc3RyaW5nIHtcbiAgICByZXR1cm4gc2VyaWFsaXplZFZhbHVlO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIHJhd1NldChuZXdWYWx1ZTogc3RyaW5nKSB7XG4gICAgY29uc3QgY2hhbmdlc2V0ID0gTG9uZ1RleHRDaGFuZ2UuZnJvbURpZmYodGhpcy52YWx1ZSwgbmV3VmFsdWUpO1xuXG4gICAgYXdhaXQgdGhpcy5jaGFuZ2UoY2hhbmdlc2V0KTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyByYXdDaGFuZ2UoY2hhbmdlc2V0OiBMb25nVGV4dENoYW5nZSkge1xuICAgIC8vIFRPRE86IENoZWNrIGZvciB2ZXJzaW9uIGlzIHZhbGlkXG4gICAgLy8gaWYgKHRoaXMudmVyc2lvbiA9PT0gJzAnKSB7XG4gICAgLy8gICB0aHJvdyBFcnJvcignQ2Fubm90IGNoYW5nZSBhdHRyaWJ1dGUgYXMgYXR0cmlidXRlZCBzdGF0ZSBpcyBub3QgbG9hZGVkIGZyb20gc2VydmVyIScpO1xuICAgIC8vIH1cblxuICAgIHRoaXMudmFsdWUgPSBjaGFuZ2VzZXQuYXBwbHkodGhpcy52YWx1ZSk7XG5cbiAgICBpZiAodGhpcy5jaGFuZ2VJblRyYW5zbWlzc2lvbikge1xuICAgICAgdGhpcy5idWZmZXIuYWRkKGNoYW5nZXNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudHJhbnNtaXRDaGFuZ2UobmV3IExvbmdUZXh0Q2hhbmdlKGNoYW5nZXNldC5jaGFuZ2VzZXQsIHRoaXMudmVyc2lvbikpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBvbkxvYWQoKSB7XG4gICAgdGhpcy5idWZmZXIuY2xlYXIoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvblNlcnZlck1lc3NhZ2UoY2hhbmdlV2l0aE1ldGFkYXRhOiBTZXJpYWxpemVkQ2hhbmdlV2l0aE1ldGFkYXRhPExvbmdUZXh0Q2hhbmdlPikge1xuICAgIGlmIChjaGFuZ2VXaXRoTWV0YWRhdGEuY2xpZW50SWQgPT09IHRoaXMuY2xpZW50SWQpIHtcbiAgICAgIHRoaXMucHJvY2Vzc0FwcHJvdmFsKGNoYW5nZVdpdGhNZXRhZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJvY2Vzc0ZvcmVpZ25DaGFuZ2UoY2hhbmdlV2l0aE1ldGFkYXRhKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHByb2Nlc3NGb3JlaWduQ2hhbmdlKFxuICAgIGZvcmVpZ25DaGFuZ2VXaXRoTWV0YWRhdGE6IFNlcmlhbGl6ZWRDaGFuZ2VXaXRoTWV0YWRhdGE8TG9uZ1RleHRDaGFuZ2U+LFxuICApIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZm9yZWlnbkNoYW5nZXNldCA9IExvbmdUZXh0Q2hhbmdlLmZyb21TdHJpbmcoXG4gICAgICAgIGZvcmVpZ25DaGFuZ2VXaXRoTWV0YWRhdGEuY2hhbmdlLmNoYW5nZXNldCxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHRyYW5zZm9ybWVkRm9yZWlnbkNoYW5nZSA9IHRoaXMuYnVmZmVyLnRyYW5zZm9ybUFnYWluc3QoXG4gICAgICAgIGZvcmVpZ25DaGFuZ2VzZXQsXG4gICAgICAgIHRoaXMuY2hhbmdlSW5UcmFuc21pc3Npb24/LmNoYW5nZSxcbiAgICAgICk7XG5cbiAgICAgIHRoaXMudmFsdWUgPSB0cmFuc2Zvcm1lZEZvcmVpZ25DaGFuZ2UuYXBwbHkodGhpcy52YWx1ZSk7XG4gICAgICB0aGlzLnZlcnNpb24gPSBmb3JlaWduQ2hhbmdlV2l0aE1ldGFkYXRhLmNoYW5nZS5jaGFuZ2VJZDtcbiAgICAgIHRoaXMubm90aWZ5U3Vic2NyaWJlcnModHJhbnNmb3JtZWRGb3JlaWduQ2hhbmdlLCBmb3JlaWduQ2hhbmdlV2l0aE1ldGFkYXRhKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgY29uc29sZS5sb2coJ0VSUk9SOiBwcm9jZXNzaW5nIGZvcmVpZ24gY2hhbmdlIGZhaWxlZCAocHJvYmFibHkgYmVjYXVzZSBvZiBhIHByZXZpb3VzIG1lc3NhZ2UgbG9zcykuIFJlbG9hZCBzZXJ2ZXIgc3RhdGUgdG8gcmVjb3Zlci4nLCBleCk7XG4gICAgICB0aGlzLmxvYWQoKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHByb2Nlc3NBcHByb3ZhbChhcHByb3ZhbDogU2VyaWFsaXplZENoYW5nZVdpdGhNZXRhZGF0YTxMb25nVGV4dENoYW5nZT4pIHtcbiAgICBjb25zdCBidWZmZXJlZENoYW5nZXMgPSB0aGlzLmJ1ZmZlci5nZXRWYWx1ZSgpO1xuICAgIHRoaXMuY2hhbmdlSW5UcmFuc21pc3Npb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy52ZXJzaW9uID0gYXBwcm92YWwuY2hhbmdlLmNoYW5nZUlkO1xuICAgIHRoaXMuYnVmZmVyLmNsZWFyKCk7XG5cbiAgICBpZiAoYnVmZmVyZWRDaGFuZ2VzKSB7XG4gICAgICB0aGlzLnRyYW5zbWl0Q2hhbmdlKG5ldyBMb25nVGV4dENoYW5nZShidWZmZXJlZENoYW5nZXMuY2hhbmdlc2V0LCBhcHByb3ZhbC5jaGFuZ2UuY2hhbmdlSWQpKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgdHJhbnNtaXRDaGFuZ2UoY2hhbmdlc2V0OiBMb25nVGV4dENoYW5nZSkge1xuICAgIGlmICghdGhpcy5pZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGFuZ2UgY2FuIG5vdCBiZSB0cmFuc21pdHRlZCBiZWNhdXNlIGF0dHJpYnV0ZSBkb2VzIG5vdCBoYXMgYW4gaWQnKTtcbiAgICB9XG5cbiAgICB0aGlzLmNoYW5nZUluVHJhbnNtaXNzaW9uID0gbmV3IFNlcmlhbGl6ZWRDaGFuZ2VXaXRoTWV0YWRhdGE8TG9uZ1RleHRDaGFuZ2U+KFxuICAgICAgdGhpcy5pZCxcbiAgICAgIHRoaXMuYWN0b3JJZCxcbiAgICAgIHRoaXMuY2xpZW50SWQsXG4gICAgICBjaGFuZ2VzZXQsXG4gICAgKTtcblxuICAgIHRoaXMuc2VuZFRvU2VydmVyKHRoaXMuY2hhbmdlSW5UcmFuc21pc3Npb24pO1xuICB9XG59XG4iLCJpbXBvcnQgeyBDaGFuZ2VzZXQgfSBmcm9tICdjaGFuZ2VzZXRzJztcbmltcG9ydCB7IGRpZmZfbWF0Y2hfcGF0Y2ggYXMgRGlmZk1hdGNoUGF0Y2ggfSBmcm9tICdkaWZmX21hdGNoX3BhdGNoJztcblxuY29uc3QgZGlmZkVuZ2luZSA9IG5ldyBEaWZmTWF0Y2hQYXRjaCgpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb25nVGV4dENoYW5nZSB7XG4gIHB1YmxpYyBjaGFuZ2VzZXQ7XG5cbiAgcHVibGljIGNoYW5nZUlkOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoY2hhbmdlc2V0LCBjaGFuZ2VJZD86IHN0cmluZykge1xuICAgIHRoaXMuY2hhbmdlc2V0ID0gY2hhbmdlc2V0O1xuICAgIHRoaXMuY2hhbmdlSWQgPSBjaGFuZ2VJZCA/PyAndW5jb21taXRlZCc7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGZyb21TdHJpbmcoY2hhbmdlOiBzdHJpbmcpOiBMb25nVGV4dENoYW5nZSB7XG4gICAgcmV0dXJuIG5ldyBMb25nVGV4dENoYW5nZShDaGFuZ2VzZXQudW5wYWNrKGNoYW5nZSkpO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBmcm9tRGlmZihhOiBzdHJpbmcsIGI6IHN0cmluZyk6IExvbmdUZXh0Q2hhbmdlIHtcbiAgICByZXR1cm4gbmV3IExvbmdUZXh0Q2hhbmdlKENoYW5nZXNldC5mcm9tRGlmZihkaWZmRW5naW5lLmRpZmZfbWFpbihhLCBiKSkpO1xuICB9XG5cbiAgcHVibGljIGFwcGx5KHZhbHVlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmNoYW5nZXNldC5hcHBseSh2YWx1ZSk7XG4gIH1cblxuICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMuY2hhbmdlc2V0ID09PSAnc3RyaW5nJ1xuICAgICAgPyB0aGlzLmNoYW5nZXNldFxuICAgICAgOiB0aGlzLmNoYW5nZXNldC5wYWNrKCk7XG4gIH1cblxuICBwdWJsaWMgdHJhbnNmb3JtQWdhaW5zdChjaGFuZ2U6IExvbmdUZXh0Q2hhbmdlIHwgbnVsbCwgc2lkZT8pIDogTG9uZ1RleHRDaGFuZ2Uge1xuICAgIGlmICghY2hhbmdlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IExvbmdUZXh0Q2hhbmdlKHRoaXMuY2hhbmdlc2V0LnRyYW5zZm9ybUFnYWluc3QoY2hhbmdlLmNoYW5nZXNldCwgc2lkZSkpO1xuICB9XG5cbiAgcHVibGljIG1lcmdlKG90aGVyQ2hhbmdlOiBMb25nVGV4dENoYW5nZSkgOiBMb25nVGV4dENoYW5nZSB7XG4gICAgcmV0dXJuIG5ldyBMb25nVGV4dENoYW5nZSh0aGlzLmNoYW5nZXNldC5tZXJnZShvdGhlckNoYW5nZS5jaGFuZ2VzZXQpKTtcbiAgfVxuXG4gIHB1YmxpYyB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNoYW5nZXNldDogdGhpcy50b1N0cmluZygpLFxuICAgICAgY2hhbmdlSWQ6IHRoaXMuY2hhbmdlSWQsXG4gICAgfTtcbiAgfVxufVxuIiwiLyogZXNsaW50LWRpc2FibGUgbWF4LWNsYXNzZXMtcGVyLWZpbGUgKi9cbi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9uby1jeWNsZSAqL1xuXG5pbXBvcnQgeyB2NCBhcyB1dWlkIH0gZnJvbSAndXVpZCc7XG5pbXBvcnQgTG9uZ1RleHRBdHRyaWJ1dGUgZnJvbSAnLi4vYXR0cmlidXRlcy9sb25nX3RleHQvY2xpZW50JztcbmltcG9ydCBLZXlWYWx1ZUF0dHJpYnV0ZSBmcm9tICcuLi9hdHRyaWJ1dGVzL2tleV92YWx1ZS9jbGllbnQnO1xuaW1wb3J0IFNlcnZlclNpZGVFdmVudHMsIHsgSXNTdWJzY3JpYmFibGUgfSBmcm9tICcuLi8uLi9saWIvc2VydmVyLXNpZGUtZXZlbnRzL2NsaWVudCc7XG5pbXBvcnQgQWJzdHJhY3RBdHRyaWJ1dGVDbGllbnQgZnJvbSAnLi4vYXR0cmlidXRlcy9hYnN0cmFjdC9hYnN0cmFjdF9hdHRyaWJ1dGVfY2xpZW50JztcbmltcG9ydCBJc1NlcmlhbGl6YWJsZSBmcm9tICcuLi9hdHRyaWJ1dGVzL2Fic3RyYWN0L2lzX3NlcmlhbGl6YWJsZSc7XG5pbXBvcnQgRmFjdCBmcm9tICcuLi9mYWN0cy9jbGllbnQnO1xuXG5jbGFzcyBBdHRyaWJ1dGVzUmVwb3NpdG9yeSB7XG4gIGxpbmtlZFJlY29yZHM6IExpbmtlZFJlY29yZHM7XG5cbiAgcHJpdmF0ZSBzZXJ2ZXJTaWRlRXZlbnRzOiBJc1N1YnNjcmliYWJsZTtcblxuICBwcml2YXRlIHN0YXRpYyBhdHRyaWJ1dGVUeXBlcyA9IFtcbiAgICBMb25nVGV4dEF0dHJpYnV0ZSxcbiAgICBLZXlWYWx1ZUF0dHJpYnV0ZSxcbiAgXTtcblxuICBjb25zdHJ1Y3RvcihsaW5rZWRSZWNvcmRzOiBMaW5rZWRSZWNvcmRzLCBzZXJ2ZXJTaWRlRXZlbnRzOiBJc1N1YnNjcmliYWJsZSkge1xuICAgIHRoaXMubGlua2VkUmVjb3JkcyA9IGxpbmtlZFJlY29yZHM7XG4gICAgdGhpcy5zZXJ2ZXJTaWRlRXZlbnRzID0gc2VydmVyU2lkZUV2ZW50cztcbiAgfVxuXG4gIGFzeW5jIGNyZWF0ZShhdHRyaWJ1dGVUeXBlOiBzdHJpbmcsIHZhbHVlOiBhbnkpXG4gICAgOlByb21pc2U8QWJzdHJhY3RBdHRyaWJ1dGVDbGllbnQ8YW55LCBJc1NlcmlhbGl6YWJsZT4+IHtcbiAgICBjb25zdCBBdHRyaWJ1dGVDbGFzcyA9IEF0dHJpYnV0ZXNSZXBvc2l0b3J5XG4gICAgICAuYXR0cmlidXRlVHlwZXNcbiAgICAgIC5maW5kKChjKSA9PiBjLmdldERhdGFUeXBlTmFtZSgpID09PSBhdHRyaWJ1dGVUeXBlKTtcblxuICAgIGlmICghQXR0cmlidXRlQ2xhc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQXR0cmlidXRlIFR5cGUgJHthdHRyaWJ1dGVUeXBlfSBpcyB1bmtub3duYCk7XG4gICAgfVxuXG4gICAgY29uc3QgYXR0cmlidXRlOiBBYnN0cmFjdEF0dHJpYnV0ZUNsaWVudDxhbnksIElzU2VyaWFsaXphYmxlPiA9IG5ldyBBdHRyaWJ1dGVDbGFzcyhcbiAgICAgIHRoaXMubGlua2VkUmVjb3JkcyxcbiAgICAgIHRoaXMuc2VydmVyU2lkZUV2ZW50cyxcbiAgICApO1xuXG4gICAgYXdhaXQgYXR0cmlidXRlLmNyZWF0ZSh2YWx1ZSk7XG4gICAgcmV0dXJuIGF0dHJpYnV0ZTtcbiAgfVxuXG4gIGFzeW5jIGZpbmQoYXR0cmlidXRlSWQ6IHN0cmluZylcbiAgICA6UHJvbWlzZTxBYnN0cmFjdEF0dHJpYnV0ZUNsaWVudDxhbnksIElzU2VyaWFsaXphYmxlPj4ge1xuICAgIGNvbnN0IFthdHRyaWJ1dGVUeXBlUHJlZml4XSA9IGF0dHJpYnV0ZUlkLnNwbGl0KCctJyk7XG4gICAgY29uc3QgQXR0cmlidXRlQ2xhc3MgPSBBdHRyaWJ1dGVzUmVwb3NpdG9yeVxuICAgICAgLmF0dHJpYnV0ZVR5cGVzXG4gICAgICAuZmluZCgoYykgPT4gYy5nZXREYXRhVHlwZVByZWZpeCgpID09PSBhdHRyaWJ1dGVUeXBlUHJlZml4KTtcblxuICAgIGlmICghQXR0cmlidXRlQ2xhc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQXR0cmlidXRlIElEICR7YXR0cmlidXRlSWR9IGlzIHVua25vd25gKTtcbiAgICB9XG5cbiAgICBjb25zdCBhdHRyaWJ1dGUgPSBuZXcgQXR0cmlidXRlQ2xhc3ModGhpcy5saW5rZWRSZWNvcmRzLCB0aGlzLnNlcnZlclNpZGVFdmVudHMsIGF0dHJpYnV0ZUlkKTtcbiAgICBhd2FpdCBhdHRyaWJ1dGUuZ2V0KCk7XG4gICAgcmV0dXJuIGF0dHJpYnV0ZTtcbiAgfVxuXG4gIGFzeW5jIGZpbmRBbGwocXVlcnk6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgc3RyaW5nW11bXSB9KVxuICAgIDpQcm9taXNlPHtcbiAgICAgIFtrZXk6IHN0cmluZ106IEFic3RyYWN0QXR0cmlidXRlQ2xpZW50PGFueSwgYW55PltdIHwgQWJzdHJhY3RBdHRyaWJ1dGVDbGllbnQ8YW55LCBhbnk+XG4gICAgfT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGNvbnN0IHFFbnRyaWVzID0gT2JqZWN0LmVudHJpZXMocXVlcnkpO1xuICAgIGNvbnN0IHByb21pc2VzOiBQcm9taXNlPGFueT5bXSA9IFtdO1xuXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBxRW50cmllcy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgY29uc3QgcUVudHJ5ID0gcUVudHJpZXNbal07XG5cbiAgICAgIGlmIChxRW50cnkpIHtcbiAgICAgICAgY29uc3QgbiA9IHFFbnRyeVswXTtcbiAgICAgICAgY29uc3QgcSA9IHFFbnRyeVsxXTtcblxuICAgICAgICBpZiAodHlwZW9mIHEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLmZpbmQocSkudGhlbigoYXR0cmlidXRlKSA9PiB7XG4gICAgICAgICAgICByZXN1bHRbbl0gPSBhdHRyaWJ1dGU7XG4gICAgICAgICAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgcmVzdWx0W25dID0gbnVsbDtcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0W25dID0gW107XG4gICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLmxpbmtlZFJlY29yZHMuRmFjdC5maW5kQWxsKHsgc3ViamVjdDogcSB9KS50aGVuKChmYWN0cykgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmYWN0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICBjb25zdCBzdWJqZWN0SWQgPSBmYWN0c1tpXT8uc3ViamVjdDtcbiAgICAgICAgICAgICAgaWYgKHN1YmplY3RJZCAmJiAhcmVzdWx0W25dLmZpbmQoKGF0dHIpID0+IGF0dHIuaWQgPT09IHN1YmplY3RJZCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBBdHRyaWJ1dGVDbGFzcyA9IEF0dHJpYnV0ZXNSZXBvc2l0b3J5LmF0dHJpYnV0ZVR5cGVzXG4gICAgICAgICAgICAgICAgICAuZmluZCgoYXQpID0+IGF0LmlzQXR0cmlidXRlSWQoc3ViamVjdElkKSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoQXR0cmlidXRlQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IG5ldyBBdHRyaWJ1dGVDbGFzcyhcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5rZWRSZWNvcmRzLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlcnZlclNpZGVFdmVudHMsXG4gICAgICAgICAgICAgICAgICAgIHN1YmplY3RJZCxcbiAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgIHJlc3VsdFtuXS5wdXNoKGF0dHJpYnV0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuXG5jbGFzcyBGYWN0c1JlcG9zaXRvcnkge1xuICBsaW5rZWRSZWNvcmRzOiBMaW5rZWRSZWNvcmRzO1xuXG4gIGNvbnN0cnVjdG9yKGxpbmtlZFJlY29yZHM6IExpbmtlZFJlY29yZHMpIHtcbiAgICB0aGlzLmxpbmtlZFJlY29yZHMgPSBsaW5rZWRSZWNvcmRzO1xuICB9XG5cbiAgYXN5bmMgY3JlYXRlQWxsKGZhY3RzOiBbIHN0cmluZz8sIHN0cmluZz8sIHN0cmluZz8gXVtdKTpcbiAgUHJvbWlzZTxGYWN0W10+IHtcbiAgICBjb25zdCBjcmVhdGVkRmFjdHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIGZhY3RzLm1hcCgoYXR0cikgPT4gdGhpcy5jcmVhdGUoXG4gICAgICAgIGF0dHJbMF0sXG4gICAgICAgIGF0dHJbMV0sXG4gICAgICAgIGF0dHJbMl0sXG4gICAgICApKSxcbiAgICApO1xuXG4gICAgcmV0dXJuIGNyZWF0ZWRGYWN0cztcbiAgfVxuXG4gIGFzeW5jIGNyZWF0ZShzdWJqZWN0SWQ/OiBzdHJpbmcsIHByZWRpY2F0ZUlkPzogc3RyaW5nLCBvYmplY3RJZD86IHN0cmluZyk6IFByb21pc2U8RmFjdD4ge1xuICAgIGlmICghc3ViamVjdElkKSB7XG4gICAgICB0aHJvdyBFcnJvcignc3ViamVjdElkIGNhbiBub3QgYmUgbnVsbCcpO1xuICAgIH1cblxuICAgIGlmICghb2JqZWN0SWQpIHtcbiAgICAgIHRocm93IEVycm9yKCdvYmplY3RJZCBjYW4gbm90IGJlIG51bGwnKTtcbiAgICB9XG5cbiAgICBpZiAoIXByZWRpY2F0ZUlkKSB7XG4gICAgICB0aHJvdyBFcnJvcigncHJlZGljYXRlSWQgY2FuIG5vdCBiZSBudWxsJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZmFjdCA9IG5ldyBGYWN0KHRoaXMubGlua2VkUmVjb3Jkcywgc3ViamVjdElkLCBwcmVkaWNhdGVJZCwgb2JqZWN0SWQpO1xuICAgIGF3YWl0IGZhY3Quc2F2ZSgpO1xuICAgIHJldHVybiBmYWN0O1xuICB9XG5cbiAgYXN5bmMgZGVsZXRlQWxsKCkge1xuICAgIGF3YWl0IGZldGNoKGAke3RoaXMubGlua2VkUmVjb3Jkcy5zZXJ2ZXJVUkx9ZmFjdHNgLCB7XG4gICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBmaW5kQWxsKHsgc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QgfTpcbiAgeyBzdWJqZWN0PzogKHN0cmluZyB8IHN0cmluZ1tdKVtdLFxuICAgIHByZWRpY2F0ZT86IHN0cmluZ1tdLFxuICAgIG9iamVjdD86IChzdHJpbmcgfCBzdHJpbmdbXSlbXSB9KTogUHJvbWlzZTxGYWN0W10+IHtcbiAgICBjb25zdCBxdWVyeVVSTCA9IG5ldyBVUkwoYCR7dGhpcy5saW5rZWRSZWNvcmRzLnNlcnZlclVSTH1mYWN0c2ApO1xuXG4gICAgaWYgKHN1YmplY3QpIHtcbiAgICAgIHF1ZXJ5VVJMLnNlYXJjaFBhcmFtcy5hcHBlbmQoJ3N1YmplY3QnLCBKU09OLnN0cmluZ2lmeShzdWJqZWN0KSk7XG4gICAgfVxuXG4gICAgaWYgKHByZWRpY2F0ZSkge1xuICAgICAgcXVlcnlVUkwuc2VhcmNoUGFyYW1zLmFwcGVuZCgncHJlZGljYXRlJywgSlNPTi5zdHJpbmdpZnkocHJlZGljYXRlKSk7XG4gICAgfVxuXG4gICAgaWYgKG9iamVjdCkge1xuICAgICAgcXVlcnlVUkwuc2VhcmNoUGFyYW1zLmFwcGVuZCgnb2JqZWN0JywgSlNPTi5zdHJpbmdpZnkob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChxdWVyeVVSTCwge1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBjb25zdCByZXNwb25zZUpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICByZXR1cm4gcmVzcG9uc2VKc29uLm1hcCgocmVjb3JkKSA9PiBuZXcgRmFjdChcbiAgICAgIHRoaXMubGlua2VkUmVjb3JkcyxcbiAgICAgIHJlY29yZC5zdWJqZWN0LFxuICAgICAgcmVjb3JkLnByZWRpY2F0ZSxcbiAgICAgIHJlY29yZC5vYmplY3QsXG4gICAgKSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGlua2VkUmVjb3JkcyB7XG4gIHNlcnZlclNpZGVFdmVudHM6IElzU3Vic2NyaWJhYmxlO1xuXG4gIHNlcnZlclVSTDogVVJMO1xuXG4gIGNsaWVudElkOiBzdHJpbmc7XG5cbiAgYWN0b3JJZDogc3RyaW5nO1xuXG4gIEF0dHJpYnV0ZTogQXR0cmlidXRlc1JlcG9zaXRvcnk7XG5cbiAgRmFjdDogRmFjdHNSZXBvc2l0b3J5O1xuXG4gIGNvbnN0cnVjdG9yKHNlcnZlclVSTDogVVJMLCBzZXJ2ZXJTaWRlRXZlbnRzPzogSXNTdWJzY3JpYmFibGUpIHtcbiAgICB0aGlzLnNlcnZlclVSTCA9IHNlcnZlclVSTDtcbiAgICB0aGlzLmFjdG9ySWQgPSB1dWlkKCk7XG4gICAgdGhpcy5jbGllbnRJZCA9IHV1aWQoKTtcbiAgICB0aGlzLnNlcnZlclNpZGVFdmVudHMgPSBzZXJ2ZXJTaWRlRXZlbnRzIHx8IG5ldyBTZXJ2ZXJTaWRlRXZlbnRzKCk7XG4gICAgdGhpcy5BdHRyaWJ1dGUgPSBuZXcgQXR0cmlidXRlc1JlcG9zaXRvcnkodGhpcywgdGhpcy5zZXJ2ZXJTaWRlRXZlbnRzKTtcbiAgICB0aGlzLkZhY3QgPSBuZXcgRmFjdHNSZXBvc2l0b3J5KHRoaXMpO1xuICB9XG59XG4iLCIvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWN5Y2xlXG5pbXBvcnQgTGlua2VkUmVjb3JkcyBmcm9tICcuLi8uLi9icm93c2VyX3Nkayc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZhY3Qge1xuICBzZXJ2ZXJVUkw6IFVSTDtcblxuICBzdWJqZWN0OiBzdHJpbmc7XG5cbiAgcHJlZGljYXRlOiBzdHJpbmc7XG5cbiAgb2JqZWN0OiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IobGlua2VkUmVjb3JkczogTGlua2VkUmVjb3Jkcywgc3ViamVjdDogc3RyaW5nLCBwcmVkaWNhdGU6IHN0cmluZywgb2JqZWN0OiBzdHJpbmcpIHtcbiAgICB0aGlzLnNlcnZlclVSTCA9IGxpbmtlZFJlY29yZHMuc2VydmVyVVJMO1xuICAgIHRoaXMuc3ViamVjdCA9IHN1YmplY3Q7XG4gICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XG4gIH1cblxuICBhc3luYyBzYXZlKCkge1xuICAgIGF3YWl0IGZldGNoKGAke3RoaXMuc2VydmVyVVJMfWZhY3RzYCwge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgc3ViamVjdDogdGhpcy5zdWJqZWN0LFxuICAgICAgICBwcmVkaWNhdGU6IHRoaXMucHJlZGljYXRlLFxuICAgICAgICBvYmplY3Q6IHRoaXMub2JqZWN0LFxuICAgICAgfSksXG4gICAgfSk7XG4gIH1cbn1cbiIsImV4cG9ydCB7IGRlZmF1bHQgYXMgdjEgfSBmcm9tICcuL3YxLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdjMgfSBmcm9tICcuL3YzLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdjQgfSBmcm9tICcuL3Y0LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdjUgfSBmcm9tICcuL3Y1LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTklMIH0gZnJvbSAnLi9uaWwuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2ZXJzaW9uIH0gZnJvbSAnLi92ZXJzaW9uLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdmFsaWRhdGUgfSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgc3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwYXJzZSB9IGZyb20gJy4vcGFyc2UuanMnOyIsIi8qXG4gKiBCcm93c2VyLWNvbXBhdGlibGUgSmF2YVNjcmlwdCBNRDVcbiAqXG4gKiBNb2RpZmljYXRpb24gb2YgSmF2YVNjcmlwdCBNRDVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ibHVlaW1wL0phdmFTY3JpcHQtTUQ1XG4gKlxuICogQ29weXJpZ2h0IDIwMTEsIFNlYmFzdGlhbiBUc2NoYW5cbiAqIGh0dHBzOi8vYmx1ZWltcC5uZXRcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG4gKiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICpcbiAqIEJhc2VkIG9uXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFJTQSBEYXRhIFNlY3VyaXR5LCBJbmMuIE1ENSBNZXNzYWdlXG4gKiBEaWdlc3QgQWxnb3JpdGhtLCBhcyBkZWZpbmVkIGluIFJGQyAxMzIxLlxuICogVmVyc2lvbiAyLjIgQ29weXJpZ2h0IChDKSBQYXVsIEpvaG5zdG9uIDE5OTkgLSAyMDA5XG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2VcbiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBtb3JlIGluZm8uXG4gKi9cbmZ1bmN0aW9uIG1kNShieXRlcykge1xuICBpZiAodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykge1xuICAgIHZhciBtc2cgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoYnl0ZXMpKTsgLy8gVVRGOCBlc2NhcGVcblxuICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobXNnLmxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7ICsraSkge1xuICAgICAgYnl0ZXNbaV0gPSBtc2cuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWQ1VG9IZXhFbmNvZGVkQXJyYXkod29yZHNUb01kNShieXRlc1RvV29yZHMoYnl0ZXMpLCBieXRlcy5sZW5ndGggKiA4KSk7XG59XG4vKlxuICogQ29udmVydCBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzIHRvIGFuIGFycmF5IG9mIGJ5dGVzXG4gKi9cblxuXG5mdW5jdGlvbiBtZDVUb0hleEVuY29kZWRBcnJheShpbnB1dCkge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIHZhciBsZW5ndGgzMiA9IGlucHV0Lmxlbmd0aCAqIDMyO1xuICB2YXIgaGV4VGFiID0gJzAxMjM0NTY3ODlhYmNkZWYnO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoMzI7IGkgKz0gOCkge1xuICAgIHZhciB4ID0gaW5wdXRbaSA+PiA1XSA+Pj4gaSAlIDMyICYgMHhmZjtcbiAgICB2YXIgaGV4ID0gcGFyc2VJbnQoaGV4VGFiLmNoYXJBdCh4ID4+PiA0ICYgMHgwZikgKyBoZXhUYWIuY2hhckF0KHggJiAweDBmKSwgMTYpO1xuICAgIG91dHB1dC5wdXNoKGhleCk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuLyoqXG4gKiBDYWxjdWxhdGUgb3V0cHV0IGxlbmd0aCB3aXRoIHBhZGRpbmcgYW5kIGJpdCBsZW5ndGhcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldE91dHB1dExlbmd0aChpbnB1dExlbmd0aDgpIHtcbiAgcmV0dXJuIChpbnB1dExlbmd0aDggKyA2NCA+Pj4gOSA8PCA0KSArIDE0ICsgMTtcbn1cbi8qXG4gKiBDYWxjdWxhdGUgdGhlIE1ENSBvZiBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzLCBhbmQgYSBiaXQgbGVuZ3RoLlxuICovXG5cblxuZnVuY3Rpb24gd29yZHNUb01kNSh4LCBsZW4pIHtcbiAgLyogYXBwZW5kIHBhZGRpbmcgKi9cbiAgeFtsZW4gPj4gNV0gfD0gMHg4MCA8PCBsZW4gJSAzMjtcbiAgeFtnZXRPdXRwdXRMZW5ndGgobGVuKSAtIDFdID0gbGVuO1xuICB2YXIgYSA9IDE3MzI1ODQxOTM7XG4gIHZhciBiID0gLTI3MTczMzg3OTtcbiAgdmFyIGMgPSAtMTczMjU4NDE5NDtcbiAgdmFyIGQgPSAyNzE3MzM4Nzg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSArPSAxNikge1xuICAgIHZhciBvbGRhID0gYTtcbiAgICB2YXIgb2xkYiA9IGI7XG4gICAgdmFyIG9sZGMgPSBjO1xuICAgIHZhciBvbGRkID0gZDtcbiAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpXSwgNywgLTY4MDg3NjkzNik7XG4gICAgZCA9IG1kNWZmKGQsIGEsIGIsIGMsIHhbaSArIDFdLCAxMiwgLTM4OTU2NDU4Nik7XG4gICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDJdLCAxNywgNjA2MTA1ODE5KTtcbiAgICBiID0gbWQ1ZmYoYiwgYywgZCwgYSwgeFtpICsgM10sIDIyLCAtMTA0NDUyNTMzMCk7XG4gICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaSArIDRdLCA3LCAtMTc2NDE4ODk3KTtcbiAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgNV0sIDEyLCAxMjAwMDgwNDI2KTtcbiAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgNl0sIDE3LCAtMTQ3MzIzMTM0MSk7XG4gICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDddLCAyMiwgLTQ1NzA1OTgzKTtcbiAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpICsgOF0sIDcsIDE3NzAwMzU0MTYpO1xuICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyA5XSwgMTIsIC0xOTU4NDE0NDE3KTtcbiAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgMTBdLCAxNywgLTQyMDYzKTtcbiAgICBiID0gbWQ1ZmYoYiwgYywgZCwgYSwgeFtpICsgMTFdLCAyMiwgLTE5OTA0MDQxNjIpO1xuICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2kgKyAxMl0sIDcsIDE4MDQ2MDM2ODIpO1xuICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyAxM10sIDEyLCAtNDAzNDExMDEpO1xuICAgIGMgPSBtZDVmZihjLCBkLCBhLCBiLCB4W2kgKyAxNF0sIDE3LCAtMTUwMjAwMjI5MCk7XG4gICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDE1XSwgMjIsIDEyMzY1MzUzMjkpO1xuICAgIGEgPSBtZDVnZyhhLCBiLCBjLCBkLCB4W2kgKyAxXSwgNSwgLTE2NTc5NjUxMCk7XG4gICAgZCA9IG1kNWdnKGQsIGEsIGIsIGMsIHhbaSArIDZdLCA5LCAtMTA2OTUwMTYzMik7XG4gICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDExXSwgMTQsIDY0MzcxNzcxMyk7XG4gICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaV0sIDIwLCAtMzczODk3MzAyKTtcbiAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgNV0sIDUsIC03MDE1NTg2OTEpO1xuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyAxMF0sIDksIDM4MDE2MDgzKTtcbiAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgMTVdLCAxNCwgLTY2MDQ3ODMzNSk7XG4gICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaSArIDRdLCAyMCwgLTQwNTUzNzg0OCk7XG4gICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDldLCA1LCA1Njg0NDY0MzgpO1xuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyAxNF0sIDksIC0xMDE5ODAzNjkwKTtcbiAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgM10sIDE0LCAtMTg3MzYzOTYxKTtcbiAgICBiID0gbWQ1Z2coYiwgYywgZCwgYSwgeFtpICsgOF0sIDIwLCAxMTYzNTMxNTAxKTtcbiAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgMTNdLCA1LCAtMTQ0NDY4MTQ2Nyk7XG4gICAgZCA9IG1kNWdnKGQsIGEsIGIsIGMsIHhbaSArIDJdLCA5LCAtNTE0MDM3ODQpO1xuICAgIGMgPSBtZDVnZyhjLCBkLCBhLCBiLCB4W2kgKyA3XSwgMTQsIDE3MzUzMjg0NzMpO1xuICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2kgKyAxMl0sIDIwLCAtMTkyNjYwNzczNCk7XG4gICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDVdLCA0LCAtMzc4NTU4KTtcbiAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpICsgOF0sIDExLCAtMjAyMjU3NDQ2Myk7XG4gICAgYyA9IG1kNWhoKGMsIGQsIGEsIGIsIHhbaSArIDExXSwgMTYsIDE4MzkwMzA1NjIpO1xuICAgIGIgPSBtZDVoaChiLCBjLCBkLCBhLCB4W2kgKyAxNF0sIDIzLCAtMzUzMDk1NTYpO1xuICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyAxXSwgNCwgLTE1MzA5OTIwNjApO1xuICAgIGQgPSBtZDVoaChkLCBhLCBiLCBjLCB4W2kgKyA0XSwgMTEsIDEyNzI4OTMzNTMpO1xuICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyA3XSwgMTYsIC0xNTU0OTc2MzIpO1xuICAgIGIgPSBtZDVoaChiLCBjLCBkLCBhLCB4W2kgKyAxMF0sIDIzLCAtMTA5NDczMDY0MCk7XG4gICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDEzXSwgNCwgNjgxMjc5MTc0KTtcbiAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpXSwgMTEsIC0zNTg1MzcyMjIpO1xuICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyAzXSwgMTYsIC03MjI1MjE5NzkpO1xuICAgIGIgPSBtZDVoaChiLCBjLCBkLCBhLCB4W2kgKyA2XSwgMjMsIDc2MDI5MTg5KTtcbiAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgOV0sIDQsIC02NDAzNjQ0ODcpO1xuICAgIGQgPSBtZDVoaChkLCBhLCBiLCBjLCB4W2kgKyAxMl0sIDExLCAtNDIxODE1ODM1KTtcbiAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgMTVdLCAxNiwgNTMwNzQyNTIwKTtcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgMl0sIDIzLCAtOTk1MzM4NjUxKTtcbiAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpXSwgNiwgLTE5ODYzMDg0NCk7XG4gICAgZCA9IG1kNWlpKGQsIGEsIGIsIGMsIHhbaSArIDddLCAxMCwgMTEyNjg5MTQxNSk7XG4gICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDE0XSwgMTUsIC0xNDE2MzU0OTA1KTtcbiAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgNV0sIDIxLCAtNTc0MzQwNTUpO1xuICAgIGEgPSBtZDVpaShhLCBiLCBjLCBkLCB4W2kgKyAxMl0sIDYsIDE3MDA0ODU1NzEpO1xuICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyAzXSwgMTAsIC0xODk0OTg2NjA2KTtcbiAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgMTBdLCAxNSwgLTEwNTE1MjMpO1xuICAgIGIgPSBtZDVpaShiLCBjLCBkLCBhLCB4W2kgKyAxXSwgMjEsIC0yMDU0OTIyNzk5KTtcbiAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpICsgOF0sIDYsIDE4NzMzMTMzNTkpO1xuICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyAxNV0sIDEwLCAtMzA2MTE3NDQpO1xuICAgIGMgPSBtZDVpaShjLCBkLCBhLCBiLCB4W2kgKyA2XSwgMTUsIC0xNTYwMTk4MzgwKTtcbiAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgMTNdLCAyMSwgMTMwOTE1MTY0OSk7XG4gICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaSArIDRdLCA2LCAtMTQ1NTIzMDcwKTtcbiAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgMTFdLCAxMCwgLTExMjAyMTAzNzkpO1xuICAgIGMgPSBtZDVpaShjLCBkLCBhLCBiLCB4W2kgKyAyXSwgMTUsIDcxODc4NzI1OSk7XG4gICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDldLCAyMSwgLTM0MzQ4NTU1MSk7XG4gICAgYSA9IHNhZmVBZGQoYSwgb2xkYSk7XG4gICAgYiA9IHNhZmVBZGQoYiwgb2xkYik7XG4gICAgYyA9IHNhZmVBZGQoYywgb2xkYyk7XG4gICAgZCA9IHNhZmVBZGQoZCwgb2xkZCk7XG4gIH1cblxuICByZXR1cm4gW2EsIGIsIGMsIGRdO1xufVxuLypcbiAqIENvbnZlcnQgYW4gYXJyYXkgYnl0ZXMgdG8gYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3Jkc1xuICogQ2hhcmFjdGVycyA+MjU1IGhhdmUgdGhlaXIgaGlnaC1ieXRlIHNpbGVudGx5IGlnbm9yZWQuXG4gKi9cblxuXG5mdW5jdGlvbiBieXRlc1RvV29yZHMoaW5wdXQpIHtcbiAgaWYgKGlucHV0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBsZW5ndGg4ID0gaW5wdXQubGVuZ3RoICogODtcbiAgdmFyIG91dHB1dCA9IG5ldyBVaW50MzJBcnJheShnZXRPdXRwdXRMZW5ndGgobGVuZ3RoOCkpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoODsgaSArPSA4KSB7XG4gICAgb3V0cHV0W2kgPj4gNV0gfD0gKGlucHV0W2kgLyA4XSAmIDB4ZmYpIDw8IGkgJSAzMjtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG4vKlxuICogQWRkIGludGVnZXJzLCB3cmFwcGluZyBhdCAyXjMyLiBUaGlzIHVzZXMgMTYtYml0IG9wZXJhdGlvbnMgaW50ZXJuYWxseVxuICogdG8gd29yayBhcm91bmQgYnVncyBpbiBzb21lIEpTIGludGVycHJldGVycy5cbiAqL1xuXG5cbmZ1bmN0aW9uIHNhZmVBZGQoeCwgeSkge1xuICB2YXIgbHN3ID0gKHggJiAweGZmZmYpICsgKHkgJiAweGZmZmYpO1xuICB2YXIgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XG4gIHJldHVybiBtc3cgPDwgMTYgfCBsc3cgJiAweGZmZmY7XG59XG4vKlxuICogQml0d2lzZSByb3RhdGUgYSAzMi1iaXQgbnVtYmVyIHRvIHRoZSBsZWZ0LlxuICovXG5cblxuZnVuY3Rpb24gYml0Um90YXRlTGVmdChudW0sIGNudCkge1xuICByZXR1cm4gbnVtIDw8IGNudCB8IG51bSA+Pj4gMzIgLSBjbnQ7XG59XG4vKlxuICogVGhlc2UgZnVuY3Rpb25zIGltcGxlbWVudCB0aGUgZm91ciBiYXNpYyBvcGVyYXRpb25zIHRoZSBhbGdvcml0aG0gdXNlcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIG1kNWNtbihxLCBhLCBiLCB4LCBzLCB0KSB7XG4gIHJldHVybiBzYWZlQWRkKGJpdFJvdGF0ZUxlZnQoc2FmZUFkZChzYWZlQWRkKGEsIHEpLCBzYWZlQWRkKHgsIHQpKSwgcyksIGIpO1xufVxuXG5mdW5jdGlvbiBtZDVmZihhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVjbW4oYiAmIGMgfCB+YiAmIGQsIGEsIGIsIHgsIHMsIHQpO1xufVxuXG5mdW5jdGlvbiBtZDVnZyhhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVjbW4oYiAmIGQgfCBjICYgfmQsIGEsIGIsIHgsIHMsIHQpO1xufVxuXG5mdW5jdGlvbiBtZDVoaChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVjbW4oYiBeIGMgXiBkLCBhLCBiLCB4LCBzLCB0KTtcbn1cblxuZnVuY3Rpb24gbWQ1aWkoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICByZXR1cm4gbWQ1Y21uKGMgXiAoYiB8IH5kKSwgYSwgYiwgeCwgcywgdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1kNTsiLCJleHBvcnQgZGVmYXVsdCAnMDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwJzsiLCJpbXBvcnQgdmFsaWRhdGUgZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG5cbmZ1bmN0aW9uIHBhcnNlKHV1aWQpIHtcbiAgaWYgKCF2YWxpZGF0ZSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignSW52YWxpZCBVVUlEJyk7XG4gIH1cblxuICB2YXIgdjtcbiAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDE2KTsgLy8gUGFyc2UgIyMjIyMjIyMtLi4uLi0uLi4uLS4uLi4tLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzBdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDAsIDgpLCAxNikpID4+PiAyNDtcbiAgYXJyWzFdID0gdiA+Pj4gMTYgJiAweGZmO1xuICBhcnJbMl0gPSB2ID4+PiA4ICYgMHhmZjtcbiAgYXJyWzNdID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLSMjIyMtLi4uLi0uLi4uLS4uLi4uLi4uLi4uLlxuXG4gIGFycls0XSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSg5LCAxMyksIDE2KSkgPj4+IDg7XG4gIGFycls1XSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0uLi4uLSMjIyMtLi4uLi0uLi4uLi4uLi4uLi5cblxuICBhcnJbNl0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMTQsIDE4KSwgMTYpKSA+Pj4gODtcbiAgYXJyWzddID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tLi4uLi0jIyMjLS4uLi4uLi4uLi4uLlxuXG4gIGFycls4XSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgxOSwgMjMpLCAxNikpID4+PiA4O1xuICBhcnJbOV0gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tLi4uLi0uLi4uLS4uLi4tIyMjIyMjIyMjIyMjXG4gIC8vIChVc2UgXCIvXCIgdG8gYXZvaWQgMzItYml0IHRydW5jYXRpb24gd2hlbiBiaXQtc2hpZnRpbmcgaGlnaC1vcmRlciBieXRlcylcblxuICBhcnJbMTBdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDI0LCAzNiksIDE2KSkgLyAweDEwMDAwMDAwMDAwICYgMHhmZjtcbiAgYXJyWzExXSA9IHYgLyAweDEwMDAwMDAwMCAmIDB4ZmY7XG4gIGFyclsxMl0gPSB2ID4+PiAyNCAmIDB4ZmY7XG4gIGFyclsxM10gPSB2ID4+PiAxNiAmIDB4ZmY7XG4gIGFyclsxNF0gPSB2ID4+PiA4ICYgMHhmZjtcbiAgYXJyWzE1XSA9IHYgJiAweGZmO1xuICByZXR1cm4gYXJyO1xufVxuXG5leHBvcnQgZGVmYXVsdCBwYXJzZTsiLCJleHBvcnQgZGVmYXVsdCAvXig/OlswLTlhLWZdezh9LVswLTlhLWZdezR9LVsxLTVdWzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCkkL2k7IiwiLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gSW4gdGhlIGJyb3dzZXIgd2UgdGhlcmVmb3JlXG4vLyByZXF1aXJlIHRoZSBjcnlwdG8gQVBJIGFuZCBkbyBub3Qgc3VwcG9ydCBidWlsdC1pbiBmYWxsYmFjayB0byBsb3dlciBxdWFsaXR5IHJhbmRvbSBudW1iZXJcbi8vIGdlbmVyYXRvcnMgKGxpa2UgTWF0aC5yYW5kb20oKSkuXG52YXIgZ2V0UmFuZG9tVmFsdWVzO1xudmFyIHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcm5nKCkge1xuICAvLyBsYXp5IGxvYWQgc28gdGhhdCBlbnZpcm9ubWVudHMgdGhhdCBuZWVkIHRvIHBvbHlmaWxsIGhhdmUgYSBjaGFuY2UgdG8gZG8gc29cbiAgaWYgKCFnZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAvLyBnZXRSYW5kb21WYWx1ZXMgbmVlZHMgdG8gYmUgaW52b2tlZCBpbiBhIGNvbnRleHQgd2hlcmUgXCJ0aGlzXCIgaXMgYSBDcnlwdG8gaW1wbGVtZW50YXRpb24uIEFsc28sXG4gICAgLy8gZmluZCB0aGUgY29tcGxldGUgaW1wbGVtZW50YXRpb24gb2YgY3J5cHRvIChtc0NyeXB0bykgb24gSUUxMS5cbiAgICBnZXRSYW5kb21WYWx1ZXMgPSB0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChjcnlwdG8pIHx8IHR5cGVvZiBtc0NyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJyAmJiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChtc0NyeXB0byk7XG5cbiAgICBpZiAoIWdldFJhbmRvbVZhbHVlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKCkgbm90IHN1cHBvcnRlZC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZCNnZXRyYW5kb212YWx1ZXMtbm90LXN1cHBvcnRlZCcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBnZXRSYW5kb21WYWx1ZXMocm5kczgpO1xufSIsIi8vIEFkYXB0ZWQgZnJvbSBDaHJpcyBWZW5lc3MnIFNIQTEgY29kZSBhdFxuLy8gaHR0cDovL3d3dy5tb3ZhYmxlLXR5cGUuY28udWsvc2NyaXB0cy9zaGExLmh0bWxcbmZ1bmN0aW9uIGYocywgeCwgeSwgeikge1xuICBzd2l0Y2ggKHMpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4geCAmIHkgXiB+eCAmIHo7XG5cbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4geCBeIHkgXiB6O1xuXG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIHggJiB5IF4geCAmIHogXiB5ICYgejtcblxuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiB4IF4geSBeIHo7XG4gIH1cbn1cblxuZnVuY3Rpb24gUk9UTCh4LCBuKSB7XG4gIHJldHVybiB4IDw8IG4gfCB4ID4+PiAzMiAtIG47XG59XG5cbmZ1bmN0aW9uIHNoYTEoYnl0ZXMpIHtcbiAgdmFyIEsgPSBbMHg1YTgyNzk5OSwgMHg2ZWQ5ZWJhMSwgMHg4ZjFiYmNkYywgMHhjYTYyYzFkNl07XG4gIHZhciBIID0gWzB4Njc0NTIzMDEsIDB4ZWZjZGFiODksIDB4OThiYWRjZmUsIDB4MTAzMjU0NzYsIDB4YzNkMmUxZjBdO1xuXG4gIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIG1zZyA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChieXRlcykpOyAvLyBVVEY4IGVzY2FwZVxuXG4gICAgYnl0ZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgKytpKSB7XG4gICAgICBieXRlcy5wdXNoKG1zZy5jaGFyQ29kZUF0KGkpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoYnl0ZXMpKSB7XG4gICAgLy8gQ29udmVydCBBcnJheS1saWtlIHRvIEFycmF5XG4gICAgYnl0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChieXRlcyk7XG4gIH1cblxuICBieXRlcy5wdXNoKDB4ODApO1xuICB2YXIgbCA9IGJ5dGVzLmxlbmd0aCAvIDQgKyAyO1xuICB2YXIgTiA9IE1hdGguY2VpbChsIC8gMTYpO1xuICB2YXIgTSA9IG5ldyBBcnJheShOKTtcblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgTjsgKytfaSkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDMyQXJyYXkoMTYpO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCAxNjsgKytqKSB7XG4gICAgICBhcnJbal0gPSBieXRlc1tfaSAqIDY0ICsgaiAqIDRdIDw8IDI0IHwgYnl0ZXNbX2kgKiA2NCArIGogKiA0ICsgMV0gPDwgMTYgfCBieXRlc1tfaSAqIDY0ICsgaiAqIDQgKyAyXSA8PCA4IHwgYnl0ZXNbX2kgKiA2NCArIGogKiA0ICsgM107XG4gICAgfVxuXG4gICAgTVtfaV0gPSBhcnI7XG4gIH1cblxuICBNW04gLSAxXVsxNF0gPSAoYnl0ZXMubGVuZ3RoIC0gMSkgKiA4IC8gTWF0aC5wb3coMiwgMzIpO1xuICBNW04gLSAxXVsxNF0gPSBNYXRoLmZsb29yKE1bTiAtIDFdWzE0XSk7XG4gIE1bTiAtIDFdWzE1XSA9IChieXRlcy5sZW5ndGggLSAxKSAqIDggJiAweGZmZmZmZmZmO1xuXG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IE47ICsrX2kyKSB7XG4gICAgdmFyIFcgPSBuZXcgVWludDMyQXJyYXkoODApO1xuXG4gICAgZm9yICh2YXIgdCA9IDA7IHQgPCAxNjsgKyt0KSB7XG4gICAgICBXW3RdID0gTVtfaTJdW3RdO1xuICAgIH1cblxuICAgIGZvciAodmFyIF90ID0gMTY7IF90IDwgODA7ICsrX3QpIHtcbiAgICAgIFdbX3RdID0gUk9UTChXW190IC0gM10gXiBXW190IC0gOF0gXiBXW190IC0gMTRdIF4gV1tfdCAtIDE2XSwgMSk7XG4gICAgfVxuXG4gICAgdmFyIGEgPSBIWzBdO1xuICAgIHZhciBiID0gSFsxXTtcbiAgICB2YXIgYyA9IEhbMl07XG4gICAgdmFyIGQgPSBIWzNdO1xuICAgIHZhciBlID0gSFs0XTtcblxuICAgIGZvciAodmFyIF90MiA9IDA7IF90MiA8IDgwOyArK190Mikge1xuICAgICAgdmFyIHMgPSBNYXRoLmZsb29yKF90MiAvIDIwKTtcbiAgICAgIHZhciBUID0gUk9UTChhLCA1KSArIGYocywgYiwgYywgZCkgKyBlICsgS1tzXSArIFdbX3QyXSA+Pj4gMDtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICBjID0gUk9UTChiLCAzMCkgPj4+IDA7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSBUO1xuICAgIH1cblxuICAgIEhbMF0gPSBIWzBdICsgYSA+Pj4gMDtcbiAgICBIWzFdID0gSFsxXSArIGIgPj4+IDA7XG4gICAgSFsyXSA9IEhbMl0gKyBjID4+PiAwO1xuICAgIEhbM10gPSBIWzNdICsgZCA+Pj4gMDtcbiAgICBIWzRdID0gSFs0XSArIGUgPj4+IDA7XG4gIH1cblxuICByZXR1cm4gW0hbMF0gPj4gMjQgJiAweGZmLCBIWzBdID4+IDE2ICYgMHhmZiwgSFswXSA+PiA4ICYgMHhmZiwgSFswXSAmIDB4ZmYsIEhbMV0gPj4gMjQgJiAweGZmLCBIWzFdID4+IDE2ICYgMHhmZiwgSFsxXSA+PiA4ICYgMHhmZiwgSFsxXSAmIDB4ZmYsIEhbMl0gPj4gMjQgJiAweGZmLCBIWzJdID4+IDE2ICYgMHhmZiwgSFsyXSA+PiA4ICYgMHhmZiwgSFsyXSAmIDB4ZmYsIEhbM10gPj4gMjQgJiAweGZmLCBIWzNdID4+IDE2ICYgMHhmZiwgSFszXSA+PiA4ICYgMHhmZiwgSFszXSAmIDB4ZmYsIEhbNF0gPj4gMjQgJiAweGZmLCBIWzRdID4+IDE2ICYgMHhmZiwgSFs0XSA+PiA4ICYgMHhmZiwgSFs0XSAmIDB4ZmZdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzaGExOyIsImltcG9ydCB2YWxpZGF0ZSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcbi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xuXG52YXIgYnl0ZVRvSGV4ID0gW107XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgYnl0ZVRvSGV4LnB1c2goKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKSk7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeShhcnIpIHtcbiAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgLy8gTm90ZTogQmUgY2FyZWZ1bCBlZGl0aW5nIHRoaXMgY29kZSEgIEl0J3MgYmVlbiB0dW5lZCBmb3IgcGVyZm9ybWFuY2VcbiAgLy8gYW5kIHdvcmtzIGluIHdheXMgeW91IG1heSBub3QgZXhwZWN0LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkL3B1bGwvNDM0XG4gIHZhciB1dWlkID0gKGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgM11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDVdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA3XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDhdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxM11dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNV1dKS50b0xvd2VyQ2FzZSgpOyAvLyBDb25zaXN0ZW5jeSBjaGVjayBmb3IgdmFsaWQgVVVJRC4gIElmIHRoaXMgdGhyb3dzLCBpdCdzIGxpa2VseSBkdWUgdG8gb25lXG4gIC8vIG9mIHRoZSBmb2xsb3dpbmc6XG4gIC8vIC0gT25lIG9yIG1vcmUgaW5wdXQgYXJyYXkgdmFsdWVzIGRvbid0IG1hcCB0byBhIGhleCBvY3RldCAobGVhZGluZyB0b1xuICAvLyBcInVuZGVmaW5lZFwiIGluIHRoZSB1dWlkKVxuICAvLyAtIEludmFsaWQgaW5wdXQgdmFsdWVzIGZvciB0aGUgUkZDIGB2ZXJzaW9uYCBvciBgdmFyaWFudGAgZmllbGRzXG5cbiAgaWYgKCF2YWxpZGF0ZSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignU3RyaW5naWZpZWQgVVVJRCBpcyBpbnZhbGlkJyk7XG4gIH1cblxuICByZXR1cm4gdXVpZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RyaW5naWZ5OyIsImltcG9ydCBybmcgZnJvbSAnLi9ybmcuanMnO1xuaW1wb3J0IHN0cmluZ2lmeSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7IC8vICoqYHYxKClgIC0gR2VuZXJhdGUgdGltZS1iYXNlZCBVVUlEKipcbi8vXG4vLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vTGlvc0svVVVJRC5qc1xuLy8gYW5kIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS91dWlkLmh0bWxcblxudmFyIF9ub2RlSWQ7XG5cbnZhciBfY2xvY2tzZXE7IC8vIFByZXZpb3VzIHV1aWQgY3JlYXRpb24gdGltZVxuXG5cbnZhciBfbGFzdE1TZWNzID0gMDtcbnZhciBfbGFzdE5TZWNzID0gMDsgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZCBmb3IgQVBJIGRldGFpbHNcblxuZnVuY3Rpb24gdjEob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG4gIHZhciBiID0gYnVmIHx8IG5ldyBBcnJheSgxNik7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgbm9kZSA9IG9wdGlvbnMubm9kZSB8fCBfbm9kZUlkO1xuICB2YXIgY2xvY2tzZXEgPSBvcHRpb25zLmNsb2Nrc2VxICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsb2Nrc2VxIDogX2Nsb2Nrc2VxOyAvLyBub2RlIGFuZCBjbG9ja3NlcSBuZWVkIHRvIGJlIGluaXRpYWxpemVkIHRvIHJhbmRvbSB2YWx1ZXMgaWYgdGhleSdyZSBub3RcbiAgLy8gc3BlY2lmaWVkLiAgV2UgZG8gdGhpcyBsYXppbHkgdG8gbWluaW1pemUgaXNzdWVzIHJlbGF0ZWQgdG8gaW5zdWZmaWNpZW50XG4gIC8vIHN5c3RlbSBlbnRyb3B5LiAgU2VlICMxODlcblxuICBpZiAobm9kZSA9PSBudWxsIHx8IGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICB2YXIgc2VlZEJ5dGVzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTtcblxuICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjUsIGNyZWF0ZSBhbmQgNDgtYml0IG5vZGUgaWQsICg0NyByYW5kb20gYml0cyArIG11bHRpY2FzdCBiaXQgPSAxKVxuICAgICAgbm9kZSA9IF9ub2RlSWQgPSBbc2VlZEJ5dGVzWzBdIHwgMHgwMSwgc2VlZEJ5dGVzWzFdLCBzZWVkQnl0ZXNbMl0sIHNlZWRCeXRlc1szXSwgc2VlZEJ5dGVzWzRdLCBzZWVkQnl0ZXNbNV1dO1xuICAgIH1cblxuICAgIGlmIChjbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgICAvLyBQZXIgNC4yLjIsIHJhbmRvbWl6ZSAoMTQgYml0KSBjbG9ja3NlcVxuICAgICAgY2xvY2tzZXEgPSBfY2xvY2tzZXEgPSAoc2VlZEJ5dGVzWzZdIDw8IDggfCBzZWVkQnl0ZXNbN10pICYgMHgzZmZmO1xuICAgIH1cbiAgfSAvLyBVVUlEIHRpbWVzdGFtcHMgYXJlIDEwMCBuYW5vLXNlY29uZCB1bml0cyBzaW5jZSB0aGUgR3JlZ29yaWFuIGVwb2NoLFxuICAvLyAoMTU4Mi0xMC0xNSAwMDowMCkuICBKU051bWJlcnMgYXJlbid0IHByZWNpc2UgZW5vdWdoIGZvciB0aGlzLCBzb1xuICAvLyB0aW1lIGlzIGhhbmRsZWQgaW50ZXJuYWxseSBhcyAnbXNlY3MnIChpbnRlZ2VyIG1pbGxpc2Vjb25kcykgYW5kICduc2VjcydcbiAgLy8gKDEwMC1uYW5vc2Vjb25kcyBvZmZzZXQgZnJvbSBtc2Vjcykgc2luY2UgdW5peCBlcG9jaCwgMTk3MC0wMS0wMSAwMDowMC5cblxuXG4gIHZhciBtc2VjcyA9IG9wdGlvbnMubXNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubXNlY3MgOiBEYXRlLm5vdygpOyAvLyBQZXIgNC4yLjEuMiwgdXNlIGNvdW50IG9mIHV1aWQncyBnZW5lcmF0ZWQgZHVyaW5nIHRoZSBjdXJyZW50IGNsb2NrXG4gIC8vIGN5Y2xlIHRvIHNpbXVsYXRlIGhpZ2hlciByZXNvbHV0aW9uIGNsb2NrXG5cbiAgdmFyIG5zZWNzID0gb3B0aW9ucy5uc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uc2VjcyA6IF9sYXN0TlNlY3MgKyAxOyAvLyBUaW1lIHNpbmNlIGxhc3QgdXVpZCBjcmVhdGlvbiAoaW4gbXNlY3MpXG5cbiAgdmFyIGR0ID0gbXNlY3MgLSBfbGFzdE1TZWNzICsgKG5zZWNzIC0gX2xhc3ROU2VjcykgLyAxMDAwMDsgLy8gUGVyIDQuMi4xLjIsIEJ1bXAgY2xvY2tzZXEgb24gY2xvY2sgcmVncmVzc2lvblxuXG4gIGlmIChkdCA8IDAgJiYgb3B0aW9ucy5jbG9ja3NlcSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2xvY2tzZXEgPSBjbG9ja3NlcSArIDEgJiAweDNmZmY7XG4gIH0gLy8gUmVzZXQgbnNlY3MgaWYgY2xvY2sgcmVncmVzc2VzIChuZXcgY2xvY2tzZXEpIG9yIHdlJ3ZlIG1vdmVkIG9udG8gYSBuZXdcbiAgLy8gdGltZSBpbnRlcnZhbFxuXG5cbiAgaWYgKChkdCA8IDAgfHwgbXNlY3MgPiBfbGFzdE1TZWNzKSAmJiBvcHRpb25zLm5zZWNzID09PSB1bmRlZmluZWQpIHtcbiAgICBuc2VjcyA9IDA7XG4gIH0gLy8gUGVyIDQuMi4xLjIgVGhyb3cgZXJyb3IgaWYgdG9vIG1hbnkgdXVpZHMgYXJlIHJlcXVlc3RlZFxuXG5cbiAgaWYgKG5zZWNzID49IDEwMDAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidXVpZC52MSgpOiBDYW4ndCBjcmVhdGUgbW9yZSB0aGFuIDEwTSB1dWlkcy9zZWNcIik7XG4gIH1cblxuICBfbGFzdE1TZWNzID0gbXNlY3M7XG4gIF9sYXN0TlNlY3MgPSBuc2VjcztcbiAgX2Nsb2Nrc2VxID0gY2xvY2tzZXE7IC8vIFBlciA0LjEuNCAtIENvbnZlcnQgZnJvbSB1bml4IGVwb2NoIHRvIEdyZWdvcmlhbiBlcG9jaFxuXG4gIG1zZWNzICs9IDEyMjE5MjkyODAwMDAwOyAvLyBgdGltZV9sb3dgXG5cbiAgdmFyIHRsID0gKChtc2VjcyAmIDB4ZmZmZmZmZikgKiAxMDAwMCArIG5zZWNzKSAlIDB4MTAwMDAwMDAwO1xuICBiW2krK10gPSB0bCA+Pj4gMjQgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gMTYgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsICYgMHhmZjsgLy8gYHRpbWVfbWlkYFxuXG4gIHZhciB0bWggPSBtc2VjcyAvIDB4MTAwMDAwMDAwICogMTAwMDAgJiAweGZmZmZmZmY7XG4gIGJbaSsrXSA9IHRtaCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRtaCAmIDB4ZmY7IC8vIGB0aW1lX2hpZ2hfYW5kX3ZlcnNpb25gXG5cbiAgYltpKytdID0gdG1oID4+PiAyNCAmIDB4ZiB8IDB4MTA7IC8vIGluY2x1ZGUgdmVyc2lvblxuXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMTYgJiAweGZmOyAvLyBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGAgKFBlciA0LjIuMiAtIGluY2x1ZGUgdmFyaWFudClcblxuICBiW2krK10gPSBjbG9ja3NlcSA+Pj4gOCB8IDB4ODA7IC8vIGBjbG9ja19zZXFfbG93YFxuXG4gIGJbaSsrXSA9IGNsb2Nrc2VxICYgMHhmZjsgLy8gYG5vZGVgXG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCA2OyArK24pIHtcbiAgICBiW2kgKyBuXSA9IG5vZGVbbl07XG4gIH1cblxuICByZXR1cm4gYnVmIHx8IHN0cmluZ2lmeShiKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdjE7IiwiaW1wb3J0IHYzNSBmcm9tICcuL3YzNS5qcyc7XG5pbXBvcnQgbWQ1IGZyb20gJy4vbWQ1LmpzJztcbnZhciB2MyA9IHYzNSgndjMnLCAweDMwLCBtZDUpO1xuZXhwb3J0IGRlZmF1bHQgdjM7IiwiaW1wb3J0IHN0cmluZ2lmeSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5pbXBvcnQgcGFyc2UgZnJvbSAnLi9wYXJzZS5qcyc7XG5cbmZ1bmN0aW9uIHN0cmluZ1RvQnl0ZXMoc3RyKSB7XG4gIHN0ciA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKTsgLy8gVVRGOCBlc2NhcGVcblxuICB2YXIgYnl0ZXMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGJ5dGVzLnB1c2goc3RyLmNoYXJDb2RlQXQoaSkpO1xuICB9XG5cbiAgcmV0dXJuIGJ5dGVzO1xufVxuXG5leHBvcnQgdmFyIEROUyA9ICc2YmE3YjgxMC05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzgnO1xuZXhwb3J0IHZhciBVUkwgPSAnNmJhN2I4MTEtOWRhZC0xMWQxLTgwYjQtMDBjMDRmZDQzMGM4JztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChuYW1lLCB2ZXJzaW9uLCBoYXNoZnVuYykge1xuICBmdW5jdGlvbiBnZW5lcmF0ZVVVSUQodmFsdWUsIG5hbWVzcGFjZSwgYnVmLCBvZmZzZXQpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSBzdHJpbmdUb0J5dGVzKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5hbWVzcGFjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWVzcGFjZSA9IHBhcnNlKG5hbWVzcGFjZSk7XG4gICAgfVxuXG4gICAgaWYgKG5hbWVzcGFjZS5sZW5ndGggIT09IDE2KSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ05hbWVzcGFjZSBtdXN0IGJlIGFycmF5LWxpa2UgKDE2IGl0ZXJhYmxlIGludGVnZXIgdmFsdWVzLCAwLTI1NSknKTtcbiAgICB9IC8vIENvbXB1dGUgaGFzaCBvZiBuYW1lc3BhY2UgYW5kIHZhbHVlLCBQZXIgNC4zXG4gICAgLy8gRnV0dXJlOiBVc2Ugc3ByZWFkIHN5bnRheCB3aGVuIHN1cHBvcnRlZCBvbiBhbGwgcGxhdGZvcm1zLCBlLmcuIGBieXRlcyA9XG4gICAgLy8gaGFzaGZ1bmMoWy4uLm5hbWVzcGFjZSwgLi4uIHZhbHVlXSlgXG5cblxuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KDE2ICsgdmFsdWUubGVuZ3RoKTtcbiAgICBieXRlcy5zZXQobmFtZXNwYWNlKTtcbiAgICBieXRlcy5zZXQodmFsdWUsIG5hbWVzcGFjZS5sZW5ndGgpO1xuICAgIGJ5dGVzID0gaGFzaGZ1bmMoYnl0ZXMpO1xuICAgIGJ5dGVzWzZdID0gYnl0ZXNbNl0gJiAweDBmIHwgdmVyc2lvbjtcbiAgICBieXRlc1s4XSA9IGJ5dGVzWzhdICYgMHgzZiB8IDB4ODA7XG5cbiAgICBpZiAoYnVmKSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IGJ5dGVzW2ldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnVmO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmdpZnkoYnl0ZXMpO1xuICB9IC8vIEZ1bmN0aW9uI25hbWUgaXMgbm90IHNldHRhYmxlIG9uIHNvbWUgcGxhdGZvcm1zICgjMjcwKVxuXG5cbiAgdHJ5IHtcbiAgICBnZW5lcmF0ZVVVSUQubmFtZSA9IG5hbWU7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICB9IGNhdGNoIChlcnIpIHt9IC8vIEZvciBDb21tb25KUyBkZWZhdWx0IGV4cG9ydCBzdXBwb3J0XG5cblxuICBnZW5lcmF0ZVVVSUQuRE5TID0gRE5TO1xuICBnZW5lcmF0ZVVVSUQuVVJMID0gVVJMO1xuICByZXR1cm4gZ2VuZXJhdGVVVUlEO1xufSIsImltcG9ydCBybmcgZnJvbSAnLi9ybmcuanMnO1xuaW1wb3J0IHN0cmluZ2lmeSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5cbmZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7IC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcblxuICBybmRzWzZdID0gcm5kc1s2XSAmIDB4MGYgfCAweDQwO1xuICBybmRzWzhdID0gcm5kc1s4XSAmIDB4M2YgfCAweDgwOyAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcblxuICBpZiAoYnVmKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHJuZHNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuXG4gIHJldHVybiBzdHJpbmdpZnkocm5kcyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHY0OyIsImltcG9ydCB2MzUgZnJvbSAnLi92MzUuanMnO1xuaW1wb3J0IHNoYTEgZnJvbSAnLi9zaGExLmpzJztcbnZhciB2NSA9IHYzNSgndjUnLCAweDUwLCBzaGExKTtcbmV4cG9ydCBkZWZhdWx0IHY1OyIsImltcG9ydCBSRUdFWCBmcm9tICcuL3JlZ2V4LmpzJztcblxuZnVuY3Rpb24gdmFsaWRhdGUodXVpZCkge1xuICByZXR1cm4gdHlwZW9mIHV1aWQgPT09ICdzdHJpbmcnICYmIFJFR0VYLnRlc3QodXVpZCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZhbGlkYXRlOyIsImltcG9ydCB2YWxpZGF0ZSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcblxuZnVuY3Rpb24gdmVyc2lvbih1dWlkKSB7XG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0ludmFsaWQgVVVJRCcpO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlSW50KHV1aWQuc3Vic3RyKDE0LCAxKSwgMTYpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2ZXJzaW9uOyIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCIiLCIvLyBzdGFydHVwXG4vLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8vIFRoaXMgZW50cnkgbW9kdWxlIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgbW9kdWxlcyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG52YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL2V4YW1wbGUvY2xpZW50L2luZGV4LnRzXCIpO1xuIiwiIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9