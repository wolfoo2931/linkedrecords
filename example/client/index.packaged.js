/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../structured-text-editor/assets/latex_cheatsheet.js":
/*!************************************************************!*\
  !*** ../structured-text-editor/assets/latex_cheatsheet.js ***!
  \************************************************************/
/***/ ((module) => {

module.exports = `
<div class="latex-eq-tooltip">
Some Examples what you can insert here. You can scroll the list to see more.
<table>
<tr>
<td>
  <div class="markup">e=mc^2</div>
</td>
<td>
  <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>=</mo><mi>m</mi><msup><mi>c</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">e=mc^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.864108em; vertical-align: 0em;"></span><span class="mord mathdefault">m</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.864108em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>
</td>
</tr>
<tr>
<td>
  <div class="markup">y = \\frac{2x^2}{8x}</div>
</td>
<td>
  <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mfrac><mrow><mn>2</mn><msup><mi>x</mi><mn>2</mn></msup></mrow><mrow><mn>8</mn><mi>x</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">y = \\frac{2x^2}{8x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 2.17711em; vertical-align: -0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.49111em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">8</span><span class="mord mathdefault">x</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">2</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.686em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>
</td>
</tr>
<tr>
<td>
  <div class="markup">\\int^{a+1}_{a-1}</div>
</td>
<td>
  <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∫</mo><mrow><mi>a</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>a</mi><mo>+</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding="application/x-tex">\\int^{a+1}_{a-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 2.53429em; vertical-align: -0.970281em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right: 0.44445em; position: relative; top: -0.001125em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.56401em;"><span class="" style="top: -1.78805em; margin-left: -0.44445em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span class="" style="top: -3.8129em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.970281em;"><span class=""></span></span></span></span></span></span></span></span></span></span>
</td>
</tr>
<tr>
<td>
  <div class="markup">\\sum_{i=1}^n a_i</div>
</td>
<td>
  <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\\sum_{i=1}^n a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 2.92907em; vertical-align: -1.27767em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.6514em;"><span class="" style="top: -1.87233em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span class="" style="top: -3.05001em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span><span class="" style="top: -4.30001em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.27767em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>
</td>
</tr>
<tr>
<td>
  <div class="markup">\\big[x\\big]</div>
</td>
<td>
  <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="false">[</mo><mi>x</mi><mo fence="false">]</mo></mrow><annotation encoding="application/x-tex">\\big[x\\big]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.20001em; vertical-align: -0.35001em;"></span><span class="mord"><span class="delimsizing size1">[</span></span><span class="mord mathdefault">x</span><span class="mord"><span class="delimsizing size1">]</span></span></span></span></span></span>
</td>
</tr>
<tr>
<td>
  <div class="markup">\\Big[x\\Big]</div>
</td>
<td>
  <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="false">[</mo><mi>x</mi><mo fence="false">]</mo></mrow><annotation encoding="application/x-tex">\\Big[x\\Big]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.80002em; vertical-align: -0.65002em;"></span><span class="mord"><span class="delimsizing size2">[</span></span><span class="mord mathdefault">x</span><span class="mord"><span class="delimsizing size2">]</span></span></span></span></span></span>
</td>
</tr>
<tr>
<td>
  <div class="markup">\\lim_{h\\to0} \\frac{1}{n}</div>
</td>
<td>
  <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munder><mo><mi>lim</mi><mo>⁡</mo></mo><mrow><mi>h</mi><mo>→</mo><mn>0</mn></mrow></munder><mfrac><mn>1</mn><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">\\lim_{h\\to0} \\frac{1}{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 2.07355em; vertical-align: -0.752108em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.69444em;"><span class="" style="top: -2.34789em; margin-left: 0em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mrel mtight">→</span><span class="mord mtight">0</span></span></span></span><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class=""><span class="mop">lim</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.752108em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.32144em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.686em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>
</td>
</tr>
<tr>
<td>
  <div class="markup">\\sqrt{9} = \\sqrt[2]{9} </div>
</td>
<td>
  <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mn>9</mn></msqrt><mo>=</mo><mroot><mn>9</mn><mn>2</mn></mroot></mrow><annotation encoding="application/x-tex">\\sqrt{9} = \\sqrt[2]{9} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.04em; vertical-align: -0.083905em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.956095em;"><span class="svg-align" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord" style="padding-left: 0.833em;"><span class="mord">9</span></span></span><span class="" style="top: -2.91609em;"><span class="pstrut" style="height: 3em;"></span><span class="hide-tail" style="min-width: 0.853em; height: 1.08em;"><svg width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702
    c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
    c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
    c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
    s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
    c69,-144,104.5,-217.7,106.5,-221
    l0 -0
    c5.3,-9.3,12,-14,20,-14
    H400000v40H845.2724
    s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
    c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
    M834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.083905em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.04em; vertical-align: -0.083905em;"></span><span class="mord sqrt"><span class="root"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.845534em;"><span class="" style="top: -3.02331em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size6 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.956095em;"><span class="svg-align" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord" style="padding-left: 0.833em;"><span class="mord">9</span></span></span><span class="" style="top: -2.91609em;"><span class="pstrut" style="height: 3em;"></span><span class="hide-tail" style="min-width: 0.853em; height: 1.08em;"><svg width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702
    c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
    c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
    c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
    s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
    c69,-144,104.5,-217.7,106.5,-221
    l0 -0
    c5.3,-9.3,12,-14,20,-14
    H400000v40H845.2724
    s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
    c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
    M834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.083905em;"><span class=""></span></span></span></span></span></span></span></span></span>
</td>
</tr>
<tr>
<td>
  <div class="markup">
    \\begin{pmatrix}<br/>
    &nbsp;&nbsp;a && b \\\\<br/>
    &nbsp;&nbsp;c && d<br/>
    \\end{pmatrix}<br/>
  </div>
</td>
<td>
  <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>a</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>b</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>c</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>d</mi></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\\begin{pmatrix}
    a &amp;&amp; b \\\\
    c &amp;&amp; d
  \\end{pmatrix}
  </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 2.40003em; vertical-align: -0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.45em;"><span class="" style="top: -3.61em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span class="" style="top: -2.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.95em;"><span class=""></span></span></span></span></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.45em;"><span class="" style="top: -3.45em;"><span class="pstrut" style="height: 2.84em;"></span><span class="mord"></span></span><span class="" style="top: -2.25em;"><span class="pstrut" style="height: 2.84em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.95em;"><span class=""></span></span></span></span></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.45em;"><span class="" style="top: -3.61em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">b</span></span></span><span class="" style="top: -2.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.95em;"><span class=""></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top: 0em;"><span class="delimsizing size3">)</span></span></span></span></span></span></span>
</td>

<tr>
  <td>
    <div class="markup">
      f=\\begin{cases}<br/>
      0   & c1\\\\<br/>
      1   & c2\\\\<br/>
      2   & c2<br/>
      \\end{cases}<br/>
    </div>
  </td>
  <td>
    <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>c</mi><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>c</mi><mn>2</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>c</mi><mn>2</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">f =
      \\begin{cases}
      0   &amp; c1\\\\
      1   &amp; c2\\\\
      2   &amp; c2
      \\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 4.32em; vertical-align: -1.91em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 2.35002em;"><span class="" style="top: -2.19999em;"><span class="pstrut" style="height: 3.15em;"></span><span class="delimsizinginner delim-size4"><span class="">⎩</span></span></span><span class="" style="top: -2.19499em;"><span class="pstrut" style="height: 3.15em;"></span><span class="delimsizinginner delim-size4"><span class="">⎪</span></span></span><span class="" style="top: -2.20499em;"><span class="pstrut" style="height: 3.15em;"></span><span class="delimsizinginner delim-size4"><span class="">⎪</span></span></span><span class="" style="top: -3.15001em;"><span class="pstrut" style="height: 3.15em;"></span><span class="delimsizinginner delim-size4"><span class="">⎨</span></span></span><span class="" style="top: -4.29501em;"><span class="pstrut" style="height: 3.15em;"></span><span class="delimsizinginner delim-size4"><span class="">⎪</span></span></span><span class="" style="top: -4.30501em;"><span class="pstrut" style="height: 3.15em;"></span><span class="delimsizinginner delim-size4"><span class="">⎪</span></span></span><span class="" style="top: -4.60002em;"><span class="pstrut" style="height: 3.15em;"></span><span class="delimsizinginner delim-size4"><span class="">⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.85002em;"><span class=""></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 2.41em;"><span class="" style="top: -4.41em;"><span class="pstrut" style="height: 3.008em;"></span><span class="mord"><span class="mord">0</span></span></span><span class="" style="top: -2.97em;"><span class="pstrut" style="height: 3.008em;"></span><span class="mord"><span class="mord">1</span></span></span><span class="" style="top: -1.53em;"><span class="pstrut" style="height: 3.008em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.91em;"><span class=""></span></span></span></span></span><span class="arraycolsep" style="width: 1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 2.41em;"><span class="" style="top: -4.41em;"><span class="pstrut" style="height: 3.008em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="mord">1</span></span></span><span class="" style="top: -2.97em;"><span class="pstrut" style="height: 3.008em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="mord">2</span></span></span><span class="" style="top: -1.53em;"><span class="pstrut" style="height: 3.008em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.91em;"><span class=""></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>
  </td>
</tr>
</tr>
</table>
<div>`

/***/ }),

/***/ "../structured-text-editor/lib/declarativ_forms/src/declarativ_form.js":
/*!*****************************************************************************!*\
  !*** ../structured-text-editor/lib/declarativ_forms/src/declarativ_form.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var dl = __webpack_require__(/*! ./dl_select */ "../structured-text-editor/lib/declarativ_forms/src/dl_select.js");
var tippy = (__webpack_require__(/*! tippy.js */ "../structured-text-editor/node_modules/tippy.js/dist/tippy.esm.js")["default"]);
var tippyInstances = new Map();
var modalDialogs = [];

document.addEventListener("keydown", e => {
    if(modalDialogs.length === 0) {
        return;
    }

    lastDialog = modalDialogs[modalDialogs.length - 1];

    if(e.key === 'Escape') {
        lastDialog.escHandler(e)
    } else if(e.key === 'Enter') {
        if(Object.keys(lastDialog.buttons).length === 1) {
            lastDialog.enterHandler(e)
        }
    }
});

function DeclarativForm(attrs, onChangeCallback, onCancelCallback, confirmButtonCaption) {
    var self = this;
    this.fields = attrs.fields
    this.dom = document.createElement('div')
    this.dom.classList.add('dl-form')
    this.formElement = document.createElement('form')
    this.dom.appendChild(this.formElement)
    this.onChangeCallback = onChangeCallback
    this.onCancelCallback = onCancelCallback
    this.buttons = attrs.buttons || { [confirmButtonCaption || 'OK']: { action: onChangeCallback, id: 'confirmBtn-' + Math.round(Math.random()*1000000) }  }
    this.initPromises = {}
    this.allPromises = []

    if(Object.keys(this.buttons).length === 1) {
        this.onChangeCallback = Object.values(this.buttons)[0].action || Object.values(this.buttons)[0]
    }

    if(attrs.classNames) {
        attrs.classNames.forEach(function(name) {
            self.formElement.classList.add(name)
        })
    }

    this.formElement.onsubmit = function(e) {
        e.preventDefault();
        return false;
    }

    this.escHandler = function(e) {
        self.cancelModalIfCancelable()
    }

    this.enterHandler = function(e) {
        var field = self.fields.find(function(f) { return f.name === e.target.name})
        var confirmBtnElID =  Object.values(self.buttons).map(b => b.id).find(id => !!id)
        var confirmBtnEl = document.getElementById(confirmBtnElID)

        if(!field || !field.largetext) {
            if(!confirmBtnEl || !confirmBtnEl.classList.contains('disabled')) {
                self.closeModalIfOpen()
            }

            e.preventDefault()
            e.stopPropagation()
        } else if(!field.allowNewlines) {
            e.preventDefault()
            e.stopPropagation()
        }
    }

    this.fields.forEach((field, fieldIndex) => {
        var fieldWrapper = document.createElement('div'),
            fieldElement, label, allowedValues,
            message, tooltip

        allowedValues = (field.allowedValues instanceof Function) ?
            field.allowedValues() :
            field.allowedValues

        message = (field.message instanceof Function) ?
            field.message() :
            field.message

        fieldWrapper.id = 'dl-form-field-wrapper-for-' + field.name
        fieldWrapper.classList.add('dl-form-field-wrapper')

        if(field.tab) {
            fieldWrapper.classList.add(field.tab.replace(/\s/g, ''))
        }

        if(allowedValues) {
            fieldElement = document.createElement('dl-select')
            fieldWrapper.classList.add('dl-select-wrapper')
            fieldElement.setLoadingStatus()
            self.initPromises[field.name] = Promise.resolve(allowedValues).then(values => {
                values.forEach((val) => {
                    let optEl = document.createElement('dl-option')
                    if(Array.isArray(val)) {
                        optEl.setAttribute('value', val[0])
                        optEl.innerHTML = val[1]
                        if(val[2]) {
                            optEl.setAttribute('displayWhenSelected', val[2])
                        }
                    } else {
                        optEl.innerHTML = val
                    }

                    fieldElement.onchange = () => {
                        self.updateForm(fieldElement)
                    }

                    fieldElement.addOption(optEl)
                })

                fieldElement.unsetLoadingStatus()
            }).catch(_ => {
                fieldElement.unsetLoadingStatus()
            })

            this.allPromises.push(self.initPromises[field.name])
        } else if (field.message) {
            fieldElement = document.createElement('p')
            fieldElement.classList.add('message')
            fieldElement.innerHTML = field.message
        } else if (field.arrayOf) {
            fieldElement = document.createElement('div')
            fieldElement.classList.add('array-of')
            fieldElement.setValue = (value) => {
                fieldElement.value = value
                self.updateForm(fieldElement)
            }

            field.render = (dom, formData) => {
                dom.innerHTML = ''

                let renderEntry = field.renderEntry || (obj => Object.values(obj).filter(val => (typeof val === 'string') && val.trim() !== '').join(', '))

                if(field.suggested) {
                    let suggestedContainer = document.createElement('div')
                    suggestedContainer.classList.add('dl-form-array-suggested-container')
                    let suggestedEntries = typeof field.suggested === 'function' ?
                        field.suggested(formData, modalDialogs.map(d => d.getValues())) :
                        field.suggested;

                    (suggestedEntries || []).forEach((suggestedEntry, fieldIndex) => {
                        checkboxEl = document.createElement('span')

                        let cb = document.createElement('input')
                        cb.id = 'field-' + fieldIndex
                        cb.setAttribute('type', 'checkbox')
                        cb.oninput = cb.onchange = () => {
                            field.domElement.acceptedSuggestions = field.domElement.acceptedSuggestions || [];

                            checkboxEl.setAttribute('value', cb.checked)

                            if(cb.checked) {
                                field.domElement.acceptedSuggestions.push([suggestedEntry, fieldIndex])
                            } else {
                                field.domElement.acceptedSuggestions = field.domElement.acceptedSuggestions.filter(x => x[1] !== fieldIndex)
                            }
                        }

                        let labelEl = document.createElement('label')
                        labelEl.setAttribute('for', 'field-' + fieldIndex)
                        labelEl.innerHTML = renderEntry(suggestedEntry)

                        checkboxEl.classList.add('check')
                        checkboxEl.classList.add('dl-form-array-of-suggestion')
                        checkboxEl.appendChild(cb)
                        checkboxEl.appendChild(labelEl)
                        checkboxEl.setAttribute('value', false)
                        checkboxEl.jsonValue = suggestedEntry

                        suggestedContainer.appendChild(checkboxEl)

                        return checkboxEl
                    })

                    dom.appendChild(suggestedContainer)
                }

                const getConfirmButton = action => ({
                    'OK': {
                        action,
                        id: 'addIntegration',
                        isActive: formData => field.isValidRecord ? field.isValidRecord(formData, self) : true,
                    }
                })

                dom.value && dom.value.forEach && dom.value.forEach((entryObj, elIndex) => {
                    let entryEl = document.createElement('div')
                    let deleteElBtn = document.createElement('button')
                    let editElBtn = document.createElement('button')
                    deleteElBtn.innerHTML = 'Remove'
                    editElBtn.innerHTML = 'Edit'
                    entryEl.innerHTML = '<span>' + renderEntry(entryObj) + '</span>'
                    entryEl.dataset.ElIndex = elIndex
                    entryEl.classList.add('dl-form-array-of-entry')

                    entryEl.appendChild(editElBtn)
                    entryEl.appendChild(deleteElBtn)

                    deleteElBtn.classList.add('delete-array-of-btn')

                    editElBtn.classList.add('edit-array-of-btn')
                    editElBtn.dataset.ElIndex = elIndex
                    editElBtn.onclick = e => {
                        e.preventDefault()

                        let editFieds = field.arrayOf.map(field => {
                            return {
                                ...field,
                                defaultValue: dom.value[deleteElBtn.dataset.ElIndex][field.name] || ''
                            };
                        })

                        new DeclarativForm({ classNames: [`form-for-array-of-${field.name}`], fields: editFieds, buttons: getConfirmButton(formData => {
                            dom.value = dom.value || []
                            dom.value[deleteElBtn.dataset.ElIndex] = formData
                            dom.setValue(dom.value)
                            if(field.onChange) {
                                Promise.allSettled(this.allPromises).then(() => field.onChange(this.getValues()))
                            }
                        }) }, () => {}, () => {}).openInModal()
                    }

                    deleteElBtn.dataset.ElIndex = elIndex
                    deleteElBtn.onclick = e => {
                        dom.value.splice(deleteElBtn.dataset.ElIndex, 1)
                        dom.setValue(dom.value)
                        e.preventDefault()
                        if(field.onChange) {
                            Promise.allSettled(this.allPromises).then(() => field.onChange(this.getValues()))
                        }
                    }

                    dom.appendChild(entryEl)
                })

                let addButton = document.createElement('button')
                addButton.classList.add('dl-form-array-of-add-entry')
                addButton.innerHTML = field.newButtonLabel || 'Add'

                addButton.onclick = e => {
                    new DeclarativForm({ classNames: [`form-for-array-of-${field.name}`], fields: field.arrayOf, buttons: getConfirmButton(formData => {
                        dom.value = dom.value || []
                        dom.value.push(formData)
                        dom.setValue(dom.value)
                        if(field.onChange) {
                            Promise.all(this.allPromises).then(() => field.onChange(this.getValues()))
                        }
                    })}, () => {}, () => {}).openInModal()

                    e.preventDefault()
                }

                dom.appendChild(addButton)
            }

            field.render(fieldElement, self.formData, self)
        } else if (field.render) {
            fieldElement = document.createElement('p')
            fieldElement.classList.add('render')

            fieldElement.onChange = function (forceFormUpdate) {
                self.updateForm(fieldElement, forceFormUpdate);
            }

            field.render(fieldElement, self.formData, self)
        } else if (field.largetext) {
            fieldElement = document.createElement('textarea')
            fieldElement.oninput = fieldElement.onchange = function() {
                self.updateForm(fieldElement);
            }
        } else if (field.check) {
            fieldElement = document.createElement('span')

            let cb = document.createElement('input')
            cb.id = 'field-' + fieldIndex
            cb.setAttribute('type', 'checkbox')
            cb.oninput = cb.onchange = function() {
                fieldElement.setAttribute('value', cb.checked)
                self.updateForm(cb);
            }

            let labelEl = document.createElement('label')
            labelEl.setAttribute('for', 'field-' + fieldIndex)
            labelEl.innerHTML = field.check

            fieldElement.classList.add('check')
            fieldElement.appendChild(cb)
            fieldElement.appendChild(labelEl)
            fieldElement.setAttribute('value', typeof field.defaultValue === 'function' ? field.defaultValue(self.formData) : field.defaultValue)
            fieldElement.setValue = function(val) {
                cb.checked = !!val
            }
        } else if (field.detailedOptions) {
            fieldElement = document.createElement('div')
            fieldElement.classList.add('detailed-options')

            field.detailedOptions.forEach(function(option) {
                var optionEl = document.createElement('div');
                optionEl.classList.add('detailed-option');

                optionEl.innerHTML = option.html;
                optionEl.setAttribute('data-value', option.value);

                optionEl.addEventListener("click", function() {
                    fieldElement.value = option.value;
                    fieldElement.querySelectorAll('.detailed-option').forEach(function(option) {
                        option.classList.remove('active');
                    });

                    optionEl.classList.add('active');
                    self.updateForm(optionEl);
                });

                fieldElement.appendChild(optionEl)
                fieldElement.setValue = function(val) {
                    var el = fieldElement.querySelector(`div[data-value="${val}"]`);

                    if(!el) {
                        return;
                    }

                    fieldElement.value = val;
                    fieldElement.querySelectorAll('.detailed-option').forEach(function(option) {
                        option.classList.remove('active');
                    });

                    el.classList.add('active');
                }
            });
        } else if (field.calculate) {
            fieldElement = document.createElement('input')
            fieldElement.type = 'hidden'
        } else {
            fieldElement = document.createElement('input')
            fieldElement.setValue = function(val) {
                fieldElement.value = val;
            }

            if(field.inputType) {
                fieldElement.setAttribute('type', field.inputType);
            }

            if(field.autocomplete) {
                fieldElement.setAttribute('autocomplete', field.autocomplete);
            }

            if(field.placeholder) {
                fieldElement.placeholder = field.placeholder;
            }

            fieldElement.oninput = fieldElement.onchange = function() {
                self.updateForm(fieldElement);
            }
        }

        field.domElement = fieldElement
        fieldElement.name = field.name
        fieldElement.setAttribute('name', field.name)

        if(field.displayName) {
            label = document.createElement('label')
            label.innerHTML = field.displayName
            label.setAttribute('for', field.name)
            fieldWrapper.appendChild(label)
        } else {
            fieldWrapper.classList.add('withoutLabel')
        }

        if(field.tooltip) {
            tooltip = document.createElement('span')
            tooltip.dataset['tippyContent'] = field.tooltip.text || field.tooltip
            tooltip.dataset['initialTippyContent'] = field.tooltip.text || field.tooltip
            tooltip.classList.add('dl-tooltip')
            tooltip.innerHTML = '?'

            if(label && !field.tooltip.inInput) {
                label.appendChild(tooltip)
            } else {
                tooltip.classList.add('dl-tooltip-in-input')
                fieldElement.classList.add('dl-tooltip-inside')
                fieldWrapper.appendChild(tooltip)
            }
        }

        if(fieldElement.type === 'hidden') {
            fieldWrapper.classList.add('dl-form-hidden-field')
        }

        fieldWrapper.appendChild(fieldElement)
        self.dom.children[0].appendChild(fieldWrapper)

        if(field.defaultValue) {
            this.allPromises.push(Promise.resolve(self.initPromises[field.name]).then(_ => {
                let tmpDefaultValue = typeof field.defaultValue === 'function' ? field.defaultValue(self.formData) : field.defaultValue

                if(fieldElement.setValue) {
                    fieldElement.setValue(tmpDefaultValue)
                } else if (fieldElement.tagName === 'INPUT' || fieldElement.tagName === 'TEXTAREA') {
                    fieldElement.value = tmpDefaultValue
                } else {
                    fieldElement.setAttribute('value', tmpDefaultValue)
                }
            }))
        }
    })

    Promise.allSettled(this.allPromises).then(_ => self.updateForm())
}

DeclarativForm.prototype = {

    updateForm: function(triggerElement, forceFormUpdate) {
        var formData = this.getValues();
        var self = this
        var triggerFieldName = triggerElement && triggerElement.name

        if(this._lastFromUpdatSate === JSON.stringify(formData) && !forceFormUpdate) {
            return;
        }

        this._lastFromUpdatSate = JSON.stringify(formData)

        this.fields.forEach(field => {
            var shouldReload = (!triggerFieldName || (field.reloadOnChangeOf && field.reloadOnChangeOf.includes(triggerFieldName)))

            if(!field.domElement) {
                return;
            }

            if(field.isActive) {
                let tmpIsActive = field.isActive(formData, modalDialogs.map(d => d.getValues()))
                if(tmpIsActive) {
                    field.domElement.parentElement.classList.remove('inactive')
                } else {
                    field.domElement.parentElement.classList.add('inactive')
                }
            }

            if(field.onFormChange) {
                field.onFormChange(formData, self, triggerElement)
            }

            if(field.render) {
                field.render(field.domElement, formData, self)
            }

            if(field.allowedValues instanceof Function && shouldReload) {
                const allowedValues = field.allowedValues(formData)
                field.domElement.setLoadingStatus()
                this.allPromises.push(allowedValues)

                Promise.resolve(allowedValues).then(values => {
                    this.resetTooltip(field.name)
                    field.domElement.removeAllOptions()

                    values && values.forEach((val) => {
                        let optEl = document.createElement('dl-option')
                        if(Array.isArray(val)) {
                            optEl.setAttribute('value', val[0])
                            optEl.innerHTML = val[1]
                            if(val[2]) {
                                optEl.setAttribute('displayWhenSelected', val[2])
                            }
                        } else {
                            optEl.innerHTML = val
                        }

                        field.domElement.onchange = function() {
                            self.updateForm(field.domElement)
                        }

                        field.domElement.addOption(optEl)
                    })

                    field.domElement.unsetLoadingStatus()
                    field.domElement.setValue(field.domElement.getValue())
                }).catch(err => {
                    field.domElement.unsetLoadingStatus()
                    if(field.onValuesCalculationFailedMessage) {
                        const message = field.onValuesCalculationFailedMessage(formData, err);
                        if(message.level === 'info') {
                            this.setTooltipWarning(field.name, message.text)
                        } else if(message.level === 'warning') {
                            this.setTooltipWarning(field.name, message.text)
                        } else if(message.level === 'error') {
                            this.setTooltipError(field.name, message.text)
                        }
                    }
                })
            }
        });

        Promise.allSettled(this.allPromises).then(() => {
            formData = this.getValues();

            Object.values(this.buttons)
                .filter(btn => (btn.isActive && btn.id))
                .forEach(btn => {
                    let buttonEl = document.getElementById(btn.id)
                    if(!buttonEl) return;

                    buttonEl.classList.add('disabled')

                    let isActiveCheckPrmise = btn.isActive(formData)
                    this.allPromises.push(isActiveCheckPrmise)

                    Promise.resolve(isActiveCheckPrmise)
                        .then(BtnIsActive => {
                            if(BtnIsActive) {
                                buttonEl.classList.remove('disabled')
                            } else {
                                buttonEl.classList.add('disabled')
                            }
                        })
                });
        })
    },

    updateCalculatedFields(triggerFieldName, formData) {
        return Promise.allSettled(this.fields.map(field => new Promise(done => {
            var shouldReload = (!triggerFieldName || (field.reloadOnChangeOf && field.reloadOnChangeOf.includes(triggerFieldName)))

            if(field.calculate && shouldReload) {
                return Promise.allSettled(this.allPromises).then(() => {
                    const thisUpdatePromise = field.calculate(formData || this.getValues())
                    this.allPromises.push(thisUpdatePromise)
                    return Promise.resolve(thisUpdatePromise).then(v => {
                        field.domElement._value = v
                        done()
                    })
                })
            } else {
                done()
            }
        })))
    },

    getHTML: function() {
        return this.dom.outerHTML;
    },

    openInModal: function(attr) {
        modalDialogs.push(this);

        this.modalEl = this.modalEl || this.createModalElement(attr)

        var modalContent = this.modalEl.querySelector('.modal-content')
        var modalWindow = this.modalEl.querySelector('.modal')

        this.updateTabs()
        modalContent.appendChild(this.dom)
        this.modalEl.style.display = 'block'

        if(attr && attr.classNames) {
            attr.classNames.forEach(function(name) {
                modalWindow.classList.add(name)
            })
        }

        this.updateTooltips();

        if(modalDialogs.length >= 2) {
            modalDialogs[modalDialogs.length-2].hide()
        }
    },

    appendInElement: function(el, attr) {
        var self = this
        this.modalEl = this.modalEl || this.createModalElement(attr, true)
        this.modalEl.style.display = 'block'

        var modalContent = this.modalEl.querySelector('.modal-content')

        this.modalEl.classList.add('noModalDialog')

        if(attr && attr.classNames) {
            attr.classNames.forEach(function(name) {
                self.modalEl.classList.add(name)
            })
        }

        modalContent.appendChild(this.dom)
        el.appendChild(this.modalEl)
        this.updateTabs()

        this.updateTooltips()
    },

    hide: function() {
        this.modalEl && this.modalEl.classList.add('dl-modal-hidden')
    },

    show: function() {
        this.modalEl && this.modalEl.classList.remove('dl-modal-hidden')
    },

    updateTooltips: function(sel) {
        sel = sel || '[data-tippy-content]';

        var domElements = document.querySelectorAll(sel);

        domElements.forEach(el => {
            if(tippyInstances.get(el)) {
                tippyInstances.get(el).forEach(el => el.destroy());
                tippyInstances.delete(el);
            }
        })

        var tippies = tippy(sel, {
            placement: 'right',
            allowHTML: true,
            interactive: true
        })

        tippies.forEach(tippy => {
            if(tippyInstances.get(tippy.reference)) {
                tippyInstances.get(tippy.reference).push(tippy)
            } else {
                tippyInstances.set(tippy.reference, [tippy]);
            }
        });
    },

    setTooltip: function(fieldName, text, iconContent, className) {
        className = className || '';
        var tooltipSelector = `#dl-form-field-wrapper-for-${fieldName} .dl-tooltip`;
        var tooltipEl = document.querySelector(tooltipSelector);

        if(tooltipEl.classList.value.includes('dl-tooltip-in-input')) {
            tooltipEl.classList.value = `dl-tooltip dl-tooltip-in-input ${className}`;
        } else {
            tooltipEl.classList.value = `dl-tooltip ${className}`;
        }

        tooltipEl.dataset['tippyContent'] = text;
        tooltipEl.innerHTML = iconContent;

        this.updateTooltips(tooltipSelector);
    },

    setTooltipSuccess: function(fieldName, text) {
        this.setTooltip(fieldName, text, '&#10003;', 'tooltip-success')
    },

    setTooltipWarning: function(fieldName, text) {
        this.setTooltip(fieldName, text, '!', 'tooltip-warning');
    },

    setTooltipError: function(fieldName, text) {
        this.setTooltip(fieldName, text, '!', 'tooltip-error');
    },

    resetTooltip: function(fieldName) {
        var tooltipEl = document.querySelector(`#dl-form-field-wrapper-for-${fieldName} .dl-tooltip`);

        if(tooltipEl) {
            this.setTooltip(fieldName, tooltipEl.dataset['initialTippyContent'], '?', '');
        }
    },

    resetTooltips: function(fieldNames) {
        fieldNames.forEach(fieldName => this.resetTooltip(fieldName))
    },

    updateTabs: function() {
        var tabsWrapper = this.modalEl.querySelector('.tabWrapper'),
            tabs = this.fields.filter(f => f.tab).map(f => f.tab).filter((value, index, self) => self.indexOf(value) === index),
            self = this, tmpTabEl

        tabsWrapper.innerHTML = ''

        tabs.forEach((tab) => {
            tmpTabEl = document.createElement('div')
            tmpTabEl.classList.add('dl-tab-btn')
            tmpTabEl.classList.add(tab.replace(/\s/g, ''))
            tmpTabEl.innerHTML = tab
            tmpTabEl.onclick = function() {
                self.setActiveTab(tab)
            }
            tabsWrapper.appendChild(tmpTabEl)
        })

        if(tabs[0]) {
            this.setActiveTab(tabs[0])
        }
    },

    setActiveTab: function(tab) {
        if(!tab) {
            tab = this.activeTab
        }

        var tabClassName = tab.replace(/\s/g, ''),
            currentActiveTabBtn = document.querySelector('.dl-tab-btn.active'),
            tabBtn = document.querySelector('.dl-tab-btn.' + tabClassName)

        if(currentActiveTabBtn) {
            currentActiveTabBtn.classList.remove('active')
        }

        tabBtn.classList.add('active')

        this.activeTab = tab;
        this.fields.forEach(field => {
            if(!field.domElement) { return }
            if(field.tab === tab) {
                field.domElement.parentElement.classList.remove('notInTab')
            } else {
                field.domElement.parentElement.classList.add('notInTab')
            }
        })
    },

    deleteFromStack: function() {
        modalDialogs = modalDialogs.filter(dia => dia !== this)
    },

    cancelModalIfCancelable: function() {
        if(this.onCancelCallback) {
            if(this.modalEl) {
                this.modalEl.remove()
                this.modalEl = null
            }

            this.onCancelCallback()
            this.deleteFromStack()

            if(modalDialogs.length) {
                modalDialogs[modalDialogs.length-1].show()
                modalDialogs[modalDialogs.length-1].setActiveTab()
            }
        }
    },

    closeModalIfOpen: function(callaback) {
        callaback = callaback || this.onChangeCallback

        if(this.modalEl) {
            this.modalEl.remove()
            this.modalEl = null
        }

        if(callaback) {
            callaback(this.getValues())
        }

        this.deleteFromStack()

        if(modalDialogs.length) {
            modalDialogs[modalDialogs.length-1].show()
            modalDialogs[modalDialogs.length-1].setActiveTab()
        }
    },

    getValues: function() {
        var result  = {}

        //TODO: filter calculated fields
        this.fields.filter(function(field) {
            return field.domElement && !field.domElement.parentElement.classList.contains('inactive')
        }).forEach(function(field) {
            if(!field.domElement) { return }
            result[field.name] = field.domElement.getAttribute('value') || field.domElement._value || field.domElement.value

            if(field.domElement.acceptedSuggestions) {
                result[field.name] = result[field.name] || [];
                field.domElement.acceptedSuggestions
                    .map(el => el[0])
                    .forEach(candidate => {
                        if(!result[field.name].find(processed => JSON.stringify(candidate) === JSON.stringify(processed))) {
                            result[field.name].push(candidate)
                        }
                    })
            }

            if(!result[field.name]) {
                result[field.name] = ''
            }

            if(field.check) {
                result[field.name] = result[field.name] === 'true'
            }
        })

        result.activeTab = this.activeTab;
        return result
    },

    createModalElement: function(attr, doNotMount) {

        attr = attr || {}
        attr.classNames = attr.classNames || []

        var modalWrapper = document.createElement('div'),
            modal = document.createElement('div'),
            modalContent = document.createElement('div'),
            lowBar = document.createElement('div'),
            upBar  = document.createElement('div'),
            cancelBtn = document.createElement('div'),
            tabWrapper = document.createElement('div'),
            tmpBtn

        modalWrapper.classList.add('dl-modal')
        modalWrapper.style.display = 'none'
        modal.classList.add('modal')
        modalContent.classList.add('modal-content')
        tabWrapper.classList.add('tabWrapper')
        lowBar.classList.add('low-bar')

        Object.keys(this.buttons).forEach((btn => {
            let callback = typeof this.buttons[btn] === 'function' ? this.buttons[btn] : this.buttons[btn].action
            tmpBtn = document.createElement('div')
            tmpBtn.classList.add('btn')
            tmpBtn.innerHTML = btn

            if(this.buttons[btn].id) {
                tmpBtn.id = this.buttons[btn].id
            }

            tmpBtn.onclick = (event) => {
                const classes = event.target.classList

                if(classes.contains('loading-btn') || classes.contains('disabled')) {
                    return
                }

                Promise.allSettled(this.allPromises).then(() => {
                    if(!classes.contains('disabled')) {
                        this.updateCalculatedFields().then(() => {
                            this.closeModalIfOpen(callback)
                            classes.remove('loading-btn')
                        })
                    }
                })
            }

            lowBar.appendChild(tmpBtn)
        }))

        if(this.onCancelCallback) {
            upBar.classList.add('up-bar')
            cancelBtn.classList.add('cancelBtn')
            cancelBtn.onclick = () => { this.cancelModalIfCancelable() }
            upBar.appendChild(cancelBtn)
        }

        modalWrapper.appendChild(modal)
        modal.appendChild(upBar)
        modal.appendChild(tabWrapper)
        modal.appendChild(modalContent)
        modal.appendChild(lowBar)

        if(!doNotMount) {
            document.body.appendChild(modalWrapper)
        }

        return modalWrapper
    }
}

module.exports = DeclarativForm


/***/ }),

/***/ "../structured-text-editor/lib/declarativ_forms/src/dl_select.js":
/*!***********************************************************************!*\
  !*** ../structured-text-editor/lib/declarativ_forms/src/dl_select.js ***!
  \***********************************************************************/
/***/ (() => {

var style = document.createElement('style'),
    xmlns = 'http://www.w3.org/2000/svg'

style.textContent = `
    @keyframes placeHolderShimmer{
        0%{
            background-position: -468px 0
        }
        100%{
            background-position: 468px 0
        }
    }

    dl-select {
        position: relative;
        font-weight: 300;
        font-family: 'Rubik', sans-serif;
    }

    dl-select .input-wrapper {
        display: inline-block;
        border: 2px solid #ddd;
        border-radius: 4px;
    }

    dl-select.dl-focused .input-wrapper {
        border: 2px solid #bbb;
    }

    dl-select.dl-focused .input-wrapper svg {
        border-left: 1px solid #bbb;
        fill: #bbb;
    }

    dl-select .options-wrapper {
        position: absolute;
        left: 0px;
        top: 20px;
        font-size: 0.9em;
        background-color: #fff;
        width: 100%;
        max-height: 230px;
        overflow: scroll;
        box-shadow: 0px 0px 10px -2px rgba(0,0,0,0.4);
        z-index: 100;
    }

    dl-select .options-wrapper dl-option {
        border-left: 1px solid #bbb;
        border-right: 1px solid #bbb;
        cursor: pointer;
    }

    dl-select .options-wrapper .noMatchesHint {
        border-left: 1px solid #bbb;
        border-right: 1px solid #bbb;
        padding: 5px;
        font-style: italic;
    }

    dl-select .options-wrapper {
        border-top: 1px solid #bbb;
        border-bottom: 1px solid #bbb;
        border-radius: 4px;
    }

    dl-select .input-wrapper input {
        width: 371px;
        outline-width: 0;
        margin-top: 2px;
        padding: 6px;
        font-size: 0.9em;
        font-family: 'Rubik', sans-serif;
        font-weight: 300;
        border: 0px;
        border-radius: 4px;
        float: left;
        cursor: pointer;
        box-sizing: content-box;
    }

    dl-select .input-wrapper svg {
        width: 20px;
        height: 20px;
        margin-top: 5px;
        margin-right: 4px;
        padding-left: 4px;
        fill: #ddd;
        float: right;
        border-left: 1px solid #ddd;
        cursor: pointer;
    }

    dl-select .options-wrapper dl-option {
        display: block;
        padding: 5px;
        color: #545454;
    }

    dl-select .options-wrapper dl-option:hover {
        background-color: rgba(224, 240, 227, 0.4);
    }

    dl-select .options-wrapper dl-option.dl-focused {
        background-color: rgba(224, 240, 227, 0.4);
    }

    dl-select .dl-option-tag {
        float: right;
        border: 1px solid #888;
        font-size: 0.8em;
        padding: 2px;
        font-family: 'Source Code Pro', monospace;
        border-radius: 2px;
        margin-top: -1px;
    }

    dl-select .dl-option-tag:last-child {
       margin-right: 10px;
    }

    .dl-select-loading {

    }

    .dl-select-no-options-available svg path {
        display: none;
    }

    .dl-select-no-options-available svg {
        border-left: none !important;
    }

    .dl-select-loading svg, .dl-select-no-options-available svg {
        pointer-events: none;
    }

    .dl-select-loading input, .dl-select-no-options-available input {
        pointer-events: none;
    }

    body.dark-theme dl-select {
        --dl-select-loading-col1: #282727;
        --dl-select-loading-col2: #505656;
    }

    dl-select {
        --dl-select-loading-col1: #eeeeee;
        --dl-select-loading-col2: #dddddd;
    }

    .dl-select-loading .input-wrapper {
        animation-duration: 1.25s;
        animation-fill-mode: forwards;
        animation-iteration-count: infinite;
        animation-name: placeHolderShimmer;
        animation-timing-function: linear;
        background: darkgray;
        background: linear-gradient(to right, var(--dl-select-loading-col1) 10%, var(--dl-select-loading-col2) 18%, var(--dl-select-loading-col1) 33%);
        background-size: 800px 104px;
        position: relative;
        width: 412px;
        height: 31px;
    }
    .dl-select-loading input {
        display: none;
    }
`

window.addEventListener('load', () => {
    document.body.appendChild(style)
})

class DlSelect extends HTMLElement {
    constructor() {
        super()
        this.loadingScreenTimeouts = []
        this.loadingStartedAt = undefined
        this.optionsWrapper = document.createElement('div')
        this.inputWrapper = document.createElement('span')
        this.noMatchesHint = document.createElement('span')
        this.inputField = document.createElement('input')
        this.arrow = document.createElementNS(xmlns, 'svg')
    }

    connectedCallback() {
        var self = this

        if(this.isInitialized) { return }

        this.inputWrapper.classList.add('input-wrapper')
        this.optionsWrapper.classList.add('options-wrapper')
        this.optionsWrapper.style.display = 'none'
        this.inputField.placeholder = 'Select ...'
        this.noMatchesHint.classList.add('noMatchesHint')
        this.noMatchesHint.innerHTML = 'No Matches'
        this.noMatchesHint.style.display = 'none'
        this.inputField.onfocus = () => { self.focus() }
        this.inputField.onblur = (e) => { self.unfocus() }
        this.inputField.oninput = () => { self.filterOptions(this.inputField.value) }
        this.arrow.onclick = () => { self.inputField.focus() }
        this.arrow.innerHTML = '<path d="M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"></path>'

        this.optionsWrapper.appendChild(this.noMatchesHint)

        this.classList.add('dl-select-no-options-available')

        if (document.readyState !== 'loading') {
            this.loadOptions()
        } else {
            window.addEventListener('load', () => {self.loadOptions()})
        }

        this.addEventListener("keydown", (e) => {
            var option = self.focusedOption()
            if(e.key === 'ArrowDown') {
                self.focusOption(self.nextVisibleOptionAfter(option))
                e.preventDefault()
                e.stopPropagation()
            } else if(e.key === 'ArrowUp') {
                self.focusOption(self.previousVisibleOptionAfter(option))
                e.preventDefault()
                e.stopPropagation()
            } else if(e.key === 'Enter') {
                self.setOption(option)
                self.unfocus()
                e.preventDefault()
                e.stopPropagation()
            }
        })

        this.isInitialized = true;
    }

    setLoadingStatus() {
        this.loadingScreenTimeouts.push(setTimeout(() => {
            this.classList.add('dl-select-loading')
            this.optionsWrapper.remove()
            this.loadingStartedAt = Date.now()
        }, 100))
    }

    unsetLoadingStatus() {
        this.loadingScreenTimeouts.forEach(clearTimeout)
        this.loadingScreenTimeouts = []

        const minLoadTimeInSeconds = 1.5
        const delay = this.loadingStartedAt ?
            (minLoadTimeInSeconds * 1000) - (Date.now() - this.loadingStartedAt)
            : 0

        setTimeout(() => {
            this.appendChild(this.optionsWrapper)
            this.classList.remove('dl-select-loading')
        }, delay)
    }

    loadOptions() {
        var self = this
        while(self.firstElementChild) {
            self.firstElementChild.onmousedown = function() { self.setOption(this) }
            self.firstElementChild.onmouseover = function() { self.clearFocusedOption() }
            self.optionsWrapper.appendChild(self.firstElementChild)
        }

        self.inputWrapper.appendChild(self.inputField)
        self.inputWrapper.appendChild(self.arrow)
        self.appendChild(self.inputWrapper)
        self.appendChild(self.optionsWrapper)
        self.setValue(self.getValue())
        this.updatePlaceholderText()
    }

    removeAllOptions() {
        this.classList.add('dl-select-no-options-available')
        this.querySelectorAll('dl-option').forEach(opt => opt.remove())
        this.updatePlaceholderText()
    }

    addOption(optionEl) {
        var self = this

        optionEl.onmousedown = function() { self.setOption(this) }
        optionEl.onmouseover = function() { self.clearFocusedOption() }
        self.optionsWrapper.appendChild(optionEl)

        this.classList.remove('dl-select-no-options-available')
        this.updatePlaceholderText()
    }

    clearFocusedOption() {
        this._focusedOption = null
        Array.prototype.forEach.call(this.optionsWrapper.children, (opt) => {
            opt.classList.remove('dl-focused')
        })
    }

    focusedOption() {
        return this._focusedOption
    }

    focusOption(option) {
        option = option || this.nextVisibleOptionAfter(option)

        this.clearFocusedOption()

        this._focusedOption = option
        if(option) {
            option.classList.add('dl-focused')
        }
    }

    nextVisibleOptionAfter(option) {
        option = option || this.optionsWrapper.children[0]
        while(option) {
            if(option.nextSibling && option.nextSibling.style.display !== 'none') {
                return option.nextSibling
            }

            option = option.nextSibling
        }
    }

    previousVisibleOptionAfter(option) {
        option = option || this.optionsWrapper.children[0]
        while(option) {
            if(option.previousSibling && option.previousSibling.style.display !== 'none') {
                return option.previousSibling
            }

            option = option.previousSibling
        }
    }

    filterOptions(str) {
        var hasMatched = false;
        str = str.toLowerCase()

        Array.prototype.forEach.call(this.optionsWrapper.children, (opt) => {
            if(str === '' || str.split(' ').every(term => opt.innerText.toLowerCase().includes(term))) {
                opt.style.display = 'block'
                hasMatched = true
            } else {
                opt.style.display = 'none'
            }
        })

        this.noMatchesHint.style.display = hasMatched ? 'none' : 'block'
    }

    setValue(val) {
        if(!val) {
            return
        }

        var option = this.querySelector('dl-option[value="'+val+'"]') ||
                     Array.prototype.find.call(this.querySelectorAll('dl-option'), function(el) {return el.innerText == val})

        this.setAttribute('tmp-value', val)
        this.setOption(option)
    }

    setOption(optionEl) {
        if(!optionEl) { return false }

        this.selectedOptionEl = optionEl
        this.inputField.value = this.getDisplayedText()
        this.setAttribute('value', optionEl.getAttribute('value') || optionEl.innerText)

        var evt = document.createEvent("HTMLEvents")
        evt.initEvent("change", false, true)
        this.dispatchEvent(evt)
    }

    getDisplayedText() {
        if(this.selectedOptionEl) {
            return this.selectedOptionEl.getAttribute('displayWhenSelected') || this.selectedOptionEl.innerText
        } else {
            return ''
        }
    }

    getPlaceholderText() {
        if (this.optionsWrapper.querySelectorAll('dl-option').length === 0) {
            return 'No Options Available'
        } else if(this.selectedOptionEl) {
            return this.selectedOptionEl.innerText
        } else {
            return 'Select ...'
        }
    }

    updatePlaceholderText() {
        this.inputField.placeholder = this.getPlaceholderText()
    }

    getValue() {
        if(this.getAttribute('value')) {
            return this.getAttribute('value')
        }

        var tmpValue = this.getAttribute('tmp-value')
        var option = this.querySelector('dl-option[value="'+this.getAttribute('tmp-value')+'"]')

        if(option && tmpValue) {
            return tmpValue
        }
    }

    focus() {
        this.classList.add('dl-focused')
        this.updatePlaceholderText()
        this.inputField.value = ''
        this.optionsWrapper.style.display = 'inline-block'
        this.filterOptions(this.inputField.value)
    }

    unfocus() {
        this.classList.remove('dl-focused')
        this.optionsWrapper.style.display = 'none'
        this.inputField.value = this.getDisplayedText()
        this.inputField.blur()
    }
}

customElements.define('dl-select', DlSelect)


/***/ }),

/***/ "../structured-text-editor/lib/documentupdater/documentupdater.js":
/*!************************************************************************!*\
  !*** ../structured-text-editor/lib/documentupdater/documentupdater.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ModificationLogEntry = __webpack_require__(/*! ./modification_log */ "../structured-text-editor/lib/documentupdater/modification_log.js"),
    utils = __webpack_require__(/*! ../pixelschubser/utils */ "../structured-text-editor/lib/pixelschubser/utils.js"),
    diffMatchPatch = __webpack_require__(/*! diff_match_patch */ "../structured-text-editor/node_modules/diff_match_patch/lib/diff_match_patch.js"),
    diffEngine = new diffMatchPatch.diff_match_patch,
    withLookahead = __webpack_require__(/*! ../generatorlookahead */ "../structured-text-editor/lib/generatorlookahead/index.js");

// This creates a vitual DOM for the passed `contentElement`
// Using the updateHTML function of this object provides the following advantages:
// - Passed HTML is sanitized based on the content rules of the `htmlRazor`.
// - It returns a modificationLogEntry which includes the changes made.
// - Only updates the dom fractions that must be changed (optimized
//   for long and quite flat documents)
function Documentupdater(contentElement, htmlRazor) {
    this.contentElement = contentElement;
    this.htmlRazor = htmlRazor;
}

Documentupdater.prototype = {
    updateHTML: function(content, focusedSection, args) {
        args = args || {};

        if(this.contentElement.children.length === 0) {
            this.contentElement.innerHTML = '<p></p>';
        }

        if(args.actor) {
            this.contentElement
                .querySelectorAll('.focused-by-api-actor' + args.actor.id + '-fbaaend')
                .forEach(el => el.classList.remove('focused-by-api-actor'+ args.actor.id + '-fbaaend'))
        }

        this.modificationLogEntry = args.modificationLogEntry || new ModificationLogEntry();
        this.modificationLogEntry.insertedBeforeSelectionRangeStart = 0;
        this.modificationLogEntry.insertedBeforeSelectionRangeEnd = 0;

        var firstSectionToUpdate = args.section || args.startSection || this.contentElement.children[0],
            lastSectionToUpdate =  args.section || args.endSection || this.contentElement.children[this.contentElement.children.length-1],
            newSectionStream,
            pairStream,
            lastUpdatedSection,
            pair;

        if(args.startSection &&
           args.endSection &&
        //    this.contentElement.children[0] !== args.startSection &&
        //    this.contentElement.children[this.contentElement.children.length-1] !== args.endSection &&
           content !== undefined &&
           content !== null &&
           content.trim() === '') {
            pairStream = this._deleteOldSectionsPairStream(firstSectionToUpdate, lastSectionToUpdate);
        } else {
            newSectionStream = this.htmlRazor.cleanupHTMLAndAttachEventHandlers(content, this.modificationLogEntry);
            pairStream = this._oldAndNewSectionPairStream(newSectionStream, firstSectionToUpdate, lastSectionToUpdate);
        }

        this.focusedSection = focusedSection;
        this.modificationLogEntry.retainAllSectionsBefore(firstSectionToUpdate);

        while(pair = pairStream.next().value) {
            if(pair.old && pair.new) {
                lastUpdatedSection = this._replaceSections(pair.old, pair.new, args);
            } else if(pair.new) {
                if(lastUpdatedSection) {
                    lastUpdatedSection = this._insertSectionAfter(lastUpdatedSection, pair.new, args);
                } else if(firstSectionToUpdate) {
                    lastUpdatedSection = this._insertSectionBefore(firstSectionToUpdate, pair.new, args);
                } else {
                    lastUpdatedSection = this._insertSectionAtBeginning(pair.new, args);
                }

            } else if(pair.old) {
                this._removeSection(pair.old);
            }

            if(lastUpdatedSection) {
                if(!lastUpdatedSection.wordCount) {
                    lastUpdatedSection.wordCount = lastUpdatedSection
                        .innerText
                        .split(/[\s\.:\?\!']/)
                        .filter(w => w.trim().length > 0)
                        .length;
                }
            }
        }

        this.modificationLogEntry.retainAllSectionsAfter(lastUpdatedSection);

        return this.modificationLogEntry;
    },

    _deleteOldSectionsPairStream: function*(firstSectionToUpdate, lastSectionToUpdate) {
        var nextOldSection = firstSectionToUpdate,
            nextNextOldSection;

        if(firstSectionToUpdate === lastSectionToUpdate) {
            yield { old: firstSectionToUpdate, new: null };
        } else {
            while(nextOldSection) {
                nextNextOldSection = nextOldSection.nextSibling;

                yield { old: nextOldSection, new: null };
                nextOldSection = nextNextOldSection;

                if(nextOldSection === lastSectionToUpdate) {
                    yield { old: nextOldSection, new: null };
                    break;
                }
            }
        }
    },

    _oldAndNewSectionPairStream: function*(newSectionStream, firstSectionToUpdate, lastSectionToUpdate) {
        newSectionStream = withLookahead(newSectionStream)

        var nextOldSection = firstSectionToUpdate,
            nextNextOldSection, nextSectionToBeInserted,
            newSection, nextNewSection;

        while(nextOldSection) {
            nextNextOldSection = nextOldSection.nextSibling;
            newSection = newSectionStream.next().value;
            nextNewSection = newSectionStream.lookahead().value;

            if(!this._areEqualSections(nextOldSection, newSection) &&
               !this._areEqualSections(nextNextOldSection, nextOldSection) &&
               this._areEqualSections(nextOldSection, nextNewSection)
            ) {
                yield { old: undefined, new: newSection };
            } else {
                yield { old: nextOldSection, new: newSection };
                if(nextOldSection === lastSectionToUpdate) { break }
                nextOldSection = nextNextOldSection;
            }
        }

        while(nextSectionToBeInserted = newSectionStream.next().value) {
            yield { old: null, new: nextSectionToBeInserted };
        }
    },

    _removeSection: function(section) {
        if(!section) return false;

        if(section === this.focusedSection) {
            this.modificationLogEntry.focusedSectionHasBeenModified = true;
        }

        this.modificationLogEntry.deleteSection(section);
        return this.contentElement.removeChild(section);
    },

    _insertSectionAtBeginning: function(sectionToInsert, args) {
        if(!sectionToInsert) { return false }

        sectionToInsert.setAttribute('contenteditable', true);

        if(sectionToInsert.onMarkupCleaningFinshed) {
            sectionToInsert.onMarkupCleaningFinshed(sectionToInsert);
        }

        if(args.actor) {
            sectionToInsert.classList.add('focused-by-api-actor' + args.actor.id + '-fbaaend');
        }

        this.modificationLogEntry.insertSection(sectionToInsert);

        if(this.contentElement.children[0]) {
            return this.contentElement.insertBefore(sectionToInsert, this.contentElement.children[0]);
        } else {
            return this.contentElement.appendChild(sectionToInsert);
        }
    },

    _insertSectionAfter: function(predecessorSection, sectionToInsert, args) {
        if(!predecessorSection || !sectionToInsert) { return false }
        sectionToInsert.setAttribute('contenteditable', true);

        if(sectionToInsert.onMarkupCleaningFinshed) {
            sectionToInsert.onMarkupCleaningFinshed(sectionToInsert);
        }

        if(args.actor) {
            sectionToInsert.classList.add('focused-by-api-actor'+ args.actor.id + '-fbaaend');
        }

        this.modificationLogEntry.insertSection(sectionToInsert);
        return this.contentElement.insertBefore(sectionToInsert, predecessorSection.nextSibling);   // if predecessorSection.nextSibling is null, the newNode is inserted at the end of the list of child nodes.
    },

    _insertSectionBefore: function(predecessorSection, sectionToInsert, args) {
        if(!predecessorSection || !sectionToInsert) { return false }
        sectionToInsert.setAttribute('contenteditable', true);

        if(sectionToInsert.onMarkupCleaningFinshed) {
            sectionToInsert.onMarkupCleaningFinshed(sectionToInsert);
        }

        if(args.actor) {
            sectionToInsert.classList.add('focused-by-api-actor'+ args.actor.id + '-fbaaend');
        }

        this.modificationLogEntry.insertSection(sectionToInsert);
        return this.contentElement.insertBefore(sectionToInsert, predecessorSection);   // if predecessorSection.nextSibling is null, the newNode is inserted at the end of the list of child nodes.
    },

    _isSameSectionType: function(section1, section2) {
        if(!section1 || !section2) {
            return false;
        }

        var sameClasses = section1.classList.toString().replace(/focused-by-api-actor.*-fbaaend/g, '').replace(/focused/g, '').replace(/\s/g, '') === section2.classList.toString().replace(/focused-by-api-actor.*-fbaaend/g, '').replace(/focused/g, '').replace(/\s/g, ''),
          sameTags = section1.tagName === section2.tagName;

        return sameTags && sameClasses;
    },

    _getSectionAttributeSigniture: function(section) {
        return JSON.stringify(Object.values(section.attributes)
            .filter(attr => attr.name !== 'class' && attr.name !== 'contenteditable')
            .map(attr => ({ [attr.name]: attr.value })))
    },

    _areEqualSections: function(section1, section2) {
        return this._isSameSectionType(section1, section2) &&
            section1.innerHTML.length === section2.innerHTML.length &&
            this._getSectionAttributeSigniture(section1) === this._getSectionAttributeSigniture(section2) &&
            section1.innerHTML === section2.innerHTML
    },

    _replaceSections: function(oldSection, newSection, args) {
        newSection.setAttribute('contenteditable', true);

        oldSection.summarizedContentLength = undefined;
        newSection.summarizedContentLength = undefined;

        if(this._isSameSectionType(oldSection, newSection)) {
            utils.copyEventListenersRecursively(oldSection, newSection);
        }

        if(newSection.onMarkupCleaningFinshed) {
            newSection.onMarkupCleaningFinshed(newSection);
        }

        if(!this._areEqualSections(newSection, oldSection) || (newSection && newSection.childNodes.length === 0)) {
            this.modificationLogEntry.replaceSection(oldSection, newSection);

            if(args.actor) {
                newSection.classList.add('focused-by-api-actor'+ args.actor.id + '-fbaaend');

                const contentLengthTillSectionStart = args.caret.getContentLengthTillSection(oldSection);
                const diff = diffEngine
                    .diff_main(args.caret._getContentLengthIncrementMaskedText(oldSection), args.caret._getContentLengthIncrementMaskedText(newSection))
                    .flatMap(a => a[1].split('').map(ia => a[0]));

                if(args.caret.rangeStart) {
                    const selectionStartOffsetWithinSection = args.caret.rangeStart - contentLengthTillSectionStart;
                    this.modificationLogEntry.insertedBeforeSelectionRangeStart += diff
                        .slice(0, selectionStartOffsetWithinSection)
                        .reduce((acc, val) => acc + val, 0);
                }

                if(args.caret.rangeEnd && args.caret.rangeEnd !== args.caret.rangeStart) {
                    const selectionStartOffsetWithinSection = args.caret.rangeEnd - contentLengthTillSectionStart;
                    this.modificationLogEntry.insertedBeforeSelectionRangeEnd += diff
                        .slice(0, selectionStartOffsetWithinSection)
                        .reduce((acc, val) => acc + val, 0);
                } else if(args.caret.rangeEnd === args.caret.rangeStart) {
                    this.modificationLogEntry.insertedBeforeSelectionRangeEnd = this.modificationLogEntry.insertedBeforeSelectionRangeStart;
                }
            }

            this.contentElement.replaceChild(newSection, oldSection);

            if(oldSection === this.focusedSection) {
                this.modificationLogEntry.focusedSectionHasBeenModified = true;
                this.modificationLogEntry.focusedSectionReplacement = newSection;
            }

            return newSection;
        } else if(oldSection.originalHTML !== newSection.originalHTML) {
            // we end up in this branch when we simply type text into a section.
            // in this case the actual DOM is already on the actual state, only
            // the originalHTML attribute must be updated.
            this.modificationLogEntry.replaceSection(oldSection, newSection);

            oldSection.originalHTML = newSection.originalHTML;

            Object.keys(this.modificationLogEntry.modLogFlags).forEach(function(flag) {
                oldSection['originalHTMLContains' + flag] = newSection['originalHTMLContains' + flag];
            });

            if(oldSection === this.focusedSection) {
                this.modificationLogEntry.focusedSectionHasBeenModified = true;
                this.modificationLogEntry.focusedSectionDOMWasNotModified = true;
                this.modificationLogEntry.focusedSectionReplacement = newSection;
            }

            oldSection.wordCount = undefined;
            return oldSection;
        }

        this.modificationLogEntry.retainSection(oldSection);
        return oldSection;
    }
}

module.exports = Documentupdater;


/***/ }),

/***/ "../structured-text-editor/lib/documentupdater/modification_log.js":
/*!*************************************************************************!*\
  !*** ../structured-text-editor/lib/documentupdater/modification_log.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var diffMatchPatch = __webpack_require__(/*! diff_match_patch */ "../structured-text-editor/node_modules/diff_match_patch/lib/diff_match_patch.js"),
    diffEngine = new diffMatchPatch.diff_match_patch;

var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;

function ModificationLogEntry() {
    this.log = [];
}

ModificationLogEntry.prototype = {

    setFlagsFor: function(section) {
        var self = this,
            modLogFlags = this.modLogFlags;

        if(!modLogFlags) { return; }

        Object.keys(modLogFlags).forEach(function(flag) {
            if(self['mightInclude' + flag + 'Updates']) {
                return;
            }

            if(section['originalHTMLContains' + flag]) {
                self['mightInclude' + flag + 'Updates'] = true;
                return;
            }

            self['mightInclude' + flag + 'Updates'] = modLogFlags[flag].some(function(selector) {
                return section.matches(selector) || section.querySelector(selector)
            });
        });
    },

    toChangeset: function(Changeset) {
        var cs = Changeset.create();
        var wasLastOpTypeRetain = false, lastOptTypeLength = 0;

        this.log.forEach(function(entry) {
            if(entry.type === 'retain') {
                wasLastOpTypeRetain = true;
                lastOptTypeLength += entry.sectionHTML.length;
            } else if (wasLastOpTypeRetain) {
                cs.retain(lastOptTypeLength);
                wasLastOpTypeRetain = false;
                lastOptTypeLength = 0;
            }

            if (entry.type === 'delete') {
                cs.delete(entry.sectionHTML);
            } else if (entry.type === 'insert') {
                cs.insert(entry.sectionHTML);
            } else if (entry.type === 'replace') {
                var diff = diffEngine.diff_main(entry.oldSectionHTML, entry.newSectionHTML);

                diff.forEach(function(d) {
                    if (DIFF_DELETE == d[0]) {
                        cs.delete(d[1])
                    }

                    if (DIFF_INSERT == d[0]) {
                        cs.insert(d[1]);
                    }

                    if(DIFF_EQUAL == d[0]) {
                      cs.retain(d[1].length);
                    }
                });
            }
        });

        if (wasLastOpTypeRetain) {
            cs.retain(lastOptTypeLength);
        }

        return cs.end();
    },

    afterState: function() {
        var result = '';
        this.log.forEach(function(log) {
            if(log.type === 'retain' || log.type === 'insert') {
                result += log.sectionHTML;
            } else if(log.type === 'replace') {
                result += log.newSectionHTML;
            }
        });

        return result;
    },

    beforeState: function() {
        var result = '';
        this.log.forEach(function(log) {
            if(log.type === 'retain' || log.type === 'delete') {
                result += log.sectionHTML;
            } else if(log.type === 'replace') {
                result += log.oldSectionHTML;
            }
        });

        return result;
    },

    retainSection: function(section) {
        this.log.push({type: 'retain', sectionHTML: section.originalHTML});
    },

    deleteSection: function(section) {
        this.log.push({type: 'delete', sectionHTML: section.originalHTML});
        this.setFlagsFor(section);
    },

    replaceSection: function(oldSec, newSec) {
        this.log.push({type: 'replace', oldSectionHTML: oldSec.originalHTML, newSectionHTML: newSec.originalHTML});
        this.setFlagsFor(newSec);
        this.setFlagsFor(oldSec);
    },

    insertSection: function(section) {
        this.log.push({type: 'insert', sectionHTML: section.originalHTML})
        this.setFlagsFor(section);
    },

    deleteSectionAt: function(index, section) {
        var oldLog;

        if(this.log[index] && this.log[index].type !== 'insert') {
            oldLog = this.log[index];
            this.log[index] = { type: 'delete', sectionHTML: this.log[index].oldSectionHTML || this.log[index].sectionHTML };
        } else if(this.log[index] && this.log[index].type === 'insert') {
            oldLog = this.log.splice(index, 1)[0]; //remove array element with index "index"
        }

        this.setFlagsFor(section);

        return oldLog;
    },

    retainAllSectionsBefore: function(section) {
        if(!section) return;
        var tmpSec = section.parentElement.children[0];
        while(tmpSec !== section) {
            this.retainSection(tmpSec);
            tmpSec = tmpSec.nextSibling;
        }
    },

    retainAllSectionsAfter: function(section) {
        if(!section) return;
        var tmpSec = section.nextSibling;
        while(tmpSec) {
            this.retainSection(tmpSec);
            tmpSec = tmpSec.nextSibling;
        }
    },

    includesHeadingUpdate: function() {
        return !!this.includesHeadingUpdates;
    }
};

module.exports = ModificationLogEntry;


/***/ }),

/***/ "../structured-text-editor/lib/generatorlookahead/index.js":
/*!*****************************************************************!*\
  !*** ../structured-text-editor/lib/generatorlookahead/index.js ***!
  \*****************************************************************/
/***/ ((module) => {

module.exports = function (stream) {
    var nextValue = stream.next();

    return {
        next: function() {
            const thisRound = nextValue;
            nextValue = stream.next();
            return thisRound;
        },
        lookahead: function() {
            return nextValue
        }
    };
}

/***/ }),

/***/ "../structured-text-editor/lib/html_razor/html_razor.js":
/*!**************************************************************!*\
  !*** ../structured-text-editor/lib/html_razor/html_razor.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var StateMachine = __webpack_require__(/*! ./state_machine.js */ "../structured-text-editor/lib/html_razor/state_machine.js");
var utils = __webpack_require__(/*! ../pixelschubser/utils */ "../structured-text-editor/lib/pixelschubser/utils.js");
var namedEncodings = {quot: 34, amp: 38, lt: 60, gt: 62, nbsp: 160, copy: 169, reg: 174, deg: 176, frasl: 47, trade: 8482, euro: 8364, Agrave: 192, Aacute: 193, Acirc: 194, Atilde: 195, Auml: 196, Aring: 197, AElig: 198, Ccedil: 199, Egrave: 200, Eacute: 201, Ecirc: 202, Euml: 203, Igrave: 204, Iacute: 205, Icirc: 206, Iuml: 207, ETH: 208, Ntilde: 209, Ograve: 210, Oacute: 211, Ocirc: 212, Otilde: 213, Ouml: 214, times: 215, Oslash: 216, Ugrave: 217, Uacute: 218, Ucirc: 219, Uuml: 220, Yacute: 221, THORN: 222, szlig: 223, agrave: 224, aacute: 225, acirc: 226, atilde: 227, auml: 228, aring: 229, aelig: 230, ccedil: 231, egrave: 232, eacute: 233, ecirc: 234, euml: 235, igrave: 236, iacute: 237, icirc: 238, iuml: 239, eth: 240, ntilde: 241, ograve: 242, oacute: 243, ocirc: 244, otilde: 245, ouml: 246, divide: 247, oslash: 248, ugrave: 249, uacute: 250, ucirc: 251, uuml: 252, yacute: 253, thorn: 254, yuml: 255, lsquo: 8216, rsquo: 8217, sbquo: 8218, ldquo: 8220, rdquo: 8221, bdquo: 8222, dagger: 8224, Dagger: 8225, permil: 8240, lsaquo: 8249, rsaquo: 8250, spades: 9824, clubs: 9827, hearts: 9829, diams: 9830, oline: 8254, larr: 8592, uarr: 8593, rarr: 8594, darr: 8595, hellip: 133, ndash: 150, mdash: 151, iexcl: 161, cent: 162, pound: 163, curren: 164, yen: 165, brvbar: 166, brkbar: 166, sect: 167, uml: 168, die: 168, ordf: 170, laquo: 171, not: 172, shy: 173, macr: 175, hibar: 175, plusmn: 177, sup2: 178, sup3: 179, acute: 180, micro: 181, para: 182, middot: 183, cedil: 184, sup1: 185, ordm: 186, raquo: 187, frac14: 188, frac12: 189, frac34: 190, iquest: 191, Alpha: 913, alpha: 945, Beta: 914, beta: 946, Gamma: 915, gamma: 947, Delta: 916, delta: 948, Epsilon: 917, epsilon: 949, Zeta: 918, zeta: 950, Eta: 919, eta: 951, Theta: 920, theta: 952, Iota: 921, iota: 953, Kappa: 922, kappa: 954, Lambda: 923, lambda: 955, Mu: 924, mu: 956, Nu: 925, nu: 957, Xi: 926, xi: 958, Omicron: 927, omicron: 959, Pi: 928, pi: 960, Rho: 929, rho: 961, Sigma: 931, sigma: 963, Tau: 932, tau: 964, Upsilon: 933, upsilon: 965, Phi: 934, phi: 966, Chi: 935, chi: 967, Psi: 936, psi: 968, Omega: 937, omega: 969};

function HTMLRazor(tagTransformations, rules) {
    this.tagTransformations = tagTransformations  || {};
    this.rules = rules;
    this.ruleNameByElementCache = {};
    this.ruleNameByTokenCache = {};
    this.tagTransformationByNodeCache = {};
    this.stateMachine = new StateMachine();
    this.temproaryPruneProtectedWhitespace = '\u2588';
}

HTMLRazor.prototype = {

    getRuleNamesByTag: function(tagName) {
        this.ruleEntries = this.ruleEntries || Object.entries(this.rules);

        return this.ruleEntries.filter(function(rule) {
            return rule[1].tagName === tagName.toLowerCase();
        }).map(function(rule) {
            return rule[0];
        });
    },

    doesElementMatchRule: function(element, rule) {
        if(!element || !rule) return false;
        if(rule.tagName !== element.nodeName.toLowerCase()) return false;
        if(rule.className && !element.classList.contains(rule.className)) return false;

        return true;
    },

    doesElementMatchOneRule: function(element, ruleNames) {
        for(let i=0; i<ruleNames.length; i++) {
            if(this.doesElementMatchRule(element, this.rules[ruleNames[i]])) {
                return true;
            }
        }
        return false;
    },

    lookupRuleNameCacheFor: function(t) {
        if(t.nodeName && this.ruleNameByElementCache[t.nodeName] && this.ruleNameByElementCache[t.nodeName][t.className]) {
            return this.ruleNameByElementCache[t.nodeName][t.className];
        } else if(this.ruleNameByTokenCache[t.value] && this.ruleNameByTokenCache[t.value]){
            return this.ruleNameByTokenCache[t.value][t.classNames];
        }
    },

    cacheRuleNameFor: function(t, result) {

        if(!result) {
          result = -1;
        }

        if(t.nodeName) {
            if(!this.ruleNameByElementCache[t.nodeName]) {
                this.ruleNameByElementCache[t.nodeName] = {}
            }

            this.ruleNameByElementCache[t.nodeName][t.className] = result;
        } else {
            if(!this.ruleNameByTokenCache[t.value]) {
                this.ruleNameByTokenCache[t.value] = {}
            }

            this.ruleNameByTokenCache[t.value][t.classNames] = result;
        }
    },

    getRuleNameByElement: function(t) {
        var rules = this.rules,
            result, tokenClassNames, resultCandidates, tmpResult;

        if(!t) return;
        if(t.nodeType === Node.TEXT_NODE) return '#text';

        result = this.lookupRuleNameCacheFor(t);
        if(result === -1) return;
        if(result) return result;

        tokenClassNames = (t && t.attributes && t.attributes['classNames']) || t.classList || [];
        resultCandidates = this.getRuleNamesByTag(t.value || t.nodeName);

        if(tokenClassNames.length !== 0) {
            tmpResult = resultCandidates.find(function(rc) {
                if(!rules[rc].className) return false;

                for(var i=0; i<tokenClassNames.length; i++) {
                    if(rules[rc].className === tokenClassNames[i]) return true;
                }
            });
        }

        result = tmpResult || resultCandidates.find(function(rc) {
            return !rules[rc].className;
        });

        this.cacheRuleNameFor(t, result);

        return result;
    },

    getRuleByElement: function(element) {
        return this.rules[this.getRuleNameByElement(element)];
    },

    isTokenAllowedToBeRootElement: function(t) {
        var rule = this.rules && this.rules[this.getRuleNameByElement(t)];
        return rule && rule.allowedToBeRoot;
    },

    isTokenAllowedToContainItself: function(t) {
      var ruleName = this.getRuleNameByElement(t),
          rule = this.rules && this.rules[ruleName];

        if(!rule.allowedChildren) return false;
        return rule.allowedChildren.indexOf(ruleName) !== -1;
    },

    rootElementsShouldNotBreakOutFrom: function(parentNode) {
        var rule = this.getRuleByElement(parentNode);
        if(!rule) { return false }

        return !!rule.doNotBreakOutRootElements;
    },

    cacheTagTransformationFor: function(tokenPathInParsedTree, result) {
        result = result || -1;
        this.tagTransformationByNodeCache[tokenPathInParsedTree] = result;
        return result == -1 ? undefined : result;
    },

    loockupTagTransformationCacheFor: function(tokenPathInParsedTree, classList) {
        if(classList && classList.length !== 0) {
            return;
        }

        if(this.tagTransformationByNodeCache[tokenPathInParsedTree] === -1) {
            return -1;
        }

        if(this.tagTransformationByNodeCache[tokenPathInParsedTree]) {
            return this.tagTransformationByNodeCache[tokenPathInParsedTree];
        }
    },

    tagTransformationByNode: function(node) {
        var self = this,
            classList = node.classList,
            oriNode = node,
            tokenPathInParsedTree = '',
            matchesByPath = [],
            keys = Object.keys(this.tagTransformations),
            result,
            tk, split;

        if(!oriNode.classList) { oriNode.classList = [] }

        while(node) {
            if(node.tagName) {
                tokenPathInParsedTree = '/' + node.tagName.toLowerCase() + tokenPathInParsedTree;
            } else if(node.nodeType === Node.TEXT_NODE){
                tokenPathInParsedTree = '/#text' + tokenPathInParsedTree;
            }

            node = node.parentNode;
        }

        result = this.loockupTagTransformationCacheFor(tokenPathInParsedTree, classList)

        if(result === -1) {return}
        if(result) {return result}

        for(var i=0; i<keys.length; i++) {
            tk = keys[i];
            split = tk.split('.');

            if(split[0] === tokenPathInParsedTree) {
                if(!split[1]) {
                    matchesByPath.push(tk)
                } else if(oriNode.classList.contains(split[1])) {
                    return this.tagTransformations[tk];
                }
            }
        }

        return self.cacheTagTransformationFor(
                    tokenPathInParsedTree,
                    matchesByPath[0] ? this.tagTransformations[matchesByPath[0]] : -1);
    },

    isNodeAllowedToBeRootElement: function(node) {
        var rule = this.rules[this.getRuleNameByElement(node)];
        return rule && rule.allowedToBeRoot;
    },

    isNodeForbiddenByAllowedChildrenDefinition: function(rootElement, childNodeRuleName, parentElementRule) {
        parentElementRule = parentElementRule || this.getRuleByElement(rootElement);
        if(!childNodeRuleName) return false;
        if(!parentElementRule.allowedChildren) return false;

        return parentElementRule.allowedChildren.indexOf(childNodeRuleName) === -1
    },

    isNodeForbiddenByCardinalityDefinition: function(cardinalities, childNodeRuleName, parentElementRule) {
        var maxAllowed;

        cardinalities[childNodeRuleName] = cardinalities[childNodeRuleName] || 0;

        maxAllowed = parentElementRule &&
                     parentElementRule.childrenCardinality &&
                     parentElementRule.childrenCardinality[childNodeRuleName] &&
                     parentElementRule.childrenCardinality[childNodeRuleName].max;

        if(!maxAllowed) return false;

        return maxAllowed <= cardinalities[childNodeRuleName];
    },

    getRootNodeOf: function(node)  {
        var root = node;

        while(root && root.parentNode) {
            root = root.parentNode;
        }

        return root;
    },

    createDOMElementFromToken: function(token) {
        var self = this, element = document.createElement(token.value);
        Object.keys(token.attributes).forEach(function(key) {
            if(key === 'classNames') {
                element.setAttribute('class', token.attributes[key].join(' '));
            } else {
                element.setAttribute(key, self.strip(token.attributes[key]));
            }
        });

        return element;
    },

    cloneDOMElementAndChangeTagName: function(node, tagName) {
        var result = document.createElement(tagName);

        result.attributes = node.attributes;

        for(var i=0; i<node.attributes.length; i++) {
            result.setAttribute(node.attributes[i].name, node.attributes[i].value)
        }

        result.innerHTML = node.innerHTML;

        return result;
    },

    strip: function(html) {
        if(!html.replace) { return html }

        return html.replace(/&#?(\w+);/g, function(match, dec) {
            if(isNaN(dec) && namedEncodings[dec]) {
                dec = namedEncodings[dec];
            }

            return String.fromCharCode(dec);
        });
    },

    tokenizeHTML: function*(html) {
        var token = null;
        this.stateMachine.resetStateMachine();
        for(let i=0; i<=html.length; i++) {
            token = this.stateMachine.process(html[i] || 'EOF');
            if(token) { yield token; token = null };
        }
    },

    buildTrees: function*(html) {
        var self = this,
            tokenStream = this.tokenizeHTML(html),
            token = null,
            newChild = null,
            currentNodeInTree = null,
            tmpHandlerResult = null;

        var tokenHandler =  {
            OPEN_TAG: function(token) {
                var result;

                if(['br', 'img', 'input'].indexOf(token.value.toLowerCase()) !== -1) {
                    return tokenHandler['EMPTY_TAG'](token);
                }

                newChild = self.createDOMElementFromToken(token);

                if(currentNodeInTree &&
                   self.isTokenAllowedToBeRootElement(token) &&
                   !self.isTokenAllowedToContainItself(token) &&
                   !self.rootElementsShouldNotBreakOutFrom(currentNodeInTree)) {
                    result = self.getRootNodeOf(currentNodeInTree);
                    currentNodeInTree = newChild;
                    return result;
                } else if(currentNodeInTree) {
                    currentNodeInTree.appendChild(newChild);
                    currentNodeInTree = newChild;
                } else {
                    currentNodeInTree = newChild;
                }
            },

            CLOSE_TAG: function(token) {
                if(!currentNodeInTree) return;

                var tmpCurrentNodeInTree;

                if(currentNodeInTree.parentNode) {
                    currentNodeInTree = currentNodeInTree.parentNode;
                } else {
                    tmpCurrentNodeInTree = currentNodeInTree;
                    currentNodeInTree = null;

                    if(tmpCurrentNodeInTree.tagName.toLowerCase() !== token.value && token.value !== '') {
                        tmpCurrentNodeInTree = self.cloneDOMElementAndChangeTagName(tmpCurrentNodeInTree, token.value);
                    }

                    return tmpCurrentNodeInTree;
                }
            },

            EMPTY_TAG: function(token) {
                newChild = self.createDOMElementFromToken(token);

                if(currentNodeInTree) {
                    currentNodeInTree.appendChild(newChild);
                } else {
                    return newChild;
                }
            },

            TEXT: function(token) {
                newChild = document.createTextNode(self.strip(token.value));

                if(!currentNodeInTree) {
                    if(token.value.trim().length === 0) return;
                    currentNodeInTree = document.createElement('p');
                }
                currentNodeInTree.appendChild(newChild);
            }
        }

        while(token = tokenStream.next().value) {
            try {
                tmpHandlerResult = tokenHandler[token.type](token);
            } catch(ex) {
                token = tokenStream.next().value;
                tmpHandlerResult = tokenHandler[token.type](token);
            }

            if(tmpHandlerResult) yield tmpHandlerResult;
        }

        if(currentNodeInTree) {
            yield self.getRootNodeOf(currentNodeInTree);
        }
    },

    transformTreeWithReruns: function(rootElement, transRule, className, modLog) {
        var self = this,
            res = this.transformTree(rootElement, transRule, className, modLog);

        if(Array.isArray(res)) {
            res = res.map(function(r) {
                return self.transformTreeWithReruns(r, undefined, undefined, modLog);
            });

            res = res.reduce((acc, val) => acc.concat(val), []);
        }

        return res;
    },

    // returns an array of DOM elements which should replace the passed element
    transformTree: function(rootElement, transRule, className, modLog) {
        var self = this,
            transRuleWithClass = this.tagTransformationByNode(rootElement),
            transRuleAr, toRuleCondidates, newContent,
            normalizedInnerText, praefixToBeReplaced, praefixMatch, directiveParams,
            toTransformation, tmpDirectiveParams;

        modLog = modLog || {};
        modLog.deletedCharsByMarkupTransformations = modLog.deletedCharsByMarkupTransformations || 0;

        if(!Array.isArray(transRuleWithClass)) {
            transRuleAr = transRuleWithClass ? transRuleWithClass.split('.') : [];
            transRule = transRule || transRuleAr[0];
            className = className || transRuleAr[1];
        } else {
            transRule = transRule || transRuleWithClass;
        }

        if (transRule === '#content') {
            return Array.from(rootElement.childNodes)
        } else if (transRule === '#no-content') {
            rootElement.innerHTML = '';
            return rootElement;
        } else if (transRule === '#text-content') {
            rootElement.innerHTML = rootElement.innerText.replace(/</g, '&lt;').replace(/>/g, '&gt;');
            return rootElement;
        } else if (transRule && rootElement.nodeType === Node.TEXT_NODE) {
            //text node in the left part of the rule is not supported
        } else if(Array.isArray(transRule)) {
            for(let i=0; i<transRule.length; i++) {
                normalizedInnerText = rootElement.innerText.replace(new RegExp(String.fromCharCode(160),"g"), ' ');
                normalizedInnerText = normalizedInnerText.replace(this.temproaryPruneProtectedWhitespace, ' ');
                praefixMatch = normalizedInnerText.match(new RegExp('^' + transRule[i].praefix + '(\\((.*?)\\))?\\s'));

                if(praefixMatch) {
                    praefixToBeReplaced = praefixMatch[0];
                    if(praefixMatch[2]) {
                        directiveParams = praefixMatch[2].split(',').map(function(e) { return e.trim() });
                    } else {
                        directiveParams = [];
                    }

                    toTransformation = transRule[i].to.split(/\(|\)/)[0];
                    tmpDirectiveParams = transRule[i].to.split(/\(|\)/)[1];

                    if(tmpDirectiveParams) {
                        tmpDirectiveParams = tmpDirectiveParams.split(',').map(function(e) { return e.trim() });
                        directiveParams = directiveParams.concat(tmpDirectiveParams);
                    }

                    toRuleCondidates = this.getRuleNamesByTag(toTransformation)
                                           .map(function(ruleName) { return self.rules[ruleName] })
                                           .filter(function(rule) { return rule.allowedToBeRoot && rule.buildEmptyElement });

                    newContent = rootElement.innerHTML.replace('&nbsp;', ' ').replace(this.temproaryPruneProtectedWhitespace, ' ').replace(praefixToBeReplaced, '');
                    modLog.deletedCharsByMarkupTransformations += praefixToBeReplaced.length;
                    modLog.changeSectionType = true;

                    if(toRuleCondidates.length === 1) {
                        rootElement = toRuleCondidates[0].buildEmptyElement(newContent, directiveParams, toRuleCondidates[0]);
                    } else {
                        rootElement = this.cloneDOMElementAndChangeTagName(rootElement, toTransformation);
                        rootElement.innerHTML = newContent;
                    }
                }
            }
        } else if(transRule) {
            rootElement = this.cloneDOMElementAndChangeTagName(rootElement, transRule);
            if(className) rootElement.classList.add(className)
        }

        if(rootElement.childNodes) {
            for(let i=0; i<rootElement.childNodes.length; i++) {

                transRuleWithClass = this.tagTransformationByNode(rootElement.childNodes[i]);
                transRuleAr = transRuleWithClass ? transRuleWithClass.split('.') : [];
                transRule = transRuleAr[0];
                className = transRuleAr[1];

                if(transRule === '-') {
                    let res = [rootElement, rootElement.removeChild(rootElement.childNodes[i])]

                    if(rootElement.childNodes[i]) {
                        let newEl = document.createElement(rootElement.tagName);
                        while(rootElement.childNodes[i]) {
                            newEl.appendChild(rootElement.removeChild(rootElement.childNodes[i]))
                        }

                        res.push(newEl);
                    }

                    if(rootElement.childNodes.length === 0) {
                        res.shift();
                    }

                    return res;
                } else if(transRule && transRule[0] === '=')  {
                    let res = [rootElement, rootElement.removeChild(rootElement.childNodes[i])];
                    let newElementTagName = transRule.substring(1, transRule.length);

                    let newEl = document.createElement(newElementTagName === '' ? rootElement.tagName : newElementTagName);
                    utils.copyNodeAttributes(rootElement, newEl, ['class']);

                    while(rootElement.childNodes[i]) {
                        newEl.appendChild(rootElement.removeChild(rootElement.childNodes[i]))
                    }

                    res.push(newEl);
                    return res;
                } else {
                    let res = this.transformTree(rootElement.childNodes[i], transRule, className, modLog);
                    if(res instanceof Array) {
                        rootElement.childNodes[i].replaceWith(...res);
                        i--;
                    } else if(res) {
                        rootElement.childNodes[i].replaceWith(res);
                    }
                }
            }
        }

        return rootElement;
    },

    cleanupClassAttribte: function(node) {
        var rule = this.getRuleByElement(node),
            classNamesToRemove = [];

        if(rule && rule.allowedClassNames) {
            for(let i=0; i<node.classList.length; i++) {
                if(rule.allowedClassNames.indexOf(node.classList[i]) === -1) {
                    classNamesToRemove.push(node.classList[i]);
                }
            }
            classNamesToRemove.forEach(function(cn) {node.classList.remove(cn);})
        } else if (rule && node.attributes && node.attributes.class) {
            node.removeAttribute('class');
        }
    },

    cleanupNodeAttributes: function(node) {
        // first check whether the cleaning process will remove the class attribute
        var rule = this.getRuleByElement(node),
            attributesToRemove = [];

        if(!rule) return;

        if(node.attributes) {
            for(let i=0; i<node.attributes.length; i++) {
                if(!rule.allowedAttributes ||
                   rule.allowedAttributes.indexOf(node.attributes[i].name) === -1 ||
                  node.attributes[i].value === ''
                  ) {
                    attributesToRemove.push(node.attributes[i].name);
                }
            }
        }

        attributesToRemove.forEach(function(attr) {
            node.removeAttribute(attr);
        });
    },

    buildEmptyElementByRuleName: function(ruleName) {
        var el, rule = this.rules[ruleName];

        if(rule.buildEmptyElement) {
            return rule.buildEmptyElement(null, null, rule);
        }

        el = document.createElement(rule.tagName);
        if(rule.className) {
            el.classList.add(rule.className);
        }
        return el;
    },

    cleanupTree: function(rootElement, modificationLogEntry, previousDOMTree, nextDOMTree) {
        this.cleanupClassAttribte(rootElement);
        this.cleanupNodeAttributes(rootElement);

        var self = this,
            ruleName = this.getRuleNameByElement(rootElement),
            rule = this.rules[ruleName],
            childNodeRuleName,
            cardinalityMap = {},
            result = {},
            deletedCharsByMarkupTransformationsCalulationHelper,
            cTResult;

        if(!ruleName || (rule && rule.deleteIfEmpty && rootElement.innerText.length === 0)) {
            return { removeThisNode: true };
        }

        if(rule && rule.buildAttributes) {
            rule.buildAttributes.forEach(function(ba) {
                if(!rootElement.hasAttribute(ba.name)) {
                    rootElement.setAttribute(ba.name, ba.build())
                }
            })
        }

        for(let i=0; i<rootElement.childNodes.length; i++) {
            childNodeRuleName = this.getRuleNameByElement(rootElement.childNodes[i]);

            if(this.isNodeForbiddenByAllowedChildrenDefinition(rootElement, childNodeRuleName, rule) ||
               this.isNodeForbiddenByCardinalityDefinition(cardinalityMap, childNodeRuleName, rule)) {
                rootElement.removeChild(rootElement.childNodes[i--]);
            } else {
                cardinalityMap[childNodeRuleName]++;

                if(rule.pruneSpaces && rootElement.childNodes[i].nodeType == Node.TEXT_NODE) {
                    deletedCharsByMarkupTransformationsCalulationHelper = rootElement.childNodes[i].nodeValue.length;
                    rootElement.childNodes[i].nodeValue = rootElement.childNodes[i].nodeValue.replace(/(\s|\u00A0)+/g, ' ').replace(/\s$/, '\u00A0');
                    modificationLogEntry.deletedCharsByMarkupTransformations += (deletedCharsByMarkupTransformationsCalulationHelper - rootElement.childNodes[i].nodeValue.length);
                }

                if(rootElement.childNodes[i].nodeType == Node.TEXT_NODE) {
                    rootElement.childNodes[i].nodeValue = rootElement.childNodes[i].nodeValue.replace(this.temproaryPruneProtectedWhitespace, '\u00A0');
                }

                cTResult = this.cleanupTree(rootElement.childNodes[i], modificationLogEntry);

                if(cTResult.removeThisNode) {
                    rootElement.removeChild(rootElement.childNodes[i--]);
                }

                if(cTResult.insertNodeAfter) {
                    rootElement.insertBefore(cTResult.insertNodeAfter, rootElement.childNodes[i].nextSibling);
                }

                if(cTResult.insertNodeBefore) {
                    rootElement.insertBefore(cTResult.insertNodeBefore, rootElement.childNodes[i++]);
                }
            }
        }

        if(rule && rule.allowedSuccessors && rule.allowedSuccessors.length !== 0 && !this.doesElementMatchOneRule(nextDOMTree || rootElement.nextSibling, rule.allowedSuccessors)) {
            result.insertNodeAfter = this.buildEmptyElementByRuleName(rule.allowedSuccessors[0]);
        }

        if(rule && rule.allowedPredecessors && rule.allowedPredecessors.length !== 0 && !this.doesElementMatchOneRule(previousDOMTree || rootElement.previousSibling, rule.allowedPredecessors)) {
            result.insertNodeBefore = this.buildEmptyElementByRuleName(rule.allowedPredecessors[0]);
        }

        return result;
    },

    HTMLToTransformedTreeStream: function*(html, modificationLogEntry) {
        var DOMTreeStream = this.buildTrees(html),
            DOMTree = DOMTreeStream.next().value;

        while(DOMTree) {
            DOMTree = this.transformTreeWithReruns(DOMTree, undefined, undefined, modificationLogEntry);

            if(Array.isArray(DOMTree)) {
                for(let i=0; i<DOMTree.length; i++) {
                    yield DOMTree[i];
                }
            } else {
                yield DOMTree;
            }

            DOMTree = DOMTreeStream.next().value;
        }
    },

    cleanupHTML: function*(html, modificationLogEntry)  {
        if(!html || html === '') { html = '<p></p>' }

        modificationLogEntry = modificationLogEntry || {}
        modificationLogEntry.deletedCharsByMarkupTransformations = 0;

        var DOMTreeStream = this.HTMLToTransformedTreeStream(html, modificationLogEntry),
            cTResult,
            previousDOMTree,
            DOMTree = DOMTreeStream.next().value,
            nextDOMTree = DOMTreeStream.next().value;

        while(DOMTree) {
            if(this.isNodeAllowedToBeRootElement(DOMTree)) {
                cTResult = this.cleanupTree(DOMTree, modificationLogEntry, previousDOMTree, nextDOMTree);
                if(cTResult.insertNodeBefore) {
                    yield this.memorizedNode(cTResult.insertNodeBefore, modificationLogEntry.modLogFlags);
                }

                if(!cTResult.removeThisNode) {
                    yield this.memorizedNode(DOMTree, modificationLogEntry.modLogFlags);
                }

                if(cTResult.insertNodeAfter) {
                    yield this.memorizedNode(cTResult.insertNodeAfter, modificationLogEntry.modLogFlags);
                }
            }

            previousDOMTree = DOMTree;
            DOMTree = nextDOMTree;
            nextDOMTree = DOMTreeStream.next().value;
        }
    },

    memorizedNode: function(node, modLogFlags) {

        modLogFlags = modLogFlags || {};
        node.originalHTML = node.outerHTML;

        Object.keys(modLogFlags).forEach(function(flag) {
            node['originalHTMLContains' + flag] = modLogFlags[flag].some(function(selector) {
                return node.matches(selector) || node.querySelector(selector)
            });
        });

        return node;
    },

    cleanupHTMLAndAttachEventHandlers: function*(html, modificationLogEntry) {
          var DOMTreeStream = this.cleanupHTML(html, modificationLogEntry),
            DOMTree = DOMTreeStream.next().value,
            dummyElement, rule;

        while(DOMTree) {
            rule = this.getRuleByElement(DOMTree);
            if(rule.buildEmptyElement) {
                dummyElement = rule.buildEmptyElement(null, null, rule);
                utils.copyEventListenersRecursively(dummyElement, DOMTree);
            }

            yield DOMTree;
            DOMTree = DOMTreeStream.next().value;
        }
    }
}

module.exports = HTMLRazor;


/***/ }),

/***/ "../structured-text-editor/lib/html_razor/state_machine.js":
/*!*****************************************************************!*\
  !*** ../structured-text-editor/lib/html_razor/state_machine.js ***!
  \*****************************************************************/
/***/ ((module) => {

var i=0,
    WAIT_FOR_NEXT_TOKEN_TO_START = i++,
    READING_TAG_NAME = i++,
    DETERMINING_TAG_TYPE = i++,
    READING_ATTRIBUTE_NAME = i++,
    EXPECTING_QUOTE_TO_START_ATTRIBUTE_VALUE = i++,
    READING_ATTRIBUTE_VALUE = i++,
    WAIT_FOR_NEXT_ATTRIBUTE_TO_START = i++,
    READING_TEXT = i++,
    WAITING_FOR_EMPTY_TAG_TO_BE_CLOSED = i++;

function addCharRangeToTransition(transition, CharRangeStart, CharRangeEnd, TransitionAction) {
    for(let asciCode=CharRangeStart.charCodeAt(0); asciCode<=CharRangeEnd.charCodeAt(0); asciCode++) {
        transition[String.fromCharCode(asciCode)] = TransitionAction;
    }
}

function globCharRangesInTranstion(transition) {
    Object.keys(transition).filter(function(tk) {
        return tk.match(/^\[(.|\s)*\]$/);
    }).forEach(function(tk) {
        var tf = transition[tk];

        if(tk.indexOf('A-Z') !== -1) {addCharRangeToTransition(transition, 'A', 'Z', tf);}
        if(tk.indexOf('a-z') !== -1) {addCharRangeToTransition(transition, 'a', 'z', tf);}
        if(tk.indexOf('0-9') !== -1) {addCharRangeToTransition(transition, '0', '9', tf);}

        if(tk.indexOf(' \n') !== -1) {
           transition[' '] = tf;
           transition['\n'] = tf;
        }

        //tk.replace(/\[|\]|A\-Z|a\-z|0\-9/g, '') -> "[A-Za-z-']" is replaced to "-'", and then "-" and "'" are added to the transition
        tk.replace(/\[|\]|A\-Z|a\-z|0\-9/g, '').split('').forEach(function(c) {
            transition[c] = tf;
        });
    });
}


function StateMachine() {
    var self = this;

    this.transistions = [];
    this.tokens = [];
    this.state = WAIT_FOR_NEXT_TOKEN_TO_START;

    this.resetState();

    this.transistions[WAIT_FOR_NEXT_TOKEN_TO_START] = {
        '<':                 function()     { self.state = DETERMINING_TAG_TYPE; },
        'else':              function(char) { self.state = READING_TEXT; self.currentToken.type = 'TEXT'; self.currentToken.value += char; }
    };

    this.transistions[DETERMINING_TAG_TYPE] = {
        '[a-zA-Z]':          function(char)  { self.state = READING_TAG_NAME; self.currentToken.type = 'OPEN_TAG'; self.currentToken.value += char; },
        '/':                 function()      { self.state = READING_TAG_NAME; self.currentToken.type = 'CLOSE_TAG'; },
    };

    this.transistions[READING_TAG_NAME] = {
        '[a-zA-Z0-9]':       function(char) { self.currentToken.value += char },
        '[ \n]':             function()     { self.currentToken.type === 'CLOSE_TAG' ? self.transistions[READING_TAG_NAME]['>']() : self.state = WAIT_FOR_NEXT_ATTRIBUTE_TO_START },
        '>':                 function()     { self.state = WAIT_FOR_NEXT_TOKEN_TO_START, self.finishToken() },
        '/':                 function()     { self.state = WAITING_FOR_EMPTY_TAG_TO_BE_CLOSED, self.currentToken.type = 'EMPTY_TAG'; }
    };

    this.transistions[READING_ATTRIBUTE_NAME] = {
        '[a-zA-Z-]':         function(char) { self.currentAttribute.name += char },
        ' ':                 function()     { self.state = WAIT_FOR_NEXT_ATTRIBUTE_TO_START; self.finishAttribute() },
        '\n':                function()     {},
        '=':                 function()     { self.state = EXPECTING_QUOTE_TO_START_ATTRIBUTE_VALUE },
        '>':                 function()     { self.state = WAIT_FOR_NEXT_TOKEN_TO_START; self.finishAttribute(); self.finishToken()  },
        '<':                 function()     { self.state = DETERMINING_TAG_TYPE; self.handleBrokenOpenTag(READING_ATTRIBUTE_NAME); },
        '/':                 function()     { self.state = WAITING_FOR_EMPTY_TAG_TO_BE_CLOSED, self.currentToken.type = 'EMPTY_TAG'; self.finishAttribute() }
    };

    this.transistions[EXPECTING_QUOTE_TO_START_ATTRIBUTE_VALUE] = {
        '["\']':             function()     { self.state = READING_ATTRIBUTE_VALUE }
    };

    this.transistions[READING_ATTRIBUTE_VALUE] = {
        '["\']':             function()     { self.state = WAIT_FOR_NEXT_ATTRIBUTE_TO_START; self.finishAttribute() },
        '<':                 function()     { self.state = DETERMINING_TAG_TYPE; self.handleBrokenOpenTag(READING_ATTRIBUTE_VALUE); },
        'else':              function(char) { self.currentAttribute.value += char }
    };

    this.transistions[WAIT_FOR_NEXT_ATTRIBUTE_TO_START] = {
        '[ \n]':             function()     { },
        '[a-zA-Z]':          function(char) { self.state = READING_ATTRIBUTE_NAME; self.currentAttribute.name += char },
        '>':                 function()     { self.state = WAIT_FOR_NEXT_TOKEN_TO_START, self.finishToken() },
        '/':                 function()     { self.state = WAITING_FOR_EMPTY_TAG_TO_BE_CLOSED, self.currentToken.type = 'EMPTY_TAG'; }
    };

    this.transistions[WAITING_FOR_EMPTY_TAG_TO_BE_CLOSED] = {
        '\n':                function()     {},
        '>':                 function()     { self.state = WAIT_FOR_NEXT_TOKEN_TO_START, self.finishToken() },
    };

    this.transistions[READING_TEXT] = {
        '<':                 function()     { self.state = DETERMINING_TAG_TYPE; self.finishToken(); },
        'else':              function(char) { self.currentToken.value += char; },
        'EOF':               function()     { self.finishToken(); }
    };

    this.transistions.forEach(function(t) {
        globCharRangesInTranstion(t);
    })
};

StateMachine.prototype.finishAttribute = function() {

    if(this.currentAttribute.name === 'class') {
        this.currentAttribute.name = 'classNames';
        this.currentAttribute.value = this.currentAttribute.value.split(' ');
        this.currentAttribute.value = this.currentAttribute.value.map(function(c) { return c.trim() });
    }

    this.currentToken.attributes[this.currentAttribute.name] = this.currentAttribute.value || true;
    this.currentAttribute = {name: '', value: ''};
};

StateMachine.prototype.finishToken = function() {
    this.tokens.push(this.currentToken);
    this.resetState();
};

StateMachine.prototype.resetState = function() {
    this.currentToken = {value: '', type: 'UNKNOWN', attributes: {}};
    this.currentAttribute = {name: '', value: ''};
};

StateMachine.prototype.resetStateMachine = function() {
    this.resetState();
    this.tokens = [];
    this.state = WAIT_FOR_NEXT_TOKEN_TO_START;
}

// State Param: the StateMachine state in which the broken open tag has been detected
StateMachine.prototype.handleBrokenOpenTag = function(state) {
    if(state === READING_ATTRIBUTE_NAME || state === READING_ATTRIBUTE_VALUE) {
        this.finishToken();
        this.currentToken = {value: '', type: 'TEXT', attributes: {}};
        this.finishToken();
    }
}

StateMachine.prototype.process = function(char) {

    if(this.transistions[this.state][char]) {
        this.transistions[this.state][char](char);
    } else if (this.transistions[this.state]['else'])  {
        this.transistions[this.state]['else'](char)
    } else {
        // console.log('error parsing content');
    }

    return this.tokens.pop();
};


module.exports = StateMachine


/***/ }),

/***/ "../structured-text-editor/lib/html_razor/tag_transformation.js":
/*!**********************************************************************!*\
  !*** ../structured-text-editor/lib/html_razor/tag_transformation.js ***!
  \**********************************************************************/
/***/ ((module) => {

var TagTransformations = function() {
    Object.call(this);
}

TagTransformations.prototype = Object.create(Object.prototype);

TagTransformations.prototype.allowOnlyTextIn = function(path, args) {
    var t = this,
        p = path,
        c = '#content';

    args = args || {};

    t[p+'/span'] =
    t[p+'/ul'] =
    t[p+'/li'] =
    t[p+'/ul/li'] =
    t[p+'/ol'] =
    t[p+'/ol/li'] =
    t[p+'/strong'] =
    t[p+'/em'] =
    t[p+'/a/span'] =
    t[p+'/b/b'] =
    t[p+'/u/u'] =
    t[p+'/i/i'] =
    t[p+'/font'] = c;

    if(!args.allowBoldItalicUnderline) {
        t[p+'/b'] =
        t[p+'/u'] =
        t[p+'/i'] =
        t[p+'/code'] = c;
    } else {
        t[p+'/inlinecode/b'] =
        t[p+'/inlinecode/i'] =
        t[p+'/inlinecode/u'] =
        t[p+'/inlinecode/a'] = c;
        t[p+'/code'] = 'inlinecode';
        t[p+'/inlinecode/inlinecode'] = '#content';
        t[p+'/b/inlinecode'] = '-';
        t[p+'/u/inlinecode'] = '-';
        t[p+'/i/inlinecode'] = '-';
        t[p+'/a/code'] = 'inlinecode';
    }

    if(!args.allowLinks) {
      t[p+'/a'] = c;
      t[p+'/code'] = c;
      t[p+'/inlinecode'] = c;
    }

    if(!args.allowRootElements) {
        t[p+'/h1'] =
        t[p+'/h2'] =
        t[p+'/h3'] =
        t[p+'/h4'] =
        t[p+'/h5'] =
        t[p+'/h6'] =
        t[p+'/h7'] =
        t[p+'/div'] =
        t[p+'/p'] = c;
    }

    if(args.allowEquations) {
        t.allowInlineequationsIn(p)
    }

    if(args.allowRefs) {
        t.allowRefsIn(p);

        if(args.allowBoldItalicUnderline) {
            t.allowRefsIn(p + '/b');
            t.allowRefsIn(p + '/u');
            t.allowRefsIn(p + '/i');
        }

        if(args.allowLinks) {
            t.allowRefsIn(p + '/a');
        }
    }
};

TagTransformations.prototype.allowInlineequationsIn = function(path) {
    var t = this,
        p = path;

    t[p+'/inlineequation'] = '#no-content';
    t[p+'/b/inlineequation'] =
    t[p+'/u/inlineequation'] =
    t[p+'/i/inlineequation'] =
    t[p+'/a/inlineequation'] =
    t[p+'/b/i/inlineequation'] =
    t[p+'/i/b/inlineequation'] =
    t[p+'/b/u/inlineequation'] =
    t[p+'/u/b/inlineequation'] =
    t[p+'/i/u/inlineequation'] =
    t[p+'/u/i/inlineequation'] =
    t[p+'/a/i/inlineequation'] =
    t[p+'/i/a/inlineequation'] =
    t[p+'/a/u/inlineequation'] =
    t[p+'/u/a/inlineequation'] =
    t[p+'/a/b/inlineequation'] =
    t[p+'/b/a/inlineequation'] = '-'
};



TagTransformations.prototype.allowRefsIn = function(path) {
    this[path+'/span'] = '#content';
    this[path+'/span.footnote'] = 'span.footnote';
    this[path+'/span.reference'] = 'span.reference';
};


module.exports = TagTransformations


/***/ }),

/***/ "../structured-text-editor/lib/lookup_refs/errors.js":
/*!***********************************************************!*\
  !*** ../structured-text-editor/lib/lookup_refs/errors.js ***!
  \***********************************************************/
/***/ ((module) => {

class NotFound extends Error {
    constructor(lookupID) {
        super(`No record found for ${lookupID}`)
    }
}

class InvalidID extends Error {
    constructor(lookupID) {
        super(`ID is invalid: ${lookupID}`)
    }
}

class EmptyID extends Error {
    constructor() {
        super('ID argument should not be null for fetching reference data. Needs to be a DOI/ISBN')
    }
}

module.exports = {
    NotFound,
    InvalidID,
    EmptyID
};

/***/ }),

/***/ "../structured-text-editor/lib/lookup_refs/index.js":
/*!**********************************************************!*\
  !*** ../structured-text-editor/lib/lookup_refs/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var lookupByDOI = __webpack_require__(/*! ./lookup_by_doi */ "../structured-text-editor/lib/lookup_refs/lookup_by_doi.js");
var lookupByISBN = __webpack_require__(/*! ./lookup_by_isbn */ "../structured-text-editor/lib/lookup_refs/lookup_by_isbn.js");
var lookupByURL = __webpack_require__(/*! ./lookup_by_url */ "../structured-text-editor/lib/lookup_refs/lookup_by_url.js");
var lookupByArxiv = __webpack_require__(/*! ./lookup_by_arxiv */ "../structured-text-editor/lib/lookup_refs/lookup_by_arxiv.js");
var errors = __webpack_require__(/*! ./errors */ "../structured-text-editor/lib/lookup_refs/errors.js");

module.exports = {
    fetchJSON: function(id) {
        if(!id) {
            return new Promise((_, rej) => rej(new errors.EmptyID()));
        }

        id = id.trim();

        if(lookupByDOI.isValidID(id)) {
            return lookupByDOI.fetchJSON(id);
        }

        if(lookupByISBN.isValidID(id)) {
            return lookupByISBN.fetchJSON(id);
        }

        if(lookupByURL.isValidID(id)) {
            return lookupByURL.fetchJSON(id);
        }

        if(lookupByArxiv.isValidID(id)) {
            return lookupByArxiv.fetchJSON(id);
        }

        return new Promise((_, rej) => rej(new errors.InvalidID(id)));
    },

    lookupByDOI: lookupByDOI.fetchJSON,
    lookupByISBN: lookupByISBN.fetchJSON,
    lookupByURL: lookupByURL.fetchJSON,
    errors: errors,
}

/***/ }),

/***/ "../structured-text-editor/lib/lookup_refs/lookup_by_arxiv.js":
/*!********************************************************************!*\
  !*** ../structured-text-editor/lib/lookup_refs/lookup_by_arxiv.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// fetch('http://export.arxiv.org/api/query?id_list=1906.01738').then(r => r.text()).then(text => )

var errors = __webpack_require__(/*! ./errors */ "../structured-text-editor/lib/lookup_refs/errors.js");
var months = ['Jan.', 'Feb.', 'Mar.', 'Apr.', 'May.', 'Jun.', 'Jul.', 'Aug.', 'Sep.', 'Oct.', 'Nov.', 'Dec'];
var lookupCache = {}

function getPublishedMonth(entry) {
    try {
        var date = new Date(entry.querySelector('published').innerHTML)

        if(!date || date == 'Invalid Date') {
            throw 'invalid publication date';
        }

        return months[date.getMonth()]
    } catch (ex) {
        console.log('error parsing publication date', ex)
        return ''
    }
}

function getPublishedYear(entry) {
    try {
        var date = new Date(entry.querySelector('published').innerHTML)

        if(!date || date == 'Invalid Date') {
            throw 'invalid publication date'
        }

        return date.getFullYear()
    } catch (ex) {
        console.log('error parsing publication date', ex)
        return ''
    }
}

function resultFromRespnose(xmlDoc) {
    var entry = xmlDoc.querySelector('entry')
    var titleEl = entry.querySelector('title')
    var authors = entry.querySelectorAll('author').map(author => {
        author = author && author.querySelector('name')
        if(author && author.innerHTML) {
            return author.innerHTML
        }
    }).join(' and ')

    return {
        type: 'Article',
        title: (titleEl && titleEl.innerHTML) || '',
        author: authors,
        year: getPublishedYear(entry),
        month: getPublishedMonth(entry)
    }
}

module.exports = {

    isValidID: function(id) {
        return id && id.trim().match(/^(arXiv:)?[0-9]{4}\.[0-9]+(v.)?$/)
    },

    fetchJSON: async function(id) {

        if(!this.isValidID(id)) {
            throw new errors.InvalidID(id);
        }

        if(id.trim().match(/^arXiv:/)) {
            id = id.trim().replace(/^arXiv:/, '')
        }

        if(lookupCache[id]) {
            return lookupCache[id]
        }

        var res = await fetch(`http://export.arxiv.org/api/query?id_list=${id}`)

        if(!res.ok) {
            throw errors.NotFound
        }

        lookupCache[id] = resultFromRespnose(
            new window.DOMParser().parseFromString(await res.text(), "text/xml")
        )

        return lookupCache[id]
    }
}

/***/ }),

/***/ "../structured-text-editor/lib/lookup_refs/lookup_by_doi.js":
/*!******************************************************************!*\
  !*** ../structured-text-editor/lib/lookup_refs/lookup_by_doi.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var errors = __webpack_require__(/*! ./errors */ "../structured-text-editor/lib/lookup_refs/errors.js");
var doiLookupCache = {}

var months = ['Jan.', 'Feb.', 'Mar.', 'Apr.', 'May.', 'Jun.', 'Jul.', 'Aug.', 'Sep.', 'Oct.', 'Nov.', 'Dec'];

var doiType2bibTeXType = {
    'journal-article': 'Article',
    'proceedings-article': 'Conference/Inproceedings',
    'dissertation': 'Phdthesis',

    'book': 'Book',
    'book-series': 'Book',
    'book-set': 'Book',
    'book-track': 'Book',
    'monograph': 'Book',
    'reference-book': 'Book',

    'book-chapter': 'Inbook',
    'book-part': 'Inbook',
    'book-section': 'Inbook',
    'reference-entry': 'Inbook',

    'dataset': 'Techreport',
    'posted-content': 'Techreport',
    'report': 'Techreport',
    'report-series': 'Techreport',
    'standard': 'Techreport',
};

var selectedFields = [
    'type',
    'container-title', // -> journal, booktitle, eventtitle
    'volume',
    'issue',
    'publisher',
    'issued', // -> year, month
    'title',
    'subtitle',
    'author',
    'editor',
];

function transformDoiAuthors(doiData, field) {
    return (doiData[(field)] || [])
        .map(a => `${a.family}, ${a.given}`)
        .join(' and ')
}

function transformDoiMonth(doiData) {
    if(doiData && doiData.issued && doiData.issued['date-parts'] && doiData.issued['date-parts'][0] && doiData.issued['date-parts'][0][1]) {
        return months[doiData.issued['date-parts'][0][1]-1];
    }

    return '';
}

function transformDoiYear(doiData) {
    if(doiData && doiData.issued && doiData.issued['date-parts'] && doiData.issued['date-parts'][0] && doiData.issued['date-parts'][0][0]) {
        return doiData.issued['date-parts'][0][0];
    }

    return '';
}

function transformDoiPublisher(doiData) {
    if(['book-chapter',
      'book-part',
      'book-section',
      'reference-entry',
      'proceedings-article',
      'book',
      'book-series',
      'book-set',
      'book-track',
      'monograph',
      'reference-book'].includes(doiData.type)) {
        return doiData.publisher || '';
    }
    return '';
}

function transformDoiOrganization(doiData) {
    if(['proceedings-article'].includes(doiData.type)) {
        return doiData.publisher || '';
    }

    return '';
}

function transformDoiSchool(doiData) {
    if(['dissertation'].includes(doiData.type)) {
        return doiData.publisher || '';
    }
    return '';
}

function decode(str) {
    return str.replace('&amp;', '&')
}

module.exports = {

    isValidID: function(doi) {
        return doi.match(/^10.\d{4,9}\/.+$/i);
    },

    fetchJSON: function(doi) {
        return module.exports.queryCrossref(doi).then(resultData => {
            return {
                type: resultData.type ? doiType2bibTeXType[resultData.type] : 'Article',
                author: transformDoiAuthors(resultData, 'author'),
                editor: transformDoiAuthors(resultData, 'editor'),
                title: decode(resultData.title ? resultData.title.join(' - ') : ''),
                subtitle: decode(resultData.subtitle ? resultData.subtitle.join(' - ') : ''),
                journal: decode(resultData['container-title'] ? resultData['container-title'].join(' - ') : ''),
                number: resultData.issue || '',
                volume: resultData.volume || '',
                publisher: decode(transformDoiPublisher(resultData)),
                organization: decode(transformDoiOrganization(resultData)),
                year: transformDoiYear(resultData),
                month: transformDoiMonth(resultData),
                school: transformDoiSchool(resultData)
            }
        });
    },

    queryCrossref: function(doi) {
        if(!doi || !this.isValidID(doi)) {
            return new Promise((res, rej) => rej('invalid DOI'));
        }

        if(doiLookupCache[doi]) {
            return doiLookupCache[doi]
        }

        doiLookupCache[doi] = fetch(`https://api.crossref.org/works/?filter=doi:${encodeURIComponent(doi)}&select=${encodeURIComponent(selectedFields.join(','))}`)
            .then(response => response.json())
            .then(data => {
                if(data && data.message && data.message.items, data.message.items.length) {
                    return data.message.items[0];
                }

                return new Promise((_, rej) => rej(new errors.NotFound(doi)));
            });

        return doiLookupCache[doi];
    }
}

/***/ }),

/***/ "../structured-text-editor/lib/lookup_refs/lookup_by_isbn.js":
/*!*******************************************************************!*\
  !*** ../structured-text-editor/lib/lookup_refs/lookup_by_isbn.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var errors = __webpack_require__(/*! ./errors */ "../structured-text-editor/lib/lookup_refs/errors.js");
var fetchCache = {}
var months = ['Jan.', 'Feb.', 'Mar.', 'Apr.', 'May.', 'Jun.', 'Jul.', 'Aug.', 'Sep.', 'Oct.', 'Nov.', 'Dec'];

module.exports = {
    isValidID: function(isbn) {
        return isbn.match(/^(?=(?:\D*\d){10}(?:(?:\D*\d){3})?$)[\d-]+$/);
    },

    fetchJSON: async function(isbn) {
        if(!this.isValidID(isbn)) {
            throw new errors.InvalidID(isbn);
        }

        if(fetchCache[isbn]) {
            return fetchCache[isbn];
        }

        var rawData = await fetch(`https://openlibrary.org/isbn/${isbn}.json`);

        if(rawData.status === 404) {
            await new Promise(res => window.setTimeout(res, 1000));
            rawData = await fetch(`https://openlibrary.org/isbn/${isbn}.json`);
        }

        if(rawData.status === 404) {
            throw new errors.NotFound(isbn);
        }

        rawData = await rawData.json();

        var result = {};
        result.author = (await this.getAuthors(rawData)).join(' and ');
        result.type = 'Book';

        if(rawData.title) {
            result.title = rawData.title;
        }

        if(rawData.subtitle) {
            result.subtitle = rawData.subtitle;
        }

        if(rawData.publishers && rawData.publishers.length) {
            result.publisher = rawData.publishers[0];
        }

        if(rawData.publish_date) {
            var publishDate = new Date(rawData.publish_date);
            if(publishDate instanceof Date && !isNaN(publishDate)) {
                result.year = publishDate.getFullYear();
                result.month = months[publishDate.getMonth()];
            }
        }

        if(rawData.isbn_13 && rawData.isbn_13.length) {
            result.isbn = rawData.isbn_13[0];
        }

        fetchCache[isbn] = result;
        return result;
    },

    getAuthors: async function(payload) {
        var authors = [];

        if(payload.authors && payload.authors.length) {
            for(var i=0; i<payload.authors.length; i++) {
                var authorData = await fetch(`https://openlibrary.org${payload.authors[i].key}.json`);

                if(!authorData.ok) {
                    throw errors.NotFound
                }

                authorData = await authorData.json();
                if(authorData && authorData.name) {
                    authors.push(authorData.name);
                }
            }
        }

        if(payload.contributors && payload.contributors.length) {
            for(var i=0; i<payload.contributors.length; i++) {
                if(payload.contributors[i].role === 'Author') {
                    authors.push(payload.contributors[i].name);
                }
            }
        }

        return authors.map(this.authorNameToBibTeXFormat);
    },

    authorNameToBibTeXFormat: function(name) {
        var names = name.split(' ');
        var lastName = names.pop();

        if(!names.length) {
            return lastName;
        }

        return `${lastName}, ${names.join(' ')}`;
    },
}

/***/ }),

/***/ "../structured-text-editor/lib/lookup_refs/lookup_by_url.js":
/*!******************************************************************!*\
  !*** ../structured-text-editor/lib/lookup_refs/lookup_by_url.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var errors = __webpack_require__(/*! ./errors */ "../structured-text-editor/lib/lookup_refs/errors.js");
var lookupCache = {}
var months = ['Jan.', 'Feb.', 'Mar.', 'Apr.', 'May.', 'Jun.', 'Jul.', 'Aug.', 'Sep.', 'Oct.', 'Nov.', 'Dec'];
var apiEndpoint = 'https://djapi.eu-gb.mybluemix.net'
// var apiEndpoint = 'http://localhost:8080'

function getPublishedMonth(urlMeta) {
    try {
        var date = new Date(urlMeta['article:published_time'])

        if(!date || date == 'Invalid Date') {
            throw 'invalid publication date';
        }

        return months[date.getMonth()]
    } catch (ex) {
        console.log('error parsing publication date', ex)
        return ''
    }
}

function getPublishedYear(urlMeta) {
    try {
        var date = new Date(urlMeta['article:published_time'])

        if(!date || date == 'Invalid Date') {
            throw 'invalid publication date'
        }

        return date.getFullYear()
    } catch (ex) {
        console.log('error parsing publication date', ex)
        return ''
    }
}

function resultFromRespnose(urlMeta, url) {
    return {
        type: 'Website',
        title: (urlMeta.title && urlMeta.title.trim() !== '' ? urlMeta.title : urlMeta.description) || '',
        author: urlMeta.author || '',
        url: url || urlMeta.url || '',
        year: getPublishedYear(urlMeta),
        month: getPublishedMonth(urlMeta)
    }
}

module.exports = {

    isValidID: function(url) {
        return url && url.trim().match(/^https?:\/\//)
    },

    fetchJSON: async function(url) {

        if(!this.isValidID(url)) {
            throw new errors.InvalidID(url);
        }

        if(lookupCache[url]) {
            return lookupCache[url]
        }

        var urlMeta = await fetch(`${apiEndpoint}/api/v2/syncjobs/geturlmetadata?url=${encodeURIComponent(url)}`)

        if(!urlMeta.ok) {
            throw errors.NotFound
        }

        lookupCache[url] = resultFromRespnose(await urlMeta.json(), url)

        return lookupCache[url]
    }
}

/***/ }),

/***/ "../structured-text-editor/lib/pixelschubser/utils.js":
/*!************************************************************!*\
  !*** ../structured-text-editor/lib/pixelschubser/utils.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";


module.exports = {
    getElementPosition: function(el) {
        var xPos = 0,
            yPos = 0;

        while (el) {
            xPos += el.offsetLeft + el.clientLeft;
            yPos += el.offsetTop  + el.clientTop;

            el = el.offsetParent;
        }

        return {
            x: xPos,
            y: yPos
        };
    },

    getDistanceToRightWindowBorder: function(el) {
        var rect = el.getBoundingClientRect();
        if(!rect) return;
        return window.innerWidth - rect.x - rect.width;
    },

    copyNodeAttributes: function(srcNode, targetNode, skipAttributes) {
        skipAttributes = skipAttributes || [];

        for(var i=0; i<srcNode.attributes.length; i++) {
            if(skipAttributes.indexOf(srcNode.attributes[i].name) === -1) {
                targetNode.setAttribute(srcNode.attributes[i].name, srcNode.attributes[i].value);
            }
        }
    },

    getFirstParentWithTagName: function(el, tagName) {
        while(el && !el.tagName === tagName) {
            el = el.parentElement
        }

        return el
    },

    getAllTextNodesOfElement: function(el) {
      var n, a=[], walk = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null, false);

      while(n = walk.nextNode()) { a.push(n); }
      return a;
    },

    getLastVisibleChildOfElement: function(el) {
        var walk = document.createTreeWalker(el, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT, null, false);
        return walk.lastChild();
    },

    getFirstVisibleChildOfElement: function(el) {
        var walk = document.createTreeWalker(el, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT, null, false);
        return walk.nextNode();
    },

    copyEventListenersRecursively: function(srcNode, targetNode) {
        if(srcNode && targetNode) {
            this.copyEventListeners(srcNode, targetNode);
            for(let i=0; i<srcNode.childNodes.length; i++) {
                this.copyEventListenersRecursively(srcNode.childNodes[i], targetNode.childNodes[i]);
            }
        }
    },

    copyEventListeners: function(srcNode, targetNode) {
        targetNode.onclick = targetNode.onclick || srcNode.onclick;
        targetNode.ondragover = targetNode.ondragover || srcNode.ondragover;
        targetNode.ondragleave = targetNode.ondragleave || srcNode.ondragleave;
        targetNode.ondrop = targetNode.ondrop || srcNode.ondrop;
        targetNode.onchange = targetNode.onchange || srcNode.onchange;
        targetNode.onKeyUp = targetNode.onKeyUp || srcNode.onKeyUp;
        targetNode.onKeyDown = targetNode.onKeyDown || srcNode.onKeyDown;
        targetNode.onKeyEnter = targetNode.onKeyEnter || srcNode.onKeyEnter;
        targetNode.onKeyTab = targetNode.onKeyTab || srcNode.onKeyTab;
        targetNode.onKeyBackspace = targetNode.onKeyBackspace || srcNode.onKeyBackspace;
        targetNode.onKeyCombination = targetNode.onKeyCombination || srcNode.onKeyCombination;
        targetNode.onMarkupCleaningFinshed = targetNode.onMarkupCleaningFinshed || srcNode.onMarkupCleaningFinshed;
        targetNode.setContenteditable = targetNode.setContenteditable || srcNode.setContenteditable;
        targetNode.onSelectionChange = targetNode.onSelectionChange || srcNode.onSelectionChange;
        targetNode.onUnfocus = targetNode.onUnfocus || srcNode.onUnfocus;
        targetNode.onWindowResize = targetNode.onWindowResize || srcNode.onWindowResize;

        targetNode.sectionType = targetNode.sectionType || srcNode.sectionType;
    },

    getNodeIteratorPointingTo: function(node) {
        if(!node) { return; }
        var nodeIterator = document.createTreeWalker(
              document.body,
              NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT,
              function(node) {
                  return (node.length === 0 || node.innerHTML === '') ?
                        NodeFilter.FILTER_REJECT :
                        NodeFilter.FILTER_ACCEPT;
              }
        );

        nodeIterator.currentNode = node;

        return nodeIterator;
    },

    rescueLaTeXCharsFromEscape: function(str) {
        var mapping = {
            '\\': 'latexslash',
            '{': 'latexcmdstart',
            '}': 'latexcmdend',
            '$': 'latexcdollar',
        };

        return str.replace(/[\\{}$]/g, function(match) {
            return  mapping[match] ? ('--'+mapping[match]+'--') : '';
        });
    },

    restoreRescuedLaTeXChars: function(str) {
        var mapping = {
            'latexslash': '\\',
            'latexcmdstart': '{',
            'latexcmdend': '}',
            'latexcdollar': '$'
        };

        return str.replace(/--(latex.{5,8}?)--/g, function(match, codename) {
            console.log(codename, mapping[codename])
            return  mapping[codename] ? mapping[codename] : '';
        });
    },

    stringToAttributeSaveString: function(str) {
        var mapping = {
            '<': 'lt',
            '>': 'gt',
            '\'': 'apos',
            '"': 'quot'
        };

        return str.replace(/[<>'"]/g, function(match) {
            return  mapping[match] ? ('--'+mapping[match]+'--') : '';
        });
    },

    attributeSaveStringToString: function(str) {
        var mapping = {
            'lt': '<',
            'gt': '>',
            'apos': '\'',
            'quot': '"'
        };

        return str.replace(/--(.{2,4}?)--/g, function(match, code) {
            return mapping[code] || '';
        });
    },

    attributeSaveStringToHTMLEncoded: function(str) {
        return str.replace(/--(.{2,4}?)--/g, function(match, code) {
            return  '&' + code + ';';
        });
    },

    getSubtreeByChildNode: function(container, child) {
        while(child) {
            if(child && child.parentElement === container && child.nodeType !== Node.TEXT_NODE) {
                return child;
            }
            child = child.parentNode;
        }
    }
};


/***/ }),

/***/ "../structured-text-editor/lib/throttle/throttle.js":
/*!**********************************************************!*\
  !*** ../structured-text-editor/lib/throttle/throttle.js ***!
  \**********************************************************/
/***/ ((module) => {

//see: https://codeburst.io/throttling-and-debouncing-in-javascript-b01cad5c8edf
module.exports = function(limit, func) {
  let lastFunc;
  let lastRan;
  let lastReject;

  return function() {
      const context = this;
      const args = arguments;

      return new Promise((resolve, reject) => {
          if (!lastRan) {
              resolve(func.apply(context, args));
              lastRan = Date.now();
          } else {
              clearTimeout(lastFunc);

              if(lastReject) {
                  lastReject('canceled by throttle')
              }

              lastReject = reject

              lastFunc = setTimeout(function() {
                    if (Date.now() - lastRan >= limit) {
                        resolve(func.apply(context, args));
                        lastRan = Date.now();
                    }
              }, limit - (Date.now() - lastRan));
          }
      }).catch((err) => {
          console.log(err)

          if(err !== 'canceled by throttle') {
              return new Promise((_, reject) => reject(err))
          }
      });
  };
};


/***/ }),

/***/ "../structured-text-editor/lib/toc_builder/toc_builder.js":
/*!****************************************************************!*\
  !*** ../structured-text-editor/lib/toc_builder/toc_builder.js ***!
  \****************************************************************/
/***/ ((module) => {

function getNumberPreafixHTML(numbering) {
    if(!numbering || numbering.length === 0) { return '' }

    return '<span class="index-preafix">' + numbering + '. </span>'
}

function TOCEntryFromElement(h, args) {
    var link, result = document.createElement('li')

    if(h.el.hasAttribute('id') && args.withLinks) {
        link = document.createElement('a')
        link.setAttribute('href', '#' + h.el.getAttribute('id'))
        link.innerHTML = h.content
        result.appendChild(link)
    } else {
        result.innerHTML = h.content
    }

    if(h.numbering) {
        result.innerHTML = getNumberPreafixHTML(h.numbering) + result.innerHTML
    }

    if(h.el.classList.contains('missingLevelHint')) {
        result.classList = h.el.classList
    }
    return result
}

function missingLevelWaring(level) {
  var result = document.createElement('H' + level)
  result.classList.add('missingLevelHint')
  result.classList.add('level-' + level)

  return {
      level: level,
      content: '',
      el: result
  }
}

function annotateHeadingNumbering(DOMElement, args) {
    var c1 = c2 = c3 = c4 = c5 = c6 = 0;

    if(!Number.isInteger(args.startNumberingAtLevel) ||
       args.startNumberingAtLevel < 1 ||
       args.startNumberingAtLevel > 6) {
        return DOMElement;
    }

    DOMElement.querySelectorAll('h1, h2, h3, h4, h5, h6').forEach(function(heading) {
        var numbering

        if(heading.getAttribute('unnumbered-heading') === 'Yes') {
            heading.numbering = undefined;
            return;
        }

        if(heading.tagName === 'H1') {
            c2 = c3 = c4 = c5 = c6 = 0
            c1++
            heading.numbering = c1
            numbering = [c1]
        } else if(heading.tagName === 'H2') {
            c3 = c4 = c5 = c6 = 0
            c2++
            heading.numbering = c2
            numbering = [c1, c2]
        } else if(heading.tagName === 'H3') {
            c4 = c5 = c6 = 0
            c3++
            numbering = [c1, c2, c3]
        } else if(heading.tagName === 'H4') {
            c5 = c6 = 0
            c4++
            numbering = [c1, c2, c3, c4]
        } else if(heading.tagName === 'H5') {
            c6 = 0
            c5++
            numbering = [c1, c2, c3, c4, c5]
        } else if(heading.tagName === 'H6') {
            c6++
            numbering = [c1, c2, c3, c4, c5, c6]
        }

        if(numbering) {
            numbering.splice(0, args.startNumberingAtLevel-1)
            heading.numbering = numbering.join('.')
        }
    })

    return DOMElement
}

function extractHeadings(DOMElement) {
    var tmpMatch, headings = [];

    DOMElement.querySelectorAll('h1, h2, h3, h4, h5, h6').forEach(function(heading) {
        if((tmpMatch = heading.tagName.match(/^H(\d+)$/)) && !heading.classList.contains('no-toc-listing')) {
            headings.push({
                level: parseInt(tmpMatch[1]),
                content: heading.innerText,
                el: heading,
                numbering: heading.numbering
            })
        }
    });

    return headings;
}

function repairHierarchy(headings) {
    var result = [],
        currentLevel = 1

    headings.forEach((heading) => {
        let missingLevels = (heading.level - currentLevel)

        for(let i=0; missingLevels>1; missingLevels--) {
            result.push(missingLevelWaring(++currentLevel))
        }

        result.push(heading)

        if(missingLevels > 0) {
            currentLevel++
        } else if(missingLevels < 0) {
            currentLevel--
        }
    })

    return result
}

function TOCFromDOMElement(DOMElement, args) {
    args = args || {}
    var headings = repairHierarchy(extractHeadings(annotateHeadingNumbering(DOMElement, args))),
        result = document.createElement('ol'),
        currentList = result,
        currentLevel = 1

    headings.forEach((heading) => {
        if(currentLevel < heading.level) {
            let tmpList = document.createElement('ol')
            currentList.appendChild(tmpList)
            currentList = tmpList
            currentLevel = currentLevel+1
        }

        while(currentLevel > heading.level) {
            currentList = currentList.parentNode
            currentLevel = currentLevel-1
        }

        currentList.appendChild(TOCEntryFromElement(heading, args))
    })

    return result
}

module.exports = TOCFromDOMElement


/***/ }),

/***/ "../structured-text-editor/lib/zotero-client/index.js":
/*!************************************************************!*\
  !*** ../structured-text-editor/lib/zotero-client/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
    ZoteroOnline: __webpack_require__(/*! ./online */ "../structured-text-editor/lib/zotero-client/online.js")
}

/***/ }),

/***/ "../structured-text-editor/lib/zotero-client/online.js":
/*!*************************************************************!*\
  !*** ../structured-text-editor/lib/zotero-client/online.js ***!
  \*************************************************************/
/***/ ((module) => {

var months = ['Jan.', 'Feb.', 'Mar.', 'Apr.', 'May.', 'Jun.', 'Jul.', 'Aug.', 'Sep.', 'Oct.', 'Nov.', 'Dec']

function getNextLink(result) {
    const linkHeader = result.headers.get('Link')
    const nextMatch = linkHeader.split(',').map(x => x.match(/<(.+?)>; rel="(.+?)"/)).find(x => x[0] && x[1] && x[2] === 'next')

    if(nextMatch && nextMatch[1]) {
        return nextMatch[1]
    }
}

class ZoteroOnline {

    static transformResponseItem(item, lastModVersion) {
        const typeMap = {
            'book': 'Book',
            'webpage': 'Website',
            'encyclopediaArticle': 'Website',
            'blogPost': 'Website',
            'thesis': 'Mastersthesis',
            'conferencePaper': 'Conference',
            'journalArticle': 'Article',
            'bookSection': 'Inbook'
        }

        const getCreatorsByTypet = type => {
            if(!item || !item.data || !item.data.creators || !item.data.creators.filter) {
                return ''
            }

            return item.data.creators
                .filter(c => c)
                .filter(c => c.creatorType === type)
                .filter(c => c.lastName && c.firstName)
                .map(c => `${c.lastName}, ${c.firstName}`)
                .join(' and ')
        }

        const tryToParseYear = date => {
            if(!date) {
                return ''
            }

            try {
                return (new Date(date)).getFullYear().toString()
            } catch(ex) {
                return ''
            }
        }

        const tryToParseMonth = date => {
            if(!date) {
                return ''
            }

            try {
                return months[(new Date(date)).getMonth()]
            } catch(ex) {
                return ''
            }
        }

        const tryToParseDate = date => {
            if(!date) {
                return ''
            }

            try {
                return date.split('T')[0]
            } catch(ex) {
                return ''
            }
        }

        if(item.data) {
            return {
                lookupId: item.data.ISBN || item.data.DOI,
                id: item.key,
                type: typeMap[item.data.itemType] || 'Article',
                referenceSource: `zotero-online-${item.library.type}-${item.library.id}`,
                title: item.data.title,
                author: getCreatorsByTypet('author'),
                pages: item.data.numPages,
                volume: item.data.valume,
                url: item.data.url,
                series: item.data.series,
                publisher: item.data.publisher,
                edition: item.data.edition,
                date: tryToParseDate(item.data.accessDate),
                series: item.data.seriesNumber,
                booktitle: item.data.bookTitle,
                year: tryToParseYear(item.data.date),
                month: tryToParseMonth(item.data.date),
                editor: getCreatorsByTypet('editor'),
                zoteroLastModVersion: lastModVersion
            }
        }
    }

    constructor(apiKey, store) {
        this.apiKey = apiKey
        this.store = store || new Map()
        this.authHeaderOptions = {
            headers: {
                Authorization: `Bearer ${this.apiKey}`
            }
        }
    }

    async getLastModifiedVersion(scope, scopeID) {
        scope = scope === 'users' ? 'user' : 'group'

        return Object.values(this.store.all(true))
            .filter(item => item.id.startsWith(`zotero-online-item-${scopeID}`))
            .map(item => item.zoteroLastModVersion || 0)
            .reduce((a, b) => Math.max(a, b), 0)
    }

    async saveItem(item, scopeID) {
        await Promise.resolve(this.store.set(`zotero-online-item-${scopeID}-${item.id}`, item))
        return item
    }

    saveAllItem(items, lastModVersion, scopeID) {
        return Promise.all(items.map(item => {
            return this.saveItem(ZoteroOnline.transformResponseItem(item, lastModVersion), scopeID)
        }))
    }

    async loadUserInfo() {
        const result = await fetch(`https://api.zotero.org/keys/${this.apiKey}`)
        const body = await result.json()
        this.userID = body.userID
        this.userName = body.username
        return this
    }

    async groups() {
        const result = await fetch(`https://api.zotero.org/users/${this.userID}/groups`, this.authHeaderOptions)
        const body = await result.json()
        this._groups = body.map(r => r.data)
        return this._groups
    }

    async items() {
        await this.requestItems('users', this.userID)

        return Object.values(this.store.all(true))
            .filter(item => item.id.startsWith(`zotero-online-item-${this.userID}`))
    }

    async itemsByGroupID(groupID) {
        await this.requestItems('groups', groupID)

        return Object.values(this.store.all(true))
            .filter(item => item.id.startsWith(`zotero-online-item-${groupID}`))
    }

    async requestItems(scope, scopeID) {
        var [ body, nextLink, lastModVersion] = await this.requestJson(`https://api.zotero.org/${scope}/${scopeID}/items?since=${await this.getLastModifiedVersion(scope, scopeID)}`)
        var nextLink;

        var storedValues = await this.saveAllItem(body, lastModVersion, scopeID)

        while(nextLink) {
            [ body, nextLink ] = await this.requestJson(nextLink)
            storedValues.push(...(await this.saveAllItem(body, lastModVersion, scopeID)))
        }

        return Object.values(storedValues)
    }

    async requestJson(url) {
        const result = await fetch(url, this.authHeaderOptions)

        if(result.status !== 200) {
            throw 'Error while connecting to Zotero API'
        }

        return [
            await result.json(),
            getNextLink(result),
            result.headers.get('Last-Modified-Version')
        ]
    }
}

module.exports = ZoteroOnline

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/contains.js":
/*!***************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/contains.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ contains)
/* harmony export */ });
function contains(parent, child) {
  // $FlowFixMe: hasOwnProperty doesn't seem to work in tests
  var isShadow = Boolean(child.getRootNode && child.getRootNode().host); // First, attempt with faster native method

  if (parent.contains(child)) {
    return true;
  } // then fallback to custom implementation with Shadow DOM support
  else if (isShadow) {
      var next = child;

      do {
        if (next && parent.isSameNode(next)) {
          return true;
        } // $FlowFixMe: need a better way to handle this...


        next = next.parentNode || next.host;
      } while (next);
    } // Give up, the result is false


  return false;
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getBorders.js":
/*!*****************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getBorders.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getBorders)
/* harmony export */ });
/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getComputedStyle.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");



function toNumber(cssValue) {
  return parseFloat(cssValue) || 0;
}

function getBorders(element) {
  var computedStyle = (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) ? (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element) : {};
  return {
    top: toNumber(computedStyle.borderTopWidth),
    right: toNumber(computedStyle.borderRightWidth),
    bottom: toNumber(computedStyle.borderBottomWidth),
    left: toNumber(computedStyle.borderLeftWidth)
  };
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js":
/*!****************************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getBoundingClientRect)
/* harmony export */ });
function getBoundingClientRect(element) {
  var rect = element.getBoundingClientRect();
  return {
    width: rect.width,
    height: rect.height,
    top: rect.top,
    right: rect.right,
    bottom: rect.bottom,
    left: rect.left,
    x: rect.left,
    y: rect.top
  };
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js":
/*!**********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getClippingRect)
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _getViewportRect_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getViewportRect.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js");
/* harmony import */ var _getDocumentRect_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getDocumentRect.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js");
/* harmony import */ var _listScrollParents_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./listScrollParents.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js");
/* harmony import */ var _getOffsetParent_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./getOffsetParent.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./getDocumentElement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./getComputedStyle.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./instanceOf.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
/* harmony import */ var _getDecorations_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./getDecorations.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getDecorations.js");
/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./contains.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/contains.js");
/* harmony import */ var _utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/rectToClientRect.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/rectToClientRect.js");













function getClientRectFromMixedType(element, clippingParent) {
  return clippingParent === _enums_js__WEBPACK_IMPORTED_MODULE_0__.viewport ? (0,_utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_1__["default"])((0,_getViewportRect_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element)) : (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__.isHTMLElement)(clippingParent) ? (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_4__["default"])(clippingParent) : (0,_utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_1__["default"])((0,_getDocumentRect_js__WEBPACK_IMPORTED_MODULE_5__["default"])((0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_6__["default"])(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`


function getClippingParents(element) {
  var clippingParents = (0,_listScrollParents_js__WEBPACK_IMPORTED_MODULE_7__["default"])(element);
  var canEscapeClipping = ['absolute', 'fixed'].indexOf((0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_8__["default"])(element).position) >= 0;
  var clipperElement = canEscapeClipping && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__.isHTMLElement)(element) ? (0,_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_9__["default"])(element) : element;

  if (!(0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__.isElement)(clipperElement)) {
    return [];
  } // $FlowFixMe: https://github.com/facebook/flow/issues/1414


  return clippingParents.filter(function (clippingParent) {
    return (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__.isElement)(clippingParent) && (0,_contains_js__WEBPACK_IMPORTED_MODULE_10__["default"])(clippingParent, clipperElement);
  });
} // Gets the maximum area that the element is visible in due to any number of
// clipping parents


function getClippingRect(element, boundary, rootBoundary) {
  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents[0];
  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent);
    var decorations = (0,_getDecorations_js__WEBPACK_IMPORTED_MODULE_11__["default"])((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__.isHTMLElement)(clippingParent) ? clippingParent : (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_6__["default"])(element));
    accRect.top = Math.max(rect.top + decorations.top, accRect.top);
    accRect.right = Math.min(rect.right - decorations.right, accRect.right);
    accRect.bottom = Math.min(rect.bottom - decorations.bottom, accRect.bottom);
    accRect.left = Math.max(rect.left + decorations.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js":
/*!***********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getCompositeRect)
/* harmony export */ });
/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
/* harmony import */ var _getNodeScroll_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getNodeScroll.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getNodeName.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./instanceOf.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getDocumentElement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isScrollParent.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js");






 // Returns the composite rect of an element relative to its offsetParent.
// Composite means it takes into account transforms as well as layout.

function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }

  var documentElement = (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(offsetParent);
  var rect = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_1__["default"])(elementOrVirtualElement);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };

  if (!isFixed) {
    if ((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_2__["default"])(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
    (0,_isScrollParent_js__WEBPACK_IMPORTED_MODULE_3__["default"])(documentElement)) {
      scroll = (0,_getNodeScroll_js__WEBPACK_IMPORTED_MODULE_4__["default"])(offsetParent);
    }

    if ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_5__.isHTMLElement)(offsetParent)) {
      offsets = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_1__["default"])(offsetParent);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = (0,_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_6__["default"])(documentElement);
    }
  }

  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js":
/*!***********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getComputedStyle)
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindow.js");

function getComputedStyle(element) {
  return (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element).getComputedStyle(element);
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getDecorations.js":
/*!*********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getDecorations.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getDecorations)
/* harmony export */ });
/* harmony import */ var _getBorders_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getBorders.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getBorders.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getNodeName.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js");



 // Borders + scrollbars

function getDecorations(element) {
  var win = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);
  var borders = (0,_getBorders_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element);
  var isHTML = (0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element) === 'html';
  var winScrollBarX = (0,_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_3__["default"])(element);
  var x = element.clientWidth + borders.right;
  var y = element.clientHeight + borders.bottom; // HACK:
  // document.documentElement.clientHeight on iOS reports the height of the
  // viewport including the bottom bar, even if the bottom bar isn't visible.
  // If the difference between window innerHeight and html clientHeight is more
  // than 50, we assume it's a mobile bottom bar and ignore scrollbars.
  // * A 50px thick scrollbar is likely non-existent (macOS is 15px and Windows
  //   is about 17px)
  // * The mobile bar is 114px tall

  if (isHTML && win.innerHeight - element.clientHeight > 50) {
    y = win.innerHeight - borders.bottom;
  }

  return {
    top: isHTML ? 0 : element.clientTop,
    right: // RTL scrollbar (scrolling containers only)
    element.clientLeft > borders.left ? borders.right : // LTR scrollbar
    isHTML ? win.innerWidth - x - winScrollBarX : element.offsetWidth - x,
    bottom: isHTML ? win.innerHeight - y : element.offsetHeight - y,
    left: isHTML ? winScrollBarX : element.clientLeft
  };
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js":
/*!*************************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getDocumentElement)
/* harmony export */ });
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");

function getDocumentElement(element) {
  // $FlowFixMe: assume body is always available
  return ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isElement)(element) ? element.ownerDocument : element.document).documentElement;
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js":
/*!**********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getDocumentRect)
/* harmony export */ });
/* harmony import */ var _getCompositeRect_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getCompositeRect.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js");
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getDocumentElement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getWindowScroll.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js");




function getDocumentRect(element) {
  var win = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);
  var winScroll = (0,_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element);
  var documentRect = (0,_getCompositeRect_js__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(element), win);
  documentRect.height = Math.max(documentRect.height, win.innerHeight);
  documentRect.width = Math.max(documentRect.width, win.innerWidth);
  documentRect.x = -winScroll.scrollLeft;
  documentRect.y = -winScroll.scrollTop;
  return documentRect;
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js":
/*!***************************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getHTMLElementScroll)
/* harmony export */ });
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js":
/*!********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getLayoutRect)
/* harmony export */ });
// Returns the layout rect of an element relative to its offsetParent. Layout
// means it doesn't take into account transforms.
function getLayoutRect(element) {
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: element.offsetWidth,
    height: element.offsetHeight
  };
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getNodeName.js":
/*!******************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getNodeName.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getNodeName)
/* harmony export */ });
function getNodeName(element) {
  return element ? (element.nodeName || '').toLowerCase() : null;
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js":
/*!********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getNodeScroll)
/* harmony export */ });
/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindowScroll.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js");
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instanceOf.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _getHTMLElementScroll_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getHTMLElementScroll.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js");




function getNodeScroll(node) {
  if (node === (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node) || !(0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(node)) {
    return (0,_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__["default"])(node);
  } else {
    return (0,_getHTMLElementScroll_js__WEBPACK_IMPORTED_MODULE_3__["default"])(node);
  }
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js":
/*!**********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getOffsetParent)
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindow.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getNodeName.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getComputedStyle.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _isTableElement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isTableElement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/isTableElement.js");






function getTrueOffsetParent(element) {
  if (!(0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) || // https://github.com/popperjs/popper-core/issues/837
  (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element).position === 'fixed') {
    return null;
  }

  return element.offsetParent;
}

function getOffsetParent(element) {
  var window = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element);
  var offsetParent = getTrueOffsetParent(element); // Find the nearest non-table offsetParent

  while (offsetParent && (0,_isTableElement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent);
  }

  if (offsetParent && (0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_4__["default"])(offsetParent) === 'body' && (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(offsetParent).position === 'static') {
    return window;
  }

  return offsetParent || window;
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getParentNode.js":
/*!********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getParentNode.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getParentNode)
/* harmony export */ });
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getNodeName.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getDocumentElement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");


function getParentNode(element) {
  if ((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element) === 'html') {
    return element;
  }

  return (// $FlowFixMe: this is a quicker (but less type safe) way to save quite some bytes from the bundle
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    // $FlowFixMe: need a better way to handle this...
    element.host || // ShadowRoot detected
    // $FlowFixMe: HTMLElement is a Node
    (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element) // fallback

  );
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js":
/*!**********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getScrollParent)
/* harmony export */ });
/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getParentNode.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");
/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isScrollParent.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getNodeName.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instanceOf.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");




function getScrollParent(node) {
  if (['html', 'body', '#document'].indexOf((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node)) >= 0) {
    // $FlowFixMe: assume body is always available
    return node.ownerDocument.body;
  }

  if ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(node) && (0,_isScrollParent_js__WEBPACK_IMPORTED_MODULE_2__["default"])(node)) {
    return node;
  }

  return getScrollParent((0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_3__["default"])(node));
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js":
/*!**********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getViewportRect)
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindow.js");

function getViewportRect(element) {
  var win = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);
  var visualViewport = win.visualViewport;
  var width = win.innerWidth;
  var height = win.innerHeight; // We don't know which browsers have buggy or odd implementations of this, so
  // for now we're only applying it to iOS to fix the keyboard issue.
  // Investigation required

  if (visualViewport && /iPhone|iPod|iPad/.test(navigator.platform)) {
    width = visualViewport.width;
    height = visualViewport.height;
  }

  return {
    width: width,
    height: height,
    x: 0,
    y: 0
  };
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindow.js":
/*!****************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindow.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getWindow)
/* harmony export */ });
/*:: import type { Window } from '../types'; */

/*:: declare function getWindow(node: Node | Window): Window; */
function getWindow(node) {
  if (node.toString() !== '[object Window]') {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView : window;
  }

  return node;
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js":
/*!**********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getWindowScroll)
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindow.js");

function getWindowScroll(node) {
  var win = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft: scrollLeft,
    scrollTop: scrollTop
  };
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js":
/*!**************************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getWindowScrollBarX)
/* harmony export */ });
/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getDocumentElement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindowScroll.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js");



function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  // Popper 1 is broken in this case and never had a bug report so let's assume
  // it's not an issue. I don't think anyone ever specifies width on <html>
  // anyway.
  // Browsers where the left scrollbar doesn't cause an issue report `0` for
  // this (e.g. Edge 2019, IE11, Safari)
  return (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element)).left + (0,_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element).scrollLeft;
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/instanceOf.js":
/*!*****************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/instanceOf.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isElement": () => (/* binding */ isElement),
/* harmony export */   "isHTMLElement": () => (/* binding */ isHTMLElement)
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindow.js");

/*:: declare function isElement(node: mixed): boolean %checks(node instanceof
  Element); */

function isElement(node) {
  var OwnElement = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
/*:: declare function isHTMLElement(node: mixed): boolean %checks(node instanceof
  HTMLElement); */


function isHTMLElement(node) {
  var OwnElement = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}



/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js":
/*!*********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isScrollParent)
/* harmony export */ });
/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getComputedStyle.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");

function isScrollParent(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  var _getComputedStyle = (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element),
      overflow = _getComputedStyle.overflow,
      overflowX = _getComputedStyle.overflowX,
      overflowY = _getComputedStyle.overflowY;

  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/isTableElement.js":
/*!*********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/isTableElement.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isTableElement)
/* harmony export */ });
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getNodeName.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");

function isTableElement(element) {
  return ['table', 'td', 'th'].indexOf((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element)) >= 0;
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js":
/*!************************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ listScrollParents)
/* harmony export */ });
/* harmony import */ var _getScrollParent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getScrollParent.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js");
/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getParentNode.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getNodeName.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindow.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isScrollParent.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js");





function listScrollParents(element, list) {
  if (list === void 0) {
    list = [];
  }

  var scrollParent = (0,_getScrollParent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);
  var isBody = (0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scrollParent) === 'body';
  var win = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_2__["default"])(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], (0,_isScrollParent_js__WEBPACK_IMPORTED_MODULE_3__["default"])(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : // $FlowFixMe: isBody tells us target will be an HTMLElement here
  updatedList.concat(listScrollParents((0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_4__["default"])(target)));
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/enums.js":
/*!**************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/enums.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "afterMain": () => (/* binding */ afterMain),
/* harmony export */   "afterRead": () => (/* binding */ afterRead),
/* harmony export */   "afterWrite": () => (/* binding */ afterWrite),
/* harmony export */   "auto": () => (/* binding */ auto),
/* harmony export */   "basePlacements": () => (/* binding */ basePlacements),
/* harmony export */   "beforeMain": () => (/* binding */ beforeMain),
/* harmony export */   "beforeRead": () => (/* binding */ beforeRead),
/* harmony export */   "beforeWrite": () => (/* binding */ beforeWrite),
/* harmony export */   "bottom": () => (/* binding */ bottom),
/* harmony export */   "clippingParents": () => (/* binding */ clippingParents),
/* harmony export */   "end": () => (/* binding */ end),
/* harmony export */   "left": () => (/* binding */ left),
/* harmony export */   "main": () => (/* binding */ main),
/* harmony export */   "modifierPhases": () => (/* binding */ modifierPhases),
/* harmony export */   "placements": () => (/* binding */ placements),
/* harmony export */   "popper": () => (/* binding */ popper),
/* harmony export */   "read": () => (/* binding */ read),
/* harmony export */   "reference": () => (/* binding */ reference),
/* harmony export */   "right": () => (/* binding */ right),
/* harmony export */   "start": () => (/* binding */ start),
/* harmony export */   "top": () => (/* binding */ top),
/* harmony export */   "variationPlacements": () => (/* binding */ variationPlacements),
/* harmony export */   "viewport": () => (/* binding */ viewport),
/* harmony export */   "write": () => (/* binding */ write)
/* harmony export */ });
var top = 'top';
var bottom = 'bottom';
var right = 'right';
var left = 'left';
var auto = 'auto';
var basePlacements = [top, bottom, right, left];
var start = 'start';
var end = 'end';
var clippingParents = 'clippingParents';
var viewport = 'viewport';
var popper = 'popper';
var reference = 'reference';
var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []); // modifiers that need to read the DOM

var beforeRead = 'beforeRead';
var read = 'read';
var afterRead = 'afterRead'; // pure-logic modifiers

var beforeMain = 'beforeMain';
var main = 'main';
var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

var beforeWrite = 'beforeWrite';
var write = 'write';
var afterWrite = 'afterWrite';
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/index.js":
/*!**************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "afterMain": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.afterMain),
/* harmony export */   "afterRead": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.afterRead),
/* harmony export */   "afterWrite": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.afterWrite),
/* harmony export */   "auto": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.auto),
/* harmony export */   "basePlacements": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.basePlacements),
/* harmony export */   "beforeMain": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.beforeMain),
/* harmony export */   "beforeRead": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.beforeRead),
/* harmony export */   "beforeWrite": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.beforeWrite),
/* harmony export */   "bottom": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom),
/* harmony export */   "clippingParents": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.clippingParents),
/* harmony export */   "createPopper": () => (/* binding */ createPopper),
/* harmony export */   "end": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.end),
/* harmony export */   "left": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.left),
/* harmony export */   "main": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.main),
/* harmony export */   "modifierPhases": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.modifierPhases),
/* harmony export */   "placements": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.placements),
/* harmony export */   "popper": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper),
/* harmony export */   "popperGenerator": () => (/* binding */ popperGenerator),
/* harmony export */   "read": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.read),
/* harmony export */   "reference": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.reference),
/* harmony export */   "right": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.right),
/* harmony export */   "start": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.start),
/* harmony export */   "top": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.top),
/* harmony export */   "variationPlacements": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.variationPlacements),
/* harmony export */   "viewport": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.viewport),
/* harmony export */   "write": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.write)
/* harmony export */ });
/* harmony import */ var _dom_utils_getCompositeRect_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./dom-utils/getCompositeRect.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js");
/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./dom-utils/getLayoutRect.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js");
/* harmony import */ var _dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dom-utils/listScrollParents.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js");
/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./dom-utils/getOffsetParent.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./dom-utils/getComputedStyle.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _utils_orderModifiers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/orderModifiers.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/orderModifiers.js");
/* harmony import */ var _utils_debounce_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./utils/debounce.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/debounce.js");
/* harmony import */ var _utils_validateModifiers_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/validateModifiers.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/validateModifiers.js");
/* harmony import */ var _utils_uniqueBy_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/uniqueBy.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/uniqueBy.js");
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/getBasePlacement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _utils_mergeByName_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/mergeByName.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/mergeByName.js");
/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom-utils/instanceOf.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enums.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/enums.js");














var INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';
var INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';
var DEFAULT_OPTIONS = {
  placement: 'bottom',
  modifiers: [],
  strategy: 'absolute'
};

function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return !args.some(function (element) {
    return !(element && typeof element.getBoundingClientRect === 'function');
  });
}

function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }

  var _generatorOptions = generatorOptions,
      _generatorOptions$def = _generatorOptions.defaultModifiers,
      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
      _generatorOptions$def2 = _generatorOptions.defaultOptions,
      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions;
    }

    var state = {
      placement: 'bottom',
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, {}, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference,
        popper: popper
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state,
      setOptions: function setOptions(options) {
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, {}, state.options, {}, options);
        state.scrollParents = {
          reference: (0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isElement)(reference) ? (0,_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_2__["default"])(reference) : reference.contextElement ? (0,_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_2__["default"])(reference.contextElement) : [],
          popper: (0,_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_2__["default"])(popper)
        }; // Orders the modifiers based on their dependencies and `phase`
        // properties

        var orderedModifiers = (0,_utils_orderModifiers_js__WEBPACK_IMPORTED_MODULE_3__["default"])((0,_utils_mergeByName_js__WEBPACK_IMPORTED_MODULE_4__["default"])([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

        state.orderedModifiers = orderedModifiers.filter(function (m) {
          return m.enabled;
        }); // Validate the provided modifiers so that the consumer will get warned
        // if one of the modifiers is invalid for any reason

        if (true) {
          var modifiers = (0,_utils_uniqueBy_js__WEBPACK_IMPORTED_MODULE_5__["default"])([].concat(orderedModifiers, state.options.modifiers), function (_ref) {
            var name = _ref.name;
            return name;
          });
          (0,_utils_validateModifiers_js__WEBPACK_IMPORTED_MODULE_6__["default"])(modifiers);

          if ((0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_7__["default"])(state.options.placement) === _enums_js__WEBPACK_IMPORTED_MODULE_0__.auto) {
            var flipModifier = state.orderedModifiers.find(function (_ref2) {
              var name = _ref2.name;
              return name === 'flip';
            });

            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', 'present and enabled to work.'].join(' '));
            }
          }

          var _getComputedStyle = (0,_dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_8__["default"])(popper),
              marginTop = _getComputedStyle.marginTop,
              marginRight = _getComputedStyle.marginRight,
              marginBottom = _getComputedStyle.marginBottom,
              marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can
          // cause bugs with positioning, so we'll warn the consumer


          if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));
          }
        }

        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }

        var _state$elements = state.elements,
            reference = _state$elements.reference,
            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
        // anymore

        if (!areValidElements(reference, popper)) {
          if (true) {
            console.error(INVALID_ELEMENT_ERROR);
          }

          return;
        } // Store the reference and popper rects to be read by modifiers


        state.rects = {
          reference: (0,_dom_utils_getCompositeRect_js__WEBPACK_IMPORTED_MODULE_9__["default"])(reference, (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_10__["default"])(popper), state.options.strategy === 'fixed'),
          popper: (0,_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_11__["default"])(popper)
        }; // Modifiers have the ability to reset the current update cycle. The
        // most common use case for this is the `flip` modifier changing the
        // placement, which then needs to re-run all the modifiers, because the
        // logic was previously ran for the previous placement and is therefore
        // stale/incorrect

        state.reset = false;
        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
        // is filled with the initial data specified by the modifier. This means
        // it doesn't persist and is fresh on each update.
        // To ensure persistent data, use `${name}#persistent`

        state.orderedModifiers.forEach(function (modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;

        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (true) {
            __debug_loops__ += 1;

            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }

          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }

          var _state$orderedModifie = state.orderedModifiers[index],
              fn = _state$orderedModifie.fn,
              _state$orderedModifie2 = _state$orderedModifie.options,
              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
              name = _state$orderedModifie.name;

          if (typeof fn === 'function') {
            state = fn({
              state: state,
              options: _options,
              name: name,
              instance: instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: (0,_utils_debounce_js__WEBPACK_IMPORTED_MODULE_12__["default"])(function () {
        return new Promise(function (resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };

    if (!areValidElements(reference, popper)) {
      if (true) {
        console.error(INVALID_ELEMENT_ERROR);
      }

      return instance;
    }

    instance.setOptions(options).then(function (state) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state);
      }
    }); // Modifiers have the ability to execute arbitrary code before the first
    // update cycle runs. They will be executed in the same order as the update
    // cycle. This is useful when a modifier adds some persistent data that
    // other modifiers need to use, but the modifier is run after the dependent
    // one.

    function runModifierEffects() {
      state.orderedModifiers.forEach(function (_ref3) {
        var name = _ref3.name,
            _ref3$options = _ref3.options,
            options = _ref3$options === void 0 ? {} : _ref3$options,
            effect = _ref3.effect;

        if (typeof effect === 'function') {
          var cleanupFn = effect({
            state: state,
            name: name,
            instance: instance,
            options: options
          });

          var noopFn = function noopFn() {};

          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }

    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function (fn) {
        return fn();
      });
      effectCleanupFns = [];
    }

    return instance;
  };
}
var createPopper = /*#__PURE__*/popperGenerator();

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/applyStyles.js":
/*!******************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/applyStyles.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom-utils/getNodeName.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom-utils/instanceOf.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");

 // This modifier takes the styles prepared by the `computeStyles` modifier
// and applies them to the HTMLElements such as popper and arrow

function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function (name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name]; // arrow is optional + virtual elements

    if (!(0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) || !(0,_dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element)) {
      return;
    } // Flow doesn't support to extend this property, but it's the most
    // effective way to apply styles to an HTMLElement
    // $FlowFixMe


    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function (name) {
      var value = attributes[name];

      if (value === false) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? '' : value);
      }
    });
  });
}

function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: '0',
      top: '0',
      margin: '0'
    },
    arrow: {
      position: 'absolute'
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);

  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }

  return function () {
    Object.keys(state.elements).forEach(function (name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

      var style = styleProperties.reduce(function (style, property) {
        style[property] = '';
        return style;
      }, {}); // arrow is optional + virtual elements

      if (!(0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) || !(0,_dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element)) {
        return;
      } // Flow doesn't support to extend this property, but it's the most
      // effective way to apply styles to an HTMLElement
      // $FlowFixMe


      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'applyStyles',
  enabled: true,
  phase: 'write',
  fn: applyStyles,
  effect: effect,
  requires: ['computeStyles']
});

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/arrow.js":
/*!************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/arrow.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom-utils/getLayoutRect.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js");
/* harmony import */ var _dom_utils_contains_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../dom-utils/contains.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/contains.js");
/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/getMainAxisFromPlacement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js");
/* harmony import */ var _utils_within_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/within.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/within.js");
/* harmony import */ var _utils_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/mergePaddingObject.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/mergePaddingObject.js");
/* harmony import */ var _utils_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils/expandToHashMap.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/expandToHashMap.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom-utils/instanceOf.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");









 // eslint-disable-next-line import/no-unused-modules

function arrow(_ref) {
  var _state$modifiersData$;

  var state = _ref.state,
      name = _ref.name;
  var arrowElement = state.elements.arrow;
  var popperOffsets = state.modifiersData.popperOffsets;
  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(state.placement);
  var axis = (0,_utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(basePlacement);
  var isVertical = [_enums_js__WEBPACK_IMPORTED_MODULE_2__.left, _enums_js__WEBPACK_IMPORTED_MODULE_2__.right].indexOf(basePlacement) >= 0;
  var len = isVertical ? 'height' : 'width';

  if (!arrowElement || !popperOffsets) {
    return;
  }

  var paddingObject = state.modifiersData[name + "#persistent"].padding;
  var arrowRect = (0,_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_3__["default"])(arrowElement);
  var minProp = axis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_2__.top : _enums_js__WEBPACK_IMPORTED_MODULE_2__.left;
  var maxProp = axis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_2__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_2__.right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
  var startDiff = popperOffsets[axis] - state.rects.reference[axis];
  var arrowOffsetParent = (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(arrowElement);
  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
  // outside of the popper bounds

  var min = paddingObject[minProp];
  var max = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset = (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_5__["default"])(min, center, max); // Prevents breaking syntax highlighting...

  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}

function effect(_ref2) {
  var state = _ref2.state,
      options = _ref2.options,
      name = _ref2.name;
  var _options$element = options.element,
      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element,
      _options$padding = options.padding,
      padding = _options$padding === void 0 ? 0 : _options$padding;

  if (arrowElement == null) {
    return;
  } // CSS selector


  if (typeof arrowElement === 'string') {
    arrowElement = state.elements.popper.querySelector(arrowElement);

    if (!arrowElement) {
      return;
    }
  }

  if (true) {
    if (!(0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_6__.isHTMLElement)(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', 'To use an SVG arrow, wrap it in an HTMLElement that will be used as', 'the arrow.'].join(' '));
    }
  }

  if (!(0,_dom_utils_contains_js__WEBPACK_IMPORTED_MODULE_7__["default"])(state.elements.popper, arrowElement)) {
    if (true) {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', 'element.'].join(' '));
    }

    return;
  }

  state.elements.arrow = arrowElement;
  state.modifiersData[name + "#persistent"] = {
    padding: (0,_utils_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_8__["default"])(typeof padding !== 'number' ? padding : (0,_utils_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_9__["default"])(padding, _enums_js__WEBPACK_IMPORTED_MODULE_2__.basePlacements))
  };
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'arrow',
  enabled: true,
  phase: 'main',
  fn: arrow,
  effect: effect,
  requires: ['popperOffsets'],
  requiresIfExists: ['preventOverflow']
});

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/computeStyles.js":
/*!********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/computeStyles.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "mapToStyles": () => (/* binding */ mapToStyles)
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom-utils/getWindow.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom-utils/getDocumentElement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dom-utils/getComputedStyle.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getBasePlacement.js");





 // eslint-disable-next-line import/no-unused-modules

var unsetSides = {
  top: 'auto',
  right: 'auto',
  bottom: 'auto',
  left: 'auto'
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.

function roundOffsets(_ref) {
  var x = _ref.x,
      y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: Math.round(x * dpr) / dpr || 0,
    y: Math.round(y * dpr) / dpr || 0
  };
}

function mapToStyles(_ref2) {
  var _Object$assign2;

  var popper = _ref2.popper,
      popperRect = _ref2.popperRect,
      placement = _ref2.placement,
      offsets = _ref2.offsets,
      position = _ref2.position,
      gpuAcceleration = _ref2.gpuAcceleration,
      adaptive = _ref2.adaptive;

  var _roundOffsets = roundOffsets(offsets),
      x = _roundOffsets.x,
      y = _roundOffsets.y;

  var hasX = offsets.hasOwnProperty('x');
  var hasY = offsets.hasOwnProperty('y');
  var sideX = _enums_js__WEBPACK_IMPORTED_MODULE_0__.left;
  var sideY = _enums_js__WEBPACK_IMPORTED_MODULE_0__.top;
  var win = window;

  if (adaptive) {
    var offsetParent = (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_1__["default"])(popper);

    if (offsetParent === (0,_dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_2__["default"])(popper)) {
      offsetParent = (0,_dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(popper);
    } // $FlowFixMe: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it

    /*:: offsetParent = (offsetParent: Element); */


    if (placement === _enums_js__WEBPACK_IMPORTED_MODULE_0__.top) {
      sideY = _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom;
      y -= offsetParent.clientHeight - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }

    if (placement === _enums_js__WEBPACK_IMPORTED_MODULE_0__.left) {
      sideX = _enums_js__WEBPACK_IMPORTED_MODULE_0__.right;
      x -= offsetParent.clientWidth - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }

  var commonStyles = Object.assign({
    position: position
  }, adaptive && unsetSides);

  if (gpuAcceleration) {
    var _Object$assign;

    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) < 2 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }

  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
}

function computeStyles(_ref3) {
  var state = _ref3.state,
      options = _ref3.options;
  var _options$gpuAccelerat = options.gpuAcceleration,
      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
      _options$adaptive = options.adaptive,
      adaptive = _options$adaptive === void 0 ? true : _options$adaptive;

  if (true) {
    var transitionProperty = (0,_dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_4__["default"])(state.elements.popper).transitionProperty || '';

    if (adaptive && ['transform', 'top', 'right', 'bottom', 'left'].some(function (property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
      console.warn(['Popper: Detected CSS transitions on at least one of the following', 'CSS properties: "transform", "top", "right", "bottom", "left".', '\n\n', 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', 'for smooth transitions, or remove these properties from the CSS', 'transition declaration on the popper element if only transitioning', 'opacity or background-color for example.', '\n\n', 'We recommend using the popper element as a wrapper around an inner', 'element that can have any CSS property transitioned for animations.'].join(' '));
    }
  }

  var commonStyles = {
    placement: (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_5__["default"])(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration: gpuAcceleration
  };

  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, {}, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive: adaptive
    })));
  }

  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, {}, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: 'absolute',
      adaptive: false
    })));
  }

  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-placement': state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'computeStyles',
  enabled: true,
  phase: 'beforeWrite',
  fn: computeStyles,
  data: {}
});

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/eventListeners.js":
/*!*********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/eventListeners.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom-utils/getWindow.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
 // eslint-disable-next-line import/no-unused-modules

var passive = {
  passive: true
};

function effect(_ref) {
  var state = _ref.state,
      instance = _ref.instance,
      options = _ref.options;
  var _options$scroll = options.scroll,
      scroll = _options$scroll === void 0 ? true : _options$scroll,
      _options$resize = options.resize,
      resize = _options$resize === void 0 ? true : _options$resize;
  var window = (0,_dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

  if (scroll) {
    scrollParents.forEach(function (scrollParent) {
      scrollParent.addEventListener('scroll', instance.update, passive);
    });
  }

  if (resize) {
    window.addEventListener('resize', instance.update, passive);
  }

  return function () {
    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.removeEventListener('scroll', instance.update, passive);
      });
    }

    if (resize) {
      window.removeEventListener('resize', instance.update, passive);
    }
  };
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'eventListeners',
  enabled: true,
  phase: 'write',
  fn: function fn() {},
  effect: effect,
  data: {}
});

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/flip.js":
/*!***********************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/flip.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/getOppositePlacement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getOppositePlacement.js");
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/getOppositeVariationPlacement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js");
/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/detectOverflow.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _utils_computeAutoPlacement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/computeAutoPlacement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _utils_getVariation_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/getVariation.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getVariation.js");






 // eslint-disable-next-line import/no-unused-modules

function getExpandedFallbackPlacements(placement) {
  if ((0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_1__.auto) {
    return [];
  }

  var oppositePlacement = (0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(placement);
  return [(0,_utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(placement), oppositePlacement, (0,_utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(oppositePlacement)];
}

function flip(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;

  if (state.modifiersData[name]._skip) {
    return;
  }

  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
      specifiedFallbackPlacements = options.fallbackPlacements,
      padding = options.padding,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      _options$flipVariatio = options.flipVariations,
      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
      allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [(0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
    return acc.concat((0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_1__.auto ? (0,_utils_computeAutoPlacement_js__WEBPACK_IMPORTED_MODULE_4__["default"])(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      flipVariations: flipVariations,
      allowedAutoPlacements: allowedAutoPlacements
    }) : placement);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements[0];

  for (var i = 0; i < placements.length; i++) {
    var placement = placements[i];

    var _basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement);

    var isStartVariation = (0,_utils_getVariation_js__WEBPACK_IMPORTED_MODULE_5__["default"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_1__.start;
    var isVertical = [_enums_js__WEBPACK_IMPORTED_MODULE_1__.top, _enums_js__WEBPACK_IMPORTED_MODULE_1__.bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? 'width' : 'height';
    var overflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_6__["default"])(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      altBoundary: altBoundary,
      padding: padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? _enums_js__WEBPACK_IMPORTED_MODULE_1__.right : _enums_js__WEBPACK_IMPORTED_MODULE_1__.left : isStartVariation ? _enums_js__WEBPACK_IMPORTED_MODULE_1__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_1__.top;

    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = (0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(mainVariationSide);
    }

    var altVariationSide = (0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(mainVariationSide);
    var checks = [];

    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }

    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }

    if (checks.every(function (check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }

    checksMap.set(placement, checks);
  }

  if (makeFallbackChecks) {
    // `2` may be desired in some cases – research later
    var numberOfChecks = flipVariations ? 3 : 1;

    var _loop = function _loop(_i) {
      var fittingPlacement = placements.find(function (placement) {
        var checks = checksMap.get(placement);

        if (checks) {
          return checks.slice(0, _i).every(function (check) {
            return check;
          });
        }
      });

      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };

    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);

      if (_ret === "break") break;
    }
  }

  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'flip',
  enabled: true,
  phase: 'main',
  fn: flip,
  requiresIfExists: ['offset'],
  data: {
    _skip: false
  }
});

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/hide.js":
/*!***********************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/hide.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/detectOverflow.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/detectOverflow.js");



function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }

  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}

function isAnySideFullyClipped(overflow) {
  return [_enums_js__WEBPACK_IMPORTED_MODULE_0__.top, _enums_js__WEBPACK_IMPORTED_MODULE_0__.right, _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom, _enums_js__WEBPACK_IMPORTED_MODULE_0__.left].some(function (side) {
    return overflow[side] >= 0;
  });
}

function hide(_ref) {
  var state = _ref.state,
      name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state, {
    elementContext: 'reference'
  });
  var popperAltOverflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets: referenceClippingOffsets,
    popperEscapeOffsets: popperEscapeOffsets,
    isReferenceHidden: isReferenceHidden,
    hasPopperEscaped: hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-reference-hidden': isReferenceHidden,
    'data-popper-escaped': hasPopperEscaped
  });
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'hide',
  enabled: true,
  phase: 'main',
  requiresIfExists: ['preventOverflow'],
  fn: hide
});

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/offset.js":
/*!*************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/offset.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "distanceAndSkiddingToXY": () => (/* binding */ distanceAndSkiddingToXY)
/* harmony export */ });
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/enums.js");


function distanceAndSkiddingToXY(placement, rects, offset) {
  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement);
  var invertDistance = [_enums_js__WEBPACK_IMPORTED_MODULE_1__.left, _enums_js__WEBPACK_IMPORTED_MODULE_1__.top].indexOf(basePlacement) >= 0 ? -1 : 1;

  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
    placement: placement
  })) : offset,
      skidding = _ref[0],
      distance = _ref[1];

  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [_enums_js__WEBPACK_IMPORTED_MODULE_1__.left, _enums_js__WEBPACK_IMPORTED_MODULE_1__.right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}

function offset(_ref2) {
  var state = _ref2.state,
      options = _ref2.options,
      name = _ref2.name;
  var _options$offset = options.offset,
      offset = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = _enums_js__WEBPACK_IMPORTED_MODULE_1__.placements.reduce(function (acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement],
      x = _data$state$placement.x,
      y = _data$state$placement.y;

  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'offset',
  enabled: true,
  phase: 'main',
  requires: ['popperOffsets'],
  fn: offset
});

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/popperOffsets.js":
/*!********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/popperOffsets.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_computeOffsets_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/computeOffsets.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/computeOffsets.js");


function popperOffsets(_ref) {
  var state = _ref.state,
      name = _ref.name;
  // Offsets are the actual position the popper needs to have to be
  // properly positioned near its reference element
  // This is the most basic placement, and will be adjusted by
  // the modifiers in the next step
  state.modifiersData[name] = (0,_utils_computeOffsets_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: 'absolute',
    placement: state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'popperOffsets',
  enabled: true,
  phase: 'read',
  fn: popperOffsets,
  data: {}
});

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/preventOverflow.js":
/*!**********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/preventOverflow.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../enums.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/getMainAxisFromPlacement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js");
/* harmony import */ var _utils_getAltAxis_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/getAltAxis.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getAltAxis.js");
/* harmony import */ var _utils_within_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/within.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/within.js");
/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom-utils/getLayoutRect.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js");
/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/detectOverflow.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _utils_getVariation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/getVariation.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getVariation.js");
/* harmony import */ var _utils_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/getFreshSideObject.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getFreshSideObject.js");











function preventOverflow(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;
  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      padding = options.padding,
      _options$tether = options.tether,
      tether = _options$tether === void 0 ? true : _options$tether,
      _options$tetherOffset = options.tetherOffset,
      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(state, {
    boundary: boundary,
    rootBoundary: rootBoundary,
    padding: padding,
    altBoundary: altBoundary
  });
  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state.placement);
  var variation = (0,_utils_getVariation_js__WEBPACK_IMPORTED_MODULE_2__["default"])(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = (0,_utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(basePlacement);
  var altAxis = (0,_utils_getAltAxis_js__WEBPACK_IMPORTED_MODULE_4__["default"])(mainAxis);
  var popperOffsets = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var data = {
    x: 0,
    y: 0
  };

  if (!popperOffsets) {
    return;
  }

  if (checkMainAxis) {
    var mainSide = mainAxis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.top : _enums_js__WEBPACK_IMPORTED_MODULE_5__.left;
    var altSide = mainAxis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_5__.right;
    var len = mainAxis === 'y' ? 'height' : 'width';
    var offset = popperOffsets[mainAxis];
    var min = popperOffsets[mainAxis] + overflow[mainSide];
    var max = popperOffsets[mainAxis] - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === _enums_js__WEBPACK_IMPORTED_MODULE_5__.start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === _enums_js__WEBPACK_IMPORTED_MODULE_5__.start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
    // outside the reference bounds

    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? (0,_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_6__["default"])(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : (0,_utils_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_7__["default"])();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
    // to include its full size in the calculation. If the reference is small
    // and near the edge of a boundary, the popper can overflow even if the
    // reference is not overflowing as well (e.g. virtual elements with no
    // width or height)

    var arrowLen = (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_8__["default"])(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;
    var arrowOffsetParent = state.elements.arrow && (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_9__["default"])(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;
    var tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;
    var preventedOffset = (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_8__["default"])(tether ? Math.min(min, tetherMin) : min, offset, tether ? Math.max(max, tetherMax) : max);
    popperOffsets[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset;
  }

  if (checkAltAxis) {
    var _mainSide = mainAxis === 'x' ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.top : _enums_js__WEBPACK_IMPORTED_MODULE_5__.left;

    var _altSide = mainAxis === 'x' ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_5__.right;

    var _offset = popperOffsets[altAxis];

    var _min = _offset + overflow[_mainSide];

    var _max = _offset - overflow[_altSide];

    var _preventedOffset = (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_8__["default"])(_min, _offset, _max);

    popperOffsets[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'preventOverflow',
  enabled: true,
  phase: 'main',
  fn: preventOverflow,
  requiresIfExists: ['offset']
});

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/popper.js":
/*!***************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/popper.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createPopper": () => (/* binding */ createPopper),
/* harmony export */   "defaultModifiers": () => (/* binding */ defaultModifiers),
/* harmony export */   "detectOverflow": () => (/* reexport safe */ _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   "popperGenerator": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_9__.popperGenerator)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./index.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/index.js");
/* harmony import */ var _modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modifiers/eventListeners.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/eventListeners.js");
/* harmony import */ var _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modifiers/popperOffsets.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/popperOffsets.js");
/* harmony import */ var _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modifiers/computeStyles.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/computeStyles.js");
/* harmony import */ var _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modifiers/applyStyles.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/applyStyles.js");
/* harmony import */ var _modifiers_offset_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modifiers/offset.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/offset.js");
/* harmony import */ var _modifiers_flip_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modifiers/flip.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/flip.js");
/* harmony import */ var _modifiers_preventOverflow_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modifiers/preventOverflow.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/preventOverflow.js");
/* harmony import */ var _modifiers_arrow_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modifiers/arrow.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/arrow.js");
/* harmony import */ var _modifiers_hide_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./modifiers/hide.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/modifiers/hide.js");
/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils/detectOverflow.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/detectOverflow.js");











var defaultModifiers = [_modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_0__["default"], _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_1__["default"], _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_2__["default"], _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_3__["default"], _modifiers_offset_js__WEBPACK_IMPORTED_MODULE_4__["default"], _modifiers_flip_js__WEBPACK_IMPORTED_MODULE_5__["default"], _modifiers_preventOverflow_js__WEBPACK_IMPORTED_MODULE_6__["default"], _modifiers_arrow_js__WEBPACK_IMPORTED_MODULE_7__["default"], _modifiers_hide_js__WEBPACK_IMPORTED_MODULE_8__["default"]];
var createPopper = /*#__PURE__*/(0,_index_js__WEBPACK_IMPORTED_MODULE_9__.popperGenerator)({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules



/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js":
/*!***********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ computeAutoPlacement)
/* harmony export */ });
/* harmony import */ var _getVariation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getVariation.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getVariation.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _detectOverflow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./detectOverflow.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getBasePlacement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getBasePlacement.js");





/*:: type OverflowsMap = { [ComputedPlacement]: number }; */

/*;; type OverflowsMap = { [key in ComputedPlacement]: number }; */
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      placement = _options.placement,
      boundary = _options.boundary,
      rootBoundary = _options.rootBoundary,
      padding = _options.padding,
      flipVariations = _options.flipVariations,
      _options$allowedAutoP = _options.allowedAutoPlacements,
      allowedAutoPlacements = _options$allowedAutoP === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.placements : _options$allowedAutoP;
  var variation = (0,_getVariation_js__WEBPACK_IMPORTED_MODULE_1__["default"])(placement);
  var placements = (variation ? flipVariations ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.variationPlacements : _enums_js__WEBPACK_IMPORTED_MODULE_0__.variationPlacements.filter(function (placement) {
    return (0,_getVariation_js__WEBPACK_IMPORTED_MODULE_1__["default"])(placement) === variation;
  }) : _enums_js__WEBPACK_IMPORTED_MODULE_0__.basePlacements).filter(function (placement) {
    return allowedAutoPlacements.indexOf(placement) >= 0;
  }); // $FlowFixMe: Flow seems to have problems with two array unions...

  var overflows = placements.reduce(function (acc, placement) {
    acc[placement] = (0,_detectOverflow_js__WEBPACK_IMPORTED_MODULE_2__["default"])(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding
    })[(0,_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(placement)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function (a, b) {
    return overflows[a] - overflows[b];
  });
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/computeOffsets.js":
/*!*****************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/utils/computeOffsets.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ computeOffsets)
/* harmony export */ });
/* harmony import */ var _getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBasePlacement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _getVariation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getVariation.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getVariation.js");
/* harmony import */ var _getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getMainAxisFromPlacement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/enums.js");




function computeOffsets(_ref) {
  var reference = _ref.reference,
      element = _ref.element,
      placement = _ref.placement;
  var basePlacement = placement ? (0,_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement) : null;
  var variation = placement ? (0,_getVariation_js__WEBPACK_IMPORTED_MODULE_1__["default"])(placement) : null;
  var commonX = reference.x + reference.width / 2 - element.width / 2;
  var commonY = reference.y + reference.height / 2 - element.height / 2;
  var offsets;

  switch (basePlacement) {
    case _enums_js__WEBPACK_IMPORTED_MODULE_2__.top:
      offsets = {
        x: commonX,
        y: reference.y - element.height
      };
      break;

    case _enums_js__WEBPACK_IMPORTED_MODULE_2__.bottom:
      offsets = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;

    case _enums_js__WEBPACK_IMPORTED_MODULE_2__.right:
      offsets = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;

    case _enums_js__WEBPACK_IMPORTED_MODULE_2__.left:
      offsets = {
        x: reference.x - element.width,
        y: commonY
      };
      break;

    default:
      offsets = {
        x: reference.x,
        y: reference.y
      };
  }

  var mainAxis = basePlacement ? (0,_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(basePlacement) : null;

  if (mainAxis != null) {
    var len = mainAxis === 'y' ? 'height' : 'width';

    switch (variation) {
      case _enums_js__WEBPACK_IMPORTED_MODULE_2__.start:
        offsets[mainAxis] = Math.floor(offsets[mainAxis]) - Math.floor(reference[len] / 2 - element[len] / 2);
        break;

      case _enums_js__WEBPACK_IMPORTED_MODULE_2__.end:
        offsets[mainAxis] = Math.floor(offsets[mainAxis]) + Math.ceil(reference[len] / 2 - element[len] / 2);
        break;

      default:
    }
  }

  return offsets;
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/debounce.js":
/*!***********************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/utils/debounce.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ debounce)
/* harmony export */ });
function debounce(fn) {
  var pending;
  return function () {
    if (!pending) {
      pending = new Promise(function (resolve) {
        Promise.resolve().then(function () {
          pending = undefined;
          resolve(fn());
        });
      });
    }

    return pending;
  };
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/detectOverflow.js":
/*!*****************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/utils/detectOverflow.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ detectOverflow)
/* harmony export */ });
/* harmony import */ var _dom_utils_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom-utils/getBoundingClientRect.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
/* harmony import */ var _dom_utils_getClippingRect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom-utils/getClippingRect.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js");
/* harmony import */ var _dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dom-utils/getDocumentElement.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _computeOffsets_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./computeOffsets.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/computeOffsets.js");
/* harmony import */ var _rectToClientRect_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./rectToClientRect.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/rectToClientRect.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dom-utils/instanceOf.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mergePaddingObject.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/mergePaddingObject.js");
/* harmony import */ var _expandToHashMap_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./expandToHashMap.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/expandToHashMap.js");








 // eslint-disable-next-line import/no-unused-modules

function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$placement = _options.placement,
      placement = _options$placement === void 0 ? state.placement : _options$placement,
      _options$boundary = _options.boundary,
      boundary = _options$boundary === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.clippingParents : _options$boundary,
      _options$rootBoundary = _options.rootBoundary,
      rootBoundary = _options$rootBoundary === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.viewport : _options$rootBoundary,
      _options$elementConte = _options.elementContext,
      elementContext = _options$elementConte === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper : _options$elementConte,
      _options$altBoundary = _options.altBoundary,
      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
      _options$padding = _options.padding,
      padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = (0,_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_1__["default"])(typeof padding !== 'number' ? padding : (0,_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_2__["default"])(padding, _enums_js__WEBPACK_IMPORTED_MODULE_0__.basePlacements));
  var altContext = elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.reference : _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper;
  var referenceElement = state.elements.reference;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = (0,_dom_utils_getClippingRect_js__WEBPACK_IMPORTED_MODULE_3__["default"])((0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isElement)(element) ? element : element.contextElement || (0,_dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_5__["default"])(state.elements.popper), boundary, rootBoundary);
  var referenceClientRect = (0,_dom_utils_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_6__["default"])(referenceElement);
  var popperOffsets = (0,_computeOffsets_js__WEBPACK_IMPORTED_MODULE_7__["default"])({
    reference: referenceClientRect,
    element: popperRect,
    strategy: 'absolute',
    placement: placement
  });
  var popperClientRect = (0,_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_8__["default"])(Object.assign({}, popperRect, {}, popperOffsets));
  var elementClientRect = elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
  // 0 or negative = within the clipping rect

  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

  if (elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper && offsetData) {
    var offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function (key) {
      var multiply = [_enums_js__WEBPACK_IMPORTED_MODULE_0__.right, _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [_enums_js__WEBPACK_IMPORTED_MODULE_0__.top, _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom].indexOf(key) >= 0 ? 'y' : 'x';
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }

  return overflowOffsets;
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/expandToHashMap.js":
/*!******************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/utils/expandToHashMap.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ expandToHashMap)
/* harmony export */ });
function expandToHashMap(value, keys) {
  return keys.reduce(function (hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/format.js":
/*!*********************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/utils/format.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ format)
/* harmony export */ });
function format(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return [].concat(args).reduce(function (p, c) {
    return p.replace(/%s/, c);
  }, str);
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getAltAxis.js":
/*!*************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/utils/getAltAxis.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getAltAxis)
/* harmony export */ });
function getAltAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getBasePlacement.js":
/*!*******************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/utils/getBasePlacement.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getBasePlacement)
/* harmony export */ });

function getBasePlacement(placement) {
  return placement.split('-')[0];
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getFreshSideObject.js":
/*!*********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/utils/getFreshSideObject.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getFreshSideObject)
/* harmony export */ });
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js":
/*!***************************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getMainAxisFromPlacement)
/* harmony export */ });
function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getOppositePlacement.js":
/*!***********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/utils/getOppositePlacement.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getOppositePlacement)
/* harmony export */ });
var hash = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js":
/*!********************************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getOppositeVariationPlacement)
/* harmony export */ });
var hash = {
  start: 'end',
  end: 'start'
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function (matched) {
    return hash[matched];
  });
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getVariation.js":
/*!***************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/utils/getVariation.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getVariation)
/* harmony export */ });
function getVariation(placement) {
  return placement.split('-')[1];
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/mergeByName.js":
/*!**************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/utils/mergeByName.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mergeByName)
/* harmony export */ });
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function (merged, current) {
    var existing = merged[current.name];
    merged[current.name] = existing ? Object.assign({}, existing, {}, current, {
      options: Object.assign({}, existing.options, {}, current.options),
      data: Object.assign({}, existing.data, {}, current.data)
    }) : current;
    return merged;
  }, {}); // IE11 does not support Object.values

  return Object.keys(merged).map(function (key) {
    return merged[key];
  });
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/mergePaddingObject.js":
/*!*********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/utils/mergePaddingObject.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mergePaddingObject)
/* harmony export */ });
/* harmony import */ var _getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getFreshSideObject.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/getFreshSideObject.js");

function mergePaddingObject(paddingObject) {
  return Object.assign({}, (0,_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(), {}, paddingObject);
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/orderModifiers.js":
/*!*****************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/utils/orderModifiers.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ orderModifiers)
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/enums.js");
 // source: https://stackoverflow.com/questions/49875255

function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function (modifier) {
    map.set(modifier.name, modifier);
  }); // On visiting object, check for its dependencies and visit them recursively

  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function (dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);

        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }

  modifiers.forEach(function (modifier) {
    if (!visited.has(modifier.name)) {
      // check for visited object
      sort(modifier);
    }
  });
  return result;
}

function orderModifiers(modifiers) {
  // order based on dependencies
  var orderedModifiers = order(modifiers); // order based on phase

  return _enums_js__WEBPACK_IMPORTED_MODULE_0__.modifierPhases.reduce(function (acc, phase) {
    return acc.concat(orderedModifiers.filter(function (modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/rectToClientRect.js":
/*!*******************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/utils/rectToClientRect.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ rectToClientRect)
/* harmony export */ });
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/uniqueBy.js":
/*!***********************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/utils/uniqueBy.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ uniqueBy)
/* harmony export */ });
function uniqueBy(arr, fn) {
  var identifiers = new Set();
  return arr.filter(function (item) {
    var identifier = fn(item);

    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/validateModifiers.js":
/*!********************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/utils/validateModifiers.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ validateModifiers)
/* harmony export */ });
/* harmony import */ var _format_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./format.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/format.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "../structured-text-editor/node_modules/@popperjs/core/lib/enums.js");


var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ['name', 'enabled', 'phase', 'fn', 'effect', 'requires', 'options'];
function validateModifiers(modifiers) {
  modifiers.forEach(function (modifier) {
    Object.keys(modifier).forEach(function (key) {
      switch (key) {
        case 'name':
          if (typeof modifier.name !== 'string') {
            console.error((0,_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', "\"" + String(modifier.name) + "\""));
          }

          break;

        case 'enabled':
          if (typeof modifier.enabled !== 'boolean') {
            console.error((0,_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', "\"" + String(modifier.enabled) + "\""));
          }

        case 'phase':
          if (_enums_js__WEBPACK_IMPORTED_MODULE_1__.modifierPhases.indexOf(modifier.phase) < 0) {
            console.error((0,_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + _enums_js__WEBPACK_IMPORTED_MODULE_1__.modifierPhases.join(', '), "\"" + String(modifier.phase) + "\""));
          }

          break;

        case 'fn':
          if (typeof modifier.fn !== 'function') {
            console.error((0,_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', "\"" + String(modifier.fn) + "\""));
          }

          break;

        case 'effect':
          if (typeof modifier.effect !== 'function') {
            console.error((0,_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', "\"" + String(modifier.fn) + "\""));
          }

          break;

        case 'requires':
          if (!Array.isArray(modifier.requires)) {
            console.error((0,_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', "\"" + String(modifier.requires) + "\""));
          }

          break;

        case 'requiresIfExists':
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error((0,_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', "\"" + String(modifier.requiresIfExists) + "\""));
          }

          break;

        case 'options':
        case 'data':
          break;

        default:
          console.error("PopperJS: an invalid property has been provided to the \"" + modifier.name + "\" modifier, valid properties are " + VALID_PROPERTIES.map(function (s) {
            return "\"" + s + "\"";
          }).join(', ') + "; but \"" + key + "\" was provided.");
      }

      modifier.requires && modifier.requires.forEach(function (requirement) {
        if (modifiers.find(function (mod) {
          return mod.name === requirement;
        }) == null) {
          console.error((0,_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}

/***/ }),

/***/ "../structured-text-editor/node_modules/@popperjs/core/lib/utils/within.js":
/*!*********************************************************************************!*\
  !*** ../structured-text-editor/node_modules/@popperjs/core/lib/utils/within.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ within)
/* harmony export */ });
function within(min, value, max) {
  return Math.max(min, Math.min(value, max));
}

/***/ }),

/***/ "../structured-text-editor/node_modules/changesets/lib/Builder.js":
/*!************************************************************************!*\
  !*** ../structured-text-editor/node_modules/changesets/lib/Builder.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Changeset = __webpack_require__(/*! ./Changeset */ "../structured-text-editor/node_modules/changesets/lib/Changeset.js")
  , Retain = __webpack_require__(/*! ./operations/Retain */ "../structured-text-editor/node_modules/changesets/lib/operations/Retain.js")
  , Skip = __webpack_require__(/*! ./operations/Skip */ "../structured-text-editor/node_modules/changesets/lib/operations/Skip.js")
  , Insert = __webpack_require__(/*! ./operations/Insert */ "../structured-text-editor/node_modules/changesets/lib/operations/Insert.js")

function Builder() {
  this.ops = []
  this.addendum = ''
  this.removendum = ''
}

module.exports = Builder

Builder.prototype.keep =
Builder.prototype.retain = function(len) {
  this.ops.push(new Retain(len))
  return this
}

Builder.prototype.delete =
Builder.prototype.skip = function(str) {
  this.removendum += str
  this.ops.push(new Skip(str.length))
  return this
}

Builder.prototype.add =
Builder.prototype.insert = function(str) {
  this.addendum += str
  this.ops.push(new Insert(str.length))
  return this
}

Builder.prototype.end = function() {
  var cs = new Changeset(this.ops)
  cs.addendum = this.addendum
  cs.removendum = this.removendum
  return cs
}


/***/ }),

/***/ "../structured-text-editor/node_modules/changesets/lib/Changeset.js":
/*!**************************************************************************!*\
  !*** ../structured-text-editor/node_modules/changesets/lib/Changeset.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * changesets
 * A Changeset library incorporating operational transformation (OT)
 * Copyright 2012 by Marcel Klehr <mklehr@gmx.net>
 *
 * (MIT LICENSE)
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * A sequence of consecutive operations
 *
 * @param ops.. <Operation> all passed operations will be added to the changeset
 */
function Changeset(ops/*or ops..*/) {
  this.addendum = ""
  this.removendum = ""
  this.inputLength = 0
  this.outputLength = 0

  if(!Array.isArray(ops)) ops = arguments
  for(var i=0; i<ops.length; i++) {
    this.push(ops[i])
    this.inputLength += ops[i].input
    this.outputLength += ops[i].output
  }
}

// True inheritance
Changeset.prototype = Object.create(Array.prototype, {
  constructor: {
    value: Changeset,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
module.exports = Changeset

var TextTransform = __webpack_require__(/*! ./TextTransform */ "../structured-text-editor/node_modules/changesets/lib/TextTransform.js")
  , ChangesetTransform = __webpack_require__(/*! ./ChangesetTransform */ "../structured-text-editor/node_modules/changesets/lib/ChangesetTransform.js")

var Retain = __webpack_require__(/*! ./operations/Retain */ "../structured-text-editor/node_modules/changesets/lib/operations/Retain.js")
  , Skip = __webpack_require__(/*! ./operations/Skip */ "../structured-text-editor/node_modules/changesets/lib/operations/Skip.js")
  , Insert = __webpack_require__(/*! ./operations/Insert */ "../structured-text-editor/node_modules/changesets/lib/operations/Insert.js")

var Builder = __webpack_require__(/*! ./Builder */ "../structured-text-editor/node_modules/changesets/lib/Builder.js")

/**
 * Returns an array containing the ops that are within the passed range
 * (only op.input is counted; thus not counting inserts to the range length, yet they are part of the range)
 */
Changeset.prototype.subrange = function(start, len) {
  var range = []
    , op, oplen
    , l=0
  for(var i=0, pos=0; i<this.length && l < len; i++) {
    op = this[i]
    if(op.input+pos >= start) {
      if(op.input) {
        if(op.length != Infinity) oplen = op.length -Math.max(0, start-pos) -Math.max(0, (op.length+pos)-(start+len))
        else oplen = len
        if (oplen !== 0) range.push( op.derive(oplen) ) // (Don't copy over more than len param allows)
      }
      else {
        range.push( op.derive(op.length) )
        oplen = 0
      }
      l += oplen
    }
    pos += op.input
  }
  return range
}

/**
 * Merge two changesets (that are based on the same state!) so that the resulting changseset
 * has the same effect as both orignal ones applied one after the other
 *
 * @param otherCs <Changeset>
 * @param left <boolean> Which op to choose if there's an insert tie (If you use this function in a distributed, synchronous environment, be sure to invert this param on the other site, otherwise it can be omitted safely))
 * @returns <Changeset>
 */
Changeset.prototype.merge = function(otherCs, left) {
  if(!(otherCs instanceof Changeset)) {
    throw new Error('Argument must be a #<Changeset>, but received '+otherCs.__proto__.constructor.name)
  }

  if(otherCs.inputLength !== this.outputLength) {
    throw new Error("Changeset lengths for merging don't match! Input length of younger cs: "+otherCs.inputLength+', output length of older cs:'+this.outputLength)
  }

  var newops = []
    , addPtr1 = 0
    , remPtr1 = 0
    , addPtr2 = 0
    , remPtr2 = 0
    , newaddendum = ''
    , newremovendum = ''

  zip(this, otherCs, function(op1, op2) {
    // console.log(newops)
    // console.log(op1, op2)

    // I'm deleting something -- the other cs can't know that, so just overtake my op
    if(op1 && !op1.output) {
      newops.push(op1.merge().clone())
      newremovendum += this.removendum.substr(remPtr1, op1.length) // overtake added chars
      remPtr1 += op1.length
      op1.length = 0 // don't gimme that one again.
      return
    }

    // op2 is an insert
    if(op2 && !op2.input) {
      newops.push(op2.merge().clone())
      newaddendum += otherCs.addendum.substr(addPtr2, op2.length) // overtake added chars
      addPtr2 += op2.length
      op2.length = 0 // don't gimme that one again.
      return
    }

    // op2 is either a retain or a skip
    if(op2 && op2.input && op1) {
      // op2 retains whatever we do here (retain or insert), so just clone my op
      if(op2.output) {
        newops.push(op1.merge(op2).clone())
        if(!op1.input) { // overtake addendum
          newaddendum += this.addendum.substr(addPtr1, op1.length)
          addPtr1 += op1.length
        }
        op1.length = 0 // don't gimme these again
        op2.length = 0
      }else

      // op2 deletes my retain here, so just clone the delete
      // (op1 can only be a retain and no skip here, cause we've handled skips above already)
      if(!op2.output && op1.input) {
        newops.push(op2.merge(op1).clone())
        newremovendum += otherCs.removendum.substr(remPtr2, op2.length) // overtake added chars
        remPtr2 += op2.length
        op1.length = 0 // don't gimme these again
        op2.length = 0
      }else

      //otherCs deletes something I added (-1) +1 = 0
      {
        addPtr1 += op1.length
        op1.length = 0 // don't gimme these again
        op2.length = 0
      }
      return
    }

    console.log('oops', arguments)
    throw new Error('oops. This case hasn\'t been considered by the developer (error code: PBCAC)')
  }.bind(this))

  var newCs = new Changeset(newops)
  newCs.addendum = newaddendum
  newCs.removendum = newremovendum

  return newCs
}

/**
 * A private and quite handy function that slices ops into equally long pieces and applies them on a mapping function
 * that can determine the iteration steps by setting op.length to 0 on an op (equals using .next() in a usual iterator)
 */
function zip(cs1, cs2, func) {
  var opstack1 = cs1.map(function(op) {return op.clone()}) // copy ops
    , opstack2 = cs2.map(function(op) {return op.clone()})

  var op2, op1
  while(opstack1.length || opstack2.length) {// iterate through all outstanding ops of this cs
    op1 = opstack1[0]? opstack1[0].clone() : null
    op2 = opstack2[0]? opstack2[0].clone() : null

    if(op1) {
      if(op2) op1 = op1.derive(Math.min(op1.length, op2.length)) // slice 'em into equally long pieces
      if(opstack1[0].length > op1.length) opstack1[0] = opstack1[0].derive(opstack1[0].length-op1.length)
      else opstack1.shift()
    }

    if(op2) {
      if(op1) op2 = op2.derive(Math.min(op1.length, op2.length)) // slice 'em into equally long pieces
      if(opstack2[0].length > op2.length) opstack2[0] = opstack2[0].derive(opstack2[0].length-op2.length)
      else opstack2.shift()
    }

    func(op1, op2)

    if(op1 && op1.length) opstack1.unshift(op1)
    if(op2 && op2.length) opstack2.unshift(op2)
  }
}

/**
 * Inclusion Transformation (IT) or Forward Transformation
 *
 * transforms the operations of the current changeset against the
 * all operations in another changeset in such a way that the
 * effects of the latter are effectively included.
 * This is basically like a applying the other cs on this one.
 *
 * @param otherCs <Changeset>
 * @param left <boolean> Which op to choose if there's an insert tie (If you use this function in a distributed, synchronous environment, be sure to invert this param on the other site, otherwise it can be omitted safely)
 *
 * @returns <Changeset>
 */
Changeset.prototype.transformAgainst = function(otherCs, left) {
  if(!(otherCs instanceof Changeset)) {
    throw new Error('Argument to Changeset#transformAgainst must be a #<Changeset>, but received '+otherCs.__proto__.constructor.name)
  }

  if(this.inputLength != otherCs.inputLength) {
    throw new Error('Can\'t transform changesets with differing inputLength: '+this.inputLength+' and '+otherCs.inputLength)
  }

  var transformation = new ChangesetTransform(this, [new Retain(Infinity)])
  otherCs.forEach(function(op) {
    var nextOp = this.subrange(transformation.pos, Infinity)[0] // next op of this cs
    if(nextOp && !nextOp.input && !op.input) { // two inserts tied; left breaks it
      if (left) transformation.writeOutput(transformation.readInput(nextOp.length))
    }
    op.apply(transformation)
  }.bind(this))

  return transformation.result()
}

/**
 * Exclusion Transformation (ET) or Backwards Transformation
 *
 * transforms all operations in the current changeset against the operations
 * in another changeset in such a way that the impact of the latter are effectively excluded
 *
 * @param changeset <Changeset> the changeset to substract from this one
 * @param left <boolean> Which op to choose if there's an insert tie (If you use this function in a distributed, synchronous environment, be sure to invert this param on the other site, otherwise it can be omitted safely)
 * @returns <Changeset>
 */
Changeset.prototype.substract = function(changeset, left) {
  // The current operations assume that the changes in
  // `changeset` happened before, so for each of those ops
  // we create an operation that undoes its effect and
  // transform all our operations on top of the inverse changes
  return this.transformAgainst(changeset.invert(), left)
}

/**
 * Returns the inverse Changeset of the current one
 *
 * Changeset.invert().apply(Changeset.apply(document)) == document
 */
Changeset.prototype.invert = function() {
  // invert all ops
  var newCs = new Changeset(this.map(function(op) {
    return op.invert()
  }))

  // removendum becomes addendum and vice versa
  newCs.addendum = this.removendum
  newCs.removendum = this.addendum

  return newCs
}

/**
 * Applies this changeset on a text
 */
Changeset.prototype.apply = function(input) {
  // pre-requisites
  if(input.length != this.inputLength) throw new Error('Input length doesn\'t match expected length. expected: '+this.inputLength+'; actual: '+input.length)

  var operation = new TextTransform(input, this.addendum, this.removendum)

  this.forEach(function(op) {
    // each Operation has access to all pointers as well as the input, addendum and removendum (the latter are immutable)
    op.apply(operation)
  }.bind(this))

  return operation.result()
}

/**
 * Returns an array of strings describing this changeset's operations
 */
Changeset.prototype.inspect = function() {
  var j = 0
  return this.map(function(op) {
    var string = ''

    if(!op.input) { // if Insert
      string = this.addendum.substr(j,op.length)
      j += op.length
      return string
    }

    for(var i=0; i<op.length; i++) string += op.symbol
    return string
  }.bind(this)).join('')
}

/**
 * Serializes the given changeset in order to return a (hopefully) more compact representation
 * than json that can be sent through a network or stored in a database
 *
 * Numbers are converted to the base 36, unsafe chars in the text are urlencoded
 *
 * @param cs <Changeset> The changeset to be serialized
 * @returns <String> The serialized changeset
 */
Changeset.prototype.pack = function() {
  var packed = this.map(function(op) {
    return op.pack()
  }).join('')

  var addendum = this.addendum.replace(/%/g, '%25').replace(/\|/g, '%7C')
    , removendum = this.removendum.replace(/%/g, '%25').replace(/\|/g, '%7C')
  return packed+'|'+addendum+'|'+removendum
}
Changeset.prototype.toString = function() {
  return this.pack()
}

/**
 * Unserializes the output of cs.text.Changeset#toString()
 *
 * @param packed <String> The serialized changeset
 * @param <cs.Changeset>
 */
Changeset.unpack = function(packed) {
  if(packed == '') throw new Error('Cannot unpack from empty string')
  var components = packed.split('|')
    , opstring = components[0]
    , addendum = components[1].replace(/%7c/gi, '|').replace(/%25/g, '%')
    , removendum = components[2].replace(/%7c/gi, '|').replace(/%25/g, '%')

  var matches = opstring.match(/[=+-]([^=+-])+/g)
  if(!matches) throw new Error('Cannot unpack invalidly serialized op string')

  var ops = []
  matches.forEach(function(s) {
    var symbol = s.substr(0,1)
      , data = s.substr(1)
    if(Skip.prototype.symbol == symbol) return ops.push(Skip.unpack(data))
    if(Insert.prototype.symbol == symbol) return ops.push(Insert.unpack(data))
    if(Retain.prototype.symbol == symbol) return ops.push(Retain.unpack(data))
    throw new Error('Invalid changeset representation passed to Changeset.unpack')
  })

  var cs = new Changeset(ops)
  cs.addendum = addendum
  cs.removendum = removendum

  return cs
}

Changeset.create = function() {
  return new Builder
}

/**
 * Returns a Changeset containing the operations needed to transform text1 into text2
 *
 * @param text1 <String>
 * @param text2 <String>
 */
Changeset.fromDiff = function(diff) {
  /**
   * The data structure representing a diff is an array of tuples:
   * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
   * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
   */
  var DIFF_DELETE = -1;
  var DIFF_INSERT = 1;
  var DIFF_EQUAL = 0;

  var ops = []
    , removendum = ''
    , addendum = ''

  diff.forEach(function(d) {
    if (DIFF_DELETE == d[0]) {
      ops.push(new Skip(d[1].length))
      removendum += d[1]
    }

    if (DIFF_INSERT == d[0]) {
      ops.push(new Insert(d[1].length))
      addendum += d[1]
    }

    if(DIFF_EQUAL == d[0]) {
      ops.push(new Retain(d[1].length))
    }
  })

  var cs = new Changeset(ops)
  cs.addendum = addendum
  cs.removendum = removendum
  return cs
}


/***/ }),

/***/ "../structured-text-editor/node_modules/changesets/lib/ChangesetTransform.js":
/*!***********************************************************************************!*\
  !*** ../structured-text-editor/node_modules/changesets/lib/ChangesetTransform.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * changesets
 * A Changeset library incorporating operational ChangesetTransform (OT)
 * Copyright 2012 by Marcel Klehr <mklehr@gmx.net>
 *
 * (MIT LICENSE)
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var Retain = __webpack_require__(/*! ./operations/Retain */ "../structured-text-editor/node_modules/changesets/lib/operations/Retain.js")
  , Skip = __webpack_require__(/*! ./operations/Skip */ "../structured-text-editor/node_modules/changesets/lib/operations/Skip.js")
  , Insert = __webpack_require__(/*! ./operations/Insert */ "../structured-text-editor/node_modules/changesets/lib/operations/Insert.js")
  , Changeset = __webpack_require__(/*! ./Changeset */ "../structured-text-editor/node_modules/changesets/lib/Changeset.js")


function ChangesetTransform(inputCs, addendum) {
  this.output = []
  this.addendum = addendum
  this.newRemovendum = ''
  this.newAddendum = ''

  this.cs = inputCs
  this.pos = 0
  this.addendumPointer = 0
  this.removendumPointer = 0
}
module.exports = ChangesetTransform

ChangesetTransform.prototype.readInput = function (len) {
  var ret = this.cs.subrange(this.pos, len)
  this.pos += len
  return ret
}

ChangesetTransform.prototype.readAddendum = function (len) {
  //return [new Retain(len)]
  var ret = this.subrange(this.addendum, this.addendumPointer, len)
  this.addendumPointer += len
  return ret
}

ChangesetTransform.prototype.writeRemovendum = function (range) {
  range
    .filter(function(op) {return !op.output})
    .forEach(function(op) {
      this.removendumPointer += op.length
    }.bind(this))
}

ChangesetTransform.prototype.writeOutput = function (range) {
  this.output = this.output.concat(range)
  range
    .filter(function(op) {return !op.output})
    .forEach(function(op) {
      this.newRemovendum += this.cs.removendum.substr(this.removendumPointer, op.length)
      this.removendumPointer += op.length
    }.bind(this))
}

ChangesetTransform.prototype.subrange = function (range, start, len) {
  if(len) return this.cs.subrange.call(range, start, len)
  else return range.filter(function(op){ return !op.input})
}

ChangesetTransform.prototype.result = function() {
  this.writeOutput(this.readInput(Infinity))
  var newCs = new Changeset(this.output)
  newCs.addendum = this.cs.addendum
  newCs.removendum = this.newRemovendum
  return newCs
}


/***/ }),

/***/ "../structured-text-editor/node_modules/changesets/lib/Operator.js":
/*!*************************************************************************!*\
  !*** ../structured-text-editor/node_modules/changesets/lib/Operator.js ***!
  \*************************************************************************/
/***/ ((module) => {

function Operator() {
}

module.exports = Operator

Operator.prototype.clone = function() {
  return this.derive(this.length)
}

Operator.prototype.derive = function(len) {
  return new (this.constructor)(len)
}

Operator.prototype.pack = function() {
  return this.symbol + (this.length).toString(36)
}


/***/ }),

/***/ "../structured-text-editor/node_modules/changesets/lib/TextTransform.js":
/*!******************************************************************************!*\
  !*** ../structured-text-editor/node_modules/changesets/lib/TextTransform.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * changesets
 * A Changeset library incorporating operational Apply (OT)
 * Copyright 2012 by Marcel Klehr <mklehr@gmx.net>
 *
 * (MIT LICENSE)
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var Retain = __webpack_require__(/*! ./operations/Retain */ "../structured-text-editor/node_modules/changesets/lib/operations/Retain.js")
  , Skip = __webpack_require__(/*! ./operations/Skip */ "../structured-text-editor/node_modules/changesets/lib/operations/Skip.js")
  , Insert = __webpack_require__(/*! ./operations/Insert */ "../structured-text-editor/node_modules/changesets/lib/operations/Insert.js")
  , Insert = __webpack_require__(/*! ./Changeset */ "../structured-text-editor/node_modules/changesets/lib/Changeset.js")


function TextTransform(input, addendum, removendum) {
  this.output = ''

  this.input = input
  this.addendum = addendum
  this.removendum = removendum
  this.pos = 0
  this.addPos = 0
  this.remPos = 0
}
module.exports = TextTransform

TextTransform.prototype.readInput = function (len) {
  var ret = this.input.substr(this.pos, len)
  this.pos += len
  return ret
}

TextTransform.prototype.readAddendum = function (len) {
  var ret = this.addendum.substr(this.addPos, len)
  this.addPos += len
  return ret
}

TextTransform.prototype.writeRemovendum = function (range) {
  //var expected = this.removendum.substr(this.remPos, range.length)
  //if(range != expected) throw new Error('Removed chars don\'t match removendum. expected: '+expected+'; actual: '+range)
  this.remPos += range.length
}

TextTransform.prototype.writeOutput = function (range) {
  this.output += range
}

TextTransform.prototype.subrange = function (range, start, len) {
  return range.substr(start, len)
}

TextTransform.prototype.result = function() {
  this.writeOutput(this.readInput(Infinity))
  return this.output
}


/***/ }),

/***/ "../structured-text-editor/node_modules/changesets/lib/index.js":
/*!**********************************************************************!*\
  !*** ../structured-text-editor/node_modules/changesets/lib/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*!
 * changesets
 * A Changeset library incorporating operational transformation (OT)
 * Copyright 2012 by Marcel Klehr <mklehr@gmx.net>
 *
 * (MIT LICENSE)
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var Changeset = __webpack_require__(/*! ./Changeset */ "../structured-text-editor/node_modules/changesets/lib/Changeset.js")
  , Retain = __webpack_require__(/*! ./operations/Retain */ "../structured-text-editor/node_modules/changesets/lib/operations/Retain.js")
  , Skip = __webpack_require__(/*! ./operations/Skip */ "../structured-text-editor/node_modules/changesets/lib/operations/Skip.js")
  , Insert = __webpack_require__(/*! ./operations/Insert */ "../structured-text-editor/node_modules/changesets/lib/operations/Insert.js")

exports.Operator = __webpack_require__(/*! ./Operator */ "../structured-text-editor/node_modules/changesets/lib/Operator.js")
exports.Changeset = Changeset
exports.Insert = Insert
exports.Retain = Retain
exports.Skip = Skip

if('undefined' != typeof window) window.changesets = exports

/**
 * Serializes the given changeset in order to return a (hopefully) more compact representation
 * that can be sent through a network or stored in a database
 * @alias cs.text.Changeset#pack
 */
exports.pack = function(cs) {
  return cs.pack()
}

/**
 * Unserializes the output of cs.text.pack
 * @alias cs.text.Changeset.unpack
 */
exports.unpack = function(packed) {
  return Changeset.unpack(packed)
}




/**
 * shareJS ot type API sepc support
 */

exports.name = 'changesets'
exports.url = 'https://github.com/marcelklehr/changesets'

/**
 * create([initialText])
 *
 * creates a snapshot (optionally with supplied intial text)
 */
exports.create = function(initText) {
  return initText || ''
}

/**
 * Apply a changeset on a snapshot creating a new one
 *
 * The old snapshot object mustn't be used after calling apply on it
 * returns the resulting
 */
exports.apply = function(snapshot, op) {
  op = exports.unpack(op)
  return op.apply(snapshot)
}

/**
 * Transform changeset1 against changeset2
 */
exports.transform = function (op1, op2, side) {
  op1 = exports.unpack(op1)
  op2 = exports.unpack(op2)
  return exports.pack(op1.transformAgainst(op2, ('left'==side)))
}

/**
 * Merge two changesets into one
 */
exports.compose = function (op1, op2) {
  op1 = exports.unpack(op1)
  op2 = exports.unpack(op2)
  return exports.pack(op1.merge(op2))
}

/**
 * Invert a changeset
 */
exports.invert = function(op) {
  return exports.pack(exports.unpack(op).invert())
}


/***/ }),

/***/ "../structured-text-editor/node_modules/changesets/lib/operations/Insert.js":
/*!**********************************************************************************!*\
  !*** ../structured-text-editor/node_modules/changesets/lib/operations/Insert.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * changesets
 * A Changeset library incorporating operational transformation (OT)
 * Copyright 2012 by Marcel Klehr <mklehr@gmx.net>
 *
 * (MIT LICENSE)
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var Operator = __webpack_require__(/*! ../Operator */ "../structured-text-editor/node_modules/changesets/lib/Operator.js")

/**
 * Insert Operator
 * Defined by:
 * - length
 * - input=0
 * - output=length
 *
 * @param length <Number> How many chars to be inserted
 */
function Insert(length) {
  this.length = length
  this.input = 0
  this.output = length
}

// True inheritance
Insert.prototype = Object.create(Operator.prototype, {
  constructor: {
    value: Insert,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
module.exports = Insert
Insert.prototype.symbol = '+'

var Skip = __webpack_require__(/*! ./Skip */ "../structured-text-editor/node_modules/changesets/lib/operations/Skip.js")
  , Retain = __webpack_require__(/*! ./Retain */ "../structured-text-editor/node_modules/changesets/lib/operations/Retain.js")

Insert.prototype.apply = function(t) {
  t.writeOutput(t.readAddendum(this.output))
}

Insert.prototype.merge = function() {
  return this
}

Insert.prototype.invert = function() {
  return new Skip(this.length)
}

Insert.unpack = function(data) {
  return new Insert(parseInt(data, 36))
}


/***/ }),

/***/ "../structured-text-editor/node_modules/changesets/lib/operations/Retain.js":
/*!**********************************************************************************!*\
  !*** ../structured-text-editor/node_modules/changesets/lib/operations/Retain.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * changesets
 * A Changeset library incorporating operational transformation (OT)
 * Copyright 2012 by Marcel Klehr <mklehr@gmx.net>
 *
 * (MIT LICENSE)
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var Operator = __webpack_require__(/*! ../Operator */ "../structured-text-editor/node_modules/changesets/lib/Operator.js")

/**
 * Retain Operator
 * Defined by:
 * - length
 * - input=output=length
 *
 * @param length <Number> How many chars to retain
 */
function Retain(length) {
  this.length = length
  this.input = length
  this.output = length
}

// True inheritance
Retain.prototype = Object.create(Operator.prototype, {
  constructor: {
    value: Retain,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
module.exports = Retain
Retain.prototype.symbol = '='

Retain.prototype.apply = function(t) {
  t.writeOutput(t.readInput(this.input))
}

Retain.prototype.invert = function() {
  return this
}

Retain.prototype.merge = function(op2) {
  return this
}

Retain.unpack = function(data) {
  return new Retain(parseInt(data, 36))
}


/***/ }),

/***/ "../structured-text-editor/node_modules/changesets/lib/operations/Skip.js":
/*!********************************************************************************!*\
  !*** ../structured-text-editor/node_modules/changesets/lib/operations/Skip.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * changesets
 * A Changeset library incorporating operational transformation (OT)
 * Copyright 2012 by Marcel Klehr <mklehr@gmx.net>
 *
 * (MIT LICENSE)
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var Operator = __webpack_require__(/*! ../Operator */ "../structured-text-editor/node_modules/changesets/lib/Operator.js")

/**
 * Skip Operator
 * Defined by:
 * - length
 * - input=length
 * - output=0
 *
 * @param length <Number> How many chars to be Skip
 */
function Skip(length) {
  this.length = length
  this.input = length
  this.output = 0
}

// True inheritance
Skip.prototype = Object.create(Operator.prototype, {
  constructor: {
    value: Skip,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
module.exports = Skip
Skip.prototype.symbol = '-'

var Insert = __webpack_require__(/*! ./Insert */ "../structured-text-editor/node_modules/changesets/lib/operations/Insert.js")
  , Retain = __webpack_require__(/*! ./Retain */ "../structured-text-editor/node_modules/changesets/lib/operations/Retain.js")
  , Changeset = __webpack_require__(/*! ../Changeset */ "../structured-text-editor/node_modules/changesets/lib/Changeset.js")

Skip.prototype.apply = function(t) {
  var input = t.readInput(this.input)
  t.writeRemovendum(input)
  t.writeOutput(t.subrange(input, 0, this.output)) // retain Inserts in my range
}

Skip.prototype.merge = function(op2) {
  return this
}

Skip.prototype.invert = function() {
  return new Insert(this.length)
}

Skip.unpack = function(data) {
  return new Skip(parseInt(data, 36))
}


/***/ }),

/***/ "../structured-text-editor/node_modules/diff_match_patch/lib/diff_match_patch.js":
/*!***************************************************************************************!*\
  !*** ../structured-text-editor/node_modules/diff_match_patch/lib/diff_match_patch.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

/**
 * Diff Match and Patch
 *
 * Copyright 2006 Google Inc.
 * http://code.google.com/p/google-diff-match-patch/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview Computes the difference between two texts to create a patch.
 * Applies the patch onto another text, allowing for errors.
 * @author fraser@google.com (Neil Fraser)
 */

/**
 * Class containing the diff, match and patch methods.
 * @constructor
 */
function diff_match_patch() {

  // Defaults.
  // Redefine these in your program to override the defaults.

  // Number of seconds to map a diff before giving up (0 for infinity).
  this.Diff_Timeout = 1.0;
  // Cost of an empty edit operation in terms of edit characters.
  this.Diff_EditCost = 4;
  // The size beyond which the double-ended diff activates.
  // Double-ending is twice as fast, but less accurate.
  this.Diff_DualThreshold = 32;
  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).
  this.Match_Threshold = 0.5;
  // How far to search for a match (0 = exact location, 1000+ = broad match).
  // A match this many characters away from the expected location will add
  // 1.0 to the score (0.0 is a perfect match).
  this.Match_Distance = 1000;
  // When deleting a large block of text (over ~64 characters), how close does
  // the contents have to match the expected contents. (0.0 = perfection,
  // 1.0 = very loose).  Note that Match_Threshold controls how closely the
  // end points of a delete need to match.
  this.Patch_DeleteThreshold = 0.5;
  // Chunk size for context length.
  this.Patch_Margin = 4;

  /**
   * Compute the number of bits in an int.
   * The normal answer for JavaScript is 32.
   * @return {number} Max bits
   */
  function getMaxBits() {
    var maxbits = 0;
    var oldi = 1;
    var newi = 2;
    while (oldi != newi) {
      maxbits++;
      oldi = newi;
      newi = newi << 1;
    }
    return maxbits;
  }
  // How many bits in a number?
  this.Match_MaxBits = getMaxBits();
}


//  DIFF FUNCTIONS


/**
 * The data structure representing a diff is an array of tuples:
 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
 */
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;


/**
 * Find the differences between two texts.  Simplifies the problem by stripping
 * any common prefix or suffix off the texts before diffing.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {boolean} opt_checklines Optional speedup flag.  If present and false,
 *     then don't run a line-level diff first to identify the changed areas.
 *     Defaults to true, which does a faster, slightly less optimal diff
 * @return {Array.<Array.<number|string>>} Array of diff tuples.
 */
diff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines) {
  // Check for null inputs.
  if (text1 == null || text2 == null) {
    throw new Error('Null input. (diff_main)');
  }

  // Check for equality (speedup).
  if (text1 == text2) {
    return [[DIFF_EQUAL, text1]];
  }

  if (typeof opt_checklines == 'undefined') {
    opt_checklines = true;
  }
  var checklines = opt_checklines;

  // Trim off common prefix (speedup).
  var commonlength = this.diff_commonPrefix(text1, text2);
  var commonprefix = text1.substring(0, commonlength);
  text1 = text1.substring(commonlength);
  text2 = text2.substring(commonlength);

  // Trim off common suffix (speedup).
  commonlength = this.diff_commonSuffix(text1, text2);
  var commonsuffix = text1.substring(text1.length - commonlength);
  text1 = text1.substring(0, text1.length - commonlength);
  text2 = text2.substring(0, text2.length - commonlength);

  // Compute the diff on the middle block.
  var diffs = this.diff_compute(text1, text2, checklines);

  // Restore the prefix and suffix.
  if (commonprefix) {
    diffs.unshift([DIFF_EQUAL, commonprefix]);
  }
  if (commonsuffix) {
    diffs.push([DIFF_EQUAL, commonsuffix]);
  }
  this.diff_cleanupMerge(diffs);
  return diffs;
};


/**
 * Find the differences between two texts.  Assumes that the texts do not
 * have any common prefix or suffix.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {boolean} checklines Speedup flag.  If false, then don't run a
 *     line-level diff first to identify the changed areas.
 *     If true, then run a faster, slightly less optimal diff
 * @return {Array.<Array.<number|string>>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_compute = function(text1, text2, checklines) {
  var diffs;

  if (!text1) {
    // Just add some text (speedup).
    return [[DIFF_INSERT, text2]];
  }

  if (!text2) {
    // Just delete some text (speedup).
    return [[DIFF_DELETE, text1]];
  }

  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  var i = longtext.indexOf(shorttext);
  if (i != -1) {
    // Shorter text is inside the longer text (speedup).
    diffs = [[DIFF_INSERT, longtext.substring(0, i)],
             [DIFF_EQUAL, shorttext],
             [DIFF_INSERT, longtext.substring(i + shorttext.length)]];
    // Swap insertions for deletions if diff is reversed.
    if (text1.length > text2.length) {
      diffs[0][0] = diffs[2][0] = DIFF_DELETE;
    }
    return diffs;
  }
  longtext = shorttext = null;  // Garbage collect.

  // Check to see if the problem can be split in two.
  var hm = this.diff_halfMatch(text1, text2);
  if (hm) {
    // A half-match was found, sort out the return data.
    var text1_a = hm[0];
    var text1_b = hm[1];
    var text2_a = hm[2];
    var text2_b = hm[3];
    var mid_common = hm[4];
    // Send both pairs off for separate processing.
    var diffs_a = this.diff_main(text1_a, text2_a, checklines);
    var diffs_b = this.diff_main(text1_b, text2_b, checklines);
    // Merge the results.
    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
  }

  // Perform a real diff.
  if (checklines && (text1.length < 100 || text2.length < 100)) {
    // Too trivial for the overhead.
    checklines = false;
  }
  var linearray;
  if (checklines) {
    // Scan the text on a line-by-line basis first.
    var a = this.diff_linesToChars(text1, text2);
    text1 = a[0];
    text2 = a[1];
    linearray = a[2];
  }
  diffs = this.diff_map(text1, text2);
  if (!diffs) {
    // No acceptable result.
    diffs = [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
  }
  if (checklines) {
    // Convert the diff back to original text.
    this.diff_charsToLines(diffs, linearray);
    // Eliminate freak matches (e.g. blank lines)
    this.diff_cleanupSemantic(diffs);

    // Rediff any replacement blocks, this time character-by-character.
    // Add a dummy entry at the end.
    diffs.push([DIFF_EQUAL, '']);
    var pointer = 0;
    var count_delete = 0;
    var count_insert = 0;
    var text_delete = '';
    var text_insert = '';
    while (pointer < diffs.length) {
      switch (diffs[pointer][0]) {
        case DIFF_INSERT:
          count_insert++;
          text_insert += diffs[pointer][1];
          break;
        case DIFF_DELETE:
          count_delete++;
          text_delete += diffs[pointer][1];
          break;
        case DIFF_EQUAL:
          // Upon reaching an equality, check for prior redundancies.
          if (count_delete >= 1 && count_insert >= 1) {
            // Delete the offending records and add the merged ones.
            var a = this.diff_main(text_delete, text_insert, false);
            diffs.splice(pointer - count_delete - count_insert,
                         count_delete + count_insert);
            pointer = pointer - count_delete - count_insert;
            for (var j = a.length - 1; j >= 0; j--) {
              diffs.splice(pointer, 0, a[j]);
            }
            pointer = pointer + a.length;
          }
          count_insert = 0;
          count_delete = 0;
          text_delete = '';
          text_insert = '';
          break;
      }
     pointer++;
    }
    diffs.pop();  // Remove the dummy entry at the end.
  }
  return diffs;
};


/**
 * Split two texts into an array of strings.  Reduce the texts to a string of
 * hashes where each Unicode character represents one line.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {Array.<string|Array.<string>>} Three element Array, containing the
 *     encoded text1, the encoded text2 and the array of unique strings.  The
 *     zeroth element of the array of unique strings is intentionally blank.
 * @private
 */
diff_match_patch.prototype.diff_linesToChars = function(text1, text2) {
  var lineArray = [];  // e.g. lineArray[4] == 'Hello\n'
  var lineHash = {};   // e.g. lineHash['Hello\n'] == 4

  // '\x00' is a valid character, but various debuggers don't like it.
  // So we'll insert a junk entry to avoid generating a null character.
  lineArray[0] = '';

  /**
   * Split a text into an array of strings.  Reduce the texts to a string of
   * hashes where each Unicode character represents one line.
   * Modifies linearray and linehash through being a closure.
   * @param {string} text String to encode.
   * @return {string} Encoded string.
   * @private
   */
  function diff_linesToCharsMunge(text) {
    var chars = '';
    // Walk the text, pulling out a substring for each line.
    // text.split('\n') would would temporarily double our memory footprint.
    // Modifying text would create many large strings to garbage collect.
    var lineStart = 0;
    var lineEnd = -1;
    // Keeping our own length variable is faster than looking it up.
    var lineArrayLength = lineArray.length;
    while (lineEnd < text.length - 1) {
      lineEnd = text.indexOf('\n', lineStart);
      if (lineEnd == -1) {
        lineEnd = text.length - 1;
      }
      var line = text.substring(lineStart, lineEnd + 1);
      lineStart = lineEnd + 1;

      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :
          (lineHash[line] !== undefined)) {
        chars += String.fromCharCode(lineHash[line]);
      } else {
        chars += String.fromCharCode(lineArrayLength);
        lineHash[line] = lineArrayLength;
        lineArray[lineArrayLength++] = line;
      }
    }
    return chars;
  }

  var chars1 = diff_linesToCharsMunge(text1);
  var chars2 = diff_linesToCharsMunge(text2);
  return [chars1, chars2, lineArray];
};


/**
 * Rehydrate the text in a diff from a string of line hashes to real lines of
 * text.
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 * @param {Array.<string>} lineArray Array of unique strings.
 * @private
 */
diff_match_patch.prototype.diff_charsToLines = function(diffs, lineArray) {
  for (var x = 0; x < diffs.length; x++) {
    var chars = diffs[x][1];
    var text = [];
    for (var y = 0; y < chars.length; y++) {
      text[y] = lineArray[chars.charCodeAt(y)];
    }
    diffs[x][1] = text.join('');
  }
};


/**
 * Explore the intersection points between the two texts.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @return {?Array.<Array.<number|string>>} Array of diff tuples or null if no
 *     diff available.
 * @private
 */
diff_match_patch.prototype.diff_map = function(text1, text2) {
  // Don't run for too long.
  var ms_end = (new Date()).getTime() + this.Diff_Timeout * 1000;
  // Cache the text lengths to prevent multiple calls.
  var text1_length = text1.length;
  var text2_length = text2.length;
  var max_d = text1_length + text2_length - 1;
  var doubleEnd = this.Diff_DualThreshold * 2 < max_d;
  // JavaScript efficiency note: (x << 32) + y doesn't work since numbers are
  // only 32 bit.  Use x + ',' + y to create a hash instead.
  var v_map1 = [];
  var v_map2 = [];
  var v1 = {};
  var v2 = {};
  v1[1] = 0;
  v2[1] = 0;
  var x, y;
  var footstep;  // Used to track overlapping paths.
  var footsteps = {};
  var done = false;
  // If the total number of characters is odd, then the front path will collide
  // with the reverse path.
  var front = (text1_length + text2_length) % 2;
  for (var d = 0; d < max_d; d++) {
    // Bail out if timeout reached.
    if (this.Diff_Timeout > 0 && (new Date()).getTime() > ms_end) {
      return null;
    }

    // Walk the front path one step.
    v_map1[d] = {};
    for (var k = -d; k <= d; k += 2) {
      if (k == -d || k != d && v1[k - 1] < v1[k + 1]) {
        x = v1[k + 1];
      } else {
        x = v1[k - 1] + 1;
      }
      y = x - k;
      if (doubleEnd) {
        footstep = x + ',' + y;
        if (front && footsteps[footstep] !== undefined) {
          done = true;
        }
        if (!front) {
          footsteps[footstep] = d;
        }
      }
      while (!done && x < text1_length && y < text2_length &&
             text1.charAt(x) == text2.charAt(y)) {
        x++;
        y++;
        if (doubleEnd) {
          footstep = x + ',' + y;
          if (front && footsteps[footstep] !== undefined) {
            done = true;
          }
          if (!front) {
            footsteps[footstep] = d;
          }
        }
      }
      v1[k] = x;
      v_map1[d][x + ',' + y] = true;
      if (x == text1_length && y == text2_length) {
        // Reached the end in single-path mode.
        return this.diff_path1(v_map1, text1, text2);
      } else if (done) {
        // Front path ran over reverse path.
        v_map2 = v_map2.slice(0, footsteps[footstep] + 1);
        var a = this.diff_path1(v_map1, text1.substring(0, x),
                                text2.substring(0, y));
        return a.concat(this.diff_path2(v_map2, text1.substring(x),
                                        text2.substring(y)));
      }
    }

    if (doubleEnd) {
      // Walk the reverse path one step.
      v_map2[d] = {};
      for (var k = -d; k <= d; k += 2) {
        if (k == -d || k != d && v2[k - 1] < v2[k + 1]) {
          x = v2[k + 1];
        } else {
          x = v2[k - 1] + 1;
        }
        y = x - k;
        footstep = (text1_length - x) + ',' + (text2_length - y);
        if (!front && footsteps[footstep] !== undefined) {
          done = true;
        }
        if (front) {
          footsteps[footstep] = d;
        }
        while (!done && x < text1_length && y < text2_length &&
               text1.charAt(text1_length - x - 1) ==
               text2.charAt(text2_length - y - 1)) {
          x++;
          y++;
          footstep = (text1_length - x) + ',' + (text2_length - y);
          if (!front && footsteps[footstep] !== undefined) {
            done = true;
          }
          if (front) {
            footsteps[footstep] = d;
          }
        }
        v2[k] = x;
        v_map2[d][x + ',' + y] = true;
        if (done) {
          // Reverse path ran over front path.
          v_map1 = v_map1.slice(0, footsteps[footstep] + 1);
          var a = this.diff_path1(v_map1, text1.substring(0, text1_length - x),
                                  text2.substring(0, text2_length - y));
          return a.concat(this.diff_path2(v_map2,
                          text1.substring(text1_length - x),
                          text2.substring(text2_length - y)));
        }
      }
    }
  }
  // Number of diffs equals number of characters, no commonality at all.
  return null;
};


/**
 * Work from the middle back to the start to determine the path.
 * @param {Array.<Object>} v_map Array of paths.
 * @param {string} text1 Old string fragment to be diffed.
 * @param {string} text2 New string fragment to be diffed.
 * @return {Array.<Array.<number|string>>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_path1 = function(v_map, text1, text2) {
  var path = [];
  var x = text1.length;
  var y = text2.length;
  /** @type {?number} */
  var last_op = null;
  for (var d = v_map.length - 2; d >= 0; d--) {
    while (1) {
      if (v_map[d][(x - 1) + ',' + y] !== undefined) {
        x--;
        if (last_op === DIFF_DELETE) {
          path[0][1] = text1.charAt(x) + path[0][1];
        } else {
          path.unshift([DIFF_DELETE, text1.charAt(x)]);
        }
        last_op = DIFF_DELETE;
        break;
      } else if (v_map[d][x + ',' + (y - 1)] !== undefined) {
        y--;
        if (last_op === DIFF_INSERT) {
          path[0][1] = text2.charAt(y) + path[0][1];
        } else {
          path.unshift([DIFF_INSERT, text2.charAt(y)]);
        }
        last_op = DIFF_INSERT;
        break;
      } else {
        x--;
        y--;
        if (text1.charAt(x) != text2.charAt(y)) {
          throw new Error('No diagonal.  Can\'t happen. (diff_path1)');
        }
        if (last_op === DIFF_EQUAL) {
          path[0][1] = text1.charAt(x) + path[0][1];
        } else {
          path.unshift([DIFF_EQUAL, text1.charAt(x)]);
        }
        last_op = DIFF_EQUAL;
      }
    }
  }
  return path;
};


/**
 * Work from the middle back to the end to determine the path.
 * @param {Array.<Object>} v_map Array of paths.
 * @param {string} text1 Old string fragment to be diffed.
 * @param {string} text2 New string fragment to be diffed.
 * @return {Array.<Array.<number|string>>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_path2 = function(v_map, text1, text2) {
  var path = [];
  var pathLength = 0;
  var x = text1.length;
  var y = text2.length;
  /** @type {?number} */
  var last_op = null;
  for (var d = v_map.length - 2; d >= 0; d--) {
    while (1) {
      if (v_map[d][(x - 1) + ',' + y] !== undefined) {
        x--;
        if (last_op === DIFF_DELETE) {
          path[pathLength - 1][1] += text1.charAt(text1.length - x - 1);
        } else {
          path[pathLength++] =
              [DIFF_DELETE, text1.charAt(text1.length - x - 1)];
        }
        last_op = DIFF_DELETE;
        break;
      } else if (v_map[d][x + ',' + (y - 1)] !== undefined) {
        y--;
        if (last_op === DIFF_INSERT) {
          path[pathLength - 1][1] += text2.charAt(text2.length - y - 1);
        } else {
          path[pathLength++] =
              [DIFF_INSERT, text2.charAt(text2.length - y - 1)];
        }
        last_op = DIFF_INSERT;
        break;
      } else {
        x--;
        y--;
        if (text1.charAt(text1.length - x - 1) !=
            text2.charAt(text2.length - y - 1)) {
          throw new Error('No diagonal.  Can\'t happen. (diff_path2)');
        }
        if (last_op === DIFF_EQUAL) {
          path[pathLength - 1][1] += text1.charAt(text1.length - x - 1);
        } else {
          path[pathLength++] =
              [DIFF_EQUAL, text1.charAt(text1.length - x - 1)];
        }
        last_op = DIFF_EQUAL;
      }
    }
  }
  return path;
};


/**
 * Determine the common prefix of two strings
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the start of each
 *     string.
 */
diff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerstart = 0;
  while (pointermin < pointermid) {
    if (text1.substring(pointerstart, pointermid) ==
        text2.substring(pointerstart, pointermid)) {
      pointermin = pointermid;
      pointerstart = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Determine the common suffix of two strings
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of each string.
 */
diff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 || text1.charAt(text1.length - 1) !=
                          text2.charAt(text2.length - 1)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerend = 0;
  while (pointermin < pointermid) {
    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
        text2.substring(text2.length - pointermid, text2.length - pointerend)) {
      pointermin = pointermid;
      pointerend = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Do the two texts share a substring which is at least half the length of the
 * longer text?
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {?Array.<string>} Five element Array, containing the prefix of
 *     text1, the suffix of text1, the prefix of text2, the suffix of
 *     text2 and the common middle.  Or null if there was no match.
 */
diff_match_patch.prototype.diff_halfMatch = function(text1, text2) {
  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  if (longtext.length < 10 || shorttext.length < 1) {
    return null;  // Pointless.
  }
  var dmp = this;  // 'this' becomes 'window' in a closure.

  /**
   * Does a substring of shorttext exist within longtext such that the substring
   * is at least half the length of longtext?
   * Closure, but does not reference any external variables.
   * @param {string} longtext Longer string.
   * @param {string} shorttext Shorter string.
   * @param {number} i Start index of quarter length substring within longtext
   * @return {?Array.<string>} Five element Array, containing the prefix of
   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
   *     of shorttext and the common middle.  Or null if there was no match.
   * @private
   */
  function diff_halfMatchI(longtext, shorttext, i) {
    // Start with a 1/4 length substring at position i as a seed.
    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
    var j = -1;
    var best_common = '';
    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),
                                               shorttext.substring(j));
      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),
                                               shorttext.substring(0, j));
      if (best_common.length < suffixLength + prefixLength) {
        best_common = shorttext.substring(j - suffixLength, j) +
            shorttext.substring(j, j + prefixLength);
        best_longtext_a = longtext.substring(0, i - suffixLength);
        best_longtext_b = longtext.substring(i + prefixLength);
        best_shorttext_a = shorttext.substring(0, j - suffixLength);
        best_shorttext_b = shorttext.substring(j + prefixLength);
      }
    }
    if (best_common.length >= longtext.length / 2) {
      return [best_longtext_a, best_longtext_b,
              best_shorttext_a, best_shorttext_b, best_common];
    } else {
      return null;
    }
  }

  // First check if the second quarter is the seed for a half-match.
  var hm1 = diff_halfMatchI(longtext, shorttext,
                            Math.ceil(longtext.length / 4));
  // Check again based on the third quarter.
  var hm2 = diff_halfMatchI(longtext, shorttext,
                            Math.ceil(longtext.length / 2));
  var hm;
  if (!hm1 && !hm2) {
    return null;
  } else if (!hm2) {
    hm = hm1;
  } else if (!hm1) {
    hm = hm2;
  } else {
    // Both matched.  Select the longest.
    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
  }

  // A half-match was found, sort out the return data.
  var text1_a, text1_b, text2_a, text2_b;
  if (text1.length > text2.length) {
    text1_a = hm[0];
    text1_b = hm[1];
    text2_a = hm[2];
    text2_b = hm[3];
  } else {
    text2_a = hm[0];
    text2_b = hm[1];
    text1_a = hm[2];
    text1_b = hm[3];
  }
  var mid_common = hm[4];
  return [text1_a, text1_b, text2_a, text2_b, mid_common];
};


/**
 * Reduce the number of edits by eliminating semantically trivial equalities.
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {
  var changes = false;
  var equalities = [];  // Stack of indices where equalities are found.
  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
  var lastequality = null;  // Always equal to equalities[equalitiesLength-1][1]
  var pointer = 0;  // Index of current position.
  // Number of characters that changed prior to the equality.
  var length_changes1 = 0;
  // Number of characters that changed after the equality.
  var length_changes2 = 0;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {  // equality found
      equalities[equalitiesLength++] = pointer;
      length_changes1 = length_changes2;
      length_changes2 = 0;
      lastequality = diffs[pointer][1];
    } else {  // an insertion or deletion
      length_changes2 += diffs[pointer][1].length;
      if (lastequality !== null && (lastequality.length <= length_changes1) &&
          (lastequality.length <= length_changes2)) {
        // Duplicate record
        diffs.splice(equalities[equalitiesLength - 1], 0,
                     [DIFF_DELETE, lastequality]);
        // Change second copy to insert.
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        // Throw away the equality we just deleted.
        equalitiesLength--;
        // Throw away the previous equality (it needs to be reevaluated).
        equalitiesLength--;
        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
        length_changes1 = 0;  // Reset the counters.
        length_changes2 = 0;
        lastequality = null;
        changes = true;
      }
    }
    pointer++;
  }
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
  this.diff_cleanupSemanticLossless(diffs);
};


/**
 * Look for single edits surrounded on both sides by equalities
 * which can be shifted sideways to align the edit to a word boundary.
 * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {
  // Define some regex patterns for matching boundaries.
  var punctuation = /[^a-zA-Z0-9]/;
  var whitespace = /\s/;
  var linebreak = /[\r\n]/;
  var blanklineEnd = /\n\r?\n$/;
  var blanklineStart = /^\r?\n\r?\n/;

  /**
   * Given two strings, compute a score representing whether the internal
   * boundary falls on logical boundaries.
   * Scores range from 5 (best) to 0 (worst).
   * Closure, makes reference to regex patterns defined above.
   * @param {string} one First string.
   * @param {string} two Second string.
   * @return {number} The score.
   */
  function diff_cleanupSemanticScore(one, two) {
    if (!one || !two) {
      // Edges are the best.
      return 5;
    }

    // Each port of this function behaves slightly differently due to
    // subtle differences in each language's definition of things like
    // 'whitespace'.  Since this function's purpose is largely cosmetic,
    // the choice has been made to use each language's native features
    // rather than force total conformity.
    var score = 0;
    // One point for non-alphanumeric.
    if (one.charAt(one.length - 1).match(punctuation) ||
        two.charAt(0).match(punctuation)) {
      score++;
      // Two points for whitespace.
      if (one.charAt(one.length - 1).match(whitespace) ||
          two.charAt(0).match(whitespace)) {
        score++;
        // Three points for line breaks.
        if (one.charAt(one.length - 1).match(linebreak) ||
            two.charAt(0).match(linebreak)) {
          score++;
          // Four points for blank lines.
          if (one.match(blanklineEnd) || two.match(blanklineStart)) {
            score++;
          }
        }
      }
    }
    return score;
  }

  var pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
        diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      var equality1 = diffs[pointer - 1][1];
      var edit = diffs[pointer][1];
      var equality2 = diffs[pointer + 1][1];

      // First, shift the edit as far left as possible.
      var commonOffset = this.diff_commonSuffix(equality1, edit);
      if (commonOffset) {
        var commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset);
        edit = commonString + edit.substring(0, edit.length - commonOffset);
        equality2 = commonString + equality2;
      }

      // Second, step character by character right, looking for the best fit.
      var bestEquality1 = equality1;
      var bestEdit = edit;
      var bestEquality2 = equality2;
      var bestScore = diff_cleanupSemanticScore(equality1, edit) +
          diff_cleanupSemanticScore(edit, equality2);
      while (edit.charAt(0) === equality2.charAt(0)) {
        equality1 += edit.charAt(0);
        edit = edit.substring(1) + equality2.charAt(0);
        equality2 = equality2.substring(1);
        var score = diff_cleanupSemanticScore(equality1, edit) +
            diff_cleanupSemanticScore(edit, equality2);
        // The >= encourages trailing rather than leading whitespace on edits.
        if (score >= bestScore) {
          bestScore = score;
          bestEquality1 = equality1;
          bestEdit = edit;
          bestEquality2 = equality2;
        }
      }

      if (diffs[pointer - 1][1] != bestEquality1) {
        // We have an improvement, save it back to the diff.
        if (bestEquality1) {
          diffs[pointer - 1][1] = bestEquality1;
        } else {
          diffs.splice(pointer - 1, 1);
          pointer--;
        }
        diffs[pointer][1] = bestEdit;
        if (bestEquality2) {
          diffs[pointer + 1][1] = bestEquality2;
        } else {
          diffs.splice(pointer + 1, 1);
          pointer--;
        }
      }
    }
    pointer++;
  }
};


/**
 * Reduce the number of edits by eliminating operationally trivial equalities.
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {
  var changes = false;
  var equalities = [];  // Stack of indices where equalities are found.
  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
  var lastequality = '';  // Always equal to equalities[equalitiesLength-1][1]
  var pointer = 0;  // Index of current position.
  // Is there an insertion operation before the last equality.
  var pre_ins = false;
  // Is there a deletion operation before the last equality.
  var pre_del = false;
  // Is there an insertion operation after the last equality.
  var post_ins = false;
  // Is there a deletion operation after the last equality.
  var post_del = false;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {  // equality found
      if (diffs[pointer][1].length < this.Diff_EditCost &&
          (post_ins || post_del)) {
        // Candidate found.
        equalities[equalitiesLength++] = pointer;
        pre_ins = post_ins;
        pre_del = post_del;
        lastequality = diffs[pointer][1];
      } else {
        // Not a candidate, and can never become one.
        equalitiesLength = 0;
        lastequality = '';
      }
      post_ins = post_del = false;
    } else {  // an insertion or deletion
      if (diffs[pointer][0] == DIFF_DELETE) {
        post_del = true;
      } else {
        post_ins = true;
      }
      /*
       * Five types to be split:
       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>
       * <ins>A</ins>X<ins>C</ins><del>D</del>
       * <ins>A</ins><del>B</del>X<ins>C</ins>
       * <ins>A</del>X<ins>C</ins><del>D</del>
       * <ins>A</ins><del>B</del>X<del>C</del>
       */
      if (lastequality && ((pre_ins && pre_del && post_ins && post_del) ||
                           ((lastequality.length < this.Diff_EditCost / 2) &&
                            (pre_ins + pre_del + post_ins + post_del) == 3))) {
        // Duplicate record
        diffs.splice(equalities[equalitiesLength - 1], 0,
                     [DIFF_DELETE, lastequality]);
        // Change second copy to insert.
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        equalitiesLength--;  // Throw away the equality we just deleted;
        lastequality = '';
        if (pre_ins && pre_del) {
          // No changes made which could affect previous entry, keep going.
          post_ins = post_del = true;
          equalitiesLength = 0;
        } else {
          equalitiesLength--;  // Throw away the previous equality;
          pointer = equalitiesLength > 0 ?
              equalities[equalitiesLength - 1] : -1;
          post_ins = post_del = false;
        }
        changes = true;
      }
    }
    pointer++;
  }

  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};


/**
 * Reorder and merge like edit sections.  Merge equalities.
 * Any edit section can move as long as it doesn't cross an equality.
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupMerge = function(diffs) {
  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = '';
  var text_insert = '';
  var commonlength;
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_EQUAL:
        // Upon reaching an equality, check for prior redundancies.
        if (count_delete !== 0 || count_insert !== 0) {
          if (count_delete !== 0 && count_insert !== 0) {
            // Factor out any common prefixies.
            commonlength = this.diff_commonPrefix(text_insert, text_delete);
            if (commonlength !== 0) {
              if ((pointer - count_delete - count_insert) > 0 &&
                  diffs[pointer - count_delete - count_insert - 1][0] ==
                  DIFF_EQUAL) {
                diffs[pointer - count_delete - count_insert - 1][1] +=
                    text_insert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, [DIFF_EQUAL,
                    text_insert.substring(0, commonlength)]);
                pointer++;
              }
              text_insert = text_insert.substring(commonlength);
              text_delete = text_delete.substring(commonlength);
            }
            // Factor out any common suffixies.
            commonlength = this.diff_commonSuffix(text_insert, text_delete);
            if (commonlength !== 0) {
              diffs[pointer][1] = text_insert.substring(text_insert.length -
                  commonlength) + diffs[pointer][1];
              text_insert = text_insert.substring(0, text_insert.length -
                  commonlength);
              text_delete = text_delete.substring(0, text_delete.length -
                  commonlength);
            }
          }
          // Delete the offending records and add the merged ones.
          if (count_delete === 0) {
            diffs.splice(pointer - count_delete - count_insert,
                count_delete + count_insert, [DIFF_INSERT, text_insert]);
          } else if (count_insert === 0) {
            diffs.splice(pointer - count_delete - count_insert,
                count_delete + count_insert, [DIFF_DELETE, text_delete]);
          } else {
            diffs.splice(pointer - count_delete - count_insert,
                count_delete + count_insert, [DIFF_DELETE, text_delete],
                [DIFF_INSERT, text_insert]);
          }
          pointer = pointer - count_delete - count_insert +
                    (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
          // Merge this equality with the previous one.
          diffs[pointer - 1][1] += diffs[pointer][1];
          diffs.splice(pointer, 1);
        } else {
          pointer++;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = '';
        text_insert = '';
        break;
    }
  }
  if (diffs[diffs.length - 1][1] === '') {
    diffs.pop();  // Remove the dummy entry at the end.
  }

  // Second pass: look for single edits surrounded on both sides by equalities
  // which can be shifted sideways to eliminate an equality.
  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
  var changes = false;
  pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
        diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      if (diffs[pointer][1].substring(diffs[pointer][1].length -
          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
        // Shift the edit over the previous equality.
        diffs[pointer][1] = diffs[pointer - 1][1] +
            diffs[pointer][1].substring(0, diffs[pointer][1].length -
                                        diffs[pointer - 1][1].length);
        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
        diffs.splice(pointer - 1, 1);
        changes = true;
      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
          diffs[pointer + 1][1]) {
        // Shift the edit over the next equality.
        diffs[pointer - 1][1] += diffs[pointer + 1][1];
        diffs[pointer][1] =
            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
            diffs[pointer + 1][1];
        diffs.splice(pointer + 1, 1);
        changes = true;
      }
    }
    pointer++;
  }
  // If shifts were made, the diff needs reordering and another shift sweep.
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};


/**
 * loc is a location in text1, compute and return the equivalent location in
 * text2.
 * e.g. 'The cat' vs 'The big cat', 1->1, 5->8
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 * @param {number} loc Location within text1.
 * @return {number} Location within text2.
 */
diff_match_patch.prototype.diff_xIndex = function(diffs, loc) {
  var chars1 = 0;
  var chars2 = 0;
  var last_chars1 = 0;
  var last_chars2 = 0;
  var x;
  for (x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.
      chars1 += diffs[x][1].length;
    }
    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.
      chars2 += diffs[x][1].length;
    }
    if (chars1 > loc) {  // Overshot the location.
      break;
    }
    last_chars1 = chars1;
    last_chars2 = chars2;
  }
  // Was the location was deleted?
  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {
    return last_chars2;
  }
  // Add the remaining character length.
  return last_chars2 + (loc - last_chars1);
};


/**
 * Convert a diff array into a pretty HTML report.
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 * @return {string} HTML representation.
 */
diff_match_patch.prototype.diff_prettyHtml = function(diffs) {
  var html = [];
  var i = 0;
  for (var x = 0; x < diffs.length; x++) {
    var op = diffs[x][0];    // Operation (insert, delete, equal)
    var data = diffs[x][1];  // Text of change.
    var text = data.replace(/&/g, '&amp;').replace(/</g, '&lt;')
        .replace(/>/g, '&gt;').replace(/\n/g, '&para;<BR>');
    switch (op) {
      case DIFF_INSERT:
        html[x] = '<INS STYLE="background:#E6FFE6;" TITLE="i=' + i + '">' +
                text + '</INS>';
        break;
      case DIFF_DELETE:
        html[x] = '<DEL STYLE="background:#FFE6E6;" TITLE="i=' + i + '">' +
                text + '</DEL>';
        break;
      case DIFF_EQUAL:
        html[x] = '<SPAN TITLE="i=' + i + '">' + text + '</SPAN>';
        break;
    }
    if (op !== DIFF_DELETE) {
      i += data.length;
    }
  }
  return html.join('');
};


/**
 * Compute and return the source text (all equalities and deletions).
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 * @return {string} Source text.
 */
diff_match_patch.prototype.diff_text1 = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {
      text[x] = diffs[x][1];
    }
  }
  return text.join('');
};


/**
 * Compute and return the destination text (all equalities and insertions).
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 * @return {string} Destination text.
 */
diff_match_patch.prototype.diff_text2 = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_DELETE) {
      text[x] = diffs[x][1];
    }
  }
  return text.join('');
};


/**
 * Compute the Levenshtein distance; the number of inserted, deleted or
 * substituted characters.
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 * @return {number} Number of changes.
 */
diff_match_patch.prototype.diff_levenshtein = function(diffs) {
  var levenshtein = 0;
  var insertions = 0;
  var deletions = 0;
  for (var x = 0; x < diffs.length; x++) {
    var op = diffs[x][0];
    var data = diffs[x][1];
    switch (op) {
      case DIFF_INSERT:
        insertions += data.length;
        break;
      case DIFF_DELETE:
        deletions += data.length;
        break;
      case DIFF_EQUAL:
        // A deletion and an insertion is one substitution.
        levenshtein += Math.max(insertions, deletions);
        insertions = 0;
        deletions = 0;
        break;
    }
  }
  levenshtein += Math.max(insertions, deletions);
  return levenshtein;
};


/**
 * Crush the diff into an encoded string which describes the operations
 * required to transform text1 into text2.
 * E.g. =3\t-2\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.
 * Operations are tab-separated.  Inserted text is escaped using %xx notation.
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 * @return {string} Delta text.
 */
diff_match_patch.prototype.diff_toDelta = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    switch (diffs[x][0]) {
      case DIFF_INSERT:
        text[x] = '+' + encodeURI(diffs[x][1]);
        break;
      case DIFF_DELETE:
        text[x] = '-' + diffs[x][1].length;
        break;
      case DIFF_EQUAL:
        text[x] = '=' + diffs[x][1].length;
        break;
    }
  }
  // Opera doesn't know how to encode char 0.
  return text.join('\t').replace(/\x00/g, '%00').replace(/%20/g, ' ');
};


/**
 * Given the original text1, and an encoded string which describes the
 * operations required to transform text1 into text2, compute the full diff.
 * @param {string} text1 Source string for the diff.
 * @param {string} delta Delta text.
 * @return {Array.<Array.<number|string>>} Array of diff tuples.
 * @throws {Error} If invalid input.
 */
diff_match_patch.prototype.diff_fromDelta = function(text1, delta) {
  var diffs = [];
  var diffsLength = 0;  // Keeping our own length var is faster in JS.
  var pointer = 0;  // Cursor in text1
  // Opera doesn't know how to decode char 0.
  delta = delta.replace(/%00/g, '\0');
  var tokens = delta.split(/\t/g);
  for (var x = 0; x < tokens.length; x++) {
    // Each token begins with a one character parameter which specifies the
    // operation of this token (delete, insert, equality).
    var param = tokens[x].substring(1);
    switch (tokens[x].charAt(0)) {
      case '+':
        try {
          diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)];
        } catch (ex) {
          // Malformed URI sequence.
          throw new Error('Illegal escape in diff_fromDelta: ' + param);
        }
        break;
      case '-':
        // Fall through.
      case '=':
        var n = parseInt(param, 10);
        if (isNaN(n) || n < 0) {
          throw new Error('Invalid number in diff_fromDelta: ' + param);
        }
        var text = text1.substring(pointer, pointer += n);
        if (tokens[x].charAt(0) == '=') {
          diffs[diffsLength++] = [DIFF_EQUAL, text];
        } else {
          diffs[diffsLength++] = [DIFF_DELETE, text];
        }
        break;
      default:
        // Blank tokens are ok (from a trailing \t).
        // Anything else is an error.
        if (tokens[x]) {
          throw new Error('Invalid diff operation in diff_fromDelta: ' +
                          tokens[x]);
        }
    }
  }
  if (pointer != text1.length) {
    throw new Error('Delta length (' + pointer +
        ') does not equal source text length (' + text1.length + ').');
  }
  return diffs;
};


//  MATCH FUNCTIONS


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc'.
 * @param {string} text The text to search.
 * @param {string} pattern The pattern to search for.
 * @param {number} loc The location to search around.
 * @return {number} Best match index or -1.
 */
diff_match_patch.prototype.match_main = function(text, pattern, loc) {
  // Check for null inputs.
  if (text == null || pattern == null || loc == null) {
    throw new Error('Null input. (match_main)');
  }

  loc = Math.max(0, Math.min(loc, text.length));
  if (text == pattern) {
    // Shortcut (potentially not guaranteed by the algorithm)
    return 0;
  } else if (!text.length) {
    // Nothing to match.
    return -1;
  } else if (text.substring(loc, loc + pattern.length) == pattern) {
    // Perfect match at the perfect spot!  (Includes case of null pattern)
    return loc;
  } else {
    // Do a fuzzy compare.
    return this.match_bitap(text, pattern, loc);
  }
};


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc' using the
 * Bitap algorithm.
 * @param {string} text The text to search.
 * @param {string} pattern The pattern to search for.
 * @param {number} loc The location to search around.
 * @return {number} Best match index or -1.
 * @private
 */
diff_match_patch.prototype.match_bitap = function(text, pattern, loc) {
  if (pattern.length > this.Match_MaxBits) {
    throw new Error('Pattern too long for this browser.');
  }

  // Initialise the alphabet.
  var s = this.match_alphabet(pattern);

  var dmp = this;  // 'this' becomes 'window' in a closure.

  /**
   * Compute and return the score for a match with e errors and x location.
   * Accesses loc and pattern through being a closure.
   * @param {number} e Number of errors in match.
   * @param {number} x Location of match.
   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).
   * @private
   */
  function match_bitapScore(e, x) {
    var accuracy = e / pattern.length;
    var proximity = Math.abs(loc - x);
    if (!dmp.Match_Distance) {
      // Dodge divide by zero error.
      return proximity ? 1.0 : accuracy;
    }
    return accuracy + (proximity / dmp.Match_Distance);
  }

  // Highest score beyond which we give up.
  var score_threshold = this.Match_Threshold;
  // Is there a nearby exact match? (speedup)
  var best_loc = text.indexOf(pattern, loc);
  if (best_loc != -1) {
    score_threshold = Math.min(match_bitapScore(0, best_loc), score_threshold);
    // What about in the other direction? (speedup)
    best_loc = text.lastIndexOf(pattern, loc + pattern.length);
    if (best_loc != -1) {
      score_threshold =
          Math.min(match_bitapScore(0, best_loc), score_threshold);
    }
  }

  // Initialise the bit arrays.
  var matchmask = 1 << (pattern.length - 1);
  best_loc = -1;

  var bin_min, bin_mid;
  var bin_max = pattern.length + text.length;
  var last_rd;
  for (var d = 0; d < pattern.length; d++) {
    // Scan for the best match; each iteration allows for one more error.
    // Run a binary search to determine how far from 'loc' we can stray at this
    // error level.
    bin_min = 0;
    bin_mid = bin_max;
    while (bin_min < bin_mid) {
      if (match_bitapScore(d, loc + bin_mid) <= score_threshold) {
        bin_min = bin_mid;
      } else {
        bin_max = bin_mid;
      }
      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);
    }
    // Use the result from this iteration as the maximum for the next.
    bin_max = bin_mid;
    var start = Math.max(1, loc - bin_mid + 1);
    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;

    var rd = Array(finish + 2);
    rd[finish + 1] = (1 << d) - 1;
    for (var j = finish; j >= start; j--) {
      // The alphabet (s) is a sparse hash, so the following line generates
      // warnings.
      var charMatch = s[text.charAt(j - 1)];
      if (d === 0) {  // First pass: exact match.
        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;
      } else {  // Subsequent passes: fuzzy match.
        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch |
                (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |
                last_rd[j + 1];
      }
      if (rd[j] & matchmask) {
        var score = match_bitapScore(d, j - 1);
        // This match will almost certainly be better than any existing match.
        // But check anyway.
        if (score <= score_threshold) {
          // Told you so.
          score_threshold = score;
          best_loc = j - 1;
          if (best_loc > loc) {
            // When passing loc, don't exceed our current distance from loc.
            start = Math.max(1, 2 * loc - best_loc);
          } else {
            // Already passed loc, downhill from here on in.
            break;
          }
        }
      }
    }
    // No hope for a (better) match at greater error levels.
    if (match_bitapScore(d + 1, loc) > score_threshold) {
      break;
    }
    last_rd = rd;
  }
  return best_loc;
};


/**
 * Initialise the alphabet for the Bitap algorithm.
 * @param {string} pattern The text to encode.
 * @return {Object} Hash of character locations.
 * @private
 */
diff_match_patch.prototype.match_alphabet = function(pattern) {
  var s = {};
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] = 0;
  }
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);
  }
  return s;
};


//  PATCH FUNCTIONS


/**
 * Increase the context until it is unique,
 * but don't let the pattern expand beyond Match_MaxBits.
 * @param {patch_obj} patch The patch to grow.
 * @param {string} text Source text.
 * @private
 */
diff_match_patch.prototype.patch_addContext = function(patch, text) {
  if (text.length == 0) {
    return;
  }
  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);
  var padding = 0;

  // Look for the first and last matches of pattern in text.  If two different
  // matches are found, increase the pattern length.
  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&
         pattern.length < this.Match_MaxBits - this.Patch_Margin -
         this.Patch_Margin) {
    padding += this.Patch_Margin;
    pattern = text.substring(patch.start2 - padding,
                             patch.start2 + patch.length1 + padding);
  }
  // Add one chunk for good luck.
  padding += this.Patch_Margin;

  // Add the prefix.
  var prefix = text.substring(patch.start2 - padding, patch.start2);
  if (prefix) {
    patch.diffs.unshift([DIFF_EQUAL, prefix]);
  }
  // Add the suffix.
  var suffix = text.substring(patch.start2 + patch.length1,
                              patch.start2 + patch.length1 + padding);
  if (suffix) {
    patch.diffs.push([DIFF_EQUAL, suffix]);
  }

  // Roll back the start points.
  patch.start1 -= prefix.length;
  patch.start2 -= prefix.length;
  // Extend the lengths.
  patch.length1 += prefix.length + suffix.length;
  patch.length2 += prefix.length + suffix.length;
};


/**
 * Compute a list of patches to turn text1 into text2.
 * Use diffs if provided, otherwise compute it ourselves.
 * There are four ways to call this function, depending on what data is
 * available to the caller:
 * Method 1:
 * a = text1, b = text2
 * Method 2:
 * a = diffs
 * Method 3 (optimal):
 * a = text1, b = diffs
 * Method 4 (deprecated, use method 3):
 * a = text1, b = text2, c = diffs
 *
 * @param {string|Array.<Array.<number|string>>} a text1 (methods 1,3,4) or
 * Array of diff tuples for text1 to text2 (method 2).
 * @param {string|Array.<Array.<number|string>>} opt_b text2 (methods 1,4) or
 * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).
 * @param {string|Array.<Array.<number|string>>} opt_c Array of diff tuples for
 * text1 to text2 (method 4) or undefined (methods 1,2,3).
 * @return {Array.<patch_obj>} Array of patch objects.
 */
diff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {
  var text1, diffs;
  if (typeof a == 'string' && typeof opt_b == 'string' &&
      typeof opt_c == 'undefined') {
    // Method 1: text1, text2
    // Compute diffs from text1 and text2.
    text1 = a;
    diffs = this.diff_main(text1, opt_b, true);
    if (diffs.length > 2) {
      this.diff_cleanupSemantic(diffs);
      this.diff_cleanupEfficiency(diffs);
    }
  } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&
      typeof opt_c == 'undefined') {
    // Method 2: diffs
    // Compute text1 from diffs.
    diffs = a;
    text1 = this.diff_text1(diffs);
  } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&
      typeof opt_c == 'undefined') {
    // Method 3: text1, diffs
    text1 = a;
    diffs = opt_b;
  } else if (typeof a == 'string' && typeof opt_b == 'string' &&
      opt_c && typeof opt_c == 'object') {
    // Method 4: text1, text2, diffs
    // text2 is not used.
    text1 = a;
    diffs = opt_c;
  } else {
    throw new Error('Unknown call format to patch_make.');
  }

  if (diffs.length === 0) {
    return [];  // Get rid of the null case.
  }
  var patches = [];
  var patch = new patch_obj();
  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.
  var char_count1 = 0;  // Number of characters into the text1 string.
  var char_count2 = 0;  // Number of characters into the text2 string.
  // Start with text1 (prepatch_text) and apply the diffs until we arrive at
  // text2 (postpatch_text).  We recreate the patches one by one to determine
  // context info.
  var prepatch_text = text1;
  var postpatch_text = text1;
  for (var x = 0; x < diffs.length; x++) {
    var diff_type = diffs[x][0];
    var diff_text = diffs[x][1];

    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
      // A new patch starts here.
      patch.start1 = char_count1;
      patch.start2 = char_count2;
    }

    switch (diff_type) {
      case DIFF_INSERT:
        patch.diffs[patchDiffLength++] = diffs[x];
        patch.length2 += diff_text.length;
        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +
                         postpatch_text.substring(char_count2);
        break;
      case DIFF_DELETE:
        patch.length1 += diff_text.length;
        patch.diffs[patchDiffLength++] = diffs[x];
        postpatch_text = postpatch_text.substring(0, char_count2) +
                         postpatch_text.substring(char_count2 +
                             diff_text.length);
        break;
      case DIFF_EQUAL:
        if (diff_text.length <= 2 * this.Patch_Margin &&
            patchDiffLength && diffs.length != x + 1) {
          // Small equality inside a patch.
          patch.diffs[patchDiffLength++] = diffs[x];
          patch.length1 += diff_text.length;
          patch.length2 += diff_text.length;
        } else if (diff_text.length >= 2 * this.Patch_Margin) {
          // Time for a new patch.
          if (patchDiffLength) {
            this.patch_addContext(patch, prepatch_text);
            patches.push(patch);
            patch = new patch_obj();
            patchDiffLength = 0;
            // Unlike Unidiff, our patch lists have a rolling context.
            // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff
            // Update prepatch text & pos to reflect the application of the
            // just completed patch.
            prepatch_text = postpatch_text;
            char_count1 = char_count2;
          }
        }
        break;
    }

    // Update the current character count.
    if (diff_type !== DIFF_INSERT) {
      char_count1 += diff_text.length;
    }
    if (diff_type !== DIFF_DELETE) {
      char_count2 += diff_text.length;
    }
  }
  // Pick up the leftover patch if not empty.
  if (patchDiffLength) {
    this.patch_addContext(patch, prepatch_text);
    patches.push(patch);
  }

  return patches;
};


/**
 * Given an array of patches, return another array that is identical.
 * @param {Array.<patch_obj>} patches Array of patch objects.
 * @return {Array.<patch_obj>} Array of patch objects.
 */
diff_match_patch.prototype.patch_deepCopy = function(patches) {
  // Making deep copies is hard in JavaScript.
  var patchesCopy = [];
  for (var x = 0; x < patches.length; x++) {
    var patch = patches[x];
    var patchCopy = new patch_obj();
    patchCopy.diffs = [];
    for (var y = 0; y < patch.diffs.length; y++) {
      patchCopy.diffs[y] = patch.diffs[y].slice();
    }
    patchCopy.start1 = patch.start1;
    patchCopy.start2 = patch.start2;
    patchCopy.length1 = patch.length1;
    patchCopy.length2 = patch.length2;
    patchesCopy[x] = patchCopy;
  }
  return patchesCopy;
};


/**
 * Merge a set of patches onto the text.  Return a patched text, as well
 * as a list of true/false values indicating which patches were applied.
 * @param {Array.<patch_obj>} patches Array of patch objects.
 * @param {string} text Old text.
 * @return {Array.<string|Array.<boolean>>} Two element Array, containing the
 *      new text and an array of boolean values.
 */
diff_match_patch.prototype.patch_apply = function(patches, text) {
  if (patches.length == 0) {
    return [text, []];
  }

  // Deep copy the patches so that no changes are made to originals.
  patches = this.patch_deepCopy(patches);

  var nullPadding = this.patch_addPadding(patches);
  text = nullPadding + text + nullPadding;

  this.patch_splitMax(patches);
  // delta keeps track of the offset between the expected and actual location
  // of the previous patch.  If there are patches expected at positions 10 and
  // 20, but the first patch was found at 12, delta is 2 and the second patch
  // has an effective expected position of 22.
  var delta = 0;
  var results = [];
  for (var x = 0; x < patches.length; x++) {
    var expected_loc = patches[x].start2 + delta;
    var text1 = this.diff_text1(patches[x].diffs);
    var start_loc;
    var end_loc = -1;
    if (text1.length > this.Match_MaxBits) {
      // patch_splitMax will only provide an oversized pattern in the case of
      // a monster delete.
      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),
                                  expected_loc);
      if (start_loc != -1) {
        end_loc = this.match_main(text,
            text1.substring(text1.length - this.Match_MaxBits),
            expected_loc + text1.length - this.Match_MaxBits);
        if (end_loc == -1 || start_loc >= end_loc) {
          // Can't find valid trailing context.  Drop this patch.
          start_loc = -1;
        }
      }
    } else {
      start_loc = this.match_main(text, text1, expected_loc);
    }
    if (start_loc == -1) {
      // No match found.  :(
      results[x] = false;
      // Subtract the delta for this failed patch from subsequent patches.
      delta -= patches[x].length2 - patches[x].length1;
    } else {
      // Found a match.  :)
      results[x] = true;
      delta = start_loc - expected_loc;
      var text2;
      if (end_loc == -1) {
        text2 = text.substring(start_loc, start_loc + text1.length);
      } else {
        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);
      }
      if (text1 == text2) {
        // Perfect match, just shove the replacement text in.
        text = text.substring(0, start_loc) +
               this.diff_text2(patches[x].diffs) +
               text.substring(start_loc + text1.length);
      } else {
        // Imperfect match.  Run a diff to get a framework of equivalent
        // indices.
        var diffs = this.diff_main(text1, text2, false);
        if (text1.length > this.Match_MaxBits &&
            this.diff_levenshtein(diffs) / text1.length >
            this.Patch_DeleteThreshold) {
          // The end points match, but the content is unacceptably bad.
          results[x] = false;
        } else {
          this.diff_cleanupSemanticLossless(diffs);
          var index1 = 0;
          var index2;
          for (var y = 0; y < patches[x].diffs.length; y++) {
            var mod = patches[x].diffs[y];
            if (mod[0] !== DIFF_EQUAL) {
              index2 = this.diff_xIndex(diffs, index1);
            }
            if (mod[0] === DIFF_INSERT) {  // Insertion
              text = text.substring(0, start_loc + index2) + mod[1] +
                     text.substring(start_loc + index2);
            } else if (mod[0] === DIFF_DELETE) {  // Deletion
              text = text.substring(0, start_loc + index2) +
                     text.substring(start_loc + this.diff_xIndex(diffs,
                         index1 + mod[1].length));
            }
            if (mod[0] !== DIFF_DELETE) {
              index1 += mod[1].length;
            }
          }
        }
      }
    }
  }
  // Strip the padding off.
  text = text.substring(nullPadding.length, text.length - nullPadding.length);
  return [text, results];
};


/**
 * Add some padding on text start and end so that edges can match something.
 * Intended to be called only from within patch_apply.
 * @param {Array.<patch_obj>} patches Array of patch objects.
 * @return {string} The padding string added to each side.
 */
diff_match_patch.prototype.patch_addPadding = function(patches) {
  var paddingLength = this.Patch_Margin;
  var nullPadding = '';
  for (var x = 1; x <= paddingLength; x++) {
    nullPadding += String.fromCharCode(x);
  }

  // Bump all the patches forward.
  for (var x = 0; x < patches.length; x++) {
    patches[x].start1 += paddingLength;
    patches[x].start2 += paddingLength;
  }

  // Add some padding on start of first diff.
  var patch = patches[0];
  var diffs = patch.diffs;
  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
    // Add nullPadding equality.
    diffs.unshift([DIFF_EQUAL, nullPadding]);
    patch.start1 -= paddingLength;  // Should be 0.
    patch.start2 -= paddingLength;  // Should be 0.
    patch.length1 += paddingLength;
    patch.length2 += paddingLength;
  } else if (paddingLength > diffs[0][1].length) {
    // Grow first equality.
    var extraLength = paddingLength - diffs[0][1].length;
    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
    patch.start1 -= extraLength;
    patch.start2 -= extraLength;
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }

  // Add some padding on end of last diff.
  patch = patches[patches.length - 1];
  diffs = patch.diffs;
  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
    // Add nullPadding equality.
    diffs.push([DIFF_EQUAL, nullPadding]);
    patch.length1 += paddingLength;
    patch.length2 += paddingLength;
  } else if (paddingLength > diffs[diffs.length - 1][1].length) {
    // Grow last equality.
    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;
    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }

  return nullPadding;
};


/**
 * Look through the patches and break up any which are longer than the maximum
 * limit of the match algorithm.
 * @param {Array.<patch_obj>} patches Array of patch objects.
 */
diff_match_patch.prototype.patch_splitMax = function(patches) {
  for (var x = 0; x < patches.length; x++) {
    if (patches[x].length1 > this.Match_MaxBits) {
      var bigpatch = patches[x];
      // Remove the big old patch.
      patches.splice(x--, 1);
      var patch_size = this.Match_MaxBits;
      var start1 = bigpatch.start1;
      var start2 = bigpatch.start2;
      var precontext = '';
      while (bigpatch.diffs.length !== 0) {
        // Create one of several smaller patches.
        var patch = new patch_obj();
        var empty = true;
        patch.start1 = start1 - precontext.length;
        patch.start2 = start2 - precontext.length;
        if (precontext !== '') {
          patch.length1 = patch.length2 = precontext.length;
          patch.diffs.push([DIFF_EQUAL, precontext]);
        }
        while (bigpatch.diffs.length !== 0 &&
               patch.length1 < patch_size - this.Patch_Margin) {
          var diff_type = bigpatch.diffs[0][0];
          var diff_text = bigpatch.diffs[0][1];
          if (diff_type === DIFF_INSERT) {
            // Insertions are harmless.
            patch.length2 += diff_text.length;
            start2 += diff_text.length;
            patch.diffs.push(bigpatch.diffs.shift());
            empty = false;
          } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&
                     patch.diffs[0][0] == DIFF_EQUAL &&
                     diff_text.length > 2 * patch_size) {
            // This is a large deletion.  Let it pass in one chunk.
            patch.length1 += diff_text.length;
            start1 += diff_text.length;
            empty = false;
            patch.diffs.push([diff_type, diff_text]);
            bigpatch.diffs.shift();
          } else {
            // Deletion or equality.  Only take as much as we can stomach.
            diff_text = diff_text.substring(0, patch_size - patch.length1 -
                                               this.Patch_Margin);
            patch.length1 += diff_text.length;
            start1 += diff_text.length;
            if (diff_type === DIFF_EQUAL) {
              patch.length2 += diff_text.length;
              start2 += diff_text.length;
            } else {
              empty = false;
            }
            patch.diffs.push([diff_type, diff_text]);
            if (diff_text == bigpatch.diffs[0][1]) {
              bigpatch.diffs.shift();
            } else {
              bigpatch.diffs[0][1] =
                  bigpatch.diffs[0][1].substring(diff_text.length);
            }
          }
        }
        // Compute the head context for the next patch.
        precontext = this.diff_text2(patch.diffs);
        precontext =
            precontext.substring(precontext.length - this.Patch_Margin);
        // Append the end context for this patch.
        var postcontext = this.diff_text1(bigpatch.diffs)
                              .substring(0, this.Patch_Margin);
        if (postcontext !== '') {
          patch.length1 += postcontext.length;
          patch.length2 += postcontext.length;
          if (patch.diffs.length !== 0 &&
              patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {
            patch.diffs[patch.diffs.length - 1][1] += postcontext;
          } else {
            patch.diffs.push([DIFF_EQUAL, postcontext]);
          }
        }
        if (!empty) {
          patches.splice(++x, 0, patch);
        }
      }
    }
  }
};


/**
 * Take a list of patches and return a textual representation.
 * @param {Array.<patch_obj>} patches Array of patch objects.
 * @return {string} Text representation of patches.
 */
diff_match_patch.prototype.patch_toText = function(patches) {
  var text = [];
  for (var x = 0; x < patches.length; x++) {
    text[x] = patches[x];
  }
  return text.join('');
};


/**
 * Parse a textual representation of patches and return a list of patch objects.
 * @param {string} textline Text representation of patches.
 * @return {Array.<patch_obj>} Array of patch objects.
 * @throws {Error} If invalid input.
 */
diff_match_patch.prototype.patch_fromText = function(textline) {
  var patches = [];
  if (!textline) {
    return patches;
  }
  // Opera doesn't know how to decode char 0.
  textline = textline.replace(/%00/g, '\0');
  var text = textline.split('\n');
  var textPointer = 0;
  while (textPointer < text.length) {
    var m = text[textPointer].match(/^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/);
    if (!m) {
      throw new Error('Invalid patch string: ' + text[textPointer]);
    }
    var patch = new patch_obj();
    patches.push(patch);
    patch.start1 = parseInt(m[1], 10);
    if (m[2] === '') {
      patch.start1--;
      patch.length1 = 1;
    } else if (m[2] == '0') {
      patch.length1 = 0;
    } else {
      patch.start1--;
      patch.length1 = parseInt(m[2], 10);
    }

    patch.start2 = parseInt(m[3], 10);
    if (m[4] === '') {
      patch.start2--;
      patch.length2 = 1;
    } else if (m[4] == '0') {
      patch.length2 = 0;
    } else {
      patch.start2--;
      patch.length2 = parseInt(m[4], 10);
    }
    textPointer++;

    while (textPointer < text.length) {
      var sign = text[textPointer].charAt(0);
      try {
        var line = decodeURI(text[textPointer].substring(1));
      } catch (ex) {
        // Malformed URI sequence.
        throw new Error('Illegal escape in patch_fromText: ' + line);
      }
      if (sign == '-') {
        // Deletion.
        patch.diffs.push([DIFF_DELETE, line]);
      } else if (sign == '+') {
        // Insertion.
        patch.diffs.push([DIFF_INSERT, line]);
      } else if (sign == ' ') {
        // Minor equality.
        patch.diffs.push([DIFF_EQUAL, line]);
      } else if (sign == '@') {
        // Start of next patch.
        break;
      } else if (sign === '') {
        // Blank line?  Whatever.
      } else {
        // WTF?
        throw new Error('Invalid patch mode "' + sign + '" in: ' + line);
      }
      textPointer++;
    }
  }
  return patches;
};


/**
 * Class representing one patch operation.
 * @constructor
 */
function patch_obj() {
  /** @type {Array.<Array.<number|string>>} */
  this.diffs = [];
  /** @type {?number} */
  this.start1 = null;
  /** @type {?number} */
  this.start2 = null;
  /** @type {number} */
  this.length1 = 0;
  /** @type {number} */
  this.length2 = 0;
}


/**
 * Emmulate GNU diff's format.
 * Header: @@ -382,8 +481,9 @@
 * Indicies are printed as 1-based, not 0-based.
 * @return {string} The GNU diff string.
 */
patch_obj.prototype.toString = function() {
  var coords1, coords2;
  if (this.length1 === 0) {
    coords1 = this.start1 + ',0';
  } else if (this.length1 == 1) {
    coords1 = this.start1 + 1;
  } else {
    coords1 = (this.start1 + 1) + ',' + this.length1;
  }
  if (this.length2 === 0) {
    coords2 = this.start2 + ',0';
  } else if (this.length2 == 1) {
    coords2 = this.start2 + 1;
  } else {
    coords2 = (this.start2 + 1) + ',' + this.length2;
  }
  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\n'];
  var op;
  // Escape the body of the patch with %xx notation.
  for (var x = 0; x < this.diffs.length; x++) {
    switch (this.diffs[x][0]) {
      case DIFF_INSERT:
        op = '+';
        break;
      case DIFF_DELETE:
        op = '-';
        break;
      case DIFF_EQUAL:
        op = ' ';
        break;
    }
    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\n';
  }
  // Opera doesn't know how to encode char 0.
  return text.join('').replace(/\x00/g, '%00').replace(/%20/g, ' ');
};


// Export these global variables so that they survive Google's JS compiler.
/*changed by lfborjas: changed `window` for `exports` to make it suitable for the node.js module conventions*/
exports.diff_match_patch = diff_match_patch;
exports.patch_obj = patch_obj;
exports.DIFF_DELETE = DIFF_DELETE;
exports.DIFF_INSERT = DIFF_INSERT;
exports.DIFF_EQUAL = DIFF_EQUAL;


/***/ }),

/***/ "../structured-text-editor/node_modules/prismjs/components/prism-latex.js":
/*!********************************************************************************!*\
  !*** ../structured-text-editor/node_modules/prismjs/components/prism-latex.js ***!
  \********************************************************************************/
/***/ (() => {

(function (Prism) {
	var funcPattern = /\\(?:[^a-z()[\]]|[a-z*]+)/i;
	var insideEqu = {
		'equation-command': {
			pattern: funcPattern,
			alias: 'regex'
		}
	};

	Prism.languages.latex = {
		'comment': /%.*/,
		// the verbatim environment prints whitespace to the document
		'cdata': {
			pattern: /(\\begin\{((?:lstlisting|verbatim)\*?)\})[\s\S]*?(?=\\end\{\2\})/,
			lookbehind: true
		},
		/*
		 * equations can be between $$ $$ or $ $ or \( \) or \[ \]
		 * (all are multiline)
		 */
		'equation': [
			{
				pattern: /\$\$(?:\\[\s\S]|[^\\$])+\$\$|\$(?:\\[\s\S]|[^\\$])+\$|\\\([\s\S]*?\\\)|\\\[[\s\S]*?\\\]/,
				inside: insideEqu,
				alias: 'string'
			},
			{
				pattern: /(\\begin\{((?:align|eqnarray|equation|gather|math|multline)\*?)\})[\s\S]*?(?=\\end\{\2\})/,
				lookbehind: true,
				inside: insideEqu,
				alias: 'string'
			}
		],
		/*
		 * arguments which are keywords or references are highlighted
		 * as keywords
		 */
		'keyword': {
			pattern: /(\\(?:begin|cite|documentclass|end|label|ref|usepackage)(?:\[[^\]]+\])?\{)[^}]+(?=\})/,
			lookbehind: true
		},
		'url': {
			pattern: /(\\url\{)[^}]+(?=\})/,
			lookbehind: true
		},
		/*
		 * section or chapter headlines are highlighted as bold so that
		 * they stand out more
		 */
		'headline': {
			pattern: /(\\(?:chapter|frametitle|paragraph|part|section|subparagraph|subsection|subsubparagraph|subsubsection|subsubsubparagraph)\*?(?:\[[^\]]+\])?\{)[^}]+(?=\})/,
			lookbehind: true,
			alias: 'class-name'
		},
		'function': {
			pattern: funcPattern,
			alias: 'selector'
		},
		'punctuation': /[[\]{}&]/
	};

	Prism.languages.tex = Prism.languages.latex;
	Prism.languages.context = Prism.languages.latex;
}(Prism));


/***/ }),

/***/ "../structured-text-editor/node_modules/prismjs/prism.js":
/*!***************************************************************!*\
  !*** ../structured-text-editor/node_modules/prismjs/prism.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/* **********************************************
     Begin prism-core.js
********************************************** */

/// <reference lib="WebWorker"/>

var _self = (typeof window !== 'undefined')
	? window   // if in browser
	: (
		(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
			? self // if in worker
			: {}   // if in node js
	);

/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 *
 * @license MIT <https://opensource.org/licenses/MIT>
 * @author Lea Verou <https://lea.verou.me>
 * @namespace
 * @public
 */
var Prism = (function (_self) {

	// Private helper vars
	var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
	var uniqueId = 0;

	// The grammar object for plaintext
	var plainTextGrammar = {};


	var _ = {
		/**
		 * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
		 * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
		 * additional languages or plugins yourself.
		 *
		 * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
		 *
		 * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
		 * empty Prism object into the global scope before loading the Prism script like this:
		 *
		 * ```js
		 * window.Prism = window.Prism || {};
		 * Prism.manual = true;
		 * // add a new <script> to load Prism's script
		 * ```
		 *
		 * @default false
		 * @type {boolean}
		 * @memberof Prism
		 * @public
		 */
		manual: _self.Prism && _self.Prism.manual,
		/**
		 * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
		 * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
		 * own worker, you don't want it to do this.
		 *
		 * By setting this value to `true`, Prism will not add its own listeners to the worker.
		 *
		 * You obviously have to change this value before Prism executes. To do this, you can add an
		 * empty Prism object into the global scope before loading the Prism script like this:
		 *
		 * ```js
		 * window.Prism = window.Prism || {};
		 * Prism.disableWorkerMessageHandler = true;
		 * // Load Prism's script
		 * ```
		 *
		 * @default false
		 * @type {boolean}
		 * @memberof Prism
		 * @public
		 */
		disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,

		/**
		 * A namespace for utility methods.
		 *
		 * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
		 * change or disappear at any time.
		 *
		 * @namespace
		 * @memberof Prism
		 */
		util: {
			encode: function encode(tokens) {
				if (tokens instanceof Token) {
					return new Token(tokens.type, encode(tokens.content), tokens.alias);
				} else if (Array.isArray(tokens)) {
					return tokens.map(encode);
				} else {
					return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
				}
			},

			/**
			 * Returns the name of the type of the given value.
			 *
			 * @param {any} o
			 * @returns {string}
			 * @example
			 * type(null)      === 'Null'
			 * type(undefined) === 'Undefined'
			 * type(123)       === 'Number'
			 * type('foo')     === 'String'
			 * type(true)      === 'Boolean'
			 * type([1, 2])    === 'Array'
			 * type({})        === 'Object'
			 * type(String)    === 'Function'
			 * type(/abc+/)    === 'RegExp'
			 */
			type: function (o) {
				return Object.prototype.toString.call(o).slice(8, -1);
			},

			/**
			 * Returns a unique number for the given object. Later calls will still return the same number.
			 *
			 * @param {Object} obj
			 * @returns {number}
			 */
			objId: function (obj) {
				if (!obj['__id']) {
					Object.defineProperty(obj, '__id', { value: ++uniqueId });
				}
				return obj['__id'];
			},

			/**
			 * Creates a deep clone of the given object.
			 *
			 * The main intended use of this function is to clone language definitions.
			 *
			 * @param {T} o
			 * @param {Record<number, any>} [visited]
			 * @returns {T}
			 * @template T
			 */
			clone: function deepClone(o, visited) {
				visited = visited || {};

				var clone; var id;
				switch (_.util.type(o)) {
					case 'Object':
						id = _.util.objId(o);
						if (visited[id]) {
							return visited[id];
						}
						clone = /** @type {Record<string, any>} */ ({});
						visited[id] = clone;

						for (var key in o) {
							if (o.hasOwnProperty(key)) {
								clone[key] = deepClone(o[key], visited);
							}
						}

						return /** @type {any} */ (clone);

					case 'Array':
						id = _.util.objId(o);
						if (visited[id]) {
							return visited[id];
						}
						clone = [];
						visited[id] = clone;

						(/** @type {Array} */(/** @type {any} */(o))).forEach(function (v, i) {
							clone[i] = deepClone(v, visited);
						});

						return /** @type {any} */ (clone);

					default:
						return o;
				}
			},

			/**
			 * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
			 *
			 * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
			 *
			 * @param {Element} element
			 * @returns {string}
			 */
			getLanguage: function (element) {
				while (element) {
					var m = lang.exec(element.className);
					if (m) {
						return m[1].toLowerCase();
					}
					element = element.parentElement;
				}
				return 'none';
			},

			/**
			 * Sets the Prism `language-xxxx` class of the given element.
			 *
			 * @param {Element} element
			 * @param {string} language
			 * @returns {void}
			 */
			setLanguage: function (element, language) {
				// remove all `language-xxxx` classes
				// (this might leave behind a leading space)
				element.className = element.className.replace(RegExp(lang, 'gi'), '');

				// add the new `language-xxxx` class
				// (using `classList` will automatically clean up spaces for us)
				element.classList.add('language-' + language);
			},

			/**
			 * Returns the script element that is currently executing.
			 *
			 * This does __not__ work for line script element.
			 *
			 * @returns {HTMLScriptElement | null}
			 */
			currentScript: function () {
				if (typeof document === 'undefined') {
					return null;
				}
				if ('currentScript' in document && 1 < 2 /* hack to trip TS' flow analysis */) {
					return /** @type {any} */ (document.currentScript);
				}

				// IE11 workaround
				// we'll get the src of the current script by parsing IE11's error stack trace
				// this will not work for inline scripts

				try {
					throw new Error();
				} catch (err) {
					// Get file src url from stack. Specifically works with the format of stack traces in IE.
					// A stack will look like this:
					//
					// Error
					//    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)
					//    at Global code (http://localhost/components/prism-core.js:606:1)

					var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
					if (src) {
						var scripts = document.getElementsByTagName('script');
						for (var i in scripts) {
							if (scripts[i].src == src) {
								return scripts[i];
							}
						}
					}
					return null;
				}
			},

			/**
			 * Returns whether a given class is active for `element`.
			 *
			 * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
			 * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
			 * given class is just the given class with a `no-` prefix.
			 *
			 * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
			 * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
			 * ancestors have the given class or the negated version of it, then the default activation will be returned.
			 *
			 * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
			 * version of it, the class is considered active.
			 *
			 * @param {Element} element
			 * @param {string} className
			 * @param {boolean} [defaultActivation=false]
			 * @returns {boolean}
			 */
			isActive: function (element, className, defaultActivation) {
				var no = 'no-' + className;

				while (element) {
					var classList = element.classList;
					if (classList.contains(className)) {
						return true;
					}
					if (classList.contains(no)) {
						return false;
					}
					element = element.parentElement;
				}
				return !!defaultActivation;
			}
		},

		/**
		 * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
		 *
		 * @namespace
		 * @memberof Prism
		 * @public
		 */
		languages: {
			/**
			 * The grammar for plain, unformatted text.
			 */
			plain: plainTextGrammar,
			plaintext: plainTextGrammar,
			text: plainTextGrammar,
			txt: plainTextGrammar,

			/**
			 * Creates a deep copy of the language with the given id and appends the given tokens.
			 *
			 * If a token in `redef` also appears in the copied language, then the existing token in the copied language
			 * will be overwritten at its original position.
			 *
			 * ## Best practices
			 *
			 * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
			 * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
			 * understand the language definition because, normally, the order of tokens matters in Prism grammars.
			 *
			 * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
			 * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
			 *
			 * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
			 * @param {Grammar} redef The new tokens to append.
			 * @returns {Grammar} The new language created.
			 * @public
			 * @example
			 * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
			 *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
			 *     // at its original position
			 *     'comment': { ... },
			 *     // CSS doesn't have a 'color' token, so this token will be appended
			 *     'color': /\b(?:red|green|blue)\b/
			 * });
			 */
			extend: function (id, redef) {
				var lang = _.util.clone(_.languages[id]);

				for (var key in redef) {
					lang[key] = redef[key];
				}

				return lang;
			},

			/**
			 * Inserts tokens _before_ another token in a language definition or any other grammar.
			 *
			 * ## Usage
			 *
			 * This helper method makes it easy to modify existing languages. For example, the CSS language definition
			 * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
			 * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
			 * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
			 * this:
			 *
			 * ```js
			 * Prism.languages.markup.style = {
			 *     // token
			 * };
			 * ```
			 *
			 * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
			 * before existing tokens. For the CSS example above, you would use it like this:
			 *
			 * ```js
			 * Prism.languages.insertBefore('markup', 'cdata', {
			 *     'style': {
			 *         // token
			 *     }
			 * });
			 * ```
			 *
			 * ## Special cases
			 *
			 * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
			 * will be ignored.
			 *
			 * This behavior can be used to insert tokens after `before`:
			 *
			 * ```js
			 * Prism.languages.insertBefore('markup', 'comment', {
			 *     'comment': Prism.languages.markup.comment,
			 *     // tokens after 'comment'
			 * });
			 * ```
			 *
			 * ## Limitations
			 *
			 * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
			 * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
			 * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
			 * deleting properties which is necessary to insert at arbitrary positions.
			 *
			 * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
			 * Instead, it will create a new object and replace all references to the target object with the new one. This
			 * can be done without temporarily deleting properties, so the iteration order is well-defined.
			 *
			 * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
			 * you hold the target object in a variable, then the value of the variable will not change.
			 *
			 * ```js
			 * var oldMarkup = Prism.languages.markup;
			 * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
			 *
			 * assert(oldMarkup !== Prism.languages.markup);
			 * assert(newMarkup === Prism.languages.markup);
			 * ```
			 *
			 * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
			 * object to be modified.
			 * @param {string} before The key to insert before.
			 * @param {Grammar} insert An object containing the key-value pairs to be inserted.
			 * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
			 * object to be modified.
			 *
			 * Defaults to `Prism.languages`.
			 * @returns {Grammar} The new grammar object.
			 * @public
			 */
			insertBefore: function (inside, before, insert, root) {
				root = root || /** @type {any} */ (_.languages);
				var grammar = root[inside];
				/** @type {Grammar} */
				var ret = {};

				for (var token in grammar) {
					if (grammar.hasOwnProperty(token)) {

						if (token == before) {
							for (var newToken in insert) {
								if (insert.hasOwnProperty(newToken)) {
									ret[newToken] = insert[newToken];
								}
							}
						}

						// Do not insert token which also occur in insert. See #1525
						if (!insert.hasOwnProperty(token)) {
							ret[token] = grammar[token];
						}
					}
				}

				var old = root[inside];
				root[inside] = ret;

				// Update references in other language definitions
				_.languages.DFS(_.languages, function (key, value) {
					if (value === old && key != inside) {
						this[key] = ret;
					}
				});

				return ret;
			},

			// Traverse a language definition with Depth First Search
			DFS: function DFS(o, callback, type, visited) {
				visited = visited || {};

				var objId = _.util.objId;

				for (var i in o) {
					if (o.hasOwnProperty(i)) {
						callback.call(o, i, o[i], type || i);

						var property = o[i];
						var propertyType = _.util.type(property);

						if (propertyType === 'Object' && !visited[objId(property)]) {
							visited[objId(property)] = true;
							DFS(property, callback, null, visited);
						} else if (propertyType === 'Array' && !visited[objId(property)]) {
							visited[objId(property)] = true;
							DFS(property, callback, i, visited);
						}
					}
				}
			}
		},

		plugins: {},

		/**
		 * This is the most high-level function in Prism’s API.
		 * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
		 * each one of them.
		 *
		 * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
		 *
		 * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
		 * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
		 * @memberof Prism
		 * @public
		 */
		highlightAll: function (async, callback) {
			_.highlightAllUnder(document, async, callback);
		},

		/**
		 * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
		 * {@link Prism.highlightElement} on each one of them.
		 *
		 * The following hooks will be run:
		 * 1. `before-highlightall`
		 * 2. `before-all-elements-highlight`
		 * 3. All hooks of {@link Prism.highlightElement} for each element.
		 *
		 * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
		 * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
		 * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
		 * @memberof Prism
		 * @public
		 */
		highlightAllUnder: function (container, async, callback) {
			var env = {
				callback: callback,
				container: container,
				selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
			};

			_.hooks.run('before-highlightall', env);

			env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));

			_.hooks.run('before-all-elements-highlight', env);

			for (var i = 0, element; (element = env.elements[i++]);) {
				_.highlightElement(element, async === true, env.callback);
			}
		},

		/**
		 * Highlights the code inside a single element.
		 *
		 * The following hooks will be run:
		 * 1. `before-sanity-check`
		 * 2. `before-highlight`
		 * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
		 * 4. `before-insert`
		 * 5. `after-highlight`
		 * 6. `complete`
		 *
		 * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
		 * the element's language.
		 *
		 * @param {Element} element The element containing the code.
		 * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
		 * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
		 * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
		 * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
		 *
		 * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
		 * asynchronous highlighting to work. You can build your own bundle on the
		 * [Download page](https://prismjs.com/download.html).
		 * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
		 * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
		 * @memberof Prism
		 * @public
		 */
		highlightElement: function (element, async, callback) {
			// Find language
			var language = _.util.getLanguage(element);
			var grammar = _.languages[language];

			// Set language on the element, if not present
			_.util.setLanguage(element, language);

			// Set language on the parent, for styling
			var parent = element.parentElement;
			if (parent && parent.nodeName.toLowerCase() === 'pre') {
				_.util.setLanguage(parent, language);
			}

			var code = element.textContent;

			var env = {
				element: element,
				language: language,
				grammar: grammar,
				code: code
			};

			function insertHighlightedCode(highlightedCode) {
				env.highlightedCode = highlightedCode;

				_.hooks.run('before-insert', env);

				env.element.innerHTML = env.highlightedCode;

				_.hooks.run('after-highlight', env);
				_.hooks.run('complete', env);
				callback && callback.call(env.element);
			}

			_.hooks.run('before-sanity-check', env);

			// plugins may change/add the parent/element
			parent = env.element.parentElement;
			if (parent && parent.nodeName.toLowerCase() === 'pre' && !parent.hasAttribute('tabindex')) {
				parent.setAttribute('tabindex', '0');
			}

			if (!env.code) {
				_.hooks.run('complete', env);
				callback && callback.call(env.element);
				return;
			}

			_.hooks.run('before-highlight', env);

			if (!env.grammar) {
				insertHighlightedCode(_.util.encode(env.code));
				return;
			}

			if (async && _self.Worker) {
				var worker = new Worker(_.filename);

				worker.onmessage = function (evt) {
					insertHighlightedCode(evt.data);
				};

				worker.postMessage(JSON.stringify({
					language: env.language,
					code: env.code,
					immediateClose: true
				}));
			} else {
				insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
			}
		},

		/**
		 * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
		 * and the language definitions to use, and returns a string with the HTML produced.
		 *
		 * The following hooks will be run:
		 * 1. `before-tokenize`
		 * 2. `after-tokenize`
		 * 3. `wrap`: On each {@link Token}.
		 *
		 * @param {string} text A string with the code to be highlighted.
		 * @param {Grammar} grammar An object containing the tokens to use.
		 *
		 * Usually a language definition like `Prism.languages.markup`.
		 * @param {string} language The name of the language definition passed to `grammar`.
		 * @returns {string} The highlighted HTML.
		 * @memberof Prism
		 * @public
		 * @example
		 * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
		 */
		highlight: function (text, grammar, language) {
			var env = {
				code: text,
				grammar: grammar,
				language: language
			};
			_.hooks.run('before-tokenize', env);
			if (!env.grammar) {
				throw new Error('The language "' + env.language + '" has no grammar.');
			}
			env.tokens = _.tokenize(env.code, env.grammar);
			_.hooks.run('after-tokenize', env);
			return Token.stringify(_.util.encode(env.tokens), env.language);
		},

		/**
		 * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
		 * and the language definitions to use, and returns an array with the tokenized code.
		 *
		 * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
		 *
		 * This method could be useful in other contexts as well, as a very crude parser.
		 *
		 * @param {string} text A string with the code to be highlighted.
		 * @param {Grammar} grammar An object containing the tokens to use.
		 *
		 * Usually a language definition like `Prism.languages.markup`.
		 * @returns {TokenStream} An array of strings and tokens, a token stream.
		 * @memberof Prism
		 * @public
		 * @example
		 * let code = `var foo = 0;`;
		 * let tokens = Prism.tokenize(code, Prism.languages.javascript);
		 * tokens.forEach(token => {
		 *     if (token instanceof Prism.Token && token.type === 'number') {
		 *         console.log(`Found numeric literal: ${token.content}`);
		 *     }
		 * });
		 */
		tokenize: function (text, grammar) {
			var rest = grammar.rest;
			if (rest) {
				for (var token in rest) {
					grammar[token] = rest[token];
				}

				delete grammar.rest;
			}

			var tokenList = new LinkedList();
			addAfter(tokenList, tokenList.head, text);

			matchGrammar(text, tokenList, grammar, tokenList.head, 0);

			return toArray(tokenList);
		},

		/**
		 * @namespace
		 * @memberof Prism
		 * @public
		 */
		hooks: {
			all: {},

			/**
			 * Adds the given callback to the list of callbacks for the given hook.
			 *
			 * The callback will be invoked when the hook it is registered for is run.
			 * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
			 *
			 * One callback function can be registered to multiple hooks and the same hook multiple times.
			 *
			 * @param {string} name The name of the hook.
			 * @param {HookCallback} callback The callback function which is given environment variables.
			 * @public
			 */
			add: function (name, callback) {
				var hooks = _.hooks.all;

				hooks[name] = hooks[name] || [];

				hooks[name].push(callback);
			},

			/**
			 * Runs a hook invoking all registered callbacks with the given environment variables.
			 *
			 * Callbacks will be invoked synchronously and in the order in which they were registered.
			 *
			 * @param {string} name The name of the hook.
			 * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
			 * @public
			 */
			run: function (name, env) {
				var callbacks = _.hooks.all[name];

				if (!callbacks || !callbacks.length) {
					return;
				}

				for (var i = 0, callback; (callback = callbacks[i++]);) {
					callback(env);
				}
			}
		},

		Token: Token
	};
	_self.Prism = _;


	// Typescript note:
	// The following can be used to import the Token type in JSDoc:
	//
	//   @typedef {InstanceType<import("./prism-core")["Token"]>} Token

	/**
	 * Creates a new token.
	 *
	 * @param {string} type See {@link Token#type type}
	 * @param {string | TokenStream} content See {@link Token#content content}
	 * @param {string|string[]} [alias] The alias(es) of the token.
	 * @param {string} [matchedStr=""] A copy of the full string this token was created from.
	 * @class
	 * @global
	 * @public
	 */
	function Token(type, content, alias, matchedStr) {
		/**
		 * The type of the token.
		 *
		 * This is usually the key of a pattern in a {@link Grammar}.
		 *
		 * @type {string}
		 * @see GrammarToken
		 * @public
		 */
		this.type = type;
		/**
		 * The strings or tokens contained by this token.
		 *
		 * This will be a token stream if the pattern matched also defined an `inside` grammar.
		 *
		 * @type {string | TokenStream}
		 * @public
		 */
		this.content = content;
		/**
		 * The alias(es) of the token.
		 *
		 * @type {string|string[]}
		 * @see GrammarToken
		 * @public
		 */
		this.alias = alias;
		// Copy of the full string this token was created from
		this.length = (matchedStr || '').length | 0;
	}

	/**
	 * A token stream is an array of strings and {@link Token Token} objects.
	 *
	 * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process
	 * them.
	 *
	 * 1. No adjacent strings.
	 * 2. No empty strings.
	 *
	 *    The only exception here is the token stream that only contains the empty string and nothing else.
	 *
	 * @typedef {Array<string | Token>} TokenStream
	 * @global
	 * @public
	 */

	/**
	 * Converts the given token or token stream to an HTML representation.
	 *
	 * The following hooks will be run:
	 * 1. `wrap`: On each {@link Token}.
	 *
	 * @param {string | Token | TokenStream} o The token or token stream to be converted.
	 * @param {string} language The name of current language.
	 * @returns {string} The HTML representation of the token or token stream.
	 * @memberof Token
	 * @static
	 */
	Token.stringify = function stringify(o, language) {
		if (typeof o == 'string') {
			return o;
		}
		if (Array.isArray(o)) {
			var s = '';
			o.forEach(function (e) {
				s += stringify(e, language);
			});
			return s;
		}

		var env = {
			type: o.type,
			content: stringify(o.content, language),
			tag: 'span',
			classes: ['token', o.type],
			attributes: {},
			language: language
		};

		var aliases = o.alias;
		if (aliases) {
			if (Array.isArray(aliases)) {
				Array.prototype.push.apply(env.classes, aliases);
			} else {
				env.classes.push(aliases);
			}
		}

		_.hooks.run('wrap', env);

		var attributes = '';
		for (var name in env.attributes) {
			attributes += ' ' + name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
		}

		return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + attributes + '>' + env.content + '</' + env.tag + '>';
	};

	/**
	 * @param {RegExp} pattern
	 * @param {number} pos
	 * @param {string} text
	 * @param {boolean} lookbehind
	 * @returns {RegExpExecArray | null}
	 */
	function matchPattern(pattern, pos, text, lookbehind) {
		pattern.lastIndex = pos;
		var match = pattern.exec(text);
		if (match && lookbehind && match[1]) {
			// change the match to remove the text matched by the Prism lookbehind group
			var lookbehindLength = match[1].length;
			match.index += lookbehindLength;
			match[0] = match[0].slice(lookbehindLength);
		}
		return match;
	}

	/**
	 * @param {string} text
	 * @param {LinkedList<string | Token>} tokenList
	 * @param {any} grammar
	 * @param {LinkedListNode<string | Token>} startNode
	 * @param {number} startPos
	 * @param {RematchOptions} [rematch]
	 * @returns {void}
	 * @private
	 *
	 * @typedef RematchOptions
	 * @property {string} cause
	 * @property {number} reach
	 */
	function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
		for (var token in grammar) {
			if (!grammar.hasOwnProperty(token) || !grammar[token]) {
				continue;
			}

			var patterns = grammar[token];
			patterns = Array.isArray(patterns) ? patterns : [patterns];

			for (var j = 0; j < patterns.length; ++j) {
				if (rematch && rematch.cause == token + ',' + j) {
					return;
				}

				var patternObj = patterns[j];
				var inside = patternObj.inside;
				var lookbehind = !!patternObj.lookbehind;
				var greedy = !!patternObj.greedy;
				var alias = patternObj.alias;

				if (greedy && !patternObj.pattern.global) {
					// Without the global flag, lastIndex won't work
					var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
					patternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');
				}

				/** @type {RegExp} */
				var pattern = patternObj.pattern || patternObj;

				for ( // iterate the token list and keep track of the current token/string position
					var currentNode = startNode.next, pos = startPos;
					currentNode !== tokenList.tail;
					pos += currentNode.value.length, currentNode = currentNode.next
				) {

					if (rematch && pos >= rematch.reach) {
						break;
					}

					var str = currentNode.value;

					if (tokenList.length > text.length) {
						// Something went terribly wrong, ABORT, ABORT!
						return;
					}

					if (str instanceof Token) {
						continue;
					}

					var removeCount = 1; // this is the to parameter of removeBetween
					var match;

					if (greedy) {
						match = matchPattern(pattern, pos, text, lookbehind);
						if (!match || match.index >= text.length) {
							break;
						}

						var from = match.index;
						var to = match.index + match[0].length;
						var p = pos;

						// find the node that contains the match
						p += currentNode.value.length;
						while (from >= p) {
							currentNode = currentNode.next;
							p += currentNode.value.length;
						}
						// adjust pos (and p)
						p -= currentNode.value.length;
						pos = p;

						// the current node is a Token, then the match starts inside another Token, which is invalid
						if (currentNode.value instanceof Token) {
							continue;
						}

						// find the last node which is affected by this match
						for (
							var k = currentNode;
							k !== tokenList.tail && (p < to || typeof k.value === 'string');
							k = k.next
						) {
							removeCount++;
							p += k.value.length;
						}
						removeCount--;

						// replace with the new match
						str = text.slice(pos, p);
						match.index -= pos;
					} else {
						match = matchPattern(pattern, 0, str, lookbehind);
						if (!match) {
							continue;
						}
					}

					// eslint-disable-next-line no-redeclare
					var from = match.index;
					var matchStr = match[0];
					var before = str.slice(0, from);
					var after = str.slice(from + matchStr.length);

					var reach = pos + str.length;
					if (rematch && reach > rematch.reach) {
						rematch.reach = reach;
					}

					var removeFrom = currentNode.prev;

					if (before) {
						removeFrom = addAfter(tokenList, removeFrom, before);
						pos += before.length;
					}

					removeRange(tokenList, removeFrom, removeCount);

					var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
					currentNode = addAfter(tokenList, removeFrom, wrapped);

					if (after) {
						addAfter(tokenList, currentNode, after);
					}

					if (removeCount > 1) {
						// at least one Token object was removed, so we have to do some rematching
						// this can only happen if the current pattern is greedy

						/** @type {RematchOptions} */
						var nestedRematch = {
							cause: token + ',' + j,
							reach: reach
						};
						matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);

						// the reach might have been extended because of the rematching
						if (rematch && nestedRematch.reach > rematch.reach) {
							rematch.reach = nestedRematch.reach;
						}
					}
				}
			}
		}
	}

	/**
	 * @typedef LinkedListNode
	 * @property {T} value
	 * @property {LinkedListNode<T> | null} prev The previous node.
	 * @property {LinkedListNode<T> | null} next The next node.
	 * @template T
	 * @private
	 */

	/**
	 * @template T
	 * @private
	 */
	function LinkedList() {
		/** @type {LinkedListNode<T>} */
		var head = { value: null, prev: null, next: null };
		/** @type {LinkedListNode<T>} */
		var tail = { value: null, prev: head, next: null };
		head.next = tail;

		/** @type {LinkedListNode<T>} */
		this.head = head;
		/** @type {LinkedListNode<T>} */
		this.tail = tail;
		this.length = 0;
	}

	/**
	 * Adds a new node with the given value to the list.
	 *
	 * @param {LinkedList<T>} list
	 * @param {LinkedListNode<T>} node
	 * @param {T} value
	 * @returns {LinkedListNode<T>} The added node.
	 * @template T
	 */
	function addAfter(list, node, value) {
		// assumes that node != list.tail && values.length >= 0
		var next = node.next;

		var newNode = { value: value, prev: node, next: next };
		node.next = newNode;
		next.prev = newNode;
		list.length++;

		return newNode;
	}
	/**
	 * Removes `count` nodes after the given node. The given node will not be removed.
	 *
	 * @param {LinkedList<T>} list
	 * @param {LinkedListNode<T>} node
	 * @param {number} count
	 * @template T
	 */
	function removeRange(list, node, count) {
		var next = node.next;
		for (var i = 0; i < count && next !== list.tail; i++) {
			next = next.next;
		}
		node.next = next;
		next.prev = node;
		list.length -= i;
	}
	/**
	 * @param {LinkedList<T>} list
	 * @returns {T[]}
	 * @template T
	 */
	function toArray(list) {
		var array = [];
		var node = list.head.next;
		while (node !== list.tail) {
			array.push(node.value);
			node = node.next;
		}
		return array;
	}


	if (!_self.document) {
		if (!_self.addEventListener) {
			// in Node.js
			return _;
		}

		if (!_.disableWorkerMessageHandler) {
			// In worker
			_self.addEventListener('message', function (evt) {
				var message = JSON.parse(evt.data);
				var lang = message.language;
				var code = message.code;
				var immediateClose = message.immediateClose;

				_self.postMessage(_.highlight(code, _.languages[lang], lang));
				if (immediateClose) {
					_self.close();
				}
			}, false);
		}

		return _;
	}

	// Get current script and highlight
	var script = _.util.currentScript();

	if (script) {
		_.filename = script.src;

		if (script.hasAttribute('data-manual')) {
			_.manual = true;
		}
	}

	function highlightAutomaticallyCallback() {
		if (!_.manual) {
			_.highlightAll();
		}
	}

	if (!_.manual) {
		// If the document state is "loading", then we'll use DOMContentLoaded.
		// If the document state is "interactive" and the prism.js script is deferred, then we'll also use the
		// DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they
		// might take longer one animation frame to execute which can create a race condition where only some plugins have
		// been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.
		// See https://github.com/PrismJS/prism/issues/2102
		var readyState = document.readyState;
		if (readyState === 'loading' || readyState === 'interactive' && script && script.defer) {
			document.addEventListener('DOMContentLoaded', highlightAutomaticallyCallback);
		} else {
			if (window.requestAnimationFrame) {
				window.requestAnimationFrame(highlightAutomaticallyCallback);
			} else {
				window.setTimeout(highlightAutomaticallyCallback, 16);
			}
		}
	}

	return _;

}(_self));

if ( true && module.exports) {
	module.exports = Prism;
}

// hack for components to work correctly in node.js
if (typeof __webpack_require__.g !== 'undefined') {
	__webpack_require__.g.Prism = Prism;
}

// some additional documentation/types

/**
 * The expansion of a simple `RegExp` literal to support additional properties.
 *
 * @typedef GrammarToken
 * @property {RegExp} pattern The regular expression of the token.
 * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)
 * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.
 * @property {boolean} [greedy=false] Whether the token is greedy.
 * @property {string|string[]} [alias] An optional alias or list of aliases.
 * @property {Grammar} [inside] The nested grammar of this token.
 *
 * The `inside` grammar will be used to tokenize the text value of each token of this kind.
 *
 * This can be used to make nested and even recursive language definitions.
 *
 * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into
 * each another.
 * @global
 * @public
 */

/**
 * @typedef Grammar
 * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}
 * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.
 * @global
 * @public
 */

/**
 * A function which will invoked after an element was successfully highlighted.
 *
 * @callback HighlightCallback
 * @param {Element} element The element successfully highlighted.
 * @returns {void}
 * @global
 * @public
 */

/**
 * @callback HookCallback
 * @param {Object<string, any>} env The environment variables of the hook.
 * @returns {void}
 * @global
 * @public
 */


/* **********************************************
     Begin prism-markup.js
********************************************** */

Prism.languages.markup = {
	'comment': {
		pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
		greedy: true
	},
	'prolog': {
		pattern: /<\?[\s\S]+?\?>/,
		greedy: true
	},
	'doctype': {
		// https://www.w3.org/TR/xml/#NT-doctypedecl
		pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
		greedy: true,
		inside: {
			'internal-subset': {
				pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
				lookbehind: true,
				greedy: true,
				inside: null // see below
			},
			'string': {
				pattern: /"[^"]*"|'[^']*'/,
				greedy: true
			},
			'punctuation': /^<!|>$|[[\]]/,
			'doctype-tag': /^DOCTYPE/i,
			'name': /[^\s<>'"]+/
		}
	},
	'cdata': {
		pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
		greedy: true
	},
	'tag': {
		pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
		greedy: true,
		inside: {
			'tag': {
				pattern: /^<\/?[^\s>\/]+/,
				inside: {
					'punctuation': /^<\/?/,
					'namespace': /^[^\s>\/:]+:/
				}
			},
			'special-attr': [],
			'attr-value': {
				pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
				inside: {
					'punctuation': [
						{
							pattern: /^=/,
							alias: 'attr-equals'
						},
						/"|'/
					]
				}
			},
			'punctuation': /\/?>/,
			'attr-name': {
				pattern: /[^\s>\/]+/,
				inside: {
					'namespace': /^[^\s>\/:]+:/
				}
			}

		}
	},
	'entity': [
		{
			pattern: /&[\da-z]{1,8};/i,
			alias: 'named-entity'
		},
		/&#x?[\da-f]{1,8};/i
	]
};

Prism.languages.markup['tag'].inside['attr-value'].inside['entity'] =
	Prism.languages.markup['entity'];
Prism.languages.markup['doctype'].inside['internal-subset'].inside = Prism.languages.markup;

// Plugin to make entity title show the real entity, idea by Roman Komarov
Prism.hooks.add('wrap', function (env) {

	if (env.type === 'entity') {
		env.attributes['title'] = env.content.replace(/&amp;/, '&');
	}
});

Object.defineProperty(Prism.languages.markup.tag, 'addInlined', {
	/**
	 * Adds an inlined language to markup.
	 *
	 * An example of an inlined language is CSS with `<style>` tags.
	 *
	 * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
	 * case insensitive.
	 * @param {string} lang The language key.
	 * @example
	 * addInlined('style', 'css');
	 */
	value: function addInlined(tagName, lang) {
		var includedCdataInside = {};
		includedCdataInside['language-' + lang] = {
			pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
			lookbehind: true,
			inside: Prism.languages[lang]
		};
		includedCdataInside['cdata'] = /^<!\[CDATA\[|\]\]>$/i;

		var inside = {
			'included-cdata': {
				pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
				inside: includedCdataInside
			}
		};
		inside['language-' + lang] = {
			pattern: /[\s\S]+/,
			inside: Prism.languages[lang]
		};

		var def = {};
		def[tagName] = {
			pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function () { return tagName; }), 'i'),
			lookbehind: true,
			greedy: true,
			inside: inside
		};

		Prism.languages.insertBefore('markup', 'cdata', def);
	}
});
Object.defineProperty(Prism.languages.markup.tag, 'addAttribute', {
	/**
	 * Adds an pattern to highlight languages embedded in HTML attributes.
	 *
	 * An example of an inlined language is CSS with `style` attributes.
	 *
	 * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
	 * case insensitive.
	 * @param {string} lang The language key.
	 * @example
	 * addAttribute('style', 'css');
	 */
	value: function (attrName, lang) {
		Prism.languages.markup.tag.inside['special-attr'].push({
			pattern: RegExp(
				/(^|["'\s])/.source + '(?:' + attrName + ')' + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
				'i'
			),
			lookbehind: true,
			inside: {
				'attr-name': /^[^\s=]+/,
				'attr-value': {
					pattern: /=[\s\S]+/,
					inside: {
						'value': {
							pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
							lookbehind: true,
							alias: [lang, 'language-' + lang],
							inside: Prism.languages[lang]
						},
						'punctuation': [
							{
								pattern: /^=/,
								alias: 'attr-equals'
							},
							/"|'/
						]
					}
				}
			}
		});
	}
});

Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;

Prism.languages.xml = Prism.languages.extend('markup', {});
Prism.languages.ssml = Prism.languages.xml;
Prism.languages.atom = Prism.languages.xml;
Prism.languages.rss = Prism.languages.xml;


/* **********************************************
     Begin prism-css.js
********************************************** */

(function (Prism) {

	var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;

	Prism.languages.css = {
		'comment': /\/\*[\s\S]*?\*\//,
		'atrule': {
			pattern: /@[\w-](?:[^;{\s]|\s+(?![\s{]))*(?:;|(?=\s*\{))/,
			inside: {
				'rule': /^@[\w-]+/,
				'selector-function-argument': {
					pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
					lookbehind: true,
					alias: 'selector'
				},
				'keyword': {
					pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
					lookbehind: true
				}
				// See rest below
			}
		},
		'url': {
			// https://drafts.csswg.org/css-values-3/#urls
			pattern: RegExp('\\burl\\((?:' + string.source + '|' + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ')\\)', 'i'),
			greedy: true,
			inside: {
				'function': /^url/i,
				'punctuation': /^\(|\)$/,
				'string': {
					pattern: RegExp('^' + string.source + '$'),
					alias: 'url'
				}
			}
		},
		'selector': {
			pattern: RegExp('(^|[{}\\s])[^{}\\s](?:[^{};"\'\\s]|\\s+(?![\\s{])|' + string.source + ')*(?=\\s*\\{)'),
			lookbehind: true
		},
		'string': {
			pattern: string,
			greedy: true
		},
		'property': {
			pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
			lookbehind: true
		},
		'important': /!important\b/i,
		'function': {
			pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
			lookbehind: true
		},
		'punctuation': /[(){};:,]/
	};

	Prism.languages.css['atrule'].inside.rest = Prism.languages.css;

	var markup = Prism.languages.markup;
	if (markup) {
		markup.tag.addInlined('style', 'css');
		markup.tag.addAttribute('style', 'css');
	}

}(Prism));


/* **********************************************
     Begin prism-clike.js
********************************************** */

Prism.languages.clike = {
	'comment': [
		{
			pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
			lookbehind: true,
			greedy: true
		},
		{
			pattern: /(^|[^\\:])\/\/.*/,
			lookbehind: true,
			greedy: true
		}
	],
	'string': {
		pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
		greedy: true
	},
	'class-name': {
		pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
		lookbehind: true,
		inside: {
			'punctuation': /[.\\]/
		}
	},
	'keyword': /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
	'boolean': /\b(?:false|true)\b/,
	'function': /\b\w+(?=\()/,
	'number': /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
	'operator': /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
	'punctuation': /[{}[\];(),.:]/
};


/* **********************************************
     Begin prism-javascript.js
********************************************** */

Prism.languages.javascript = Prism.languages.extend('clike', {
	'class-name': [
		Prism.languages.clike['class-name'],
		{
			pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
			lookbehind: true
		}
	],
	'keyword': [
		{
			pattern: /((?:^|\})\s*)catch\b/,
			lookbehind: true
		},
		{
			pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
			lookbehind: true
		},
	],
	// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
	'function': /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
	'number': {
		pattern: RegExp(
			/(^|[^\w$])/.source +
			'(?:' +
			(
				// constant
				/NaN|Infinity/.source +
				'|' +
				// binary integer
				/0[bB][01]+(?:_[01]+)*n?/.source +
				'|' +
				// octal integer
				/0[oO][0-7]+(?:_[0-7]+)*n?/.source +
				'|' +
				// hexadecimal integer
				/0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source +
				'|' +
				// decimal bigint
				/\d+(?:_\d+)*n/.source +
				'|' +
				// decimal number (integer or float) but no bigint
				/(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source
			) +
			')' +
			/(?![\w$])/.source
		),
		lookbehind: true
	},
	'operator': /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
});

Prism.languages.javascript['class-name'][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;

Prism.languages.insertBefore('javascript', 'keyword', {
	'regex': {
		pattern: RegExp(
			// lookbehind
			// eslint-disable-next-line regexp/no-dupe-characters-character-class
			/((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source +
			// Regex pattern:
			// There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
			// classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
			// with the only syntax, so we have to define 2 different regex patterns.
			/\//.source +
			'(?:' +
			/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source +
			'|' +
			// `v` flag syntax. This supports 3 levels of nested character classes.
			/(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source +
			')' +
			// lookahead
			/(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
		),
		lookbehind: true,
		greedy: true,
		inside: {
			'regex-source': {
				pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
				lookbehind: true,
				alias: 'language-regex',
				inside: Prism.languages.regex
			},
			'regex-delimiter': /^\/|\/$/,
			'regex-flags': /^[a-z]+$/,
		}
	},
	// This must be declared before keyword because we use "function" inside the look-forward
	'function-variable': {
		pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
		alias: 'function'
	},
	'parameter': [
		{
			pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
			lookbehind: true,
			inside: Prism.languages.javascript
		},
		{
			pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
			lookbehind: true,
			inside: Prism.languages.javascript
		},
		{
			pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
			lookbehind: true,
			inside: Prism.languages.javascript
		},
		{
			pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
			lookbehind: true,
			inside: Prism.languages.javascript
		}
	],
	'constant': /\b[A-Z](?:[A-Z_]|\dx?)*\b/
});

Prism.languages.insertBefore('javascript', 'string', {
	'hashbang': {
		pattern: /^#!.*/,
		greedy: true,
		alias: 'comment'
	},
	'template-string': {
		pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
		greedy: true,
		inside: {
			'template-punctuation': {
				pattern: /^`|`$/,
				alias: 'string'
			},
			'interpolation': {
				pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
				lookbehind: true,
				inside: {
					'interpolation-punctuation': {
						pattern: /^\$\{|\}$/,
						alias: 'punctuation'
					},
					rest: Prism.languages.javascript
				}
			},
			'string': /[\s\S]+/
		}
	},
	'string-property': {
		pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
		lookbehind: true,
		greedy: true,
		alias: 'property'
	}
});

Prism.languages.insertBefore('javascript', 'operator', {
	'literal-property': {
		pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
		lookbehind: true,
		alias: 'property'
	},
});

if (Prism.languages.markup) {
	Prism.languages.markup.tag.addInlined('script', 'javascript');

	// add attribute support for all DOM events.
	// https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events
	Prism.languages.markup.tag.addAttribute(
		/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
		'javascript'
	);
}

Prism.languages.js = Prism.languages.javascript;


/* **********************************************
     Begin prism-file-highlight.js
********************************************** */

(function () {

	if (typeof Prism === 'undefined' || typeof document === 'undefined') {
		return;
	}

	// https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill
	if (!Element.prototype.matches) {
		Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
	}

	var LOADING_MESSAGE = 'Loading…';
	var FAILURE_MESSAGE = function (status, message) {
		return '✖ Error ' + status + ' while fetching file: ' + message;
	};
	var FAILURE_EMPTY_MESSAGE = '✖ Error: File does not exist or is empty';

	var EXTENSIONS = {
		'js': 'javascript',
		'py': 'python',
		'rb': 'ruby',
		'ps1': 'powershell',
		'psm1': 'powershell',
		'sh': 'bash',
		'bat': 'batch',
		'h': 'c',
		'tex': 'latex'
	};

	var STATUS_ATTR = 'data-src-status';
	var STATUS_LOADING = 'loading';
	var STATUS_LOADED = 'loaded';
	var STATUS_FAILED = 'failed';

	var SELECTOR = 'pre[data-src]:not([' + STATUS_ATTR + '="' + STATUS_LOADED + '"])'
		+ ':not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';

	/**
	 * Loads the given file.
	 *
	 * @param {string} src The URL or path of the source file to load.
	 * @param {(result: string) => void} success
	 * @param {(reason: string) => void} error
	 */
	function loadFile(src, success, error) {
		var xhr = new XMLHttpRequest();
		xhr.open('GET', src, true);
		xhr.onreadystatechange = function () {
			if (xhr.readyState == 4) {
				if (xhr.status < 400 && xhr.responseText) {
					success(xhr.responseText);
				} else {
					if (xhr.status >= 400) {
						error(FAILURE_MESSAGE(xhr.status, xhr.statusText));
					} else {
						error(FAILURE_EMPTY_MESSAGE);
					}
				}
			}
		};
		xhr.send(null);
	}

	/**
	 * Parses the given range.
	 *
	 * This returns a range with inclusive ends.
	 *
	 * @param {string | null | undefined} range
	 * @returns {[number, number | undefined] | undefined}
	 */
	function parseRange(range) {
		var m = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range || '');
		if (m) {
			var start = Number(m[1]);
			var comma = m[2];
			var end = m[3];

			if (!comma) {
				return [start, start];
			}
			if (!end) {
				return [start, undefined];
			}
			return [start, Number(end)];
		}
		return undefined;
	}

	Prism.hooks.add('before-highlightall', function (env) {
		env.selector += ', ' + SELECTOR;
	});

	Prism.hooks.add('before-sanity-check', function (env) {
		var pre = /** @type {HTMLPreElement} */ (env.element);
		if (pre.matches(SELECTOR)) {
			env.code = ''; // fast-path the whole thing and go to complete

			pre.setAttribute(STATUS_ATTR, STATUS_LOADING); // mark as loading

			// add code element with loading message
			var code = pre.appendChild(document.createElement('CODE'));
			code.textContent = LOADING_MESSAGE;

			var src = pre.getAttribute('data-src');

			var language = env.language;
			if (language === 'none') {
				// the language might be 'none' because there is no language set;
				// in this case, we want to use the extension as the language
				var extension = (/\.(\w+)$/.exec(src) || [, 'none'])[1];
				language = EXTENSIONS[extension] || extension;
			}

			// set language classes
			Prism.util.setLanguage(code, language);
			Prism.util.setLanguage(pre, language);

			// preload the language
			var autoloader = Prism.plugins.autoloader;
			if (autoloader) {
				autoloader.loadLanguages(language);
			}

			// load file
			loadFile(
				src,
				function (text) {
					// mark as loaded
					pre.setAttribute(STATUS_ATTR, STATUS_LOADED);

					// handle data-range
					var range = parseRange(pre.getAttribute('data-range'));
					if (range) {
						var lines = text.split(/\r\n?|\n/g);

						// the range is one-based and inclusive on both ends
						var start = range[0];
						var end = range[1] == null ? lines.length : range[1];

						if (start < 0) { start += lines.length; }
						start = Math.max(0, Math.min(start - 1, lines.length));
						if (end < 0) { end += lines.length; }
						end = Math.max(0, Math.min(end, lines.length));

						text = lines.slice(start, end).join('\n');

						// add data-start for line numbers
						if (!pre.hasAttribute('data-start')) {
							pre.setAttribute('data-start', String(start + 1));
						}
					}

					// highlight code
					code.textContent = text;
					Prism.highlightElement(code);
				},
				function (error) {
					// mark as failed
					pre.setAttribute(STATUS_ATTR, STATUS_FAILED);

					code.textContent = error;
				}
			);
		}
	});

	Prism.plugins.fileHighlight = {
		/**
		 * Executes the File Highlight plugin for all matching `pre` elements under the given container.
		 *
		 * Note: Elements which are already loaded or currently loading will not be touched by this method.
		 *
		 * @param {ParentNode} [container=document]
		 */
		highlight: function highlight(container) {
			var elements = (container || document).querySelectorAll(SELECTOR);

			for (var i = 0, element; (element = elements[i++]);) {
				Prism.highlightElement(element);
			}
		}
	};

	var logged = false;
	/** @deprecated Use `Prism.plugins.fileHighlight.highlight` instead. */
	Prism.fileHighlight = function () {
		if (!logged) {
			console.warn('Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.');
			logged = true;
		}
		Prism.plugins.fileHighlight.highlight.apply(this, arguments);
	};

}());


/***/ }),

/***/ "../structured-text-editor/node_modules/tippy.js/dist/tippy.esm.js":
/*!*************************************************************************!*\
  !*** ../structured-text-editor/node_modules/tippy.js/dist/tippy.esm.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "animateFill": () => (/* binding */ animateFill),
/* harmony export */   "createSingleton": () => (/* binding */ createSingleton),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "delegate": () => (/* binding */ delegate),
/* harmony export */   "followCursor": () => (/* binding */ followCursor),
/* harmony export */   "hideAll": () => (/* binding */ hideAll),
/* harmony export */   "inlinePositioning": () => (/* binding */ inlinePositioning),
/* harmony export */   "roundArrow": () => (/* binding */ ROUND_ARROW),
/* harmony export */   "sticky": () => (/* binding */ sticky)
/* harmony export */ });
/* harmony import */ var _popperjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @popperjs/core */ "../structured-text-editor/node_modules/@popperjs/core/lib/popper.js");
/**!
* tippy.js v6.2.3
* (c) 2017-2020 atomiks
* MIT License
*/


var ROUND_ARROW = '<svg width="16" height="6" xmlns="http://www.w3.org/2000/svg"><path d="M0 6s1.796-.013 4.67-3.615C5.851.9 6.93.006 8 0c1.07-.006 2.148.887 3.343 2.385C14.233 6.005 16 6 16 6H0z"></svg>';
var BOX_CLASS = "tippy-box";
var CONTENT_CLASS = "tippy-content";
var BACKDROP_CLASS = "tippy-backdrop";
var ARROW_CLASS = "tippy-arrow";
var SVG_ARROW_CLASS = "tippy-svg-arrow";
var TOUCH_OPTIONS = {
  passive: true,
  capture: true
};

function hasOwnProperty(obj, key) {
  return {}.hasOwnProperty.call(obj, key);
}
function getValueAtIndexOrReturn(value, index, defaultValue) {
  if (Array.isArray(value)) {
    var v = value[index];
    return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;
  }

  return value;
}
function isType(value, type) {
  var str = {}.toString.call(value);
  return str.indexOf('[object') === 0 && str.indexOf(type + "]") > -1;
}
function invokeWithArgsOrReturn(value, args) {
  return typeof value === 'function' ? value.apply(void 0, args) : value;
}
function debounce(fn, ms) {
  // Avoid wrapping in `setTimeout` if ms is 0 anyway
  if (ms === 0) {
    return fn;
  }

  var timeout;
  return function (arg) {
    clearTimeout(timeout);
    timeout = setTimeout(function () {
      fn(arg);
    }, ms);
  };
}
function removeProperties(obj, keys) {
  var clone = Object.assign({}, obj);
  keys.forEach(function (key) {
    delete clone[key];
  });
  return clone;
}
function splitBySpaces(value) {
  return value.split(/\s+/).filter(Boolean);
}
function normalizeToArray(value) {
  return [].concat(value);
}
function pushIfUnique(arr, value) {
  if (arr.indexOf(value) === -1) {
    arr.push(value);
  }
}
function unique(arr) {
  return arr.filter(function (item, index) {
    return arr.indexOf(item) === index;
  });
}
function getBasePlacement(placement) {
  return placement.split('-')[0];
}
function arrayFrom(value) {
  return [].slice.call(value);
}

function div() {
  return document.createElement('div');
}
function isElement(value) {
  return ['Element', 'Fragment'].some(function (type) {
    return isType(value, type);
  });
}
function isNodeList(value) {
  return isType(value, 'NodeList');
}
function isMouseEvent(value) {
  return isType(value, 'MouseEvent');
}
function isReferenceElement(value) {
  return !!(value && value._tippy && value._tippy.reference === value);
}
function getArrayOfElements(value) {
  if (isElement(value)) {
    return [value];
  }

  if (isNodeList(value)) {
    return arrayFrom(value);
  }

  if (Array.isArray(value)) {
    return value;
  }

  return arrayFrom(document.querySelectorAll(value));
}
function setTransitionDuration(els, value) {
  els.forEach(function (el) {
    if (el) {
      el.style.transitionDuration = value + "ms";
    }
  });
}
function setVisibilityState(els, state) {
  els.forEach(function (el) {
    if (el) {
      el.setAttribute('data-state', state);
    }
  });
}
function getOwnerDocument(elementOrElements) {
  var _normalizeToArray = normalizeToArray(elementOrElements),
      element = _normalizeToArray[0];

  return element ? element.ownerDocument || document : document;
}
function isCursorOutsideInteractiveBorder(popperTreeData, event) {
  var clientX = event.clientX,
      clientY = event.clientY;
  return popperTreeData.every(function (_ref) {
    var popperRect = _ref.popperRect,
        popperState = _ref.popperState,
        props = _ref.props;
    var interactiveBorder = props.interactiveBorder;
    var basePlacement = getBasePlacement(popperState.placement);
    var offsetData = popperState.modifiersData.offset;

    if (!offsetData) {
      return true;
    }

    var topDistance = basePlacement === 'bottom' ? offsetData.top.y : 0;
    var bottomDistance = basePlacement === 'top' ? offsetData.bottom.y : 0;
    var leftDistance = basePlacement === 'right' ? offsetData.left.x : 0;
    var rightDistance = basePlacement === 'left' ? offsetData.right.x : 0;
    var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
    var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
    var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
    var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
  });
}
function updateTransitionEndListener(box, action, listener) {
  var method = action + "EventListener"; // some browsers apparently support `transition` (unprefixed) but only fire
  // `webkitTransitionEnd`...

  ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {
    box[method](event, listener);
  });
}

var currentInput = {
  isTouch: false
};
var lastMouseMoveTime = 0;
/**
 * When a `touchstart` event is fired, it's assumed the user is using touch
 * input. We'll bind a `mousemove` event listener to listen for mouse input in
 * the future. This way, the `isTouch` property is fully dynamic and will handle
 * hybrid devices that use a mix of touch + mouse input.
 */

function onDocumentTouchStart() {
  if (currentInput.isTouch) {
    return;
  }

  currentInput.isTouch = true;

  if (window.performance) {
    document.addEventListener('mousemove', onDocumentMouseMove);
  }
}
/**
 * When two `mousemove` event are fired consecutively within 20ms, it's assumed
 * the user is using mouse input again. `mousemove` can fire on touch devices as
 * well, but very rarely that quickly.
 */

function onDocumentMouseMove() {
  var now = performance.now();

  if (now - lastMouseMoveTime < 20) {
    currentInput.isTouch = false;
    document.removeEventListener('mousemove', onDocumentMouseMove);
  }

  lastMouseMoveTime = now;
}
/**
 * When an element is in focus and has a tippy, leaving the tab/window and
 * returning causes it to show again. For mouse users this is unexpected, but
 * for keyboard use it makes sense.
 * TODO: find a better technique to solve this problem
 */

function onWindowBlur() {
  var activeElement = document.activeElement;

  if (isReferenceElement(activeElement)) {
    var instance = activeElement._tippy;

    if (activeElement.blur && !instance.state.isVisible) {
      activeElement.blur();
    }
  }
}
function bindGlobalEventListeners() {
  document.addEventListener('touchstart', onDocumentTouchStart, TOUCH_OPTIONS);
  window.addEventListener('blur', onWindowBlur);
}

var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
var ua = isBrowser ? navigator.userAgent : '';
var isIE = /MSIE |Trident\//.test(ua);

function createMemoryLeakWarning(method) {
  var txt = method === 'destroy' ? 'n already-' : ' ';
  return [method + "() was called on a" + txt + "destroyed instance. This is a no-op but", 'indicates a potential memory leak.'].join(' ');
}
function clean(value) {
  var spacesAndTabs = /[ \t]{2,}/g;
  var lineStartWithSpaces = /^[ \t]*/gm;
  return value.replace(spacesAndTabs, ' ').replace(lineStartWithSpaces, '').trim();
}

function getDevMessage(message) {
  return clean("\n  %ctippy.js\n\n  %c" + clean(message) + "\n\n  %c\uD83D\uDC77\u200D This is a development-only message. It will be removed in production.\n  ");
}

function getFormattedMessage(message) {
  return [getDevMessage(message), // title
  'color: #00C584; font-size: 1.3em; font-weight: bold;', // message
  'line-height: 1.5', // footer
  'color: #a6a095;'];
} // Assume warnings and errors never have the same message

var visitedMessages;

if (true) {
  resetVisitedMessages();
}

function resetVisitedMessages() {
  visitedMessages = new Set();
}
function warnWhen(condition, message) {
  if (condition && !visitedMessages.has(message)) {
    var _console;

    visitedMessages.add(message);

    (_console = console).warn.apply(_console, getFormattedMessage(message));
  }
}
function errorWhen(condition, message) {
  if (condition && !visitedMessages.has(message)) {
    var _console2;

    visitedMessages.add(message);

    (_console2 = console).error.apply(_console2, getFormattedMessage(message));
  }
}
function validateTargets(targets) {
  var didPassFalsyValue = !targets;
  var didPassPlainObject = Object.prototype.toString.call(targets) === '[object Object]' && !targets.addEventListener;
  errorWhen(didPassFalsyValue, ['tippy() was passed', '`' + String(targets) + '`', 'as its targets (first) argument. Valid types are: String, Element,', 'Element[], or NodeList.'].join(' '));
  errorWhen(didPassPlainObject, ['tippy() was passed a plain object which is not supported as an argument', 'for virtual positioning. Use props.getReferenceClientRect instead.'].join(' '));
}

var pluginProps = {
  animateFill: false,
  followCursor: false,
  inlinePositioning: false,
  sticky: false
};
var renderProps = {
  allowHTML: false,
  animation: 'fade',
  arrow: true,
  content: '',
  inertia: false,
  maxWidth: 350,
  role: 'tooltip',
  theme: '',
  zIndex: 9999
};
var defaultProps = Object.assign({
  appendTo: function appendTo() {
    return document.body;
  },
  aria: {
    content: 'auto',
    expanded: 'auto'
  },
  delay: 0,
  duration: [300, 250],
  getReferenceClientRect: null,
  hideOnClick: true,
  ignoreAttributes: false,
  interactive: false,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  moveTransition: '',
  offset: [0, 10],
  onAfterUpdate: function onAfterUpdate() {},
  onBeforeUpdate: function onBeforeUpdate() {},
  onCreate: function onCreate() {},
  onDestroy: function onDestroy() {},
  onHidden: function onHidden() {},
  onHide: function onHide() {},
  onMount: function onMount() {},
  onShow: function onShow() {},
  onShown: function onShown() {},
  onTrigger: function onTrigger() {},
  onUntrigger: function onUntrigger() {},
  onClickOutside: function onClickOutside() {},
  placement: 'top',
  plugins: [],
  popperOptions: {},
  render: null,
  showOnCreate: false,
  touch: true,
  trigger: 'mouseenter focus',
  triggerTarget: null
}, pluginProps, {}, renderProps);
var defaultKeys = Object.keys(defaultProps);
var setDefaultProps = function setDefaultProps(partialProps) {
  /* istanbul ignore else */
  if (true) {
    validateProps(partialProps, []);
  }

  var keys = Object.keys(partialProps);
  keys.forEach(function (key) {
    defaultProps[key] = partialProps[key];
  });
};
function getExtendedPassedProps(passedProps) {
  var plugins = passedProps.plugins || [];
  var pluginProps = plugins.reduce(function (acc, plugin) {
    var name = plugin.name,
        defaultValue = plugin.defaultValue;

    if (name) {
      acc[name] = passedProps[name] !== undefined ? passedProps[name] : defaultValue;
    }

    return acc;
  }, {});
  return Object.assign({}, passedProps, {}, pluginProps);
}
function getDataAttributeProps(reference, plugins) {
  var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
    plugins: plugins
  }))) : defaultKeys;
  var props = propKeys.reduce(function (acc, key) {
    var valueAsString = (reference.getAttribute("data-tippy-" + key) || '').trim();

    if (!valueAsString) {
      return acc;
    }

    if (key === 'content') {
      acc[key] = valueAsString;
    } else {
      try {
        acc[key] = JSON.parse(valueAsString);
      } catch (e) {
        acc[key] = valueAsString;
      }
    }

    return acc;
  }, {});
  return props;
}
function evaluateProps(reference, props) {
  var out = Object.assign({}, props, {
    content: invokeWithArgsOrReturn(props.content, [reference])
  }, props.ignoreAttributes ? {} : getDataAttributeProps(reference, props.plugins));
  out.aria = Object.assign({}, defaultProps.aria, {}, out.aria);
  out.aria = {
    expanded: out.aria.expanded === 'auto' ? props.interactive : out.aria.expanded,
    content: out.aria.content === 'auto' ? props.interactive ? null : 'describedby' : out.aria.content
  };
  return out;
}
function validateProps(partialProps, plugins) {
  if (partialProps === void 0) {
    partialProps = {};
  }

  if (plugins === void 0) {
    plugins = [];
  }

  var keys = Object.keys(partialProps);
  keys.forEach(function (prop) {
    var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));
    var didPassUnknownProp = !hasOwnProperty(nonPluginProps, prop); // Check if the prop exists in `plugins`

    if (didPassUnknownProp) {
      didPassUnknownProp = plugins.filter(function (plugin) {
        return plugin.name === prop;
      }).length === 0;
    }

    warnWhen(didPassUnknownProp, ["`" + prop + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", 'a plugin, forgot to pass it in an array as props.plugins.', '\n\n', 'All props: https://atomiks.github.io/tippyjs/v6/all-props/\n', 'Plugins: https://atomiks.github.io/tippyjs/v6/plugins/'].join(' '));
  });
}

var innerHTML = function innerHTML() {
  return 'innerHTML';
};

function dangerouslySetInnerHTML(element, html) {
  element[innerHTML()] = html;
}

function createArrowElement(value) {
  var arrow = div();

  if (value === true) {
    arrow.className = ARROW_CLASS;
  } else {
    arrow.className = SVG_ARROW_CLASS;

    if (isElement(value)) {
      arrow.appendChild(value);
    } else {
      dangerouslySetInnerHTML(arrow, value);
    }
  }

  return arrow;
}

function setContent(content, props) {
  if (isElement(props.content)) {
    dangerouslySetInnerHTML(content, '');
    content.appendChild(props.content);
  } else if (typeof props.content !== 'function') {
    if (props.allowHTML) {
      dangerouslySetInnerHTML(content, props.content);
    } else {
      content.textContent = props.content;
    }
  }
}
function getChildren(popper) {
  var box = popper.firstElementChild;
  var boxChildren = arrayFrom(box.children);
  return {
    box: box,
    content: boxChildren.find(function (node) {
      return node.classList.contains(CONTENT_CLASS);
    }),
    arrow: boxChildren.find(function (node) {
      return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
    }),
    backdrop: boxChildren.find(function (node) {
      return node.classList.contains(BACKDROP_CLASS);
    })
  };
}
function render(instance) {
  var popper = div();
  var box = div();
  box.className = BOX_CLASS;
  box.setAttribute('data-state', 'hidden');
  box.setAttribute('tabindex', '-1');
  var content = div();
  content.className = CONTENT_CLASS;
  content.setAttribute('data-state', 'hidden');
  setContent(content, instance.props);
  popper.appendChild(box);
  box.appendChild(content);
  onUpdate(instance.props, instance.props);

  function onUpdate(prevProps, nextProps) {
    var _getChildren = getChildren(popper),
        box = _getChildren.box,
        content = _getChildren.content,
        arrow = _getChildren.arrow;

    if (nextProps.theme) {
      box.setAttribute('data-theme', nextProps.theme);
    } else {
      box.removeAttribute('data-theme');
    }

    if (typeof nextProps.animation === 'string') {
      box.setAttribute('data-animation', nextProps.animation);
    } else {
      box.removeAttribute('data-animation');
    }

    if (nextProps.inertia) {
      box.setAttribute('data-inertia', '');
    } else {
      box.removeAttribute('data-inertia');
    }

    box.style.maxWidth = typeof nextProps.maxWidth === 'number' ? nextProps.maxWidth + "px" : nextProps.maxWidth;

    if (nextProps.role) {
      box.setAttribute('role', nextProps.role);
    } else {
      box.removeAttribute('role');
    }

    if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
      setContent(content, instance.props);
    }

    if (nextProps.arrow) {
      if (!arrow) {
        box.appendChild(createArrowElement(nextProps.arrow));
      } else if (prevProps.arrow !== nextProps.arrow) {
        box.removeChild(arrow);
        box.appendChild(createArrowElement(nextProps.arrow));
      }
    } else if (arrow) {
      box.removeChild(arrow);
    }
  }

  return {
    popper: popper,
    onUpdate: onUpdate
  };
} // Runtime check to identify if the render function is the default one; this
// way we can apply default CSS transitions logic and it can be tree-shaken away

render.$$tippy = true;

var idCounter = 1;
var mouseMoveListeners = []; // Used by `hideAll()`

var mountedInstances = [];
function createTippy(reference, passedProps) {
  var props = evaluateProps(reference, Object.assign({}, defaultProps, {}, getExtendedPassedProps(passedProps))); // ===========================================================================
  // 🔒 Private members
  // ===========================================================================

  var showTimeout;
  var hideTimeout;
  var scheduleHideAnimationFrame;
  var isVisibleFromClick = false;
  var didHideDueToDocumentMouseDown = false;
  var didTouchMove = false;
  var ignoreOnFirstUpdate = false;
  var lastTriggerEvent;
  var currentTransitionEndListener;
  var onFirstUpdate;
  var listeners = [];
  var debouncedOnMouseMove = debounce(onMouseMove, props.interactiveDebounce);
  var currentTarget;
  var doc = getOwnerDocument(props.triggerTarget || reference); // ===========================================================================
  // 🔑 Public members
  // ===========================================================================

  var id = idCounter++;
  var popperInstance = null;
  var plugins = unique(props.plugins);
  var state = {
    // Is the instance currently enabled?
    isEnabled: true,
    // Is the tippy currently showing and not transitioning out?
    isVisible: false,
    // Has the instance been destroyed?
    isDestroyed: false,
    // Is the tippy currently mounted to the DOM?
    isMounted: false,
    // Has the tippy finished transitioning in?
    isShown: false
  };
  var instance = {
    // properties
    id: id,
    reference: reference,
    popper: div(),
    popperInstance: popperInstance,
    props: props,
    state: state,
    plugins: plugins,
    // methods
    clearDelayTimeouts: clearDelayTimeouts,
    setProps: setProps,
    setContent: setContent,
    show: show,
    hide: hide,
    hideWithInteractivity: hideWithInteractivity,
    enable: enable,
    disable: disable,
    unmount: unmount,
    destroy: destroy
  }; // TODO: Investigate why this early return causes a TDZ error in the tests —
  // it doesn't seem to happen in the browser

  /* istanbul ignore if */

  if (!props.render) {
    if (true) {
      errorWhen(true, 'render() function has not been supplied.');
    }

    return instance;
  } // ===========================================================================
  // Initial mutations
  // ===========================================================================


  var _props$render = props.render(instance),
      popper = _props$render.popper,
      onUpdate = _props$render.onUpdate;

  popper.setAttribute('data-tippy-root', '');
  popper.id = "tippy-" + instance.id;
  instance.popper = popper;
  reference._tippy = instance;
  popper._tippy = instance;
  var pluginsHooks = plugins.map(function (plugin) {
    return plugin.fn(instance);
  });
  var hasAriaExpanded = reference.hasAttribute('aria-expanded');
  addListeners();
  handleAriaExpandedAttribute();
  handleStyles();
  invokeHook('onCreate', [instance]);

  if (props.showOnCreate) {
    scheduleShow();
  } // Prevent a tippy with a delay from hiding if the cursor left then returned
  // before it started hiding


  popper.addEventListener('mouseenter', function () {
    if (instance.props.interactive && instance.state.isVisible) {
      instance.clearDelayTimeouts();
    }
  });
  popper.addEventListener('mouseleave', function (event) {
    if (instance.props.interactive && instance.props.trigger.indexOf('mouseenter') >= 0) {
      doc.addEventListener('mousemove', debouncedOnMouseMove);
      debouncedOnMouseMove(event);
    }
  });
  return instance; // ===========================================================================
  // 🔒 Private methods
  // ===========================================================================

  function getNormalizedTouchSettings() {
    var touch = instance.props.touch;
    return Array.isArray(touch) ? touch : [touch, 0];
  }

  function getIsCustomTouchBehavior() {
    return getNormalizedTouchSettings()[0] === 'hold';
  }

  function getIsDefaultRenderFn() {
    var _instance$props$rende;

    // @ts-ignore
    return !!((_instance$props$rende = instance.props.render) == null ? void 0 : _instance$props$rende.$$tippy);
  }

  function getCurrentTarget() {
    return currentTarget || reference;
  }

  function getDefaultTemplateChildren() {
    return getChildren(popper);
  }

  function getDelay(isShow) {
    // For touch or keyboard input, force `0` delay for UX reasons
    // Also if the instance is mounted but not visible (transitioning out),
    // ignore delay
    if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === 'focus') {
      return 0;
    }

    return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
  }

  function handleStyles() {
    popper.style.pointerEvents = instance.props.interactive && instance.state.isVisible ? '' : 'none';
    popper.style.zIndex = "" + instance.props.zIndex;
  }

  function invokeHook(hook, args, shouldInvokePropsHook) {
    if (shouldInvokePropsHook === void 0) {
      shouldInvokePropsHook = true;
    }

    pluginsHooks.forEach(function (pluginHooks) {
      if (pluginHooks[hook]) {
        pluginHooks[hook].apply(void 0, args);
      }
    });

    if (shouldInvokePropsHook) {
      var _instance$props;

      (_instance$props = instance.props)[hook].apply(_instance$props, args);
    }
  }

  function handleAriaContentAttribute() {
    var aria = instance.props.aria;

    if (!aria.content) {
      return;
    }

    var attr = "aria-" + aria.content;
    var id = popper.id;
    var nodes = normalizeToArray(instance.props.triggerTarget || reference);
    nodes.forEach(function (node) {
      var currentValue = node.getAttribute(attr);

      if (instance.state.isVisible) {
        node.setAttribute(attr, currentValue ? currentValue + " " + id : id);
      } else {
        var nextValue = currentValue && currentValue.replace(id, '').trim();

        if (nextValue) {
          node.setAttribute(attr, nextValue);
        } else {
          node.removeAttribute(attr);
        }
      }
    });
  }

  function handleAriaExpandedAttribute() {
    if (hasAriaExpanded || !instance.props.aria.expanded) {
      return;
    }

    var nodes = normalizeToArray(instance.props.triggerTarget || reference);
    nodes.forEach(function (node) {
      if (instance.props.interactive) {
        node.setAttribute('aria-expanded', instance.state.isVisible && node === getCurrentTarget() ? 'true' : 'false');
      } else {
        node.removeAttribute('aria-expanded');
      }
    });
  }

  function cleanupInteractiveMouseListeners() {
    doc.body.removeEventListener('mouseleave', scheduleHide);
    doc.removeEventListener('mousemove', debouncedOnMouseMove);
    mouseMoveListeners = mouseMoveListeners.filter(function (listener) {
      return listener !== debouncedOnMouseMove;
    });
  }

  function onDocumentPress(event) {
    // Moved finger to scroll instead of an intentional tap outside
    if (currentInput.isTouch) {
      if (didTouchMove || event.type === 'mousedown') {
        return;
      }
    } // Clicked on interactive popper


    if (instance.props.interactive && popper.contains(event.target)) {
      return;
    } // Clicked on the event listeners target


    if (getCurrentTarget().contains(event.target)) {
      if (currentInput.isTouch) {
        return;
      }

      if (instance.state.isVisible && instance.props.trigger.indexOf('click') >= 0) {
        return;
      }
    } else {
      invokeHook('onClickOutside', [instance, event]);
    }

    if (instance.props.hideOnClick === true) {
      isVisibleFromClick = false;
      instance.clearDelayTimeouts();
      instance.hide(); // `mousedown` event is fired right before `focus` if pressing the
      // currentTarget. This lets a tippy with `focus` trigger know that it
      // should not show

      didHideDueToDocumentMouseDown = true;
      setTimeout(function () {
        didHideDueToDocumentMouseDown = false;
      }); // The listener gets added in `scheduleShow()`, but this may be hiding it
      // before it shows, and hide()'s early bail-out behavior can prevent it
      // from being cleaned up

      if (!instance.state.isMounted) {
        removeDocumentPress();
      }
    }
  }

  function onTouchMove() {
    didTouchMove = true;
  }

  function onTouchStart() {
    didTouchMove = false;
  }

  function addDocumentPress() {
    doc.addEventListener('mousedown', onDocumentPress, true);
    doc.addEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);
    doc.addEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);
    doc.addEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);
  }

  function removeDocumentPress() {
    doc.removeEventListener('mousedown', onDocumentPress, true);
    doc.removeEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);
    doc.removeEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);
    doc.removeEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);
  }

  function onTransitionedOut(duration, callback) {
    onTransitionEnd(duration, function () {
      if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {
        callback();
      }
    });
  }

  function onTransitionedIn(duration, callback) {
    onTransitionEnd(duration, callback);
  }

  function onTransitionEnd(duration, callback) {
    var box = getDefaultTemplateChildren().box;

    function listener(event) {
      if (event.target === box) {
        updateTransitionEndListener(box, 'remove', listener);
        callback();
      }
    } // Make callback synchronous if duration is 0
    // `transitionend` won't fire otherwise


    if (duration === 0) {
      return callback();
    }

    updateTransitionEndListener(box, 'remove', currentTransitionEndListener);
    updateTransitionEndListener(box, 'add', listener);
    currentTransitionEndListener = listener;
  }

  function on(eventType, handler, options) {
    if (options === void 0) {
      options = false;
    }

    var nodes = normalizeToArray(instance.props.triggerTarget || reference);
    nodes.forEach(function (node) {
      node.addEventListener(eventType, handler, options);
      listeners.push({
        node: node,
        eventType: eventType,
        handler: handler,
        options: options
      });
    });
  }

  function addListeners() {
    if (getIsCustomTouchBehavior()) {
      on('touchstart', onTrigger, {
        passive: true
      });
      on('touchend', onMouseLeave, {
        passive: true
      });
    }

    splitBySpaces(instance.props.trigger).forEach(function (eventType) {
      if (eventType === 'manual') {
        return;
      }

      on(eventType, onTrigger);

      switch (eventType) {
        case 'mouseenter':
          on('mouseleave', onMouseLeave);
          break;

        case 'focus':
          on(isIE ? 'focusout' : 'blur', onBlurOrFocusOut);
          break;

        case 'focusin':
          on('focusout', onBlurOrFocusOut);
          break;
      }
    });
  }

  function removeListeners() {
    listeners.forEach(function (_ref) {
      var node = _ref.node,
          eventType = _ref.eventType,
          handler = _ref.handler,
          options = _ref.options;
      node.removeEventListener(eventType, handler, options);
    });
    listeners = [];
  }

  function onTrigger(event) {
    var _lastTriggerEvent;

    var shouldScheduleClickHide = false;

    if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
      return;
    }

    var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === 'focus';
    lastTriggerEvent = event;
    currentTarget = event.currentTarget;
    handleAriaExpandedAttribute();

    if (!instance.state.isVisible && isMouseEvent(event)) {
      // If scrolling, `mouseenter` events can be fired if the cursor lands
      // over a new target, but `mousemove` events don't get fired. This
      // causes interactive tooltips to get stuck open until the cursor is
      // moved
      mouseMoveListeners.forEach(function (listener) {
        return listener(event);
      });
    } // Toggle show/hide when clicking click-triggered tooltips


    if (event.type === 'click' && (instance.props.trigger.indexOf('mouseenter') < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
      shouldScheduleClickHide = true;
    } else {
      scheduleShow(event);
    }

    if (event.type === 'click') {
      isVisibleFromClick = !shouldScheduleClickHide;
    }

    if (shouldScheduleClickHide && !wasFocused) {
      scheduleHide(event);
    }
  }

  function onMouseMove(event) {
    var target = event.target;
    var isCursorOverReferenceOrPopper = reference.contains(target) || popper.contains(target);

    if (event.type === 'mousemove' && isCursorOverReferenceOrPopper) {
      return;
    }

    var popperTreeData = getNestedPopperTree().concat(popper).map(function (popper) {
      var _instance$popperInsta;

      var instance = popper._tippy;
      var state = (_instance$popperInsta = instance.popperInstance) == null ? void 0 : _instance$popperInsta.state;

      if (state) {
        return {
          popperRect: popper.getBoundingClientRect(),
          popperState: state,
          props: props
        };
      }

      return null;
    }).filter(Boolean);

    if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
      cleanupInteractiveMouseListeners();
      scheduleHide(event);
    }
  }

  function onMouseLeave(event) {
    var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf('click') >= 0 && isVisibleFromClick;

    if (shouldBail) {
      return;
    }

    if (instance.props.interactive) {
      instance.hideWithInteractivity(event);
      return;
    }

    scheduleHide(event);
  }

  function onBlurOrFocusOut(event) {
    if (instance.props.trigger.indexOf('focusin') < 0 && event.target !== getCurrentTarget()) {
      return;
    } // If focus was moved to within the popper


    if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {
      return;
    }

    scheduleHide(event);
  }

  function isEventListenerStopped(event) {
    return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf('touch') >= 0 : false;
  }

  function createPopperInstance() {
    destroyPopperInstance();
    var _instance$props2 = instance.props,
        popperOptions = _instance$props2.popperOptions,
        placement = _instance$props2.placement,
        offset = _instance$props2.offset,
        getReferenceClientRect = _instance$props2.getReferenceClientRect,
        moveTransition = _instance$props2.moveTransition;
    var arrow = getIsDefaultRenderFn() ? getChildren(popper).arrow : null;
    var computedReference = getReferenceClientRect ? {
      getBoundingClientRect: getReferenceClientRect,
      contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
    } : reference;
    var tippyModifier = {
      name: '$$tippy',
      enabled: true,
      phase: 'beforeWrite',
      requires: ['computeStyles'],
      fn: function fn(_ref2) {
        var state = _ref2.state;

        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh = getDefaultTemplateChildren(),
              box = _getDefaultTemplateCh.box;

          ['placement', 'reference-hidden', 'escaped'].forEach(function (attr) {
            if (attr === 'placement') {
              box.setAttribute('data-placement', state.placement);
            } else {
              if (state.attributes.popper["data-popper-" + attr]) {
                box.setAttribute("data-" + attr, '');
              } else {
                box.removeAttribute("data-" + attr);
              }
            }
          });
          state.attributes.popper = {};
        }
      }
    };
    var modifiers = [{
      name: 'offset',
      options: {
        offset: offset
      }
    }, {
      name: 'preventOverflow',
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    }, {
      name: 'flip',
      options: {
        padding: 5
      }
    }, {
      name: 'computeStyles',
      options: {
        adaptive: !moveTransition
      }
    }, tippyModifier];

    if (getIsDefaultRenderFn() && arrow) {
      modifiers.push({
        name: 'arrow',
        options: {
          element: arrow,
          padding: 3
        }
      });
    }

    modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
    instance.popperInstance = (0,_popperjs_core__WEBPACK_IMPORTED_MODULE_0__.createPopper)(computedReference, popper, Object.assign({}, popperOptions, {
      placement: placement,
      onFirstUpdate: onFirstUpdate,
      modifiers: modifiers
    }));
  }

  function destroyPopperInstance() {
    if (instance.popperInstance) {
      instance.popperInstance.destroy();
      instance.popperInstance = null;
    }
  }

  function mount() {
    var appendTo = instance.props.appendTo;
    var parentNode; // By default, we'll append the popper to the triggerTargets's parentNode so
    // it's directly after the reference element so the elements inside the
    // tippy can be tabbed to
    // If there are clipping issues, the user can specify a different appendTo
    // and ensure focus management is handled correctly manually

    var node = getCurrentTarget();

    if (instance.props.interactive && appendTo === defaultProps.appendTo || appendTo === 'parent') {
      parentNode = node.parentNode;
    } else {
      parentNode = invokeWithArgsOrReturn(appendTo, [node]);
    } // The popper element needs to exist on the DOM before its position can be
    // updated as Popper needs to read its dimensions


    if (!parentNode.contains(popper)) {
      parentNode.appendChild(popper);
    }

    createPopperInstance();
    /* istanbul ignore else */

    if (true) {
      // Accessibility check
      warnWhen(instance.props.interactive && appendTo === defaultProps.appendTo && node.nextElementSibling !== popper, ['Interactive tippy element may not be accessible via keyboard', 'navigation because it is not directly after the reference element', 'in the DOM source order.', '\n\n', 'Using a wrapper <div> or <span> tag around the reference element', 'solves this by creating a new parentNode context.', '\n\n', 'Specifying `appendTo: document.body` silences this warning, but it', 'assumes you are using a focus management solution to handle', 'keyboard navigation.', '\n\n', 'See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity'].join(' '));
    }
  }

  function getNestedPopperTree() {
    return arrayFrom(popper.querySelectorAll('[data-tippy-root]'));
  }

  function scheduleShow(event) {
    instance.clearDelayTimeouts();

    if (event) {
      invokeHook('onTrigger', [instance, event]);
    }

    addDocumentPress();
    var delay = getDelay(true);

    var _getNormalizedTouchSe = getNormalizedTouchSettings(),
        touchValue = _getNormalizedTouchSe[0],
        touchDelay = _getNormalizedTouchSe[1];

    if (currentInput.isTouch && touchValue === 'hold' && touchDelay) {
      delay = touchDelay;
    }

    if (delay) {
      showTimeout = setTimeout(function () {
        instance.show();
      }, delay);
    } else {
      instance.show();
    }
  }

  function scheduleHide(event) {
    instance.clearDelayTimeouts();
    invokeHook('onUntrigger', [instance, event]);

    if (!instance.state.isVisible) {
      removeDocumentPress();
      return;
    } // For interactive tippies, scheduleHide is added to a document.body handler
    // from onMouseLeave so must intercept scheduled hides from mousemove/leave
    // events when trigger contains mouseenter and click, and the tip is
    // currently shown as a result of a click.


    if (instance.props.trigger.indexOf('mouseenter') >= 0 && instance.props.trigger.indexOf('click') >= 0 && ['mouseleave', 'mousemove'].indexOf(event.type) >= 0 && isVisibleFromClick) {
      return;
    }

    var delay = getDelay(false);

    if (delay) {
      hideTimeout = setTimeout(function () {
        if (instance.state.isVisible) {
          instance.hide();
        }
      }, delay);
    } else {
      // Fixes a `transitionend` problem when it fires 1 frame too
      // late sometimes, we don't want hide() to be called.
      scheduleHideAnimationFrame = requestAnimationFrame(function () {
        instance.hide();
      });
    }
  } // ===========================================================================
  // 🔑 Public methods
  // ===========================================================================


  function enable() {
    instance.state.isEnabled = true;
  }

  function disable() {
    // Disabling the instance should also hide it
    // https://github.com/atomiks/tippy.js-react/issues/106
    instance.hide();
    instance.state.isEnabled = false;
  }

  function clearDelayTimeouts() {
    clearTimeout(showTimeout);
    clearTimeout(hideTimeout);
    cancelAnimationFrame(scheduleHideAnimationFrame);
  }

  function setProps(partialProps) {
    /* istanbul ignore else */
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('setProps'));
    }

    if (instance.state.isDestroyed) {
      return;
    }

    invokeHook('onBeforeUpdate', [instance, partialProps]);
    removeListeners();
    var prevProps = instance.props;
    var nextProps = evaluateProps(reference, Object.assign({}, instance.props, {}, partialProps, {
      ignoreAttributes: true
    }));
    instance.props = nextProps;
    addListeners();

    if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
      cleanupInteractiveMouseListeners();
      debouncedOnMouseMove = debounce(onMouseMove, nextProps.interactiveDebounce);
    } // Ensure stale aria-expanded attributes are removed


    if (prevProps.triggerTarget && !nextProps.triggerTarget) {
      normalizeToArray(prevProps.triggerTarget).forEach(function (node) {
        node.removeAttribute('aria-expanded');
      });
    } else if (nextProps.triggerTarget) {
      reference.removeAttribute('aria-expanded');
    }

    handleAriaExpandedAttribute();
    handleStyles();

    if (onUpdate) {
      onUpdate(prevProps, nextProps);
    }

    if (instance.popperInstance) {
      createPopperInstance(); // Fixes an issue with nested tippies if they are all getting re-rendered,
      // and the nested ones get re-rendered first.
      // https://github.com/atomiks/tippyjs-react/issues/177
      // TODO: find a cleaner / more efficient solution(!)

      getNestedPopperTree().forEach(function (nestedPopper) {
        // React (and other UI libs likely) requires a rAF wrapper as it flushes
        // its work in one
        requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
      });
    }

    invokeHook('onAfterUpdate', [instance, partialProps]);
  }

  function setContent(content) {
    instance.setProps({
      content: content
    });
  }

  function show() {
    /* istanbul ignore else */
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('show'));
    } // Early bail-out


    var isAlreadyVisible = instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
    var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);

    if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
      return;
    } // Normalize `disabled` behavior across browsers.
    // Firefox allows events on disabled elements, but Chrome doesn't.
    // Using a wrapper element (i.e. <span>) is recommended.


    if (getCurrentTarget().hasAttribute('disabled')) {
      return;
    }

    invokeHook('onShow', [instance], false);

    if (instance.props.onShow(instance) === false) {
      return;
    }

    instance.state.isVisible = true;

    if (getIsDefaultRenderFn()) {
      popper.style.visibility = 'visible';
    }

    handleStyles();
    addDocumentPress();

    if (!instance.state.isMounted) {
      popper.style.transition = 'none';
    } // If flipping to the opposite side after hiding at least once, the
    // animation will use the wrong placement without resetting the duration


    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh2 = getDefaultTemplateChildren(),
          box = _getDefaultTemplateCh2.box,
          content = _getDefaultTemplateCh2.content;

      setTransitionDuration([box, content], 0);
    }

    onFirstUpdate = function onFirstUpdate() {
      if (!instance.state.isVisible || ignoreOnFirstUpdate) {
        return;
      }

      ignoreOnFirstUpdate = true; // reflow

      void popper.offsetHeight;
      popper.style.transition = instance.props.moveTransition;

      if (getIsDefaultRenderFn() && instance.props.animation) {
        var _getDefaultTemplateCh3 = getDefaultTemplateChildren(),
            _box = _getDefaultTemplateCh3.box,
            _content = _getDefaultTemplateCh3.content;

        setTransitionDuration([_box, _content], duration);
        setVisibilityState([_box, _content], 'visible');
      }

      handleAriaContentAttribute();
      handleAriaExpandedAttribute();
      pushIfUnique(mountedInstances, instance);
      instance.state.isMounted = true;
      invokeHook('onMount', [instance]);

      if (instance.props.animation && getIsDefaultRenderFn()) {
        onTransitionedIn(duration, function () {
          instance.state.isShown = true;
          invokeHook('onShown', [instance]);
        });
      }
    };

    mount();
  }

  function hide() {
    /* istanbul ignore else */
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('hide'));
    } // Early bail-out


    var isAlreadyHidden = !instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);

    if (isAlreadyHidden || isDestroyed || isDisabled) {
      return;
    }

    invokeHook('onHide', [instance], false);

    if (instance.props.onHide(instance) === false) {
      return;
    }

    instance.state.isVisible = false;
    instance.state.isShown = false;
    ignoreOnFirstUpdate = false;

    if (getIsDefaultRenderFn()) {
      popper.style.visibility = 'hidden';
    }

    cleanupInteractiveMouseListeners();
    removeDocumentPress();
    handleStyles();

    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh4 = getDefaultTemplateChildren(),
          box = _getDefaultTemplateCh4.box,
          content = _getDefaultTemplateCh4.content;

      if (instance.props.animation) {
        setTransitionDuration([box, content], duration);
        setVisibilityState([box, content], 'hidden');
      }
    }

    handleAriaContentAttribute();
    handleAriaExpandedAttribute();

    if (instance.props.animation) {
      if (getIsDefaultRenderFn()) {
        onTransitionedOut(duration, instance.unmount);
      }
    } else {
      instance.unmount();
    }
  }

  function hideWithInteractivity(event) {
    /* istanbul ignore else */
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('hideWithInteractivity'));
    }

    doc.body.addEventListener('mouseleave', scheduleHide);
    doc.addEventListener('mousemove', debouncedOnMouseMove);
    pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
    debouncedOnMouseMove(event);
  }

  function unmount() {
    /* istanbul ignore else */
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('unmount'));
    }

    if (instance.state.isVisible) {
      instance.hide();
    }

    if (!instance.state.isMounted) {
      return;
    }

    destroyPopperInstance(); // If a popper is not interactive, it will be appended outside the popper
    // tree by default. This seems mainly for interactive tippies, but we should
    // find a workaround if possible

    getNestedPopperTree().forEach(function (nestedPopper) {
      nestedPopper._tippy.unmount();
    });

    if (popper.parentNode) {
      popper.parentNode.removeChild(popper);
    }

    mountedInstances = mountedInstances.filter(function (i) {
      return i !== instance;
    });
    instance.state.isMounted = false;
    invokeHook('onHidden', [instance]);
  }

  function destroy() {
    /* istanbul ignore else */
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('destroy'));
    }

    if (instance.state.isDestroyed) {
      return;
    }

    instance.clearDelayTimeouts();
    instance.unmount();
    removeListeners();
    delete reference._tippy;
    instance.state.isDestroyed = true;
    invokeHook('onDestroy', [instance]);
  }
}

function tippy(targets, optionalProps) {
  if (optionalProps === void 0) {
    optionalProps = {};
  }

  var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);
  /* istanbul ignore else */

  if (true) {
    validateTargets(targets);
    validateProps(optionalProps, plugins);
  }

  bindGlobalEventListeners();
  var passedProps = Object.assign({}, optionalProps, {
    plugins: plugins
  });
  var elements = getArrayOfElements(targets);
  /* istanbul ignore else */

  if (true) {
    var isSingleContentElement = isElement(passedProps.content);
    var isMoreThanOneReferenceElement = elements.length > 1;
    warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, ['tippy() was passed an Element as the `content` prop, but more than', 'one tippy instance was created by this invocation. This means the', 'content element will only be appended to the last tippy instance.', '\n\n', 'Instead, pass the .innerHTML of the element, or use a function that', 'returns a cloned version of the element instead.', '\n\n', '1) content: element.innerHTML\n', '2) content: () => element.cloneNode(true)'].join(' '));
  }

  var instances = elements.reduce(function (acc, reference) {
    var instance = reference && createTippy(reference, passedProps);

    if (instance) {
      acc.push(instance);
    }

    return acc;
  }, []);
  return isElement(targets) ? instances[0] : instances;
}

tippy.defaultProps = defaultProps;
tippy.setDefaultProps = setDefaultProps;
tippy.currentInput = currentInput;
var hideAll = function hideAll(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      excludedReferenceOrInstance = _ref.exclude,
      duration = _ref.duration;

  mountedInstances.forEach(function (instance) {
    var isExcluded = false;

    if (excludedReferenceOrInstance) {
      isExcluded = isReferenceElement(excludedReferenceOrInstance) ? instance.reference === excludedReferenceOrInstance : instance.popper === excludedReferenceOrInstance.popper;
    }

    if (!isExcluded) {
      var originalDuration = instance.props.duration;
      instance.setProps({
        duration: duration
      });
      instance.hide();

      if (!instance.state.isDestroyed) {
        instance.setProps({
          duration: originalDuration
        });
      }
    }
  });
};

var createSingleton = function createSingleton(tippyInstances, optionalProps) {
  if (optionalProps === void 0) {
    optionalProps = {};
  }

  /* istanbul ignore else */
  if (true) {
    errorWhen(!Array.isArray(tippyInstances), ['The first argument passed to createSingleton() must be an array of', 'tippy instances. The passed value was', String(tippyInstances)].join(' '));
  }

  var mutTippyInstances = tippyInstances;
  var references = [];
  var currentTarget;
  var overrides = optionalProps.overrides;

  function setReferences() {
    references = mutTippyInstances.map(function (instance) {
      return instance.reference;
    });
  }

  function enableInstances(isEnabled) {
    mutTippyInstances.forEach(function (instance) {
      if (isEnabled) {
        instance.enable();
      } else {
        instance.disable();
      }
    });
  }

  enableInstances(false);
  setReferences();
  var singleton = {
    fn: function fn() {
      return {
        onDestroy: function onDestroy() {
          enableInstances(true);
        },
        onTrigger: function onTrigger(instance, event) {
          var target = event.currentTarget;
          var index = references.indexOf(target); // bail-out

          if (target === currentTarget) {
            return;
          }

          currentTarget = target;
          var overrideProps = (overrides || []).concat('content').reduce(function (acc, prop) {
            acc[prop] = mutTippyInstances[index].props[prop];
            return acc;
          }, {});
          instance.setProps(Object.assign({}, overrideProps, {
            getReferenceClientRect: function getReferenceClientRect() {
              return target.getBoundingClientRect();
            }
          }));
        }
      };
    }
  };
  var instance = tippy(div(), Object.assign({}, removeProperties(optionalProps, ['overrides']), {
    plugins: [singleton].concat(optionalProps.plugins || []),
    triggerTarget: references
  }));
  var originalSetProps = instance.setProps;

  instance.setProps = function (props) {
    overrides = props.overrides || overrides;
    originalSetProps(props);
  };

  instance.setInstances = function (nextInstances) {
    enableInstances(true);
    mutTippyInstances = nextInstances;
    enableInstances(false);
    setReferences();
    instance.setProps({
      triggerTarget: references
    });
  };

  return instance;
};

var BUBBLING_EVENTS_MAP = {
  mouseover: 'mouseenter',
  focusin: 'focus',
  click: 'click'
};
/**
 * Creates a delegate instance that controls the creation of tippy instances
 * for child elements (`target` CSS selector).
 */

function delegate(targets, props) {
  /* istanbul ignore else */
  if (true) {
    errorWhen(!(props && props.target), ['You must specity a `target` prop indicating a CSS selector string matching', 'the target elements that should receive a tippy.'].join(' '));
  }

  var listeners = [];
  var childTippyInstances = [];
  var target = props.target;
  var nativeProps = removeProperties(props, ['target']);
  var parentProps = Object.assign({}, nativeProps, {
    trigger: 'manual',
    touch: false
  });
  var childProps = Object.assign({}, nativeProps, {
    showOnCreate: true
  });
  var returnValue = tippy(targets, parentProps);
  var normalizedReturnValue = normalizeToArray(returnValue);

  function onTrigger(event) {
    if (!event.target) {
      return;
    }

    var targetNode = event.target.closest(target);

    if (!targetNode) {
      return;
    } // Get relevant trigger with fallbacks:
    // 1. Check `data-tippy-trigger` attribute on target node
    // 2. Fallback to `trigger` passed to `delegate()`
    // 3. Fallback to `defaultProps.trigger`


    var trigger = targetNode.getAttribute('data-tippy-trigger') || props.trigger || defaultProps.trigger; // @ts-ignore

    if (targetNode._tippy) {
      return;
    }

    if (event.type === 'touchstart' && typeof childProps.touch === 'boolean') {
      return;
    }

    if (event.type !== 'touchstart' && trigger.indexOf(BUBBLING_EVENTS_MAP[event.type])) {
      return;
    }

    var instance = tippy(targetNode, childProps);

    if (instance) {
      childTippyInstances = childTippyInstances.concat(instance);
    }
  }

  function on(node, eventType, handler, options) {
    if (options === void 0) {
      options = false;
    }

    node.addEventListener(eventType, handler, options);
    listeners.push({
      node: node,
      eventType: eventType,
      handler: handler,
      options: options
    });
  }

  function addEventListeners(instance) {
    var reference = instance.reference;
    on(reference, 'touchstart', onTrigger);
    on(reference, 'mouseover', onTrigger);
    on(reference, 'focusin', onTrigger);
    on(reference, 'click', onTrigger);
  }

  function removeEventListeners() {
    listeners.forEach(function (_ref) {
      var node = _ref.node,
          eventType = _ref.eventType,
          handler = _ref.handler,
          options = _ref.options;
      node.removeEventListener(eventType, handler, options);
    });
    listeners = [];
  }

  function applyMutations(instance) {
    var originalDestroy = instance.destroy;

    instance.destroy = function (shouldDestroyChildInstances) {
      if (shouldDestroyChildInstances === void 0) {
        shouldDestroyChildInstances = true;
      }

      if (shouldDestroyChildInstances) {
        childTippyInstances.forEach(function (instance) {
          instance.destroy();
        });
      }

      childTippyInstances = [];
      removeEventListeners();
      originalDestroy();
    };

    addEventListeners(instance);
  }

  normalizedReturnValue.forEach(applyMutations);
  return returnValue;
}

var animateFill = {
  name: 'animateFill',
  defaultValue: false,
  fn: function fn(instance) {
    var _instance$props$rende;

    // @ts-ignore
    if (!((_instance$props$rende = instance.props.render) == null ? void 0 : _instance$props$rende.$$tippy)) {
      if (true) {
        errorWhen(instance.props.animateFill, 'The `animateFill` plugin requires the default render function.');
      }

      return {};
    }

    var _getChildren = getChildren(instance.popper),
        box = _getChildren.box,
        content = _getChildren.content;

    var backdrop = instance.props.animateFill ? createBackdropElement() : null;
    return {
      onCreate: function onCreate() {
        if (backdrop) {
          box.insertBefore(backdrop, box.firstElementChild);
          box.setAttribute('data-animatefill', '');
          box.style.overflow = 'hidden';
          instance.setProps({
            arrow: false,
            animation: 'shift-away'
          });
        }
      },
      onMount: function onMount() {
        if (backdrop) {
          var transitionDuration = box.style.transitionDuration;
          var duration = Number(transitionDuration.replace('ms', '')); // The content should fade in after the backdrop has mostly filled the
          // tooltip element. `clip-path` is the other alternative but is not
          // well-supported and is buggy on some devices.

          content.style.transitionDelay = Math.round(duration / 10) + "ms";
          backdrop.style.transitionDuration = transitionDuration;
          setVisibilityState([backdrop], 'visible');
        }
      },
      onShow: function onShow() {
        if (backdrop) {
          backdrop.style.transitionDuration = '0ms';
        }
      },
      onHide: function onHide() {
        if (backdrop) {
          setVisibilityState([backdrop], 'hidden');
        }
      }
    };
  }
};

function createBackdropElement() {
  var backdrop = div();
  backdrop.className = BACKDROP_CLASS;
  setVisibilityState([backdrop], 'hidden');
  return backdrop;
}

var followCursor = {
  name: 'followCursor',
  defaultValue: false,
  fn: function fn(instance) {
    var reference = instance.reference;
    var doc = getOwnerDocument(instance.props.triggerTarget || reference);
    var initialMouseCoords = null;

    function getIsManual() {
      return instance.props.trigger.trim() === 'manual';
    }

    function getIsEnabled() {
      // #597
      var isValidMouseEvent = getIsManual() ? true : // Check if a keyboard "click"
      initialMouseCoords !== null && !(initialMouseCoords.clientX === 0 && initialMouseCoords.clientY === 0);
      return instance.props.followCursor && isValidMouseEvent;
    }

    function getIsInitialBehavior() {
      return currentInput.isTouch || instance.props.followCursor === 'initial' && instance.state.isVisible;
    }

    function unsetReferenceClientRect(shouldUnset) {
      if (shouldUnset) {
        instance.setProps({
          getReferenceClientRect: null
        });
      }
    }

    function handleMouseMoveListener() {
      if (getIsEnabled()) {
        addListener();
      } else {
        unsetReferenceClientRect(instance.props.followCursor);
      }
    }

    function triggerLastMouseMove() {
      if (getIsEnabled()) {
        onMouseMove(initialMouseCoords);
      }
    }

    function addListener() {
      doc.addEventListener('mousemove', onMouseMove);
    }

    function removeListener() {
      doc.removeEventListener('mousemove', onMouseMove);
    }

    function onMouseMove(event) {
      initialMouseCoords = {
        clientX: event.clientX,
        clientY: event.clientY
      }; // If the instance is interactive, avoid updating the position unless it's
      // over the reference element

      var isCursorOverReference = event.target ? reference.contains(event.target) : true;
      var followCursor = instance.props.followCursor;
      var clientX = event.clientX,
          clientY = event.clientY;
      var rect = reference.getBoundingClientRect();
      var relativeX = clientX - rect.left;
      var relativeY = clientY - rect.top;

      if (isCursorOverReference || !instance.props.interactive) {
        instance.setProps({
          getReferenceClientRect: function getReferenceClientRect() {
            var rect = reference.getBoundingClientRect();
            var x = clientX;
            var y = clientY;

            if (followCursor === 'initial') {
              x = rect.left + relativeX;
              y = rect.top + relativeY;
            }

            var top = followCursor === 'horizontal' ? rect.top : y;
            var right = followCursor === 'vertical' ? rect.right : x;
            var bottom = followCursor === 'horizontal' ? rect.bottom : y;
            var left = followCursor === 'vertical' ? rect.left : x;
            return {
              width: right - left,
              height: bottom - top,
              top: top,
              right: right,
              bottom: bottom,
              left: left
            };
          }
        });
      }

      if (getIsInitialBehavior()) {
        removeListener();
      }
    }

    return {
      onAfterUpdate: function onAfterUpdate(_, _ref) {
        var followCursor = _ref.followCursor;

        if (followCursor !== undefined && !followCursor) {
          unsetReferenceClientRect(true);
        }
      },
      onMount: function onMount() {
        triggerLastMouseMove();
      },
      onShow: function onShow() {
        if (getIsManual()) {
          // Since there's no trigger event to use, we have to use these as
          // baseline coords
          initialMouseCoords = {
            clientX: 0,
            clientY: 0
          };
          handleMouseMoveListener();
        }
      },
      onTrigger: function onTrigger(_, event) {
        // Tapping on touch devices can trigger `mouseenter` then `focus`
        if (initialMouseCoords) {
          return;
        }

        if (isMouseEvent(event)) {
          initialMouseCoords = {
            clientX: event.clientX,
            clientY: event.clientY
          };
        }

        handleMouseMoveListener();
      },
      onUntrigger: function onUntrigger() {
        // If untriggered before showing (`onHidden` will never be invoked)
        if (!instance.state.isVisible) {
          removeListener();
          initialMouseCoords = null;
        }
      },
      onHidden: function onHidden() {
        removeListener();
        initialMouseCoords = null;
      }
    };
  }
};

function getProps(props, modifier) {
  var _props$popperOptions;

  return {
    popperOptions: Object.assign({}, props.popperOptions, {
      modifiers: [].concat((((_props$popperOptions = props.popperOptions) == null ? void 0 : _props$popperOptions.modifiers) || []).filter(function (_ref) {
        var name = _ref.name;
        return name !== modifier.name;
      }), [modifier])
    })
  };
}

var inlinePositioning = {
  name: 'inlinePositioning',
  defaultValue: false,
  fn: function fn(instance) {
    var reference = instance.reference;

    function isEnabled() {
      return !!instance.props.inlinePositioning;
    }

    var placement;
    var cursorRectIndex = -1;
    var isInternalUpdate = false;
    var modifier = {
      name: 'tippyInlinePositioning',
      enabled: true,
      phase: 'afterWrite',
      fn: function fn(_ref2) {
        var state = _ref2.state;

        if (isEnabled()) {
          if (placement !== state.placement) {
            instance.setProps({
              getReferenceClientRect: function getReferenceClientRect() {
                return _getReferenceClientRect(state.placement);
              }
            });
          }

          placement = state.placement;
        }
      }
    };

    function _getReferenceClientRect(placement) {
      return getInlineBoundingClientRect(getBasePlacement(placement), reference.getBoundingClientRect(), arrayFrom(reference.getClientRects()), cursorRectIndex);
    }

    function setInternalProps(partialProps) {
      isInternalUpdate = true;
      instance.setProps(partialProps);
      isInternalUpdate = false;
    }

    function addModifier() {
      if (!isInternalUpdate) {
        setInternalProps(getProps(instance.props, modifier));
      }
    }

    return {
      onCreate: addModifier,
      onAfterUpdate: addModifier,
      onTrigger: function onTrigger(_, event) {
        if (isMouseEvent(event)) {
          var rects = arrayFrom(instance.reference.getClientRects());
          var cursorRect = rects.find(function (rect) {
            return rect.left - 2 <= event.clientX && rect.right + 2 >= event.clientX && rect.top - 2 <= event.clientY && rect.bottom + 2 >= event.clientY;
          });
          cursorRectIndex = rects.indexOf(cursorRect);
        }
      },
      onUntrigger: function onUntrigger() {
        cursorRectIndex = -1;
      }
    };
  }
};
function getInlineBoundingClientRect(currentBasePlacement, boundingRect, clientRects, cursorRectIndex) {
  // Not an inline element, or placement is not yet known
  if (clientRects.length < 2 || currentBasePlacement === null) {
    return boundingRect;
  } // There are two rects and they are disjoined


  if (clientRects.length === 2 && cursorRectIndex >= 0 && clientRects[0].left > clientRects[1].right) {
    return clientRects[cursorRectIndex] || boundingRect;
  }

  switch (currentBasePlacement) {
    case 'top':
    case 'bottom':
      {
        var firstRect = clientRects[0];
        var lastRect = clientRects[clientRects.length - 1];
        var isTop = currentBasePlacement === 'top';
        var top = firstRect.top;
        var bottom = lastRect.bottom;
        var left = isTop ? firstRect.left : lastRect.left;
        var right = isTop ? firstRect.right : lastRect.right;
        var width = right - left;
        var height = bottom - top;
        return {
          top: top,
          bottom: bottom,
          left: left,
          right: right,
          width: width,
          height: height
        };
      }

    case 'left':
    case 'right':
      {
        var minLeft = Math.min.apply(Math, clientRects.map(function (rects) {
          return rects.left;
        }));
        var maxRight = Math.max.apply(Math, clientRects.map(function (rects) {
          return rects.right;
        }));
        var measureRects = clientRects.filter(function (rect) {
          return currentBasePlacement === 'left' ? rect.left === minLeft : rect.right === maxRight;
        });
        var _top = measureRects[0].top;
        var _bottom = measureRects[measureRects.length - 1].bottom;
        var _left = minLeft;
        var _right = maxRight;

        var _width = _right - _left;

        var _height = _bottom - _top;

        return {
          top: _top,
          bottom: _bottom,
          left: _left,
          right: _right,
          width: _width,
          height: _height
        };
      }

    default:
      {
        return boundingRect;
      }
  }
}

var sticky = {
  name: 'sticky',
  defaultValue: false,
  fn: function fn(instance) {
    var reference = instance.reference,
        popper = instance.popper;

    function getReference() {
      return instance.popperInstance ? instance.popperInstance.state.elements.reference : reference;
    }

    function shouldCheck(value) {
      return instance.props.sticky === true || instance.props.sticky === value;
    }

    var prevRefRect = null;
    var prevPopRect = null;

    function updatePosition() {
      var currentRefRect = shouldCheck('reference') ? getReference().getBoundingClientRect() : null;
      var currentPopRect = shouldCheck('popper') ? popper.getBoundingClientRect() : null;

      if (currentRefRect && areRectsDifferent(prevRefRect, currentRefRect) || currentPopRect && areRectsDifferent(prevPopRect, currentPopRect)) {
        if (instance.popperInstance) {
          instance.popperInstance.update();
        }
      }

      prevRefRect = currentRefRect;
      prevPopRect = currentPopRect;

      if (instance.state.isMounted) {
        requestAnimationFrame(updatePosition);
      }
    }

    return {
      onMount: function onMount() {
        if (instance.props.sticky) {
          updatePosition();
        }
      }
    };
  }
};

function areRectsDifferent(rectA, rectB) {
  if (rectA && rectB) {
    return rectA.top !== rectB.top || rectA.right !== rectB.right || rectA.bottom !== rectB.bottom || rectA.left !== rectB.left;
  }

  return true;
}

tippy.setDefaultProps({
  render: render
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (tippy);

//# sourceMappingURL=tippy.esm.js.map


/***/ }),

/***/ "../structured-text-editor/node_modules/uuid/lib/bytesToUuid.js":
/*!**********************************************************************!*\
  !*** ../structured-text-editor/node_modules/uuid/lib/bytesToUuid.js ***!
  \**********************************************************************/
/***/ ((module) => {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([bth[buf[i++]], bth[buf[i++]], 
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]]]).join('');
}

module.exports = bytesToUuid;


/***/ }),

/***/ "../structured-text-editor/node_modules/uuid/lib/rng-browser.js":
/*!**********************************************************************!*\
  !*** ../structured-text-editor/node_modules/uuid/lib/rng-browser.js ***!
  \**********************************************************************/
/***/ ((module) => {

// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}


/***/ }),

/***/ "../structured-text-editor/node_modules/uuid/v1.js":
/*!*********************************************************!*\
  !*** ../structured-text-editor/node_modules/uuid/v1.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var rng = __webpack_require__(/*! ./lib/rng */ "../structured-text-editor/node_modules/uuid/lib/rng-browser.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "../structured-text-editor/node_modules/uuid/lib/bytesToUuid.js");

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;
var _clockseq;

// Previous uuid creation time
var _lastMSecs = 0;
var _lastNSecs = 0;

// See https://github.com/broofa/node-uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189
  if (node == null || clockseq == null) {
    var seedBytes = rng();
    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [
        seedBytes[0] | 0x01,
        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]
      ];
    }
    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  }

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid(b);
}

module.exports = v1;


/***/ }),

/***/ "../structured-text-editor/src/caret.js":
/*!**********************************************!*\
  !*** ../structured-text-editor/src/caret.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../lib/pixelschubser/utils */ "../structured-text-editor/lib/pixelschubser/utils.js");

var Caret = function(editor) {
    var self = this;
    this.editor = editor;
    this.selectionchangeSubscribers = [];

    document.addEventListener('selectionchange', function(e) {
        var selection = window.getSelection();

        if(self._isSelectionProcessed(selection)) {
            self._markSelectionAsProcessed(selection)
            for(let i=0; i<self.selectionchangeSubscribers.length; i++) {
                self.selectionchangeSubscribers[i](selection);
            }
        }
    });
}

Caret.prototype = {

    subscribeSelectionChange: function(f) {
        this.selectionchangeSubscribers.push(f);
    },

    _markSelectionAsProcessed: function(selection) {
        this.lastProcessedSelectionChange = {
            anchorNode: selection.anchorNode,
            anchorOffset: selection.anchorOffset,
            focusNode: selection.focusNode,
            focusOffset: selection.focusOffset
        };
    },

    _isSelectionProcessed: function(selection) {
      return this.lastProcessedSelectionChange === undefined ||
             this.lastProcessedSelectionChange.anchorNode !==  selection.anchorNode ||
             this.lastProcessedSelectionChange.anchorOffset !==  selection.anchorOffset ||
             this.lastProcessedSelectionChange.focusNode !==  selection.focusNode ||
             this.lastProcessedSelectionChange.focusOffset !==  selection.focusOffset
    },

    _getElementsContentLengthIncrement: function(element) {
        if(['BR', 'IMG'].includes(element.tagName)) return 1;

        if(element && element.classList && element.classList.contains('toc-content')) return 0;
        if(element && element.classList && element.classList.contains('missingLevelHint')) return 0;

        if(element.tagName === 'LI' && element.innerText === '') return 1;
        if(element.getAttribute && element.getAttribute('contenteditable') === 'false') return 1;
        if(this.withinUnedidableReferenceEl(element)) return 0;

        if(['CAPTION', 'FIGCAPTION', 'CITESRC'].includes(element.tagName) && (element.children && element.children.length) === 0) { //Fixme: Should it not be childNodes instead of children
            return 1;
        }

        if(!element.length) return 0;
        return element.length;
    },

    // example Input:  "test<span class="footnote" data-note="note number 11" contenteditable="false">11</span> the editor interface to restoreX selection"
    // example Output: "test_ the editor interface to restoreX selection"
    // -> because we cannot place the caret within the footnote (or reference, inline equation, toc section)
    // we replace the footenote with one placeholder char.
    _getContentLengthIncrementMaskedText: function(rootElement) {
        var result = '';


        if(rootElement.length && rootElement.textContent) {
            return rootElement.textContent;
        }

        rootElement.childNodes.forEach(element => {
            if(['BR', 'IMG'].includes(element.tagName)) { result += '_'; }
            else if(element && element.classList && element.classList.contains('toc-content')) { result += ''; }
            else if(element && element.classList && element.classList.contains('missingLevelHint')) { result += ''; }
            else if(element.tagName === 'LI' && element.innerText === '') { result += '_'; }
            else if(element.getAttribute && element.getAttribute('contenteditable') === 'false') { result += '_'; }
            else if(this.withinUnedidableReferenceEl(element)) { result += ''; }

            else if(['CAPTION', 'FIGCAPTION', 'CITESRC'].includes(element.tagName) && (element.childNodes && element.childNodes.length) === 0) {
                result += '_';
            }
            else {
                result += this._getContentLengthIncrementMaskedText(element);
            }
        })

        return result;
    },

    _getContentLengthOfDOMElement: function(element, endChild) {
        if(!endChild && element.summarizedContentLength) {
            return element.summarizedContentLength;
        }

        var endSection = endChild && utils.getSubtreeByChildNode(element, endChild),
            endSectionIndex = endSection && element.children.indexOf(endSection),
            treeWalker = document.createTreeWalker(endSection || element),
            length = 0,
            currentEl;

        if(endSection) {
            for(var i=0; i<endSectionIndex; i++) {
                length += this._getContentLengthOfDOMElement(element.children[i])
            }
        }

        while((currentEl = treeWalker.currentNode)) {
            if(currentEl === endChild) return length;
            length += this._getElementsContentLengthIncrement(currentEl);

            if(!treeWalker.nextNode()) break;
        }

        if(!endChild) {
            element.summarizedContentLength = length;
        }

        return length;
    },

    _walkToNextEditableNode: function(treeWalker) {
        var candidte = treeWalker.nextNode();
        if(!candidte) { return candidte }

        while(this.withinUnedidableReferenceEl(candidte)) {
            candidte = treeWalker.nextNode();
            if(!candidte) { return candidte }
        }

        return candidte;
    },

    // rightMatch: when root element contains: '<p>Hello</p><p>World</p>' and contentLength is '5'
    //             it is not clear which element to return, if rightMatch is true then '<p>World</p>' will
    //             be returned, '<p>Hello</p>' otherwise
    _getElementByContentLength: function(rootEl, contentLength, rightMatch) {
        var treeWalker = document.createTreeWalker(rootEl),
            currentEl,
            length = 0,
            currentElLength;

        while(currentEl = treeWalker.currentNode) {
            currentElLength = this._getElementsContentLengthIncrement(currentEl);

            if((length + currentElLength) < contentLength) {
                length += currentElLength;
            } else if((length + currentElLength) === contentLength) {
                return rightMatch ? (this._walkToNextEditableNode(treeWalker) || currentEl) : currentEl;
            } else {
                return currentEl;
            }

            if(!treeWalker.nextNode()) break;
        }

        return null;
    },

    _getFirstParentWhichMatchContext: function(node, context) {
        if(!node) return;

        var tmpNode = node,
            contextType,
            matchFns;

        if(!Array.isArray(context)) {
            context = [context]
        }

        matchFns = context.map(function(ctx) {
            if(ctx.startsWith('.')) {
                contextType = 'class';
                ctx = ctx.substring(1);
            } else {
                contextType = 'tag';
            }

            if((contextType === 'tag' || !contextType)) {
                return function(node) {return node.tagName && node.tagName.toLowerCase() === ctx}
            } else {
                return function(node) {return node.classList && node.classList.contains(ctx)}
            }
        })

        while(tmpNode) {
            if(matchFns.some(function(matchFn) {return matchFn(tmpNode)})) {
                return tmpNode;
            }

            tmpNode = tmpNode.parentElement;
        }
    },

    isWithinElement: function(el) {
        var sel = window.getSelection();

        return sel.focusNode &&
               sel.anchorNode &&
               el.contains(sel.focusNode) &&
               el.contains(sel.anchorNode)
    },

    getPrecedingCharacter: function(contextElement) {
        var precedingChar = '', sel, range;
        var sel = window.getSelection();
        if (sel.rangeCount > 0) {
            range = sel.getRangeAt(0).cloneRange();
            range.collapse(true);
            range.setStart(contextElement, 0);
            precedingChar = range.toString().slice(-1);
        }
        return precedingChar;
    },

    isPrecedingCharacterWhitespace: function(contextElement) {
        var precedingCharacter = Caret.prototype.getPrecedingCharacter(contextElement),
            precedingCharacterCode;

        if(!precedingCharacter) { return false }
        precedingCharacterCode = precedingCharacter.charCodeAt(0);
        return (precedingCharacterCode === 32 || precedingCharacterCode === 160);
    },

    isCollapsedAndPositionedAtTheFirstLineOf: function(node) {
        if(!node.offsetTop) { return }

        if(node.innerText === '' && (node.tagName === 'OL' || node.tagName === 'UL')) {
            var targetEl = this.getContextElement('li');
            if(targetEl && targetEl !== node.firstChild) {
                return false;
            }
        } else if(node.innerText === '') {
            return true
        }

        var style = window.getComputedStyle(node),
            caretPos = this.getPosition(),
            caretPosY = caretPos && caretPos.y,
            paddingTop = parseInt(style.getPropertyValue('padding-top')),
            lineHeight = parseInt(style.getPropertyValue('line-height')),
            firstLineStartYPos = node.offsetTop + paddingTop,
            firstLineEndYPos = firstLineStartYPos + lineHeight;

        return firstLineStartYPos < caretPosY && firstLineEndYPos > caretPosY;
    },

    isCollapsedAndPositionedAtTheLastLineOf: function(node) {
        if(!node.offsetTop) { return }
        if(node.innerText === '') { return true }

        var style = window.getComputedStyle(node),
            caretPos = this.getPosition(),
            caretPosY = caretPos && caretPos.y,
            paddingBottom = parseInt(style.getPropertyValue('padding-bottom')),
            lineHeight = parseInt(style.getPropertyValue('line-height')),
            borderBottom = 1,
            lastLineEndYPos = (node.offsetTop + node.offsetHeight) - paddingBottom - borderBottom,
            lastLineStartYPos = lastLineEndYPos - lineHeight - 10;

        return lastLineEndYPos > caretPosY && lastLineStartYPos < caretPosY;
    },

    isCollapsedAndPositionedAtTheBeginningOf: function(node, ignoreFirstCharIfWhitespace) {
        var selection = window.getSelection(),
            pos;

        ignoreFirstCharIfWhitespace = ignoreFirstCharIfWhitespace === undefined ? true : ignoreFirstCharIfWhitespace;

        if(!selection.isCollapsed || !node) { return false }

        pos = this._getContentLengthOfDOMElement(node, selection.anchorNode) + selection.anchorOffset;
        if(ignoreFirstCharIfWhitespace &&
           pos === 1 &&
           node.childNodes && node.childNodes[0] === selection.anchorNode &&
           (selection.focusNode.nodeValue && (selection.focusNode.nodeValue[0] === '\u00A0' || selection.focusNode.nodeValue[0] === ' '))) {

            // when the first node of the section is focused and it starts with
            // a white space we do not mind whether the caret is placed right or
            // left from that whitespace. This is because for some reason the browser
            // just does not display this whitespace ?!?!? Blame this line in git
            // and see the spec in the same commit to get more details about this
            // specifc scenario.
            return true;
        }

        return pos === 0;
    },

    isCollapsedAndPositionedAtTheEndOf: function(node) {
        var selection = window.getSelection(),
            pos, nodeLength, lastEl;

        if(!selection.isCollapsed || !node) { return false }

        if(selection.anchorNode === node && selection.anchorOffset === node.childNodes.length) {
            return true;
        }

        pos = this._getContentLengthOfDOMElement(node, selection.anchorNode) + selection.anchorOffset;
        nodeLength = this._getContentLengthOfDOMElement(node);

        if(pos === nodeLength-1 && node.innerText[node.innerText.length-1] === '\n') {
            return true;
        }

        return pos === nodeLength;
    },

    positionAtTheBeginningOf: function(node) {
        var range = document.createRange(),
            selection = window.getSelection();

        range.setEnd(node, 0);
        range.setStart(node, 0);
        selection.removeAllRanges();
        selection.addRange(range);
    },

    positionAfter: function(node) {
        var nodeIndex,
            range = document.createRange(),
            selection = window.getSelection(),
            uneditableParent = this.withinUnedidableReferenceEl(node);

        if(uneditableParent) {
            node = uneditableParent
        }

        if(node.parentNode) {
            nodeIndex = Array.prototype.indexOf.call(node.parentNode.childNodes, node);
            range.setEnd(node.parentNode, nodeIndex+1);
            range.setStart(node.parentNode, nodeIndex+1);
            selection.removeAllRanges();
            selection.addRange(range);
        }
    },

    positionIn: function(node) {
        var range = document.createRange(),
            selection = window.getSelection();

        range.selectNodeContents(node);
        range.collapse();
        selection.removeAllRanges();
        selection.addRange(range);
    },

    modifyRangeToBeValidInsertPosition: function(range) {
        var node = range && range.collapsed && range.startContainer,
            firstLI;

        if(node && ['UL', 'OL'].includes(node.tagName) && range.startOffset === 0) {
            if(firstLI = node.querySelector('li')) {
                range.setStart(firstLI, 0);
                range.setEnd(firstLI, 0);
            }
        }

        return range;
    },

    insertNode: function (node) {
        var sel = window.getSelection(),
            range = sel.getRangeAt(0);

        this.modifyRangeToBeValidInsertPosition(range);
        range.insertNode(node);
        range.collapse();
        sel.removeAllRanges();
        sel.addRange(range);

        if(node.nextSibling && node.nextSibling.nodeValue === '') {
            node.nextSibling.remove();
        }
    },

    insertLineBreak: function() {
        var node = document.createElement('br'),
            focusedSection = this.editor.focusedSection(),
            index = this.editor.indexOfFocusedSection(),
            nextSection = 1;

        if(this.isPositionedAtTheBeginningOfFocusNode(window.getSelection())) {
            nextSection = 0;
        }

        this.editor.caret.insertNode(node);
        this.editor.replaceSectionWithHTML(focusedSection, focusedSection.outerHTML, {
            positionCaretAtTheEndOfSectionWithIndex: index+nextSection
        });
    },

    withinUnedidableReferenceEl: function(node) {
        if(node && node.isContentEditable) { return false }

        var sel = window.getSelection(),
            tmpNode = node || sel.focusNode;

        if(!tmpNode) { return false }

        while(tmpNode) {
            if(tmpNode.isContentEditable === true) {
                return false;
            }

            if(tmpNode.getAttribute && tmpNode.getAttribute('contenteditable') === 'false') {
                return tmpNode;
            }

            tmpNode = tmpNode.parentElement;
        }

        return false;
    },

    isPositionedAtTheEndOfFocusNode: function(selection) {
        return selection.isCollapsed &&
               selection.focusNode &&
               selection.focusOffset === selection.focusNode.length;
    },

    isPositionedAtTheBeginningOfFocusNode: function(selection) {
        return selection.isCollapsed &&
               selection.focusNode &&
               selection.focusOffset === 0;
    },

    getTangetNodes: function() {
        var self = this,
            selection = window.getSelection(),
            tangentNodes = {left: null, right: null},
            nodeIterator,
            ensureSameSection = function(n) { return n };

        if(this.editor && self.editor.focusedSection) {
            ensureSameSection = function(n) {
                if(n && self.editor.focusedSection() === self.editor.sectionByChildNode(n)) {
                    return n;
                }
            }
        }

        if(selection && selection.focusNode && selection.focusNode.nodeType !== Node.TEXT_NODE) {
            return {
                left: selection.focusNode.childNodes[selection.focusOffset-1],
                right: selection.focusNode.childNodes[selection.focusOffset]
            }
        }

        nodeIterator = utils.getNodeIteratorPointingTo(selection.focusNode);

        if(!nodeIterator) {
            return tangentNodes;
        }

        if(this.isPositionedAtTheBeginningOfFocusNode(selection)) {
            tangentNodes.left = ensureSameSection(nodeIterator.previousNode());
            nodeIterator.nextNode(); //move the iterator back to the focus node
        }

        if(this.isPositionedAtTheEndOfFocusNode(selection)) {
            tangentNodes.right = ensureSameSection(nodeIterator.nextNode());
        }

        return tangentNodes;
    },

    // This method finds a DOM element which wraps the passed selection and matches the context.
    //   - wraps means, focusNode and anchorNode are contained within the element
    //   - matches the context means, the returned element has either (depending on contextType, see below)
    //     the same tagName as specified in context, or a class name specified in context
    //   - the contextType is determined by the first char of the context argument. If it is '.' the type is
    //     "class" will match a element which has the according class assigned in its class attribute.
    //     If the context does not start with a '.' a element with the according tag name will match.
    getContextElement: function(context, selection, tangentNodes) {
        selection = selection || window.getSelection();
        tangentNodes = tangentNodes || this.getTangetNodes();

        if(selection.rangeCount === 0) return null;

        var commonAncestor = selection.getRangeAt(0).commonAncestorContainer;

        return this._getFirstParentWhichMatchContext(commonAncestor, context) ||
               this._getFirstParentWhichMatchContext(tangentNodes.right, context) ||
               this._getFirstParentWhichMatchContext(tangentNodes.left, context);
    },

    getPosition: function() {
        var selection = window.getSelection(),
            range = selection.getRangeAt(0),
            rect = range.getClientRects()[0],
            tn;

        if(rect) {
          return {x: rect.left, y: rect.top + window.scrollY, width: rect.width, height: rect.height};
        }

        tn = this.getTangetNodes();

        if(tn.left && tn.left.nodeType === Node.TEXT_NODE) {
            range = document.createRange();
            range.selectNodeContents(tn.left);
            range.collapse(false);
            rect = range.getClientRects()[0];
            return {x: rect.left+rect.width, y: rect.top + window.scrollY, width: 0, height: rect.height};
        } else if(tn.left) {
            rect = tn.left.getClientRects()[0];
            return {x: rect.left+rect.width, y: rect.top + window.scrollY, width: 0, height: rect.height};
        } else if(!rect && range.startContainer === range.endContainer)  {
            rect = range.startContainer.getClientRects()[0];
            return {x: rect.left, y: rect.top + window.scrollY, width: rect.width, height: rect.height};
        }

        // it seeems there is no known situation in which we have to consider tn.right
    },

    restoreSelection: function(moveToLeft, strategy) {
        strategy = strategy || 'OffsetStrategy';
        if(strategy === 'OffsetStrategy') {
            return this.restoreSelectionViaOffsetStrategy(moveToLeft);
        } else if(strategy === 'TryDOMStrategyFirst') {
            if(!this.restoreSelectionViaDOMStrategy()) {
                return this.restoreSelectionViaOffsetStrategy(moveToLeft);
            }
            return true;
        } else {
            return this.restoreSelectionViaDOMStrategy();
        }
    },

    // param 'moveToLeft': will correct the poistion by the given amount of char
    restoreSelectionViaOffsetStrategy: function(moveToLeft, savedSelection) {
        moveToLeft = moveToLeft || 0;

        if(savedSelection) {
            this.rootEl = savedSelection.rootEl;
            this.rangeStart = savedSelection.rangeStart;
            this.rangeEnd = savedSelection.rangeEnd;
            this.isAnchorLeft = savedSelection.isAnchorLeft;
            this.rangeStartAtZeroOffset = savedSelection.rangeStartAtZeroOffset;
            this.rangeEndAtZeroOffset =  savedSelection.rangeEndAtZeroOffset;
            this.selectionFocusNode = savedSelection.selectionFocusNode;
            this.selectionAnchorNode = savedSelection.selectionAnchorNode;
            this.rangeStartAtZeroOffset = savedSelection.rangeStartAtZeroOffset;
            this.rangeEndAtZeroOffset = savedSelection.rangeEndAtZeroOffset;
        }

        if(this.selectionIsUnedidable) {
            return true;
        }

        if(this.carretPlacementCorrection) {
            moveToLeft += this.carretPlacementCorrection;
        }

        this.rangeStartAtZeroOffset = (this.selectionAnchorOffset-moveToLeft) === 0;
        this.rangeEndAtZeroOffset = (this.selectionFocusOffset-moveToLeft) === 0;

        if(typeof this.rangeStart === 'number' && typeof this.rangeEnd === 'number') {

            var range,
                selection = window.getSelection(),
                startNode = this._getElementByContentLength(this.rootEl, this.rangeStart - moveToLeft, this.rangeStartAtZeroOffset),
                startOffset = this.rangeStart - moveToLeft - this._getContentLengthOfDOMElement(this.rootEl, startNode),
                endNode,
                endOffset,
                unediableContexEl;

            if(this.selectionIsCollapsed) {
                endNode = startNode;
                endOffset = startOffset;
            } else {
                endNode = this._getElementByContentLength(this.rootEl, this.rangeEnd - moveToLeft, this.rangeEndAtZeroOffset);
                endOffset = this.rangeEnd - moveToLeft - this._getContentLengthOfDOMElement(this.rootEl, endNode);
            }

            unediableContexEl = startNode == endNode && (unediableContexEl = this.withinUnedidableReferenceEl(startNode));

            try {
                if(unediableContexEl) {
                    startOffset = endOffset = unediableContexEl.parentElement.childNodes.indexOf(unediableContexEl) + 1;
                    startNode = endNode = unediableContexEl.parentElement;
                }

                range = document.createRange();
                if(this.isAnchorLeft) {
                    range.setStart(startNode, startOffset);
                    range.setEnd(endNode, endOffset);
                } else {
                    range.setEnd(startNode, startOffset);
                    range.setStart(endNode, endOffset);
                }

                selection.removeAllRanges();
                selection.addRange(range);
                return true;
            } catch(ex) {
                console.log('failed to set caret position via offset strategy', ex);
                return false;
            }
        }
    },

    restoreSelectionViaDOMStrategy: function() {
        var range, selection;

        if(!this.rootEl) {
            return false;
        }

        if(this.selectionIsUnedidable) {
            return true;
        }

        if(this.rootEl.contains(this.selectionAnchorNode) && this.rootEl.contains(this.selectionFocusNode)) {
            range = document.createRange();
            selection = window.getSelection();
            if(this.isAnchorLeft) {
                range.setEnd(this.selectionAnchorNode, this.selectionAnchorOffset);
                range.setStart(this.selectionFocusNode, this.selectionFocusOffset);
            } else {
                range.setStart(this.selectionAnchorNode, this.selectionAnchorOffset);
                range.setEnd(this.selectionFocusNode, this.selectionFocusOffset);
            }
            selection.removeAllRanges();
            selection.addRange(range);
            return true;
        }

        return false;
    },

    saveSelection: function(rootEl, insertedContent) {
        var selection = window.getSelection();

        if(this.withinUnedidableReferenceEl(selection.anchorNode)) {
            this.selectionIsUnedidable = true;
        } else if(!selection.isCollapsed && this.withinUnedidableReferenceEl(selection.focusNode)) {
            this.selectionIsUnedidable = true;
        } else {
            this.selectionIsUnedidable = false;
        }

        if(this.selectionIsUnedidable) {
            return { selectionIsUnedidable: true };
        }

        if(selection.anchorNode && selection.focusNode) {
            if(selection.anchorNode.nodeType === Node.TEXT_NODE) {
                this.rangeStart = this._getContentLengthOfDOMElement(rootEl, selection.anchorNode) + selection.anchorOffset;
            } else {
                this.rangeStart = this._getContentLengthOfDOMElement(rootEl, selection.anchorNode);
                for(let i=0; i<selection.anchorOffset; i++) {
                    this.rangeStart += this._getContentLengthOfDOMElement(selection.anchorNode.childNodes[i]);
                }
            }

            if(selection.isCollapsed) {
                this.rangeEnd = this.rangeStart;
            } else {
                if(selection.focusNode.nodeType === Node.TEXT_NODE) {
                    this.rangeEnd = this._getContentLengthOfDOMElement(rootEl, selection.focusNode) + selection.focusOffset;
                } else {
                    this.rangeEnd = this._getContentLengthOfDOMElement(rootEl, selection.focusNode);
                    for(let i=0; i<selection.focusOffset; i++) {
                        this.rangeEnd += this._getContentLengthOfDOMElement(selection.focusNode.childNodes[i]);
                    }
                }
            }

            this.rootEl = rootEl;
            this.selectionIsUnedidable = false;
            this.isAnchorLeft = this.rangeStart <= this.rangeEnd;
            this.rangeStartAtZeroOffset = selection.anchorOffset === 0;
            this.rangeEndAtZeroOffset = selection.focusOffset === 0;
            this.selectionAnchorNode = selection.anchorNode;
            this.selectionFocusNode = selection.focusNode;
            this.selectionAnchorOffset = selection.anchorOffset;
            this.selectionFocusOffset = selection.focusOffset;
            this.selectionIsCollapsed = selection.isCollapsed;

            this.followingSpaceTerminatesTextNode = selection.anchorNode === selection.focusNode &&
                                                    selection.focusNode.length &&
                                                    selection.anchorOffset === (selection.focusNode.length-1) &&
                                                    (selection.focusNode.nodeValue[selection.focusNode.length-1] === '\u00A0' ||
                                                     selection.focusNode.nodeValue[selection.focusNode.length-1] === ' ');

             if(insertedContent === ' ' && this.followingSpaceTerminatesTextNode) {
               this.carretPlacementCorrection = -1;
             } else {
               this.carretPlacementCorrection = 0;
             }

             return {
                rootEl: this.rootEl,
                rangeStart: this.rangeStart,
                rangeEnd: this.rangeEnd,
                isAnchorLeft: this.isAnchorLeft,
                rangeStartAtZeroOffset: this.rangeStartAtZeroOffset,
                rangeEndAtZeroOffset: this.rangeEndAtZeroOffset,
                selectionFocusNode: this.selectionFocusNode,
                selectionAnchorNode: this.selectionAnchorNode,
                selectionIsCollapsed: this.selectionIsCollapsed,
                selectionIsUnedidable: this.selectionIsUnedidable
             }
        }
    },

    clearSelection: function() {
        window.getSelection().removeAllRanges();
    },

    targetElement: function() {
        return window.getSelection().focusNode;
    },

    isCollapsed: function() {
        var sel = window.getSelection(),
            range;

        if(sel.rangeCount === 0) return;

        range = sel.getRangeAt(0);
        if(!range) return;
        return range.collapsed;
    },

    // If the selection is not collapsed and the start or end
    // is outsite the given element, this function will move the
    // corresponding selection end inside the given element.
    //
    // In the following Example the passed element is the p section
    // in the middle:
    // <p>text</p><p>w|ith</p><p>paragr|aphs</p>
    // =>
    // <p>text</p><p>w|ith|</p><p>paragraphs</p>
    //
    // This is actually not used on section level but to ensure
    // that the selection is within the editor iteself.
    ensureExpandedSelectionIsWithinElement: function(el) {
        var sel = window.getSelection(),
            n1 = sel.focusNode,
            o1 = sel.focusOffset,
            n2 = sel.anchorNode,
            o2 = sel.anchorOffset,
            tmp, n1IncludedInEl, n2IncludedInEl, n1Pos, n2Pos,
            n1AndN2AreFollowingEl, n1AndN2ArePrecedingEl, childEl,
            elWalker, newRange;

        if(!n1 || !n2 || sel.isCollapsed) { return }

        n1Pos = n1.compareDocumentPosition(el);
        n2Pos = n2.compareDocumentPosition(el);

        n1IncludedInEl = n1Pos & Node.DOCUMENT_POSITION_CONTAINS;
        n2IncludedInEl = n2Pos & Node.DOCUMENT_POSITION_CONTAINS;

        if(n1IncludedInEl && n2IncludedInEl) { return }

        n1AndN2AreFollowingEl = !!((n1Pos & Node.DOCUMENT_POSITION_FOLLOWING) && (n2Pos & Node.DOCUMENT_POSITION_FOLLOWING) && !n1IncludedInEl && !n2IncludedInEl);
        n1AndN2ArePrecedingEl = !!((n1Pos & Node.DOCUMENT_POSITION_PRECEDING) && (n2Pos & Node.DOCUMENT_POSITION_PRECEDING) && !n1IncludedInEl && !n2IncludedInEl);

        if(n1AndN2AreFollowingEl || n1AndN2ArePrecedingEl) { return }

        if(n1.compareDocumentPosition(n2) & Node.DOCUMENT_POSITION_PRECEDING) {
            tmp = n2; n2 = n1; n1 = tmp;
            tmp = o2; o2 = o1; o1 = tmp;
            tmp = n2IncludedInEl; n2IncludedInEl = n1IncludedInEl; n1IncludedInEl = tmp;
        }

        newRange = document.createRange();

        if(!n1IncludedInEl) {
            elWalker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null, false);
            newRange.setStart(elWalker.firstChild(), 0);
        } else {
            newRange.setStart(n1, o1);
        }

        if(!n2IncludedInEl) {
            elWalker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null, false);
            childEl = elWalker.lastChild();
            newRange.setEnd(childEl, childEl.length);
        } else {
            newRange.setEnd(n2, o2);
        }

        sel.removeAllRanges();
        sel.addRange(newRange);
    },

    getContentLengthTillSection: function(section) {
        var result = 0;
        section = section.previousSibling;

        while(section) {
            result += this._getContentLengthOfDOMElement(section);
            section = section.previousSibling;
        }

        return result;
    },
}

module.exports = Caret;


/***/ }),

/***/ "../structured-text-editor/src/editor.js":
/*!***********************************************!*\
  !*** ../structured-text-editor/src/editor.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var HTMLRazor = __webpack_require__(/*! ../lib/html_razor/html_razor */ "../structured-text-editor/lib/html_razor/html_razor.js"),
    TagTransformations = __webpack_require__(/*! ../lib/html_razor/tag_transformation */ "../structured-text-editor/lib/html_razor/tag_transformation.js"),
    Caret = __webpack_require__(/*! ./caret */ "../structured-text-editor/src/caret.js"),
    SectionTypeSelectorControl = __webpack_require__(/*! ./section_type_selector_control */ "../structured-text-editor/src/section_type_selector_control.js"),
    KeyPressHandler = __webpack_require__(/*! ./key_press_handler */ "../structured-text-editor/src/key_press_handler.js"),
    TextEnrichmentControl = __webpack_require__(/*! ./text_enrichment_control */ "../structured-text-editor/src/text_enrichment_control.js"),
    Documentupdater = __webpack_require__(/*! ../lib/documentupdater/documentupdater */ "../structured-text-editor/lib/documentupdater/documentupdater.js"),
    ModificationLogEntry = __webpack_require__(/*! ../lib/documentupdater/modification_log */ "../structured-text-editor/lib/documentupdater/modification_log.js"),
    ReferenceStore = __webpack_require__(/*! ./references/reference_store */ "../structured-text-editor/src/references/reference_store.js"),
    ReferenceController = __webpack_require__(/*! ./references/reference_controller */ "../structured-text-editor/src/references/reference_controller.js"),
    DeclarativForm = __webpack_require__(/*! ../lib/declarativ_forms/src/declarativ_form */ "../structured-text-editor/lib/declarativ_forms/src/declarativ_form.js"),
    Changeset = (__webpack_require__(/*! changesets */ "../structured-text-editor/node_modules/changesets/lib/index.js").Changeset),
    paragraphSectionType = __webpack_require__(/*! ./section_types/paragraph/paragraph_section_type */ "../structured-text-editor/src/section_types/paragraph/paragraph_section_type.js"),
    tableSectionType = __webpack_require__(/*! ./section_types/table/table_section_type */ "../structured-text-editor/src/section_types/table/table_section_type.js"),
    unorderedListSectionType = __webpack_require__(/*! ./section_types/list/unordered_list_section_type */ "../structured-text-editor/src/section_types/list/unordered_list_section_type.js"),
    orderedListSectionType = __webpack_require__(/*! ./section_types/list/ordered_list_section_type */ "../structured-text-editor/src/section_types/list/ordered_list_section_type.js"),
    imageSectionType = __webpack_require__(/*! ./section_types/image/image_section_type */ "../structured-text-editor/src/section_types/image/image_section_type.js"),
    codeSectionType = __webpack_require__(/*! ./section_types/code/code_section_type */ "../structured-text-editor/src/section_types/code/code_section_type.js"),
    tocSectionType = __webpack_require__(/*! ./section_types/toc/toc_section_type */ "../structured-text-editor/src/section_types/toc/toc_section_type.js"),
    bibliographieSectionType = __webpack_require__(/*! ./section_types/bibliographie/bibliographie_section_type */ "../structured-text-editor/src/section_types/bibliographie/bibliographie_section_type.js"),
    footnotesSectionType = __webpack_require__(/*! ./section_types/footnotes/footnotes_section_type */ "../structured-text-editor/src/section_types/footnotes/footnotes_section_type.js"),
    formulaSectionType = __webpack_require__(/*! ./section_types/formula/formula_section_type */ "../structured-text-editor/src/section_types/formula/formula_section_type.js"),
    mermaidSectionType = __webpack_require__(/*! ./section_types/mermaid/mermaid_section_type */ "../structured-text-editor/src/section_types/mermaid/mermaid_section_type.js"),
    blockquoteSectionType = __webpack_require__(/*! ./section_types/blockquote/blockquote_section_type */ "../structured-text-editor/src/section_types/blockquote/blockquote_section_type.js"),
    heading1SectionType = __webpack_require__(/*! ./section_types/heading/heading1 */ "../structured-text-editor/src/section_types/heading/heading1.js"),
    heading2SectionType = __webpack_require__(/*! ./section_types/heading/heading2 */ "../structured-text-editor/src/section_types/heading/heading2.js"),
    heading3SectionType = __webpack_require__(/*! ./section_types/heading/heading3 */ "../structured-text-editor/src/section_types/heading/heading3.js"),
    heading4SectionType = __webpack_require__(/*! ./section_types/heading/heading4 */ "../structured-text-editor/src/section_types/heading/heading4.js"),
    heading5SectionType = __webpack_require__(/*! ./section_types/heading/heading5 */ "../structured-text-editor/src/section_types/heading/heading5.js"),
    utils = __webpack_require__(/*! ../lib/pixelschubser/utils */ "../structured-text-editor/lib/pixelschubser/utils.js"),
    // katex = require('katex'), // make sure to load <script src="./katex.js" defer></script> in your html
    uuid = __webpack_require__(/*! uuid/v1 */ "../structured-text-editor/node_modules/uuid/v1.js"),
    isMac = navigator.platform.indexOf("Mac") === 0;

window.Changeset = Changeset;

DOMTokenList.prototype.find = Array.prototype.find;
NodeList.prototype.indexOf = Array.prototype.indexOf;
NodeList.prototype.filter = Array.prototype.filter;
NodeList.prototype.forEach = Array.prototype.forEach;
NodeList.prototype.map = Array.prototype.map;
HTMLCollection.prototype.indexOf = Array.prototype.indexOf;
HTMLCollection.prototype.filter = Array.prototype.filter;
HTMLCollection.prototype.forEach = Array.prototype.forEach;
HTMLCollection.prototype.map = Array.prototype.map;
Array.prototype.contains = Array.prototype.includes;
Array.prototype.includesAll = function() { var self = this, args = Array.from(arguments); return args.every(function(r) {return self.includes(r) })}
Array.prototype.unique = function() { return this.filter(function (value, index, self) { return self.indexOf(value) === index }) }

var Editor = function(domId, options) {
    var self = this;
    options = options || {}

    this._initDone = false;
    this._isContentEditable = true;
    this.reference = new ReferenceController(new ReferenceStore(options.contentID, options.ReferencePersitencyDriver), this);
    this.tagTransformations = new TagTransformations();
    this.domId = domId;
    this.hintEl = document.createElement('ste-input-hint')
    this.containerElement = document.getElementById(domId);
    this.containerElement.innerHTML = '';
    this.contentElement = document.createElement('div');
    this.caret = new Caret(this);
    this.subscribers = [];
    this.referenceInsertedSubscribers = [];
    this.sectionFocusChangeSubscribers = [];
    this.sectionTypeSelector = new SectionTypeSelectorControl(this.changeFocusedSectionType, this, this);
    this.textEnrichmentControl = new TextEnrichmentControl(this);
    this.keyPressHandler = new KeyPressHandler(this);

    this.contentElement.setAttribute('spellcheck', options.spellcheck);
    this.contentElement.className = 'structured-text-editor';

    this.hintEl.innerHTML = `Write Here... Press <code>${isMac ? '⌘' : 'Ctrl'}</code> + <code>i</code> to insert a reference, footnote or equation.`;

    this.containerElement.className = 'structured-text-editor-container';
    this.containerElement.appendChild(this.buildAddSectionButton('top'));
    this.containerElement.appendChild(this.contentElement);
    this.containerElement.appendChild(this.buildAddSectionButton('bottom'));

    this.supportedSectionTypes = {};

    this.history = [];
    this.undoneModifications = [];
    this.caretPositions = [];

    this.markupTransformations = [
        { to: 'table',     praefix: '#table'  },
        { to: 'pre',       praefix: '#code'   },
        { to: 'h1',        praefix: '#title'  },
        { to: 'h2',        praefix: '#'       },
        { to: 'h2',        praefix: '#h1'     },
        { to: 'h3',        praefix: '##'      },
        { to: 'h3',        praefix: '#h2'     },
        { to: 'h4',        praefix: '###'     },
        { to: 'h4',        praefix: '#h3'     },
        { to: 'h5',        praefix: '####'    },
        { to: 'h5',        praefix: '#h4'     },
        { to: 'p',         praefix: '#p'      },
        { to: 'ul',        praefix: '#ul'     },
        { to: 'ul',        praefix: '\\*'     },
        { to: 'ol',        praefix: '#ol'     },
        { to: 'ol',        praefix: '1\\)'    },
        { to: 'figure',    praefix: '#img'    },
        { to: 'figure',    praefix: '#image'  },
        { to: 'nav',       praefix: '#toc'    },
        { to: 'h2(Abstract)',   praefix: '#abstract'  },
        { to: 'h2(Abstract)',   praefix: '#Abstract'  },
        { to: 'bibliographie',  praefix: '#bib'       },
        { to: 'footnotes',      praefix: '#footnotes' },
        { to: 'formula',        praefix: '#formula'   },
        { to: 'formula',        praefix: '#eq'        },
        { to: 'mermaid',        praefix: '#dia'       },
        { to: 'bquote',         praefix: '#quote'     },
        { to: 'bquote',         praefix: '#"'         },
        { to: 'bquote',         praefix: "#'"         },
        { to: 'bquote',         praefix: '#blockquote'},
    ];

    Object.assign(this.tagTransformations, {
        '/p': this.markupTransformations,
        '/h1': this.markupTransformations,
        '/h2': this.markupTransformations,
        '/h3': this.markupTransformations,
        '/h4': this.markupTransformations,
        '/h5': this.markupTransformations,
        '/div': 'p',
        '/b': 'p',
        '/i': 'p',
        '/inlinecode': 'p',
        '/p/br': '=',
        '/h1/br': '=p',
        '/h2/br': '=p',
        '/h3/br': '=p',
        '/h4/br': '=p',
        '/h5/br': '=p',

        '/p/b/br': '=',
        '/p/b/i/br': '=',
        '/p/b/u/br': '=',
        '/p/b/a/br': '=',

        '/p/u/br': '=',
        '/p/u/i/br': '=',
        '/p/u/b/br': '=',
        '/p/u/a/br': '=',

        '/p/i/br': '=',
        '/p/i/u/br': '=',
        '/p/i/b/br': '=',
        '/p/i/a/br': '=',

        '/p/code': 'inlinecode',
        '/p/inlinecode/br': '=',
        '/p/inlinecode/inlinecode': '#content',
        '/p/inlinecode/b': '#content',
        '/p/inlinecode/u': '#content',
        '/p/inlinecode/i': '#content',
        '/p/inlinecode/a': '#content',
        '/p/i/code': '-',
        '/p/b/code': '-',
        '/p/u/code': '-',
        '/p/a/code': 'inlinecode',
        '/p/i/inlinecode': '-',
        '/p/b/inlinecode': '-',
        '/p/u/inlinecode': '-',

        '/p/a/br': '=',
        '/p/a/i/br': '=',
        '/p/a/u/br': '=',
        '/p/a/b/br': '=',

        '/p/div': '-',
        '/h1/div': '-',
        '/h2/div': '-',
        '/h3/div': '-',
        '/h4/div': '-',
        '/h5/div': '-',
        '/p/p': '#content',
        '/p/font': '#content',
        '/p/var': '#content',
        '/p/a/span': '#content',
        '/figure/div': '#content',
    });

     this.tagTransformations.allowOnlyTextIn('/table/caption');
     this.tagTransformations.allowOnlyTextIn('/figure/figcaption');
     this.tagTransformations.allowOnlyTextIn('/table/tbody/tr/td', { allowEquations: true, allowRefs: true, allowLinks: true, allowBoldItalicUnderline: true });
     this.tagTransformations.allowOnlyTextIn('/ul/li', { allowEquations: true, allowRefs: true, allowLinks: true, allowBoldItalicUnderline: true });
     this.tagTransformations.allowOnlyTextIn('/ol/li', { allowEquations: true, allowRefs: true, allowLinks: true, allowBoldItalicUnderline: true });

     this.tagTransformations.allowOnlyTextIn('/ol/ol/li', { allowEquations: true, allowRefs: true, allowLinks: true, allowBoldItalicUnderline: true });
     this.tagTransformations.allowOnlyTextIn('/ol/ol/ol/li', { allowEquations: true, allowRefs: true, allowLinks: true, allowBoldItalicUnderline: true });

     this.tagTransformations.allowOnlyTextIn('/ul/ul/li', { allowEquations: true, allowRefs: true, allowLinks: true, allowBoldItalicUnderline: true });
     this.tagTransformations.allowOnlyTextIn('/ul/ul/ul/li', { allowEquations: true, allowRefs: true, allowLinks: true, allowBoldItalicUnderline: true });

     this.tagTransformations.allowOnlyTextIn('/h1', { allowEquations: true });
     this.tagTransformations.allowOnlyTextIn('/h2', { allowEquations: true });
     this.tagTransformations.allowOnlyTextIn('/h3', { allowEquations: true });
     this.tagTransformations.allowOnlyTextIn('/h4', { allowEquations: true });
     this.tagTransformations.allowOnlyTextIn('/h5', { allowEquations: true });

     this.tagTransformations.allowRefsIn('/p');
     this.tagTransformations.allowRefsIn('/p/b');
     this.tagTransformations.allowRefsIn('/p/i');
     this.tagTransformations.allowRefsIn('/p/u');
     this.tagTransformations.allowRefsIn('/pre/caption');
     this.tagTransformations.allowRefsIn('/table/caption');
     this.tagTransformations.allowRefsIn('/formula/caption');
     this.tagTransformations.allowRefsIn('/mermaid/caption');
     this.tagTransformations.allowRefsIn('/figure/figcaption');
     // this.tagTransformations.allowRefsIn('/bquote/citesrc'); // this is specified in the section type code file itself

     this.tagTransformations.allowInlineequationsIn('/p');
     this.tagTransformations.allowInlineequationsIn('/pre/caption');
     this.tagTransformations.allowInlineequationsIn('/table/caption');
     this.tagTransformations.allowInlineequationsIn('/formula/caption');
     this.tagTransformations.allowInlineequationsIn('/mermaid/caption');
     this.tagTransformations.allowInlineequationsIn('/figure/figcaption');
     this.tagTransformations.allowInlineequationsIn('/bquote/citesrc');

    this.contentRules = {
        'i': {
            tagName: 'i',
            allowedChildren: ['#text', 'link', 'b', 'u', 'footnote', 'reference'],
            pruneSpaces: true,
            deleteIfEmpty: true
        },
        'b': {
            tagName: 'b',
            allowedChildren: ['#text', 'link', 'i', 'u', 'footnote', 'reference'],
            pruneSpaces: true,
            deleteIfEmpty: true
        },
        'u': {
            tagName: 'u',
            allowedChildren: ['#text', 'link', 'b', 'i', 'footnote', 'reference'],
            pruneSpaces: true,
            deleteIfEmpty: true
        },
        'inlinecode': {
            tagName: 'inlinecode',
            allowedChildren: ['#text'],
            pruneSpaces: true,
            deleteIfEmpty: true,
        },
        'link': {
            tagName: 'a',
            allowedChildren: ['#text', 'b', 'i', 'u', 'inlinecode'],
            allowedAttributes: ['href'],
            pruneSpaces: true,
            deleteIfEmpty: true
        },
        'footnote': {
            tagName: 'span',
            className: 'footnote',
            allowedAttributes: ['class', 'contenteditable', 'data-note'],
            allowedClassNames: ['footnote'],
            allowedChildren: [],
            buildAttributes: [{name: 'contenteditable', build: function() { return false }}]
        },
        'inlineequation': {
            tagName: 'inlineequation',
            allowedAttributes: ['contenteditable', 'data-latexequation', 'id'],
            allowedChildren: [],
            buildAttributes: [
                {name: 'contenteditable', build: function() { return false }},
                {name: 'id', build: function() { return uuid() }}
            ]
        },
        'reference': {
            tagName: 'span',
            className: 'reference',
            allowedAttributes: ['class', 'contenteditable', 'data-ref', 'data-external'],
            allowedClassNames: ['reference'],
            allowedChildren: [],
            buildAttributes: [{name: 'contenteditable', build: function() { return false }}]
        }
    };

    // According to this config:
    //   when the editor updated a section which
    //     - contains a "h2" element or
    //     - contained a "h2" element or
    //     - is a "h2" element or
    //     - was a "h2" element
    // the modificationLogEntry will have a field "mightIncludeHeadingUpdates" set to true
    this.modLogFlags = {
        Heading: ['h1', 'h2', 'h3', 'h4', 'h5'],
        TableOfContent: ['nav'],
        Bibliographie: ['bibliographie'],
        Reference: ['.reference[data-external="true"]'],
        Footnote: ['.footnote'],
        Inlinequation: ['.inlineequation'],
        FootnotesSection: ['footnotes'],
    };

    this.addSectionType(paragraphSectionType);
    this.addSectionType(tableSectionType);
    this.addSectionType(unorderedListSectionType);
    this.addSectionType(orderedListSectionType);
    this.addSectionType(codeSectionType);
    this.addSectionType(tocSectionType);
    this.addSectionType(bibliographieSectionType.setEditor(this));
    this.addSectionType(footnotesSectionType.setEditor(this));
    this.addSectionType(heading1SectionType);
    this.addSectionType(heading2SectionType);
    this.addSectionType(heading3SectionType);
    this.addSectionType(heading4SectionType);
    this.addSectionType(heading5SectionType);
    this.addSectionType(imageSectionType.setEditor(this));
    this.addSectionType(formulaSectionType);
    this.addSectionType(mermaidSectionType);
    this.addSectionType(blockquoteSectionType);

    this.htmlRazor = new HTMLRazor(this.tagTransformations, this.contentRules);
    this.documentupdater = new Documentupdater(this.contentElement, this.htmlRazor);
    this.activateInputEventProcessing();

    this.subscribe(function(modLogEntry) {
        if(modLogEntry.tags !== 'undo') {
            self.history.push(modLogEntry);
            if(self.history.length > 30) {
                self.history.shift();
            }
        }

        if(modLogEntry.tags !== 'redo' && modLogEntry.tags !== 'undo') {
            self.undoneModifications = [];
        }
    });

    window.addEventListener('resize', function() {
        var section = self.focusedSection();

        if(section && section.onWindowResize) {
            section.onWindowResize(self);
        }
    })

    document.addEventListener('selectionchange', function(e) {
        if(self.isContentEditable() && self._mouseDown && !self.caret.isCollapsed()) {
            self.setContentEditable(false);
        }

        var section = self.focusedSection();

        if(section && section.onSelectionChange) {
            section.onSelectionChange(self);
        }
    });

    document.addEventListener('mousedown', function(e) {
        self._mouseDown = true;
        self.setContentEditable(true);
    });

    document.addEventListener('mouseup', function(e) {
        self._mouseDown = false;
        if(!self.areMultipleSectionsSelected()) {
            self.setContentEditable(true);
        }
    });

    window.addEventListener('scroll', function(e) {
        self.sectionTypeSelector.displayNextTo(self.focusedSection());
    });

    window.addEventListener('resize', function(e) {
        self.sectionTypeSelector.displayNextTo(self.focusedSection());
        self.textEnrichmentControl.updatePositionIfVisible();
    });

    this.caret.subscribeSelectionChange(function(selection) {
        var section = self.sectionAtCaretPostion(),
            previousFocusedSection = self.focusedSection();

        if(section && !self.isFocused(section)) {
            self.focusSection(section);

            if(previousFocusedSection && self.shouldSectionBeRemovedIfUnfocused(previousFocusedSection)) {
                // this will delete the previous focused Section in case it is empty
                self.replaceSectionWithHTML(previousFocusedSection, previousFocusedSection.outerHTML);
            }
        }

        self.scrollToFocusedSectionIfNotInViewport();
    });

    this.contentElement.addEventListener('input', function(e) {
        if(self.isInputEventProcessingActivated() && e.target.tagName !== 'INPUT') {
            self.replaceSectionWithHTML(e.target, e.target.outerHTML, {inputEvent: e})
        }
    });

    this._initDone = true;
}

Editor.prototype = {

    displayModal: function(fields, handler, notFocusFirstInput) {
        var self = this, form;

        this.freezeSelection({
            'unfreezeCallback': function() {
                self.textEnrichmentControl.preventEnrichmentControllToBeHidden = false;
                self.textEnrichmentControl.hide();
            },
        });

        try {
            form = new DeclarativForm({fields: fields}, handler, () => {
                self.unfreezeSelection();
                self.unfocusSection();
                self.caret.clearSelection();
            });
            form.openInModal();

            if(!notFocusFirstInput && fields[0] && fields[0].domElement && fields[0].domElement.tagName === 'DL-SELECT') {
                form.formElement.querySelector('input').focus();
            }

            if(!notFocusFirstInput && fields[0] && fields[0].domElement && fields[0].domElement.tagName === 'TEXTAREA') {
                form.formElement.querySelector('textarea').focus();
            }

            if(!notFocusFirstInput && fields[0] && fields[0].domElement && fields[0].domElement.tagName === 'INPUT') {
                form.formElement.querySelector('input').focus();
            }
        } catch(e) {
            self.unfreezeSelection();
            throw e;
        }
    },

    undo: function() {
        var logEntry = this.history.pop();

        if(logEntry) {
            this.setContent(logEntry.beforeState(), { caretPosition: logEntry.beforeStateCaretPosition, modificationLogTags: 'undo' });
            this.focusSection(this.sectionAtCaretPostion(), { force: true });
            this.undoneModifications.push(logEntry);
        }
    },

    redo: function() {
        var logEntry = this.undoneModifications.pop();

        if(logEntry) {
            this.setContent(logEntry.afterState(), { caretPosition: logEntry.afterStateCaretPosition, modificationLogTags: 'redo' });
            this.focusSection(this.sectionAtCaretPostion(), { force: true });
        }
    },

    emptyHistory: function() {
        this.history = [];
        this.undoneModifications = [];
    },

    selectEverything: function() {
        var lastSection = this.contentElement.children[this.contentElement.children.length-1],
            firstSection = this.contentElement.children[0],
            lastNonEmptySectionIndex = lastSection.innerText !== '' ? this.contentElement.children.length-1 : this.contentElement.children.length-2,
            firstNonEmptySectionIndex = firstSection.innerText !== '' ? 0 : 1,
            range = document.createRange(),
            sel = window.getSelection(),
            allTextNodesOfFirstSection = this.allTextNodesOfSection(firstNonEmptySectionIndex),
            allTextNodesOfLastSection = this.allTextNodesOfSection(lastNonEmptySectionIndex),
            lastTextNodeOfLastSection = allTextNodesOfLastSection[allTextNodesOfLastSection.length-1];

        range.setStart(allTextNodesOfFirstSection[0], 0);
        range.setEnd(lastTextNodeOfLastSection, lastTextNodeOfLastSection.length);
        sel.removeAllRanges();
        sel.addRange(range);

        if(firstNonEmptySectionIndex !== lastNonEmptySectionIndex) {
            for(let i=0; i<this.contentElement.children.length; i++) {
                this.contentElement.children[i].blur();
            }
            this.setContentEditable(false);
        }
    },

    allTextNodesOfSection: function(index) {
        return utils.getAllTextNodesOfElement(this.sectionAt(index))
    },

    isSpellcheckEnabled: function() {
        return this.contentElement.getAttribute('spellcheck') === 'true';
    },

    buildAddSectionButton: function(type) {
        var self = this,
            btn = document.createElement('div');

        if(type !== 'bottom' && type !== 'top') return false

        btn.className = type + 'SectionInsertButton'
        btn.innerHTML = '<span>Add Section</span>';
        btn.onclick = function() { self.addSection(type); btn.onmouseover()}
        btn.onmouseover = function() {
            var section = self.contentElement[type == 'bottom' ? 'lastChild' : 'firstChild'];
            if(self.shouldSectionBeRemovedIfUnfocused(section)) {
               btn.classList.add('deactivatedSectionInsertButton');
            } else {
               btn.classList.remove('deactivatedSectionInsertButton');
            }
        };
        return btn;
    },

    isContentEditable: function() {
        return this._isContentEditable;
    },

    setContentEditable: function(shouldBeEditable) {
        var self = this,
            indexOfFocusedSection = this.indexOfFocusedSection();

        if(this._isContentEditable === shouldBeEditable) return;

        var updateDom = function(el, shouldBeEditable) {
            if(el.setContenteditable) {
                el.setContenteditable(shouldBeEditable, el);
            } else {
                if(shouldBeEditable) {
                    el.setAttribute('contenteditable', true);
                } else {
                    el.removeAttribute('contenteditable');
                }
            }
        }

        this._isContentEditable = shouldBeEditable;
        for(let i=0; i<this.contentElement.children.length; i++) {

            if(Math.abs(indexOfFocusedSection - i) <= 3) {
                updateDom(self.contentElement.children[i], shouldBeEditable);
            } else {
                (function(el) {
                    window.setTimeout(function() {
                        updateDom(el, shouldBeEditable);
                    }, 0);
                })(self.contentElement.children[i]);
            }
        }

        if(shouldBeEditable) {
            this.refreshFocus();
        }
    },

    refreshFocus: function() {
        var range, sel = window.getSelection();
        if(sel.rangeCount > 0 && !this.isSelectionFreezed) {
            range = sel.getRangeAt(0);
            if(range) {
                sel.removeRange(range);
                sel.addRange(range);
            }
        }
    },

    sectionAt: function(index) {
        return this.contentElement.children[index];
    },

    indexOf: function(section) {
        return this.contentElement.children.indexOf(section);
    },

    indexOfFocusedSection: function() {
        return this.indexOf(this.focusedSection());
    },

    scrollToFocusedSectionIfNotInViewport: function() {
        var section;
        if(this.isFocusedSectionInViewport() === false) {
            section = this.focusedSection();
            if(section) {
                window.scrollTo(0, section.offsetTop-(window.innerHeight/2));
            }
        }
    },

    isFocusedSectionInViewport: function() {
        var section = this.focusedSection();
        if(!section) return;
        return window.innerHeight-20 > section.getBoundingClientRect().y;
    },

    addSection: function(position) {
        position = position || 'bottom';

        if(position === 'bottom') {
            return this.addNewSectionNextTo(this.contentElement.lastChild);
        } else if(position === 'top') {
            return this.addNewSectionNextTo(this.contentElement.firstChild, 'before');
        } else {
            return false;
        }
    },

    addNewSectionNextTo: function(section, position) {
        if(this.shouldSectionBeRemovedIfUnfocused(section)) {
            return false;
        }

        var emptySection = document.createElement('p');

        this.modificationLogEntry = new ModificationLogEntry();
        emptySection.innerHTML = '';
        emptySection.originalHTML = emptySection.outerHTML;
        emptySection.setAttribute('contenteditable', true);

        this.contentElement.insertBefore(emptySection, (position === 'before' ? section : section.nextSibling));
        this.modificationLogEntry.retainAllSectionsBefore(emptySection);
        this.modificationLogEntry.insertSection(emptySection);
        this.modificationLogEntry.retainAllSectionsAfter(emptySection);

        this.focusSection(emptySection);
        this.caret.positionAtTheBeginningOf(emptySection);
        this.notifySubscribers(this.modificationLogEntry);
        return true;
    },

    removeSection: function(section) {
        if(!this.isSection(section)) return;

        if(this.contentElement.children.length === 1) {
            this.replaceSectionWithHTML(section, '<p></p>');
            this.caret.positionAtTheBeginningOf(this.contentElement.children[0]);
        } else {
            this.modificationLogEntry = new ModificationLogEntry();
            this.modificationLogEntry.modLogFlags = this.modLogFlags;
            this.modificationLogEntry.retainAllSectionsBefore(section);
            this.modificationLogEntry.deleteSection(section);
            this.modificationLogEntry.retainAllSectionsAfter(section);

            this.caret.saveSelection(this.contentElement);
            this.contentElement.removeChild(section);
            this.modificationLogEntry.wordCount = this.getWordCount();
            this.updateFootnotesNumbering();
            this.updateReferenceNumbering();
            this.caret.restoreSelection(0);
            this.notifySubscribers(this.modificationLogEntry);
        }
    },

    addSectionType: function(sectionType) {
        Object.assign(this.tagTransformations, sectionType.tagTransformations || {});
        Object.assign(this.contentRules, sectionType.contentRules || {});
        this.textEnrichmentControl.addEnrichments(sectionType.enrichments || []);
        this.supportedSectionTypes[sectionType.name] = sectionType;

        if(sectionType.onEditorContentChanged) {
            this.subscribe(sectionType.onEditorContentChanged, true);
        }
    },

    subscribe: function(callback, notifyOnMetadataChange) {

        if(notifyOnMetadataChange) {
            callback.notifyOnMetadataChange = true;
        }

        this.subscribers.push(callback);
    },

    subscribeReferenceInsertion: function(callback) {
        this.referenceInsertedSubscribers.push(callback);
    },

    subscribeSectionFocusChange: function(callback) {
        this.sectionFocusChangeSubscribers.push(callback)
    },

    isInputEventProcessingActivated: function() {
        return this.cleanupContentOnInputEvent;
    },

    deactivateInputEventProcessing: function() {
        for(let i=0; i<this.contentElement.children.length; i++) {
            this.contentElement.children[i].HTMLbevoreInputProcessingDeactivation = this.contentElement.children[i].outerHTML;
        }

        this.sectionCountBeforeInputProcessing = this.contentElement.children.length;
        this.cleanupContentOnInputEvent = false;
    },

    activateInputEventProcessing: function() {
        this.cleanupContentOnInputEvent = true;
        var changesMade = false;

        if(this.sectionCountBeforeInputProcessing === this.contentElement.children.length) {
            for(let i=0; i<this.contentElement.children.length; i++) {
                if(this.contentElement.children[i].forceUpdateOnInputProcesssingEnablement ||
                    this.contentElement.children[i].HTMLbevoreInputProcessingDeactivation !== this.contentElement.children[i].outerHTML) {
                    this.replaceSectionWithHTML(this.contentElement.children[i], this.contentElement.children[i].outerHTML);
                    changesMade = true;
                }

                delete this.contentElement.children[i].HTMLbevoreInputProcessingDeactivation;
                delete this.contentElement.children[i].forceUpdateOnInputProcesssingEnablement;
            }

            if(changesMade) {
                this.updateFootnotesNumbering();
                this.updateReferenceNumbering();
            }
        } else {
            this.content(this.contentElement.innerHTML);
        }

        delete this.sectionCountBeforeInputProcessing;
    },

    freezeSelection: function(args) {
        var args = args || {},
            clickableElement = args['unfreezeOnClicksOutsiteOf'],
            self = this,
            f;

        this.unfreezeCallback = args['unfreezeCallback'];

        if(clickableElement) {
            document.body.addEventListener('click', f = function(e) {
                var tmp = e.target,
                    path = [];

                while(tmp.parentElement) {
                    path.push(tmp.parentElement);
                    tmp = tmp.parentElement;
                }

                if(path.indexOf(clickableElement) === -1) {
                    self.unfreezeSelection(false);
                    document.body.removeEventListener('click', f);
                }
            });
        }

        if(!this.isSelectionFreezed) {
            this.deactivateInputEventProcessing();
            document.execCommand('backColor', false, '#b2d7fd');
            this.caret.saveSelection(this.contentElement);
            window.getSelection().removeAllRanges();
            this.isSelectionFreezed = true;
        }
    },

    unfreezeSelection: function(restoreSelection) {
        if(this.isSelectionFreezed) {
            restoreSelection = restoreSelection === undefined ? true : restoreSelection;

            if(restoreSelection) {
                if(this.caret.selectionIsCollapsed && this.caret.selectionFocusNode.tagName === 'TD') {
                    this.caret.restoreSelection(false, 'TryDOMStrategyFirst');
                } else {
                    this.caret.restoreSelection();
                }
            }

            this.activateInputEventProcessing();

            if(this.unfreezeCallback) {
                this.unfreezeCallback();
                this.unfreezeCallback = null;
            }
            this.isSelectionFreezed = false;
        }
    },

    notifySubscribers: function(modificationLogEntry) {
        this._cleanupModificationLogFromEditorSpecificMarkup(modificationLogEntry);

        const noNoOp = modificationLogEntry.log.find(l => {
            if(l.type === 'retain') {
                return false;
            }

            if(l.type === 'replace' && l.newSectionHTML === l.oldSectionHTML) {
                return false;
            }

            return true;
        })

        if(!noNoOp) {
            this.subscribers.filter(cb => cb.notifyOnMetadataChange).forEach(function(f) {f(modificationLogEntry)});
        } else {
            this.subscribers.forEach(function(f) {f(modificationLogEntry)});
        }
    },

    sectionByChildNode: function(child) {
        while(child) {
            if(this.isSection(child)) {
                return child;
            }
            child = child.parentNode;
        }
    },

    sectionAtCaretPostion: function() {
        return this.sectionByChildNode(this.caret.targetElement());
    },

    areMultipleSectionsSelected: function() {
        var sel = window.getSelection(), s1, s2;

        if(!sel || sel.isCollapsed) { return false }

        s1 = this.sectionByChildNode(sel.anchorNode);
        s2 = this.sectionByChildNode(sel.focusNode);

        return s1 && s2 && s1 !== s2;
    },

    placeCaretIntoSection: function(section, position, doNotFocusSection) {
        if(!section) return;
        position = position || 'end';

        if(position === 'preferredOrBeginning') {
            position = section.sectionType && section.sectionType.preferredCaretPositioning || 'beginning';
        }

        var targetEl = section,
            tmpTargetEl;

        if(section.sectionType && section.sectionType.editableElementSelector) {
            tmpTargetEl = section.querySelector(section.sectionType.editableElementSelector);
            targetEl = tmpTargetEl || section;
        }

        var range = document.createRange(),
            sel = window.getSelection(),
            textNodes = utils.getAllTextNodesOfElement(targetEl),
            textNode = position === 'end' ? textNodes[textNodes.length-1] : textNodes[0];

        // The focus/anchor node should be the deepest node possible.
        // Otherwise the text enrichment controlls will be placed at the wrong
        // position.

        if(position === 'end' && textNode) {
            this.caret.positionAfter(textNode);
        } else {
            range.selectNodeContents(textNode || targetEl);
            range.collapse(position !== 'end');
            sel.removeAllRanges();
            sel.addRange(range);
        }

        if(!doNotFocusSection) {
            this.focusSection(targetEl, {action: 'placeCaretIntoSection'});
        }
    },

    isSection: function(element) {
        return element &&
               element.parentElement === this.contentElement &&
               element.nodeType !== Node.TEXT_NODE;
    },

    focusSection: function(element, args) {
        args = args || {};
        if(!element || !this.isSection(element)) return;
        if(this.focusedElement === element && !args.force) return;
        var isAlreadyHighlighted = element.classList.contains('focused');

        this.unfocusSection();
        this.focusedElement = element;
        this.focusedElement.classList.add('focused');

        this.sectionFocusChangeSubscribers.forEach(function(cb) {cb()});
        this.sectionTypeSelector.displayNextTo(this.focusedElement);

        if(!isAlreadyHighlighted) {
            if(element && element.sectionType && element.sectionType.onFocus) {
                if(!this.areMultipleSectionsSelected()) {
                    element.sectionType.onFocus(element, this, args);
                }
            }
        }
    },

    unfocusSection: function() {
        var self = this,
            focusedSections = this.contentElement.querySelectorAll('.focused');

        focusedSections.forEach(function(sec) {
            if(sec.classList.contains('focused')) {
                sec.classList.remove('focused');

                if(sec.onUnfocus) {
                    sec.onUnfocus(self);
                }
            }
        });

        self.sectionTypeSelector.hide();
        this.focusedElement = null;
    },

    focusedSection: function() {
        return this.focusedElement;
    },

    isFocused: function(section) {
        return section === this.focusedElement;
    },

    moveCaretOneSectionUp: function(position) {
        position = position || 'end';
        var s = this.focusedSection();
        this.placeCaretIntoSection(s && s.previousSibling, position, true);
    },

    moveCaretOneSectionDown: function(position) {
        position = position || 'end';
        var s = this.focusedSection();
        this.placeCaretIntoSection(s && s.nextSibling, position, true);
    },

    moveFocusedSectionUp: function() {
        var focusedSection = this.focusedSection();
        if(focusedSection && focusedSection.previousSibling) {
            this.caret.saveSelection(this.contentElement);

            this.modificationLogEntry = new ModificationLogEntry();
            this.modificationLogEntry.modLogFlags = this.modLogFlags;
            this.modificationLogEntry.retainAllSectionsBefore(focusedSection.previousSibling);
            this.modificationLogEntry.replaceSection(focusedSection.previousSibling, focusedSection);
            this.modificationLogEntry.replaceSection(focusedSection, focusedSection.previousSibling);
            this.modificationLogEntry.retainAllSectionsAfter(focusedSection);

            this.contentElement.insertBefore(focusedSection, focusedSection.previousSibling);
            this.caret.restoreSelection(0, 'DOMStrategy');
            this.notifySubscribers(this.modificationLogEntry);
            this.sectionTypeSelector.displayNextTo(this.focusedSection());
            this.updateFootnotesNumbering();
            this.updateReferenceNumbering();
        }
    },

    moveFocusedSectionDown: function() {
        var focusedSection = this.focusedSection();
        if(focusedSection && focusedSection.nextSibling) {
            this.caret.saveSelection(this.contentElement);

            this.modificationLogEntry = new ModificationLogEntry();
            this.modificationLogEntry.modLogFlags = this.modLogFlags;
            this.modificationLogEntry.retainAllSectionsBefore(focusedSection);
            this.modificationLogEntry.replaceSection(focusedSection, focusedSection.nextSibling);
            this.modificationLogEntry.replaceSection(focusedSection.nextSibling, focusedSection);
            this.modificationLogEntry.retainAllSectionsAfter(focusedSection.nextSibling);

            if(focusedSection.nextSibling.nextSibling) {
                this.contentElement.insertBefore(focusedSection, focusedSection.nextSibling.nextSibling);
            } else  {
                this.contentElement.appendChild(focusedSection);
            }

            this.caret.restoreSelection(0, 'DOMStrategy');
            this.notifySubscribers(this.modificationLogEntry);
            this.sectionTypeSelector.displayNextTo(this.focusedSection());
            this.updateFootnotesNumbering();
            this.updateReferenceNumbering();
        }
    },

    changeFocusedSectionType: function(sectionTypeName, annotation) {
        var focusedSection = this.focusedSection(),
            st = this.supportedSectionTypes[sectionTypeName],
            newEl, sectionCreator, sectionIndex, changedSection,
            self = this, newContent, oldContent, rule;

        if(annotation) {
            annotation = [annotation]
        }

        sectionCreator = (st && st.getSectionElement) || function(existingSectionContent) {
            newContent = self.htmlRazor.cleanupHTML('<' + sectionTypeName + '>' +  existingSectionContent +  '<' + sectionTypeName + '>');
            newContent = newContent.next() || '';
            newContent = newContent.value || '';
            return newContent;
        }

        if(focusedSection) {
            rule = st && Object.values(st.contentRules).find(function(r) { return r.allowedToBeRoot });
            oldContent = focusedSection.innerHTML

            if(focusedSection.tagName === 'PRE' && focusedSection.querySelector('code')) {
                oldContent = focusedSection.querySelector('code').innerText
            }

            newEl = sectionCreator(oldContent, annotation, rule) || document.createElement(sectionTypeName);
            sectionIndex = this.indexOf(focusedSection);
            this.replaceSectionWithHTML(focusedSection, newEl.outerHTML, {action: 'changeFocusedSectionType'});
            utils.copyEventListenersRecursively(newEl, this.contentElement.children[sectionIndex]);
            this.focusSection(newEl, {action: 'changeFocusedSectionType'});
            changedSection = this.contentElement.children[sectionIndex];
        }
    },

    mergeParagraphIntoListIfSectionTypeMatch: function(s1, s2) {
        var liItem, newElement;

        if(s1.tagName !== 'UL' && s1.tagName !== 'OL') {
            return false;
        }

        if(s2.tagName !== 'P') {
            return false;
        }

        newElement = s1.cloneNode(false);
        newElement.innerHTML = s1.innerHTML + '<li>' +  s2.innerHTML + '</li>'
        return newElement;
    },

    mergeSimpleTextSectionsIfSectionTypeMatch: function(s1, s2) {
        if(!s1 || !s2) { return false }

        var s2IsEmpty = s2.innerHTML.trim() === '',
            mergeable = ['P', 'H1', 'H2', 'H3', 'H4', 'H5'],
            newElement;

        if(s2IsEmpty) {
            return s1;
        }

        if(mergeable.includesAll(s1.tagName, s2.tagName)) {
            newElement = s1.cloneNode(false);
            newElement.innerHTML = s1.innerHTML + s2.innerHTML;
            return newElement;
        }
    },

    mergeSections: function(s1, s2) {
        var sectionIndex = this.indexOf(s1),
            s2IsEmpty = s2.innerText.trim() === '',
            newElement;

        newElement = this.mergeParagraphIntoListIfSectionTypeMatch(s1, s2);

        if(!newElement) {
            newElement = this.mergeSimpleTextSectionsIfSectionTypeMatch(s1, s2);
        }

        if(newElement) {
            this.setContent(newElement.outerHTML, { startSection: s1, endSection: s2 });

            if(s2IsEmpty) {
                this.placeCaretIntoSection(this.contentElement.children[sectionIndex]);
            }
        }
    },

    replaceSectionWithHTML: function(oldSection, outerHTML, args) {
        args = args || {};
        args.section = oldSection;
        this.setContent(outerHTML, args);
    },

    content: function(content, args) {
        if(typeof content === 'undefined') {
            return this.getContent();
        } else {
            return this.setContent(content, args);
        }
    },

    getContent: function() {
        return this.getRenderedContent();
    },

    getRenderedContent: function() {
        var result = '',
        section = this.contentElement.children[0];

        while(section) {
            result += this._cleanupHTMLFromEditorSpecificMarkupForSectionHTML(section.outerHTML);
            section = section.nextSibling;
        }

        return result;
    },

    getOriginalContent: function() {
        var result = '',
            section = this.contentElement.children[0];

        while(section) {
            result += this._cleanupHTMLFromEditorSpecificMarkupForSectionHTML(section.originalHTML);
            section = section.nextSibling;
        }

        return result;
    },

    applyChangeset: function(changeset, attr) {
        var i = 0;
        var totalOldContentLength = 0;
        var changesetCursorOldVersion = 0;
        var changesetCursorNewVersion = 0;
        var lengthOfUnchangedSection = 0;
        var lengthOfRemainingContent = 0;
        var changesStartAfter = 0;
        var changesEndAfterInOldVersion = 0;
        var updateStartSection = this.contentElement.children[0];

        for(; i<changeset.length; i++) {
            if(changeset[i].constructor.name !== 'Retain') {
                break;
            }

            changesStartAfter += changeset[i].length;
            changesetCursorOldVersion += changeset[i].length;
        }

        while((lengthOfUnchangedSection + this._cleanupHTMLFromEditorSpecificMarkupForSectionHTML(updateStartSection.originalHTML).length) <= changesStartAfter) {
            if(!updateStartSection.nextSibling) {
                break;
            }

            lengthOfUnchangedSection += this._cleanupHTMLFromEditorSpecificMarkupForSectionHTML(updateStartSection.originalHTML).length;

            updateStartSection = updateStartSection.nextSibling;
        }

        changesetCursorNewVersion = changesetCursorOldVersion;

        for(; i<changeset.length; i++) {
            changesetCursorOldVersion += changeset[i].input;
            changesetCursorNewVersion += changeset[i].output;

            if(changeset[i].constructor.name === 'Skip') {
                changesEndAfterInOldVersion = changesetCursorOldVersion;
            }
        }

        var updateEndSection = updateStartSection;
        var tmpChangesEndPosition = lengthOfUnchangedSection;

        while((tmpChangesEndPosition + this._cleanupHTMLFromEditorSpecificMarkupForSectionHTML(updateEndSection.originalHTML).length) < changesEndAfterInOldVersion) {
            tmpChangesEndPosition += this._cleanupHTMLFromEditorSpecificMarkupForSectionHTML(updateEndSection.originalHTML).length;
            updateEndSection = updateEndSection.nextSibling;
        }

        var oldContent = '';
        var tmpSection = updateStartSection;

        while(tmpSection !== updateEndSection) {
            oldContent += this._cleanupHTMLFromEditorSpecificMarkupForSectionHTML(tmpSection.originalHTML);
            tmpSection = tmpSection.nextSibling;
        }

        oldContent += this._cleanupHTMLFromEditorSpecificMarkupForSectionHTML(updateEndSection.originalHTML);

        tmpSection = tmpSection.nextSibling;

        while(tmpSection) {
            lengthOfRemainingContent += this._cleanupHTMLFromEditorSpecificMarkupForSectionHTML(tmpSection.originalHTML).length;
            tmpSection = tmpSection.nextSibling;
        }

        totalOldContentLength = lengthOfUnchangedSection + oldContent.length + lengthOfRemainingContent;

        if(totalOldContentLength !== changeset.inputLength) {
            throw 'applyChangeset: the given changeset does not match the content length!!';
        }

        const slice = (cangeset, start, end) => {
            let processed = 0;
            let result = Changeset.create();

            for(let op of changeset) {
                let currentOpStart = processed;
                let currentOpEnd = processed + op.input;

                if(currentOpStart < start && currentOpEnd > start) {
                    if(op.constructor.name !== 'Retain') {
                        throw 'Retain operation expected when extracting the changes local to a section'
                    }

                    result.retain(op.input - (start - currentOpStart));
                } else if(currentOpStart >= start && currentOpEnd <= end) {
                    result.ops.push(op);
                } else if(currentOpStart >= start && currentOpStart < end && end < currentOpEnd) {
                    if(op.constructor.name !== 'Retain') {
                        throw 'Retain operation expected when extracting the changes local to a section';
                    }

                    result.retain(op.input - (currentOpEnd-end));

                } else if(currentOpStart > end) {
                   break;
                }

                processed += op.input;
            }

            return result.end();
        }

        var localChangeset = slice(changeset, lengthOfUnchangedSection, lengthOfUnchangedSection+oldContent.length);
        localChangeset.addendum = changeset.addendum;
        localChangeset.removendum = changeset.removendum;

        var newContent = localChangeset.apply(oldContent);

        this.setContent(newContent, {
            ...attr,
            startSection: updateStartSection,
            endSection: updateEndSection
        });
    },

    setContent: function(content, args) {
        args = args || {};

        var insertedContent = args.inputEvent && args.inputEvent.data,
            modificationLogEntry,
            currentCaretPosition,
            beforeStateCaretPosition,
            scrollPosition = this.saveScrollPosition(args.section);

        if(this.caret.isWithinElement(this.contentElement) && args.positionCaretAtTheEndOfSectionWithIndex === undefined) {
            currentCaretPosition = this.caret.saveSelection(this.contentElement, insertedContent),
            beforeStateCaretPosition = this.caretPositions[this.caretPositions.length-1];
        }

        args.modificationLogEntry = args.modificationLogEntry || new ModificationLogEntry();
        args.modificationLogEntry.modLogFlags = this.modLogFlags;

        args.modificationLogEntry.actor = args.actor

        this.caretPositions.push(args.caretPosition || currentCaretPosition);

        modificationLogEntry = this.documentupdater.updateHTML(content, this.focusedSection(), { ...args, caret: this.caret });

        if(modificationLogEntry.focusedSectionHasBeenModified && args.positionCaretAtTheEndOfSectionWithIndex === undefined) {
            if(modificationLogEntry.changeSectionType) {
                args.action = 'changeFocusedSectionType';
            }

            if(!args.caretPosition) {
                if(!modificationLogEntry.focusedSectionDOMWasNotModified || !(currentCaretPosition &&  currentCaretPosition.selectionIsCollapsed)) {

                    if(modificationLogEntry.insertedBeforeSelectionRangeStart) {
                        this.caret.rangeStart += modificationLogEntry.insertedBeforeSelectionRangeStart;
                    }

                    if(modificationLogEntry.insertedBeforeSelectionRangeEnd) {
                        this.caret.rangeEnd += modificationLogEntry.insertedBeforeSelectionRangeEnd;
                    }

                    this.caret.restoreSelection(modificationLogEntry.deletedCharsByMarkupTransformations, 'TryDOMStrategyFirst');
                }

                if(modificationLogEntry.focusedSectionReplacement) {
                    this.focusSection(modificationLogEntry.focusedSectionReplacement, args);
                }
            }
        } else if(args.positionCaretAtTheEndOfSectionWithIndex !== undefined) {
            this.caret.positionAtTheBeginningOf(this.sectionAt(args.positionCaretAtTheEndOfSectionWithIndex));
        }

        if(args.caretPosition) {
            this.caret.restoreSelectionViaOffsetStrategy(0, args.caretPosition);
        }

        this.restoreScrollPostion(modificationLogEntry.focusedSectionReplacement, scrollPosition);

        this.updateFootnotesNumbering();
        this.updateReferenceNumbering();
        this.updateInlineEquationNumbering(modificationLogEntry);

        modificationLogEntry.beforeStateCaretPosition = beforeStateCaretPosition;
        modificationLogEntry.afterStateCaretPosition = args.caretPosition || currentCaretPosition;
        modificationLogEntry.tags = args.modificationLogTags;

        modificationLogEntry.wordCount = this.getWordCount();

        this.showInputTooltipIfContentIsEmpty();

        this.focusSection(this.sectionAtCaretPostion(), args);
        this._removeEmptySectionsExceptOfFocusedSection(modificationLogEntry);
        this.notifySubscribers(modificationLogEntry);

        return modificationLogEntry;
    },

    showInputTooltipIfContentIsEmpty: function() {
        if(this._initDone && this.contentElement.children.length === 1 && this.contentElement.innerText.trim() === '' && this.contentElement.children[0].tagName === 'P') {
            this.containerElement.insertBefore(this.hintEl, this.contentElement);
        } else {
            this.hintEl.remove();
        }
    },

    getWordCount: function() {
        var result = 0;

        for(let i=0; i<this.contentElement.children.length; i++) {
            result += this.contentElement.children[i].wordCount;
        }

        return result;
    },

    saveScrollPosition: function(section) {
        var nestedCodeEl,
            isDiaSection = section && section.classList && section.classList.contains('m2dia'),
            isCodeSection = section && section.tagName === 'PRE';

        if(isDiaSection || isCodeSection) {
            nestedCodeEl = section.querySelector('code');

            return {
                x: window.scrollX,
                y: window.scrollY,
                codeScrollX: nestedCodeEl && nestedCodeEl.scrollLeft
            }
        }
    },

    restoreScrollPostion: function(section, scrollPosition) {
        var nestedCodeEl;
        if(scrollPosition) {
            window.scrollTo(scrollPosition.x, scrollPosition.y);
            if(scrollPosition.codeScrollX && section) {
                nestedCodeEl = section.querySelector('code')
                nestedCodeEl.scrollTo(scrollPosition.codeScrollX, nestedCodeEl.scrollY)
            }
        }
    },

    updateFootnotesNumbering: function() {
        var allFootnotes = this.contentElement.querySelectorAll('.footnote');
        for(var i=0; i<allFootnotes.length; i++) {
            if(allFootnotes[i].innerText !== (i+1).toString()) {
                allFootnotes[i].innerText = (i+1);
            }
        }
    },

    updateReferenceNumbering: function() {
        var refs = this.contentElement.querySelectorAll('.reference');

        for(var i=0; i<refs.length; i++) {
            this.reference.updateRefElement(refs[i]);
        }
    },

    updateInlineEquationNumbering: function(modificationLogEntry) {
        var eqs = this.contentElement.querySelectorAll('inlineequation'),
            latex, self = this;

        for(var i=0; i<eqs.length; i++) {
            let eq = eqs[i]
            eq.innerHTML = '';
            latex = utils.attributeSaveStringToString(eq.dataset.latexequation)

            eq.onclick = eq.onclick || function(e) {
                self.caret.positionAfter(utils.getFirstParentWithTagName(e.target));
            }

            try {
                katex.render(latex, eq, {
                    throwOnError: true,
                    displayMode: false
                });
            } catch (ex) {
                eq.innerHTML = '<span class="error">invalid LaTeX equation</span>';
            }
        }
    },

    shouldSectionBeRemovedIfUnfocused: function(section) {
        return section.innerText.trim() === '' &&
               !section.classList.find(c => c.startsWith('focused-by-api-actor')) &&
               !(this.htmlRazor.getRuleByElement(section).deleteIfEmpty === false);
    },

    deleteNonCollapsedSelectionContent: function(sel) {
        sel = sel || window.getSelection();

        if(!sel) return;

        var s1 = this.sectionByChildNode(sel.anchorNode),
            s2 = this.sectionByChildNode(sel.focusNode),
            i1 = this.indexOf(s1),
            i2 = this.indexOf(s2),
            tmp, newElement;

        if(i1 === undefined || i2 === undefined) return;

        if(i1 > i2) {
            tmp = s1; s1 = s2; s2 = tmp;
        }

        // We have to keep the sections in between the selection in order
        // to caclulate the modificationLogEntry. They will be removed by
        // the setContent function which also calculates the LogEntry.
        this._deleteSelectedTextButKeepAllSelectedSections(s1, s2, sel);

        newElement = s1.cloneNode(false);
        newElement.innerHTML = s1.innerHTML + s2.innerHTML;

        this.setContent(newElement.outerHTML, {startSection: s1, endSection: s2});

        if(!this.sectionAtCaretPostion()) {
            this.placeCaretIntoSection(this.contentElement.lastChild);
        }

        this.setContentEditable(true);
    },

    setFilePersistHandler: function(handler) {
        Object.values(this.supportedSectionTypes)
            .filter(section => section.persistFile)
            .forEach(section => {
                section.persistFile = handler;
        })
    },

    addReferenceData: function(data) {
        this.reference.addReferenceData(data);
        this.updateReferenceNumbering();

        if(this.contentElement.children[0]) {
            this.modificationLogEntry = new ModificationLogEntry();
            this.modificationLogEntry.retainSection(this.contentElement.children[0]);
            this.modificationLogEntry.retainAllSectionsAfter(this.contentElement.children[0]);
            this.modificationLogEntry.mightIncludeReferenceUpdates = true;
            this.notifySubscribers(this.modificationLogEntry);
        }
    },

    _removeEmptySectionsExceptOfFocusedSection: function(finalizedModificationLogEntry) {
        var sections = this.contentElement.children,
            toBeDeleted = [], indexCorrection = 0, oldModLog, deletedSection;

        if(sections.length === 1) return;

        for(let i=0; i<sections.length; i++) {
            if(this.shouldSectionBeRemovedIfUnfocused(sections[i]) &&
               sections[i] !== this.focusedSection()) {
                 toBeDeleted.push({section: sections[i], index: i});
            }
        }

        for(let i=0; i<toBeDeleted.length; i++) {
            deletedSection = this.contentElement.removeChild(toBeDeleted[i].section);
            oldModLog = finalizedModificationLogEntry.deleteSectionAt(toBeDeleted[i+indexCorrection].index, deletedSection);
            if(oldModLog.type === 'insert') {
                indexCorrection--;
            }
        }

        this.sectionTypeSelector.displayNextTo(this.focusedSection());
    },

    // Example: the pipes ("|") show where the selection starts/ends
    // content before execution: <p>section |one</p><p>section two</p><p>section three</p><p>section |four</p>
    // content after execution: <p>section ||</p><p></p><p></p><p>four</p>
    _deleteSelectedTextButKeepAllSelectedSections: function(s1, s2, sel) {
        var inBetweenSections = [],
            i1 = this.indexOf(s1),
            i2 = this.indexOf(s2),
            cec = this.contentElement.children,
            tmp, i, range, selection, lastInsertedDummySection, clonedRange;

        if(i1 > i2) {
            tmp = s1; s1 = s2; s2 = tmp;
            tmp = i1; i1 = i2; i2 = tmp;
        }

        s1.summarizedContentLength = undefined;
        s2.summarizedContentLength = undefined;

        for(i=i1+1 ; i<i2; i++) {
            tmp = cec[i].cloneNode(false);
            tmp.originalHTML = cec[i].originalHTML;
            tmp.summarizedContentLength = undefined;

            Object.keys(this.modLogFlags).forEach(function(flag) {
                tmp['originalHTMLContains' + flag] = cec[i]['originalHTMLContains' + flag];
            });

            inBetweenSections.push(tmp);
        }

        range = sel.getRangeAt(0);
        clonedRange = range.cloneRange();
        range.deleteContents();
        // clonedRange.collapse; ?? why not clonedRange.collapse()
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(clonedRange);

        lastInsertedDummySection = s2;
        while(inBetweenSections.length > 0) {
            tmp = inBetweenSections.pop();
            this.contentElement.insertBefore(tmp, lastInsertedDummySection);
            lastInsertedDummySection = tmp;
        }
    },

    _cleanupHTMLFromEditorSpecificMarkupForSectionHTML: function(HTML) {
        return HTML.replace(/^<([a-zA-Z0-9\-]+?)\s(.*?)>/, (match, tagName, attributes) => {
            attributes = attributes
                .match(/([a-zA-Z0-9\-]+=".*?")|[a-zA-Z0-9\-]*/g)
                .map(x => x.trim())
                .filter(x => x !== '')
                .map(attr => {
                    attr = attr.split('=')

                    if(attr[1]) {
                        attr[1] = attr[1].replace(/^("|')/g, '').replace(/("|')$/g, '')
                    }

                    if(attr[0] === 'class') {
                        attr[1] = attr[1]
                            .split(' ')
                            .map(c => c.trim())
                            .filter(c => c !== 'focused' && !c.startsWith('focused-by-api-actor'))
                            .join(' ')
                    }

                    if(attr[1]) {
                        attr[1] = `"${attr[1].trim()}"`
                    }

                    return attr.join('=')
                })
                .filter(attr => !attr.match(/contenteditable="true"/))
                .filter(attr => attr !== 'class=')
                .join(' ')


            return attributes !== '' ?
                `<${tagName} ${attributes}>` :
                `<${tagName}>`
        }).replaceAll('&nbsp;', ' ');
    },

    _cleanupModificationLogFromEditorSpecificMarkup: function(modificationLogEntry) {
        modificationLogEntry.log.forEach(log => {
            if(log.oldSectionHTML) {
                log.oldSectionHTML = this._cleanupHTMLFromEditorSpecificMarkupForSectionHTML(log.oldSectionHTML);
            }
            if(log.newSectionHTML) {
                log.newSectionHTML = this._cleanupHTMLFromEditorSpecificMarkupForSectionHTML(log.newSectionHTML);
            }
            if(log.sectionHTML) {
                log.sectionHTML = this._cleanupHTMLFromEditorSpecificMarkupForSectionHTML(log.sectionHTML);
            }
        });
    }
}

module.exports = Editor;


/***/ }),

/***/ "../structured-text-editor/src/key_press_handler.js":
/*!**********************************************************!*\
  !*** ../structured-text-editor/src/key_press_handler.js ***!
  \**********************************************************/
/***/ ((module) => {

function KeyPressHandler(editor) {
    var self = this;
    this.editor = editor;

    document.addEventListener("paste", function (e) {
        var pasteData;
        editor.caret.ensureExpandedSelectionIsWithinElement(editor.contentElement);

        if(self.editor.areMultipleSectionsSelected()) {
            self.editor.deleteNonCollapsedSelectionContent();
        }

        if((editor.caret.getContextElement('code') && editor.caret.getContextElement('pre'))
           || editor.caret.getContextElement('caption')
           || editor.caret.getContextElement('citesrc'))
            {
            pasteData = e.clipboardData.getData('text/plain').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            e.preventDefault();
            document.execCommand('inserthtml', false, pasteData);
        }
    });

    document.addEventListener("keydown", function (e) {
        var section, handleEnterKey;

        if(!e.metaKey && !e.ctrlKey) {
            if(e.key === ' ')              { !editor.isContentEditable() && e.preventDefault(); }

            if(e.key === 'Backspace') {
                section = editor.sectionByChildNode(e.target);
                editor.caret.ensureExpandedSelectionIsWithinElement(editor.contentElement);
                if(section && section.onKeyBackspace) {
                    section.onKeyBackspace(e, editor);
                } else {
                    self.handleBackspace(e);
                }
            }

            if(e.key === 'ArrowUp') {
                section = editor.sectionByChildNode(e.target);
                if(section && section.onKeyUp) {
                    section.onKeyUp(e, editor);
                } else {
                    editor.moveCaretOneSectionUp();
                    e.preventDefault();
                }
            }

            if(e.key === 'ArrowDown') {
                section = editor.sectionByChildNode(e.target);
                if(section && section.onKeyDown) {
                    section.onKeyDown(e, editor);
                } else {
                    editor.moveCaretOneSectionDown();
                    e.preventDefault();
                }
            }

            if(e.key === 'Enter') {
                section = editor.sectionByChildNode(e.target);
                handleEnterKey = function() {
                    if(e.shiftKey) {
                        self.handleShiftEnter(e);
                    } else if(section && section.onKeyEnter) {
                        section.onKeyEnter(e, editor);
                    } else if(section) {
                        editor.caret.insertLineBreak();
                        e.preventDefault();
                    }
                }

                if(e.isComposing) {
                    // e.target.dispatchEvent(new CompositionEvent('compositionend'));
                    // window.setTimeout(function() { handleEnterKey() }, 100);
                } else {
                    handleEnterKey();
                }
            }

            if(e.key === 'Tab') {
                section = editor.sectionByChildNode(e.target);
                if(section && section.onKeyTab) {
                    section.onKeyTab(e, editor);
                } else if(section && section.nextSibling && !e.shiftKey) {
                    editor.placeCaretIntoSection(section.nextSibling)
                    e.preventDefault();
                } else if(section && section.previousSibling && e.shiftKey) {
                    editor.placeCaretIntoSection(section.previousSibling)
                    e.preventDefault();
                }
            }

            if(e.key === ' ' && !(e.isComposing || e.keyCode === 229)) {
                section = editor.sectionByChildNode(e.target);
                if(section && !self.editor.caret.isPrecedingCharacterWhitespace(section)) {
                    document.execCommand('insertText', false, self.editor.htmlRazor.temproaryPruneProtectedWhitespace);
                    e.preventDefault();
                }
            }

            //do not handle the keys below if CMD or Control
            //is not pressed at the same time
            return;
        }

        if(e.key === 'Enter')             { self.handleShiftEnter(e); }
        else if(e.key === 'ArrowUp')      { editor.moveFocusedSectionUp(); e.preventDefault(); }
        else if(e.key === 'ArrowDown')    { editor.moveFocusedSectionDown(); e.preventDefault(); }
        else if(e.key === 'i')            { editor.textEnrichmentControl.show(true); e.preventDefault(); }
        else if(e.key === 'a')            { self.handleCmdA(e); }
        else if(e.key === 'z')            { editor.undo(); e.preventDefault(); }
        else if(e.key === 'y')            { editor.redo(); e.preventDefault(); }
        else {
            section = editor.sectionByChildNode(e.target);
            if(section && section.onKeyCombination) {
                section.onKeyCombination(e, editor);
            }
        }

        return true;
    });
}

KeyPressHandler.prototype = {

    handleShiftEnter: function(event) {
        var section = this.editor.sectionByChildNode(event.target);
        this.editor.addNewSectionNextTo(section);
        event.preventDefault();
    },

    handleBackspace: function(event) {
        var sel = window.getSelection(), s1, s2;

        if(!sel) return; //no caret positioned, no deletion required

        if(this.editor.caret.isCollapsedAndPositionedAtTheBeginningOf(this.editor.focusedSection())) {
            s2 = this.editor.sectionByChildNode(sel.anchorNode);
            s1 = s2.previousSibling;
            this.editor.mergeSections(s1, s2);
            event.preventDefault();
        }

        if(this.editor.areMultipleSectionsSelected()) {
            this.editor.deleteNonCollapsedSelectionContent(sel);
            event.preventDefault();
        }

        // for some reason there is a edge case in which the backspace doesn't
        // trigger a selection change and so the controlls will not been hidden
        // by the handler inteded to do this.
        this.editor.textEnrichmentControl.hide();
    },

    handleCmdA: function(event) {
        var elTag = event.target && event.target.tagName;
        var nativeEventHandlingTag = ['TEXTAREA', 'INPUT']

        if(!nativeEventHandlingTag.includes(elTag)) {
            this.editor.selectEverything();
            event.preventDefault();
        }
    }
}

module.exports = KeyPressHandler;


/***/ }),

/***/ "../structured-text-editor/src/references/reference_controller.js":
/*!************************************************************************!*\
  !*** ../structured-text-editor/src/references/reference_controller.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uuid = __webpack_require__(/*! uuid/v1 */ "../structured-text-editor/node_modules/uuid/v1.js");
var lookupRefs = __webpack_require__(/*! ../../lib/lookup_refs */ "../structured-text-editor/lib/lookup_refs/index.js");
var lookupURL = __webpack_require__(/*! ../../lib/lookup_refs/lookup_by_url */ "../structured-text-editor/lib/lookup_refs/lookup_by_url.js");
var throttle = __webpack_require__(/*! ../../lib/throttle/throttle */ "../structured-text-editor/lib/throttle/throttle.js");

var Reference = function(store, editor) {
    this.store = store;
    this.editor = editor;
}

Reference.prototype = {

    addReferenceData: function(data) {
        this.store.addReferenceData(data);
    },

    storeExternalRefData: function(id, attr) {
        this.store.set(id, attr);
        this.editor.referenceInsertedSubscribers.forEach((cb) => {
            cb(id, attr);
        })
    },

    getExternalRefData: function(id) {
        return this.store.get(id);
    },

    getAllExternalRefs: function() {
        return this.store.all(true);
    },

    updateRefElement: function(ref) {
        if(ref.getAttribute('data-external') !== 'true') {
            this.updateInternalRefElement(ref);
        } else {
            this.updateExternalRefElement(ref);
        }
    },

    // Argument: A DOM Element which is a clild element of the editor's content
    // element. The element should have the "data-ref" attribute representing the id
    // of an external reference (external references are books, papers).
    // The function will update the innerHTML of the passed reference element.
    updateExternalRefElement: function(ref) {
        var self = this, tmpContent, refkey, referencee = this.getExternalRefData(ref.getAttribute('data-ref'));

        if(!referencee) {
            ref.classList.add('warning');
            ref.innerHTML = '[<i>not found</i>]';
            return;
        }

        refkey = referencee.author.split(' ').reduce(function(a, e) {return a + (e[0] || '')}, '');
        refkey += '-';
        refkey += referencee.title.split(' ').reduce(function(a, e) {return a + (e[0] || '')}, '');
        refkey += '-';
        refkey += referencee.year;

        tmpContent = '[<i>' + refkey + '</i>]';

        ref.onclick = function() {self.showEditExternalRefDialog(this)};

        if(referencee.author.trim() === '' ||
           referencee.title.trim() === '') {
            ref.classList.add('warning');
        }

        if(ref.innerHTML !== tmpContent) {
            ref.innerHTML = tmpContent;
        }
    },

    // According to updateExternalRefElement but for internal refs, like tables,
    // figures, sections
    updateInternalRefElement: function(ref) {
        var referencee = document.getElementById(ref.getAttribute('data-ref')),
            tmpContent, indexPrefix = '', allSelector;

        if(referencee) {
            allSelector = referencee.tagName;

            if(referencee.tagName === 'FIGURE' || referencee.tagName === 'MERMAID') {
                allSelector = 'FIGURE, MERMAID';
            }

            if(referencee.tagName == 'PRE') {
                allSelector = 'pre.code';
            }

            referenceeIndex = this.editor.contentElement.querySelectorAll(allSelector).indexOf(referencee);

            if(referencee.tagName === 'FIGURE') {
                indexPrefix = 'fig-' + (referenceeIndex+1);
            } else if(referencee.tagName === 'TABLE') {
                indexPrefix = 'table-' + (referenceeIndex+1);
            } else if(referencee.tagName === 'PRE') {
                indexPrefix = 'listing-' + (referenceeIndex+1);
            } else if(referencee.classList.contains('formula')) {
                indexPrefix = 'eq-' + (referenceeIndex+1);
            } else if(referencee.classList.contains('mermaid')) {
                indexPrefix = 'fig-' + (referenceeIndex+1);
            }
            else if(referencee.tagName === 'H2' || referencee.tagName === 'H3' || referencee.tagName === 'H4' || referencee.tagName === 'H5') {
                indexPrefix = 'section: ' + referencee.innerHTML;
            }

            tmpContent = '[<i><a href="#' + referencee.id + '">' + indexPrefix + '</a></i>]';

            if(ref.innerHTML !== tmpContent) {
                ref.innerHTML = tmpContent;
            }

            ref.classList.remove('warning');
        } else {
            ref.innerHTML = '[ref not found]';
            ref.classList.add('warning');
        }
    },

    getRefCaptionHTML: function(referenceEl) {
        var refId = referenceEl.getAttribute('data-ref');
        if(referenceEl.getAttribute('data-external') === 'true') {
            return this.getExternalRefCaptionHTML(refId);
        } else {
            return this.getInternalRefCaptionHTML(document.getElementById(refId));
        }
    },

    getValuesForCrossReferenceSelectBox: function() {
        var result = [],
            internals = this.editor.contentElement.querySelectorAll('figure, table, h2, h3, h4, h5, pre.code, .formula, .mermaid');

        internals = internals.filter(function(int) {
            if(int.tagName === 'FIGURE' && !int.querySelector('figcaption')) {
                return false;
            }

            if(int.tagName === 'TABLE' && !int.querySelector('caption')) {
                return false;
            }

            if(int.tagName === 'PRE' && !int.querySelector('caption')) {
                return false;
            }

            if(int.classList.contains('formula') && !int.querySelector('caption')) {
                return false;
            }

            if(int.classList.contains('mermaid') && !int.querySelector('caption')) {
                return false;
            }

            return true;
        });

        for(var i=0; i<internals.length; i++) {
            result.push([internals[i].id, this.getInternalRefCaptionHTML(internals[i])]);
        }

        return result;
    },

    getValuesForExistingReferenceSelectBox: async function() {
        var result = [],
            allRefs = await this.store.allAsync(true),
            externals = Object.keys(allRefs);

        for(var j=0; j<externals.length; j++) {
            result.push([externals[j], this.getExternalRefCaptionHTML(externals[j], allRefs)]);
        }

        return result;
    },

    areExistingReferencesAvailable: function() {
        var allRefs = this.getAllExternalRefs();

        return allRefs && Object.keys(allRefs).length;
    },

    // returns the caption to display in the reference select box.
    getInternalRefCaptionHTML: function(refereeEl) {
        if(!refereeEl) {
            return '[ref not found]';
        }

        var tmpCaption,
            allSelector = refereeEl.tagName;

        if(refereeEl.tagName === 'FIGURE' || refereeEl.tagName ===  'MERMAID') {
            allSelector = 'FIGURE, MERMAID';
        }

        if(refereeEl.tagName === 'PRE') {
            allSelector = 'pre.code';
        }

        referenceeIndex = this.editor.contentElement.querySelectorAll(allSelector).indexOf(refereeEl);

        if(refereeEl.tagName === 'FIGURE') {
            tmpCaption = refereeEl.querySelector('figcaption').innerHTML;
            return '<b>Image</b> ' + (referenceeIndex+1) + ': ' + tmpCaption;
        } else if(refereeEl.tagName === 'TABLE') {
            tmpCaption = refereeEl.querySelector('caption').innerHTML;
            return '<b>Table</b> ' + (referenceeIndex+1) + ': ' + tmpCaption;
        } else if(refereeEl.tagName === 'H2' || refereeEl.tagName === 'H3' || refereeEl.tagName === 'H4' || refereeEl.tagName === 'H5') {
            return '<b>Section</b>: ' + refereeEl.innerHTML;
        } else if(refereeEl.tagName === 'PRE') {
            tmpCaption = refereeEl.querySelector('caption').innerHTML;
            return '<b>Listing</b> ' + (referenceeIndex+1) + ': ' + tmpCaption;
        } else if(refereeEl.classList.contains('formula')) {
            tmpCaption = refereeEl.querySelector('caption').innerHTML;
            return '<b>Equation</b> ' + (referenceeIndex+1) + ': ' + tmpCaption;
        } else if(refereeEl.classList.contains('mermaid')) {
            tmpCaption = refereeEl.querySelector('caption').innerHTML;
            return '<b>Image</b> ' + (referenceeIndex+1) + ': ' + tmpCaption;
        }
    },

    // returns the caption to display in the reference select box.
    getExternalRefCaptionHTML: function(refereeId, allRefs) {
        var ref = (allRefs || this.getAllExternalRefs())[refereeId];
        if(!ref) { return '' }
        return [ref.author, ref.title, (ref.publisher || ref.journal), ref.year].filter(function (f) { return f !== '' && f }).join(' - ');
    },

    insertInternalReference: function(formData) {
        var node = document.createElement('span');
        node.classList.add('reference');
        node.setAttribute('data-ref', formData.ref);

        if(this.getExternalRefData(formData.ref)) {
            node.setAttribute('data-external', 'true');
        }

        node.setAttribute('contenteditable', false);
        this.editor.caret.insertNode(node);
    },

    insertExternalReference: function(formData) {
        var node = document.createElement('span'),
            refId = uuid(),
            self = this;

        node.classList.add('reference');
        node.setAttribute('contenteditable', false);
        node.setAttribute('data-external', 'true');
        node.setAttribute('data-ref', refId);
        node.onclick = function() {self.showEditExternalRefDialog(this)};
        this.storeExternalRefData(refId, formData);
        this.editor.caret.insertNode(node);
    },

    showEditExternalRefDialog: function(refNode) {
        var refId = refNode.getAttribute('data-ref'),
            ref = this.getExternalRefData(refId),
            self = this;

        if(!ref) { return }

        self.editor.unfocusSection();

        self.editor.displayModal(self.getExternalRefDialogAttributes(ref, refId), function(formData) {
            var section = self.editor.sectionByChildNode(refNode);
            if(section) {
                section.forceUpdateOnInputProcesssingEnablement = true;
            }

            self.storeExternalRefData(refId, formData);
            self.editor.unfreezeSelection();
            self.editor.textEnrichmentControl.hide();

            self.editor.reference.updateRefElement(refNode);
            self.editor.unfocusSection();
            self.editor.caret.clearSelection();
            window.setTimeout(function() {
                self.editor.sectionTypeSelector.hide();
            }, 50)
        });
    },

    getExternalRefDialogAttributes: function(dataRecord, refId) {
        dataRecord = dataRecord || {};

        var self = this;

        var referenceTypes = {
            'Article': {
                required: ['author', 'title', 'journal', 'year'],
                optional: ['volume', 'number', 'pages', 'month', 'subtitle']
            },
            'Book': {
                required: ['author', 'title', 'publisher', 'year'],
                optional: ['editor', 'volume', 'number', 'series', 'edition', 'month', 'subtitle']
            },
            'Conference/Inproceedings': {
                required: ['author', 'title', 'booktitle', 'year'],
                optional: ['editor', 'volume', 'number', 'series', 'pages', 'month', 'organization']
            },
            'Inbook': {
                required: ['title', 'publisher', 'year'],
                optional: ['author', 'editor', 'chapter', 'pages', 'subtitle']
            },
            'Manual': {
                required: ['title'],
                optional: ['author', 'organization', 'edition', 'month', 'year', 'subtitle']
            },
            'Mastersthesis': {
                required: ['author', 'title', 'school', 'year'],
                optional: ['month', 'subtitle']
            },
            'Phdthesis': {
                required: ['author', 'title', 'school', 'year'],
                optional: ['month', 'subtitle']
            },
            'Proceedings': {
                required: ['title', 'year'],
                optional: ['editor', 'volume', 'number', 'series', 'month', 'organization', 'subtitle']
            },
            'Techreport': {
                required: ['author', 'title', 'institution', 'year'],
                optional: ['type', 'number', 'month', 'subtitle']
            },
            'Website': {
                required: ['url'],
                optional: ['author', 'date', 'month', 'year', 'title']
            }
        }

        var allowedTypeValues = Object.keys(referenceTypes)
            .map(rt => [
                rt,
                rt,
                'Type: ' + rt
            ])

        var handleUrlFieldChange = async function (formData, dFrom, triggerElement, allExistingRefs, url) {

            var url = url || formData.url;
            var fields = ['url', 'author', 'title', 'year', 'month']

            if(lookupURL.isValidID(url)) {
                fields.forEach(field => dFrom.setTooltip(field, 'Wait for it ...', '', 'tooltip-loading'))

                try {
                    var urlMeta = await lookupURL.fetchJSON(url);

                    Object.keys(urlMeta).forEach(key => {
                        let field = dFrom.fields.find(f => f.name == key);
                        if(field && field.domElement && field.domElement.setValue && formData[field.name] !== urlMeta[key]) {
                            field.domElement.setValue(urlMeta[key]);
                        }
                    })
                } finally {
                    fields.forEach(field => dFrom.resetTooltip(field));
                    dFrom.resetTooltip('lookupId');
                }
            }
        }

        var handleLookupIdFieldChange = function(formData, dFrom, triggerElement, allExistingRefs) {
            dFrom.setTooltip('lookupId', 'Wait for it ...', '', 'tooltip-loading')

            const similarRef = allExistingRefs.find(ref => (ref.lookupId && ref.lookupId.trim().toLowerCase() === formData.lookupId.trim().toLowerCase()))

            if(formData.lookupId
                && similarRef
                && (!refId || refId !== similarRef.id)) {
                dFrom.setTooltipError('lookupId', 'You already referenced this document before. You can find it in the "Find Reference" tab of this dialog.');
                return;
            }

            var errorText = 'Something went wrong. Maybe the provided DOI / ISBN / Website URL / arXiv ID does not exists?';

            lookupRefs.fetchJSON(formData.lookupId)
                .catch(err => {
                    console.log('error when fetching ref data', err)
                    if(err instanceof lookupRefs.errors.InvalidID) {
                        dFrom.setTooltipWarning('lookupId', 'It needs to be a valid DOI or ISBN');
                    } else if(err instanceof lookupRefs.errors.EmptyID) {
                        dFrom.resetTooltip('lookupId');
                    } else if(err instanceof lookupRefs.errors.NotFound) {
                        dFrom.setTooltipError('lookupId', 'No data found for the given DOI / ISBN');
                    } else {
                        dFrom.setTooltipError('lookupId', errorText);
                    }
                })
                .then(data => {
                    if(data) {
                        dFrom.setTooltip('lookupId', 'MonsterWriter filled out all the information it could find. You can still complete or change the data below.', '&#10003;', 'tooltip-success');

                        Object.keys(data)
                            .map(fieldName => dFrom.fields.find(f => f.name == fieldName))
                            .filter(field => field && field.domElement && field.domElement.setValue)
                            .forEach(field => {
                                if(formData[field.name] !== data[field.name]) {
                                    field.domElement.setValue(data[field.name]);
                                }
                            })
                    }
                }).catch(ex => {
                    dFrom.setTooltipError('lookupId', errorText);
                })
        }

        var handleTitleFieldChange = function (formData, dFrom, triggerElement, allExistingRefs) {
            const similarRef = allExistingRefs.find(ref => (ref.title && ref.title.trim().toLowerCase() === formData.title.trim().toLowerCase()))

            if(formData.title
                && similarRef
                && (!refId || refId !== similarRef.id)) {
                dFrom.setTooltipWarning('title', 'You already referenced a document with the same title. Consider to choose it in the "Find Reference" tab of this dialog.');
                return;
            } else {
                dFrom.resetTooltip('title');
            }
        }

        var onFormChange = throttle(100, function (formData, dFrom, triggerElement) {
            if(!triggerElement) {
                return;
            }

            var allExistingRefs = Object.values(self.getAllExternalRefs());

            if(triggerElement.name === 'lookupId') {
                handleLookupIdFieldChange(formData, dFrom, triggerElement, allExistingRefs);
            } else if(triggerElement.name === 'title') {
                handleTitleFieldChange(formData, dFrom, triggerElement, allExistingRefs);
            } else if(triggerElement.name === 'url') {
                handleUrlFieldChange(formData, dFrom, triggerElement, allExistingRefs);
            }
        });

        return [
            {name: 'lookupId', displayName: 'Automatically Fetch and Fill Out Information By:', tooltip: { text: 'Insert a valid DOI, ISBN, arXiv ID or the URL of a website you want to cite. MonsterWriter will try to find all the information on the internet for you.', inInput: true }, autocomplete: 'off', placeholder: 'ISBN / DOI / arXiv ID / Website URL', onFormChange: onFormChange },
            {name: 'type', displayName: 'Manually Specify Information:', defaultValue: 'Article', allowedValues: allowedTypeValues },
            {name: 'url', placeholder: 'Website URL', tooltip: 'The address of the website.'},
            {name: 'date', placeholder: 'Lookup Date', tooltip: 'The date when you accessed the website. This is usally todays date.', defaultValue: () => (new Date()).getFullYear() + '-' + ((new Date()).getMonth() + 1).toString().padStart(2, '0') + '-' + ((new Date()).getDate()).toString().padStart(2, '0') },
            {name: 'author', placeholder: 'Author(s)', tooltip: 'All authors separated by the word "and". Comma is used to distinguish first and last name. e.g "Wolf, Oliver and Barnett, Phillip".'},
            {name: 'title', placeholder: 'Title', tooltip: 'The title of the reference.'},
            {name: 'subtitle', placeholder: 'Subtitle', tooltip: 'The sub title of the reference.'},
            {name: 'booktitle', placeholder: 'Book Title', tooltip: 'The title of the book.'},
            {name: 'organization', placeholder: 'Organization', tooltip: 'The organization that organizes the conference or publishes the work.'},
            {name: 'journal', placeholder: 'Journal', tooltip: 'The journal that published the article.'},
            {name: 'publisher', placeholder: 'Publisher', tooltip: 'The publisher of the work.'},
            {name: 'school', placeholder: 'School', tooltip: 'The institution in which the author is enrolled.'},
            {name: 'institution', placeholder: 'Institution', tooltip: 'The institution that sponsors the research work.'},
            {name: 'editor', placeholder: 'Editor(s)', tooltip: 'All editors separated by the word "and". Comma is used to distinguish first and last name. e.g "Wolf, Oliver and Barnett, Phillip'},
            {name: 'series', placeholder: 'Series', tooltip: 'The series name of the book/work'},
            {name: 'year', placeholder: 'Year', tooltip: 'The year of the publication consisting of four digits (e.g. "2020").'},
            {name: 'month', placeholder: 'Month', tooltip: 'The month of the publication. Use the three letter abbreviation: Jan. Feb. Mar. Apr. May. Jun. Jul. Aug. Sep. Oct. Nov. Dec.'},
            {name: 'edition', placeholder: 'Edition', tooltip: 'The edition of the publication (e.g. "Second"). The first letter should be capitalized.'},
            {name: 'volume', placeholder: 'Volume', tooltip: 'The volume of the publication.'},
            {name: 'number', placeholder: 'Number', tooltip: 'The work\'s number within a series.'},
            {name: 'chapter', placeholder: 'Chapter', tooltip: 'A chapter if you reference to a particular part of the work.'},
            {name: 'pages', placeholder: 'Pages', tooltip: 'The page number(s) if you reference to a particular part of the work (e.g. "23-50" or "417,423,590-601" or 50+).'},
        ].map(field =>
            Object.assign(field, {
                defaultValue: (dataRecord[field.name] || field.defaultValue || ''),
                isActive: function(formData) {
                    if(field.name === 'type' || field.name === 'lookupId') {
                        return true;
                    }

                    if(!referenceTypes[formData.type]) {
                        return false;
                    }

                    if(referenceTypes[formData.type].required.includes(field.name)) {
                        return true;
                    }

                    if(referenceTypes[formData.type].optional.includes(field.name)) {
                        return true
                    }
                }
            })
        )
    },
}

module.exports = Reference;


/***/ }),

/***/ "../structured-text-editor/src/references/reference_sources/index.js":
/*!***************************************************************************!*\
  !*** ../structured-text-editor/src/references/reference_sources/index.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const referenceSourcesConfig = [
    { id, displayName, isValidRecord, renderEntry, fields, sync } = __webpack_require__(/*! ./zotero_online */ "../structured-text-editor/src/references/reference_sources/zotero_online.js"),
    { id, displayName, isValidRecord, renderEntry, fields, sync } = __webpack_require__(/*! ./zotero_desktop */ "../structured-text-editor/src/references/reference_sources/zotero_desktop.js")
]

async function saveReferenceSources(formData, ReferenceStore) {
    await ReferenceStore.deleteAllSources()
    await Promise.all(formData['reference-sources'].map(async rs => {
        await ReferenceStore.addSource(rs)
    }))

    await ReferenceStore.cleanupReferencesFromSources()
}

const syncAllSources = async function(ReferenceStore) {
    const referenceSources = await ReferenceStore.getAllSources()

    referenceSources.forEach(rcFormData => {
        const rsc = referenceSourcesConfig.find(rs => rs.id === rcFormData.type)

        if(rsc && rsc.sync) {
            rsc.sync(rcFormData, ReferenceStore)
        } else {
            console.log('No reference source implementation for ' + rcFormData.type + ' found')
        }
    })
}

const getReferenceSourcesFields = async function(ReferenceStore) {
    const referenceSources = await ReferenceStore.getAllSources()

    return [
        {
            tab: 'Reference Sources',
            isActive: formData => !formData['reference-sources'] || !formData['reference-sources'].length,
            render: (el, formData) => {
                el.classList.add('integration-info');
                el.innerHTML = 'No integration(s) configured. Click the "Configure New Integration" button below to do so.'
            }
        },
        {
            name: 'reference-sources',
            newButtonLabel: 'Configure New Reference Source',
            tab: 'Reference Sources',
            isValidRecord: (formData, dForm) => {
                const rsc = referenceSourcesConfig.find(rs => rs.id === formData.type)
                return rsc && rsc.isValidRecord(formData, dForm, ReferenceStore)
            },
            renderEntry: (formData, dForm) => {
                const rsc = referenceSourcesConfig.find(rs => rs.id === formData.type)
                return rsc && rsc.renderEntry(formData, dForm)
            },
            defaultValue: referenceSources,
            onChange: formData => saveReferenceSources(formData, ReferenceStore),
            arrayOf: [
                {
                    name: 'type',
                    displayName: 'Source:',
                    allowedValues: referenceSourcesConfig.map(i => [i.id, i.displayName]),
                },
                ...referenceSourcesConfig.flatMap(i => i.fields)
            ]
        }
    ]
}

module.exports = {
    getReferenceSourcesFields,
    syncAllSources
}

/***/ }),

/***/ "../structured-text-editor/src/references/reference_sources/zotero_desktop.js":
/*!************************************************************************************!*\
  !*** ../structured-text-editor/src/references/reference_sources/zotero_desktop.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const throttle = __webpack_require__(/*! ../../../lib/throttle/throttle */ "../structured-text-editor/lib/throttle/throttle.js")

const transformResponseItem = function(item, libraryID, CollectionID) {
    const typeMap = {
        'article-journal': 'Article',
        'article': 'Article',
        'article-magazine': 'Article',
        'article-newspaper': 'Article',
        'bill': 'Article',
        'book': 'Book',
        'broadcast': 'Article',
        'chapter': 'Inbook',
        'classic': 'Article',
        'collection': 'Article',
        'dataset': 'Article',
        'document': 'Article',
        'entry': 'Article',
        'entry-dictionary': 'Article',
        'entry-encyclopedia': 'Website',
        'event': 'Article',
        'figure': 'Article',
        'graphic': 'Article',
        'hearing': 'Article',
        'interview': 'Article',
        'legal_case': 'Article',
        'legislation': 'Article',
        'manuscript': 'Article',
        'map': 'Article',
        'motion_picture': 'Article',
        'musical_score': 'Article',
        'pamphlet': 'Article',
        'paper-conference': 'Conference/Inproceedings',
        'patent': 'Article',
        'performance': 'Article',
        'periodical': 'Article',
        'personal_communication': 'Article',
        'post': 'Website',
        'post-weblog': 'Website',
        'regulation': 'Article',
        'report': 'Article',
        'review': 'Article',
        'review-book': 'Article',
        'software': 'Article',
        'song': 'Article',
        'speech': 'Article',
        'standard': 'Article',
        'thesis': 'Mastersthesis',
        'treaty': 'Article',
        'webpage': 'Website'
    }

    const convertNameValue = nameEntry => {
        return [nameEntry.family, nameEntry.given]
            .filter(f => f && f.trim)
            .map(f => f.trim())
            .filter(f => f !== '')
            .join(', ')
    }

    const tryToParseDate = dateParts => {
        if(dateParts && dateParts['date-parts'] && dateParts['date-parts'][0]) {
            return dateParts['date-parts'][0].join('-')
        }
    }

    const tryToParseYear = dateParts => {
        if(dateParts && dateParts['date-parts'] && dateParts['date-parts'][0] && dateParts['date-parts'][0][0]) {
            return dateParts['date-parts'][0][0].toString()
        }
    }

    const tryToParseMonth = dateParts => {
        if(dateParts && dateParts['date-parts'] && dateParts['date-parts'][0] && dateParts['date-parts'][0][1]) {
            return dateParts['date-parts'][0][1].toString()
        }
    }

    return {
        lookupId: item.ISBN || item.DOI,
        id: item.id,
        type: typeMap[item.type] || 'Article',
        referenceSource: `zotero-desktop-${libraryID}-${CollectionID}`,
        title: item.title,
        author: item.author && item.author.map(convertNameValue).join(' and '),
        pages: item['number-of-pages'],
        volume: item.valume,
        url: item.URL,
        publisher: item.publisher,
        edition: item.edition,
        date: tryToParseDate(item.accessed),
        year: tryToParseYear(item.issued),
        month: tryToParseMonth(item.issued),
        editor: item.editor && item.editor.map(convertNameValue).join(' and '),
    }
}

const renderEntry = function(entry) {
    if(entry.type === 'zotero-desktop') {
        return `Zotero Destkop`
    }
}

const isValidRecord = throttle(100, async function(formData, dFrom, ReferenceStore) {
    window.store = ReferenceStore
    if(formData.type === 'zotero-desktop' && formData['zotero-desktop-libraryID']) {
        var itemResponse;
        try {
            dFrom.setTooltip('zotero-desktop-libraryID', 'Wait for it ...', '', 'tooltip-loading')
            dFrom.setTooltip('zotero-desktop-collectionID', 'Wait for it ...', '', 'tooltip-loading')

            if(formData['zotero-desktop-collectionID'] === 'no-collection') {
                itemResponse = await fetch(`http://127.0.0.1:23119/better-bibtex/export/library?/${formData['zotero-desktop-libraryID']}/library.csljson`)
            } else {
                itemResponse = await fetch(`http://127.0.0.1:23119/better-bibtex/collection?/${formData['zotero-desktop-libraryID']}/${formData['zotero-desktop-collectionID']}.csljson`)
            }

            const items = await itemResponse.json();

            items.forEach(item => {
                ReferenceStore.set(`zotero-desktop-item-${formData['zotero-desktop-libraryID']}-${formData['zotero-desktop-collectionID']}-${item.id}`, transformResponseItem(item, formData['zotero-desktop-libraryID'], formData['zotero-desktop-collectionID']))
            })

            dFrom.resetTooltips(['zotero-desktop-libraryID', 'zotero-desktop-collectionID'])

            const hintField = formData['zotero-desktop-collectionID'] === 'no-collection' ? 'zotero-desktop-libraryID' : 'zotero-desktop-collectionID'
            const hintFieldType = formData['zotero-desktop-collectionID'] === 'no-collection' ? 'library' : 'collection'

            if(!items.length) {
                dFrom.setTooltipWarning(hintField, `No items found in this ${hintFieldType}!`)
            } else {
                dFrom.setTooltipSuccess(hintField, `${items.length} items found.`)
            }

            return true;
        } catch(ex) {
            dFrom.setTooltipError('zotero-desktop-libraryID', `Something went wrong fetching items from Zotero.`)
            dFrom.setTooltipError('zotero-desktop-collectionID', `Something went wrong fetching items from Zotero.`)
            return false
        }
    }
})

const sync = async function(formData, ReferenceStore) {
    if(formData.type === 'zotero-desktop' && formData['zotero-desktop-libraryID']) {
        var itemResponse;
        try {
            if(formData['zotero-desktop-collectionID'] === 'no-collection') {
                itemResponse = await fetch(`http://127.0.0.1:23119/better-bibtex/export/library?/${formData['zotero-desktop-libraryID']}/library.csljson`)
            } else {
                itemResponse = await fetch(`http://127.0.0.1:23119/better-bibtex/collection?/${formData['zotero-desktop-libraryID']}/${formData['zotero-desktop-collectionID']}.csljson`)
            }

            const items = await itemResponse.json();

            items.forEach(item => {
                ReferenceStore.set(`zotero-desktop-item-${formData['zotero-desktop-libraryID']}-${formData['zotero-desktop-collectionID']}-${item.id}`, transformResponseItem(item, formData['zotero-desktop-libraryID'], formData['zotero-desktop-collectionID']))
            })

            return true;
        } catch(ex) {
            return false
        }
    }
}

const fetchLibraries = throttle(100, async function() {
    var response;

    try {
        response = await fetch(`http://localhost:23119/better-bibtex/json-rpc`, {
            method: 'POST',
            body: JSON.stringify({ jsonrpc: "2.0", method: "user.groups", params: [true] }),
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json',
            },
        })
    } catch(ex) {
        throw { message: 'Make sure you have startet the Zotero desktop app' }
    }

    if(response.status === 404) {
        throw { message: 'Make sure you have the "Better BibTeX for Zotero" add-on installed in Zotero. You can download it here: https://retorque.re/zotero-better-bibtex/installation/' }
    } else if(response.status === 500) {
        throw { message: 'Make sure you have at least version <b>6.7.1</b> of "Better BibTeX for Zotero" installed. You can download it here: https://retorque.re/zotero-better-bibtex/installation/' }
    }

    if(response.status !== 200) {
        throw { message: 'Something went wrong fetching items from Zotero' }
    }

    var jsonResponse = (await response.json())

    if(!jsonResponse.result) {
        throw { message: 'Something went wrong fetching items from Zotero. Please send the following error test to info@monsterwriter.app: ' + JSON.stringify(jsonResponse.error) }
    }

    if(jsonResponse.result.length === 0) {
        throw { message: 'No libraries available!' }
    }

    return jsonResponse.result
})

const onValuesCalculationFailedMessage = function(fromData, err) {
    return {
        level: err.level || 'error',
        text: err.message || 'Something went wrong fetching items from Zotero.'
    }
}

const fields = [
    {
        name: 'zotero-desktop-libraryID',
        displayName: 'Library',
        tooltip: 'Choose a library from your local Zotero installation',
        isActive: formData => formData['type'] === 'zotero-desktop',
        onValuesCalculationFailedMessage,
        allowedValues: async () => (await fetchLibraries()).map(lib => [lib.id, lib.name]),
    },
    {
        name: 'zotero-desktop-collectionID',
        displayName: 'Collection',
        reloadOnChangeOf: ['zotero-desktop-libraryID'],
        tooltip: 'Choose a collection from your local Zotero installation',
        isActive: formData => formData['type'] === 'zotero-desktop',
        defaultValue: 'no-collection',
        onValuesCalculationFailedMessage,
        allowedValues: async formData => {
            if(!formData['zotero-desktop-libraryID']) {
                throw { message: 'Choose a library first!' }
            }

            var libraries = await fetchLibraries()
            var library = libraries.find(lib => lib.id.toString() === formData['zotero-desktop-libraryID'])

            if(!library.collections || !library.collections.length) {
                throw { message: 'No collections available in the choosen library!' }
            }

            return [
                ['no-collection', 'Entire Library'],
                ...library.collections.map(col => [ col.key, col.name ])
            ]
        },
    }
]

module.exports = {
    id: 'zotero-desktop',
    displayName: 'Zotero (Desktop via Better BibTeX Add-On)',
    isValidRecord,
    renderEntry,
    fields,
    sync
}

/***/ }),

/***/ "../structured-text-editor/src/references/reference_sources/zotero_online.js":
/*!***********************************************************************************!*\
  !*** ../structured-text-editor/src/references/reference_sources/zotero_online.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const throttle = __webpack_require__(/*! ./../../../lib/throttle/throttle */ "../structured-text-editor/lib/throttle/throttle.js")
const { ZoteroOnline } = __webpack_require__(/*! ./../../../lib/zotero-client */ "../structured-text-editor/lib/zotero-client/index.js")
var latestLoadedGroups = [], clientsWithoutStore = {}

const isValidRecord = throttle(100, async function(formData, dFrom, ReferenceStore) {
    if(formData.type === 'zotero-online') {
        const isGroup = formData['zotero-online-userOrGroup'] === 'group'

        if(formData['zotero-online-apiKey'].trim() === '') {
            dFrom.setTooltipWarning('zotero-online-apiKey', 'An Zotero API key is needed. You can create an API key here: https://www.zotero.org/settings/keys')
            return false
        }

        if(isGroup && formData['zotero-online-groupID'] === '') {
            dFrom.setTooltipWarning('zotero-online-groupID', 'Choose a group from which you want to retrieve references from. If you do not want to retrieve references from a Zotero group choose "User" in "User or Group Scoped Integration"')
            return false
        }

        try {
            dFrom.setTooltip('zotero-online-apiKey', 'Wait for it ...', '', 'tooltip-loading')

            const zoteroOnlineClient = new ZoteroOnline(formData['zotero-online-apiKey'], ReferenceStore)
            await zoteroOnlineClient.loadUserInfo()

            const itemCount = (isGroup ?
                await zoteroOnlineClient.itemsByGroupID(formData['zotero-online-groupID']) :
                await zoteroOnlineClient.items()).length

            dFrom.resetTooltips(['zotero-online-groupID', 'zotero-online-apiKey'])

            if(itemCount) {
                dFrom.setTooltipSuccess('zotero-online-apiKey', `${itemCount} items have been fetched from Zotero`)
            } else {
                dFrom.setTooltipWarning('zotero-online-apiKey', 'It seems like this user or group does not has any items saved')
            }

            return true
        } catch(err) {
            console.log(err)
            const errorText = `There was an error connecting to Zotero. Make sure ${isGroup ? 'Group' : 'User'} ID and API Key are correct!`
            dFrom.setTooltipError('zotero-online-apiKey', errorText)
            return false
        }
    }
})

const sync = async function(formData, ReferenceStore) {
    if(formData.type === 'zotero-online') {
        const isGroup = formData['zotero-online-userOrGroup'] === 'group'

        if(formData['zotero-online-apiKey'].trim() === '') {
            return false
        }

        if(isGroup && formData['zotero-online-groupID'] === '') {
            return false
        }

        try {
            const zoteroOnlineClient = new ZoteroOnline(formData['zotero-online-apiKey'], ReferenceStore)
            await zoteroOnlineClient.loadUserInfo()

            if(isGroup) {
                await zoteroOnlineClient.itemsByGroupID(formData['zotero-online-groupID'])
            } else {
                await zoteroOnlineClient.items()
            }

            return true
        } catch(err) {
            console.log(err)
            return false
        }
    }
}

const getClientWithoutStore = async function(apiKey) {
    if(!clientsWithoutStore[apiKey]) {
        clientsWithoutStore[apiKey] = []
        clientsWithoutStore[apiKey][0] = new ZoteroOnline(apiKey)
        clientsWithoutStore[apiKey][1] = clientsWithoutStore[apiKey][0].loadUserInfo()
    }

    await clientsWithoutStore[apiKey][1]

    return clientsWithoutStore[apiKey][0]
}

const renderEntry = function(entry) {
    if(entry.type === 'zotero-online') {
        const isGroup = entry['zotero-online-userOrGroup'] === 'group'
        const userOrGroup = entry['zotero-online-userOrGroup'].charAt(0).toUpperCase() + entry['zotero-online-userOrGroup'].slice(1)
        var displayName = ''

        if(!isGroup) {
            displayName = entry['zotero-online-userName']
        } else if(isGroup) {
            displayName = entry['zotero-online-groupName']
        }

        return `Zotero.org (Online) - ${userOrGroup}: ${displayName}`
    }
}

const fields = [
    {
        name: 'zotero-online-userOrGroup',
        displayName: 'Zotero Library Type:',
        isActive: formData => formData['type'] === 'zotero-online',
        allowedValues: [['user', 'User'], ['group', 'Group']],
        defaultValue: 'user',
    },
    {
        name: 'zotero-online-apiKey',
        isActive: formData => formData['type'] === 'zotero-online',
        displayName: 'API Key:',
        inputType: 'password',
        tooltip: 'You can create an API key here: https://www.zotero.org/settings/keys',
    },
    {
        name: 'zotero-online-userID',
        reloadOnChangeOf: ['zotero-online-apiKey'],
        calculate: async formData => {
            if(!formData || !formData['zotero-online-apiKey'] || formData['zotero-online-apiKey'] === '') {
                return;
            }

            const client = await getClientWithoutStore(formData['zotero-online-apiKey'])
            return client.userID
        }
    },
    {
        name: 'zotero-online-userName',
        reloadOnChangeOf: ['zotero-online-apiKey'],
        calculate: async formData => {
            if(!formData || !formData['zotero-online-apiKey'] || formData['zotero-online-apiKey'] === '') {
                return;
            }

            const client = await getClientWithoutStore(formData['zotero-online-apiKey'])
            return client.userName
        }
    },
    {
        name: 'zotero-online-groupName',
        reloadOnChangeOf: ['zotero-online-apiKey', 'zotero-online-userOrGroup', 'zotero-online-groupID'],
        calculate: formData => {
            if(!latestLoadedGroups
                || !latestLoadedGroups.find
                || !formData
                || !formData['zotero-online-groupID']
                || formData['zotero-online-userOrGroup'] === 'user') {
                return;
            }

            const group = latestLoadedGroups.find(gr => gr.id.toString() === formData['zotero-online-groupID'].toString())

            if(group) {
                return group.name
            }
        }
    },
    {
        name: 'zotero-online-groupID',
        displayName: 'Group',
        tooltip: 'If you want to cite references which are managed in a Zotero group, select the group here. If not, select "User" in "User or Group Scoped Integration"',
        isActive: formData => formData['type'] === 'zotero-online' && formData['zotero-online-userOrGroup'] === 'group',
        reloadOnChangeOf: ['zotero-online-apiKey', 'zotero-online-userOrGroup'],
        allowedValues: async formData => {
            if(!formData
                || !formData['zotero-online-apiKey']
                || formData['zotero-online-apiKey'].trim() === ''
                || formData['zotero-online-userOrGroup'] !== 'group') {
                return []
            }

            const client = await getClientWithoutStore(formData['zotero-online-apiKey'])
            latestLoadedGroups = await client.groups()

            return latestLoadedGroups.map(r => [r.id, r.name])
        },
    }
]

module.exports = {
    id: 'zotero-online',
    displayName: 'Zotero.org (Cloud Version)',
    isValidRecord,
    renderEntry,
    fields,
    sync
}

/***/ }),

/***/ "../structured-text-editor/src/references/reference_store.js":
/*!*******************************************************************!*\
  !*** ../structured-text-editor/src/references/reference_store.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const throttle = __webpack_require__(/*! ../../lib/throttle/throttle */ "../structured-text-editor/lib/throttle/throttle.js");
const escapeID = id => id.replace(/[^a-zA-Z0-9\-]/g, "x");

class SimplePersitencyDriver {
    constructor() {
        this.data = {}
    }

    async set(id, attr) {
        this.data[id] = { id, ...attr }
        return this.data[id]
    }

    async all() {
        return Object.values(this.data)
    }

    async get(id) {
        return this.data[id]
    }

    async deleteAll() {
        this.data = {}
    }
}

class ReferenceStore {

    static citedInCurrentDocument() {
        if(document && document.querySelectorAll) {
            return document
                .querySelectorAll('.reference[data-external="true"]')
                .map(el => el.dataset.ref)
        }

        return []
    }

    static isCitedInCurrentDocument(id) {
        return ReferenceStore.citedInCurrentDocument().includes(id)
    }

    //FIXME: make this calculated attribute of formData
    static getSourceID(formData) {
        if(formData['type'] === 'zotero-online') {
            if(formData['zotero-online-userOrGroup'] === 'user') {
                return `zotero-online-user-${formData['zotero-online-userID']}`
            } else if(formData['zotero-online-userOrGroup'] === 'group') {
                return `zotero-online-group-${formData['zotero-online-groupID']}`
            }
        } else if(formData['type'] === 'zotero-desktop') {
            return `zotero-desktop-${formData['zotero-desktop-libraryID']}-${formData['zotero-desktop-collectionID']}`
        }
    }

    constructor(contentId, PersitencyDriver = SimplePersitencyDriver) {
        this.contentId = contentId
        this.data = {}
        this.persistentReferenceStore = new PersitencyDriver('reference')
        this.persistentReferenceSourceStore = new PersitencyDriver('reference_sources')
    }

    initCache = throttle(100, async () => {
        const allRefsFromStore = await this.persistentReferenceStore.all({ updatedSince: this.lastCacheUpdate })
        this.lastCacheUpdate = Date.now()

        allRefsFromStore
            .filter(r => (r.contentId === this.contentId || r.referenceSource !== 'intern'))
            .forEach(r => { this.data[r.id] = r })
    })

    set(id, attr) {
        id = escapeID(id)

        var filteredAttr = {
            ...attr,
            contentId: this.contentId,
            lookupId: (attr.lookupId || '').trim(),
            url: (attr.url || '').trim(),
            date: (attr.date || '').trim(),
            type: (attr.type || '').trim(),
            author: (attr.author || '').trim(),
            title: (attr.title || '').trim(),
            subtitle: (attr.subtitle || '').trim(),
            booktitle: (attr.booktitle || '').trim(),
            organization: (attr.organization || '').trim(),
            journal: (attr.journal || '').trim(),
            publisher: (attr.publisher || '').trim(),
            school: (attr.school || '').trim(),
            institution: (attr.institution || '').trim(),
            editor: (attr.editor || '').trim(),
            series: (attr.series || '').trim(),
            year: (attr.year || '').trim(),
            month: (attr.month || '').trim(),
            edition: (attr.edition || '').trim(),
            volume: (attr.volume || '').trim(),
            number: (attr.number || '').trim(),
            chapter: (attr.chapter || '').trim(),
            pages: (attr.pages || '').trim(),
            _deleted: false,
            id: id
        }

        this.data[id] = filteredAttr

        return this.persistentReferenceStore.set(id, filteredAttr)
    }

    get(id) {
        id = escapeID(id)

        return this.data[id]
    }

    delete(id) {
        id = escapeID(id)

        this.data[id]._deleted = true

        this.persistentReferenceStore.get(id).then(item => {
            this.persistentReferenceStore.set(id, {
                ...item,
                _deleted: true
            })
        })
    }

    all(withID) {
        var result = {}

        Object.keys(this.data).forEach(refId => {
            if(!this.isRefEmpty(refId) && (!this.data[refId]._deleted || ReferenceStore.isCitedInCurrentDocument(refId))) {
                result[refId] = this.data[refId]

                if(withID) {
                    result[refId].id = refId;
                }
            }
        })

        return result;
    }

    addReferenceData(data) {
        Object.entries(data).forEach(refRecord => {
            this.set(refRecord[0], refRecord[1]);
        })
    }

    async allAsync(withID) {
        var result = {}

        Object.keys(this.data).forEach(refId => {
            if(!this.isRefEmpty(refId) && (!this.data[refId]._deleted || ReferenceStore.isCitedInCurrentDocument(refId))) {
                result[refId] = this.data[refId]

                if(withID) {
                    result[refId].id = refId;
                }
            }
        })

        return result;
    }

    isRefEmpty(id) {
        id = escapeID(id)

        var record = this.data[id];

        return record.author === ''
            && record.title === ''
            && record.url === '';
    }

    async deleteAllSources() {
        await this.persistentReferenceSourceStore.deleteAll()
    }

    async addSource(attr) {
        const id = ReferenceStore.getSourceID(attr)

        if(!id) {
            throw "unable to save reference source"
        }

        await this.persistentReferenceSourceStore.set(id, attr)

        const allrefs = (await this.persistentReferenceStore.all())
            .filter(r => r.id && r.id.startsWith(`zotero-online-item-${id.split('-')[3]}`) && r._deleted)

        await Promise.all(allrefs.map(item => this.set(item.id, item)))
    }

    async cleanupReferencesFromSources() {
        const allSourceIds = (await this.getAllSources()).map(src => src.id)
        const allRefs = this.all(true)

        const refsToBeDeleted = Object.values(allRefs)
            .filter(ref => {
                if(!ref.referenceSource || ref.referenceSource === 'intern') {
                    return false
                }

                return !allSourceIds.find(srcId => srcId === ref.referenceSource)
            })

        refsToBeDeleted.forEach(ref => {
            this.delete(ref.id)
        })
    }

    async getAllSources() {
        return await this.persistentReferenceSourceStore.all()
    }
}

module.exports = ReferenceStore;

/***/ }),

/***/ "../structured-text-editor/src/section_type_selector_control.js":
/*!**********************************************************************!*\
  !*** ../structured-text-editor/src/section_type_selector_control.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var utils = __webpack_require__(/*! ../lib/pixelschubser/utils */ "../structured-text-editor/lib/pixelschubser/utils.js"),
    DeclarativForm = __webpack_require__(/*! ../lib/declarativ_forms/src/declarativ_form */ "../structured-text-editor/lib/declarativ_forms/src/declarativ_form.js");

function SectionTypeSelectorControl(onChangeCallback, onChangeCallbackContext, editor) {
    var self = this;

    this.editor = editor;
    this.sectionTypeSelector = document.createElement('div');
    this.sectionTypeSelector.id = 'sectionTypeSelector';

    this.sectionTypeSelector.innerHTML = '<span class="option-btn delete-option-btn" data-option-for="img"><i class="fas fa-trash"></i></span>' +
                                         '<span class="option-btn delete-option-btn" data-option-for="table"><i class="fas fa-trash"></i></span>' +
                                         '<span class="option-btn delete-option-btn" data-option-for="code"><i class="fas fa-trash"></i></span>' +
                                         '<span class="option-btn delete-option-btn" data-option-for="toc"><i class="fas fa-trash"></i></span>' +
                                         '<span class="option-btn delete-option-btn" data-option-for="bquote"><i class="fas fa-trash"></i></span>' +
                                         '<span class="option-btn delete-option-btn" data-option-for="bibliographie"><i class="fas fa-trash"></i></span>' +
                                         '<span class="option-btn delete-option-btn" data-option-for="footnotes"><i class="fas fa-trash"></i></span>' +
                                         '<span class="option-btn delete-option-btn" data-option-for="formula"><i class="fas fa-trash"></i></span>' +
                                         '<span class="option-btn delete-option-btn" data-option-for="mermaid"><i class="fas fa-trash"></i></span>' +
                                         '<span class="option-btn config-option-btn" data-option-for="code"><i class="fas fa-cog"></i></span>' +
                                         '<span class="option-btn config-option-btn" data-option-for="table"><i class="fas fa-cog"></i></span>' +
                                         '<span class="option-btn config-option-btn" data-option-for="img"><i class="fas fa-cog"></i></span>' +
                                         '<span class="option-btn config-option-btn" data-option-for="bquote"><i class="fas fa-cog"></i></span>' +
                                         '<span class="option-btn config-option-btn" data-option-for="bibliographie"><i class="fas fa-cog"></i></span>' +
                                         '<span class="option-btn config-option-btn" data-option-for="footnotes"><i class="fas fa-cog"></i></span>' +
                                         '<span class="option-btn config-option-btn" data-option-for="formula"><i class="fas fa-cog"></i></span>' +
                                         '<span class="option-btn config-option-btn" data-option-for="mermaid"><i class="fas fa-cog"></i></span>' +
                                         '<span class="option-btn config-option-btn" data-option-for="h2"><i class="fas fa-cog"></i></span>' +
                                         '<span class="sectionTypeBtn" data-type="h1">title</span>' +
                                         '<span class="sectionTypeBtn" data-type="h2" unannotated-caption="h1" unactive-caption="heading-1">heading-1</span>' +
                                         '<span class="sectionTypeBtn" data-type="h3" unannotated-caption="h2" unactive-caption="heading-2">heading-2</span>' +
                                         '<span class="sectionTypeBtn" data-type="h4" unannotated-caption="h3" unactive-caption="heading-3">heading-3</span>' +
                                         '<span class="sectionTypeBtn" data-type="h5" unannotated-caption="h4" unactive-caption="heading-4">heading-4</span>' +
                                         '<span class="sectionTypeBtn" data-type="p">paragraph</span>'+
                                         '<span class="sectionTypeBtn notChangeable" data-type="bquote" unannotated-caption="quote" unactive-caption="blockquote">blockquote</span>'+
                                         '<span class="sectionTypeBtn notChangeable" data-type="table">table</span>' +
                                         '<span class="sectionTypeBtn" data-type="code" data-section-tag="pre" unannotated-caption="code">code</span>' +
                                         '<span class="sectionTypeBtn notChangeable" data-type="ul" unannotated-caption="list" unactive-caption="unordered-list">unordered-list</span>' +
                                         '<span class="sectionTypeBtn notChangeable" data-type="ol" unannotated-caption="list" unactive-caption="ordered-list">ordered-list</span>' +
                                         '<span class="sectionTypeBtn notChangeable" data-type="img" data-section-tag="figure">image</span>' +
                                         '<span class="sectionTypeBtn notChangeable" data-type="formula">formula</span>' +
                                         '<span class="sectionTypeBtn notChangeable" data-type="mermaid">mermaid</span>' +
                                         '<span class="sectionTypeBtn notChangeable" data-type="toc" data-section-tag="nav">toc</span>' +
                                         '<span class="sectionTypeBtn notChangeable" data-type="bibliographie" unannotated-caption="bib" unactive-caption="bibliographie">bibliographie</span>' +
                                         '<span class="sectionTypeBtn" data-type="h2(abstract)">abstract</span>' +
                                         '<span class="sectionTypeBtn" data-type="h2(declaration)">declaration</span>' +
                                         '<span class="sectionTypeBtn" data-type="h2(appendix)">appendix</span>' +
                                         '<span class="sectionTypeBtn" data-type="h2(acknowledgement)">acknowledgement</span>' +
                                         '<span class="sectionTypeBtn notChangeable" data-type="footnotes">footnotes</span>';

    this.buttons = Array.prototype.slice.call(this.sectionTypeSelector.children);

    this.sectionTypeSelector.onmouseover = function(e) {
        var isTypeBtn = e.target.classList.contains('sectionTypeBtn');

        if(e.target.id === 'sectionTypeSelector') { return }

        self.buttons.forEach(function(b) {
            isTypeBtn ? b.classList.add('hover') : b.classList.remove('hover');
        });
    }

    this.sectionTypeSelector.onmouseleave = function(e) {
        self.buttons.forEach(function(b) { b.classList.remove('hover') });
    }

    this.buttons.filter(function(btn) {
        return btn.classList.contains('delete-option-btn');
    }).forEach(function(btn) {
        btn.onclick = function() {
            if(self.editor) {
                if(self.sectionElement.onUnfocus) {
                    self.sectionElement.onUnfocus(self.editor)
                }

                self.editor.removeSection(self.sectionElement);
            } else {
                self.sectionElement.parentElement.removeChild(self.sectionElement);
            }

            self.hide();
        }
    });

    this.buttons.filter(function(btn) {
        return btn.classList.contains('config-option-btn');
    }).forEach(function(btn) {
        btn.addEventListener("click", function(){
            if(self.sectionElement.sectionType && self.sectionElement.sectionType.getOptions) {
                var form = new DeclarativForm({fields: self.sectionElement.sectionType.getOptions(self.sectionElement)}, function(formData) {
                    self.sectionElement.sectionType.onOptionsChange(formData, self.editor)
                    self.update();
                });

                form.openInModal();
            }
        });
    });

    this.sectionTypeSelector.addEventListener('click', function(e) {
        var clickedButton = e.target,
            currentSectionBtn = clickedButton.parentNode.querySelector('.sectionTypeBtn.active'),
            currentSectionIsChangeable = currentSectionBtn && !currentSectionBtn.classList.contains('notChangeable'),
            annotation, sectionTypeName;

        if(clickedButton.dataset.type && currentSectionIsChangeable) {
            sectionTypeName = clickedButton.dataset.type.split(/\(|\)/)[0];
            annotation = clickedButton.dataset.type.split(/\(|\)/)[1];
            onChangeCallback.apply(onChangeCallbackContext, [sectionTypeName, annotation]);
            self.setActiveSelection(clickedButton.dataset.sectionTag || clickedButton.dataset.type);
        }
    });

    document.body.appendChild(this.sectionTypeSelector);
}

SectionTypeSelectorControl.prototype = {
    getSectionTypeBySectionTag: function(sectionTag) {
        var btn = this.buttons.find(function (btn) {
            return btn.dataset.sectionTag === sectionTag || btn.dataset.type === sectionTag;
        });

        return btn && btn.dataset && btn.dataset.type;
    },

    setActiveSelection: function(sectionTag) {
        var self = this,
            unannotatedCaption,
            unactiveCaption,
            captionAnnotation,
            activeBtn;

        this.buttons.forEach(function(btn) {
            btn.classList.remove('active');
            btn.classList.remove('unusable');
            var tagName = btn.dataset.sectionTag || btn.dataset.type;

            unannotatedCaption = btn.getAttribute('unannotated-caption');
            unactiveCaption = btn.getAttribute('unactive-caption');

            if(unannotatedCaption) {
                btn.innerHTML = unannotatedCaption;
            }

            if(tagName === sectionTag || btn.dataset.optionFor === self.getSectionTypeBySectionTag(sectionTag)) {
                btn.classList.add('active');
                activeBtn = btn;
                if(unannotatedCaption &&
                   self.sectionElement &&
                   self.sectionElement.sectionType &&
                   self.sectionElement.sectionType.getSectionTypeCaptionAnnotation) {
                    captionAnnotation = self.sectionElement.sectionType.getSectionTypeCaptionAnnotation(self.sectionElement);
                }
            } else if (unactiveCaption) {
                btn.innerHTML = unactiveCaption;
            }

            if(captionAnnotation) {
                btn.innerHTML = unannotatedCaption + '<span class="annotation">(' + captionAnnotation + ')<span>';
            }

            captionAnnotation = undefined;
            unactiveCaption = undefined;
        });

        if(activeBtn.classList.contains('notChangeable')) {
            this.buttons.forEach(function(btn) {
                if(btn !== activeBtn) {
                    btn.classList.add('unusable');
                }
            });
        }
    },

    hide: function() {
        var sectionTypeSelectorElement = document.getElementById('sectionTypeSelector');
        sectionTypeSelectorElement.style.left = -1000 + 'px';
        sectionTypeSelectorElement.style.top = -1000 + 'px';
    },

    update: function() {
        var sectionElement = self.editor.focusedSection();
        if(sectionElement && sectionElement.tagName) {
            this.setActiveSelection(sectionElement.tagName.toLowerCase());
        }
    },

    displayNextTo: function(sectionElement, skipAnimation) {
        if(!sectionElement) return false;

        var self = this,
            sectionPosition = utils.getElementPosition(sectionElement),
            sectionTypeSelectorElement = document.getElementById('sectionTypeSelector'),
            sectionElementTopMargin = parseInt(window.getComputedStyle(sectionElement).getPropertyValue('margin-top').replace('px', '')),
            posX = sectionPosition.x,
            posY = sectionPosition.y,
            minY = window.scrollY + sectionElementTopMargin + 5, //add 5px so that there is a small room between the end of the browser screen and the selector button
            maxY = sectionElement.offsetHeight + sectionElement.offsetTop - sectionTypeSelectorElement.children[0].offsetHeight - 30,
            executeUpdate;

        posY = posY < minY ? minY : posY;
        posY = posY > maxY ? maxY : posY;

        this.sectionElement = sectionElement;
        this.setActiveSelection(sectionElement.tagName.toLowerCase());

        if(this.displaySectionTypeSelectorTimeout)
            clearTimeout(this.displaySectionTypeSelectorTimeout);

        executeUpdate = function() {
            sectionTypeSelectorElement.style.left = posX + 'px';
            sectionTypeSelectorElement.style.top = posY + 'px';
            if(utils.getDistanceToRightWindowBorder(self.editor.containerElement) < 150) {
                sectionTypeSelectorElement.classList.add('lessSpace');
            } else {
                sectionTypeSelectorElement.classList.remove('lessSpace');
            }
        }

        if(skipAnimation) {
            executeUpdate()
        } else {
            this.displaySectionTypeSelectorTimeout = setTimeout(executeUpdate, 10);
        }

    }
}

module.exports = SectionTypeSelectorControl;


/***/ }),

/***/ "../structured-text-editor/src/section_types/bibliographie/bibliographie_section_type.js":
/*!***********************************************************************************************!*\
  !*** ../structured-text-editor/src/section_types/bibliographie/bibliographie_section_type.js ***!
  \***********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uuid = __webpack_require__(/*! uuid/v1 */ "../structured-text-editor/node_modules/uuid/v1.js");

function getSectionElement() {
    var  el = document.createElement('bibliographie'),
         heading = document.createElement('h2'),
         content = document.createElement('div');
    el.classList.add('bibliographie');
    heading.classList.add('bibliographie-heading');
    content.classList.add('bibliographie-content');

    el.setAttribute('contenteditable', 'false');
    heading.setAttribute('contenteditable', 'true');
    content.setAttribute('contenteditable', 'false');

    heading.innerHTML = 'Bibliography';

    el.sectionType = module.exports;
    el.onFocus = module.exports.onFocus;
    el.onKeyBackspace = module.exports.onKeyBackspace;

    el.appendChild(heading);
    el.appendChild(content);

    return el;
}

Object.assign(module.exports, {

    name: 'bibliographie',

    preferredCaretPositioning: 'end',

    editableElementSelector: 'h2',

    contentRules: {
        'bibliographie': {
            tagName: 'bibliographie',
            allowedAttributes: ['class', 'contenteditable'],
            allowedClassNames: ['focused'],
            allowedChildren: ['bibliographie-heading', 'bibliographie-content'],
            allowedToBeRoot: true,
            deleteIfEmpty: false,
            doNotBreakOutRootElements: true,
            buildEmptyElement: getSectionElement
        },

        'bibliographie-heading': {
            tagName: 'h2',
            className: 'bibliographie-heading',
            allowedAttributes: ['id', 'class', 'contenteditable', 'unnumbered-heading'],
            allowedClassNames: ['bibliographie-heading'],
            allowedChildren: ['#text'],
            pruneSpaces: true,
            buildAttributes: [
                {name: 'id', build: function() {return uuid()}},
                {name: 'unnumbered-heading', build: function() {return 'Yes'}}
            ]
        },

        'bibliographie-content': {
            tagName: 'div',
            className: 'bibliographie-content',
            allowedAttributes: ['class', 'contenteditable'],
            allowedClassNames: ['bibliographie-content'],
            allowedChildren: ['bibliographie-entry'],
        },

        'bibliographie-entry': {
            tagName: 'div',
            className: 'entry',
            allowedAttributes: ['class'],
            allowedClassNames: ['entry', 'note'],
            allowedChildren: ['#text'],
        }
    },

    enrichments: [],

    getSectionElement: getSectionElement,

    getOptions: function(sectionElement) {
        return [
            {
                name: 'numberedHeading',
                displayName: 'Should the heading be numbered',
                allowedValues: ['Yes', 'No'],
                defaultValue: sectionElement.querySelector('h2').getAttribute('unnumbered-heading') === 'Yes' ? 'No' : 'Yes'
            }
        ]
    },

    onOptionsChange: function(opt, editor) {
        var section = editor.focusedSection();
        if(opt.numberedHeading === 'Yes' || opt.numberedHeading === 'No') {
            section.querySelector('h2').setAttribute('unnumbered-heading', opt.numberedHeading === 'Yes' ? 'No' : 'Yes');
            self.editor.replaceSectionWithHTML(section, section.outerHTML);
        }
    },

    onEditorContentChanged: function(modificationLog) {
        if(!modificationLog.mightIncludeReferenceUpdates && !modificationLog.mightIncludeBibliographieUpdates) {
            return;
        }

        var bibs = document.querySelectorAll('bibliographie .bibliographie-content'),
            refs = document.querySelectorAll('.reference[data-external]').map(function(r) { return r.getAttribute('data-ref')}).unique(),
            allRefs = module.exports.editor.reference.getAllExternalRefs(), refData;

        bibs.forEach(function(bib) {
            bib.innerHTML = '';
            if(refs.length === 0) {
                bib.innerHTML += '<div class="entry note">Insert references to see them here.</div>';
            }

            refs.forEach(function(refId) {
                refData = allRefs[refId];

                if(refData) {
                    let tmp = document.createElement('div');
                    tmp.classList.add('entry')
                    tmp.setAttribute('data-ref', refId);
                    tmp.innerHTML = [refData.url, refData.author, refData.title, refData.year, (refData.publisher || refData.journal)].filter(function(x) {return x}).join(' - ');
                    tmp.onclick = function() { module.exports.editor.reference.showEditExternalRefDialog(tmp) };
                    bib.appendChild(tmp);
                }
            });
        });
    },

    onKeyBackspace: function(e, editor) {
        var heading = editor.caret.getContextElement('h2', window.getSelection(), []),
            sectionIndex = editor.indexOf(editor.focusedSection());

        if(!heading || editor.caret.isCollapsedAndPositionedAtTheBeginningOf(heading, false)) {
            e.preventDefault();
        } else if(heading.innerText.length === 1) {
            document.execCommand('delete');
            editor.caret.positionIn(editor.sectionAt(sectionIndex).querySelector('h2'));
            e.preventDefault();
        } else if(heading.innerText.length === 0) {
            e.preventDefault();
        }
    },

    onFocus: function(el, editor, args) {
        var heading = el.querySelector('h2'),
            isCaretInsideSection = (editor.sectionAtCaretPostion() === el && editor.caret.getContextElement('h2')),
            hasBeenFocusedAfterSectionTypeChange = args.action === 'changeFocusedSectionType';

        if(hasBeenFocusedAfterSectionTypeChange || !isCaretInsideSection) {
            heading && editor.caret.positionIn(heading);
        }
    },

    setEditor: function(editor) {
        this.editor = editor;
        return this;
    }
});


/***/ }),

/***/ "../structured-text-editor/src/section_types/blockquote/blockquote_section_type.js":
/*!*****************************************************************************************!*\
  !*** ../structured-text-editor/src/section_types/blockquote/blockquote_section_type.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uuid = __webpack_require__(/*! uuid/v1 */ "../structured-text-editor/node_modules/uuid/v1.js");

var getSectionElement = function(existingSectionContent) {
    var el = document.createElement('bquote'),
        blockquoteEl = document.createElement('blockquote'),
        captionEl = document.createElement('citesrc');

    el.setAttribute('contenteditable', 'false')
    el.setAttribute('display-citesrc', 'Yes');
    el.id = uuid();
    el.setContenteditable = module.exports.setContenteditable;
    el.sectionType = module.exports;

    blockquoteEl.innerHTML = existingSectionContent;
    blockquoteEl.setAttribute('contenteditable', 'true');

    captionEl.innerHTML = 'citation source';

    el.appendChild(blockquoteEl);
    el.appendChild(captionEl);

    return el;
}

Object.assign(module.exports, {

    name: 'bquote',

    tagTransformations: {
      '/bquote/blockquote/div': '#content',
      '/bquote/blockquote/span': '#content',
      '/bquote/blockquote': '#text-content',
    },

    contentRules: {
        'bquote': {
            tagName: 'bquote',
            allowedAttributes: ['class', 'contenteditable', 'display-caption', 'id', 'reference'],
            allowedClassNames: ['focused'],
            allowedChildren: ['blockquote', 'citesrc'],
            allowedToBeRoot: true,
            buildEmptyElement: getSectionElement,
            deleteIfEmpty: false,
            buildAttributes: [
              {name: 'id', build: function() {return uuid()}},
              {name: 'display-caption', build: function() {return 'Yes'}}
            ]
        },
        'blockquote': {
            tagName: 'blockquote',
            allowedSuccessors: ['citesrc'],
            allowedAttributes: ['contenteditable'],
            allowedChildren: ['#text'],
        },
        'citesrc': {
            tagName: 'citesrc',
            allowedChildren: ['#text', 'reference',  'inlineequation'],
            deleteIfEmpty: false,
            pruneSpaces: true,
        }
    },

    enrichments: [],

    getOptions: function(sectionElement) {
        return [
            {
              name: 'displayCaption',
              displayName: 'Display Source',
              allowedValues: ['Yes', 'No'],
              defaultValue: sectionElement.getAttribute('display-caption') || 'Yes'
            }
        ]
    },

    onOptionsChange: function(opt, editor) {
        var section = editor.focusedSection();

        if(section) {
            if(opt.displayCaption === 'Yes' || opt.displayCaption === 'No') {
                section.setAttribute('display-caption', opt.displayCaption);
            }

            editor.replaceSectionWithHTML(section, section.outerHTML);
        }
    },

    getSectionElement: getSectionElement,
})


/***/ }),

/***/ "../structured-text-editor/src/section_types/code/code_section_type.js":
/*!*****************************************************************************!*\
  !*** ../structured-text-editor/src/section_types/code/code_section_type.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var HTMLRazor = __webpack_require__(/*! ../../../lib/html_razor/html_razor */ "../structured-text-editor/lib/html_razor/html_razor.js"),
    utils = __webpack_require__(/*! ../../../lib/pixelschubser/utils */ "../structured-text-editor/lib/pixelschubser/utils.js"),
    shared = __webpack_require__(/*! ../shared/shared */ "../structured-text-editor/src/section_types/shared/shared.js"),
    primsjs = __webpack_require__(/*! prismjs */ "../structured-text-editor/node_modules/prismjs/prism.js"),
    progLanguages = ["XML", "HTML", "MathML", "SVG", "CSS", "clike", "JavaScript"],
    progLanguagesShort = {'JavaScript': 'JS'},
    defaultLanguage = 'JavaScript',
    uuid = __webpack_require__(/*! uuid/v1 */ "../structured-text-editor/node_modules/uuid/v1.js");

var getSectionElement = function(existingSectionContent, params) {
    var el = document.createElement('pre'),
        codeEl = document.createElement('code'),
        captionEl = document.createElement('caption'),
        capitalizedLangauge;

    el.classList.add('code');
    el.setAttribute('contenteditable', 'false')
    el.setAttribute('display-caption', 'Yes');
    el.id = uuid();
    el.onKeyUp = module.exports.onKeyUp;
    el.onKeyDown = module.exports.onKeyDown;
    el.onKeyEnter = module.exports.onKeyEnter;
    el.onKeyTab = module.exports.onKeyTab;
    el.onKeyBackspace = module.exports.onKeyBackspace;
    el.onMarkupCleaningFinshed = module.exports.onMarkupCleaningFinshed;
    el.setContenteditable = module.exports.setContenteditable;
    el.sectionType = module.exports;

    codeEl.innerHTML = existingSectionContent;
    codeEl.setAttribute('contenteditable', 'true');

    captionEl.innerHTML = 'listing title';

    el.appendChild(codeEl);
    el.appendChild(captionEl);

    if(params && params[0]) {
        params[0] = params[0].toLowerCase();
        capitalizedLangauge = progLanguages.find(function(lan) {
            return lan.toLowerCase() === params[0];
        });
    }

    capitalizedLangauge = capitalizedLangauge || defaultLanguage;
    el.setAttribute('language', capitalizedLangauge);

    return el;
}

Object.assign(module.exports, {

    name: 'code',

    tagTransformations: {
      '/pre/code/div': '#content',
      '/pre/code/span': '#content',
      '/pre/code': '#text-content',
    },

    contentRules: {
        'pre': {
            tagName: 'pre',
            allowedAttributes: ['class', 'language', 'contenteditable', 'display-caption', 'id'],
            allowedClassNames: ['focused', 'code'],
            allowedChildren: ['code', 'caption'],
            allowedToBeRoot: true,
            buildEmptyElement: getSectionElement,
            deleteIfEmpty: false,
            buildAttributes: [
              {name: 'id', build: function() {return uuid()}},
              {name: 'language', build: function() {return defaultLanguage}},
              {name: 'display-caption', build: function() {return 'Yes'}}
            ]
        },
        'code': {
            tagName: 'code',
            allowedSuccessors: ['caption'],
            allowedAttributes: ['contenteditable'],
            allowedChildren: ['#text'],
        }
    },

    enrichments: [],

    getOptions: function(sectionElement) {
        return [
            {
              name: 'language',
              displayName: 'Syntax Highlighting for',
              allowedValues: progLanguages,
              defaultValue: sectionElement.getAttribute('language')
            },
            {
              name: 'displayCaption',
              displayName: 'Display Listing Caption',
              allowedValues: ['Yes', 'No'],
              defaultValue: sectionElement.getAttribute('display-caption') || 'Yes'
            }
        ]
    },

    onOptionsChange: function(opt, editor) {
        var section = editor.focusedSection();

        if(section) {
            if(opt['language']) {
                section.setAttribute('language', opt['language']);
            }

            if(opt.displayCaption === 'Yes' || opt.displayCaption === 'No') {
                section.setAttribute('display-caption', opt.displayCaption);
            }

            editor.replaceSectionWithHTML(section, section.outerHTML);
        }
    },

    getSectionElement: getSectionElement,

    onMarkupCleaningFinshed: function(sectionElement) {
        var codeEl = sectionElement.querySelector('code'), content, lan;

        if(!codeEl) { return }

        content = codeEl.innerHTML;
        lan = sectionElement.getAttribute('language');

        if(!lan || lan === 'true') {
            lan = defaultLanguage;
        }

        lan = lan.toLowerCase();
        content = HTMLRazor.prototype.strip(content);
        content = primsjs.highlight(content, primsjs.languages[lan], lan);
        sectionElement.querySelector('code').innerHTML = content;
    },

    getSectionTypeCaptionAnnotation: function(sectionElement) {
        var lan = sectionElement.getAttribute('language');

        if(progLanguagesShort[lan]) {
            return progLanguagesShort[lan];
        }

        return lan;
    },

    onKeyTab: function(e) {
        document.execCommand('insertText', false, '  ');
        e.preventDefault();
    },

    setContenteditable: function(shouldBeEditable, section) {
        var el = section.querySelector('code')
        if(el) {
            if(shouldBeEditable) {
                el.setAttribute('contenteditable', true);
            } else {
                el.removeAttribute('contenteditable');
            }
        }
    },

    onKeyUp: shared.onKeyUpForFreestyleSections,
    onKeyDown: shared.onKeyDownForFreestyleSections,
    onKeyBackspace: function(e, editor) {
        var caption = editor.caret.getContextElement('caption', window.getSelection(), []),
            sectionEl, sectionIndex;

        if(caption) {
            if(caption.innerText.length === 1) {
                sectionEl = caption.parentElement;
                sectionIndex = editor.indexOf(sectionEl);

                if(sectionIndex) {
                    document.execCommand('delete');

                    sectionEl = editor.sectionAt(sectionIndex);
                    caption = sectionEl && sectionEl.querySelector('caption');

                    if(caption) {
                        editor.caret.positionIn(caption);
                    }

                    e.preventDefault();
                }
            } else if(!caption.innerText || caption.innerText.length === 0 || editor.caret.isCollapsedAndPositionedAtTheBeginningOf(caption, false)) {
                e.preventDefault();
            }
        } else {
            shared.onKeyBackspaceForBackspaceDeletableSections(e, editor)
        }
    },
    onKeyEnter: shared.onKeyEnterForFreestyleSections
})


/***/ }),

/***/ "../structured-text-editor/src/section_types/footnotes/footnotes_section_type.js":
/*!***************************************************************************************!*\
  !*** ../structured-text-editor/src/section_types/footnotes/footnotes_section_type.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uuid = __webpack_require__(/*! uuid/v1 */ "../structured-text-editor/node_modules/uuid/v1.js"),
utils = __webpack_require__(/*! ../../../lib/pixelschubser/utils */ "../structured-text-editor/lib/pixelschubser/utils.js");

function getSectionElement() {
    var  el = document.createElement('footnotes'),
         heading = document.createElement('h2'),
         content = document.createElement('div');
    el.classList.add('footnotes');

    heading.classList.add('footnotes-heading');
    content.classList.add('footnotes-content');

    el.setAttribute('contenteditable', 'false');
    heading.setAttribute('contenteditable', 'true');
    content.setAttribute('contenteditable', 'false');

    heading.innerHTML = 'Footnotes';

    el.onKeyBackspace = module.exports.onKeyBackspace;
    el.sectionType = module.exports;

    el.appendChild(heading);
    el.appendChild(content);

    return el;
}

Object.assign(module.exports, {

    name: 'footnotes',

    editableElementSelector: 'h2',

    preferredCaretPositioning: 'end',

    contentRules: {
        'footnotes': {
            tagName: 'footnotes',
            allowedAttributes: ['class', 'contenteditable'],
            allowedClassNames: ['focused'],
            allowedChildren: ['footnotes-heading', 'footnotes-content'],
            allowedToBeRoot: true,
            deleteIfEmpty: false,
            doNotBreakOutRootElements: true,
            buildEmptyElement: getSectionElement
        },

        'footnotes-heading': {
            tagName: 'h2',
            className: 'footnotes-heading',
            allowedAttributes: ['id', 'class', 'contenteditable', 'unnumbered-heading'],
            allowedClassNames: ['footnotes-heading'],
            allowedChildren: ['#text'],
            pruneSpaces: true,
            buildAttributes: [
                {name: 'id', build: function() {return uuid()}},
                {name: 'unnumbered-heading', build: function() {return 'Yes'}}
            ]
        },

        'footnotes-content': {
            tagName: 'div',
            className: 'footnotes-content',
            allowedAttributes: ['class', 'contenteditable'],
            allowedClassNames: ['footnotes-content'],
            allowedChildren: ['footnotes-entry'],
        },

        'footnotes-entry': {
            tagName: 'div',
            className: 'entry',
            allowedAttributes: ['class'],
            allowedClassNames: ['entry', 'note'],
            allowedChildren: ['#text'],
        }
    },

    enrichments: [],

    getSectionElement: getSectionElement,

    getOptions: function(sectionElement) {
        return [
            {
                name: 'numberedHeading',
                displayName: 'Should the heading be numbered',
                allowedValues: ['Yes', 'No'],
                defaultValue: sectionElement.querySelector('h2').getAttribute('unnumbered-heading') === 'Yes' ? 'No' : 'Yes'
            }
        ]
    },

    onOptionsChange: function(opt, editor) {
        var section = editor.focusedSection();
        if(opt.numberedHeading === 'Yes' || opt.numberedHeading === 'No') {
            section.querySelector('h2').setAttribute('unnumbered-heading', opt.numberedHeading === 'Yes' ? 'No' : 'Yes');
            self.editor.replaceSectionWithHTML(section, section.outerHTML);
        }
    },

    onEditorContentChanged: function(modificationLog) {
        if(!modificationLog.mightIncludeFootnoteUpdates && !modificationLog.mightIncludeFootnotesSectionUpdates) {
            return;
        }

        var notesSections = document.querySelectorAll('footnotes .footnotes-content'),
            notes = document.querySelectorAll('.footnote'),
            noteIndex, tmp;

        notesSections.forEach(function(notesSection) {
            notesSection.innerHTML = '';

            if(notes.length === 0) {
                notesSection.innerHTML += '<div class="entry note">Insert footnotes to see them here.</div>';
            }

            noteIndex = 0;

            notes.forEach(function(note) {
                noteIndex++;
                tmp = document.createElement('div');
                tmp.classList.add('entry')
                tmp.innerHTML = noteIndex + ') ' + utils.attributeSaveStringToHTMLEncoded(note.getAttribute('data-note'));
                tmp.onclick = function() {
                    module.exports.showFootnoteEditDialog(note);

                };
                notesSection.appendChild(tmp);
            });
        });
    },

    showFootnoteEditDialog: function(note) {
        var self = this,
            section = self.editor.sectionByChildNode(note),
            noteIndex,
            args = [{
            name: 'note',
            placeholder: 'footnote',
            displayName: 'Footnote',
            largetext: true,
            defaultValue: utils.attributeSaveStringToString(note.dataset.note)
        }];

        if(!section) {
            return;
        }

        self.editor.displayModal(args, function(formData) {
            noteIndex = document.querySelectorAll('.footnote').indexOf(note),
            self.editor.unfreezeSelection(false);
            note = document.querySelectorAll('.footnote')[noteIndex];
            section = self.editor.sectionByChildNode(note);

            if(!formData.note) return;
            if(typeof formData.note !== 'string') return;
            if(formData.note.trim() === '') return;
            note.setAttribute('data-note', utils.stringToAttributeSaveString(formData.note));

            self.editor.replaceSectionWithHTML(section, section.outerHTML);
        });
    },

    onKeyBackspace: function(e, editor) {
        var heading = editor.caret.getContextElement('h2', window.getSelection(), []),
            sectionIndex = editor.indexOf(editor.focusedSection());

        if(!heading || editor.caret.isCollapsedAndPositionedAtTheBeginningOf(heading, false)) {
            e.preventDefault();
        } else if(heading.innerText.length === 1) {
            document.execCommand('delete');
            editor.caret.positionIn(editor.sectionAt(sectionIndex).querySelector('h2'));
            e.preventDefault();
        } else if(heading.innerText.length === 0) {
            e.preventDefault();
        }
    },

    onFocus: function(el, editor, args) {
        var toCHeading = el.querySelector('h2'),
            isCaretInsideSection = (editor.sectionAtCaretPostion() === el && editor.caret.getContextElement('h2')),
            hasBeenFocusedAfterSectionTypeChange = args.action === 'changeFocusedSectionType';

        if(hasBeenFocusedAfterSectionTypeChange || !isCaretInsideSection) {
            toCHeading && editor.caret.positionIn(toCHeading);
        }
    },

    setEditor: function(editor) {
        this.editor = editor;
        return this;
    }
});


/***/ }),

/***/ "../structured-text-editor/src/section_types/formula/formula_section_type.js":
/*!***********************************************************************************!*\
  !*** ../structured-text-editor/src/section_types/formula/formula_section_type.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var code2dia = __webpack_require__(/*! ../shared/code2dia_section_type */ "../structured-text-editor/src/section_types/shared/code2dia_section_type.js"),
    // katex = require('katex'), // make sure to load <script src="./katex.js" defer></script> in your html
    latex = __webpack_require__(/*! prismjs/components/prism-latex */ "../structured-text-editor/node_modules/prismjs/components/prism-latex.js"),
    render;

render = function(renderEl, content) {
    if(content.trim().length === 0) {
        renderEl.innerHTML = 'Write a LaTeX formula into the input field above <span class="arrow">&#10548;</span>';
    } else {
        renderEl.innerHTML = '';
        katex.render(content, renderEl, {
            throwOnError: false,
            displayMode: true
        });
    }
}

module.exports = code2dia(render, 'formula', 'latex', 'equation caption')


/***/ }),

/***/ "../structured-text-editor/src/section_types/heading/heading1.js":
/*!***********************************************************************!*\
  !*** ../structured-text-editor/src/section_types/heading/heading1.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uuid = __webpack_require__(/*! uuid/v1 */ "../structured-text-editor/node_modules/uuid/v1.js"),
    paragraphSectionType = __webpack_require__(/*! ../paragraph/paragraph_section_type */ "../structured-text-editor/src/section_types/paragraph/paragraph_section_type.js");

var getSectionElement = function(existingSectionContent) {
    var el = document.createElement('h1');
    el.innerHTML = existingSectionContent || '';
    el.id = uuid();
    el.onKeyUp = module.exports.onKeyUp;
    el.onKeyDown = module.exports.onKeyDown;
    el.onKeyEnter = module.exports.onKeyEnter;
    return el;
}

module.exports = {

    name: 'h1',

    contentRules: {
        'h1': {
            tagName: 'h1',
            allowedAttributes: ['class', 'id'],
            allowedChildren: ['#text', 'inlineequation'],
            allowedClassNames: ['focused'],
            pruneSpaces: true,
            allowedToBeRoot: true,
            buildEmptyElement: getSectionElement,
            buildAttributes: [{name: 'id', build: function() {return uuid()}}]
        }
    },

    enrichments: [],

    onKeyUp: paragraphSectionType.onKeyUp,
    onKeyDown: paragraphSectionType.onKeyDown,
    onKeyEnter: function(e, editor) {
        if(editor.caret.isCollapsedAndPositionedAtTheBeginningOf(editor.focusedSection())) {
            if(editor.focusedSection()) {
                editor.addNewSectionNextTo(editor.focusedSection(), 'before')
            }
        } else {
            editor.caret.insertLineBreak();
        }

        e.preventDefault();
    },

    getSectionElement: getSectionElement,
}


/***/ }),

/***/ "../structured-text-editor/src/section_types/heading/heading2.js":
/*!***********************************************************************!*\
  !*** ../structured-text-editor/src/section_types/heading/heading2.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uuid = __webpack_require__(/*! uuid/v1 */ "../structured-text-editor/node_modules/uuid/v1.js"),
    paragraphSectionType = __webpack_require__(/*! ../paragraph/paragraph_section_type */ "../structured-text-editor/src/section_types/paragraph/paragraph_section_type.js"),
    h1SectionType = __webpack_require__(/*! ./heading1.js */ "../structured-text-editor/src/section_types/heading/heading1.js");

var getSectionElement = function(existingSectionContent, params) {
    var el = document.createElement('h2');

    if(params && (params.includes('abstract') || params.includes('Abstract'))) {
        el.setAttribute('role', 'Abstract')
    } else if(params && (params.includes('declaration') || params.includes('Declaration'))) {
        el.setAttribute('role', 'Declaration')
    } else if(params && (params.includes('appendix') || params.includes('Appendix'))) {
        el.setAttribute('role', 'Appendix')
    } else if(params && (params.includes('acknowledgement') || params.includes('Acknowledgement'))) {
        el.setAttribute('role', 'Acknowledgement')
    }

    el.innerHTML = existingSectionContent || '';
    el.onKeyUp = module.exports.onKeyUp;
    el.onKeyDown = module.exports.onKeyDown;
    el.onKeyEnter = module.exports.onKeyEnter;
    el.id = uuid();
    el.sectionType = module.exports;
    return el;
}

module.exports = {

    name: 'h2',

    contentRules: {
        'h2': {
            tagName: 'h2',
            allowedAttributes: ['class', 'id', 'role'],
            allowedChildren: ['#text', 'inlineequation'],
            allowedClassNames: ['focused'],
            pruneSpaces: true,
            allowedToBeRoot: true,
            buildEmptyElement: getSectionElement,
            buildAttributes: [{name: 'id', build: function() {return uuid()}}]
        }
    },

    enrichments: [],

    getOptions: function(sectionElement) {
        return [
            {
              name: 'role',
              displayName: 'Assign a special role to the heading',
              allowedValues: ['None', 'Abstract', 'Declaration', 'Appendix', 'Acknowledgement'],
              defaultValue: sectionElement.getAttribute('role') || 'None'
            }
        ]
    },

    onOptionsChange: function(opt, editor) {
        var section = editor.focusedSection();

        if(section) {
            if(opt['role']) {
                section.setAttribute('role', opt['role']);
            }

            editor.replaceSectionWithHTML(section, section.outerHTML);
        }
    },

    getSectionTypeCaptionAnnotation: function(sectionElement) {
        var role = sectionElement.getAttribute('role');
        if(role === 'None') {
            role = null;
        }

        if(role === 'Acknowledgement') {
            return 'Ack.'
        }

        if(role === 'Declaration') {
            return 'Decl.'
        }

        return role;
    },

    onKeyUp: paragraphSectionType.onKeyUp,
    onKeyDown: paragraphSectionType.onKeyDown,
    onKeyEnter: h1SectionType.onKeyEnter,

    getSectionElement: getSectionElement,
}


/***/ }),

/***/ "../structured-text-editor/src/section_types/heading/heading3.js":
/*!***********************************************************************!*\
  !*** ../structured-text-editor/src/section_types/heading/heading3.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uuid = __webpack_require__(/*! uuid/v1 */ "../structured-text-editor/node_modules/uuid/v1.js"),
    paragraphSectionType = __webpack_require__(/*! ../paragraph/paragraph_section_type */ "../structured-text-editor/src/section_types/paragraph/paragraph_section_type.js"),
    h1SectionType = __webpack_require__(/*! ./heading1.js */ "../structured-text-editor/src/section_types/heading/heading1.js");

var getSectionElement = function(existingSectionContent) {
    var el = document.createElement('h3');
    el.innerHTML = existingSectionContent || '';
    el.onKeyUp = module.exports.onKeyUp;
    el.onKeyDown = module.exports.onKeyDown;
    el.onKeyEnter = module.exports.onKeyEnter;
    el.id = uuid();
    return el;
}

module.exports = {

    name: 'h3',

    contentRules: {
        'h3': {
            tagName: 'h3',
            allowedAttributes: ['class', 'id'],
            allowedChildren: ['#text', 'inlineequation'],
            allowedClassNames: ['focused'],
            pruneSpaces: true,
            allowedToBeRoot: true,
            buildEmptyElement: getSectionElement,
            buildAttributes: [{name: 'id', build: function() {return uuid()}}]
        }
    },

    enrichments: [],

    onKeyUp: paragraphSectionType.onKeyUp,
    onKeyDown: paragraphSectionType.onKeyDown,
    onKeyEnter: h1SectionType.onKeyEnter,

    getSectionElement: getSectionElement,
}


/***/ }),

/***/ "../structured-text-editor/src/section_types/heading/heading4.js":
/*!***********************************************************************!*\
  !*** ../structured-text-editor/src/section_types/heading/heading4.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uuid = __webpack_require__(/*! uuid/v1 */ "../structured-text-editor/node_modules/uuid/v1.js"),
    paragraphSectionType = __webpack_require__(/*! ../paragraph/paragraph_section_type */ "../structured-text-editor/src/section_types/paragraph/paragraph_section_type.js"),
    h1SectionType = __webpack_require__(/*! ./heading1.js */ "../structured-text-editor/src/section_types/heading/heading1.js");

var getSectionElement = function(existingSectionContent) {
    var el = document.createElement('h4');
    el.innerHTML = existingSectionContent || '';
    el.onKeyUp = module.exports.onKeyUp;
    el.onKeyDown = module.exports.onKeyDown;
    el.onKeyEnter = module.exports.onKeyEnter;
    el.id = uuid();
    return el;
}

module.exports = {

    name: 'h4',

    contentRules: {
        'h4': {
            tagName: 'h4',
            allowedAttributes: ['class', 'id'],
            allowedChildren: ['#text', 'inlineequation'],
            allowedClassNames: ['focused'],
            pruneSpaces: true,
            allowedToBeRoot: true,
            buildEmptyElement: getSectionElement,
            buildAttributes: [{name: 'id', build: function() {return uuid()}}]
        }
    },

    enrichments: [],

    onKeyUp: paragraphSectionType.onKeyUp,
    onKeyDown: paragraphSectionType.onKeyDown,
    onKeyEnter: h1SectionType.onKeyEnter,

    getSectionElement: getSectionElement,
}


/***/ }),

/***/ "../structured-text-editor/src/section_types/heading/heading5.js":
/*!***********************************************************************!*\
  !*** ../structured-text-editor/src/section_types/heading/heading5.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uuid = __webpack_require__(/*! uuid/v1 */ "../structured-text-editor/node_modules/uuid/v1.js"),
    paragraphSectionType = __webpack_require__(/*! ../paragraph/paragraph_section_type */ "../structured-text-editor/src/section_types/paragraph/paragraph_section_type.js"),
    h1SectionType = __webpack_require__(/*! ./heading1.js */ "../structured-text-editor/src/section_types/heading/heading1.js");

var getSectionElement = function(existingSectionContent) {
    var el = document.createElement('h5');
    el.innerHTML = existingSectionContent || '';
    el.onKeyUp = module.exports.onKeyUp;
    el.onKeyDown = module.exports.onKeyDown;
    el.onKeyEnter = module.exports.onKeyEnter;
    el.id = uuid();
    return el;
}

module.exports = {

    name: 'h5',

    contentRules: {
        'h5': {
            tagName: 'h5',
            allowedAttributes: ['class', 'id'],
            allowedChildren: ['#text', 'inlineequation'],
            allowedClassNames: ['focused'],
            pruneSpaces: true,
            allowedToBeRoot: true,
            buildEmptyElement: getSectionElement,
            buildAttributes: [{name: 'id', build: function() {return uuid()}}]
        }
    },

    enrichments: [],

    onKeyUp: paragraphSectionType.onKeyUp,
    onKeyDown: paragraphSectionType.onKeyDown,
    onKeyEnter: h1SectionType.onKeyEnter,

    getSectionElement: getSectionElement,
}


/***/ }),

/***/ "../structured-text-editor/src/section_types/image/image_section_type.js":
/*!*******************************************************************************!*\
  !*** ../structured-text-editor/src/section_types/image/image_section_type.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var chooseFileBtnCounter = 0,
    imageSectionType,
    uuid = __webpack_require__(/*! uuid/v1 */ "../structured-text-editor/node_modules/uuid/v1.js");

var buildEmptyImgPlacehoder = function() {
    var imgPlaceholder = document.createElement('span'),
        emptyImage = document.createElement('i'),
        chooseFileLabel = document.createElement('label'),
        chooseFileBtn = document.createElement('input'),
        chooseFileBtnId = 'chooseFileBtn' + chooseFileBtnCounter++;

    emptyImage.classList.add('empty-image');
    chooseFileBtn.classList.add('choose-img-btn');
    chooseFileBtn.setAttribute('type', 'file');
    chooseFileBtn.setAttribute('id', chooseFileBtnId);

    chooseFileLabel.classList.add('choose-img-btn-label');
    chooseFileLabel.innerHTML = 'Click to Import Image (or drag and drop it)';

    imgPlaceholder.setAttribute('contenteditable', false);
    imgPlaceholder.classList.add('image-img-placeholder');
    imgPlaceholder.appendChild(chooseFileLabel);
    imgPlaceholder.appendChild(chooseFileBtn);
    imgPlaceholder.appendChild(emptyImage);

    var getImageOrPlaceholderByAChild = function(child) {
        if(!child) {
            return;
        }

        if(child.classList.contains('image-img-placeholder') || child.tagName === 'IMG') {
           return child;
        }

        return getImageOrPlaceholderByAChild(child.parentElement);
    }

    imgPlaceholder.onclick = function(e) {
        if(imageSectionType) {
            imageSectionType.editor.focusSection(e.target.parentElement)
        }

        chooseFileBtn.click()
    }

    imgPlaceholder.ondrop = chooseFileBtn.onchange = function(e) {
        e.preventDefault();

        var currentImg = getImageOrPlaceholderByAChild(e.target),
            sectionElement = currentImg.parentNode;

        if(!sectionElement || !document.body.contains(sectionElement)) {
            sectionElement = imageSectionType.editor.focusedSection();
            currentImg = sectionElement.querySelector('img') || sectionElement.querySelector('.image-img-placeholder')
        }

        currentImg.classList.remove('dragover');

        var files = e.target.files || e.dataTransfer.files;

        var img = document.createElement('img');
        var persistResult = imageSectionType.persistFile(files[0]);

        if(persistResult.then) {
            persistResult.then(url => img.src = url);
        } else {
            img.src = persistResult;
        }

        currentImg.parentElement.replaceChild(img, currentImg);
        img.ondrop = currentImg.ondrop;
        img.ondragover = currentImg.ondragover;
        img.ondragleave = currentImg.ondragleave;
        img.onclick = imgPlaceholder.onclick

        sectionElement.dispatchEvent(new CustomEvent('image-upload', {bubbles: true, detail: {url: img.src}}));
        sectionElement.dispatchEvent(new Event('input', {bubbles: true}));
    }

    imgPlaceholder.ondragover = function(e) { getImageOrPlaceholderByAChild(e.target).classList.add('dragover'); e.preventDefault(); }
    imgPlaceholder.ondragleave = function(e) { getImageOrPlaceholderByAChild(e.target).classList.remove('dragover'); e.preventDefault(); }

    return imgPlaceholder;
}

var getSectionElement = function(existingSectionContent) {
    var el = document.createElement('figure'),
        caption = document.createElement('figcaption');

    el.id = uuid();
    el.sectionType = imageSectionType;
    el.setAttribute('display-caption', 'Yes');
    caption.innerHTML = 'image title';
    el.appendChild(buildEmptyImgPlacehoder());
    el.appendChild(caption);
    el.onKeyBackspace = imageSectionType.onKeyBackspace;
    el.onKeyEnter = imageSectionType.onKeyEnter;

    return el;
}

imageSectionType = {

    name: 'img',

    contentRules: {
        'image': {
            tagName: 'figure',
            allowedAttributes: ['class', 'display-caption', 'id'],
            allowedClassNames: ['focused'],
            allowedChildren: ['image-img', 'image-caption', 'image-img-placeholder'],
            childrenCardinality: {'image-caption': {max: 1}, 'image-img-placeholder': {max: 1}},
            allowedToBeRoot: true,
            deleteIfEmpty: false,
            buildEmptyElement: getSectionElement,
            buildAttributes: [
                {name: 'id', build: function() {return uuid()}},
                {name: 'display-caption', build: function() {return 'Yes'}}
            ]
        },
        'image-img': {
            tagName: 'img',
            allowedAttributes: ['src'],
            allowedSuccessors: ['image-caption'],
            allowedChildren: []
        },
        'image-img-placeholder': {
            tagName: 'span',
            className: 'image-img-placeholder',
            allowedAttributes: ['class', 'contenteditable'],
            allowedClassNames: ['image-img-placeholder'],
            allowedSuccessors: ['image-caption'],
            allowedChildren: ['empty-image', 'choose-img-btn', 'choose-img-btn-label'],
            deleteIfEmpty: false,
            buildEmptyElement: buildEmptyImgPlacehoder
        },
        'empty-image': {
            tagName: 'i',
            className: 'empty-image',
            allowedAttributes: ['class'],
            allowedClassNames: ['empty-image'],
            allowedChildren: [],
            deleteIfEmpty: false,
        },
        'choose-img-btn': {
            tagName: 'input',
            className: 'choose-img-btn',
            allowedAttributes: ['class', 'type', 'id'],
            allowedClassNames: ['choose-img-btn'],
            deleteIfEmpty: false
        },
        'choose-img-btn-label': {
            tagName: 'label',
            className: 'choose-img-btn-label',
            allowedClassNames: ['choose-img-btn-label'],
            allowedAttributes: ['class'],
            allowedChildren: ['#text']
        },
        'image-caption': {
            tagName: 'figcaption',
            allowedChildren: ['#text', 'reference', 'inlineequation'],
            allowedPredecessors: ['image-img-placeholder', 'image-img'],
            deleteIfEmpty: false,
            pruneSpaces: true
        }
    },

    enrichments: [],

    getOptions: function(sectionElement) {
        return [
            {
              name: 'displayCaption',
              displayName: 'Display Image Caption',
              allowedValues: ['Yes', 'No'],
              defaultValue: sectionElement.getAttribute('display-caption')
            }
        ]
    },

    onOptionsChange: function(opt, editor) {
        var section = editor.focusedSection();
        if(opt.displayCaption === 'Yes' || opt.displayCaption === 'No') {
            section.setAttribute('display-caption', opt.displayCaption);
        }
    },

    setEditor: function(editor) {
        this.editor = editor;
        return this;
    },

    persistFile: function(blob) {
        return URL.createObjectURL(blob);
    },

    onKeyBackspace: function(e, editor) {
        var caption = editor.caret.getContextElement('figcaption');
        if(caption.innerText === '') {
            e.preventDefault();
        }
    },

    onKeyEnter: function(e) {
        e.preventDefault();
    },

    onFocus: function(el, editor, args) {
        var caption = el.querySelector('figcaption'),
            isCaretInsideSection = (editor.sectionAtCaretPostion() === el && editor.caret.getContextElement('figcaption')),
            hasBeenFocusedAfterSectionTypeChange = args.action === 'changeFocusedSectionType';

        if(hasBeenFocusedAfterSectionTypeChange || !isCaretInsideSection) {
            caption && editor.caret.positionIn(caption);
        }
    },

    getSectionElement: getSectionElement
}

module.exports = imageSectionType;


/***/ }),

/***/ "../structured-text-editor/src/section_types/list/ordered_list_section_type.js":
/*!*************************************************************************************!*\
  !*** ../structured-text-editor/src/section_types/list/ordered_list_section_type.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var shared = __webpack_require__(/*! ../shared/shared */ "../structured-text-editor/src/section_types/shared/shared.js");
var unorderedListSectionType = __webpack_require__(/*! ./unordered_list_section_type */ "../structured-text-editor/src/section_types/list/unordered_list_section_type.js");

var getSectionElement = function(existingSectionContent) {
    var el = document.createElement('ol');
    el.onKeyUp = module.exports.onKeyUp;
    el.onKeyDown = module.exports.onKeyDown;
    el.onKeyEnter = module.exports.onKeyEnter;
    el.onKeyTab = module.exports.onKeyTab;
    el.onKeyBackspace = module.exports.onKeyBackspace;
    el.innerHTML = '<li>' + existingSectionContent + '</li>';
    return el;
}

module.exports = {

    name: 'ol',

    contentRules: {
        'ol': {
            tagName: 'ol',
            allowedAttributes: ['class'],
            allowedClassNames: ['focused'],
            allowedChildren: ['li', 'ol'],
            allowedToBeRoot: true,
            buildEmptyElement: getSectionElement
        },
        'li': {
            tagName: 'li',
            pruneSpaces: true,
            doNotBreakOutRootElements: true,
            allowedChildren: ['#text', 'link', 'b', 'i', 'u', 'reference', 'footnote', 'inlinecode', 'inlineequation'],
        }
    },

    enrichments: [],

    getSectionElement: getSectionElement,
    indentFocusedListItem: unorderedListSectionType.indentFocusedListItem,
    onKeyUp: unorderedListSectionType.onKeyUp,
    onKeyDown: unorderedListSectionType.onKeyDown,
    onKeyBackspace: unorderedListSectionType.onKeyBackspace,
    onKeyEnter: function(e) {},
    onKeyTab: unorderedListSectionType.onKeyTab
}


/***/ }),

/***/ "../structured-text-editor/src/section_types/list/unordered_list_section_type.js":
/*!***************************************************************************************!*\
  !*** ../structured-text-editor/src/section_types/list/unordered_list_section_type.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var shared = __webpack_require__(/*! ../shared/shared */ "../structured-text-editor/src/section_types/shared/shared.js"),
    paragraphSectionType = __webpack_require__(/*! ../paragraph/paragraph_section_type */ "../structured-text-editor/src/section_types/paragraph/paragraph_section_type.js");

var getSectionElement = function(existingSectionContent) {
    var el = document.createElement('ul');
    el.onKeyUp = module.exports.onKeyUp;
    el.onKeyDown = module.exports.onKeyDown;
    el.onKeyEnter = module.exports.onKeyEnter;
    el.onKeyTab = module.exports.onKeyTab;
    el.onKeyBackspace = module.exports.onKeyBackspace;
    el.innerHTML = '<li>' + existingSectionContent + '</li>';
    return el;
}

module.exports = {

    name: 'ul',

    contentRules: {
        'ul': {
            tagName: 'ul',
            allowedAttributes: ['class'],
            allowedClassNames: ['focused'],
            allowedChildren: ['li', 'ul'],
            allowedToBeRoot: true,
            buildEmptyElement: getSectionElement
        },
        // The li content rules are defined in the ordered list section type
        // 'li': {}
    },

    enrichments: [],

    getSectionElement: getSectionElement,

    onKeyUp: paragraphSectionType.onKeyUp,
    onKeyDown: paragraphSectionType.onKeyDown,

    onKeyBackspace: function(e, editor) {
        var focusedSection = editor.focusedSection(),
            upperSection,
            allListItems,
            targetListItem = editor.caret.getContextElement('li'),
            targetListItemIndex,
            upperListItem;

        if(targetListItem && targetListItem.innerText.trim() === '') {
            upperSection = focusedSection.previousSibling,
            allListItems = focusedSection.querySelectorAll('li'),
            targetListItemIndex = allListItems.indexOf(targetListItem),
            upperListItem = allListItems[targetListItemIndex-1];

            if(upperListItem) {
                editor.caret.positionIn(upperListItem);
                targetListItem.remove();
                editor.replaceSectionWithHTML(focusedSection, focusedSection.outerHTML);
                e.preventDefault();
            } else if(upperSection) {
                targetListItem.remove();
                editor.replaceSectionWithHTML(focusedSection, focusedSection.outerHTML);
                editor.caret.positionIn(upperSection);
                e.preventDefault();
            } else {
                e.preventDefault();
            }
        }
    },

    onKeyEnter: function(e) {},
    onKeyTab: function(e, editor)  {
        if(!e.shiftKey) {
            module.exports.indentFocusedListItem(editor)
        } else {
            document.execCommand('outdent');
        }

        e.preventDefault();
    },

    indentFocusedListItem: function (editor) {
        var targetListItem = editor.caret.getContextElement('li'),
            previousListItem, nextListItem, parentElement,
            isTargetListItemEmpty = targetListItem.innerText === '';

        if(targetListItem) {
            previousListItem = targetListItem.previousSibling;
            nextListItem = targetListItem.nextSibling;
            parentElement = targetListItem.parentElement;
        }

        document.execCommand('indent');

        if(isTargetListItemEmpty) {
            if(previousListItem && previousListItem.nextSibling) {
                editor.caret.positionIn(previousListItem.nextSibling);
            } else if(nextListItem && nextListItem.previousSibling) {
                editor.caret.positionIn(nextListItem.previousSibling);
            } else if(!previousListItem && !nextListItem && parentElement && parentElement.firstChild) {
                editor.caret.positionIn(parentElement.firstChild);
            }
        }
    }
}


/***/ }),

/***/ "../structured-text-editor/src/section_types/mermaid/mermaid_section_type.js":
/*!***********************************************************************************!*\
  !*** ../structured-text-editor/src/section_types/mermaid/mermaid_section_type.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var code2dia = __webpack_require__(/*! ../shared/code2dia_section_type */ "../structured-text-editor/src/section_types/shared/code2dia_section_type.js"),
    // mermaid = require('mermaid'), // make sure to load <script src="./mermaid.js" defer></script> in your html
    render;

function docReady(fn) {
    if (document.readyState === "complete" || document.readyState === "interactive") {
        setTimeout(fn, 1);
    } else {
        document.addEventListener("DOMContentLoaded", fn);
    }
}

docReady(function() {
    mermaid.initialize({ startOnLoad: false, 'font-size': '10px' })
})

render = function(renderEl, content) {
    var tmpContainer, id;

    if(content.trim().length === 0) {
        renderEl.innerHTML = 'Write some mermaid here <span class="arrow">&#10548;</span>';
    } else {
        renderEl.id = renderEl.id || 'test2';
        id = 'r' + renderEl.parentElement.id;
        renderEl.innerHTML = '';
        renderEl.classList.add('mermaid');

        try {
            mermaid.render(id, content, (re) => {
                renderEl.innerHTML = re;
            });
        } catch (ex) {
            renderEl.innerHTML = ex.message.replace(/\n/g, '<br/>');
        }

        tmpContainer = document.getElementById('d' + id);
        if(tmpContainer) {
            tmpContainer.remove();
        }
    }
}

module.exports = code2dia(render, 'mermaid', 'latex', 'image title')


/***/ }),

/***/ "../structured-text-editor/src/section_types/paragraph/paragraph_section_type.js":
/*!***************************************************************************************!*\
  !*** ../structured-text-editor/src/section_types/paragraph/paragraph_section_type.js ***!
  \***************************************************************************************/
/***/ ((module) => {

var getSectionElement = function(existingSectionContent) {
    existingSectionContent = existingSectionContent || '';
    existingSectionContent = existingSectionContent.replace(/<caption>.*?<\/caption>/, '');

    var el = document.createElement('p');
    el.innerHTML = existingSectionContent;
    el.onKeyUp = module.exports.onKeyUp;
    el.onKeyDown = module.exports.onKeyDown;
    return el;
}

module.exports = {

    name: 'p',

    contentRules: {
        'p': {
            tagName: 'p',
            allowedAttributes: ['class'],
            allowedClassNames: ['focused'],
            allowedChildren: ['#text', 'b', 'i', 'u', 'link', 'footnote', 'reference', 'inlinecode', 'inlineequation'],
            pruneSpaces: true,
            allowedToBeRoot: true,
            buildEmptyElement: getSectionElement
        }
    },

    enrichments: [],

    onKeyUp: function(e, editor) {
        if(editor.caret.isCollapsedAndPositionedAtTheFirstLineOf(editor.focusedSection())) {
            editor.moveCaretOneSectionUp('end');
            e.preventDefault();
        }
    },

    onKeyDown: function(e, editor) {
        if(editor.caret.isCollapsedAndPositionedAtTheLastLineOf(editor.focusedSection())) {
            editor.moveCaretOneSectionDown('preferredOrBeginning');
            e.preventDefault();
        }
    },

    getSectionElement: getSectionElement,
}


/***/ }),

/***/ "../structured-text-editor/src/section_types/shared/code2dia_section_type.js":
/*!***********************************************************************************!*\
  !*** ../structured-text-editor/src/section_types/shared/code2dia_section_type.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var HTMLRazor = __webpack_require__(/*! ../../../lib/html_razor/html_razor */ "../structured-text-editor/lib/html_razor/html_razor.js"),
    throttle = __webpack_require__(/*! ../../../lib/throttle/throttle */ "../structured-text-editor/lib/throttle/throttle.js"),
    codeSectionType = __webpack_require__(/*! ../code/code_section_type */ "../structured-text-editor/src/section_types/code/code_section_type.js"),
    primsjs = __webpack_require__(/*! prismjs */ "../structured-text-editor/node_modules/prismjs/prism.js"),
    uuid = __webpack_require__(/*! uuid/v1 */ "../structured-text-editor/node_modules/uuid/v1.js");

module.exports = function(render, tagName, syntaxHighlighting, defaultCaption) {
    var sectionType = {};

    var getSectionElement = function(existingSectionContent, directives, rule) {
        var el = document.createElement(rule.tagName),
            pre = document.createElement('pre')
            caption = document.createElement('caption'),
            inputEl = document.createElement('code');

        caption.classList.add('m2dia-caption');
        inputEl.classList.add('m2dia-code');
        pre.classList.add('m2dia-pre');

        caption.innerHTML = rule.defaultCaption || 'caption';

        pre.appendChild(inputEl);
        el.appendChild(pre);
        el.appendChild(caption);
        el.setAttribute('display-caption', 'Yes');
        el.classList.add(rule.tagName);
        el.classList.add('m2dia');
        el.id = uuid();

        el.onFocus = sectionType.onFocus;
        el.onKeyUp = sectionType.onKeyUp;
        el.onKeyDown = sectionType.onKeyDown;
        el.onKeyEnter = sectionType.onKeyEnter;
        el.onKeyTab = sectionType.onKeyTab;
        el.onKeyBackspace = sectionType.onKeyBackspace;
        el.onMarkupCleaningFinshed = sectionType.onMarkupCleaningFinshed;
        el.setContenteditable = sectionType.setContenteditable;
        el.sectionType = sectionType;

        return el;
    };

    Object.assign(sectionType, {
        name: tagName,

        contentRules: {
            'm2dia-pre': {
                tagName: 'pre',
                className: 'm2dia-pre',
                allowedAttributes: ['class'],
                allowedClassNames: ['m2dia-pre'],
                allowedChildren: ['m2dia-code'],
            },
            'm2dia-code': {
                tagName: 'code',
                className: 'm2dia-code',
                allowedClassNames: ['m2dia-code'],
                allowedAttributes: ['class'],
                allowedChildren: ['#text'],
            },
            'm2dia-caption': {
                tagName: 'caption',
                allowedAttributes: ['class'],
                className: 'm2dia-caption',
                allowedClassNames: ['m2dia-caption'],
                allowedChildren: ['#text', 'reference', 'inlineequation'],
                deleteIfEmpty: false,
                pruneSpaces: true,
            }
        },

        enrichments: [],

        onMarkupCleaningFinshed: function(sectionElement) {
            var codeEl = sectionElement.querySelector('code'),
                preEl = sectionElement.querySelector('pre'),
                renderEl = sectionElement.querySelector('.render'),
                lan = syntaxHighlighting,
                content;

            if(!codeEl) { return }

            if(!renderEl) {
                renderEl = document.createElement('div');
                renderEl.classList.add('render');
                renderEl.setAttribute('contenteditable', false);
                sectionElement.insertBefore(renderEl, preEl.nextSibling);
            }

            content = codeEl.innerHTML;
            content = HTMLRazor.prototype.strip(content);

            throttle(700, _ => render(renderEl, content))()

            if(lan && primsjs.languages[lan]) {
                content = primsjs.highlight(content, primsjs.languages[lan], lan);
                sectionElement.querySelector('code').innerHTML = content; 
            }
        },

        onFocus: function(el, editor, args) {
            var isCaretInsideCaption = (editor.sectionAtCaretPostion() === el && editor.caret.getContextElement(['caption'])),
                code = el.querySelector('code');

            if(!isCaretInsideCaption && code) {
                editor.caret.positionIn(code);
            }
        },

        getOptions: function(sectionElement) {
            return [
                {
                  name: 'displayCaption',
                  displayName: 'Display Caption',
                  allowedValues: ['Yes', 'No'],
                  defaultValue: sectionElement.getAttribute('display-caption')
                }
            ]
        },

        onOptionsChange: function(opt, editor) {
            var section = editor.focusedSection();
            if(opt.displayCaption === 'Yes' || opt.displayCaption === 'No') {
                section.setAttribute('display-caption', opt.displayCaption);
            }
        },

        onKeyTab: codeSectionType.onKeyTab,
        onKeyUp: codeSectionType.onKeyUp,
        onKeyDown: codeSectionType.onKeyDown,
        onKeyBackspace: codeSectionType.onKeyBackspace,
        onKeyEnter: codeSectionType.onKeyEnter,
        getSectionElement: getSectionElement,
    });

    sectionType.contentRules[tagName] = {
        tagName: tagName,
        className: tagName,
        allowedAttributes: ['class', 'display-caption', 'id'],
        allowedClassNames: ['focused', tagName, 'm2dia'],
        allowedChildren: ['m2dia-caption', 'm2dia-pre'],
        pruneSpaces: true,
        allowedToBeRoot: true,
        deleteIfEmpty: false,
        buildEmptyElement: sectionType.getSectionElement,
        defaultCaption: defaultCaption,
        buildAttributes: [
            {name: 'display-caption', build: function() {return 'Yes'}},
            {name: 'id', build: function() {return uuid()}}
        ]
    };

    sectionType.tagTransformations = {};
    sectionType.tagTransformations['/'+tagName+'/div.render'] = '#no-content';
    sectionType.tagTransformations['/'+tagName+'/pre/code'] = '#text-content';

    return sectionType;
}


/***/ }),

/***/ "../structured-text-editor/src/section_types/shared/shared.js":
/*!********************************************************************!*\
  !*** ../structured-text-editor/src/section_types/shared/shared.js ***!
  \********************************************************************/
/***/ ((module) => {

module.exports = {
    onKeyUpForFreestyleSections: function(e, editor) {
        var focusedSection = editor.focusedSection(),
            upperSection = focusedSection.previousSibling;

        if(!upperSection) { return true; }

        if(editor.caret.isCollapsedAndPositionedAtTheBeginningOf(focusedSection)) {
            editor.placeCaretIntoSection(upperSection);

            // trigger the removal of empty sections
            editor.replaceSectionWithHTML(focusedSection, focusedSection.outerHTML);
            e.preventDefault();
        }
    },

    onKeyDownForFreestyleSections: function(e, editor) {
        var focusedSection = editor.focusedSection(),
            lowerSection = focusedSection.nextSibling;

        if(!lowerSection) { return true; }

        if(editor.caret.isCollapsedAndPositionedAtTheEndOf(focusedSection)) {
            editor.placeCaretIntoSection(lowerSection);

            // trigger the removal of empty sections
            editor.replaceSectionWithHTML(focusedSection, focusedSection.outerHTML);
            e.preventDefault();
        }
    },

    onKeyEnterForFreestyleSections: function(e, editor) {
        document.execCommand('insertHTML', false, '&NewLine;');

        var char = editor.caret.getPrecedingCharacter(editor.focusedSection());
        if(char !== '\n') {
            document.execCommand('insertHTML', false, '&NewLine;');
        }

        e.preventDefault();

        // We do not have to set the content of the editor because execcommand triggers
        // an input event which will handle the content change on the editor site.
    },

    onKeyBackspaceForBackspaceDeletableSections: function(e, editor) {
        var focusedSection = editor.focusedSection(),
            upperSection = focusedSection.previousSibling;

        if(!upperSection) { return true; }

        if(focusedSection.innerText.trim() === '') {
            editor.placeCaretIntoSection(upperSection);

            // trigger the removal of empty sections
            editor.replaceSectionWithHTML(focusedSection, focusedSection.outerHTML);
            e.preventDefault();
        }
    }
}


/***/ }),

/***/ "../structured-text-editor/src/section_types/table/table_section_type.js":
/*!*******************************************************************************!*\
  !*** ../structured-text-editor/src/section_types/table/table_section_type.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uuid = __webpack_require__(/*! uuid/v1 */ "../structured-text-editor/node_modules/uuid/v1.js");
var utils = __webpack_require__(/*! ../../../lib/pixelschubser/utils */ "../structured-text-editor/lib/pixelschubser/utils.js");
var lastFocusedCell, focusedCell, onUnfocusTimeout;

var getSectionElement = function(existingSectionContent) {
    var tableElement = document.createElement('table');
    tableElement.id = uuid();
    tableElement.sectionType = module.exports;
    tableElement.setAttribute('display-heading', 'Yes');
    tableElement.setAttribute('display-caption', 'Yes');

    tableElement.onKeyUp = module.exports.onKeyUp;
    tableElement.onKeyDown = module.exports.onKeyDown;
    tableElement.onKeyTab = module.exports.onKeyTab;
    tableElement.onKeyCombination = module.exports.onKeyCombination;
    tableElement.onKeyBackspace = module.exports.onKeyBackspace;
    tableElement.onKeyEnter = module.exports.onKeyEnter;
    tableElement.onSelectionChange = module.exports.onSelectionChange;
    tableElement.onUnfocus = module.exports.onUnfocus;
    tableElement.onWindowResize = module.exports.onWindowResize;

    tableElement.innerHTML = '<tbody>' +
                             '  <tr><td></td><td></td></tr>' +
                             '  <tr><td></td><td></td></tr>' +
                             '  <tr><td></td><td></td></tr>' +
                             '</tbody>' +
                             '<caption>table title</caption>';

    return tableElement;
}

var getAddRowBelowButton = function(editor) {
    var btn = document.querySelector('#tableAddRowBelowBtn');

    if(btn) {
        return btn;
    }

    var btn = document.createElement('span');
    btn.id = 'tableAddRowBelowBtn';
    btn.innerHTML = '<svg id="Layer_1" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" width="12.67" height="19.69" viewBox="0 0 12.67 19.69"><defs><style>.cls-1,.cls-3{fill:none;}.cls-1{stroke:#231f20;}.cls-1,.cls-2,.cls-3{stroke-miterlimit:10;}.cls-2{fill:#98cf8d;}.cls-2,.cls-3{stroke:#297027;}</style></defs><polyline class="cls-1" points="5.98 1.26 5.98 7.07 5.98 12.72 5.98 18.42"/><path class="cls-1" d="M327.38,413.59" transform="translate(-326.88 -401.94)"/><rect class="cls-1" x="0.5" y="1.26" width="10.97" height="17.17"/><polyline class="cls-1" points="11.47 7.07 5.98 7.07 0.5 7.07"/><polyline class="cls-1" points="11.47 12.72 5.98 12.72 0.5 12.72"/><path class="cls-2" d="M339.05,402.44c0,2.07,0,4.13-.05,6.19h-6.13v-6.19Z" transform="translate(-326.88 -401.94)"/><path class="cls-2" d="M339,408.63c0,2.25,0,4.5-.06,6.75h-6.07v-6.75Z" transform="translate(-326.88 -401.94)"/><path class="cls-2" d="M338.94,415.38c0,1.92,0,3.83,0,5.75h-6v-5.75Z" transform="translate(-326.88 -401.94)"/><line class="cls-3" x1="5.99" y1="6.69" x2="5.98" y2="6.69"/><line class="cls-3" x1="5.99" y1="13.44" x2="5.98" y2="13.44"/></svg>';

    btn.onmousedown = function(e) {
        setTimeout(function() {
            module.exports.addRow(undefined, editor);
        }, 100);
    }

    return btn;
}

var getAddRowAboveButton = function(editor) {
    var btn = document.querySelector('#tableAddRowAboveBtn');

    if(btn) {
        return btn;
    }

    var btn = document.createElement('span');
    btn.id = 'tableAddRowAboveBtn';
    btn.innerHTML = '<svg id="Layer_1" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" width="12.37" height="19.69" viewBox="0 0 12.37 19.69"><defs><style>.cls-1,.cls-3{fill:none;}.cls-1{stroke:#231f20;}.cls-1,.cls-2,.cls-3{stroke-miterlimit:10;}.cls-2{fill:#98cf8d;}.cls-2,.cls-3{stroke:#297027;}</style></defs><path class="cls-1" d="M300.83,397.41" transform="translate(-299.93 -385.76)"/><rect class="cls-1" x="0.9" y="1.26" width="10.97" height="17.17"/><polyline class="cls-1" points="6.38 1.26 6.38 7.07 6.38 12.72 6.38 18.42"/><polyline class="cls-1" points="11.87 7.07 6.38 7.07 0.9 7.07"/><polyline class="cls-1" points="11.87 12.72 6.38 12.72 0.9 12.72"/><path class="cls-2" d="M306.61,386.26c0,2.06,0,4.13-.05,6.19h-6.13v-6.19Z" transform="translate(-299.93 -385.76)"/><path class="cls-2" d="M306.56,392.45q0,3.38-.05,6.75h-6.08v-6.75Z" transform="translate(-299.93 -385.76)"/><path class="cls-2" d="M306.51,399.2c0,1.92,0,3.83,0,5.75h-6V399.2Z" transform="translate(-299.93 -385.76)"/><line class="cls-3" x1="0.5" y1="6.69" x2="0.49" y2="6.69"/><line class="cls-3" x1="0.5" y1="13.44" x2="0.49" y2="13.44"/></svg>';

    btn.onmousedown = function(e) {
        setTimeout(function() {
            module.exports.addRow(undefined, editor, true);
        }, 100);
    }

    return btn;
}

var getDeleteRowButton = function(editor) {
    var btn = document.querySelector('#tableDeleteRowBtn');

    if(btn) {
        return btn;
    }

    var btn = document.createElement('span');
    btn.id = 'tableDeleteRowBtn';
    btn.innerHTML = '<svg data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" width="17.96" height="19.69" viewBox="0 0 17.96 19.69"><defs></defs><rect class="cls-1-red" x="0.5" y="1.36" width="16.96" height="16.96"/><path class="cls-1-red" d="M316.57,393" transform="translate(-295.66 -385.76)"/><polyline class="cls-1-red" points="0.5 7.27 5.99 7.27 11.91 7.27 17.47 7.27"/><polyline class="cls-1-red" points="0.5 12.62 5.99 12.62 11.91 12.62 17.47 12.62"/><polyline class="cls-1-red" points="5.99 1.36 5.99 7.27 5.99 12.62 5.99 18.32"/><polyline class="cls-1-red" points="11.91 1.36 11.91 7.27 11.91 12.62 11.91 18.32"/><path class="cls-2-red" d="M307.86,386.26c0,2.06,0,4.13-.05,6.19h-6.13v-6.19Z" transform="translate(-295.66 -385.76)"/><path class="cls-2-red" d="M307.81,392.45q0,3.38-.05,6.75h-6.08v-6.75Z" transform="translate(-295.66 -385.76)"/><path class="cls-2-red" d="M307.76,399.2c0,1.92,0,3.83-.05,5.75h-6V399.2Z" transform="translate(-295.66 -385.76)"/><line class="cls-2-red" x1="6.02" y1="6.69" x2="6.01" y2="6.69"/><line class="cls-2-red" x1="6.02" y1="13.44" x2="6.01" y2="13.44"/></svg>';

    btn.onmousedown = function(e) {
        setTimeout(function() {
            module.exports.deleteRow(undefined, editor);
        }, 100);
    }

    return btn;
}

var getAddColumnLeftButton = function(editor) {
    var btn = document.querySelector('#tableAddColumnLeftBtn');

    if(btn) {
        return btn;
    }

    var btn = document.createElement('span');
    btn.id = 'tableAddColumnLeftBtn';
    btn.innerHTML = '<svg id="Layer_1" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" width="12.37" height="19.69" viewBox="0 0 12.37 19.69"><defs><style>.cls-1,.cls-3{fill:none;}.cls-1{stroke:#231f20;}.cls-1,.cls-2,.cls-3{stroke-miterlimit:10;}.cls-2{fill:#98cf8d;}.cls-2,.cls-3{stroke:#297027;}</style></defs><path class="cls-1" d="M300.83,397.41" transform="translate(-299.93 -385.76)"/><rect class="cls-1" x="0.9" y="1.26" width="10.97" height="17.17"/><polyline class="cls-1" points="6.38 1.26 6.38 7.07 6.38 12.72 6.38 18.42"/><polyline class="cls-1" points="11.87 7.07 6.38 7.07 0.9 7.07"/><polyline class="cls-1" points="11.87 12.72 6.38 12.72 0.9 12.72"/><path class="cls-2" d="M306.61,386.26c0,2.06,0,4.13-.05,6.19h-6.13v-6.19Z" transform="translate(-299.93 -385.76)"/><path class="cls-2" d="M306.56,392.45q0,3.38-.05,6.75h-6.08v-6.75Z" transform="translate(-299.93 -385.76)"/><path class="cls-2" d="M306.51,399.2c0,1.92,0,3.83,0,5.75h-6V399.2Z" transform="translate(-299.93 -385.76)"/><line class="cls-3" x1="0.5" y1="6.69" x2="0.49" y2="6.69"/><line class="cls-3" x1="0.5" y1="13.44" x2="0.49" y2="13.44"/></svg>';

    btn.onmousedown = function(e) {
        setTimeout(function() {
            module.exports.addColumn(undefined, editor, true);
        }, 100);
    }

    return btn;
}

var getAddColumnRightButton = function(editor) {
    var btn = document.querySelector('#tableAddColumnRightBtn');

    if(btn) {
        return btn;
    }

    var btn = document.createElement('span');
    btn.id = 'tableAddColumnRightBtn';
    btn.innerHTML = '<svg id="Layer_1" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" width="12.67" height="19.69" viewBox="0 0 12.67 19.69"><defs><style>.cls-1,.cls-3{fill:none;}.cls-1{stroke:#231f20;}.cls-1,.cls-2,.cls-3{stroke-miterlimit:10;}.cls-2{fill:#98cf8d;}.cls-2,.cls-3{stroke:#297027;}</style></defs><polyline class="cls-1" points="5.98 1.26 5.98 7.07 5.98 12.72 5.98 18.42"/><path class="cls-1" d="M327.38,413.59" transform="translate(-326.88 -401.94)"/><rect class="cls-1" x="0.5" y="1.26" width="10.97" height="17.17"/><polyline class="cls-1" points="11.47 7.07 5.98 7.07 0.5 7.07"/><polyline class="cls-1" points="11.47 12.72 5.98 12.72 0.5 12.72"/><path class="cls-2" d="M339.05,402.44c0,2.07,0,4.13-.05,6.19h-6.13v-6.19Z" transform="translate(-326.88 -401.94)"/><path class="cls-2" d="M339,408.63c0,2.25,0,4.5-.06,6.75h-6.07v-6.75Z" transform="translate(-326.88 -401.94)"/><path class="cls-2" d="M338.94,415.38c0,1.92,0,3.83,0,5.75h-6v-5.75Z" transform="translate(-326.88 -401.94)"/><line class="cls-3" x1="5.99" y1="6.69" x2="5.98" y2="6.69"/><line class="cls-3" x1="5.99" y1="13.44" x2="5.98" y2="13.44"/></svg>';

    btn.onmousedown = function(e) {
        setTimeout(function() {
            module.exports.addColumn(undefined, editor);
        }, 100);
    }

    return btn;
}

var getDeleteColumnButton = function(editor) {
    var btn = document.querySelector('#tableDeleteColumnBtn');

    if(btn) {
        return btn;
    }

    var btn = document.createElement('span');
    btn.id = 'tableDeleteColumnBtn';
    btn.innerHTML = '<svg data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" width="17.96" height="19.69" viewBox="0 0 17.96 19.69"><defs></defs><rect class="cls-1-red" x="0.5" y="1.36" width="16.96" height="16.96"/><path class="cls-1-red" d="M316.57,393" transform="translate(-295.66 -385.76)"/><polyline class="cls-1-red" points="0.5 7.27 5.99 7.27 11.91 7.27 17.47 7.27"/><polyline class="cls-1-red" points="0.5 12.62 5.99 12.62 11.91 12.62 17.47 12.62"/><polyline class="cls-1-red" points="5.99 1.36 5.99 7.27 5.99 12.62 5.99 18.32"/><polyline class="cls-1-red" points="11.91 1.36 11.91 7.27 11.91 12.62 11.91 18.32"/><path class="cls-2-red" d="M307.86,386.26c0,2.06,0,4.13-.05,6.19h-6.13v-6.19Z" transform="translate(-295.66 -385.76)"/><path class="cls-2-red" d="M307.81,392.45q0,3.38-.05,6.75h-6.08v-6.75Z" transform="translate(-295.66 -385.76)"/><path class="cls-2-red" d="M307.76,399.2c0,1.92,0,3.83-.05,5.75h-6V399.2Z" transform="translate(-295.66 -385.76)"/><line class="cls-2-red" x1="6.02" y1="6.69" x2="6.01" y2="6.69"/><line class="cls-2-red" x1="6.02" y1="13.44" x2="6.01" y2="13.44"/></svg>';

    btn.onmousedown = function(e) {
        setTimeout(function() {
            module.exports.deleteColumn(undefined, editor);
        }, 100);
    }

    return btn;
}

var getHorizontalControlsBar = function(editor) {
    var bar = document.querySelector('#horizontalTableControlsBar');

    if(bar) {
        return bar;
    }

    bar = document.createElement('div');
    bar.id = 'horizontalTableControlsBar';
    bar.classList.add('tableControlsBar');

    var arrow = document.createElement('div');
    arrow.classList.add('arrow')

    bar.appendChild(getAddColumnLeftButton(editor));
    bar.appendChild(getDeleteColumnButton(editor));
    bar.appendChild(getAddColumnRightButton(editor));
    bar.appendChild(arrow);

    bar.onclick = function(e) {
        e.preventDefault();
        return false;
    }

    document.body.appendChild(bar);

    return bar;
}

var getVerticalControlsBar = function(editor) {
    var bar = document.querySelector('#verticalTableControlsBar');

    if(bar) {
        return bar;
    }

    bar = document.createElement('div');
    bar.id = 'verticalTableControlsBar';
    bar.classList.add('tableControlsBar')

    var arrow = document.createElement('div');
    arrow.classList.add('arrow')

    bar.appendChild(getAddRowAboveButton(editor));
    bar.appendChild(getDeleteRowButton(editor));
    bar.appendChild(getAddRowBelowButton(editor));
    bar.appendChild(arrow);

    bar.onclick = function(e) {
        e.preventDefault();
        return false;
    }

    document.body.appendChild(bar);

    return bar;
}

Object.assign(module.exports, {

    name: 'table',

    contentRules: {
        'table': {
            tagName: 'table',
            allowedAttributes: ['class', 'display-heading', 'display-caption', 'id'],
            allowedClassNames: ['focused'],
            allowedChildren: ['tbody', 'caption'],
            childrenCardinality: {'caption': {max: 1}},
            allowedToBeRoot: true,
            deleteIfEmpty: false,
            buildEmptyElement: getSectionElement,
            buildAttributes: [
                {name: 'id', build: function() {return uuid()}},
                {name: 'display-heading', build: function() {return 'Yes'}},
                {name: 'display-caption', build: function() {return 'Yes'}}
            ]
        },
        'caption': {
            tagName: 'caption',
            allowedChildren: ['#text', 'reference', 'inlineequation'],
            deleteIfEmpty: false,
            pruneSpaces: true,
        },
        'tbody': {
            tagName: 'tbody',
            allowedSuccessors: ['caption'],
            allowedChildren: ['tr'],
        },
        'tr': {
            tagName: 'tr',
            allowedChildren: ['td'],
        },
        'td': {
            tagName: 'td',
            allowedChildren: ['#text', 'b', 'i', 'u', 'link', 'footnote', 'reference', 'inlinecode', 'inlineequation'],
            doNotBreakOutRootElements: true,
            pruneSpaces: true
        }
    },

    getOptions: function(sectionElement) {
        return [
            {
              name: 'displayHeading',
              displayName: 'Display Head Row',
              allowedValues: ['Yes', 'No'],
              defaultValue: sectionElement.getAttribute('display-heading')
            },
            {
              name: 'displayCaption',
              displayName: 'Display Table Caption',
              allowedValues: ['Yes', 'No'],
              defaultValue: sectionElement.getAttribute('display-caption')
            }
        ]
    },

    onFocus: function(el, editor, args) {
        var td = el.querySelector('td'),
            isCaretInsideTable = (editor.sectionAtCaretPostion() === el && editor.caret.getContextElement(['td', 'caption'])),
            hasBeenFocusedAfterSectionTypeChange = args.action === 'changeFocusedSectionType';

        if(hasBeenFocusedAfterSectionTypeChange || !isCaretInsideTable) {
            td && editor.caret.positionIn(td);
        }
    },

    onOptionsChange: function(opt, editor) {
        var section = editor.focusedSection();
        if(opt.displayHeading === 'Yes' || opt.displayHeading === 'No') {
            section.setAttribute('display-heading', opt.displayHeading);
        }

        if(opt.displayCaption === 'Yes' || opt.displayCaption === 'No') {
            section.setAttribute('display-caption', opt.displayCaption);
        }
    },

    getVerticalNeighborField: function(td, lowerNeighbor) {
        if(!td) { return }

        var xIndex = Array.prototype.indexOf.call(td.parentElement.children, td),
            neighborRow = td.parentNode && td.parentNode[(lowerNeighbor ? 'nextSibling' : 'previousSibling')],
            colspan, tmpField;

        if(!neighborRow) { return }

        for(var i=0; i<=xIndex;) {
            colspan = parseInt(neighborRow.children[i].getAttribute('colspan')) || 1;
            tmpField = neighborRow.children[i];
            i += colspan;
        }

        return tmpField;
    },

    getNextField: function(td) {
        if(td.nextSibling) {
            return td.nextSibling;
        }

        if(td.parentElement &&
           td.parentElement.nextSibling &&
           td.parentElement.nextSibling.children &&
           td.parentElement.nextSibling.children[0] &&
           td.parentElement.nextSibling.children[0].tagName === 'TD') {
             return td.parentElement.nextSibling.children[0];
        }
    },

    getPreviousField: function(td) {
        if(td.previousSibling) {
            return td.previousSibling;
        }

        if(td.parentElement &&
           td.parentElement.previousSibling &&
           td.parentElement.previousSibling.children &&
           td.parentElement.previousSibling.children[td.parentElement.previousSibling.children.length-1] &&
           td.parentElement.previousSibling.children[td.parentElement.previousSibling.children.length-1].tagName === 'TD') {
             return td.parentElement.previousSibling.children[td.parentElement.previousSibling.children.length-1];
        }
    },

    onKeyUp: function(e, editor) {
        var targetField = module.exports.getVerticalNeighborField(editor.caret.getContextElement('td'));

        if(targetField) {
            editor.caret.positionIn(targetField);
        } else {
            editor.placeCaretIntoSection(editor.focusedSection().previousSibling);
        }

        e.preventDefault();
    },

    onKeyDown: function(e, editor) {
        var targetField = module.exports.getVerticalNeighborField(editor.caret.getContextElement('td'), true);

        if(targetField) {
            editor.caret.positionIn(targetField);
        } else {
            editor.placeCaretIntoSection(editor.focusedSection().nextSibling);
        }

        e.preventDefault();
    },

    onKeyTab: function(e, editor) {

        var getTargetField = e.shiftKey ? module.exports.getPreviousField: module.exports.getNextField,
            targetField = getTargetField(editor.caret.getContextElement('td'));

        if(targetField) {
            editor.caret.positionIn(targetField);
        }

        e.preventDefault();
    },

    onKeyEnter: function(e) {
        e.preventDefault();
    },

    onWindowResize: function(editor) {
        module.exports.onSelectionChange(editor, true);
    },

    onSelectionChange: function(editor, force) {
        var cell = editor.caret.getContextElement('td');

        if(!cell) {
            this.onUnfocus(editor);
            return;
        }

        var table = cell.parentElement.parentElement.parentElement;

        if(focusedCell !== cell || force) {
            window.clearTimeout(onUnfocusTimeout);
            var hbar = getHorizontalControlsBar(editor);
            var vbar = getVerticalControlsBar(editor);
            var tablePos = utils.getElementPosition(table);
            var cellPos = utils.getElementPosition(cell);

            hbar.style.opacity = 1;
            hbar.style.top = (tablePos.y - 32) + 'px';
            hbar.style.left = Math.floor(cellPos.x + ((cell.offsetWidth/2)-(hbar.offsetWidth/2))) + 'px';

            vbar.style.opacity = 1;
            vbar.style.top = Math.floor(cellPos.y + ((cell.offsetHeight/2)-(vbar.offsetHeight/2))) + 'px';
            vbar.style.left = (tablePos.x - 30) + 'px';
        }

        focusedCell = cell;
    },

    onUnfocus: function(editor) {
        var hbar = getHorizontalControlsBar(editor);
        var vbar = getVerticalControlsBar(editor);

        lastFocusedCell = focusedCell;
        focusedCell = null;

        hbar.style.opacity = 0;
        vbar.style.opacity = 0;

        onUnfocusTimeout = window.setTimeout(function() {
            hbar.style.top = -1000 + 'px';
            hbar.style.left = -1000 + 'px';

            vbar.style.top = -1000 + 'px';
            vbar.style.left = -1000 + 'px';
        }, 100);
    },

    onKeyCombination: function(e, editor) {
        if((e.metaKey || e.ctrlKey) && !e.shiftKey && e.key === 'r') {
            module.exports.addRow(editor.caret.getContextElement('td'), editor);
            e.preventDefault();
        } else if((e.metaKey || e.ctrlKey) && !e.shiftKey && e.key === 'e') {
            module.exports.addColumn(editor.caret.getContextElement('td'), editor);
            e.preventDefault();
        } else if((e.metaKey || e.ctrlKey) && e.shiftKey && (e.key === 'e' || e.key === 'E') ) {
            module.exports.deleteColumn(editor.caret.getContextElement('td'), editor);
            e.preventDefault();
        } else if((e.metaKey || e.ctrlKey) && e.shiftKey && (e.key === 'r' || e.key === 'R') ) {
            module.exports.deleteRow(editor.caret.getContextElement('td'), editor);
            e.preventDefault();
        }
    },

    addRow: function(contextElement, editor, insertBefore) {
        var sel;
        if(!contextElement && !editor) { return }

        contextElement = contextElement || lastFocusedCell || editor.caret.getContextElement('td');

        if(!contextElement) {
            sel = window.getSelection();
            if(sel.anchorNode === sel.focusNode &&
               sel.anchorNode.tagName &&
               sel.anchorNode.tagName.toLowerCase() === 'tbody') {
                contextElement = sel.anchorNode.children[sel.anchorOffset].children[0];
            }
        }

        var colcount = contextElement.parentNode.children.length,
            currentTr = contextElement.parentNode,
            tbody = currentTr.parentNode,
            table = editor.sectionByChildNode(tbody),
            newTr = document.createElement('tr');

        for(let i=0; i<colcount; i++) {
            newTr.appendChild(document.createElement('td'));
        }

        tbody.insertBefore(newTr, insertBefore ? currentTr : currentTr.nextSibling);
        editor.replaceSectionWithHTML(table, table.outerHTML);
    },

    addColumn: function(contextElement, editor, insertLeft) {
        var sel;
        if(!contextElement && !editor) { return }
        contextElement = contextElement || lastFocusedCell || editor.caret.getContextElement('td');

        if(!contextElement) {
            sel = window.getSelection();
            if(sel.anchorNode === sel.focusNode &&
               sel.anchorNode.tagName &&
               sel.anchorNode.tagName.toLowerCase() === 'tr') {
                contextElement = sel.anchorNode.children[sel.anchorOffset];
            }
        }

        var colIndex = Array.prototype.indexOf.call(contextElement.parentNode.children, contextElement),
            tableRows = contextElement.parentNode.parentNode.children,
            table = contextElement.parentNode.parentNode.parentNode;

        Array.prototype.forEach.call(tableRows, function(tr) {
            tr.insertBefore(document.createElement('td'), insertLeft ? tr.children[colIndex] : tr.children[colIndex].nextSibling)
        });

        editor.replaceSectionWithHTML(table, table.outerHTML);
    },

    deleteColumn: function(contextElement, editor) {
        var sel;

        if(!contextElement && !editor) { return }

        contextElement = contextElement || lastFocusedCell || editor.caret.getContextElement('td');

        if(!contextElement) {
            sel = window.getSelection();
            if(sel.anchorNode === sel.focusNode &&
               sel.anchorNode.tagName &&
               sel.anchorNode.tagName.toLowerCase() === 'tr') {
                contextElement = sel.anchorNode.children[sel.anchorOffset];
            }
        }

        var columns = contextElement.parentNode.children,
            colIndex = Array.prototype.indexOf.call(columns, contextElement),
            tableRows = contextElement.parentNode.parentNode.children,
            table = contextElement.parentNode.parentNode.parentNode;

        if(columns.length <= 1) {
            return;
        }

        Array.prototype.forEach.call(tableRows, function(tr) {
            tr.removeChild(tr.children[colIndex])
        });
        editor.replaceSectionWithHTML(table, table.outerHTML);
    },

    deleteRow: function(contextElement, editor) {
        var sel, table;

        if(!contextElement && !editor) { return }

        contextElement = contextElement || lastFocusedCell || editor.caret.getContextElement('td');
        contextElement = contextElement.parentElement;

        if(!contextElement) {
            sel = window.getSelection();
            if(sel.anchorNode === sel.focusNode &&
               sel.anchorNode.tagName &&
               sel.anchorNode.tagName.toLowerCase() === 'tbody') {
                contextElement = sel.anchorNode.children[sel.anchorOffset];
            }
        }

        table = contextElement.parentNode.parentNode;

        if(contextElement.parentNode.children.length <= 1) {
            return;
        }

        contextElement.remove();
        editor.replaceSectionWithHTML(table, table.outerHTML);
    },

    onKeyBackspace: function(e, editor) {
        var sel,
            table = editor.caret.getContextElement('table'),
            caption = editor.caret.getContextElement('caption', window.getSelection(), []),
            td = editor.caret.getContextElement('td', window.getSelection(), []),
            inCaption = !!caption,
            el = td || caption,
            tableId = table.id,
            tr, trIndex, tdIndex;

        if(!el) return;

        if(el.innerText && el.innerText.length === 1) {
            if(!inCaption) {
                tr = td.parentElement;
                tdIndex = tr.children.indexOf(td);
                trIndex = tr.parentElement.children.indexOf(tr);
            }

            document.execCommand('delete');

            table = document.getElementById(tableId);

            if(!inCaption) {
                el = table.querySelector('tbody').children[trIndex].children[tdIndex];
            } else {
                el = table.querySelector('caption')
            }

            editor.caret.positionIn(el);

            e.preventDefault();
        } else if(!el.innerText || el.innerText.length === 0 || editor.caret.isCollapsedAndPositionedAtTheBeginningOf(caption, false)) {
            e.preventDefault();
        }
    },

    getSectionElement: getSectionElement
})


/***/ }),

/***/ "../structured-text-editor/src/section_types/toc/toc_section_type.js":
/*!***************************************************************************!*\
  !*** ../structured-text-editor/src/section_types/toc/toc_section_type.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var buildToC = __webpack_require__(/*! ../../../lib/toc_builder/toc_builder */ "../structured-text-editor/lib/toc_builder/toc_builder.js"),
    bibSectionType = __webpack_require__(/*! ../bibliographie/bibliographie_section_type */ "../structured-text-editor/src/section_types/bibliographie/bibliographie_section_type.js"),
    uuid = __webpack_require__(/*! uuid/v1 */ "../structured-text-editor/node_modules/uuid/v1.js");

function getSectionElement() {
    var  el = document.createElement('nav'),
         heading = document.createElement('h2');

    heading.setAttribute('contenteditable', 'true');
    heading.classList.add('toc-heading');
    heading.classList.add('no-toc-listing');
    heading.innerHTML = 'Table of Contents';

    el.onKeyBackspace = module.exports.onKeyBackspace;
    el.sectionType = module.exports;
    el.classList.add('toc');
    el.appendChild(heading);

    return el;
}

module.exports = {

    name: 'toc',

    preferredCaretPositioning: 'end',

    contentRules: {
        'toc': {
            tagName: 'nav',
            className: 'toc',
            allowedAttributes: ['class', 'contenteditable'],
            allowedClassNames: ['focused', 'toc'],
            allowedChildren: ['toc-heading'],
            allowedToBeRoot: true,
            deleteIfEmpty: false,
            buildEmptyElement: getSectionElement
        },
        'toc-heading': {
            tagName: 'h2',
            className: 'toc-heading',
            allowedAttributes: ['id', 'class', 'contenteditable', 'unnumbered-heading'],
            allowedClassNames: ['toc-heading', 'no-toc-listing'],
            allowedChildren: ['#text'],
            pruneSpaces: true,
            buildAttributes: [
                {name: 'id', build: function() {return uuid()}},
                {name: 'unnumbered-heading', build: function() {return 'Yes'}}
            ]
        },
    },

    enrichments: [],

    getSectionElement: getSectionElement,

    onKeyBackspace: bibSectionType.onKeyBackspace,

    onFocus: function(el, editor, args) {
        var toCHeading = el.querySelector('h2'),
            isCaretInsideSection = (editor.sectionAtCaretPostion() === el && editor.caret.getContextElement('h2')),
            hasBeenFocusedAfterSectionTypeChange = args.action === 'changeFocusedSectionType';

        if(hasBeenFocusedAfterSectionTypeChange || !isCaretInsideSection) {
            toCHeading && editor.caret.positionIn(toCHeading);
        }
    },

    onEditorContentChanged: function(modificationLog) {
        if(!modificationLog.mightIncludeHeadingUpdates && !modificationLog.mightIncludeTableOfContentUpdates) {
            return;
        }

        var tocSections = document.querySelectorAll('nav.toc'),
            newContent, tmpEl, toc;

        if(tocSections.length === 0) { return; }

        toc = buildToC(document.querySelector('.structured-text-editor'), {withLinks: true, startNumberingAtLevel: 2});
        toc.querySelectorAll('ol, li').forEach(function(entry) { entry.classList.add('toc') });
        toc.classList.add('toc');

        if(toc.innerHTML === '') {
            newContent = '<span class="hint">Insert some headings into your document to see a table of contents here.</span>';
        } else {
            newContent = toc.outerHTML;
        }

        tocSections.forEach(function(tocSection) {
            tocSection.summarizedContentLength = undefined;
            tmpEl = tocSection.querySelector('.toc-content');

            if(!tmpEl) {
                tmpEl = document.createElement('span');
                tmpEl.classList.add('toc-content');
                tocSection.appendChild(tmpEl);
            }

            tmpEl.setAttribute('contenteditable', 'false');

            if(tmpEl.innerHTML !== newContent) {
                tmpEl.innerHTML = newContent;
            }
        });
    }
}


/***/ }),

/***/ "../structured-text-editor/src/text_enrichment_control.js":
/*!****************************************************************!*\
  !*** ../structured-text-editor/src/text_enrichment_control.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Caret = __webpack_require__(/*! ./caret */ "../structured-text-editor/src/caret.js"),
    HTMLRazor = __webpack_require__(/*! ../lib/html_razor/html_razor */ "../structured-text-editor/lib/html_razor/html_razor.js"),
    utils = __webpack_require__(/*! ../lib/pixelschubser/utils */ "../structured-text-editor/lib/pixelschubser/utils.js"),
    // katex = require('katex'), // make sure to load <script src="./katex.js" defer></script> in your html
    latexCheatsheet = __webpack_require__(/*! ../assets/latex_cheatsheet */ "../structured-text-editor/assets/latex_cheatsheet.js"),
    DeclarativForm = __webpack_require__(/*! ../lib/declarativ_forms/src/declarativ_form */ "../structured-text-editor/lib/declarativ_forms/src/declarativ_form.js"),
    { getReferenceSourcesFields, syncAllSources } = __webpack_require__(/*! ./references/reference_sources */ "../structured-text-editor/src/references/reference_sources/index.js")

function TextEnrichmentControl(editor) {
    var self = this;

    this.caret = new Caret(editor);
    this.editor = editor;
    this.visible = false;
    this.domElement = document.createElement('div');
    this.domElement.className += ' textEnrichmentControl';
    this.hide();

    document.body.appendChild(this.domElement);

    document.addEventListener ("keydown", function (e) {
        if(e.code === 'Escape') {
            self.editor.unfreezeSelection();
            self.hide(true);
        }

        return true;
    });

    this.enrichments = [
        {className: 'italic',     command: 'italic',        diplayName: '<i>I</i>', allowedContext: ['p', 'table', 'ol', 'ul'], notAllowedContext: ['caption', 'nav']},
        {className: 'bold',       command: 'bold',          diplayName: '<b>B</b>', allowedContext: ['p', 'table', 'ol', 'ul'], notAllowedContext: ['caption', 'nav']},
        {className: 'underline',  command: 'underline',     diplayName: '<u>U</u>', allowedContext: ['p', 'table', 'ol', 'ul'], notAllowedContext: ['caption', 'nav']},
        {
            className: 'code',
            diplayName: '<code class="code-text-enrichment-button"><i class="fas fa-code"></i></code>',
            allowedContext: ['p', 'table', 'ol', 'ul'],
            notAllowedContext: ['caption', 'nav'],
            action: function() {
                var sel = window.getSelection(),
                    range = sel.getRangeAt(0),
                    newElement = document.createElement('inlinecode'),
                    section = self.editor.focusedSection(),
                    contextEl = self.caret.getContextElement('inlinecode'),
                    allCodesInSection, content, textNodeLeft, textNodeRight;

                if(contextEl) {
                    content = range.extractContents();
                    sel = window.getSelection();
                    range = sel.getRangeAt(0);

                    textNodeLeft = sel.focusNode;
                    textNodeRight = textNodeLeft.splitText(sel.focusOffset);

                    newElement.appendChild(textNodeRight);
                    contextEl.parentNode.insertBefore(newElement, contextEl.nextSibling);
                    contextEl.parentNode.insertBefore(content, contextEl.nextSibling);
                } else {
                    newElement.appendChild(range.extractContents());
                    range.insertNode(newElement);

                    allCodesInSection = section.querySelectorAll('inlinecode');

                    for(let i=0; i<allCodesInSection.length; i++) {
                        let next = allCodesInSection[i].nextSibling;

                        if(next && next.tagName === 'INLINECODE') {
                            allCodesInSection[i].innerHTML += next.innerHTML;
                            next.remove();
                            allCodesInSection = section.querySelectorAll('inlinecode');
                            i=-1;
                        }

                        if(next && next.nodeType === Node.TEXT_NODE && next.textContent === '') {
                            next.remove();
                            allCodesInSection = section.querySelectorAll('inlinecode');
                            i=-1;
                        }
                    }
                }

                self.hide();
            }
        },
        {
            className: 'link',
            command: 'createLink',
            diplayName: '<i class="fas fa-link fa-xs"></i>',
            allowedContext: ['p', 'table', 'ol', 'ul'],
            notAllowedContext: ['a', 'caption', 'nav'],
            arguments: [{name: 'url', placeholder: 'http://...', displayName: 'URL', type: 'text'}]
        },
        {
            className: 'unlink',
            rangeRequire: false,
            diplayName: '<i class="fas fa-unlink fa-xs"></i>',
            allowedContext: 'a',
            notAllowedContext: ['nav'],
            action: function(contextElement) {
                var parent = contextElement.parentNode;
                while (contextElement.firstChild) parent.insertBefore(contextElement.firstChild, contextElement);
                parent.removeChild(contextElement);
                self.hide();
            }
        },
        {
            rangeRequire: false,
            className: 'visit-link',
            diplayName: '<i class="fas fa-external-link-alt fa-xs"></i>',
            allowedContext: 'a',
            notAllowedContext: ['nav'],
            action: function(contextElement) {
                if(navigator && navigator.userAgent && navigator.userAgent.match('MonsterWriter')) {
                    var prefix = ''
                    if(!contextElement.getAttribute('href').match(/^https?:\/\//i)) {
                        prefix = 'https://'
                    }
                    // require('electron').shell.openExternal(prefix + contextElement.getAttribute('href'))
                } else {
                    window.open(contextElement.getAttribute('href'))
                }
            }
        },
        {
            className: 'edit-footnote',
            rangeRequire: false,
            diplayName: '<i class="fas fa-edit fa-xs"></i>',
            allowedContext: '.footnote',
            notAllowedContext: ['caption'],
            arguments: [{
                name: 'note',
                placeholder: 'footnote',
                displayName: 'Footnote',
                largetext: true,
                defaultValue: function(contextElement) {
                    if(!(contextElement && contextElement.dataset && contextElement.dataset.note)) {
                        return '';
                    }

                    return utils.attributeSaveStringToString((new HTMLRazor).strip(contextElement.dataset.note));
                }
            }],
            action: function(contextElement, argValue) {
                if(!argValue.note) return;
                if(typeof argValue.note !== 'string') return;
                if(argValue.note.trim() === '') return;

                contextElement.setAttribute('data-note', utils.stringToAttributeSaveString(argValue.note));
            }
        },
        {
            className: 'footnote-content',
            rangeRequire: false,
            diplayName: function(contextElement) {
                return contextElement.innerText + ': ' + utils.attributeSaveStringToHTMLEncoded(contextElement.dataset.note);
            },
            allowedContext: '.footnote',
            action: function() {}
        },
        {
            rangeRequire: false,
            insertAction: true,
            className: 'footnote',
            diplayName: 'fn<sup>*</sup>',
            allowedContext: ['p', 'table', 'ol', 'ul'],
            notAllowedContext: ['caption', 'nav'],
            arguments: [{name: 'note', placeholder: 'footnote', displayName: 'Footnote', largetext: true}],
            action: function(contextElement, argValue) {
                if(!argValue.note) return;
                if(typeof argValue.note !== 'string') return;
                if(argValue.note.trim() === '') return;

                var node = document.createElement('span');

                node.classList.add('footnote');
                node.setAttribute('data-note', utils.stringToAttributeSaveString(argValue.note));
                node.setAttribute('contenteditable', false);
                self.caret.insertNode(node);
            }
        },
        {
            rangeRequire: false,
            insertAction: true,
            className: 'ref',
            diplayName: 'ref',
            allowedContext: ['p', 'table', 'ol', 'ul', 'citesrc', 'caption', 'figcaption'],
            notAllowedContext: ['a', 'blockquote', 'code'],
            notFocusFirstInput: true,
            arguments: [
                {
                    allowedValues: function() { return self.editor.reference.getValuesForCrossReferenceSelectBox() },
                    isActive: function() { return self.editor.reference.getValuesForCrossReferenceSelectBox().length },
                    name: 'cross-ref',
                    displayName: 'Reference a part of your document (figures, tables, ...):',
                    tab: 'Cross-Reference'
                },
                {
                    name: 'no-cross-ref-available-hint',
                    message: '<div class="no-data-hint"><div class="no-data-icon"></div><div class="no-data-message-heading">No Cross-References Available!</div><div class="no-data-message">Once you have inserted a heading, table, image, etc. into your document, you will be able to reference/select it here.</div></div>',
                    isActive: function() { return !self.editor.reference.getValuesForCrossReferenceSelectBox().length },
                    tab: 'Cross-Reference'
                },
                {
                    reloadOnChangeOf: ['fetch-ref-btn', 'manage-ref-btn'],
                    allowedValues: function() { return self.editor.reference.getValuesForExistingReferenceSelectBox() },
                    isActive: function() { return self.editor.reference.areExistingReferencesAvailable() },
                    name: 'existing-ref',
                    displayName: 'Reference work you\'ve referenced before:',
                    tab: 'Find Reference'
                },
                {
                    name: 'no-existing-reference-available-hint',
                    message: '<div class="no-data-hint"><div class="no-data-icon"></div><div class="no-data-message-heading">No References Available!</div><div class="no-data-message">Select the tab "Add Reference" to insert a new reference. The next time you want to reference the same work, it will show up here.</div></div>',
                    isActive: function() { return !self.editor.reference.areExistingReferencesAvailable() },
                    tab: 'Find Reference'
                },
                {
                    name: 'fetch-ref-btn',
                    isActive: function() { return self.editor.reference.areExistingReferencesAvailable() },
                    render: function(dom, formData, dlFrom) {
                        dom.innerHTML = ''
                        const addRefSrcBtn = document.createElement('div');
                        addRefSrcBtn.classList.add('fetch-external-ref-btn');
                        addRefSrcBtn.innerHTML = 'Fetch Newest Data From Reference Sources';

                        addRefSrcBtn.onclick = async function() {
                            if(addRefSrcBtn.classList.contains('fetch-external-ref-btn-loading')) {
                                return;
                            }

                            const extRefField = dlFrom.fields.find(field => field.name === 'existing-ref');
                            extRefField.domElement.setLoadingStatus();

                            addRefSrcBtn.classList.add('fetch-external-ref-btn-loading');
                            await syncAllSources(self.editor.reference.store);
                            await self.editor.reference.store.initCache();
                            await self.editor.reference.store.cleanupReferencesFromSources();
                            await new Promise(res => setTimeout(res, 1000));

                            extRefField.domElement.setLoadingStatus();
                            addRefSrcBtn.classList.remove('fetch-external-ref-btn-loading');

                            dom.onChange(true);
                        }

                        dom.appendChild(addRefSrcBtn);
                    },
                    tab: 'Find Reference',
                },
                {
                    name: 'manage-ref-btn',
                    render: function(dom) {
                        dom.innerHTML = ''
                        const addRefSrcBtn = document.createElement('div');
                        addRefSrcBtn.classList.add('add-external-ref-btn')
                        addRefSrcBtn.innerHTML = 'Manage Reference Sources (Zotero)'

                        addRefSrcBtn.onclick = async function() {
                            const referenceSourcesFields = await getReferenceSourcesFields(self.editor.reference.store)
                            const configForm = new DeclarativForm(
                                { fields: [...referenceSourcesFields] },
                                () => { dom.onChange(true) },
                                () => { dom.onChange(true) },
                                'Back to References')

                            configForm.openInModal()
                        }

                        dom.appendChild(addRefSrcBtn);
                    },
                    tab: 'Find Reference',
                },
                ...(!self.editor.reference ? [] : self.editor.reference.getExternalRefDialogAttributes().map(field => Object.assign(field, { tab: 'Add Reference' })))
            ],
            action: function(contextElement, formData) {
                var ref = formData && (formData['cross-ref'] || formData['existing-ref']);
                if(formData.activeTab === 'Add Reference') {
                    self.editor.reference.insertExternalReference(formData);
                } else if(ref) {
                    self.editor.reference.insertInternalReference({ref: ref});
                }
            }
        },
        {
            rangeRequire: false,
            className: 'edit-ref',
            diplayName: '<i class="fas fa-edit fa-xs"></i>',
            allowedContext: '.reference',
            shouldBeDisplayed: function(contextElement) {
                return contextElement.getAttribute('data-external') === 'true';
            },
            action: function(contextElement, formData) {
                self.editor.reference.showEditExternalRefDialog(contextElement);
            }
        },
        {
            className: 'reference-caption',
            rangeRequire: false,
            diplayName: function(contextElement) {
                var caption = self.editor.reference.getRefCaptionHTML(contextElement);
                caption = caption.replace(/\<b\>/g, '')
                                 .replace(/\<\/b\>/g, '')
                                 .replace(/\</g, '&lt;')
                                 .replace(/\>/g, '&gt;');
                return caption;
            },
            shouldBeDisplayed: function(contextElement) {
                var caption = self.editor.reference.getRefCaptionHTML(contextElement);
                return caption && caption.length !== 0
            },
            allowedContext: '.reference',
            action: function() {}
        },
        {
            rangeRequire: false,
            insertAction: true,
            className: 'inlineequation',
            diplayName: '&radic;',
            allowedContext: ['p', 'table', 'ol', 'ul', 'h1', 'h2', 'h3', 'h4', 'h5', 'caption', 'figcaption', 'citesrc'],
            notAllowedContext: ['nav', 'a', 'inlinecode', 'code'],
            arguments: [
                {name: 'latexequation', placeholder: 'LaTeX Equation', displayName: 'LaTeX Equation', tooltip: latexCheatsheet},
                {
                    displayName: 'Preview',
                    tooltip: 'It shows you how the LaTeX equation will be rendered',
                    render: function(element, formData) {
                        if(formData && formData.latexequation && formData.latexequation.trim() !== '') {
                            try {
                                katex.render(formData.latexequation, element, {
                                    throwOnError: true,
                                    displayMode: false
                                });
                            } catch (ex) {
                                element.innerHTML = '<span class="error">invalid LaTeX equation</span>';
                            }
                        } else {
                            element.innerHTML = 'Insert a LaTeX in the input field above to see the equation here.';
                        }
                    }
                }
            ],
            action: function(contextElement, argValue) {
                if(!argValue.latexequation) return;
                if(typeof argValue.latexequation !== 'string') return;
                if(argValue.latexequation.trim() === '') return;

                var eq = utils.stringToAttributeSaveString(argValue.latexequation)
                var node = document.createElement('inlineequation');

                node.setAttribute('data-latexequation', eq);
                node.setAttribute('contenteditable', false);

                self.caret.insertNode(node);
                self.caret.insertNode(document.createTextNode(' '));
            }
        },
        {
            className: 'edit-inlineequation',
            rangeRequire: false,
            diplayName: '<i class="fas fa-edit fa-xs"></i>',
            allowedContext: 'inlineequation',
            notAllowedContext: [],
            arguments: [{
                name: 'latexequation',
                placeholder: 'LaTeX Equation',
                tooltip: latexCheatsheet,
                displayName: 'LaTeX Equation',
                defaultValue: function(contextElement) {
                    if(!(contextElement && contextElement.dataset && contextElement.dataset.latexequation)) {
                        return '';
                    }

                    return utils.attributeSaveStringToString(contextElement.dataset.latexequation);
                },
            },
            {
                displayName: 'Preview:',
                tooltip: 'It shows you how the LaTeX equation will be rendered',
                render: function(element, formData) {
                    if(formData && formData.latexequation && formData.latexequation.trim() !== '') {
                        try {
                            katex.render(formData.latexequation, element, {
                                throwOnError: true,
                                displayMode: false
                            });
                        } catch (ex) {
                            element.innerHTML = '<span class="error">invalid LaTeX equation</span>';
                        }
                    }
                }
            }],
            action: function(contextElement, argValue) {
                if(!argValue.latexequation) return;
                if(typeof argValue.latexequation !== 'string') return;
                if(argValue.latexequation.trim() === '') return;

                var section = self.editor.focusedSection();
                contextElement.setAttribute('data-latexequation', utils.stringToAttributeSaveString(argValue.latexequation));
                self.editor.replaceSectionWithHTML(section, section.outerHTML);
            }
        },
        {
            className: 'inlineequation-content',
            rangeRequire: false,
            diplayName: function(contextElement) {
                return utils.attributeSaveStringToHTMLEncoded(contextElement.dataset.latexequation);
            },
            allowedContext: 'inlineequation',
            action: function() {}
        },
        {
            rangeRequire: true,
            insertAction: false,
            className: 'enrichment-info',
            allowedContext: '',
            diplayName: function(contextElement) {
                var text = window.getSelection().toString();
                var wordCount = text.split(/[\s\.:\?\!']/)
                    .filter(w => w.trim().length > 0)
                    .length;
                var charCount = text.length;

                return `${wordCount} / ${charCount}`;
            },
            action: function() {}
        },
    ];

    this.caret.subscribeSelectionChange(function(selection) {
        var enrichments = self.getMeaningfulEnrichments();

        enrichments.length !== 0 ?
            self.show(false, enrichments) :
            self.hide();
    })
}

TextEnrichmentControl.prototype = {

    isVisible: function() {
        return this.visible;
    },

    addEnrichments: function(enrichments) {
        Array.prototype.push.apply(this.enrichments, enrichments);
    },

    hide: function(force) {
        if(force || !this.preventEnrichmentControllToBeHidden) {
            this.domElement.style.display = 'none';
            this.domElement.innerHTML = '';
            this.visible = false;
        }
    },

    show: function(isInsertBtnPressed, enrichments) {
        var self = this,
            el = this.domElement,
            tmpBtn, section;

        enrichments = enrichments || this.getMeaningfulEnrichments(isInsertBtnPressed);

        if(enrichments.length === 0 && !isInsertBtnPressed) return;

        if(enrichments.length === 0) {
            enrichments.push({
                diplayName: 'Nothing to do here!',
                className: 'enrichment-info',
                allowedContext: '',
                action: function() {}
            },
            {
                diplayName: '<i class="fas fa-info fa-xs"></i>',
                className: 'enrichment-more-info-btn',
                allowedContext: 'body',
                arguments: [{
                    message: 'Some parts of the document (like headings) don\'t allow to insert footnotes or references as they might not make much sence there.<br/><br/>Please give us some <a href="mailto:info@monsterwriter.app?subject=Feedback">feedback</a> if you have an use case which requires this to be changed. <br/><br/>BTW. we would &#x1F496;to hear how you like MonsterWriter in general!'
                }],
                action: function() {}
            });
        }

        el.innerHTML = '<span class="textEnrichmentControlArrow"></span>';
        enrichments.forEach(function(enrichment) {

            tmpBtn = document.createElement('span');
            tmpBtn.className = enrichment.className;

            tmpBtn.innerHTML =  (typeof enrichment.diplayName === 'function') ?
                                    enrichment.diplayName(enrichment.contextElement) :
                                    enrichment.diplayName;

            tmpBtn.onmousedown = function (e) {

                if(!enrichment.arguments && enrichment.command) {
                    document.execCommand(enrichment.command);
                } else if(!enrichment.arguments && enrichment.action) {
                    enrichment.action(self.caret.getContextElement(enrichment.allowedContext), undefined, self);
                    section = self.editor.focusedSection();
                    self.editor.replaceSectionWithHTML(section, section.outerHTML);
                } else if(enrichment.arguments.length === 1 && enrichment.arguments[0].type === 'text') {
                    self.displaySingleArgumentTextInput(enrichment);
                } else {
                    self.displayArgumentInput(enrichment);
                }

                return false;
            }

            tmpBtn.onclick = tmpBtn.onmouseup = function () { return false }

            el.appendChild(tmpBtn);
        });

        this.visible = true;
        this.updatePosition();
        el.style.display = 'block';
    },

    updatePosition: function() {
        var caretPos = this.caret.getPosition(),
            el = this.domElement,
            xOffset = (caretPos.width > 11 ? 0 : -11),
            originalDisplay = el.style.display;

        el.style.display = 'none';
        el.style.left = (caretPos.x + xOffset) + 'px';
        el.style.top = (caretPos.y - 32) + 'px';
        el.style.display = originalDisplay;
    },

    updatePositionIfVisible: function() {
        if(this.visible) {
            this.updatePosition();
        }
    },

    displayArgumentInput: function(enrichment) {
        var self = this, section;

        var args = enrichment.arguments.map(function(arg) {
            if(typeof arg.defaultValue !== 'function') {
                return arg;
            }

            var newArg = {};
            Object.assign(newArg, arg);
            newArg.defaultValue = arg.defaultValue(enrichment.contextElement);
            return newArg;
        });

        self.editor.displayModal(args, function(formData) {
            self.editor.unfreezeSelection();
            self.hide();

            enrichment.action(self.caret.getContextElement(enrichment.allowedContext), formData, self);
            section = self.editor.focusedSection();
            self.editor.replaceSectionWithHTML(section, section.outerHTML);
        }, enrichment.notFocusFirstInput);
    },

    displaySingleArgumentTextInput: function(enrichment) {
        var self = this,
            argument = enrichment.arguments[0],
            el = this.domElement,
            attrInput = document.createElement('input'),
            okBtn = document.createElement('span'),
            cachedContextElement = enrichment.contextElement,
            section;

        attrInput.placeholder = argument.placeholder;
        okBtn.innerHTML = 'OK';
        okBtn.className = 'confirmLink';

        if(typeof argument.value === 'function') {
            attrInput.value = argument.value(cachedContextElement);
        } else {
            attrInput.value = argument.value || '';
        }

        attrInput.onmousedown = function() {
            //simulate the text focus, because it should still be visible what
            //text is slected even when the foucs changes to the input field
            self.editor.freezeSelection({
                'unfreezeOnClicksOutsiteOf': el,
                'unfreezeCallback': function() {
                    self.preventEnrichmentControllToBeHidden = false;
                    self.hide()
                },
            });
            self.preventEnrichmentControllToBeHidden = true;

            attrInput.focus();
        }

        okBtn.onmousedown = function() {
            self.editor.unfreezeSelection();
            if(enrichment.command) {
                if(!document.execCommand(enrichment.command, false, attrInput.value)) {
                    window.getSelection().getRangeAt(0).collapse();
                }
            } else if(enrichment.action) {
                var attrValue = {};
                attrValue[argument.name] = attrInput.value;
                enrichment.action(self.caret.getContextElement(enrichment.allowedContext), attrValue, self);
                section = self.editor.focusedSection();
                self.editor.replaceSectionWithHTML(section, section.outerHTML);
            }

            self.hide();
            return false;
        }

        attrInput.onkeydown = function(e) {
            if(e.keyCode === 13) { // Enter
                okBtn.onmousedown();
                e.preventDefault();
                e.stopPropagation();
                return false;
            }
        }

        el.innerHTML = '<span class="textEnrichmentControlArrow"></span>';
        el.appendChild(attrInput);
        el.appendChild(okBtn);

        attrInput.onmousedown();
    },

    getMeaningfulEnrichments: function(isInsertBtnPressed, selection) {
        var self = this,
            tangentNodes = self.caret.getTangetNodes();

        selection = selection || window.getSelection();

        var collapsedMatch = function(e) {
            if(typeof e.rangeRequire === 'undefined') {
                e.rangeRequire = true;
            }

            return !e.rangeRequire || !selection.isCollapsed === e.rangeRequire;
        }

        var contextMatch = function(e) {
            if(!e.allowedContext) return true;

            if(e.notAllowedContext) {
                if(self.caret.getContextElement(e.notAllowedContext, selection, tangentNodes)) {
                    return false;
                }
            }

            e.contextElement = self.caret.getContextElement(e.allowedContext, selection, tangentNodes);
            return !!e.contextElement;
        }

        var insertActionMatch = function(e) {
            if(isInsertBtnPressed) {
                return selection.isCollapsed && e.insertAction === true;
            } else {
                return e.insertAction !== true;
            }
        }

        var enrichmentMatch = function(e) {
            if(!e.shouldBeDisplayed) { return true }

            return e.shouldBeDisplayed(self.caret.getContextElement(e.allowedContext, selection, tangentNodes));
        }

        return this.enrichments.filter(function(e) {
            return collapsedMatch(e) &&
                   contextMatch(e) &&
                   insertActionMatch(e) &&
                   enrichmentMatch(e);
        });
    }
}

module.exports = TextEnrichmentControl;


/***/ }),

/***/ "./node_modules/changesets/lib/Builder.js":
/*!************************************************!*\
  !*** ./node_modules/changesets/lib/Builder.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Changeset = __webpack_require__(/*! ./Changeset */ "./node_modules/changesets/lib/Changeset.js")
  , Retain = __webpack_require__(/*! ./operations/Retain */ "./node_modules/changesets/lib/operations/Retain.js")
  , Skip = __webpack_require__(/*! ./operations/Skip */ "./node_modules/changesets/lib/operations/Skip.js")
  , Insert = __webpack_require__(/*! ./operations/Insert */ "./node_modules/changesets/lib/operations/Insert.js")

function Builder() {
  this.ops = []
  this.addendum = ''
  this.removendum = ''
}

module.exports = Builder

Builder.prototype.keep =
Builder.prototype.retain = function(len) {
  this.ops.push(new Retain(len))
  return this
}

Builder.prototype.delete =
Builder.prototype.skip = function(str) {
  this.removendum += str
  this.ops.push(new Skip(str.length))
  return this
}

Builder.prototype.add =
Builder.prototype.insert = function(str) {
  this.addendum += str
  this.ops.push(new Insert(str.length))
  return this
}

Builder.prototype.end = function() {
  var cs = new Changeset(this.ops)
  cs.addendum = this.addendum
  cs.removendum = this.removendum
  return cs
}


/***/ }),

/***/ "./node_modules/changesets/lib/Changeset.js":
/*!**************************************************!*\
  !*** ./node_modules/changesets/lib/Changeset.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * changesets
 * A Changeset library incorporating operational transformation (OT)
 * Copyright 2012 by Marcel Klehr <mklehr@gmx.net>
 *
 * (MIT LICENSE)
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * A sequence of consecutive operations
 *
 * @param ops.. <Operation> all passed operations will be added to the changeset
 */
function Changeset(ops/*or ops..*/) {
  this.addendum = ""
  this.removendum = ""
  this.inputLength = 0
  this.outputLength = 0

  if(!Array.isArray(ops)) ops = arguments
  for(var i=0; i<ops.length; i++) {
    this.push(ops[i])
    this.inputLength += ops[i].input
    this.outputLength += ops[i].output
  }
}

// True inheritance
Changeset.prototype = Object.create(Array.prototype, {
  constructor: {
    value: Changeset,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
module.exports = Changeset

var TextTransform = __webpack_require__(/*! ./TextTransform */ "./node_modules/changesets/lib/TextTransform.js")
  , ChangesetTransform = __webpack_require__(/*! ./ChangesetTransform */ "./node_modules/changesets/lib/ChangesetTransform.js")

var Retain = __webpack_require__(/*! ./operations/Retain */ "./node_modules/changesets/lib/operations/Retain.js")
  , Skip = __webpack_require__(/*! ./operations/Skip */ "./node_modules/changesets/lib/operations/Skip.js")
  , Insert = __webpack_require__(/*! ./operations/Insert */ "./node_modules/changesets/lib/operations/Insert.js")

var Builder = __webpack_require__(/*! ./Builder */ "./node_modules/changesets/lib/Builder.js")

/**
 * Returns an array containing the ops that are within the passed range
 * (only op.input is counted; thus not counting inserts to the range length, yet they are part of the range)
 */
Changeset.prototype.subrange = function(start, len) {
  var range = []
    , op, oplen
    , l=0
  for(var i=0, pos=0; i<this.length && l < len; i++) {
    op = this[i]
    if(op.input+pos >= start) {
      if(op.input) {
        if(op.length != Infinity) oplen = op.length -Math.max(0, start-pos) -Math.max(0, (op.length+pos)-(start+len))
        else oplen = len
        if (oplen !== 0) range.push( op.derive(oplen) ) // (Don't copy over more than len param allows)
      }
      else {
        range.push( op.derive(op.length) )
        oplen = 0
      }
      l += oplen
    }
    pos += op.input
  }
  return range
}

/**
 * Merge two changesets (that are based on the same state!) so that the resulting changseset
 * has the same effect as both orignal ones applied one after the other
 *
 * @param otherCs <Changeset>
 * @param left <boolean> Which op to choose if there's an insert tie (If you use this function in a distributed, synchronous environment, be sure to invert this param on the other site, otherwise it can be omitted safely))
 * @returns <Changeset>
 */
Changeset.prototype.merge = function(otherCs, left) {
  if(!(otherCs instanceof Changeset)) {
    throw new Error('Argument must be a #<Changeset>, but received '+otherCs.__proto__.constructor.name)
  }

  if(otherCs.inputLength !== this.outputLength) {
    throw new Error("Changeset lengths for merging don't match! Input length of younger cs: "+otherCs.inputLength+', output length of older cs:'+this.outputLength)
  }

  var newops = []
    , addPtr1 = 0
    , remPtr1 = 0
    , addPtr2 = 0
    , remPtr2 = 0
    , newaddendum = ''
    , newremovendum = ''

  zip(this, otherCs, function(op1, op2) {
    // console.log(newops)
    // console.log(op1, op2)

    // I'm deleting something -- the other cs can't know that, so just overtake my op
    if(op1 && !op1.output) {
      newops.push(op1.merge().clone())
      newremovendum += this.removendum.substr(remPtr1, op1.length) // overtake added chars
      remPtr1 += op1.length
      op1.length = 0 // don't gimme that one again.
      return
    }

    // op2 is an insert
    if(op2 && !op2.input) {
      newops.push(op2.merge().clone())
      newaddendum += otherCs.addendum.substr(addPtr2, op2.length) // overtake added chars
      addPtr2 += op2.length
      op2.length = 0 // don't gimme that one again.
      return
    }

    // op2 is either a retain or a skip
    if(op2 && op2.input && op1) {
      // op2 retains whatever we do here (retain or insert), so just clone my op
      if(op2.output) {
        newops.push(op1.merge(op2).clone())
        if(!op1.input) { // overtake addendum
          newaddendum += this.addendum.substr(addPtr1, op1.length)
          addPtr1 += op1.length
        }
        op1.length = 0 // don't gimme these again
        op2.length = 0
      }else

      // op2 deletes my retain here, so just clone the delete
      // (op1 can only be a retain and no skip here, cause we've handled skips above already)
      if(!op2.output && op1.input) {
        newops.push(op2.merge(op1).clone())
        newremovendum += otherCs.removendum.substr(remPtr2, op2.length) // overtake added chars
        remPtr2 += op2.length
        op1.length = 0 // don't gimme these again
        op2.length = 0
      }else

      //otherCs deletes something I added (-1) +1 = 0
      {
        addPtr1 += op1.length
        op1.length = 0 // don't gimme these again
        op2.length = 0
      }
      return
    }

    console.log('oops', arguments)
    throw new Error('oops. This case hasn\'t been considered by the developer (error code: PBCAC)')
  }.bind(this))

  var newCs = new Changeset(newops)
  newCs.addendum = newaddendum
  newCs.removendum = newremovendum

  return newCs
}

/**
 * A private and quite handy function that slices ops into equally long pieces and applies them on a mapping function
 * that can determine the iteration steps by setting op.length to 0 on an op (equals using .next() in a usual iterator)
 */
function zip(cs1, cs2, func) {
  var opstack1 = cs1.map(function(op) {return op.clone()}) // copy ops
    , opstack2 = cs2.map(function(op) {return op.clone()})

  var op2, op1
  while(opstack1.length || opstack2.length) {// iterate through all outstanding ops of this cs
    op1 = opstack1[0]? opstack1[0].clone() : null
    op2 = opstack2[0]? opstack2[0].clone() : null

    if(op1) {
      if(op2) op1 = op1.derive(Math.min(op1.length, op2.length)) // slice 'em into equally long pieces
      if(opstack1[0].length > op1.length) opstack1[0] = opstack1[0].derive(opstack1[0].length-op1.length)
      else opstack1.shift()
    }

    if(op2) {
      if(op1) op2 = op2.derive(Math.min(op1.length, op2.length)) // slice 'em into equally long pieces
      if(opstack2[0].length > op2.length) opstack2[0] = opstack2[0].derive(opstack2[0].length-op2.length)
      else opstack2.shift()
    }

    func(op1, op2)

    if(op1 && op1.length) opstack1.unshift(op1)
    if(op2 && op2.length) opstack2.unshift(op2)
  }
}

/**
 * Inclusion Transformation (IT) or Forward Transformation
 *
 * transforms the operations of the current changeset against the
 * all operations in another changeset in such a way that the
 * effects of the latter are effectively included.
 * This is basically like a applying the other cs on this one.
 *
 * @param otherCs <Changeset>
 * @param left <boolean> Which op to choose if there's an insert tie (If you use this function in a distributed, synchronous environment, be sure to invert this param on the other site, otherwise it can be omitted safely)
 *
 * @returns <Changeset>
 */
Changeset.prototype.transformAgainst = function(otherCs, left) {
  if(!(otherCs instanceof Changeset)) {
    throw new Error('Argument to Changeset#transformAgainst must be a #<Changeset>, but received '+otherCs.__proto__.constructor.name)
  }

  if(this.inputLength != otherCs.inputLength) {
    throw new Error('Can\'t transform changesets with differing inputLength: '+this.inputLength+' and '+otherCs.inputLength)
  }

  var transformation = new ChangesetTransform(this, [new Retain(Infinity)])
  otherCs.forEach(function(op) {
    var nextOp = this.subrange(transformation.pos, Infinity)[0] // next op of this cs
    if(nextOp && !nextOp.input && !op.input) { // two inserts tied; left breaks it
      if (left) transformation.writeOutput(transformation.readInput(nextOp.length))
    }
    op.apply(transformation)
  }.bind(this))

  return transformation.result()
}

/**
 * Exclusion Transformation (ET) or Backwards Transformation
 *
 * transforms all operations in the current changeset against the operations
 * in another changeset in such a way that the impact of the latter are effectively excluded
 *
 * @param changeset <Changeset> the changeset to substract from this one
 * @param left <boolean> Which op to choose if there's an insert tie (If you use this function in a distributed, synchronous environment, be sure to invert this param on the other site, otherwise it can be omitted safely)
 * @returns <Changeset>
 */
Changeset.prototype.substract = function(changeset, left) {
  // The current operations assume that the changes in
  // `changeset` happened before, so for each of those ops
  // we create an operation that undoes its effect and
  // transform all our operations on top of the inverse changes
  return this.transformAgainst(changeset.invert(), left)
}

/**
 * Returns the inverse Changeset of the current one
 *
 * Changeset.invert().apply(Changeset.apply(document)) == document
 */
Changeset.prototype.invert = function() {
  // invert all ops
  var newCs = new Changeset(this.map(function(op) {
    return op.invert()
  }))

  // removendum becomes addendum and vice versa
  newCs.addendum = this.removendum
  newCs.removendum = this.addendum

  return newCs
}

/**
 * Applies this changeset on a text
 */
Changeset.prototype.apply = function(input) {
  // pre-requisites
  if(input.length != this.inputLength) throw new Error('Input length doesn\'t match expected length. expected: '+this.inputLength+'; actual: '+input.length)

  var operation = new TextTransform(input, this.addendum, this.removendum)

  this.forEach(function(op) {
    // each Operation has access to all pointers as well as the input, addendum and removendum (the latter are immutable)
    op.apply(operation)
  }.bind(this))

  return operation.result()
}

/**
 * Returns an array of strings describing this changeset's operations
 */
Changeset.prototype.inspect = function() {
  var j = 0
  return this.map(function(op) {
    var string = ''

    if(!op.input) { // if Insert
      string = this.addendum.substr(j,op.length)
      j += op.length
      return string
    }

    for(var i=0; i<op.length; i++) string += op.symbol
    return string
  }.bind(this)).join('')
}

/**
 * Serializes the given changeset in order to return a (hopefully) more compact representation
 * than json that can be sent through a network or stored in a database
 *
 * Numbers are converted to the base 36, unsafe chars in the text are urlencoded
 *
 * @param cs <Changeset> The changeset to be serialized
 * @returns <String> The serialized changeset
 */
Changeset.prototype.pack = function() {
  var packed = this.map(function(op) {
    return op.pack()
  }).join('')

  var addendum = this.addendum.replace(/%/g, '%25').replace(/\|/g, '%7C')
    , removendum = this.removendum.replace(/%/g, '%25').replace(/\|/g, '%7C')
  return packed+'|'+addendum+'|'+removendum
}
Changeset.prototype.toString = function() {
  return this.pack()
}

/**
 * Unserializes the output of cs.text.Changeset#toString()
 *
 * @param packed <String> The serialized changeset
 * @param <cs.Changeset>
 */
Changeset.unpack = function(packed) {
  if(packed == '') throw new Error('Cannot unpack from empty string')
  var components = packed.split('|')
    , opstring = components[0]
    , addendum = components[1].replace(/%7c/gi, '|').replace(/%25/g, '%')
    , removendum = components[2].replace(/%7c/gi, '|').replace(/%25/g, '%')

  var matches = opstring.match(/[=+-]([^=+-])+/g)
  if(!matches) throw new Error('Cannot unpack invalidly serialized op string')

  var ops = []
  matches.forEach(function(s) {
    var symbol = s.substr(0,1)
      , data = s.substr(1)
    if(Skip.prototype.symbol == symbol) return ops.push(Skip.unpack(data))
    if(Insert.prototype.symbol == symbol) return ops.push(Insert.unpack(data))
    if(Retain.prototype.symbol == symbol) return ops.push(Retain.unpack(data))
    throw new Error('Invalid changeset representation passed to Changeset.unpack')
  })

  var cs = new Changeset(ops)
  cs.addendum = addendum
  cs.removendum = removendum

  return cs
}

Changeset.create = function() {
  return new Builder
}

/**
 * Returns a Changeset containing the operations needed to transform text1 into text2
 *
 * @param text1 <String>
 * @param text2 <String>
 */
Changeset.fromDiff = function(diff) {
  /**
   * The data structure representing a diff is an array of tuples:
   * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
   * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
   */
  var DIFF_DELETE = -1;
  var DIFF_INSERT = 1;
  var DIFF_EQUAL = 0;

  var ops = []
    , removendum = ''
    , addendum = ''

  diff.forEach(function(d) {
    if (DIFF_DELETE == d[0]) {
      ops.push(new Skip(d[1].length))
      removendum += d[1]
    }

    if (DIFF_INSERT == d[0]) {
      ops.push(new Insert(d[1].length))
      addendum += d[1]
    }

    if(DIFF_EQUAL == d[0]) {
      ops.push(new Retain(d[1].length))
    }
  })

  var cs = new Changeset(ops)
  cs.addendum = addendum
  cs.removendum = removendum
  return cs
}


/***/ }),

/***/ "./node_modules/changesets/lib/ChangesetTransform.js":
/*!***********************************************************!*\
  !*** ./node_modules/changesets/lib/ChangesetTransform.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * changesets
 * A Changeset library incorporating operational ChangesetTransform (OT)
 * Copyright 2012 by Marcel Klehr <mklehr@gmx.net>
 *
 * (MIT LICENSE)
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var Retain = __webpack_require__(/*! ./operations/Retain */ "./node_modules/changesets/lib/operations/Retain.js")
  , Skip = __webpack_require__(/*! ./operations/Skip */ "./node_modules/changesets/lib/operations/Skip.js")
  , Insert = __webpack_require__(/*! ./operations/Insert */ "./node_modules/changesets/lib/operations/Insert.js")
  , Changeset = __webpack_require__(/*! ./Changeset */ "./node_modules/changesets/lib/Changeset.js")


function ChangesetTransform(inputCs, addendum) {
  this.output = []
  this.addendum = addendum
  this.newRemovendum = ''
  this.newAddendum = ''

  this.cs = inputCs
  this.pos = 0
  this.addendumPointer = 0
  this.removendumPointer = 0
}
module.exports = ChangesetTransform

ChangesetTransform.prototype.readInput = function (len) {
  var ret = this.cs.subrange(this.pos, len)
  this.pos += len
  return ret
}

ChangesetTransform.prototype.readAddendum = function (len) {
  //return [new Retain(len)]
  var ret = this.subrange(this.addendum, this.addendumPointer, len)
  this.addendumPointer += len
  return ret
}

ChangesetTransform.prototype.writeRemovendum = function (range) {
  range
    .filter(function(op) {return !op.output})
    .forEach(function(op) {
      this.removendumPointer += op.length
    }.bind(this))
}

ChangesetTransform.prototype.writeOutput = function (range) {
  this.output = this.output.concat(range)
  range
    .filter(function(op) {return !op.output})
    .forEach(function(op) {
      this.newRemovendum += this.cs.removendum.substr(this.removendumPointer, op.length)
      this.removendumPointer += op.length
    }.bind(this))
}

ChangesetTransform.prototype.subrange = function (range, start, len) {
  if(len) return this.cs.subrange.call(range, start, len)
  else return range.filter(function(op){ return !op.input})
}

ChangesetTransform.prototype.result = function() {
  this.writeOutput(this.readInput(Infinity))
  var newCs = new Changeset(this.output)
  newCs.addendum = this.cs.addendum
  newCs.removendum = this.newRemovendum
  return newCs
}


/***/ }),

/***/ "./node_modules/changesets/lib/Operator.js":
/*!*************************************************!*\
  !*** ./node_modules/changesets/lib/Operator.js ***!
  \*************************************************/
/***/ ((module) => {

function Operator() {
}

module.exports = Operator

Operator.prototype.clone = function() {
  return this.derive(this.length)
}

Operator.prototype.derive = function(len) {
  return new (this.constructor)(len)
}

Operator.prototype.pack = function() {
  return this.symbol + (this.length).toString(36)
}


/***/ }),

/***/ "./node_modules/changesets/lib/TextTransform.js":
/*!******************************************************!*\
  !*** ./node_modules/changesets/lib/TextTransform.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * changesets
 * A Changeset library incorporating operational Apply (OT)
 * Copyright 2012 by Marcel Klehr <mklehr@gmx.net>
 *
 * (MIT LICENSE)
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var Retain = __webpack_require__(/*! ./operations/Retain */ "./node_modules/changesets/lib/operations/Retain.js")
  , Skip = __webpack_require__(/*! ./operations/Skip */ "./node_modules/changesets/lib/operations/Skip.js")
  , Insert = __webpack_require__(/*! ./operations/Insert */ "./node_modules/changesets/lib/operations/Insert.js")
  , Insert = __webpack_require__(/*! ./Changeset */ "./node_modules/changesets/lib/Changeset.js")


function TextTransform(input, addendum, removendum) {
  this.output = ''

  this.input = input
  this.addendum = addendum
  this.removendum = removendum
  this.pos = 0
  this.addPos = 0
  this.remPos = 0
}
module.exports = TextTransform

TextTransform.prototype.readInput = function (len) {
  var ret = this.input.substr(this.pos, len)
  this.pos += len
  return ret
}

TextTransform.prototype.readAddendum = function (len) {
  var ret = this.addendum.substr(this.addPos, len)
  this.addPos += len
  return ret
}

TextTransform.prototype.writeRemovendum = function (range) {
  //var expected = this.removendum.substr(this.remPos, range.length)
  //if(range != expected) throw new Error('Removed chars don\'t match removendum. expected: '+expected+'; actual: '+range)
  this.remPos += range.length
}

TextTransform.prototype.writeOutput = function (range) {
  this.output += range
}

TextTransform.prototype.subrange = function (range, start, len) {
  return range.substr(start, len)
}

TextTransform.prototype.result = function() {
  this.writeOutput(this.readInput(Infinity))
  return this.output
}


/***/ }),

/***/ "./node_modules/changesets/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/changesets/lib/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*!
 * changesets
 * A Changeset library incorporating operational transformation (OT)
 * Copyright 2012 by Marcel Klehr <mklehr@gmx.net>
 *
 * (MIT LICENSE)
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var Changeset = __webpack_require__(/*! ./Changeset */ "./node_modules/changesets/lib/Changeset.js")
  , Retain = __webpack_require__(/*! ./operations/Retain */ "./node_modules/changesets/lib/operations/Retain.js")
  , Skip = __webpack_require__(/*! ./operations/Skip */ "./node_modules/changesets/lib/operations/Skip.js")
  , Insert = __webpack_require__(/*! ./operations/Insert */ "./node_modules/changesets/lib/operations/Insert.js")

exports.Operator = __webpack_require__(/*! ./Operator */ "./node_modules/changesets/lib/Operator.js")
exports.Changeset = Changeset
exports.Insert = Insert
exports.Retain = Retain
exports.Skip = Skip

if('undefined' != typeof window) window.changesets = exports

/**
 * Serializes the given changeset in order to return a (hopefully) more compact representation
 * that can be sent through a network or stored in a database
 * @alias cs.text.Changeset#pack
 */
exports.pack = function(cs) {
  return cs.pack()
}

/**
 * Unserializes the output of cs.text.pack
 * @alias cs.text.Changeset.unpack
 */
exports.unpack = function(packed) {
  return Changeset.unpack(packed)
}




/**
 * shareJS ot type API sepc support
 */

exports.name = 'changesets'
exports.url = 'https://github.com/marcelklehr/changesets'

/**
 * create([initialText])
 *
 * creates a snapshot (optionally with supplied intial text)
 */
exports.create = function(initText) {
  return initText || ''
}

/**
 * Apply a changeset on a snapshot creating a new one
 *
 * The old snapshot object mustn't be used after calling apply on it
 * returns the resulting
 */
exports.apply = function(snapshot, op) {
  op = exports.unpack(op)
  return op.apply(snapshot)
}

/**
 * Transform changeset1 against changeset2
 */
exports.transform = function (op1, op2, side) {
  op1 = exports.unpack(op1)
  op2 = exports.unpack(op2)
  return exports.pack(op1.transformAgainst(op2, ('left'==side)))
}

/**
 * Merge two changesets into one
 */
exports.compose = function (op1, op2) {
  op1 = exports.unpack(op1)
  op2 = exports.unpack(op2)
  return exports.pack(op1.merge(op2))
}

/**
 * Invert a changeset
 */
exports.invert = function(op) {
  return exports.pack(exports.unpack(op).invert())
}


/***/ }),

/***/ "./node_modules/changesets/lib/operations/Insert.js":
/*!**********************************************************!*\
  !*** ./node_modules/changesets/lib/operations/Insert.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * changesets
 * A Changeset library incorporating operational transformation (OT)
 * Copyright 2012 by Marcel Klehr <mklehr@gmx.net>
 *
 * (MIT LICENSE)
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var Operator = __webpack_require__(/*! ../Operator */ "./node_modules/changesets/lib/Operator.js")

/**
 * Insert Operator
 * Defined by:
 * - length
 * - input=0
 * - output=length
 *
 * @param length <Number> How many chars to be inserted
 */
function Insert(length) {
  this.length = length
  this.input = 0
  this.output = length
}

// True inheritance
Insert.prototype = Object.create(Operator.prototype, {
  constructor: {
    value: Insert,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
module.exports = Insert
Insert.prototype.symbol = '+'

var Skip = __webpack_require__(/*! ./Skip */ "./node_modules/changesets/lib/operations/Skip.js")
  , Retain = __webpack_require__(/*! ./Retain */ "./node_modules/changesets/lib/operations/Retain.js")

Insert.prototype.apply = function(t) {
  t.writeOutput(t.readAddendum(this.output))
}

Insert.prototype.merge = function() {
  return this
}

Insert.prototype.invert = function() {
  return new Skip(this.length)
}

Insert.unpack = function(data) {
  return new Insert(parseInt(data, 36))
}


/***/ }),

/***/ "./node_modules/changesets/lib/operations/Retain.js":
/*!**********************************************************!*\
  !*** ./node_modules/changesets/lib/operations/Retain.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * changesets
 * A Changeset library incorporating operational transformation (OT)
 * Copyright 2012 by Marcel Klehr <mklehr@gmx.net>
 *
 * (MIT LICENSE)
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var Operator = __webpack_require__(/*! ../Operator */ "./node_modules/changesets/lib/Operator.js")

/**
 * Retain Operator
 * Defined by:
 * - length
 * - input=output=length
 *
 * @param length <Number> How many chars to retain
 */
function Retain(length) {
  this.length = length
  this.input = length
  this.output = length
}

// True inheritance
Retain.prototype = Object.create(Operator.prototype, {
  constructor: {
    value: Retain,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
module.exports = Retain
Retain.prototype.symbol = '='

Retain.prototype.apply = function(t) {
  t.writeOutput(t.readInput(this.input))
}

Retain.prototype.invert = function() {
  return this
}

Retain.prototype.merge = function(op2) {
  return this
}

Retain.unpack = function(data) {
  return new Retain(parseInt(data, 36))
}


/***/ }),

/***/ "./node_modules/changesets/lib/operations/Skip.js":
/*!********************************************************!*\
  !*** ./node_modules/changesets/lib/operations/Skip.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * changesets
 * A Changeset library incorporating operational transformation (OT)
 * Copyright 2012 by Marcel Klehr <mklehr@gmx.net>
 *
 * (MIT LICENSE)
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var Operator = __webpack_require__(/*! ../Operator */ "./node_modules/changesets/lib/Operator.js")

/**
 * Skip Operator
 * Defined by:
 * - length
 * - input=length
 * - output=0
 *
 * @param length <Number> How many chars to be Skip
 */
function Skip(length) {
  this.length = length
  this.input = length
  this.output = 0
}

// True inheritance
Skip.prototype = Object.create(Operator.prototype, {
  constructor: {
    value: Skip,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
module.exports = Skip
Skip.prototype.symbol = '-'

var Insert = __webpack_require__(/*! ./Insert */ "./node_modules/changesets/lib/operations/Insert.js")
  , Retain = __webpack_require__(/*! ./Retain */ "./node_modules/changesets/lib/operations/Retain.js")
  , Changeset = __webpack_require__(/*! ../Changeset */ "./node_modules/changesets/lib/Changeset.js")

Skip.prototype.apply = function(t) {
  var input = t.readInput(this.input)
  t.writeRemovendum(input)
  t.writeOutput(t.subrange(input, 0, this.output)) // retain Inserts in my range
}

Skip.prototype.merge = function(op2) {
  return this
}

Skip.prototype.invert = function() {
  return new Insert(this.length)
}

Skip.unpack = function(data) {
  return new Skip(parseInt(data, 36))
}


/***/ }),

/***/ "./node_modules/diff_match_patch/lib/diff_match_patch.js":
/*!***************************************************************!*\
  !*** ./node_modules/diff_match_patch/lib/diff_match_patch.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

/**
 * Diff Match and Patch
 *
 * Copyright 2006 Google Inc.
 * http://code.google.com/p/google-diff-match-patch/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview Computes the difference between two texts to create a patch.
 * Applies the patch onto another text, allowing for errors.
 * @author fraser@google.com (Neil Fraser)
 */

/**
 * Class containing the diff, match and patch methods.
 * @constructor
 */
function diff_match_patch() {

  // Defaults.
  // Redefine these in your program to override the defaults.

  // Number of seconds to map a diff before giving up (0 for infinity).
  this.Diff_Timeout = 1.0;
  // Cost of an empty edit operation in terms of edit characters.
  this.Diff_EditCost = 4;
  // The size beyond which the double-ended diff activates.
  // Double-ending is twice as fast, but less accurate.
  this.Diff_DualThreshold = 32;
  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).
  this.Match_Threshold = 0.5;
  // How far to search for a match (0 = exact location, 1000+ = broad match).
  // A match this many characters away from the expected location will add
  // 1.0 to the score (0.0 is a perfect match).
  this.Match_Distance = 1000;
  // When deleting a large block of text (over ~64 characters), how close does
  // the contents have to match the expected contents. (0.0 = perfection,
  // 1.0 = very loose).  Note that Match_Threshold controls how closely the
  // end points of a delete need to match.
  this.Patch_DeleteThreshold = 0.5;
  // Chunk size for context length.
  this.Patch_Margin = 4;

  /**
   * Compute the number of bits in an int.
   * The normal answer for JavaScript is 32.
   * @return {number} Max bits
   */
  function getMaxBits() {
    var maxbits = 0;
    var oldi = 1;
    var newi = 2;
    while (oldi != newi) {
      maxbits++;
      oldi = newi;
      newi = newi << 1;
    }
    return maxbits;
  }
  // How many bits in a number?
  this.Match_MaxBits = getMaxBits();
}


//  DIFF FUNCTIONS


/**
 * The data structure representing a diff is an array of tuples:
 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
 */
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;


/**
 * Find the differences between two texts.  Simplifies the problem by stripping
 * any common prefix or suffix off the texts before diffing.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {boolean} opt_checklines Optional speedup flag.  If present and false,
 *     then don't run a line-level diff first to identify the changed areas.
 *     Defaults to true, which does a faster, slightly less optimal diff
 * @return {Array.<Array.<number|string>>} Array of diff tuples.
 */
diff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines) {
  // Check for null inputs.
  if (text1 == null || text2 == null) {
    throw new Error('Null input. (diff_main)');
  }

  // Check for equality (speedup).
  if (text1 == text2) {
    return [[DIFF_EQUAL, text1]];
  }

  if (typeof opt_checklines == 'undefined') {
    opt_checklines = true;
  }
  var checklines = opt_checklines;

  // Trim off common prefix (speedup).
  var commonlength = this.diff_commonPrefix(text1, text2);
  var commonprefix = text1.substring(0, commonlength);
  text1 = text1.substring(commonlength);
  text2 = text2.substring(commonlength);

  // Trim off common suffix (speedup).
  commonlength = this.diff_commonSuffix(text1, text2);
  var commonsuffix = text1.substring(text1.length - commonlength);
  text1 = text1.substring(0, text1.length - commonlength);
  text2 = text2.substring(0, text2.length - commonlength);

  // Compute the diff on the middle block.
  var diffs = this.diff_compute(text1, text2, checklines);

  // Restore the prefix and suffix.
  if (commonprefix) {
    diffs.unshift([DIFF_EQUAL, commonprefix]);
  }
  if (commonsuffix) {
    diffs.push([DIFF_EQUAL, commonsuffix]);
  }
  this.diff_cleanupMerge(diffs);
  return diffs;
};


/**
 * Find the differences between two texts.  Assumes that the texts do not
 * have any common prefix or suffix.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {boolean} checklines Speedup flag.  If false, then don't run a
 *     line-level diff first to identify the changed areas.
 *     If true, then run a faster, slightly less optimal diff
 * @return {Array.<Array.<number|string>>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_compute = function(text1, text2, checklines) {
  var diffs;

  if (!text1) {
    // Just add some text (speedup).
    return [[DIFF_INSERT, text2]];
  }

  if (!text2) {
    // Just delete some text (speedup).
    return [[DIFF_DELETE, text1]];
  }

  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  var i = longtext.indexOf(shorttext);
  if (i != -1) {
    // Shorter text is inside the longer text (speedup).
    diffs = [[DIFF_INSERT, longtext.substring(0, i)],
             [DIFF_EQUAL, shorttext],
             [DIFF_INSERT, longtext.substring(i + shorttext.length)]];
    // Swap insertions for deletions if diff is reversed.
    if (text1.length > text2.length) {
      diffs[0][0] = diffs[2][0] = DIFF_DELETE;
    }
    return diffs;
  }
  longtext = shorttext = null;  // Garbage collect.

  // Check to see if the problem can be split in two.
  var hm = this.diff_halfMatch(text1, text2);
  if (hm) {
    // A half-match was found, sort out the return data.
    var text1_a = hm[0];
    var text1_b = hm[1];
    var text2_a = hm[2];
    var text2_b = hm[3];
    var mid_common = hm[4];
    // Send both pairs off for separate processing.
    var diffs_a = this.diff_main(text1_a, text2_a, checklines);
    var diffs_b = this.diff_main(text1_b, text2_b, checklines);
    // Merge the results.
    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
  }

  // Perform a real diff.
  if (checklines && (text1.length < 100 || text2.length < 100)) {
    // Too trivial for the overhead.
    checklines = false;
  }
  var linearray;
  if (checklines) {
    // Scan the text on a line-by-line basis first.
    var a = this.diff_linesToChars(text1, text2);
    text1 = a[0];
    text2 = a[1];
    linearray = a[2];
  }
  diffs = this.diff_map(text1, text2);
  if (!diffs) {
    // No acceptable result.
    diffs = [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
  }
  if (checklines) {
    // Convert the diff back to original text.
    this.diff_charsToLines(diffs, linearray);
    // Eliminate freak matches (e.g. blank lines)
    this.diff_cleanupSemantic(diffs);

    // Rediff any replacement blocks, this time character-by-character.
    // Add a dummy entry at the end.
    diffs.push([DIFF_EQUAL, '']);
    var pointer = 0;
    var count_delete = 0;
    var count_insert = 0;
    var text_delete = '';
    var text_insert = '';
    while (pointer < diffs.length) {
      switch (diffs[pointer][0]) {
        case DIFF_INSERT:
          count_insert++;
          text_insert += diffs[pointer][1];
          break;
        case DIFF_DELETE:
          count_delete++;
          text_delete += diffs[pointer][1];
          break;
        case DIFF_EQUAL:
          // Upon reaching an equality, check for prior redundancies.
          if (count_delete >= 1 && count_insert >= 1) {
            // Delete the offending records and add the merged ones.
            var a = this.diff_main(text_delete, text_insert, false);
            diffs.splice(pointer - count_delete - count_insert,
                         count_delete + count_insert);
            pointer = pointer - count_delete - count_insert;
            for (var j = a.length - 1; j >= 0; j--) {
              diffs.splice(pointer, 0, a[j]);
            }
            pointer = pointer + a.length;
          }
          count_insert = 0;
          count_delete = 0;
          text_delete = '';
          text_insert = '';
          break;
      }
     pointer++;
    }
    diffs.pop();  // Remove the dummy entry at the end.
  }
  return diffs;
};


/**
 * Split two texts into an array of strings.  Reduce the texts to a string of
 * hashes where each Unicode character represents one line.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {Array.<string|Array.<string>>} Three element Array, containing the
 *     encoded text1, the encoded text2 and the array of unique strings.  The
 *     zeroth element of the array of unique strings is intentionally blank.
 * @private
 */
diff_match_patch.prototype.diff_linesToChars = function(text1, text2) {
  var lineArray = [];  // e.g. lineArray[4] == 'Hello\n'
  var lineHash = {};   // e.g. lineHash['Hello\n'] == 4

  // '\x00' is a valid character, but various debuggers don't like it.
  // So we'll insert a junk entry to avoid generating a null character.
  lineArray[0] = '';

  /**
   * Split a text into an array of strings.  Reduce the texts to a string of
   * hashes where each Unicode character represents one line.
   * Modifies linearray and linehash through being a closure.
   * @param {string} text String to encode.
   * @return {string} Encoded string.
   * @private
   */
  function diff_linesToCharsMunge(text) {
    var chars = '';
    // Walk the text, pulling out a substring for each line.
    // text.split('\n') would would temporarily double our memory footprint.
    // Modifying text would create many large strings to garbage collect.
    var lineStart = 0;
    var lineEnd = -1;
    // Keeping our own length variable is faster than looking it up.
    var lineArrayLength = lineArray.length;
    while (lineEnd < text.length - 1) {
      lineEnd = text.indexOf('\n', lineStart);
      if (lineEnd == -1) {
        lineEnd = text.length - 1;
      }
      var line = text.substring(lineStart, lineEnd + 1);
      lineStart = lineEnd + 1;

      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :
          (lineHash[line] !== undefined)) {
        chars += String.fromCharCode(lineHash[line]);
      } else {
        chars += String.fromCharCode(lineArrayLength);
        lineHash[line] = lineArrayLength;
        lineArray[lineArrayLength++] = line;
      }
    }
    return chars;
  }

  var chars1 = diff_linesToCharsMunge(text1);
  var chars2 = diff_linesToCharsMunge(text2);
  return [chars1, chars2, lineArray];
};


/**
 * Rehydrate the text in a diff from a string of line hashes to real lines of
 * text.
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 * @param {Array.<string>} lineArray Array of unique strings.
 * @private
 */
diff_match_patch.prototype.diff_charsToLines = function(diffs, lineArray) {
  for (var x = 0; x < diffs.length; x++) {
    var chars = diffs[x][1];
    var text = [];
    for (var y = 0; y < chars.length; y++) {
      text[y] = lineArray[chars.charCodeAt(y)];
    }
    diffs[x][1] = text.join('');
  }
};


/**
 * Explore the intersection points between the two texts.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @return {?Array.<Array.<number|string>>} Array of diff tuples or null if no
 *     diff available.
 * @private
 */
diff_match_patch.prototype.diff_map = function(text1, text2) {
  // Don't run for too long.
  var ms_end = (new Date()).getTime() + this.Diff_Timeout * 1000;
  // Cache the text lengths to prevent multiple calls.
  var text1_length = text1.length;
  var text2_length = text2.length;
  var max_d = text1_length + text2_length - 1;
  var doubleEnd = this.Diff_DualThreshold * 2 < max_d;
  // JavaScript efficiency note: (x << 32) + y doesn't work since numbers are
  // only 32 bit.  Use x + ',' + y to create a hash instead.
  var v_map1 = [];
  var v_map2 = [];
  var v1 = {};
  var v2 = {};
  v1[1] = 0;
  v2[1] = 0;
  var x, y;
  var footstep;  // Used to track overlapping paths.
  var footsteps = {};
  var done = false;
  // If the total number of characters is odd, then the front path will collide
  // with the reverse path.
  var front = (text1_length + text2_length) % 2;
  for (var d = 0; d < max_d; d++) {
    // Bail out if timeout reached.
    if (this.Diff_Timeout > 0 && (new Date()).getTime() > ms_end) {
      return null;
    }

    // Walk the front path one step.
    v_map1[d] = {};
    for (var k = -d; k <= d; k += 2) {
      if (k == -d || k != d && v1[k - 1] < v1[k + 1]) {
        x = v1[k + 1];
      } else {
        x = v1[k - 1] + 1;
      }
      y = x - k;
      if (doubleEnd) {
        footstep = x + ',' + y;
        if (front && footsteps[footstep] !== undefined) {
          done = true;
        }
        if (!front) {
          footsteps[footstep] = d;
        }
      }
      while (!done && x < text1_length && y < text2_length &&
             text1.charAt(x) == text2.charAt(y)) {
        x++;
        y++;
        if (doubleEnd) {
          footstep = x + ',' + y;
          if (front && footsteps[footstep] !== undefined) {
            done = true;
          }
          if (!front) {
            footsteps[footstep] = d;
          }
        }
      }
      v1[k] = x;
      v_map1[d][x + ',' + y] = true;
      if (x == text1_length && y == text2_length) {
        // Reached the end in single-path mode.
        return this.diff_path1(v_map1, text1, text2);
      } else if (done) {
        // Front path ran over reverse path.
        v_map2 = v_map2.slice(0, footsteps[footstep] + 1);
        var a = this.diff_path1(v_map1, text1.substring(0, x),
                                text2.substring(0, y));
        return a.concat(this.diff_path2(v_map2, text1.substring(x),
                                        text2.substring(y)));
      }
    }

    if (doubleEnd) {
      // Walk the reverse path one step.
      v_map2[d] = {};
      for (var k = -d; k <= d; k += 2) {
        if (k == -d || k != d && v2[k - 1] < v2[k + 1]) {
          x = v2[k + 1];
        } else {
          x = v2[k - 1] + 1;
        }
        y = x - k;
        footstep = (text1_length - x) + ',' + (text2_length - y);
        if (!front && footsteps[footstep] !== undefined) {
          done = true;
        }
        if (front) {
          footsteps[footstep] = d;
        }
        while (!done && x < text1_length && y < text2_length &&
               text1.charAt(text1_length - x - 1) ==
               text2.charAt(text2_length - y - 1)) {
          x++;
          y++;
          footstep = (text1_length - x) + ',' + (text2_length - y);
          if (!front && footsteps[footstep] !== undefined) {
            done = true;
          }
          if (front) {
            footsteps[footstep] = d;
          }
        }
        v2[k] = x;
        v_map2[d][x + ',' + y] = true;
        if (done) {
          // Reverse path ran over front path.
          v_map1 = v_map1.slice(0, footsteps[footstep] + 1);
          var a = this.diff_path1(v_map1, text1.substring(0, text1_length - x),
                                  text2.substring(0, text2_length - y));
          return a.concat(this.diff_path2(v_map2,
                          text1.substring(text1_length - x),
                          text2.substring(text2_length - y)));
        }
      }
    }
  }
  // Number of diffs equals number of characters, no commonality at all.
  return null;
};


/**
 * Work from the middle back to the start to determine the path.
 * @param {Array.<Object>} v_map Array of paths.
 * @param {string} text1 Old string fragment to be diffed.
 * @param {string} text2 New string fragment to be diffed.
 * @return {Array.<Array.<number|string>>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_path1 = function(v_map, text1, text2) {
  var path = [];
  var x = text1.length;
  var y = text2.length;
  /** @type {?number} */
  var last_op = null;
  for (var d = v_map.length - 2; d >= 0; d--) {
    while (1) {
      if (v_map[d][(x - 1) + ',' + y] !== undefined) {
        x--;
        if (last_op === DIFF_DELETE) {
          path[0][1] = text1.charAt(x) + path[0][1];
        } else {
          path.unshift([DIFF_DELETE, text1.charAt(x)]);
        }
        last_op = DIFF_DELETE;
        break;
      } else if (v_map[d][x + ',' + (y - 1)] !== undefined) {
        y--;
        if (last_op === DIFF_INSERT) {
          path[0][1] = text2.charAt(y) + path[0][1];
        } else {
          path.unshift([DIFF_INSERT, text2.charAt(y)]);
        }
        last_op = DIFF_INSERT;
        break;
      } else {
        x--;
        y--;
        if (text1.charAt(x) != text2.charAt(y)) {
          throw new Error('No diagonal.  Can\'t happen. (diff_path1)');
        }
        if (last_op === DIFF_EQUAL) {
          path[0][1] = text1.charAt(x) + path[0][1];
        } else {
          path.unshift([DIFF_EQUAL, text1.charAt(x)]);
        }
        last_op = DIFF_EQUAL;
      }
    }
  }
  return path;
};


/**
 * Work from the middle back to the end to determine the path.
 * @param {Array.<Object>} v_map Array of paths.
 * @param {string} text1 Old string fragment to be diffed.
 * @param {string} text2 New string fragment to be diffed.
 * @return {Array.<Array.<number|string>>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_path2 = function(v_map, text1, text2) {
  var path = [];
  var pathLength = 0;
  var x = text1.length;
  var y = text2.length;
  /** @type {?number} */
  var last_op = null;
  for (var d = v_map.length - 2; d >= 0; d--) {
    while (1) {
      if (v_map[d][(x - 1) + ',' + y] !== undefined) {
        x--;
        if (last_op === DIFF_DELETE) {
          path[pathLength - 1][1] += text1.charAt(text1.length - x - 1);
        } else {
          path[pathLength++] =
              [DIFF_DELETE, text1.charAt(text1.length - x - 1)];
        }
        last_op = DIFF_DELETE;
        break;
      } else if (v_map[d][x + ',' + (y - 1)] !== undefined) {
        y--;
        if (last_op === DIFF_INSERT) {
          path[pathLength - 1][1] += text2.charAt(text2.length - y - 1);
        } else {
          path[pathLength++] =
              [DIFF_INSERT, text2.charAt(text2.length - y - 1)];
        }
        last_op = DIFF_INSERT;
        break;
      } else {
        x--;
        y--;
        if (text1.charAt(text1.length - x - 1) !=
            text2.charAt(text2.length - y - 1)) {
          throw new Error('No diagonal.  Can\'t happen. (diff_path2)');
        }
        if (last_op === DIFF_EQUAL) {
          path[pathLength - 1][1] += text1.charAt(text1.length - x - 1);
        } else {
          path[pathLength++] =
              [DIFF_EQUAL, text1.charAt(text1.length - x - 1)];
        }
        last_op = DIFF_EQUAL;
      }
    }
  }
  return path;
};


/**
 * Determine the common prefix of two strings
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the start of each
 *     string.
 */
diff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerstart = 0;
  while (pointermin < pointermid) {
    if (text1.substring(pointerstart, pointermid) ==
        text2.substring(pointerstart, pointermid)) {
      pointermin = pointermid;
      pointerstart = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Determine the common suffix of two strings
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of each string.
 */
diff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 || text1.charAt(text1.length - 1) !=
                          text2.charAt(text2.length - 1)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerend = 0;
  while (pointermin < pointermid) {
    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
        text2.substring(text2.length - pointermid, text2.length - pointerend)) {
      pointermin = pointermid;
      pointerend = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Do the two texts share a substring which is at least half the length of the
 * longer text?
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {?Array.<string>} Five element Array, containing the prefix of
 *     text1, the suffix of text1, the prefix of text2, the suffix of
 *     text2 and the common middle.  Or null if there was no match.
 */
diff_match_patch.prototype.diff_halfMatch = function(text1, text2) {
  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  if (longtext.length < 10 || shorttext.length < 1) {
    return null;  // Pointless.
  }
  var dmp = this;  // 'this' becomes 'window' in a closure.

  /**
   * Does a substring of shorttext exist within longtext such that the substring
   * is at least half the length of longtext?
   * Closure, but does not reference any external variables.
   * @param {string} longtext Longer string.
   * @param {string} shorttext Shorter string.
   * @param {number} i Start index of quarter length substring within longtext
   * @return {?Array.<string>} Five element Array, containing the prefix of
   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
   *     of shorttext and the common middle.  Or null if there was no match.
   * @private
   */
  function diff_halfMatchI(longtext, shorttext, i) {
    // Start with a 1/4 length substring at position i as a seed.
    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
    var j = -1;
    var best_common = '';
    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),
                                               shorttext.substring(j));
      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),
                                               shorttext.substring(0, j));
      if (best_common.length < suffixLength + prefixLength) {
        best_common = shorttext.substring(j - suffixLength, j) +
            shorttext.substring(j, j + prefixLength);
        best_longtext_a = longtext.substring(0, i - suffixLength);
        best_longtext_b = longtext.substring(i + prefixLength);
        best_shorttext_a = shorttext.substring(0, j - suffixLength);
        best_shorttext_b = shorttext.substring(j + prefixLength);
      }
    }
    if (best_common.length >= longtext.length / 2) {
      return [best_longtext_a, best_longtext_b,
              best_shorttext_a, best_shorttext_b, best_common];
    } else {
      return null;
    }
  }

  // First check if the second quarter is the seed for a half-match.
  var hm1 = diff_halfMatchI(longtext, shorttext,
                            Math.ceil(longtext.length / 4));
  // Check again based on the third quarter.
  var hm2 = diff_halfMatchI(longtext, shorttext,
                            Math.ceil(longtext.length / 2));
  var hm;
  if (!hm1 && !hm2) {
    return null;
  } else if (!hm2) {
    hm = hm1;
  } else if (!hm1) {
    hm = hm2;
  } else {
    // Both matched.  Select the longest.
    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
  }

  // A half-match was found, sort out the return data.
  var text1_a, text1_b, text2_a, text2_b;
  if (text1.length > text2.length) {
    text1_a = hm[0];
    text1_b = hm[1];
    text2_a = hm[2];
    text2_b = hm[3];
  } else {
    text2_a = hm[0];
    text2_b = hm[1];
    text1_a = hm[2];
    text1_b = hm[3];
  }
  var mid_common = hm[4];
  return [text1_a, text1_b, text2_a, text2_b, mid_common];
};


/**
 * Reduce the number of edits by eliminating semantically trivial equalities.
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {
  var changes = false;
  var equalities = [];  // Stack of indices where equalities are found.
  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
  var lastequality = null;  // Always equal to equalities[equalitiesLength-1][1]
  var pointer = 0;  // Index of current position.
  // Number of characters that changed prior to the equality.
  var length_changes1 = 0;
  // Number of characters that changed after the equality.
  var length_changes2 = 0;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {  // equality found
      equalities[equalitiesLength++] = pointer;
      length_changes1 = length_changes2;
      length_changes2 = 0;
      lastequality = diffs[pointer][1];
    } else {  // an insertion or deletion
      length_changes2 += diffs[pointer][1].length;
      if (lastequality !== null && (lastequality.length <= length_changes1) &&
          (lastequality.length <= length_changes2)) {
        // Duplicate record
        diffs.splice(equalities[equalitiesLength - 1], 0,
                     [DIFF_DELETE, lastequality]);
        // Change second copy to insert.
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        // Throw away the equality we just deleted.
        equalitiesLength--;
        // Throw away the previous equality (it needs to be reevaluated).
        equalitiesLength--;
        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
        length_changes1 = 0;  // Reset the counters.
        length_changes2 = 0;
        lastequality = null;
        changes = true;
      }
    }
    pointer++;
  }
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
  this.diff_cleanupSemanticLossless(diffs);
};


/**
 * Look for single edits surrounded on both sides by equalities
 * which can be shifted sideways to align the edit to a word boundary.
 * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {
  // Define some regex patterns for matching boundaries.
  var punctuation = /[^a-zA-Z0-9]/;
  var whitespace = /\s/;
  var linebreak = /[\r\n]/;
  var blanklineEnd = /\n\r?\n$/;
  var blanklineStart = /^\r?\n\r?\n/;

  /**
   * Given two strings, compute a score representing whether the internal
   * boundary falls on logical boundaries.
   * Scores range from 5 (best) to 0 (worst).
   * Closure, makes reference to regex patterns defined above.
   * @param {string} one First string.
   * @param {string} two Second string.
   * @return {number} The score.
   */
  function diff_cleanupSemanticScore(one, two) {
    if (!one || !two) {
      // Edges are the best.
      return 5;
    }

    // Each port of this function behaves slightly differently due to
    // subtle differences in each language's definition of things like
    // 'whitespace'.  Since this function's purpose is largely cosmetic,
    // the choice has been made to use each language's native features
    // rather than force total conformity.
    var score = 0;
    // One point for non-alphanumeric.
    if (one.charAt(one.length - 1).match(punctuation) ||
        two.charAt(0).match(punctuation)) {
      score++;
      // Two points for whitespace.
      if (one.charAt(one.length - 1).match(whitespace) ||
          two.charAt(0).match(whitespace)) {
        score++;
        // Three points for line breaks.
        if (one.charAt(one.length - 1).match(linebreak) ||
            two.charAt(0).match(linebreak)) {
          score++;
          // Four points for blank lines.
          if (one.match(blanklineEnd) || two.match(blanklineStart)) {
            score++;
          }
        }
      }
    }
    return score;
  }

  var pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
        diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      var equality1 = diffs[pointer - 1][1];
      var edit = diffs[pointer][1];
      var equality2 = diffs[pointer + 1][1];

      // First, shift the edit as far left as possible.
      var commonOffset = this.diff_commonSuffix(equality1, edit);
      if (commonOffset) {
        var commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset);
        edit = commonString + edit.substring(0, edit.length - commonOffset);
        equality2 = commonString + equality2;
      }

      // Second, step character by character right, looking for the best fit.
      var bestEquality1 = equality1;
      var bestEdit = edit;
      var bestEquality2 = equality2;
      var bestScore = diff_cleanupSemanticScore(equality1, edit) +
          diff_cleanupSemanticScore(edit, equality2);
      while (edit.charAt(0) === equality2.charAt(0)) {
        equality1 += edit.charAt(0);
        edit = edit.substring(1) + equality2.charAt(0);
        equality2 = equality2.substring(1);
        var score = diff_cleanupSemanticScore(equality1, edit) +
            diff_cleanupSemanticScore(edit, equality2);
        // The >= encourages trailing rather than leading whitespace on edits.
        if (score >= bestScore) {
          bestScore = score;
          bestEquality1 = equality1;
          bestEdit = edit;
          bestEquality2 = equality2;
        }
      }

      if (diffs[pointer - 1][1] != bestEquality1) {
        // We have an improvement, save it back to the diff.
        if (bestEquality1) {
          diffs[pointer - 1][1] = bestEquality1;
        } else {
          diffs.splice(pointer - 1, 1);
          pointer--;
        }
        diffs[pointer][1] = bestEdit;
        if (bestEquality2) {
          diffs[pointer + 1][1] = bestEquality2;
        } else {
          diffs.splice(pointer + 1, 1);
          pointer--;
        }
      }
    }
    pointer++;
  }
};


/**
 * Reduce the number of edits by eliminating operationally trivial equalities.
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {
  var changes = false;
  var equalities = [];  // Stack of indices where equalities are found.
  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
  var lastequality = '';  // Always equal to equalities[equalitiesLength-1][1]
  var pointer = 0;  // Index of current position.
  // Is there an insertion operation before the last equality.
  var pre_ins = false;
  // Is there a deletion operation before the last equality.
  var pre_del = false;
  // Is there an insertion operation after the last equality.
  var post_ins = false;
  // Is there a deletion operation after the last equality.
  var post_del = false;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {  // equality found
      if (diffs[pointer][1].length < this.Diff_EditCost &&
          (post_ins || post_del)) {
        // Candidate found.
        equalities[equalitiesLength++] = pointer;
        pre_ins = post_ins;
        pre_del = post_del;
        lastequality = diffs[pointer][1];
      } else {
        // Not a candidate, and can never become one.
        equalitiesLength = 0;
        lastequality = '';
      }
      post_ins = post_del = false;
    } else {  // an insertion or deletion
      if (diffs[pointer][0] == DIFF_DELETE) {
        post_del = true;
      } else {
        post_ins = true;
      }
      /*
       * Five types to be split:
       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>
       * <ins>A</ins>X<ins>C</ins><del>D</del>
       * <ins>A</ins><del>B</del>X<ins>C</ins>
       * <ins>A</del>X<ins>C</ins><del>D</del>
       * <ins>A</ins><del>B</del>X<del>C</del>
       */
      if (lastequality && ((pre_ins && pre_del && post_ins && post_del) ||
                           ((lastequality.length < this.Diff_EditCost / 2) &&
                            (pre_ins + pre_del + post_ins + post_del) == 3))) {
        // Duplicate record
        diffs.splice(equalities[equalitiesLength - 1], 0,
                     [DIFF_DELETE, lastequality]);
        // Change second copy to insert.
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        equalitiesLength--;  // Throw away the equality we just deleted;
        lastequality = '';
        if (pre_ins && pre_del) {
          // No changes made which could affect previous entry, keep going.
          post_ins = post_del = true;
          equalitiesLength = 0;
        } else {
          equalitiesLength--;  // Throw away the previous equality;
          pointer = equalitiesLength > 0 ?
              equalities[equalitiesLength - 1] : -1;
          post_ins = post_del = false;
        }
        changes = true;
      }
    }
    pointer++;
  }

  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};


/**
 * Reorder and merge like edit sections.  Merge equalities.
 * Any edit section can move as long as it doesn't cross an equality.
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupMerge = function(diffs) {
  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = '';
  var text_insert = '';
  var commonlength;
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_EQUAL:
        // Upon reaching an equality, check for prior redundancies.
        if (count_delete !== 0 || count_insert !== 0) {
          if (count_delete !== 0 && count_insert !== 0) {
            // Factor out any common prefixies.
            commonlength = this.diff_commonPrefix(text_insert, text_delete);
            if (commonlength !== 0) {
              if ((pointer - count_delete - count_insert) > 0 &&
                  diffs[pointer - count_delete - count_insert - 1][0] ==
                  DIFF_EQUAL) {
                diffs[pointer - count_delete - count_insert - 1][1] +=
                    text_insert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, [DIFF_EQUAL,
                    text_insert.substring(0, commonlength)]);
                pointer++;
              }
              text_insert = text_insert.substring(commonlength);
              text_delete = text_delete.substring(commonlength);
            }
            // Factor out any common suffixies.
            commonlength = this.diff_commonSuffix(text_insert, text_delete);
            if (commonlength !== 0) {
              diffs[pointer][1] = text_insert.substring(text_insert.length -
                  commonlength) + diffs[pointer][1];
              text_insert = text_insert.substring(0, text_insert.length -
                  commonlength);
              text_delete = text_delete.substring(0, text_delete.length -
                  commonlength);
            }
          }
          // Delete the offending records and add the merged ones.
          if (count_delete === 0) {
            diffs.splice(pointer - count_delete - count_insert,
                count_delete + count_insert, [DIFF_INSERT, text_insert]);
          } else if (count_insert === 0) {
            diffs.splice(pointer - count_delete - count_insert,
                count_delete + count_insert, [DIFF_DELETE, text_delete]);
          } else {
            diffs.splice(pointer - count_delete - count_insert,
                count_delete + count_insert, [DIFF_DELETE, text_delete],
                [DIFF_INSERT, text_insert]);
          }
          pointer = pointer - count_delete - count_insert +
                    (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
          // Merge this equality with the previous one.
          diffs[pointer - 1][1] += diffs[pointer][1];
          diffs.splice(pointer, 1);
        } else {
          pointer++;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = '';
        text_insert = '';
        break;
    }
  }
  if (diffs[diffs.length - 1][1] === '') {
    diffs.pop();  // Remove the dummy entry at the end.
  }

  // Second pass: look for single edits surrounded on both sides by equalities
  // which can be shifted sideways to eliminate an equality.
  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
  var changes = false;
  pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
        diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      if (diffs[pointer][1].substring(diffs[pointer][1].length -
          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
        // Shift the edit over the previous equality.
        diffs[pointer][1] = diffs[pointer - 1][1] +
            diffs[pointer][1].substring(0, diffs[pointer][1].length -
                                        diffs[pointer - 1][1].length);
        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
        diffs.splice(pointer - 1, 1);
        changes = true;
      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
          diffs[pointer + 1][1]) {
        // Shift the edit over the next equality.
        diffs[pointer - 1][1] += diffs[pointer + 1][1];
        diffs[pointer][1] =
            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
            diffs[pointer + 1][1];
        diffs.splice(pointer + 1, 1);
        changes = true;
      }
    }
    pointer++;
  }
  // If shifts were made, the diff needs reordering and another shift sweep.
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};


/**
 * loc is a location in text1, compute and return the equivalent location in
 * text2.
 * e.g. 'The cat' vs 'The big cat', 1->1, 5->8
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 * @param {number} loc Location within text1.
 * @return {number} Location within text2.
 */
diff_match_patch.prototype.diff_xIndex = function(diffs, loc) {
  var chars1 = 0;
  var chars2 = 0;
  var last_chars1 = 0;
  var last_chars2 = 0;
  var x;
  for (x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.
      chars1 += diffs[x][1].length;
    }
    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.
      chars2 += diffs[x][1].length;
    }
    if (chars1 > loc) {  // Overshot the location.
      break;
    }
    last_chars1 = chars1;
    last_chars2 = chars2;
  }
  // Was the location was deleted?
  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {
    return last_chars2;
  }
  // Add the remaining character length.
  return last_chars2 + (loc - last_chars1);
};


/**
 * Convert a diff array into a pretty HTML report.
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 * @return {string} HTML representation.
 */
diff_match_patch.prototype.diff_prettyHtml = function(diffs) {
  var html = [];
  var i = 0;
  for (var x = 0; x < diffs.length; x++) {
    var op = diffs[x][0];    // Operation (insert, delete, equal)
    var data = diffs[x][1];  // Text of change.
    var text = data.replace(/&/g, '&amp;').replace(/</g, '&lt;')
        .replace(/>/g, '&gt;').replace(/\n/g, '&para;<BR>');
    switch (op) {
      case DIFF_INSERT:
        html[x] = '<INS STYLE="background:#E6FFE6;" TITLE="i=' + i + '">' +
                text + '</INS>';
        break;
      case DIFF_DELETE:
        html[x] = '<DEL STYLE="background:#FFE6E6;" TITLE="i=' + i + '">' +
                text + '</DEL>';
        break;
      case DIFF_EQUAL:
        html[x] = '<SPAN TITLE="i=' + i + '">' + text + '</SPAN>';
        break;
    }
    if (op !== DIFF_DELETE) {
      i += data.length;
    }
  }
  return html.join('');
};


/**
 * Compute and return the source text (all equalities and deletions).
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 * @return {string} Source text.
 */
diff_match_patch.prototype.diff_text1 = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {
      text[x] = diffs[x][1];
    }
  }
  return text.join('');
};


/**
 * Compute and return the destination text (all equalities and insertions).
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 * @return {string} Destination text.
 */
diff_match_patch.prototype.diff_text2 = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_DELETE) {
      text[x] = diffs[x][1];
    }
  }
  return text.join('');
};


/**
 * Compute the Levenshtein distance; the number of inserted, deleted or
 * substituted characters.
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 * @return {number} Number of changes.
 */
diff_match_patch.prototype.diff_levenshtein = function(diffs) {
  var levenshtein = 0;
  var insertions = 0;
  var deletions = 0;
  for (var x = 0; x < diffs.length; x++) {
    var op = diffs[x][0];
    var data = diffs[x][1];
    switch (op) {
      case DIFF_INSERT:
        insertions += data.length;
        break;
      case DIFF_DELETE:
        deletions += data.length;
        break;
      case DIFF_EQUAL:
        // A deletion and an insertion is one substitution.
        levenshtein += Math.max(insertions, deletions);
        insertions = 0;
        deletions = 0;
        break;
    }
  }
  levenshtein += Math.max(insertions, deletions);
  return levenshtein;
};


/**
 * Crush the diff into an encoded string which describes the operations
 * required to transform text1 into text2.
 * E.g. =3\t-2\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.
 * Operations are tab-separated.  Inserted text is escaped using %xx notation.
 * @param {Array.<Array.<number|string>>} diffs Array of diff tuples.
 * @return {string} Delta text.
 */
diff_match_patch.prototype.diff_toDelta = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    switch (diffs[x][0]) {
      case DIFF_INSERT:
        text[x] = '+' + encodeURI(diffs[x][1]);
        break;
      case DIFF_DELETE:
        text[x] = '-' + diffs[x][1].length;
        break;
      case DIFF_EQUAL:
        text[x] = '=' + diffs[x][1].length;
        break;
    }
  }
  // Opera doesn't know how to encode char 0.
  return text.join('\t').replace(/\x00/g, '%00').replace(/%20/g, ' ');
};


/**
 * Given the original text1, and an encoded string which describes the
 * operations required to transform text1 into text2, compute the full diff.
 * @param {string} text1 Source string for the diff.
 * @param {string} delta Delta text.
 * @return {Array.<Array.<number|string>>} Array of diff tuples.
 * @throws {Error} If invalid input.
 */
diff_match_patch.prototype.diff_fromDelta = function(text1, delta) {
  var diffs = [];
  var diffsLength = 0;  // Keeping our own length var is faster in JS.
  var pointer = 0;  // Cursor in text1
  // Opera doesn't know how to decode char 0.
  delta = delta.replace(/%00/g, '\0');
  var tokens = delta.split(/\t/g);
  for (var x = 0; x < tokens.length; x++) {
    // Each token begins with a one character parameter which specifies the
    // operation of this token (delete, insert, equality).
    var param = tokens[x].substring(1);
    switch (tokens[x].charAt(0)) {
      case '+':
        try {
          diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)];
        } catch (ex) {
          // Malformed URI sequence.
          throw new Error('Illegal escape in diff_fromDelta: ' + param);
        }
        break;
      case '-':
        // Fall through.
      case '=':
        var n = parseInt(param, 10);
        if (isNaN(n) || n < 0) {
          throw new Error('Invalid number in diff_fromDelta: ' + param);
        }
        var text = text1.substring(pointer, pointer += n);
        if (tokens[x].charAt(0) == '=') {
          diffs[diffsLength++] = [DIFF_EQUAL, text];
        } else {
          diffs[diffsLength++] = [DIFF_DELETE, text];
        }
        break;
      default:
        // Blank tokens are ok (from a trailing \t).
        // Anything else is an error.
        if (tokens[x]) {
          throw new Error('Invalid diff operation in diff_fromDelta: ' +
                          tokens[x]);
        }
    }
  }
  if (pointer != text1.length) {
    throw new Error('Delta length (' + pointer +
        ') does not equal source text length (' + text1.length + ').');
  }
  return diffs;
};


//  MATCH FUNCTIONS


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc'.
 * @param {string} text The text to search.
 * @param {string} pattern The pattern to search for.
 * @param {number} loc The location to search around.
 * @return {number} Best match index or -1.
 */
diff_match_patch.prototype.match_main = function(text, pattern, loc) {
  // Check for null inputs.
  if (text == null || pattern == null || loc == null) {
    throw new Error('Null input. (match_main)');
  }

  loc = Math.max(0, Math.min(loc, text.length));
  if (text == pattern) {
    // Shortcut (potentially not guaranteed by the algorithm)
    return 0;
  } else if (!text.length) {
    // Nothing to match.
    return -1;
  } else if (text.substring(loc, loc + pattern.length) == pattern) {
    // Perfect match at the perfect spot!  (Includes case of null pattern)
    return loc;
  } else {
    // Do a fuzzy compare.
    return this.match_bitap(text, pattern, loc);
  }
};


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc' using the
 * Bitap algorithm.
 * @param {string} text The text to search.
 * @param {string} pattern The pattern to search for.
 * @param {number} loc The location to search around.
 * @return {number} Best match index or -1.
 * @private
 */
diff_match_patch.prototype.match_bitap = function(text, pattern, loc) {
  if (pattern.length > this.Match_MaxBits) {
    throw new Error('Pattern too long for this browser.');
  }

  // Initialise the alphabet.
  var s = this.match_alphabet(pattern);

  var dmp = this;  // 'this' becomes 'window' in a closure.

  /**
   * Compute and return the score for a match with e errors and x location.
   * Accesses loc and pattern through being a closure.
   * @param {number} e Number of errors in match.
   * @param {number} x Location of match.
   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).
   * @private
   */
  function match_bitapScore(e, x) {
    var accuracy = e / pattern.length;
    var proximity = Math.abs(loc - x);
    if (!dmp.Match_Distance) {
      // Dodge divide by zero error.
      return proximity ? 1.0 : accuracy;
    }
    return accuracy + (proximity / dmp.Match_Distance);
  }

  // Highest score beyond which we give up.
  var score_threshold = this.Match_Threshold;
  // Is there a nearby exact match? (speedup)
  var best_loc = text.indexOf(pattern, loc);
  if (best_loc != -1) {
    score_threshold = Math.min(match_bitapScore(0, best_loc), score_threshold);
    // What about in the other direction? (speedup)
    best_loc = text.lastIndexOf(pattern, loc + pattern.length);
    if (best_loc != -1) {
      score_threshold =
          Math.min(match_bitapScore(0, best_loc), score_threshold);
    }
  }

  // Initialise the bit arrays.
  var matchmask = 1 << (pattern.length - 1);
  best_loc = -1;

  var bin_min, bin_mid;
  var bin_max = pattern.length + text.length;
  var last_rd;
  for (var d = 0; d < pattern.length; d++) {
    // Scan for the best match; each iteration allows for one more error.
    // Run a binary search to determine how far from 'loc' we can stray at this
    // error level.
    bin_min = 0;
    bin_mid = bin_max;
    while (bin_min < bin_mid) {
      if (match_bitapScore(d, loc + bin_mid) <= score_threshold) {
        bin_min = bin_mid;
      } else {
        bin_max = bin_mid;
      }
      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);
    }
    // Use the result from this iteration as the maximum for the next.
    bin_max = bin_mid;
    var start = Math.max(1, loc - bin_mid + 1);
    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;

    var rd = Array(finish + 2);
    rd[finish + 1] = (1 << d) - 1;
    for (var j = finish; j >= start; j--) {
      // The alphabet (s) is a sparse hash, so the following line generates
      // warnings.
      var charMatch = s[text.charAt(j - 1)];
      if (d === 0) {  // First pass: exact match.
        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;
      } else {  // Subsequent passes: fuzzy match.
        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch |
                (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |
                last_rd[j + 1];
      }
      if (rd[j] & matchmask) {
        var score = match_bitapScore(d, j - 1);
        // This match will almost certainly be better than any existing match.
        // But check anyway.
        if (score <= score_threshold) {
          // Told you so.
          score_threshold = score;
          best_loc = j - 1;
          if (best_loc > loc) {
            // When passing loc, don't exceed our current distance from loc.
            start = Math.max(1, 2 * loc - best_loc);
          } else {
            // Already passed loc, downhill from here on in.
            break;
          }
        }
      }
    }
    // No hope for a (better) match at greater error levels.
    if (match_bitapScore(d + 1, loc) > score_threshold) {
      break;
    }
    last_rd = rd;
  }
  return best_loc;
};


/**
 * Initialise the alphabet for the Bitap algorithm.
 * @param {string} pattern The text to encode.
 * @return {Object} Hash of character locations.
 * @private
 */
diff_match_patch.prototype.match_alphabet = function(pattern) {
  var s = {};
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] = 0;
  }
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);
  }
  return s;
};


//  PATCH FUNCTIONS


/**
 * Increase the context until it is unique,
 * but don't let the pattern expand beyond Match_MaxBits.
 * @param {patch_obj} patch The patch to grow.
 * @param {string} text Source text.
 * @private
 */
diff_match_patch.prototype.patch_addContext = function(patch, text) {
  if (text.length == 0) {
    return;
  }
  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);
  var padding = 0;

  // Look for the first and last matches of pattern in text.  If two different
  // matches are found, increase the pattern length.
  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&
         pattern.length < this.Match_MaxBits - this.Patch_Margin -
         this.Patch_Margin) {
    padding += this.Patch_Margin;
    pattern = text.substring(patch.start2 - padding,
                             patch.start2 + patch.length1 + padding);
  }
  // Add one chunk for good luck.
  padding += this.Patch_Margin;

  // Add the prefix.
  var prefix = text.substring(patch.start2 - padding, patch.start2);
  if (prefix) {
    patch.diffs.unshift([DIFF_EQUAL, prefix]);
  }
  // Add the suffix.
  var suffix = text.substring(patch.start2 + patch.length1,
                              patch.start2 + patch.length1 + padding);
  if (suffix) {
    patch.diffs.push([DIFF_EQUAL, suffix]);
  }

  // Roll back the start points.
  patch.start1 -= prefix.length;
  patch.start2 -= prefix.length;
  // Extend the lengths.
  patch.length1 += prefix.length + suffix.length;
  patch.length2 += prefix.length + suffix.length;
};


/**
 * Compute a list of patches to turn text1 into text2.
 * Use diffs if provided, otherwise compute it ourselves.
 * There are four ways to call this function, depending on what data is
 * available to the caller:
 * Method 1:
 * a = text1, b = text2
 * Method 2:
 * a = diffs
 * Method 3 (optimal):
 * a = text1, b = diffs
 * Method 4 (deprecated, use method 3):
 * a = text1, b = text2, c = diffs
 *
 * @param {string|Array.<Array.<number|string>>} a text1 (methods 1,3,4) or
 * Array of diff tuples for text1 to text2 (method 2).
 * @param {string|Array.<Array.<number|string>>} opt_b text2 (methods 1,4) or
 * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).
 * @param {string|Array.<Array.<number|string>>} opt_c Array of diff tuples for
 * text1 to text2 (method 4) or undefined (methods 1,2,3).
 * @return {Array.<patch_obj>} Array of patch objects.
 */
diff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {
  var text1, diffs;
  if (typeof a == 'string' && typeof opt_b == 'string' &&
      typeof opt_c == 'undefined') {
    // Method 1: text1, text2
    // Compute diffs from text1 and text2.
    text1 = a;
    diffs = this.diff_main(text1, opt_b, true);
    if (diffs.length > 2) {
      this.diff_cleanupSemantic(diffs);
      this.diff_cleanupEfficiency(diffs);
    }
  } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&
      typeof opt_c == 'undefined') {
    // Method 2: diffs
    // Compute text1 from diffs.
    diffs = a;
    text1 = this.diff_text1(diffs);
  } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&
      typeof opt_c == 'undefined') {
    // Method 3: text1, diffs
    text1 = a;
    diffs = opt_b;
  } else if (typeof a == 'string' && typeof opt_b == 'string' &&
      opt_c && typeof opt_c == 'object') {
    // Method 4: text1, text2, diffs
    // text2 is not used.
    text1 = a;
    diffs = opt_c;
  } else {
    throw new Error('Unknown call format to patch_make.');
  }

  if (diffs.length === 0) {
    return [];  // Get rid of the null case.
  }
  var patches = [];
  var patch = new patch_obj();
  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.
  var char_count1 = 0;  // Number of characters into the text1 string.
  var char_count2 = 0;  // Number of characters into the text2 string.
  // Start with text1 (prepatch_text) and apply the diffs until we arrive at
  // text2 (postpatch_text).  We recreate the patches one by one to determine
  // context info.
  var prepatch_text = text1;
  var postpatch_text = text1;
  for (var x = 0; x < diffs.length; x++) {
    var diff_type = diffs[x][0];
    var diff_text = diffs[x][1];

    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
      // A new patch starts here.
      patch.start1 = char_count1;
      patch.start2 = char_count2;
    }

    switch (diff_type) {
      case DIFF_INSERT:
        patch.diffs[patchDiffLength++] = diffs[x];
        patch.length2 += diff_text.length;
        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +
                         postpatch_text.substring(char_count2);
        break;
      case DIFF_DELETE:
        patch.length1 += diff_text.length;
        patch.diffs[patchDiffLength++] = diffs[x];
        postpatch_text = postpatch_text.substring(0, char_count2) +
                         postpatch_text.substring(char_count2 +
                             diff_text.length);
        break;
      case DIFF_EQUAL:
        if (diff_text.length <= 2 * this.Patch_Margin &&
            patchDiffLength && diffs.length != x + 1) {
          // Small equality inside a patch.
          patch.diffs[patchDiffLength++] = diffs[x];
          patch.length1 += diff_text.length;
          patch.length2 += diff_text.length;
        } else if (diff_text.length >= 2 * this.Patch_Margin) {
          // Time for a new patch.
          if (patchDiffLength) {
            this.patch_addContext(patch, prepatch_text);
            patches.push(patch);
            patch = new patch_obj();
            patchDiffLength = 0;
            // Unlike Unidiff, our patch lists have a rolling context.
            // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff
            // Update prepatch text & pos to reflect the application of the
            // just completed patch.
            prepatch_text = postpatch_text;
            char_count1 = char_count2;
          }
        }
        break;
    }

    // Update the current character count.
    if (diff_type !== DIFF_INSERT) {
      char_count1 += diff_text.length;
    }
    if (diff_type !== DIFF_DELETE) {
      char_count2 += diff_text.length;
    }
  }
  // Pick up the leftover patch if not empty.
  if (patchDiffLength) {
    this.patch_addContext(patch, prepatch_text);
    patches.push(patch);
  }

  return patches;
};


/**
 * Given an array of patches, return another array that is identical.
 * @param {Array.<patch_obj>} patches Array of patch objects.
 * @return {Array.<patch_obj>} Array of patch objects.
 */
diff_match_patch.prototype.patch_deepCopy = function(patches) {
  // Making deep copies is hard in JavaScript.
  var patchesCopy = [];
  for (var x = 0; x < patches.length; x++) {
    var patch = patches[x];
    var patchCopy = new patch_obj();
    patchCopy.diffs = [];
    for (var y = 0; y < patch.diffs.length; y++) {
      patchCopy.diffs[y] = patch.diffs[y].slice();
    }
    patchCopy.start1 = patch.start1;
    patchCopy.start2 = patch.start2;
    patchCopy.length1 = patch.length1;
    patchCopy.length2 = patch.length2;
    patchesCopy[x] = patchCopy;
  }
  return patchesCopy;
};


/**
 * Merge a set of patches onto the text.  Return a patched text, as well
 * as a list of true/false values indicating which patches were applied.
 * @param {Array.<patch_obj>} patches Array of patch objects.
 * @param {string} text Old text.
 * @return {Array.<string|Array.<boolean>>} Two element Array, containing the
 *      new text and an array of boolean values.
 */
diff_match_patch.prototype.patch_apply = function(patches, text) {
  if (patches.length == 0) {
    return [text, []];
  }

  // Deep copy the patches so that no changes are made to originals.
  patches = this.patch_deepCopy(patches);

  var nullPadding = this.patch_addPadding(patches);
  text = nullPadding + text + nullPadding;

  this.patch_splitMax(patches);
  // delta keeps track of the offset between the expected and actual location
  // of the previous patch.  If there are patches expected at positions 10 and
  // 20, but the first patch was found at 12, delta is 2 and the second patch
  // has an effective expected position of 22.
  var delta = 0;
  var results = [];
  for (var x = 0; x < patches.length; x++) {
    var expected_loc = patches[x].start2 + delta;
    var text1 = this.diff_text1(patches[x].diffs);
    var start_loc;
    var end_loc = -1;
    if (text1.length > this.Match_MaxBits) {
      // patch_splitMax will only provide an oversized pattern in the case of
      // a monster delete.
      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),
                                  expected_loc);
      if (start_loc != -1) {
        end_loc = this.match_main(text,
            text1.substring(text1.length - this.Match_MaxBits),
            expected_loc + text1.length - this.Match_MaxBits);
        if (end_loc == -1 || start_loc >= end_loc) {
          // Can't find valid trailing context.  Drop this patch.
          start_loc = -1;
        }
      }
    } else {
      start_loc = this.match_main(text, text1, expected_loc);
    }
    if (start_loc == -1) {
      // No match found.  :(
      results[x] = false;
      // Subtract the delta for this failed patch from subsequent patches.
      delta -= patches[x].length2 - patches[x].length1;
    } else {
      // Found a match.  :)
      results[x] = true;
      delta = start_loc - expected_loc;
      var text2;
      if (end_loc == -1) {
        text2 = text.substring(start_loc, start_loc + text1.length);
      } else {
        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);
      }
      if (text1 == text2) {
        // Perfect match, just shove the replacement text in.
        text = text.substring(0, start_loc) +
               this.diff_text2(patches[x].diffs) +
               text.substring(start_loc + text1.length);
      } else {
        // Imperfect match.  Run a diff to get a framework of equivalent
        // indices.
        var diffs = this.diff_main(text1, text2, false);
        if (text1.length > this.Match_MaxBits &&
            this.diff_levenshtein(diffs) / text1.length >
            this.Patch_DeleteThreshold) {
          // The end points match, but the content is unacceptably bad.
          results[x] = false;
        } else {
          this.diff_cleanupSemanticLossless(diffs);
          var index1 = 0;
          var index2;
          for (var y = 0; y < patches[x].diffs.length; y++) {
            var mod = patches[x].diffs[y];
            if (mod[0] !== DIFF_EQUAL) {
              index2 = this.diff_xIndex(diffs, index1);
            }
            if (mod[0] === DIFF_INSERT) {  // Insertion
              text = text.substring(0, start_loc + index2) + mod[1] +
                     text.substring(start_loc + index2);
            } else if (mod[0] === DIFF_DELETE) {  // Deletion
              text = text.substring(0, start_loc + index2) +
                     text.substring(start_loc + this.diff_xIndex(diffs,
                         index1 + mod[1].length));
            }
            if (mod[0] !== DIFF_DELETE) {
              index1 += mod[1].length;
            }
          }
        }
      }
    }
  }
  // Strip the padding off.
  text = text.substring(nullPadding.length, text.length - nullPadding.length);
  return [text, results];
};


/**
 * Add some padding on text start and end so that edges can match something.
 * Intended to be called only from within patch_apply.
 * @param {Array.<patch_obj>} patches Array of patch objects.
 * @return {string} The padding string added to each side.
 */
diff_match_patch.prototype.patch_addPadding = function(patches) {
  var paddingLength = this.Patch_Margin;
  var nullPadding = '';
  for (var x = 1; x <= paddingLength; x++) {
    nullPadding += String.fromCharCode(x);
  }

  // Bump all the patches forward.
  for (var x = 0; x < patches.length; x++) {
    patches[x].start1 += paddingLength;
    patches[x].start2 += paddingLength;
  }

  // Add some padding on start of first diff.
  var patch = patches[0];
  var diffs = patch.diffs;
  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
    // Add nullPadding equality.
    diffs.unshift([DIFF_EQUAL, nullPadding]);
    patch.start1 -= paddingLength;  // Should be 0.
    patch.start2 -= paddingLength;  // Should be 0.
    patch.length1 += paddingLength;
    patch.length2 += paddingLength;
  } else if (paddingLength > diffs[0][1].length) {
    // Grow first equality.
    var extraLength = paddingLength - diffs[0][1].length;
    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
    patch.start1 -= extraLength;
    patch.start2 -= extraLength;
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }

  // Add some padding on end of last diff.
  patch = patches[patches.length - 1];
  diffs = patch.diffs;
  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
    // Add nullPadding equality.
    diffs.push([DIFF_EQUAL, nullPadding]);
    patch.length1 += paddingLength;
    patch.length2 += paddingLength;
  } else if (paddingLength > diffs[diffs.length - 1][1].length) {
    // Grow last equality.
    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;
    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }

  return nullPadding;
};


/**
 * Look through the patches and break up any which are longer than the maximum
 * limit of the match algorithm.
 * @param {Array.<patch_obj>} patches Array of patch objects.
 */
diff_match_patch.prototype.patch_splitMax = function(patches) {
  for (var x = 0; x < patches.length; x++) {
    if (patches[x].length1 > this.Match_MaxBits) {
      var bigpatch = patches[x];
      // Remove the big old patch.
      patches.splice(x--, 1);
      var patch_size = this.Match_MaxBits;
      var start1 = bigpatch.start1;
      var start2 = bigpatch.start2;
      var precontext = '';
      while (bigpatch.diffs.length !== 0) {
        // Create one of several smaller patches.
        var patch = new patch_obj();
        var empty = true;
        patch.start1 = start1 - precontext.length;
        patch.start2 = start2 - precontext.length;
        if (precontext !== '') {
          patch.length1 = patch.length2 = precontext.length;
          patch.diffs.push([DIFF_EQUAL, precontext]);
        }
        while (bigpatch.diffs.length !== 0 &&
               patch.length1 < patch_size - this.Patch_Margin) {
          var diff_type = bigpatch.diffs[0][0];
          var diff_text = bigpatch.diffs[0][1];
          if (diff_type === DIFF_INSERT) {
            // Insertions are harmless.
            patch.length2 += diff_text.length;
            start2 += diff_text.length;
            patch.diffs.push(bigpatch.diffs.shift());
            empty = false;
          } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&
                     patch.diffs[0][0] == DIFF_EQUAL &&
                     diff_text.length > 2 * patch_size) {
            // This is a large deletion.  Let it pass in one chunk.
            patch.length1 += diff_text.length;
            start1 += diff_text.length;
            empty = false;
            patch.diffs.push([diff_type, diff_text]);
            bigpatch.diffs.shift();
          } else {
            // Deletion or equality.  Only take as much as we can stomach.
            diff_text = diff_text.substring(0, patch_size - patch.length1 -
                                               this.Patch_Margin);
            patch.length1 += diff_text.length;
            start1 += diff_text.length;
            if (diff_type === DIFF_EQUAL) {
              patch.length2 += diff_text.length;
              start2 += diff_text.length;
            } else {
              empty = false;
            }
            patch.diffs.push([diff_type, diff_text]);
            if (diff_text == bigpatch.diffs[0][1]) {
              bigpatch.diffs.shift();
            } else {
              bigpatch.diffs[0][1] =
                  bigpatch.diffs[0][1].substring(diff_text.length);
            }
          }
        }
        // Compute the head context for the next patch.
        precontext = this.diff_text2(patch.diffs);
        precontext =
            precontext.substring(precontext.length - this.Patch_Margin);
        // Append the end context for this patch.
        var postcontext = this.diff_text1(bigpatch.diffs)
                              .substring(0, this.Patch_Margin);
        if (postcontext !== '') {
          patch.length1 += postcontext.length;
          patch.length2 += postcontext.length;
          if (patch.diffs.length !== 0 &&
              patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {
            patch.diffs[patch.diffs.length - 1][1] += postcontext;
          } else {
            patch.diffs.push([DIFF_EQUAL, postcontext]);
          }
        }
        if (!empty) {
          patches.splice(++x, 0, patch);
        }
      }
    }
  }
};


/**
 * Take a list of patches and return a textual representation.
 * @param {Array.<patch_obj>} patches Array of patch objects.
 * @return {string} Text representation of patches.
 */
diff_match_patch.prototype.patch_toText = function(patches) {
  var text = [];
  for (var x = 0; x < patches.length; x++) {
    text[x] = patches[x];
  }
  return text.join('');
};


/**
 * Parse a textual representation of patches and return a list of patch objects.
 * @param {string} textline Text representation of patches.
 * @return {Array.<patch_obj>} Array of patch objects.
 * @throws {Error} If invalid input.
 */
diff_match_patch.prototype.patch_fromText = function(textline) {
  var patches = [];
  if (!textline) {
    return patches;
  }
  // Opera doesn't know how to decode char 0.
  textline = textline.replace(/%00/g, '\0');
  var text = textline.split('\n');
  var textPointer = 0;
  while (textPointer < text.length) {
    var m = text[textPointer].match(/^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/);
    if (!m) {
      throw new Error('Invalid patch string: ' + text[textPointer]);
    }
    var patch = new patch_obj();
    patches.push(patch);
    patch.start1 = parseInt(m[1], 10);
    if (m[2] === '') {
      patch.start1--;
      patch.length1 = 1;
    } else if (m[2] == '0') {
      patch.length1 = 0;
    } else {
      patch.start1--;
      patch.length1 = parseInt(m[2], 10);
    }

    patch.start2 = parseInt(m[3], 10);
    if (m[4] === '') {
      patch.start2--;
      patch.length2 = 1;
    } else if (m[4] == '0') {
      patch.length2 = 0;
    } else {
      patch.start2--;
      patch.length2 = parseInt(m[4], 10);
    }
    textPointer++;

    while (textPointer < text.length) {
      var sign = text[textPointer].charAt(0);
      try {
        var line = decodeURI(text[textPointer].substring(1));
      } catch (ex) {
        // Malformed URI sequence.
        throw new Error('Illegal escape in patch_fromText: ' + line);
      }
      if (sign == '-') {
        // Deletion.
        patch.diffs.push([DIFF_DELETE, line]);
      } else if (sign == '+') {
        // Insertion.
        patch.diffs.push([DIFF_INSERT, line]);
      } else if (sign == ' ') {
        // Minor equality.
        patch.diffs.push([DIFF_EQUAL, line]);
      } else if (sign == '@') {
        // Start of next patch.
        break;
      } else if (sign === '') {
        // Blank line?  Whatever.
      } else {
        // WTF?
        throw new Error('Invalid patch mode "' + sign + '" in: ' + line);
      }
      textPointer++;
    }
  }
  return patches;
};


/**
 * Class representing one patch operation.
 * @constructor
 */
function patch_obj() {
  /** @type {Array.<Array.<number|string>>} */
  this.diffs = [];
  /** @type {?number} */
  this.start1 = null;
  /** @type {?number} */
  this.start2 = null;
  /** @type {number} */
  this.length1 = 0;
  /** @type {number} */
  this.length2 = 0;
}


/**
 * Emmulate GNU diff's format.
 * Header: @@ -382,8 +481,9 @@
 * Indicies are printed as 1-based, not 0-based.
 * @return {string} The GNU diff string.
 */
patch_obj.prototype.toString = function() {
  var coords1, coords2;
  if (this.length1 === 0) {
    coords1 = this.start1 + ',0';
  } else if (this.length1 == 1) {
    coords1 = this.start1 + 1;
  } else {
    coords1 = (this.start1 + 1) + ',' + this.length1;
  }
  if (this.length2 === 0) {
    coords2 = this.start2 + ',0';
  } else if (this.length2 == 1) {
    coords2 = this.start2 + 1;
  } else {
    coords2 = (this.start2 + 1) + ',' + this.length2;
  }
  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\n'];
  var op;
  // Escape the body of the patch with %xx notation.
  for (var x = 0; x < this.diffs.length; x++) {
    switch (this.diffs[x][0]) {
      case DIFF_INSERT:
        op = '+';
        break;
      case DIFF_DELETE:
        op = '-';
        break;
      case DIFF_EQUAL:
        op = ' ';
        break;
    }
    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\n';
  }
  // Opera doesn't know how to encode char 0.
  return text.join('').replace(/\x00/g, '%00').replace(/%20/g, ' ');
};


// Export these global variables so that they survive Google's JS compiler.
/*changed by lfborjas: changed `window` for `exports` to make it suitable for the node.js module conventions*/
exports.diff_match_patch = diff_match_patch;
exports.patch_obj = patch_obj;
exports.DIFF_DELETE = DIFF_DELETE;
exports.DIFF_INSERT = DIFF_INSERT;
exports.DIFF_EQUAL = DIFF_EQUAL;


/***/ }),

/***/ "./example/client/index.ts":
/*!*********************************!*\
  !*** ./example/client/index.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const index_1 = __importDefault(__webpack_require__(/*! ../../src/browser_sdk/index */ "./src/browser_sdk/index.ts"));
const lrEditor_1 = __importDefault(__webpack_require__(/*! ./lrEditor */ "./example/client/lrEditor.ts"));
document.addEventListener('DOMContentLoaded', (event) => __awaiter(void 0, void 0, void 0, function* () {
    const linkedRecords = new index_1.default(new URL('http://10.60.3.218:3000'));
    // const content = await linkedRecords.Attribute.create('longText', 'inital');
    // console.log('New ContentId', content.id);
    // const contentId = content.id;
    const contentId = 'l-39d5ab07-b571-4d3b-abf0-2a5974fe41df';
    let { content: contentAttribute, refernces: [referencesAttribute] } = yield linkedRecords.Attribute.findAll({
        content: contentId,
        refernces: [
            ['isA', 'referenceStore'],
            ['belongsTo', contentId],
        ],
        referenceSources: [
            ['isA', 'referenceSourceStore'],
            ['belongsTo', contentId],
            ['belongsTo', 'usr-xx'],
        ]
    });
    if (!referencesAttribute) {
        referencesAttribute = (yield linkedRecords.Attribute.create('keyValue', {}));
        yield linkedRecords.Fact.createAll([
            [referencesAttribute.id, 'isA', 'referenceStore'],
            [referencesAttribute.id, 'belongsTo', contentId]
        ]);
    }
    (0, lrEditor_1.default)('value', contentAttribute, referencesAttribute);
}));


/***/ }),

/***/ "./example/client/lrEditor.ts":
/*!************************************!*\
  !*** ./example/client/lrEditor.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const editor_1 = __importDefault(__webpack_require__(/*! structured-text-editor/src/editor */ "../structured-text-editor/src/editor.js"));
const changesets_1 = __webpack_require__(/*! changesets */ "./node_modules/changesets/lib/index.js");
const key_value_change_1 = __importDefault(__webpack_require__(/*! ../../src/attributes/key_value/key_value_change */ "./src/attributes/key_value/key_value_change.ts"));
const long_text_change_1 = __importDefault(__webpack_require__(/*! ../../src/attributes/long_text/long_text_change */ "./src/attributes/long_text/long_text_change.ts"));
function default_1(domId, contentAttribute, referencesAttribute) {
    return __awaiter(this, void 0, void 0, function* () {
        const editor = new editor_1.default(domId);
        editor.setContent(yield contentAttribute.getValue());
        editor.addReferenceData(yield referencesAttribute.getValue());
        referencesAttribute.subscribe((changeset) => __awaiter(this, void 0, void 0, function* () {
            const newData = {};
            changeset.change.forEach(({ key, value }) => {
                newData[key] = value;
            });
            editor.addReferenceData(newData);
        }));
        editor.subscribeReferenceInsertion((key, value) => __awaiter(this, void 0, void 0, function* () {
            referencesAttribute.change(new key_value_change_1.default([{ key, value }]));
        }));
        contentAttribute.subscribe((changeset, changeInfo) => __awaiter(this, void 0, void 0, function* () {
            const attr = { actor: { id: changeInfo.actorId } };
            try {
                editor.applyChangeset(changeset.changeset, attr);
            }
            catch (ex) {
                console.log('failed to apply changeset to EDITOR content. Falling back to replace the whole editors content', ex);
                editor.setContent(yield contentAttribute.getValue(), attr);
            }
        }));
        editor.subscribe((modificationLog) => __awaiter(this, void 0, void 0, function* () {
            if (!modificationLog.actor) {
                try {
                    yield contentAttribute.change(new long_text_change_1.default(modificationLog.toChangeset(changesets_1.Changeset)));
                }
                catch (ex) {
                    console.log('failed to apply changeset to ATTRIBUTE. Falling back to replace whole attribute content', ex);
                    yield contentAttribute.set(editor.getOriginalContent());
                }
            }
        }));
    });
}
exports["default"] = default_1;


/***/ }),

/***/ "./lib/server-side-events/client/index.ts":
/*!************************************************!*\
  !*** ./lib/server-side-events/client/index.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
class ServerSideEvents {
    constructor() {
        this.subscriptions = {};
        this.connetions = {};
        this.isPaused = false;
        this.messagesWhilePaused = [];
        this.tabId = (Math.random() + 1).toString(36).substring(7);
    }
    getEventSourceAsync(url) {
        if (!url.searchParams.has('tabId')) {
            url.searchParams.append('tabId', this.tabId);
        }
        return new Promise((resolve, reject) => {
            const source = new EventSource(url.toString());
            source.onerror = reject;
            source.onopen = () => resolve(source);
        });
    }
    subscribe(url, channel, handler) {
        return __awaiter(this, void 0, void 0, function* () {
            const parsedUrl = new URL(url);
            const subId = `${parsedUrl.origin}-${channel}`;
            if (!parsedUrl.searchParams.has('tabId')) {
                parsedUrl.searchParams.append('tabId', this.tabId);
            }
            yield this.ensureConnection(parsedUrl.origin);
            yield fetch(parsedUrl.toString());
            this.subscriptions[subId] = this.subscriptions[subId] || [];
            this.subscriptions[subId].push(handler);
        });
    }
    unsubscribeAll() {
        Object.values(this.connetions).forEach((connection) => {
            connection.close();
        });
        this.connetions = {};
    }
    pauseNotification() {
        this.isPaused = true;
    }
    unpauseNotification() {
        this.messagesWhilePaused.forEach(({ cb, data }) => {
            cb(data);
        });
        this.messagesWhilePaused = [];
    }
    ensureConnection(origin) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = new URL(origin);
            url.pathname = '/server-sent-events';
            if (!this.connetions[url.origin]) {
                try {
                    this.connetions[url.origin] = yield this.getEventSourceAsync(url);
                }
                catch (ex) {
                    this.connetions[url.origin] = yield this.getEventSourceAsync(url);
                }
                this.connetions[url.origin].onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    const { sseChannel } = data;
                    if (!sseChannel) {
                        return;
                    }
                    delete data.sseChannel;
                    const subscriptions = this.subscriptions[`${url.origin}-${sseChannel}`];
                    if (subscriptions) {
                        subscriptions.forEach((cb) => {
                            if (this.isPaused) {
                                this.messagesWhilePaused.push({ cb, data });
                            }
                            else {
                                cb(data);
                            }
                        });
                    }
                };
            }
            return this.connetions[origin];
        });
    }
}
exports["default"] = ServerSideEvents;


/***/ }),

/***/ "./src/attributes/abstract/abstract_attribute_client.ts":
/*!**************************************************************!*\
  !*** ./src/attributes/abstract/abstract_attribute_client.ts ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* eslint-disable import/no-cycle */
/* eslint-disable class-methods-use-this */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const uuid_1 = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/index.js");
class AbstractAttributeClient {
    constructor(linkedRecords, serverSideEvents, id) {
        this.id = id;
        this.linkedRecords = linkedRecords;
        this.serverSideEvents = serverSideEvents;
        this.serverURL = linkedRecords.serverURL;
        this.observers = [];
        // because the same user can be logged on two browsers/laptops, we need
        // a clientId and an actorId
        this.clientId = linkedRecords.clientId;
        this.actorId = linkedRecords.actorId;
        this.version = '0';
        this.value = this.getDefaultValue();
        this.isInitialized = false;
    }
    static getDataTypeName() {
        throw new Error('getDataTypeName needs to be implemented in child class');
    }
    static isAttributeId(id) {
        return id.split('-')[0] === this.prototype.getDataTypePrefix();
    }
    create(value) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.id) {
                throw new Error(`Cannot create attribute because it has an id assigned (${this.id})`);
            }
            this.id = `${this.getDataTypePrefix()}-${(0, uuid_1.v4)()}`;
            const response = yield this.withConnectionLostHandler(() => fetch(`${this.linkedRecords.serverURL}attributes/${this.id}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    clientId: this.clientId,
                    actorId: this.actorId,
                    value,
                }),
            }));
            if (!response) {
                throw new Error('Error communicating with the server when creating attribute.');
            }
            if (response.status === 401) {
                this.handleExpiredLoginSession();
                return;
            }
            if (response.status !== 200) {
                throw new Error(`Error creating attribute: ${yield response.text()}`);
            }
            const responseBody = yield response.json();
            yield this.load(responseBody);
        });
    }
    get() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.load();
            return {
                value: this.value,
                changeId: this.version,
                actorId: this.actorId,
            };
        });
    }
    getValue() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.load();
            return this.value;
        });
    }
    set(newValue) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.load();
            if (newValue === this.value) {
                return;
            }
            yield this.rawSet(newValue);
        });
    }
    change(change) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.load();
            yield this.rawChange(change);
        });
    }
    subscribe(observer) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.load();
            this.observers.push(observer);
        });
    }
    handleExpiredLoginSession() {
        const win = window;
        win.location = '/login';
    }
    handleConnectionError(error) {
        console.log('Connection Lost', error);
    }
    withConnectionLostHandler(fn) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield fn();
            }
            catch (ex) {
                if (ex.message === 'Failed to fetch') {
                    this.handleConnectionError(ex);
                }
                return false;
            }
        });
    }
    load(serverState) {
        return __awaiter(this, void 0, void 0, function* () {
            let result = serverState;
            if (this.isInitialized) {
                return;
            }
            if (!this.id) {
                throw new Error('cannot load an attribute without id');
            }
            this.isInitialized = true;
            if (!result) {
                const url = `${this.serverURL}attributes/${this.id}?clientId=${this.clientId}&actorId=${this.actorId}`;
                const response = yield this.withConnectionLostHandler(() => fetch(url));
                if (response.status === 401) {
                    this.handleExpiredLoginSession();
                    return;
                }
                const jsonBody = yield response.json();
                result = {
                    changeId: jsonBody.changeId,
                    value: jsonBody.value,
                };
            }
            this.version = result.changeId;
            this.value = this.deserializeValue(typeof result.value === 'string' ? result.value : JSON.stringify(result.value));
            this.onLoad();
            this.notifySubscribers(undefined, undefined);
            const url = `${this.serverURL}attributes/${this.id}/changes?clientId=${this.clientId}&actorId=${this.actorId}`;
            yield this.serverSideEvents.subscribe(url, this.id, (parsedData) => {
                if (parsedData.attributeId !== this.id) {
                    return;
                }
                this.onServerMessage(parsedData);
            });
        });
    }
    sendToServer(change) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `${this.serverURL}attributes/${this.id}?clientId=${this.clientId}&actorId=${this.actorId}`;
            const response = yield this.withConnectionLostHandler(() => fetch(url, {
                method: 'PATCH',
                headers: {
                    Accept: 'application/json',
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(change.toJSON()),
            }));
            if (response.status === 401) {
                this.handleExpiredLoginSession();
            }
        });
    }
    notifySubscribers(change, fullChangeInfo) {
        this.observers.forEach((callback) => {
            callback(change, fullChangeInfo);
        });
    }
}
exports["default"] = AbstractAttributeClient;


/***/ }),

/***/ "./src/attributes/abstract/serialized_change_with_metadata.ts":
/*!********************************************************************!*\
  !*** ./src/attributes/abstract/serialized_change_with_metadata.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class SerializedChangeWithMetadata {
    constructor(attributeId, actorId, clientId, change) {
        this.attributeId = attributeId;
        this.actorId = actorId;
        this.clientId = clientId;
        this.change = change;
    }
    toJSON() {
        return {
            attributeId: this.attributeId,
            change: this.change.toJSON(),
            actorId: this.actorId,
            clientId: this.clientId,
        };
    }
}
exports["default"] = SerializedChangeWithMetadata;


/***/ }),

/***/ "./src/attributes/key_value/client/index.ts":
/*!**************************************************!*\
  !*** ./src/attributes/key_value/client/index.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* eslint-disable @typescript-eslint/no-empty-function */
/* eslint-disable import/no-cycle */
/* eslint-disable class-methods-use-this */
const abstract_attribute_client_1 = __importDefault(__webpack_require__(/*! ../../abstract/abstract_attribute_client */ "./src/attributes/abstract/abstract_attribute_client.ts"));
const serialized_change_with_metadata_1 = __importDefault(__webpack_require__(/*! ../../abstract/serialized_change_with_metadata */ "./src/attributes/abstract/serialized_change_with_metadata.ts"));
const key_value_change_1 = __importDefault(__webpack_require__(/*! ../key_value_change */ "./src/attributes/key_value/key_value_change.ts"));
class KeyValueAttribute extends abstract_attribute_client_1.default {
    static getDataTypePrefix() {
        return 'kv';
    }
    static getDataTypeName() {
        return 'keyValue';
    }
    getDataTypePrefix() {
        return KeyValueAttribute.getDataTypePrefix();
    }
    getDataTypeName() {
        return KeyValueAttribute.getDataTypeName();
    }
    getDefaultValue() {
        return {};
    }
    deserializeValue(serializedValue) {
        return JSON.parse(serializedValue);
    }
    rawSet(newValue) {
        return __awaiter(this, void 0, void 0, function* () {
            let changes = [];
            Object.entries(this.value).forEach(([key]) => {
                changes.push({ key, value: null });
            });
            Object.entries(newValue).forEach(([key, value]) => {
                changes = changes.filter((ch) => ch.key !== key);
                changes.push({ key, value });
            });
            this.change(new key_value_change_1.default(changes));
        });
    }
    rawChange(change) {
        return __awaiter(this, void 0, void 0, function* () {
            this.transmitChange(new key_value_change_1.default(change.change, this.version));
            this.value = change.apply(this.value);
        });
    }
    onLoad() {
    }
    onServerMessage(changeWithMetadata) {
        const change = new key_value_change_1.default(changeWithMetadata.change, changeWithMetadata.change.changeId);
        if (changeWithMetadata.clientId === this.clientId) {
            return;
        }
        this.value = change.apply(this.value);
        this.version = change.changeId;
        this.notifySubscribers(change, changeWithMetadata);
    }
    transmitChange(changeset) {
        if (!this.id) {
            throw new Error('change can not be transmitted because attribute does not has an id');
        }
        this.sendToServer(new serialized_change_with_metadata_1.default(this.id, this.actorId, this.clientId, changeset));
    }
}
exports["default"] = KeyValueAttribute;


/***/ }),

/***/ "./src/attributes/key_value/key_value_change.ts":
/*!******************************************************!*\
  !*** ./src/attributes/key_value/key_value_change.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class KeyValueChange {
    constructor(changeset, changeId) {
        this.changeId = changeId !== null && changeId !== void 0 ? changeId : 'uncommited';
        this.change = changeset;
    }
    static fromJSON(input, changeId) {
        return new KeyValueChange(input, changeId);
    }
    static fromString(input) {
        return new KeyValueChange(JSON.parse(input));
    }
    toString() {
        return JSON.stringify(this.change);
    }
    toJSON() {
        return this.change;
    }
    apply(input) {
        const result = JSON.parse(JSON.stringify(input));
        this.change.forEach((aChange) => {
            if (aChange.value === null) {
                delete result[aChange.key];
            }
            else {
                result[aChange.key] = aChange.value;
            }
        });
        return result;
    }
    merge(other) {
        let mergedChanges = [];
        this.change.forEach((ch) => {
            mergedChanges = mergedChanges.filter((x) => x.key !== ch.key);
            mergedChanges.push(ch);
        });
        other.change.forEach((ch) => {
            mergedChanges = mergedChanges.filter((x) => x.key !== ch.key);
            mergedChanges.push(ch);
        });
        return new KeyValueChange(mergedChanges);
    }
}
exports["default"] = KeyValueChange;


/***/ }),

/***/ "./src/attributes/long_text/client/buffer.ts":
/*!***************************************************!*\
  !*** ./src/attributes/long_text/client/buffer.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class ChangeBuffer {
    add(changeset) {
        this.value = this.value ? this.value.merge(changeset) : changeset;
    }
    // this function returns a transformed version of the foreignChange which
    // fits into the current client state. This is required because the client
    // could have some changes which has not been send to the server yet. So, the
    // server don't know about these changes and the changes comming from the server
    // would not fit into the client state.
    transformAgainst(foreignChange, changeInTransmission) {
        var _a, _b;
        if (!changeInTransmission) {
            return foreignChange;
        }
        this.inFlightOp = this.inFlightOp || changeInTransmission;
        const c2 = foreignChange.transformAgainst(this.inFlightOp, true);
        this.inFlightOp = (_a = this.inFlightOp) === null || _a === void 0 ? void 0 : _a.transformAgainst(foreignChange, false);
        if (!this.value)
            return c2;
        // instead of using a bridge we use c2 to transform the
        // foreignChange (change from server) into the client state.
        const c1 = c2.transformAgainst(this.value, true);
        // "Once we have this inferred operation, c2, we can use it
        // to transform the buffer (b) "down" one step"
        this.value = (_b = this.value) === null || _b === void 0 ? void 0 : _b.transformAgainst(c2, false);
        return c1;
    }
    clear() {
        this.value = undefined;
        this.inFlightOp = undefined;
    }
    getValue() {
        return this.value;
    }
}
exports["default"] = ChangeBuffer;


/***/ }),

/***/ "./src/attributes/long_text/client/index.ts":
/*!**************************************************!*\
  !*** ./src/attributes/long_text/client/index.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* eslint-disable import/no-cycle */
/* eslint-disable class-methods-use-this */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const abstract_attribute_client_1 = __importDefault(__webpack_require__(/*! ../../abstract/abstract_attribute_client */ "./src/attributes/abstract/abstract_attribute_client.ts"));
const serialized_change_with_metadata_1 = __importDefault(__webpack_require__(/*! ../../abstract/serialized_change_with_metadata */ "./src/attributes/abstract/serialized_change_with_metadata.ts"));
const long_text_change_1 = __importDefault(__webpack_require__(/*! ../long_text_change */ "./src/attributes/long_text/long_text_change.ts"));
const buffer_1 = __importDefault(__webpack_require__(/*! ./buffer */ "./src/attributes/long_text/client/buffer.ts"));
class LongTextAttribute extends abstract_attribute_client_1.default {
    constructor() {
        super(...arguments);
        this.buffer = new buffer_1.default();
        this.changeInTransmission = undefined;
    }
    static getDataTypePrefix() {
        return 'l';
    }
    static getDataTypeName() {
        return 'longText';
    }
    getDataTypePrefix() {
        return 'l';
    }
    getDataTypeName() {
        return LongTextAttribute.getDataTypeName();
    }
    getDefaultValue() {
        return '';
    }
    deserializeValue(serializedValue) {
        return serializedValue;
    }
    rawSet(newValue) {
        return __awaiter(this, void 0, void 0, function* () {
            const changeset = long_text_change_1.default.fromDiff(this.value, newValue);
            yield this.change(changeset);
        });
    }
    rawChange(changeset) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: Check for version is valid
            // if (this.version === '0') {
            //   throw Error('Cannot change attribute as attributed state is not loaded from server!');
            // }
            this.value = changeset.apply(this.value);
            if (this.changeInTransmission) {
                this.buffer.add(changeset);
            }
            else {
                this.transmitChange(new long_text_change_1.default(changeset.changeset, this.version));
            }
        });
    }
    onLoad() {
        this.buffer.clear();
    }
    onServerMessage(changeWithMetadata) {
        if (changeWithMetadata.clientId === this.clientId) {
            this.processApproval(changeWithMetadata);
        }
        else {
            this.processForeignChange(changeWithMetadata);
        }
    }
    processForeignChange(foreignChangeWithMetadata) {
        var _a;
        try {
            const foreignChangeset = long_text_change_1.default.fromString(foreignChangeWithMetadata.change.changeset);
            const transformedForeignChange = this.buffer.transformAgainst(foreignChangeset, (_a = this.changeInTransmission) === null || _a === void 0 ? void 0 : _a.change);
            this.value = transformedForeignChange.apply(this.value);
            this.version = foreignChangeWithMetadata.change.changeId;
            this.notifySubscribers(transformedForeignChange, foreignChangeWithMetadata);
        }
        catch (ex) {
            console.log('ERROR: processing foreign change failed (probably because of a previous message loss). Reload server state to recover.', ex);
            this.load();
        }
    }
    processApproval(approval) {
        const bufferedChanges = this.buffer.getValue();
        this.changeInTransmission = undefined;
        this.version = approval.change.changeId;
        this.buffer.clear();
        if (bufferedChanges) {
            this.transmitChange(new long_text_change_1.default(bufferedChanges.changeset, approval.change.changeId));
        }
    }
    transmitChange(changeset) {
        if (!this.id) {
            throw new Error('change can not be transmitted because attribute does not has an id');
        }
        this.changeInTransmission = new serialized_change_with_metadata_1.default(this.id, this.actorId, this.clientId, changeset);
        this.sendToServer(this.changeInTransmission);
    }
}
exports["default"] = LongTextAttribute;


/***/ }),

/***/ "./src/attributes/long_text/long_text_change.ts":
/*!******************************************************!*\
  !*** ./src/attributes/long_text/long_text_change.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const changesets_1 = __webpack_require__(/*! changesets */ "./node_modules/changesets/lib/index.js");
const diff_match_patch_1 = __webpack_require__(/*! diff_match_patch */ "./node_modules/diff_match_patch/lib/diff_match_patch.js");
const diffEngine = new diff_match_patch_1.diff_match_patch();
class LongTextChange {
    constructor(changeset, changeId) {
        this.changeset = changeset;
        this.changeId = changeId !== null && changeId !== void 0 ? changeId : 'uncommited';
    }
    static fromString(change) {
        return new LongTextChange(changesets_1.Changeset.unpack(change));
    }
    static fromDiff(a, b) {
        return new LongTextChange(changesets_1.Changeset.fromDiff(diffEngine.diff_main(a, b)));
    }
    apply(value) {
        return this.changeset.apply(value);
    }
    toString() {
        return typeof this.changeset === 'string'
            ? this.changeset
            : this.changeset.pack();
    }
    transformAgainst(change, side) {
        if (!change) {
            return this;
        }
        return new LongTextChange(this.changeset.transformAgainst(change.changeset, side));
    }
    merge(otherChange) {
        return new LongTextChange(this.changeset.merge(otherChange.changeset));
    }
    toJSON() {
        return {
            changeset: this.toString(),
            changeId: this.changeId,
        };
    }
}
exports["default"] = LongTextChange;


/***/ }),

/***/ "./src/browser_sdk/index.ts":
/*!**********************************!*\
  !*** ./src/browser_sdk/index.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* eslint-disable max-classes-per-file */
/* eslint-disable import/no-cycle */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const uuid_1 = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/index.js");
const client_1 = __importDefault(__webpack_require__(/*! ../attributes/long_text/client */ "./src/attributes/long_text/client/index.ts"));
const client_2 = __importDefault(__webpack_require__(/*! ../attributes/key_value/client */ "./src/attributes/key_value/client/index.ts"));
const client_3 = __importDefault(__webpack_require__(/*! ../../lib/server-side-events/client */ "./lib/server-side-events/client/index.ts"));
const client_4 = __importDefault(__webpack_require__(/*! ../facts/client */ "./src/facts/client/index.ts"));
class AttributesRepository {
    constructor(linkedRecords, serverSideEvents) {
        this.linkedRecords = linkedRecords;
        this.serverSideEvents = serverSideEvents;
    }
    create(attributeType, value) {
        return __awaiter(this, void 0, void 0, function* () {
            const AttributeClass = AttributesRepository
                .attributeTypes
                .find((c) => c.getDataTypeName() === attributeType);
            if (!AttributeClass) {
                throw new Error(`Attribute Type ${attributeType} is unknown`);
            }
            const attribute = new AttributeClass(this.linkedRecords, this.serverSideEvents);
            yield attribute.create(value);
            return attribute;
        });
    }
    find(attributeId) {
        return __awaiter(this, void 0, void 0, function* () {
            const [attributeTypePrefix] = attributeId.split('-');
            const AttributeClass = AttributesRepository
                .attributeTypes
                .find((c) => c.getDataTypePrefix() === attributeTypePrefix);
            if (!AttributeClass) {
                throw new Error(`Attribute ID ${attributeId} is unknown`);
            }
            const attribute = new AttributeClass(this.linkedRecords, this.serverSideEvents, attributeId);
            yield attribute.get();
            return attribute;
        });
    }
    findAll(query) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = {};
            const qEntries = Object.entries(query);
            const promises = [];
            for (let j = 0; j < qEntries.length; j += 1) {
                const qEntry = qEntries[j];
                if (qEntry) {
                    const n = qEntry[0];
                    const q = qEntry[1];
                    if (typeof q === 'string') {
                        promises.push(this.find(q).then((attribute) => {
                            result[n] = attribute;
                        }).catch(() => {
                            result[n] = null;
                        }));
                    }
                    else {
                        result[n] = [];
                        promises.push(this.linkedRecords.Fact.findAll({ subject: q }).then((facts) => {
                            var _a;
                            for (let i = 0; i < facts.length; i += 1) {
                                const subjectId = (_a = facts[i]) === null || _a === void 0 ? void 0 : _a.subject;
                                if (subjectId && !result[n].find((attr) => attr.id === subjectId)) {
                                    const AttributeClass = AttributesRepository.attributeTypes
                                        .find((at) => at.isAttributeId(subjectId));
                                    if (AttributeClass) {
                                        const attribute = new AttributeClass(this.linkedRecords, this.serverSideEvents, subjectId);
                                        result[n].push(attribute);
                                    }
                                }
                            }
                        }));
                    }
                }
            }
            yield Promise.all(promises);
            return result;
        });
    }
}
AttributesRepository.attributeTypes = [
    client_1.default,
    client_2.default,
];
class FactsRepository {
    constructor(linkedRecords) {
        this.linkedRecords = linkedRecords;
    }
    createAll(facts) {
        return __awaiter(this, void 0, void 0, function* () {
            const createdFacts = yield Promise.all(facts.map((attr) => this.create(attr[0], attr[1], attr[2])));
            return createdFacts;
        });
    }
    create(subjectId, predicateId, objectId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!subjectId) {
                throw Error('subjectId can not be null');
            }
            if (!objectId) {
                throw Error('objectId can not be null');
            }
            if (!predicateId) {
                throw Error('predicateId can not be null');
            }
            const fact = new client_4.default(this.linkedRecords, subjectId, predicateId, objectId);
            yield fact.save();
            return fact;
        });
    }
    deleteAll() {
        return __awaiter(this, void 0, void 0, function* () {
            yield fetch(`${this.linkedRecords.serverURL}facts`, {
                method: 'DELETE',
                headers: {
                    Accept: 'application/json',
                    'Content-Type': 'application/json',
                },
            });
        });
    }
    findAll({ subject, predicate, object }) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryURL = new URL(`${this.linkedRecords.serverURL}facts`);
            if (subject) {
                queryURL.searchParams.append('subject', JSON.stringify(subject));
            }
            if (predicate) {
                queryURL.searchParams.append('predicate', JSON.stringify(predicate));
            }
            if (object) {
                queryURL.searchParams.append('object', JSON.stringify(object));
            }
            const response = yield fetch(queryURL, {
                headers: {
                    Accept: 'application/json',
                    'Content-Type': 'application/json',
                },
            });
            const responseJson = yield response.json();
            return responseJson.map((record) => new client_4.default(this.linkedRecords, record.subject, record.predicate, record.object));
        });
    }
}
class LinkedRecords {
    constructor(serverURL, serverSideEvents) {
        this.serverURL = serverURL;
        this.actorId = (0, uuid_1.v4)();
        this.clientId = (0, uuid_1.v4)();
        this.serverSideEvents = serverSideEvents || new client_3.default();
        this.Attribute = new AttributesRepository(this, this.serverSideEvents);
        this.Fact = new FactsRepository(this);
    }
}
exports["default"] = LinkedRecords;


/***/ }),

/***/ "./src/facts/client/index.ts":
/*!***********************************!*\
  !*** ./src/facts/client/index.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
class Fact {
    constructor(linkedRecords, subject, predicate, object) {
        this.serverURL = linkedRecords.serverURL;
        this.subject = subject;
        this.predicate = predicate;
        this.object = object;
    }
    save() {
        return __awaiter(this, void 0, void 0, function* () {
            yield fetch(`${this.serverURL}facts`, {
                method: 'POST',
                headers: {
                    Accept: 'application/json',
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    subject: this.subject,
                    predicate: this.predicate,
                    object: this.object,
                }),
            });
        });
    }
}
exports["default"] = Fact;


/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NIL": () => (/* reexport safe */ _nil_js__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   "parse": () => (/* reexport safe */ _parse_js__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   "stringify": () => (/* reexport safe */ _stringify_js__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   "v1": () => (/* reexport safe */ _v1_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "v3": () => (/* reexport safe */ _v3_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   "v4": () => (/* reexport safe */ _v4_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   "v5": () => (/* reexport safe */ _v5_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   "validate": () => (/* reexport safe */ _validate_js__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   "version": () => (/* reexport safe */ _version_js__WEBPACK_IMPORTED_MODULE_5__["default"])
/* harmony export */ });
/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v1.js */ "./node_modules/uuid/dist/esm-browser/v1.js");
/* harmony import */ var _v3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./v3.js */ "./node_modules/uuid/dist/esm-browser/v3.js");
/* harmony import */ var _v4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./v4.js */ "./node_modules/uuid/dist/esm-browser/v4.js");
/* harmony import */ var _v5_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./v5.js */ "./node_modules/uuid/dist/esm-browser/v5.js");
/* harmony import */ var _nil_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./nil.js */ "./node_modules/uuid/dist/esm-browser/nil.js");
/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./version.js */ "./node_modules/uuid/dist/esm-browser/version.js");
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/esm-browser/validate.js");
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/esm-browser/stringify.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./parse.js */ "./node_modules/uuid/dist/esm-browser/parse.js");










/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/md5.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/md5.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 * Browser-compatible JavaScript MD5
 *
 * Modification of JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */
function md5(bytes) {
  if (typeof bytes === 'string') {
    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = new Uint8Array(msg.length);

    for (var i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }

  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
/*
 * Convert an array of little-endian words to an array of bytes
 */


function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = '0123456789abcdef';

  for (var i = 0; i < length32; i += 8) {
    var x = input[i >> 5] >>> i % 32 & 0xff;
    var hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
    output.push(hex);
  }

  return output;
}
/**
 * Calculate output length with padding and bit length
 */


function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */


function wordsToMd5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << len % 32;
  x[getOutputLength(len) - 1] = len;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;

  for (var i = 0; i < x.length; i += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }

  return [a, b, c, d];
}
/*
 * Convert an array bytes to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */


function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }

  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));

  for (var i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
  }

  return output;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */


function safeAdd(x, y) {
  var lsw = (x & 0xffff) + (y & 0xffff);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xffff;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */


function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
/*
 * These functions implement the four basic operations the algorithm uses.
 */


function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}

function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}

function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}

function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}

function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (md5);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/nil.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/nil.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ('00000000-0000-0000-0000-000000000000');

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/parse.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/parse.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/esm-browser/validate.js");


function parse(uuid) {
  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Invalid UUID');
  }

  var v;
  var arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parse);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/regex.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/regex.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/rng.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/rng.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ rng)
/* harmony export */ });
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/sha1.js":
/*!****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/sha1.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;

    case 1:
      return x ^ y ^ z;

    case 2:
      return x & y ^ x & z ^ y & z;

    case 3:
      return x ^ y ^ z;
  }
}

function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}

function sha1(bytes) {
  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

  if (typeof bytes === 'string') {
    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = [];

    for (var i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    // Convert Array-like to Array
    bytes = Array.prototype.slice.call(bytes);
  }

  bytes.push(0x80);
  var l = bytes.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);

  for (var _i = 0; _i < N; ++_i) {
    var arr = new Uint32Array(16);

    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
    }

    M[_i] = arr;
  }

  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

  for (var _i2 = 0; _i2 < N; ++_i2) {
    var W = new Uint32Array(80);

    for (var t = 0; t < 16; ++t) {
      W[t] = M[_i2][t];
    }

    for (var _t = 16; _t < 80; ++_t) {
      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }

    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];

    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }

    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }

  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sha1);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/stringify.js":
/*!*********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/stringify.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/esm-browser/validate.js");

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

var byteToHex = [];

for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v1.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v1.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ "./node_modules/uuid/dist/esm-browser/rng.js");
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/esm-browser/stringify.js");

 // **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;

var _clockseq; // Previous uuid creation time


var _lastMSecs = 0;
var _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || new Array(16);
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__["default"])();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  var msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__["default"])(b);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v1);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v3.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v3.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ "./node_modules/uuid/dist/esm-browser/v35.js");
/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./md5.js */ "./node_modules/uuid/dist/esm-browser/md5.js");


var v3 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__["default"])('v3', 0x30, _md5_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v3);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v35.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v35.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DNS": () => (/* binding */ DNS),
/* harmony export */   "URL": () => (/* binding */ URL),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/esm-browser/stringify.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ "./node_modules/uuid/dist/esm-browser/parse.js");



function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  var bytes = [];

  for (var i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

var DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
var URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__["default"])(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__["default"])(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v4.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v4.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ "./node_modules/uuid/dist/esm-browser/rng.js");
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/esm-browser/stringify.js");



function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__["default"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__["default"])(rnds);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v5.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v5.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ "./node_modules/uuid/dist/esm-browser/v35.js");
/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sha1.js */ "./node_modules/uuid/dist/esm-browser/sha1.js");


var v5 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__["default"])('v5', 0x50, _sha1_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v5);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/validate.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/validate.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ "./node_modules/uuid/dist/esm-browser/regex.js");


function validate(uuid) {
  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__["default"].test(uuid);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/version.js":
/*!*******************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/version.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/esm-browser/validate.js");


function version(uuid) {
  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.substr(14, 1), 16);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (version);

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./example/client/index.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBLDREQUE0RCxXQUFXO0FBQ3ZFOztBQUVBO0FBQ0EsMEVBQTBFLFVBQVU7QUFDcEYsVUFBVTtBQUNWLHNEQUFzRCxVQUFVO0FBQ2hFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0Esa0RBQWtEO0FBQ2xELEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw2RUFBNkUsV0FBVzs7QUFFeEY7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvQ0FBb0M7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7QUNqMkJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0EsWUFBWSwrQkFBK0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0EsWUFBWSwrQkFBK0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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WTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3Q1REQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFH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VDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUEsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtEQUFrRDs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLEdBQUc7QUFDSCxtQ0FBbUM7QUFDbkM7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7O0FBR0EsMEdBQTBHOztBQUUxRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLElBQXFDO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBLEtBQUs7O0FBRUw7QUFDQSw4QkFBOEI7QUFDOUIsb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsOENBQThDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7O0FBRTlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBOztBQUVBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw2Q0FBNkMsZUFBZTtBQUMzRixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2Q0FBNkMsZUFBZTtBQUM3RSxpQkFBaUIsZ0NBQWdDO0FBQ2pEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw2Q0FBNkMsZUFBZTtBQUMzRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSx1RUFBdUUsY0FBYztBQUNyRjtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtB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S0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLG9CQUFvQjtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsY0FBYyxvQkFBb0I7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxpR0FBaUcsNEJBQTRCOztBQUU3SDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFL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O0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQ0FBK0Msd0VBQXdFO0FBQ3ZIO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7Ozs7OztBQ3BPQSxXQUFXLG1CQUFPLENBQUMsa0VBQVM7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztB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QUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EseUNBQXlDOztBQUV6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFlBQVk7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBLHlDQUF5Qzs7QUFFekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FB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O0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQSxZQUFZLCtCQUErQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQSxZQUFZLCtCQUErQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Ozs7Ozs7Ozs7Ozs7QUMvRDJCO0FBQ1k7O0FBRXZDO0FBQ0E7QUFDQSwrQ0FBK0MsK0NBQUcsS0FBSzs7QUFFdkQ7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7O0FBRUEsb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFNBQVMseURBQVM7QUFDbEI7O0FBRUEsaUVBQWUsRUFBRTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2QlU7QUFDRTtBQUM3QixTQUFTLG1EQUFHLGFBQWEsZ0RBQUk7QUFDN0IsaUVBQWUsRUFBRTs7Ozs7Ozs7Ozs7Ozs7OztBQ0hjOztBQUUvQjtBQUNBLHFDQUFxQyxzREFBVTtBQUMvQzs7QUFFQSxpRUFBZSxRQUFROzs7Ozs7Ozs7Ozs7Ozs7O0FDTmM7O0FBRXJDO0FBQ0EsT0FBTyx3REFBUTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpRUFBZSxPQUFPOzs7Ozs7VUNWdEI7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7Ozs7V0N0QkE7V0FDQTtXQUNBO1dBQ0E7V0FDQSx5Q0FBeUMsd0NBQXdDO1dBQ2pGO1dBQ0E7V0FDQTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEdBQUc7V0FDSDtXQUNBO1dBQ0EsQ0FBQzs7Ozs7V0NQRDs7Ozs7V0NBQTtXQUNBO1dBQ0E7V0FDQSx1REFBdUQsaUJBQWlCO1dBQ3hFO1dBQ0EsZ0RBQWdELGFBQWE7V0FDN0Q7Ozs7O1VFTkE7VUFDQTtVQUNBO1VBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3IvYXNzZXRzL2xhdGV4X2NoZWF0c2hlZXQuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL2xpYi9kZWNsYXJhdGl2X2Zvcm1zL3NyYy9kZWNsYXJhdGl2X2Zvcm0uanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL2xpYi9kZWNsYXJhdGl2X2Zvcm1zL3NyYy9kbF9zZWxlY3QuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL2xpYi9kb2N1bWVudHVwZGF0ZXIvZG9jdW1lbnR1cGRhdGVyLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9saWIvZG9jdW1lbnR1cGRhdGVyL21vZGlmaWNhdGlvbl9sb2cuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL2xpYi9nZW5lcmF0b3Jsb29rYWhlYWQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL2xpYi9odG1sX3Jhem9yL2h0bWxfcmF6b3IuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL2xpYi9odG1sX3Jhem9yL3N0YXRlX21hY2hpbmUuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL2xpYi9odG1sX3Jhem9yL3RhZ190cmFuc2Zvcm1hdGlvbi5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3IvbGliL2xvb2t1cF9yZWZzL2Vycm9ycy5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3IvbGliL2xvb2t1cF9yZWZzL2luZGV4LmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9saWIvbG9va3VwX3JlZnMvbG9va3VwX2J5X2FyeGl2LmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9saWIvbG9va3VwX3JlZnMvbG9va3VwX2J5X2RvaS5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3IvbGliL2xvb2t1cF9yZWZzL2xvb2t1cF9ieV9pc2JuLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9saWIvbG9va3VwX3JlZnMvbG9va3VwX2J5X3VybC5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3IvbGliL3BpeGVsc2NodWJzZXIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL2xpYi90aHJvdHRsZS90aHJvdHRsZS5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3IvbGliL3RvY19idWlsZGVyL3RvY19idWlsZGVyLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9saWIvem90ZXJvLWNsaWVudC9pbmRleC5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3IvbGliL3pvdGVyby1jbGllbnQvb25saW5lLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9jb250YWlucy5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Qm9yZGVycy5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDbGlwcGluZ1JlY3QuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENvbXBvc2l0ZVJlY3QuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERlY29yYXRpb25zLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50UmVjdC5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0SFRNTEVsZW1lbnRTY3JvbGwuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldExheW91dFJlY3QuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE5vZGVOYW1lLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXROb2RlU2Nyb2xsLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFBhcmVudE5vZGUuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFNjcm9sbFBhcmVudC5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Vmlld3BvcnRSZWN0LmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3cuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvd1Njcm9sbC5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93U2Nyb2xsQmFyWC5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaXNTY3JvbGxQYXJlbnQuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzVGFibGVFbGVtZW50LmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9saXN0U2Nyb2xsUGFyZW50cy5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9lbnVtcy5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvYXBwbHlTdHlsZXMuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2Fycm93LmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9jb21wdXRlU3R5bGVzLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9ldmVudExpc3RlbmVycy5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvZmxpcC5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvaGlkZS5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvb2Zmc2V0LmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9wb3BwZXJPZmZzZXRzLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9wcmV2ZW50T3ZlcmZsb3cuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvcG9wcGVyLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2NvbXB1dGVBdXRvUGxhY2VtZW50LmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2NvbXB1dGVPZmZzZXRzLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2RlYm91bmNlLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2V4cGFuZFRvSGFzaE1hcC5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9mb3JtYXQuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0QWx0QXhpcy5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEZyZXNoU2lkZU9iamVjdC5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0T3Bwb3NpdGVQbGFjZW1lbnQuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0VmFyaWF0aW9uLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21lcmdlQnlOYW1lLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21lcmdlUGFkZGluZ09iamVjdC5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9vcmRlck1vZGlmaWVycy5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9yZWN0VG9DbGllbnRSZWN0LmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3VuaXF1ZUJ5LmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3ZhbGlkYXRlTW9kaWZpZXJzLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3dpdGhpbi5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL2NoYW5nZXNldHMvbGliL0J1aWxkZXIuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9jaGFuZ2VzZXRzL2xpYi9DaGFuZ2VzZXQuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9jaGFuZ2VzZXRzL2xpYi9DaGFuZ2VzZXRUcmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9jaGFuZ2VzZXRzL2xpYi9PcGVyYXRvci5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL2NoYW5nZXNldHMvbGliL1RleHRUcmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9jaGFuZ2VzZXRzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL2NoYW5nZXNldHMvbGliL29wZXJhdGlvbnMvSW5zZXJ0LmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvY2hhbmdlc2V0cy9saWIvb3BlcmF0aW9ucy9SZXRhaW4uanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9jaGFuZ2VzZXRzL2xpYi9vcGVyYXRpb25zL1NraXAuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy9kaWZmX21hdGNoX3BhdGNoL2xpYi9kaWZmX21hdGNoX3BhdGNoLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvcHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWxhdGV4LmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvcHJpc21qcy9wcmlzbS5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL3RpcHB5LmpzL2Rpc3QvdGlwcHkuZXNtLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9ub2RlX21vZHVsZXMvdXVpZC9saWIvYnl0ZXNUb1V1aWQuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL25vZGVfbW9kdWxlcy91dWlkL2xpYi9ybmctYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivbm9kZV9tb2R1bGVzL3V1aWQvdjEuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL3NyYy9jYXJldC5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivc3JjL2VkaXRvci5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivc3JjL2tleV9wcmVzc19oYW5kbGVyLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9zcmMvcmVmZXJlbmNlcy9yZWZlcmVuY2VfY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivc3JjL3JlZmVyZW5jZXMvcmVmZXJlbmNlX3NvdXJjZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL3NyYy9yZWZlcmVuY2VzL3JlZmVyZW5jZV9zb3VyY2VzL3pvdGVyb19kZXNrdG9wLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9zcmMvcmVmZXJlbmNlcy9yZWZlcmVuY2Vfc291cmNlcy96b3Rlcm9fb25saW5lLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9zcmMvcmVmZXJlbmNlcy9yZWZlcmVuY2Vfc3RvcmUuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL3NyYy9zZWN0aW9uX3R5cGVfc2VsZWN0b3JfY29udHJvbC5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivc3JjL3NlY3Rpb25fdHlwZXMvYmlibGlvZ3JhcGhpZS9iaWJsaW9ncmFwaGllX3NlY3Rpb25fdHlwZS5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivc3JjL3NlY3Rpb25fdHlwZXMvYmxvY2txdW90ZS9ibG9ja3F1b3RlX3NlY3Rpb25fdHlwZS5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivc3JjL3NlY3Rpb25fdHlwZXMvY29kZS9jb2RlX3NlY3Rpb25fdHlwZS5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivc3JjL3NlY3Rpb25fdHlwZXMvZm9vdG5vdGVzL2Zvb3Rub3Rlc19zZWN0aW9uX3R5cGUuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL3NyYy9zZWN0aW9uX3R5cGVzL2Zvcm11bGEvZm9ybXVsYV9zZWN0aW9uX3R5cGUuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL3NyYy9zZWN0aW9uX3R5cGVzL2hlYWRpbmcvaGVhZGluZzEuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL3NyYy9zZWN0aW9uX3R5cGVzL2hlYWRpbmcvaGVhZGluZzIuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL3NyYy9zZWN0aW9uX3R5cGVzL2hlYWRpbmcvaGVhZGluZzMuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL3NyYy9zZWN0aW9uX3R5cGVzL2hlYWRpbmcvaGVhZGluZzQuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL3NyYy9zZWN0aW9uX3R5cGVzL2hlYWRpbmcvaGVhZGluZzUuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL3NyYy9zZWN0aW9uX3R5cGVzL2ltYWdlL2ltYWdlX3NlY3Rpb25fdHlwZS5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivc3JjL3NlY3Rpb25fdHlwZXMvbGlzdC9vcmRlcmVkX2xpc3Rfc2VjdGlvbl90eXBlLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi4vc3RydWN0dXJlZC10ZXh0LWVkaXRvci9zcmMvc2VjdGlvbl90eXBlcy9saXN0L3Vub3JkZXJlZF9saXN0X3NlY3Rpb25fdHlwZS5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivc3JjL3NlY3Rpb25fdHlwZXMvbWVybWFpZC9tZXJtYWlkX3NlY3Rpb25fdHlwZS5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivc3JjL3NlY3Rpb25fdHlwZXMvcGFyYWdyYXBoL3BhcmFncmFwaF9zZWN0aW9uX3R5cGUuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL3NyYy9zZWN0aW9uX3R5cGVzL3NoYXJlZC9jb2RlMmRpYV9zZWN0aW9uX3R5cGUuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL3NyYy9zZWN0aW9uX3R5cGVzL3NoYXJlZC9zaGFyZWQuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL3NyYy9zZWN0aW9uX3R5cGVzL3RhYmxlL3RhYmxlX3NlY3Rpb25fdHlwZS5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4uL3N0cnVjdHVyZWQtdGV4dC1lZGl0b3Ivc3JjL3NlY3Rpb25fdHlwZXMvdG9jL3RvY19zZWN0aW9uX3R5cGUuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uLi9zdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL3NyYy90ZXh0X2VucmljaG1lbnRfY29udHJvbC5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4vbm9kZV9tb2R1bGVzL2NoYW5nZXNldHMvbGliL0J1aWxkZXIuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uL25vZGVfbW9kdWxlcy9jaGFuZ2VzZXRzL2xpYi9DaGFuZ2VzZXQuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uL25vZGVfbW9kdWxlcy9jaGFuZ2VzZXRzL2xpYi9DaGFuZ2VzZXRUcmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uL25vZGVfbW9kdWxlcy9jaGFuZ2VzZXRzL2xpYi9PcGVyYXRvci5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4vbm9kZV9tb2R1bGVzL2NoYW5nZXNldHMvbGliL1RleHRUcmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uL25vZGVfbW9kdWxlcy9jaGFuZ2VzZXRzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4vbm9kZV9tb2R1bGVzL2NoYW5nZXNldHMvbGliL29wZXJhdGlvbnMvSW5zZXJ0LmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi9ub2RlX21vZHVsZXMvY2hhbmdlc2V0cy9saWIvb3BlcmF0aW9ucy9SZXRhaW4uanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uL25vZGVfbW9kdWxlcy9jaGFuZ2VzZXRzL2xpYi9vcGVyYXRpb25zL1NraXAuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uL25vZGVfbW9kdWxlcy9kaWZmX21hdGNoX3BhdGNoL2xpYi9kaWZmX21hdGNoX3BhdGNoLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi9leGFtcGxlL2NsaWVudC9pbmRleC50cyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4vZXhhbXBsZS9jbGllbnQvbHJFZGl0b3IudHMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uL2xpYi9zZXJ2ZXItc2lkZS1ldmVudHMvY2xpZW50L2luZGV4LnRzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi9zcmMvYXR0cmlidXRlcy9hYnN0cmFjdC9hYnN0cmFjdF9hdHRyaWJ1dGVfY2xpZW50LnRzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi9zcmMvYXR0cmlidXRlcy9hYnN0cmFjdC9zZXJpYWxpemVkX2NoYW5nZV93aXRoX21ldGFkYXRhLnRzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi9zcmMvYXR0cmlidXRlcy9rZXlfdmFsdWUvY2xpZW50L2luZGV4LnRzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi9zcmMvYXR0cmlidXRlcy9rZXlfdmFsdWUva2V5X3ZhbHVlX2NoYW5nZS50cyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4vc3JjL2F0dHJpYnV0ZXMvbG9uZ190ZXh0L2NsaWVudC9idWZmZXIudHMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uL3NyYy9hdHRyaWJ1dGVzL2xvbmdfdGV4dC9jbGllbnQvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uL3NyYy9hdHRyaWJ1dGVzL2xvbmdfdGV4dC9sb25nX3RleHRfY2hhbmdlLnRzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi9zcmMvYnJvd3Nlcl9zZGsvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uL3NyYy9mYWN0cy9jbGllbnQvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvbWQ1LmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL25pbC5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9wYXJzZS5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9yZWdleC5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9ybmcuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvc2hhMS5qcyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9zdHJpbmdpZnkuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjEuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjMuanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjM1LmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3Y0LmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3Y1LmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3ZhbGlkYXRlLmpzIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3ZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL2xpbmtlZHJlY29yZHMvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9saW5rZWRyZWNvcmRzL3dlYnBhY2svYmVmb3JlLXN0YXJ0dXAiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy93ZWJwYWNrL3N0YXJ0dXAiLCJ3ZWJwYWNrOi8vbGlua2VkcmVjb3Jkcy93ZWJwYWNrL2FmdGVyLXN0YXJ0dXAiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBgXG48ZGl2IGNsYXNzPVwibGF0ZXgtZXEtdG9vbHRpcFwiPlxuU29tZSBFeGFtcGxlcyB3aGF0IHlvdSBjYW4gaW5zZXJ0IGhlcmUuIFlvdSBjYW4gc2Nyb2xsIHRoZSBsaXN0IHRvIHNlZSBtb3JlLlxuPHRhYmxlPlxuPHRyPlxuPHRkPlxuICA8ZGl2IGNsYXNzPVwibWFya3VwXCI+ZT1tY14yPC9kaXY+XG48L3RkPlxuPHRkPlxuICA8c3BhbiBjbGFzcz1cImthdGV4LWRpc3BsYXlcIj48c3BhbiBjbGFzcz1cImthdGV4XCI+PHNwYW4gY2xhc3M9XCJrYXRleC1tYXRobWxcIj48bWF0aCB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIj48c2VtYW50aWNzPjxtcm93PjxtaT5lPC9taT48bW8+PTwvbW8+PG1pPm08L21pPjxtc3VwPjxtaT5jPC9taT48bW4+MjwvbW4+PC9tc3VwPjwvbXJvdz48YW5ub3RhdGlvbiBlbmNvZGluZz1cImFwcGxpY2F0aW9uL3gtdGV4XCI+ZT1tY14yPC9hbm5vdGF0aW9uPjwvc2VtYW50aWNzPjwvbWF0aD48L3NwYW4+PHNwYW4gY2xhc3M9XCJrYXRleC1odG1sXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PHNwYW4gY2xhc3M9XCJiYXNlXCI+PHNwYW4gY2xhc3M9XCJzdHJ1dFwiIHN0eWxlPVwiaGVpZ2h0OiAwLjQzMDU2ZW07IHZlcnRpY2FsLWFsaWduOiAwZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwibW9yZCBtYXRoZGVmYXVsdFwiPmU8L3NwYW4+PHNwYW4gY2xhc3M9XCJtc3BhY2VcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMC4yNzc3NzhlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJtcmVsXCI+PTwvc3Bhbj48c3BhbiBjbGFzcz1cIm1zcGFjZVwiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAwLjI3Nzc3OGVtO1wiPjwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJiYXNlXCI+PHNwYW4gY2xhc3M9XCJzdHJ1dFwiIHN0eWxlPVwiaGVpZ2h0OiAwLjg2NDEwOGVtOyB2ZXJ0aWNhbC1hbGlnbjogMGVtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1vcmQgbWF0aGRlZmF1bHRcIj5tPC9zcGFuPjxzcGFuIGNsYXNzPVwibW9yZFwiPjxzcGFuIGNsYXNzPVwibW9yZCBtYXRoZGVmYXVsdFwiPmM8L3NwYW4+PHNwYW4gY2xhc3M9XCJtc3Vwc3ViXCI+PHNwYW4gY2xhc3M9XCJ2bGlzdC10XCI+PHNwYW4gY2xhc3M9XCJ2bGlzdC1yXCI+PHNwYW4gY2xhc3M9XCJ2bGlzdFwiIHN0eWxlPVwiaGVpZ2h0OiAwLjg2NDEwOGVtO1wiPjxzcGFuIGNsYXNzPVwiXCIgc3R5bGU9XCJ0b3A6IC0zLjExM2VtOyBtYXJnaW4tcmlnaHQ6IDAuMDVlbTtcIj48c3BhbiBjbGFzcz1cInBzdHJ1dFwiIHN0eWxlPVwiaGVpZ2h0OiAyLjdlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJzaXppbmcgcmVzZXQtc2l6ZTYgc2l6ZTMgbXRpZ2h0XCI+PHNwYW4gY2xhc3M9XCJtb3JkIG10aWdodFwiPjI8L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj5cbjwvdGQ+XG48L3RyPlxuPHRyPlxuPHRkPlxuICA8ZGl2IGNsYXNzPVwibWFya3VwXCI+eSA9IFxcXFxmcmFjezJ4XjJ9ezh4fTwvZGl2PlxuPC90ZD5cbjx0ZD5cbiAgPHNwYW4gY2xhc3M9XCJrYXRleC1kaXNwbGF5XCI+PHNwYW4gY2xhc3M9XCJrYXRleFwiPjxzcGFuIGNsYXNzPVwia2F0ZXgtbWF0aG1sXCI+PG1hdGggeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCI+PHNlbWFudGljcz48bXJvdz48bWk+eTwvbWk+PG1vPj08L21vPjxtZnJhYz48bXJvdz48bW4+MjwvbW4+PG1zdXA+PG1pPng8L21pPjxtbj4yPC9tbj48L21zdXA+PC9tcm93Pjxtcm93Pjxtbj44PC9tbj48bWk+eDwvbWk+PC9tcm93PjwvbWZyYWM+PC9tcm93Pjxhbm5vdGF0aW9uIGVuY29kaW5nPVwiYXBwbGljYXRpb24veC10ZXhcIj55ID0gXFxcXGZyYWN7MnheMn17OHh9PC9hbm5vdGF0aW9uPjwvc2VtYW50aWNzPjwvbWF0aD48L3NwYW4+PHNwYW4gY2xhc3M9XCJrYXRleC1odG1sXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PHNwYW4gY2xhc3M9XCJiYXNlXCI+PHNwYW4gY2xhc3M9XCJzdHJ1dFwiIHN0eWxlPVwiaGVpZ2h0OiAwLjYyNWVtOyB2ZXJ0aWNhbC1hbGlnbjogLTAuMTk0NDRlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJtb3JkIG1hdGhkZWZhdWx0XCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDAuMDM1ODhlbTtcIj55PC9zcGFuPjxzcGFuIGNsYXNzPVwibXNwYWNlXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDAuMjc3Nzc4ZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwibXJlbFwiPj08L3NwYW4+PHNwYW4gY2xhc3M9XCJtc3BhY2VcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMC4yNzc3NzhlbTtcIj48L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwiYmFzZVwiPjxzcGFuIGNsYXNzPVwic3RydXRcIiBzdHlsZT1cImhlaWdodDogMi4xNzcxMWVtOyB2ZXJ0aWNhbC1hbGlnbjogLTAuNjg2ZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwibW9yZFwiPjxzcGFuIGNsYXNzPVwibW9wZW4gbnVsbGRlbGltaXRlclwiPjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1mcmFjXCI+PHNwYW4gY2xhc3M9XCJ2bGlzdC10IHZsaXN0LXQyXCI+PHNwYW4gY2xhc3M9XCJ2bGlzdC1yXCI+PHNwYW4gY2xhc3M9XCJ2bGlzdFwiIHN0eWxlPVwiaGVpZ2h0OiAxLjQ5MTExZW07XCI+PHNwYW4gY2xhc3M9XCJcIiBzdHlsZT1cInRvcDogLTIuMzE0ZW07XCI+PHNwYW4gY2xhc3M9XCJwc3RydXRcIiBzdHlsZT1cImhlaWdodDogM2VtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1vcmRcIj48c3BhbiBjbGFzcz1cIm1vcmRcIj44PC9zcGFuPjxzcGFuIGNsYXNzPVwibW9yZCBtYXRoZGVmYXVsdFwiPng8L3NwYW4+PC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cIlwiIHN0eWxlPVwidG9wOiAtMy4yM2VtO1wiPjxzcGFuIGNsYXNzPVwicHN0cnV0XCIgc3R5bGU9XCJoZWlnaHQ6IDNlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJmcmFjLWxpbmVcIiBzdHlsZT1cImJvcmRlci1ib3R0b20td2lkdGg6IDAuMDRlbTtcIj48L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwiXCIgc3R5bGU9XCJ0b3A6IC0zLjY3N2VtO1wiPjxzcGFuIGNsYXNzPVwicHN0cnV0XCIgc3R5bGU9XCJoZWlnaHQ6IDNlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJtb3JkXCI+PHNwYW4gY2xhc3M9XCJtb3JkXCI+Mjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1vcmRcIj48c3BhbiBjbGFzcz1cIm1vcmQgbWF0aGRlZmF1bHRcIj54PC9zcGFuPjxzcGFuIGNsYXNzPVwibXN1cHN1YlwiPjxzcGFuIGNsYXNzPVwidmxpc3QtdFwiPjxzcGFuIGNsYXNzPVwidmxpc3QtclwiPjxzcGFuIGNsYXNzPVwidmxpc3RcIiBzdHlsZT1cImhlaWdodDogMC44MTQxMDhlbTtcIj48c3BhbiBjbGFzcz1cIlwiIHN0eWxlPVwidG9wOiAtMy4wNjNlbTsgbWFyZ2luLXJpZ2h0OiAwLjA1ZW07XCI+PHNwYW4gY2xhc3M9XCJwc3RydXRcIiBzdHlsZT1cImhlaWdodDogMi43ZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwic2l6aW5nIHJlc2V0LXNpemU2IHNpemUzIG10aWdodFwiPjxzcGFuIGNsYXNzPVwibW9yZCBtdGlnaHRcIj4yPC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cInZsaXN0LXNcIj7igIs8L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwidmxpc3QtclwiPjxzcGFuIGNsYXNzPVwidmxpc3RcIiBzdHlsZT1cImhlaWdodDogMC42ODZlbTtcIj48c3BhbiBjbGFzcz1cIlwiPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJtY2xvc2UgbnVsbGRlbGltaXRlclwiPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPlxuPC90ZD5cbjwvdHI+XG48dHI+XG48dGQ+XG4gIDxkaXYgY2xhc3M9XCJtYXJrdXBcIj5cXFxcaW50XnthKzF9X3thLTF9PC9kaXY+XG48L3RkPlxuPHRkPlxuICA8c3BhbiBjbGFzcz1cImthdGV4LWRpc3BsYXlcIj48c3BhbiBjbGFzcz1cImthdGV4XCI+PHNwYW4gY2xhc3M9XCJrYXRleC1tYXRobWxcIj48bWF0aCB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIj48c2VtYW50aWNzPjxtcm93Pjxtc3Vic3VwPjxtbz7iiKs8L21vPjxtcm93PjxtaT5hPC9taT48bW8+4oiSPC9tbz48bW4+MTwvbW4+PC9tcm93Pjxtcm93PjxtaT5hPC9taT48bW8+KzwvbW8+PG1uPjE8L21uPjwvbXJvdz48L21zdWJzdXA+PC9tcm93Pjxhbm5vdGF0aW9uIGVuY29kaW5nPVwiYXBwbGljYXRpb24veC10ZXhcIj5cXFxcaW50XnthKzF9X3thLTF9PC9hbm5vdGF0aW9uPjwvc2VtYW50aWNzPjwvbWF0aD48L3NwYW4+PHNwYW4gY2xhc3M9XCJrYXRleC1odG1sXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PHNwYW4gY2xhc3M9XCJiYXNlXCI+PHNwYW4gY2xhc3M9XCJzdHJ1dFwiIHN0eWxlPVwiaGVpZ2h0OiAyLjUzNDI5ZW07IHZlcnRpY2FsLWFsaWduOiAtMC45NzAyODFlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJtb3BcIj48c3BhbiBjbGFzcz1cIm1vcCBvcC1zeW1ib2wgbGFyZ2Utb3BcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMC40NDQ0NWVtOyBwb3NpdGlvbjogcmVsYXRpdmU7IHRvcDogLTAuMDAxMTI1ZW07XCI+4oirPC9zcGFuPjxzcGFuIGNsYXNzPVwibXN1cHN1YlwiPjxzcGFuIGNsYXNzPVwidmxpc3QtdCB2bGlzdC10MlwiPjxzcGFuIGNsYXNzPVwidmxpc3QtclwiPjxzcGFuIGNsYXNzPVwidmxpc3RcIiBzdHlsZT1cImhlaWdodDogMS41NjQwMWVtO1wiPjxzcGFuIGNsYXNzPVwiXCIgc3R5bGU9XCJ0b3A6IC0xLjc4ODA1ZW07IG1hcmdpbi1sZWZ0OiAtMC40NDQ0NWVtOyBtYXJnaW4tcmlnaHQ6IDAuMDVlbTtcIj48c3BhbiBjbGFzcz1cInBzdHJ1dFwiIHN0eWxlPVwiaGVpZ2h0OiAyLjdlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJzaXppbmcgcmVzZXQtc2l6ZTYgc2l6ZTMgbXRpZ2h0XCI+PHNwYW4gY2xhc3M9XCJtb3JkIG10aWdodFwiPjxzcGFuIGNsYXNzPVwibW9yZCBtYXRoZGVmYXVsdCBtdGlnaHRcIj5hPC9zcGFuPjxzcGFuIGNsYXNzPVwibWJpbiBtdGlnaHRcIj7iiJI8L3NwYW4+PHNwYW4gY2xhc3M9XCJtb3JkIG10aWdodFwiPjE8L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJcIiBzdHlsZT1cInRvcDogLTMuODEyOWVtOyBtYXJnaW4tcmlnaHQ6IDAuMDVlbTtcIj48c3BhbiBjbGFzcz1cInBzdHJ1dFwiIHN0eWxlPVwiaGVpZ2h0OiAyLjdlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJzaXppbmcgcmVzZXQtc2l6ZTYgc2l6ZTMgbXRpZ2h0XCI+PHNwYW4gY2xhc3M9XCJtb3JkIG10aWdodFwiPjxzcGFuIGNsYXNzPVwibW9yZCBtYXRoZGVmYXVsdCBtdGlnaHRcIj5hPC9zcGFuPjxzcGFuIGNsYXNzPVwibWJpbiBtdGlnaHRcIj4rPC9zcGFuPjxzcGFuIGNsYXNzPVwibW9yZCBtdGlnaHRcIj4xPC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cInZsaXN0LXNcIj7igIs8L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwidmxpc3QtclwiPjxzcGFuIGNsYXNzPVwidmxpc3RcIiBzdHlsZT1cImhlaWdodDogMC45NzAyODFlbTtcIj48c3BhbiBjbGFzcz1cIlwiPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj5cbjwvdGQ+XG48L3RyPlxuPHRyPlxuPHRkPlxuICA8ZGl2IGNsYXNzPVwibWFya3VwXCI+XFxcXHN1bV97aT0xfV5uIGFfaTwvZGl2PlxuPC90ZD5cbjx0ZD5cbiAgPHNwYW4gY2xhc3M9XCJrYXRleC1kaXNwbGF5XCI+PHNwYW4gY2xhc3M9XCJrYXRleFwiPjxzcGFuIGNsYXNzPVwia2F0ZXgtbWF0aG1sXCI+PG1hdGggeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCI+PHNlbWFudGljcz48bXJvdz48bXVuZGVyb3Zlcj48bW8+4oiRPC9tbz48bXJvdz48bWk+aTwvbWk+PG1vPj08L21vPjxtbj4xPC9tbj48L21yb3c+PG1pPm48L21pPjwvbXVuZGVyb3Zlcj48bXN1Yj48bWk+YTwvbWk+PG1pPmk8L21pPjwvbXN1Yj48L21yb3c+PGFubm90YXRpb24gZW5jb2Rpbmc9XCJhcHBsaWNhdGlvbi94LXRleFwiPlxcXFxzdW1fe2k9MX1ebiBhX2k8L2Fubm90YXRpb24+PC9zZW1hbnRpY3M+PC9tYXRoPjwvc3Bhbj48c3BhbiBjbGFzcz1cImthdGV4LWh0bWxcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48c3BhbiBjbGFzcz1cImJhc2VcIj48c3BhbiBjbGFzcz1cInN0cnV0XCIgc3R5bGU9XCJoZWlnaHQ6IDIuOTI5MDdlbTsgdmVydGljYWwtYWxpZ246IC0xLjI3NzY3ZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwibW9wIG9wLWxpbWl0c1wiPjxzcGFuIGNsYXNzPVwidmxpc3QtdCB2bGlzdC10MlwiPjxzcGFuIGNsYXNzPVwidmxpc3QtclwiPjxzcGFuIGNsYXNzPVwidmxpc3RcIiBzdHlsZT1cImhlaWdodDogMS42NTE0ZW07XCI+PHNwYW4gY2xhc3M9XCJcIiBzdHlsZT1cInRvcDogLTEuODcyMzNlbTsgbWFyZ2luLWxlZnQ6IDBlbTtcIj48c3BhbiBjbGFzcz1cInBzdHJ1dFwiIHN0eWxlPVwiaGVpZ2h0OiAzLjA1ZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwic2l6aW5nIHJlc2V0LXNpemU2IHNpemUzIG10aWdodFwiPjxzcGFuIGNsYXNzPVwibW9yZCBtdGlnaHRcIj48c3BhbiBjbGFzcz1cIm1vcmQgbWF0aGRlZmF1bHQgbXRpZ2h0XCI+aTwvc3Bhbj48c3BhbiBjbGFzcz1cIm1yZWwgbXRpZ2h0XCI+PTwvc3Bhbj48c3BhbiBjbGFzcz1cIm1vcmQgbXRpZ2h0XCI+MTwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cIlwiIHN0eWxlPVwidG9wOiAtMy4wNTAwMWVtO1wiPjxzcGFuIGNsYXNzPVwicHN0cnV0XCIgc3R5bGU9XCJoZWlnaHQ6IDMuMDVlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJcIj48c3BhbiBjbGFzcz1cIm1vcCBvcC1zeW1ib2wgbGFyZ2Utb3BcIj7iiJE8L3NwYW4+PC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cIlwiIHN0eWxlPVwidG9wOiAtNC4zMDAwMWVtOyBtYXJnaW4tbGVmdDogMGVtO1wiPjxzcGFuIGNsYXNzPVwicHN0cnV0XCIgc3R5bGU9XCJoZWlnaHQ6IDMuMDVlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJzaXppbmcgcmVzZXQtc2l6ZTYgc2l6ZTMgbXRpZ2h0XCI+PHNwYW4gY2xhc3M9XCJtb3JkIG1hdGhkZWZhdWx0IG10aWdodFwiPm48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJ2bGlzdC1zXCI+4oCLPC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cInZsaXN0LXJcIj48c3BhbiBjbGFzcz1cInZsaXN0XCIgc3R5bGU9XCJoZWlnaHQ6IDEuMjc3NjdlbTtcIj48c3BhbiBjbGFzcz1cIlwiPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJtc3BhY2VcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMC4xNjY2NjdlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJtb3JkXCI+PHNwYW4gY2xhc3M9XCJtb3JkIG1hdGhkZWZhdWx0XCI+YTwvc3Bhbj48c3BhbiBjbGFzcz1cIm1zdXBzdWJcIj48c3BhbiBjbGFzcz1cInZsaXN0LXQgdmxpc3QtdDJcIj48c3BhbiBjbGFzcz1cInZsaXN0LXJcIj48c3BhbiBjbGFzcz1cInZsaXN0XCIgc3R5bGU9XCJoZWlnaHQ6IDAuMzExNjY0ZW07XCI+PHNwYW4gY2xhc3M9XCJcIiBzdHlsZT1cInRvcDogLTIuNTVlbTsgbWFyZ2luLWxlZnQ6IDBlbTsgbWFyZ2luLXJpZ2h0OiAwLjA1ZW07XCI+PHNwYW4gY2xhc3M9XCJwc3RydXRcIiBzdHlsZT1cImhlaWdodDogMi43ZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwic2l6aW5nIHJlc2V0LXNpemU2IHNpemUzIG10aWdodFwiPjxzcGFuIGNsYXNzPVwibW9yZCBtYXRoZGVmYXVsdCBtdGlnaHRcIj5pPC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwidmxpc3Qtc1wiPuKAizwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJ2bGlzdC1yXCI+PHNwYW4gY2xhc3M9XCJ2bGlzdFwiIHN0eWxlPVwiaGVpZ2h0OiAwLjE1ZW07XCI+PHNwYW4gY2xhc3M9XCJcIj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+XG48L3RkPlxuPC90cj5cbjx0cj5cbjx0ZD5cbiAgPGRpdiBjbGFzcz1cIm1hcmt1cFwiPlxcXFxiaWdbeFxcXFxiaWddPC9kaXY+XG48L3RkPlxuPHRkPlxuICA8c3BhbiBjbGFzcz1cImthdGV4LWRpc3BsYXlcIj48c3BhbiBjbGFzcz1cImthdGV4XCI+PHNwYW4gY2xhc3M9XCJrYXRleC1tYXRobWxcIj48bWF0aCB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIj48c2VtYW50aWNzPjxtcm93PjxtbyBmZW5jZT1cImZhbHNlXCI+WzwvbW8+PG1pPng8L21pPjxtbyBmZW5jZT1cImZhbHNlXCI+XTwvbW8+PC9tcm93Pjxhbm5vdGF0aW9uIGVuY29kaW5nPVwiYXBwbGljYXRpb24veC10ZXhcIj5cXFxcYmlnW3hcXFxcYmlnXTwvYW5ub3RhdGlvbj48L3NlbWFudGljcz48L21hdGg+PC9zcGFuPjxzcGFuIGNsYXNzPVwia2F0ZXgtaHRtbFwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjxzcGFuIGNsYXNzPVwiYmFzZVwiPjxzcGFuIGNsYXNzPVwic3RydXRcIiBzdHlsZT1cImhlaWdodDogMS4yMDAwMWVtOyB2ZXJ0aWNhbC1hbGlnbjogLTAuMzUwMDFlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJtb3JkXCI+PHNwYW4gY2xhc3M9XCJkZWxpbXNpemluZyBzaXplMVwiPls8L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwibW9yZCBtYXRoZGVmYXVsdFwiPng8L3NwYW4+PHNwYW4gY2xhc3M9XCJtb3JkXCI+PHNwYW4gY2xhc3M9XCJkZWxpbXNpemluZyBzaXplMVwiPl08L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj5cbjwvdGQ+XG48L3RyPlxuPHRyPlxuPHRkPlxuICA8ZGl2IGNsYXNzPVwibWFya3VwXCI+XFxcXEJpZ1t4XFxcXEJpZ108L2Rpdj5cbjwvdGQ+XG48dGQ+XG4gIDxzcGFuIGNsYXNzPVwia2F0ZXgtZGlzcGxheVwiPjxzcGFuIGNsYXNzPVwia2F0ZXhcIj48c3BhbiBjbGFzcz1cImthdGV4LW1hdGhtbFwiPjxtYXRoIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiPjxzZW1hbnRpY3M+PG1yb3c+PG1vIGZlbmNlPVwiZmFsc2VcIj5bPC9tbz48bWk+eDwvbWk+PG1vIGZlbmNlPVwiZmFsc2VcIj5dPC9tbz48L21yb3c+PGFubm90YXRpb24gZW5jb2Rpbmc9XCJhcHBsaWNhdGlvbi94LXRleFwiPlxcXFxCaWdbeFxcXFxCaWddPC9hbm5vdGF0aW9uPjwvc2VtYW50aWNzPjwvbWF0aD48L3NwYW4+PHNwYW4gY2xhc3M9XCJrYXRleC1odG1sXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PHNwYW4gY2xhc3M9XCJiYXNlXCI+PHNwYW4gY2xhc3M9XCJzdHJ1dFwiIHN0eWxlPVwiaGVpZ2h0OiAxLjgwMDAyZW07IHZlcnRpY2FsLWFsaWduOiAtMC42NTAwMmVtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1vcmRcIj48c3BhbiBjbGFzcz1cImRlbGltc2l6aW5nIHNpemUyXCI+Wzwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJtb3JkIG1hdGhkZWZhdWx0XCI+eDwvc3Bhbj48c3BhbiBjbGFzcz1cIm1vcmRcIj48c3BhbiBjbGFzcz1cImRlbGltc2l6aW5nIHNpemUyXCI+XTwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPlxuPC90ZD5cbjwvdHI+XG48dHI+XG48dGQ+XG4gIDxkaXYgY2xhc3M9XCJtYXJrdXBcIj5cXFxcbGltX3toXFxcXHRvMH0gXFxcXGZyYWN7MX17bn08L2Rpdj5cbjwvdGQ+XG48dGQ+XG4gIDxzcGFuIGNsYXNzPVwia2F0ZXgtZGlzcGxheVwiPjxzcGFuIGNsYXNzPVwia2F0ZXhcIj48c3BhbiBjbGFzcz1cImthdGV4LW1hdGhtbFwiPjxtYXRoIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiPjxzZW1hbnRpY3M+PG1yb3c+PG11bmRlcj48bW8+PG1pPmxpbTwvbWk+PG1vPuKBoTwvbW8+PC9tbz48bXJvdz48bWk+aDwvbWk+PG1vPuKGkjwvbW8+PG1uPjA8L21uPjwvbXJvdz48L211bmRlcj48bWZyYWM+PG1uPjE8L21uPjxtaT5uPC9taT48L21mcmFjPjwvbXJvdz48YW5ub3RhdGlvbiBlbmNvZGluZz1cImFwcGxpY2F0aW9uL3gtdGV4XCI+XFxcXGxpbV97aFxcXFx0bzB9IFxcXFxmcmFjezF9e259PC9hbm5vdGF0aW9uPjwvc2VtYW50aWNzPjwvbWF0aD48L3NwYW4+PHNwYW4gY2xhc3M9XCJrYXRleC1odG1sXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PHNwYW4gY2xhc3M9XCJiYXNlXCI+PHNwYW4gY2xhc3M9XCJzdHJ1dFwiIHN0eWxlPVwiaGVpZ2h0OiAyLjA3MzU1ZW07IHZlcnRpY2FsLWFsaWduOiAtMC43NTIxMDhlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJtb3Agb3AtbGltaXRzXCI+PHNwYW4gY2xhc3M9XCJ2bGlzdC10IHZsaXN0LXQyXCI+PHNwYW4gY2xhc3M9XCJ2bGlzdC1yXCI+PHNwYW4gY2xhc3M9XCJ2bGlzdFwiIHN0eWxlPVwiaGVpZ2h0OiAwLjY5NDQ0ZW07XCI+PHNwYW4gY2xhc3M9XCJcIiBzdHlsZT1cInRvcDogLTIuMzQ3ODllbTsgbWFyZ2luLWxlZnQ6IDBlbTtcIj48c3BhbiBjbGFzcz1cInBzdHJ1dFwiIHN0eWxlPVwiaGVpZ2h0OiAzZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwic2l6aW5nIHJlc2V0LXNpemU2IHNpemUzIG10aWdodFwiPjxzcGFuIGNsYXNzPVwibW9yZCBtdGlnaHRcIj48c3BhbiBjbGFzcz1cIm1vcmQgbWF0aGRlZmF1bHQgbXRpZ2h0XCI+aDwvc3Bhbj48c3BhbiBjbGFzcz1cIm1yZWwgbXRpZ2h0XCI+4oaSPC9zcGFuPjxzcGFuIGNsYXNzPVwibW9yZCBtdGlnaHRcIj4wPC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwiXCIgc3R5bGU9XCJ0b3A6IC0zZW07XCI+PHNwYW4gY2xhc3M9XCJwc3RydXRcIiBzdHlsZT1cImhlaWdodDogM2VtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cIlwiPjxzcGFuIGNsYXNzPVwibW9wXCI+bGltPC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwidmxpc3Qtc1wiPuKAizwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJ2bGlzdC1yXCI+PHNwYW4gY2xhc3M9XCJ2bGlzdFwiIHN0eWxlPVwiaGVpZ2h0OiAwLjc1MjEwOGVtO1wiPjxzcGFuIGNsYXNzPVwiXCI+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1zcGFjZVwiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAwLjE2NjY2N2VtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1vcmRcIj48c3BhbiBjbGFzcz1cIm1vcGVuIG51bGxkZWxpbWl0ZXJcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJtZnJhY1wiPjxzcGFuIGNsYXNzPVwidmxpc3QtdCB2bGlzdC10MlwiPjxzcGFuIGNsYXNzPVwidmxpc3QtclwiPjxzcGFuIGNsYXNzPVwidmxpc3RcIiBzdHlsZT1cImhlaWdodDogMS4zMjE0NGVtO1wiPjxzcGFuIGNsYXNzPVwiXCIgc3R5bGU9XCJ0b3A6IC0yLjMxNGVtO1wiPjxzcGFuIGNsYXNzPVwicHN0cnV0XCIgc3R5bGU9XCJoZWlnaHQ6IDNlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJtb3JkXCI+PHNwYW4gY2xhc3M9XCJtb3JkIG1hdGhkZWZhdWx0XCI+bjwvc3Bhbj48L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwiXCIgc3R5bGU9XCJ0b3A6IC0zLjIzZW07XCI+PHNwYW4gY2xhc3M9XCJwc3RydXRcIiBzdHlsZT1cImhlaWdodDogM2VtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cImZyYWMtbGluZVwiIHN0eWxlPVwiYm9yZGVyLWJvdHRvbS13aWR0aDogMC4wNGVtO1wiPjwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJcIiBzdHlsZT1cInRvcDogLTMuNjc3ZW07XCI+PHNwYW4gY2xhc3M9XCJwc3RydXRcIiBzdHlsZT1cImhlaWdodDogM2VtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1vcmRcIj48c3BhbiBjbGFzcz1cIm1vcmRcIj4xPC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwidmxpc3Qtc1wiPuKAizwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJ2bGlzdC1yXCI+PHNwYW4gY2xhc3M9XCJ2bGlzdFwiIHN0eWxlPVwiaGVpZ2h0OiAwLjY4NmVtO1wiPjxzcGFuIGNsYXNzPVwiXCI+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1jbG9zZSBudWxsZGVsaW1pdGVyXCI+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+XG48L3RkPlxuPC90cj5cbjx0cj5cbjx0ZD5cbiAgPGRpdiBjbGFzcz1cIm1hcmt1cFwiPlxcXFxzcXJ0ezl9ID0gXFxcXHNxcnRbMl17OX0gPC9kaXY+XG48L3RkPlxuPHRkPlxuICA8c3BhbiBjbGFzcz1cImthdGV4LWRpc3BsYXlcIj48c3BhbiBjbGFzcz1cImthdGV4XCI+PHNwYW4gY2xhc3M9XCJrYXRleC1tYXRobWxcIj48bWF0aCB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIj48c2VtYW50aWNzPjxtcm93Pjxtc3FydD48bW4+OTwvbW4+PC9tc3FydD48bW8+PTwvbW8+PG1yb290Pjxtbj45PC9tbj48bW4+MjwvbW4+PC9tcm9vdD48L21yb3c+PGFubm90YXRpb24gZW5jb2Rpbmc9XCJhcHBsaWNhdGlvbi94LXRleFwiPlxcXFxzcXJ0ezl9ID0gXFxcXHNxcnRbMl17OX0gPC9hbm5vdGF0aW9uPjwvc2VtYW50aWNzPjwvbWF0aD48L3NwYW4+PHNwYW4gY2xhc3M9XCJrYXRleC1odG1sXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PHNwYW4gY2xhc3M9XCJiYXNlXCI+PHNwYW4gY2xhc3M9XCJzdHJ1dFwiIHN0eWxlPVwiaGVpZ2h0OiAxLjA0ZW07IHZlcnRpY2FsLWFsaWduOiAtMC4wODM5MDVlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJtb3JkIHNxcnRcIj48c3BhbiBjbGFzcz1cInZsaXN0LXQgdmxpc3QtdDJcIj48c3BhbiBjbGFzcz1cInZsaXN0LXJcIj48c3BhbiBjbGFzcz1cInZsaXN0XCIgc3R5bGU9XCJoZWlnaHQ6IDAuOTU2MDk1ZW07XCI+PHNwYW4gY2xhc3M9XCJzdmctYWxpZ25cIiBzdHlsZT1cInRvcDogLTNlbTtcIj48c3BhbiBjbGFzcz1cInBzdHJ1dFwiIHN0eWxlPVwiaGVpZ2h0OiAzZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwibW9yZFwiIHN0eWxlPVwicGFkZGluZy1sZWZ0OiAwLjgzM2VtO1wiPjxzcGFuIGNsYXNzPVwibW9yZFwiPjk8L3NwYW4+PC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cIlwiIHN0eWxlPVwidG9wOiAtMi45MTYwOWVtO1wiPjxzcGFuIGNsYXNzPVwicHN0cnV0XCIgc3R5bGU9XCJoZWlnaHQ6IDNlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJoaWRlLXRhaWxcIiBzdHlsZT1cIm1pbi13aWR0aDogMC44NTNlbTsgaGVpZ2h0OiAxLjA4ZW07XCI+PHN2ZyB3aWR0aD1cIjQwMGVtXCIgaGVpZ2h0PVwiMS4wOGVtXCIgdmlld0JveD1cIjAgMCA0MDAwMDAgMTA4MFwiIHByZXNlcnZlQXNwZWN0UmF0aW89XCJ4TWluWU1pbiBzbGljZVwiPjxwYXRoIGQ9XCJNOTUsNzAyXG4gICAgYy0yLjcsMCwtNy4xNywtMi43LC0xMy41LC04Yy01LjgsLTUuMywtOS41LC0xMCwtOS41LC0xNFxuICAgIGMwLC0yLDAuMywtMy4zLDEsLTRjMS4zLC0yLjcsMjMuODMsLTIwLjcsNjcuNSwtNTRcbiAgICBjNDQuMiwtMzMuMyw2NS44LC01MC4zLDY2LjUsLTUxYzEuMywtMS4zLDMsLTIsNSwtMmM0LjcsMCw4LjcsMy4zLDEyLDEwXG4gICAgczE3MywzNzgsMTczLDM3OGMwLjcsMCwzNS4zLC03MSwxMDQsLTIxM2M2OC43LC0xNDIsMTM3LjUsLTI4NSwyMDYuNSwtNDI5XG4gICAgYzY5LC0xNDQsMTA0LjUsLTIxNy43LDEwNi41LC0yMjFcbiAgICBsMCAtMFxuICAgIGM1LjMsLTkuMywxMiwtMTQsMjAsLTE0XG4gICAgSDQwMDAwMHY0MEg4NDUuMjcyNFxuICAgIHMtMjI1LjI3Miw0NjcsLTIyNS4yNzIsNDY3cy0yMzUsNDg2LC0yMzUsNDg2Yy0yLjcsNC43LC05LDcsLTE5LDdcbiAgICBjLTYsMCwtMTAsLTEsLTEyLC0zcy0xOTQsLTQyMiwtMTk0LC00MjJzLTY1LDQ3LC02NSw0N3pcbiAgICBNODM0IDgwaDQwMDAwMHY0MGgtNDAwMDAwelwiPjwvcGF0aD48L3N2Zz48L3NwYW4+PC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cInZsaXN0LXNcIj7igIs8L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwidmxpc3QtclwiPjxzcGFuIGNsYXNzPVwidmxpc3RcIiBzdHlsZT1cImhlaWdodDogMC4wODM5MDVlbTtcIj48c3BhbiBjbGFzcz1cIlwiPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJtc3BhY2VcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMC4yNzc3NzhlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJtcmVsXCI+PTwvc3Bhbj48c3BhbiBjbGFzcz1cIm1zcGFjZVwiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAwLjI3Nzc3OGVtO1wiPjwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJiYXNlXCI+PHNwYW4gY2xhc3M9XCJzdHJ1dFwiIHN0eWxlPVwiaGVpZ2h0OiAxLjA0ZW07IHZlcnRpY2FsLWFsaWduOiAtMC4wODM5MDVlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJtb3JkIHNxcnRcIj48c3BhbiBjbGFzcz1cInJvb3RcIj48c3BhbiBjbGFzcz1cInZsaXN0LXRcIj48c3BhbiBjbGFzcz1cInZsaXN0LXJcIj48c3BhbiBjbGFzcz1cInZsaXN0XCIgc3R5bGU9XCJoZWlnaHQ6IDAuODQ1NTM0ZW07XCI+PHNwYW4gY2xhc3M9XCJcIiBzdHlsZT1cInRvcDogLTMuMDIzMzFlbTtcIj48c3BhbiBjbGFzcz1cInBzdHJ1dFwiIHN0eWxlPVwiaGVpZ2h0OiAyLjVlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJzaXppbmcgcmVzZXQtc2l6ZTYgc2l6ZTEgbXRpZ2h0XCI+PHNwYW4gY2xhc3M9XCJtb3JkIG10aWdodFwiPjxzcGFuIGNsYXNzPVwibW9yZCBtdGlnaHRcIj4yPC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cInZsaXN0LXQgdmxpc3QtdDJcIj48c3BhbiBjbGFzcz1cInZsaXN0LXJcIj48c3BhbiBjbGFzcz1cInZsaXN0XCIgc3R5bGU9XCJoZWlnaHQ6IDAuOTU2MDk1ZW07XCI+PHNwYW4gY2xhc3M9XCJzdmctYWxpZ25cIiBzdHlsZT1cInRvcDogLTNlbTtcIj48c3BhbiBjbGFzcz1cInBzdHJ1dFwiIHN0eWxlPVwiaGVpZ2h0OiAzZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwibW9yZFwiIHN0eWxlPVwicGFkZGluZy1sZWZ0OiAwLjgzM2VtO1wiPjxzcGFuIGNsYXNzPVwibW9yZFwiPjk8L3NwYW4+PC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cIlwiIHN0eWxlPVwidG9wOiAtMi45MTYwOWVtO1wiPjxzcGFuIGNsYXNzPVwicHN0cnV0XCIgc3R5bGU9XCJoZWlnaHQ6IDNlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJoaWRlLXRhaWxcIiBzdHlsZT1cIm1pbi13aWR0aDogMC44NTNlbTsgaGVpZ2h0OiAxLjA4ZW07XCI+PHN2ZyB3aWR0aD1cIjQwMGVtXCIgaGVpZ2h0PVwiMS4wOGVtXCIgdmlld0JveD1cIjAgMCA0MDAwMDAgMTA4MFwiIHByZXNlcnZlQXNwZWN0UmF0aW89XCJ4TWluWU1pbiBzbGljZVwiPjxwYXRoIGQ9XCJNOTUsNzAyXG4gICAgYy0yLjcsMCwtNy4xNywtMi43LC0xMy41LC04Yy01LjgsLTUuMywtOS41LC0xMCwtOS41LC0xNFxuICAgIGMwLC0yLDAuMywtMy4zLDEsLTRjMS4zLC0yLjcsMjMuODMsLTIwLjcsNjcuNSwtNTRcbiAgICBjNDQuMiwtMzMuMyw2NS44LC01MC4zLDY2LjUsLTUxYzEuMywtMS4zLDMsLTIsNSwtMmM0LjcsMCw4LjcsMy4zLDEyLDEwXG4gICAgczE3MywzNzgsMTczLDM3OGMwLjcsMCwzNS4zLC03MSwxMDQsLTIxM2M2OC43LC0xNDIsMTM3LjUsLTI4NSwyMDYuNSwtNDI5XG4gICAgYzY5LC0xNDQsMTA0LjUsLTIxNy43LDEwNi41LC0yMjFcbiAgICBsMCAtMFxuICAgIGM1LjMsLTkuMywxMiwtMTQsMjAsLTE0XG4gICAgSDQwMDAwMHY0MEg4NDUuMjcyNFxuICAgIHMtMjI1LjI3Miw0NjcsLTIyNS4yNzIsNDY3cy0yMzUsNDg2LC0yMzUsNDg2Yy0yLjcsNC43LC05LDcsLTE5LDdcbiAgICBjLTYsMCwtMTAsLTEsLTEyLC0zcy0xOTQsLTQyMiwtMTk0LC00MjJzLTY1LDQ3LC02NSw0N3pcbiAgICBNODM0IDgwaDQwMDAwMHY0MGgtNDAwMDAwelwiPjwvcGF0aD48L3N2Zz48L3NwYW4+PC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cInZsaXN0LXNcIj7igIs8L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwidmxpc3QtclwiPjxzcGFuIGNsYXNzPVwidmxpc3RcIiBzdHlsZT1cImhlaWdodDogMC4wODM5MDVlbTtcIj48c3BhbiBjbGFzcz1cIlwiPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPlxuPC90ZD5cbjwvdHI+XG48dHI+XG48dGQ+XG4gIDxkaXYgY2xhc3M9XCJtYXJrdXBcIj5cbiAgICBcXFxcYmVnaW57cG1hdHJpeH08YnIvPlxuICAgICZuYnNwOyZuYnNwO2EgJiYgYiBcXFxcXFxcXDxici8+XG4gICAgJm5ic3A7Jm5ic3A7YyAmJiBkPGJyLz5cbiAgICBcXFxcZW5ke3BtYXRyaXh9PGJyLz5cbiAgPC9kaXY+XG48L3RkPlxuPHRkPlxuICA8c3BhbiBjbGFzcz1cImthdGV4LWRpc3BsYXlcIj48c3BhbiBjbGFzcz1cImthdGV4XCI+PHNwYW4gY2xhc3M9XCJrYXRleC1tYXRobWxcIj48bWF0aCB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIj48c2VtYW50aWNzPjxtcm93PjxtbyBmZW5jZT1cInRydWVcIj4oPC9tbz48bXRhYmxlIHJvd3NwYWNpbmc9XCIwLjE1OTk5OTk5OTk5OTk5OTkyZW1cIiBjb2x1bW5zcGFjaW5nPVwiMWVtXCI+PG10cj48bXRkPjxtc3R5bGUgc2NyaXB0bGV2ZWw9XCIwXCIgZGlzcGxheXN0eWxlPVwiZmFsc2VcIj48bWk+YTwvbWk+PC9tc3R5bGU+PC9tdGQ+PG10ZD48bXN0eWxlIHNjcmlwdGxldmVsPVwiMFwiIGRpc3BsYXlzdHlsZT1cImZhbHNlXCI+PG1yb3c+PC9tcm93PjwvbXN0eWxlPjwvbXRkPjxtdGQ+PG1zdHlsZSBzY3JpcHRsZXZlbD1cIjBcIiBkaXNwbGF5c3R5bGU9XCJmYWxzZVwiPjxtaT5iPC9taT48L21zdHlsZT48L210ZD48L210cj48bXRyPjxtdGQ+PG1zdHlsZSBzY3JpcHRsZXZlbD1cIjBcIiBkaXNwbGF5c3R5bGU9XCJmYWxzZVwiPjxtaT5jPC9taT48L21zdHlsZT48L210ZD48bXRkPjxtc3R5bGUgc2NyaXB0bGV2ZWw9XCIwXCIgZGlzcGxheXN0eWxlPVwiZmFsc2VcIj48bXJvdz48L21yb3c+PC9tc3R5bGU+PC9tdGQ+PG10ZD48bXN0eWxlIHNjcmlwdGxldmVsPVwiMFwiIGRpc3BsYXlzdHlsZT1cImZhbHNlXCI+PG1pPmQ8L21pPjwvbXN0eWxlPjwvbXRkPjwvbXRyPjwvbXRhYmxlPjxtbyBmZW5jZT1cInRydWVcIj4pPC9tbz48L21yb3c+PGFubm90YXRpb24gZW5jb2Rpbmc9XCJhcHBsaWNhdGlvbi94LXRleFwiPlxcXFxiZWdpbntwbWF0cml4fVxuICAgIGEgJmFtcDsmYW1wOyBiIFxcXFxcXFxcXG4gICAgYyAmYW1wOyZhbXA7IGRcbiAgXFxcXGVuZHtwbWF0cml4fVxuICA8L2Fubm90YXRpb24+PC9zZW1hbnRpY3M+PC9tYXRoPjwvc3Bhbj48c3BhbiBjbGFzcz1cImthdGV4LWh0bWxcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48c3BhbiBjbGFzcz1cImJhc2VcIj48c3BhbiBjbGFzcz1cInN0cnV0XCIgc3R5bGU9XCJoZWlnaHQ6IDIuNDAwMDNlbTsgdmVydGljYWwtYWxpZ246IC0wLjk1MDAzZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwibWlubmVyXCI+PHNwYW4gY2xhc3M9XCJtb3BlbiBkZWxpbWNlbnRlclwiIHN0eWxlPVwidG9wOiAwZW07XCI+PHNwYW4gY2xhc3M9XCJkZWxpbXNpemluZyBzaXplM1wiPig8L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwibW9yZFwiPjxzcGFuIGNsYXNzPVwibXRhYmxlXCI+PHNwYW4gY2xhc3M9XCJjb2wtYWxpZ24tY1wiPjxzcGFuIGNsYXNzPVwidmxpc3QtdCB2bGlzdC10MlwiPjxzcGFuIGNsYXNzPVwidmxpc3QtclwiPjxzcGFuIGNsYXNzPVwidmxpc3RcIiBzdHlsZT1cImhlaWdodDogMS40NWVtO1wiPjxzcGFuIGNsYXNzPVwiXCIgc3R5bGU9XCJ0b3A6IC0zLjYxZW07XCI+PHNwYW4gY2xhc3M9XCJwc3RydXRcIiBzdHlsZT1cImhlaWdodDogM2VtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1vcmRcIj48c3BhbiBjbGFzcz1cIm1vcmQgbWF0aGRlZmF1bHRcIj5hPC9zcGFuPjwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJcIiBzdHlsZT1cInRvcDogLTIuNDFlbTtcIj48c3BhbiBjbGFzcz1cInBzdHJ1dFwiIHN0eWxlPVwiaGVpZ2h0OiAzZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwibW9yZFwiPjxzcGFuIGNsYXNzPVwibW9yZCBtYXRoZGVmYXVsdFwiPmM8L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJ2bGlzdC1zXCI+4oCLPC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cInZsaXN0LXJcIj48c3BhbiBjbGFzcz1cInZsaXN0XCIgc3R5bGU9XCJoZWlnaHQ6IDAuOTVlbTtcIj48c3BhbiBjbGFzcz1cIlwiPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJhcnJheWNvbHNlcFwiIHN0eWxlPVwid2lkdGg6IDAuNWVtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cImFycmF5Y29sc2VwXCIgc3R5bGU9XCJ3aWR0aDogMC41ZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwiY29sLWFsaWduLWNcIj48c3BhbiBjbGFzcz1cInZsaXN0LXQgdmxpc3QtdDJcIj48c3BhbiBjbGFzcz1cInZsaXN0LXJcIj48c3BhbiBjbGFzcz1cInZsaXN0XCIgc3R5bGU9XCJoZWlnaHQ6IDEuNDVlbTtcIj48c3BhbiBjbGFzcz1cIlwiIHN0eWxlPVwidG9wOiAtMy40NWVtO1wiPjxzcGFuIGNsYXNzPVwicHN0cnV0XCIgc3R5bGU9XCJoZWlnaHQ6IDIuODRlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJtb3JkXCI+PC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cIlwiIHN0eWxlPVwidG9wOiAtMi4yNWVtO1wiPjxzcGFuIGNsYXNzPVwicHN0cnV0XCIgc3R5bGU9XCJoZWlnaHQ6IDIuODRlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJtb3JkXCI+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJ2bGlzdC1zXCI+4oCLPC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cInZsaXN0LXJcIj48c3BhbiBjbGFzcz1cInZsaXN0XCIgc3R5bGU9XCJoZWlnaHQ6IDAuOTVlbTtcIj48c3BhbiBjbGFzcz1cIlwiPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJhcnJheWNvbHNlcFwiIHN0eWxlPVwid2lkdGg6IDAuNWVtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cImFycmF5Y29sc2VwXCIgc3R5bGU9XCJ3aWR0aDogMC41ZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwiY29sLWFsaWduLWNcIj48c3BhbiBjbGFzcz1cInZsaXN0LXQgdmxpc3QtdDJcIj48c3BhbiBjbGFzcz1cInZsaXN0LXJcIj48c3BhbiBjbGFzcz1cInZsaXN0XCIgc3R5bGU9XCJoZWlnaHQ6IDEuNDVlbTtcIj48c3BhbiBjbGFzcz1cIlwiIHN0eWxlPVwidG9wOiAtMy42MWVtO1wiPjxzcGFuIGNsYXNzPVwicHN0cnV0XCIgc3R5bGU9XCJoZWlnaHQ6IDNlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJtb3JkXCI+PHNwYW4gY2xhc3M9XCJtb3JkIG1hdGhkZWZhdWx0XCI+Yjwvc3Bhbj48L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwiXCIgc3R5bGU9XCJ0b3A6IC0yLjQxZW07XCI+PHNwYW4gY2xhc3M9XCJwc3RydXRcIiBzdHlsZT1cImhlaWdodDogM2VtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1vcmRcIj48c3BhbiBjbGFzcz1cIm1vcmQgbWF0aGRlZmF1bHRcIj5kPC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwidmxpc3Qtc1wiPuKAizwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJ2bGlzdC1yXCI+PHNwYW4gY2xhc3M9XCJ2bGlzdFwiIHN0eWxlPVwiaGVpZ2h0OiAwLjk1ZW07XCI+PHNwYW4gY2xhc3M9XCJcIj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJtY2xvc2UgZGVsaW1jZW50ZXJcIiBzdHlsZT1cInRvcDogMGVtO1wiPjxzcGFuIGNsYXNzPVwiZGVsaW1zaXppbmcgc2l6ZTNcIj4pPC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPlxuPC90ZD5cblxuPHRyPlxuICA8dGQ+XG4gICAgPGRpdiBjbGFzcz1cIm1hcmt1cFwiPlxuICAgICAgZj1cXFxcYmVnaW57Y2FzZXN9PGJyLz5cbiAgICAgIDAgICAmIGMxXFxcXFxcXFw8YnIvPlxuICAgICAgMSAgICYgYzJcXFxcXFxcXDxici8+XG4gICAgICAyICAgJiBjMjxici8+XG4gICAgICBcXFxcZW5ke2Nhc2VzfTxici8+XG4gICAgPC9kaXY+XG4gIDwvdGQ+XG4gIDx0ZD5cbiAgICA8c3BhbiBjbGFzcz1cImthdGV4LWRpc3BsYXlcIj48c3BhbiBjbGFzcz1cImthdGV4XCI+PHNwYW4gY2xhc3M9XCJrYXRleC1tYXRobWxcIj48bWF0aCB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIj48c2VtYW50aWNzPjxtcm93PjxtaT5mPC9taT48bW8+PTwvbW8+PG1yb3c+PG1vIGZlbmNlPVwidHJ1ZVwiPns8L21vPjxtdGFibGUgcm93c3BhY2luZz1cIjAuMzU5OTk5OTk5OTk5OTk5OWVtXCIgY29sdW1uYWxpZ249XCJsZWZ0IGxlZnRcIiBjb2x1bW5zcGFjaW5nPVwiMWVtXCI+PG10cj48bXRkPjxtc3R5bGUgc2NyaXB0bGV2ZWw9XCIwXCIgZGlzcGxheXN0eWxlPVwiZmFsc2VcIj48bW4+MDwvbW4+PC9tc3R5bGU+PC9tdGQ+PG10ZD48bXN0eWxlIHNjcmlwdGxldmVsPVwiMFwiIGRpc3BsYXlzdHlsZT1cImZhbHNlXCI+PG1yb3c+PG1pPmM8L21pPjxtbj4xPC9tbj48L21yb3c+PC9tc3R5bGU+PC9tdGQ+PC9tdHI+PG10cj48bXRkPjxtc3R5bGUgc2NyaXB0bGV2ZWw9XCIwXCIgZGlzcGxheXN0eWxlPVwiZmFsc2VcIj48bW4+MTwvbW4+PC9tc3R5bGU+PC9tdGQ+PG10ZD48bXN0eWxlIHNjcmlwdGxldmVsPVwiMFwiIGRpc3BsYXlzdHlsZT1cImZhbHNlXCI+PG1yb3c+PG1pPmM8L21pPjxtbj4yPC9tbj48L21yb3c+PC9tc3R5bGU+PC9tdGQ+PC9tdHI+PG10cj48bXRkPjxtc3R5bGUgc2NyaXB0bGV2ZWw9XCIwXCIgZGlzcGxheXN0eWxlPVwiZmFsc2VcIj48bW4+MjwvbW4+PC9tc3R5bGU+PC9tdGQ+PG10ZD48bXN0eWxlIHNjcmlwdGxldmVsPVwiMFwiIGRpc3BsYXlzdHlsZT1cImZhbHNlXCI+PG1yb3c+PG1pPmM8L21pPjxtbj4yPC9tbj48L21yb3c+PC9tc3R5bGU+PC9tdGQ+PC9tdHI+PC9tdGFibGU+PC9tcm93PjwvbXJvdz48YW5ub3RhdGlvbiBlbmNvZGluZz1cImFwcGxpY2F0aW9uL3gtdGV4XCI+ZiA9XG4gICAgICBcXFxcYmVnaW57Y2FzZXN9XG4gICAgICAwICAgJmFtcDsgYzFcXFxcXFxcXFxuICAgICAgMSAgICZhbXA7IGMyXFxcXFxcXFxcbiAgICAgIDIgICAmYW1wOyBjMlxuICAgICAgXFxcXGVuZHtjYXNlc308L2Fubm90YXRpb24+PC9zZW1hbnRpY3M+PC9tYXRoPjwvc3Bhbj48c3BhbiBjbGFzcz1cImthdGV4LWh0bWxcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48c3BhbiBjbGFzcz1cImJhc2VcIj48c3BhbiBjbGFzcz1cInN0cnV0XCIgc3R5bGU9XCJoZWlnaHQ6IDAuODg4ODhlbTsgdmVydGljYWwtYWxpZ246IC0wLjE5NDQ0ZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwibW9yZCBtYXRoZGVmYXVsdFwiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAwLjEwNzY0ZW07XCI+Zjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1zcGFjZVwiIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAwLjI3Nzc3OGVtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1yZWxcIj49PC9zcGFuPjxzcGFuIGNsYXNzPVwibXNwYWNlXCIgc3R5bGU9XCJtYXJnaW4tcmlnaHQ6IDAuMjc3Nzc4ZW07XCI+PC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cImJhc2VcIj48c3BhbiBjbGFzcz1cInN0cnV0XCIgc3R5bGU9XCJoZWlnaHQ6IDQuMzJlbTsgdmVydGljYWwtYWxpZ246IC0xLjkxZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwibWlubmVyXCI+PHNwYW4gY2xhc3M9XCJtb3BlblwiPjxzcGFuIGNsYXNzPVwiZGVsaW1zaXppbmcgbXVsdFwiPjxzcGFuIGNsYXNzPVwidmxpc3QtdCB2bGlzdC10MlwiPjxzcGFuIGNsYXNzPVwidmxpc3QtclwiPjxzcGFuIGNsYXNzPVwidmxpc3RcIiBzdHlsZT1cImhlaWdodDogMi4zNTAwMmVtO1wiPjxzcGFuIGNsYXNzPVwiXCIgc3R5bGU9XCJ0b3A6IC0yLjE5OTk5ZW07XCI+PHNwYW4gY2xhc3M9XCJwc3RydXRcIiBzdHlsZT1cImhlaWdodDogMy4xNWVtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cImRlbGltc2l6aW5naW5uZXIgZGVsaW0tc2l6ZTRcIj48c3BhbiBjbGFzcz1cIlwiPuKOqTwvc3Bhbj48L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwiXCIgc3R5bGU9XCJ0b3A6IC0yLjE5NDk5ZW07XCI+PHNwYW4gY2xhc3M9XCJwc3RydXRcIiBzdHlsZT1cImhlaWdodDogMy4xNWVtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cImRlbGltc2l6aW5naW5uZXIgZGVsaW0tc2l6ZTRcIj48c3BhbiBjbGFzcz1cIlwiPuKOqjwvc3Bhbj48L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwiXCIgc3R5bGU9XCJ0b3A6IC0yLjIwNDk5ZW07XCI+PHNwYW4gY2xhc3M9XCJwc3RydXRcIiBzdHlsZT1cImhlaWdodDogMy4xNWVtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cImRlbGltc2l6aW5naW5uZXIgZGVsaW0tc2l6ZTRcIj48c3BhbiBjbGFzcz1cIlwiPuKOqjwvc3Bhbj48L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwiXCIgc3R5bGU9XCJ0b3A6IC0zLjE1MDAxZW07XCI+PHNwYW4gY2xhc3M9XCJwc3RydXRcIiBzdHlsZT1cImhlaWdodDogMy4xNWVtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cImRlbGltc2l6aW5naW5uZXIgZGVsaW0tc2l6ZTRcIj48c3BhbiBjbGFzcz1cIlwiPuKOqDwvc3Bhbj48L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwiXCIgc3R5bGU9XCJ0b3A6IC00LjI5NTAxZW07XCI+PHNwYW4gY2xhc3M9XCJwc3RydXRcIiBzdHlsZT1cImhlaWdodDogMy4xNWVtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cImRlbGltc2l6aW5naW5uZXIgZGVsaW0tc2l6ZTRcIj48c3BhbiBjbGFzcz1cIlwiPuKOqjwvc3Bhbj48L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwiXCIgc3R5bGU9XCJ0b3A6IC00LjMwNTAxZW07XCI+PHNwYW4gY2xhc3M9XCJwc3RydXRcIiBzdHlsZT1cImhlaWdodDogMy4xNWVtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cImRlbGltc2l6aW5naW5uZXIgZGVsaW0tc2l6ZTRcIj48c3BhbiBjbGFzcz1cIlwiPuKOqjwvc3Bhbj48L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwiXCIgc3R5bGU9XCJ0b3A6IC00LjYwMDAyZW07XCI+PHNwYW4gY2xhc3M9XCJwc3RydXRcIiBzdHlsZT1cImhlaWdodDogMy4xNWVtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cImRlbGltc2l6aW5naW5uZXIgZGVsaW0tc2l6ZTRcIj48c3BhbiBjbGFzcz1cIlwiPuKOpzwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cInZsaXN0LXNcIj7igIs8L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwidmxpc3QtclwiPjxzcGFuIGNsYXNzPVwidmxpc3RcIiBzdHlsZT1cImhlaWdodDogMS44NTAwMmVtO1wiPjxzcGFuIGNsYXNzPVwiXCI+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJtb3JkXCI+PHNwYW4gY2xhc3M9XCJtdGFibGVcIj48c3BhbiBjbGFzcz1cImNvbC1hbGlnbi1sXCI+PHNwYW4gY2xhc3M9XCJ2bGlzdC10IHZsaXN0LXQyXCI+PHNwYW4gY2xhc3M9XCJ2bGlzdC1yXCI+PHNwYW4gY2xhc3M9XCJ2bGlzdFwiIHN0eWxlPVwiaGVpZ2h0OiAyLjQxZW07XCI+PHNwYW4gY2xhc3M9XCJcIiBzdHlsZT1cInRvcDogLTQuNDFlbTtcIj48c3BhbiBjbGFzcz1cInBzdHJ1dFwiIHN0eWxlPVwiaGVpZ2h0OiAzLjAwOGVtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1vcmRcIj48c3BhbiBjbGFzcz1cIm1vcmRcIj4wPC9zcGFuPjwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJcIiBzdHlsZT1cInRvcDogLTIuOTdlbTtcIj48c3BhbiBjbGFzcz1cInBzdHJ1dFwiIHN0eWxlPVwiaGVpZ2h0OiAzLjAwOGVtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1vcmRcIj48c3BhbiBjbGFzcz1cIm1vcmRcIj4xPC9zcGFuPjwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJcIiBzdHlsZT1cInRvcDogLTEuNTNlbTtcIj48c3BhbiBjbGFzcz1cInBzdHJ1dFwiIHN0eWxlPVwiaGVpZ2h0OiAzLjAwOGVtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1vcmRcIj48c3BhbiBjbGFzcz1cIm1vcmRcIj4yPC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwidmxpc3Qtc1wiPuKAizwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJ2bGlzdC1yXCI+PHNwYW4gY2xhc3M9XCJ2bGlzdFwiIHN0eWxlPVwiaGVpZ2h0OiAxLjkxZW07XCI+PHNwYW4gY2xhc3M9XCJcIj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwiYXJyYXljb2xzZXBcIiBzdHlsZT1cIndpZHRoOiAxZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwiY29sLWFsaWduLWxcIj48c3BhbiBjbGFzcz1cInZsaXN0LXQgdmxpc3QtdDJcIj48c3BhbiBjbGFzcz1cInZsaXN0LXJcIj48c3BhbiBjbGFzcz1cInZsaXN0XCIgc3R5bGU9XCJoZWlnaHQ6IDIuNDFlbTtcIj48c3BhbiBjbGFzcz1cIlwiIHN0eWxlPVwidG9wOiAtNC40MWVtO1wiPjxzcGFuIGNsYXNzPVwicHN0cnV0XCIgc3R5bGU9XCJoZWlnaHQ6IDMuMDA4ZW07XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwibW9yZFwiPjxzcGFuIGNsYXNzPVwibW9yZCBtYXRoZGVmYXVsdFwiPmM8L3NwYW4+PHNwYW4gY2xhc3M9XCJtb3JkXCI+MTwvc3Bhbj48L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwiXCIgc3R5bGU9XCJ0b3A6IC0yLjk3ZW07XCI+PHNwYW4gY2xhc3M9XCJwc3RydXRcIiBzdHlsZT1cImhlaWdodDogMy4wMDhlbTtcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJtb3JkXCI+PHNwYW4gY2xhc3M9XCJtb3JkIG1hdGhkZWZhdWx0XCI+Yzwvc3Bhbj48c3BhbiBjbGFzcz1cIm1vcmRcIj4yPC9zcGFuPjwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJcIiBzdHlsZT1cInRvcDogLTEuNTNlbTtcIj48c3BhbiBjbGFzcz1cInBzdHJ1dFwiIHN0eWxlPVwiaGVpZ2h0OiAzLjAwOGVtO1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1vcmRcIj48c3BhbiBjbGFzcz1cIm1vcmQgbWF0aGRlZmF1bHRcIj5jPC9zcGFuPjxzcGFuIGNsYXNzPVwibW9yZFwiPjI8L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJ2bGlzdC1zXCI+4oCLPC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cInZsaXN0LXJcIj48c3BhbiBjbGFzcz1cInZsaXN0XCIgc3R5bGU9XCJoZWlnaHQ6IDEuOTFlbTtcIj48c3BhbiBjbGFzcz1cIlwiPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cIm1jbG9zZSBudWxsZGVsaW1pdGVyXCI+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+XG4gIDwvdGQ+XG48L3RyPlxuPC90cj5cbjwvdGFibGU+XG48ZGl2PmAiLCJ2YXIgZGwgPSByZXF1aXJlKCcuL2RsX3NlbGVjdCcpO1xudmFyIHRpcHB5ID0gcmVxdWlyZSgndGlwcHkuanMnKS5kZWZhdWx0O1xudmFyIHRpcHB5SW5zdGFuY2VzID0gbmV3IE1hcCgpO1xudmFyIG1vZGFsRGlhbG9ncyA9IFtdO1xuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBlID0+IHtcbiAgICBpZihtb2RhbERpYWxvZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsYXN0RGlhbG9nID0gbW9kYWxEaWFsb2dzW21vZGFsRGlhbG9ncy5sZW5ndGggLSAxXTtcblxuICAgIGlmKGUua2V5ID09PSAnRXNjYXBlJykge1xuICAgICAgICBsYXN0RGlhbG9nLmVzY0hhbmRsZXIoZSlcbiAgICB9IGVsc2UgaWYoZS5rZXkgPT09ICdFbnRlcicpIHtcbiAgICAgICAgaWYoT2JqZWN0LmtleXMobGFzdERpYWxvZy5idXR0b25zKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGxhc3REaWFsb2cuZW50ZXJIYW5kbGVyKGUpXG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuZnVuY3Rpb24gRGVjbGFyYXRpdkZvcm0oYXR0cnMsIG9uQ2hhbmdlQ2FsbGJhY2ssIG9uQ2FuY2VsQ2FsbGJhY2ssIGNvbmZpcm1CdXR0b25DYXB0aW9uKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuZmllbGRzID0gYXR0cnMuZmllbGRzXG4gICAgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQoJ2RsLWZvcm0nKVxuICAgIHRoaXMuZm9ybUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJylcbiAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZCh0aGlzLmZvcm1FbGVtZW50KVxuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IG9uQ2hhbmdlQ2FsbGJhY2tcbiAgICB0aGlzLm9uQ2FuY2VsQ2FsbGJhY2sgPSBvbkNhbmNlbENhbGxiYWNrXG4gICAgdGhpcy5idXR0b25zID0gYXR0cnMuYnV0dG9ucyB8fCB7IFtjb25maXJtQnV0dG9uQ2FwdGlvbiB8fCAnT0snXTogeyBhY3Rpb246IG9uQ2hhbmdlQ2FsbGJhY2ssIGlkOiAnY29uZmlybUJ0bi0nICsgTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpKjEwMDAwMDApIH0gIH1cbiAgICB0aGlzLmluaXRQcm9taXNlcyA9IHt9XG4gICAgdGhpcy5hbGxQcm9taXNlcyA9IFtdXG5cbiAgICBpZihPYmplY3Qua2V5cyh0aGlzLmJ1dHRvbnMpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sgPSBPYmplY3QudmFsdWVzKHRoaXMuYnV0dG9ucylbMF0uYWN0aW9uIHx8IE9iamVjdC52YWx1ZXModGhpcy5idXR0b25zKVswXVxuICAgIH1cblxuICAgIGlmKGF0dHJzLmNsYXNzTmFtZXMpIHtcbiAgICAgICAgYXR0cnMuY2xhc3NOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIHNlbGYuZm9ybUVsZW1lbnQuY2xhc3NMaXN0LmFkZChuYW1lKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIHRoaXMuZm9ybUVsZW1lbnQub25zdWJtaXQgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuZXNjSGFuZGxlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2VsZi5jYW5jZWxNb2RhbElmQ2FuY2VsYWJsZSgpXG4gICAgfVxuXG4gICAgdGhpcy5lbnRlckhhbmRsZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IHNlbGYuZmllbGRzLmZpbmQoZnVuY3Rpb24oZikgeyByZXR1cm4gZi5uYW1lID09PSBlLnRhcmdldC5uYW1lfSlcbiAgICAgICAgdmFyIGNvbmZpcm1CdG5FbElEID0gIE9iamVjdC52YWx1ZXMoc2VsZi5idXR0b25zKS5tYXAoYiA9PiBiLmlkKS5maW5kKGlkID0+ICEhaWQpXG4gICAgICAgIHZhciBjb25maXJtQnRuRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb25maXJtQnRuRWxJRClcblxuICAgICAgICBpZighZmllbGQgfHwgIWZpZWxkLmxhcmdldGV4dCkge1xuICAgICAgICAgICAgaWYoIWNvbmZpcm1CdG5FbCB8fCAhY29uZmlybUJ0bkVsLmNsYXNzTGlzdC5jb250YWlucygnZGlzYWJsZWQnKSkge1xuICAgICAgICAgICAgICAgIHNlbGYuY2xvc2VNb2RhbElmT3BlbigpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICB9IGVsc2UgaWYoIWZpZWxkLmFsbG93TmV3bGluZXMpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5maWVsZHMuZm9yRWFjaCgoZmllbGQsIGZpZWxkSW5kZXgpID0+IHtcbiAgICAgICAgdmFyIGZpZWxkV3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICAgICAgZmllbGRFbGVtZW50LCBsYWJlbCwgYWxsb3dlZFZhbHVlcyxcbiAgICAgICAgICAgIG1lc3NhZ2UsIHRvb2x0aXBcblxuICAgICAgICBhbGxvd2VkVmFsdWVzID0gKGZpZWxkLmFsbG93ZWRWYWx1ZXMgaW5zdGFuY2VvZiBGdW5jdGlvbikgP1xuICAgICAgICAgICAgZmllbGQuYWxsb3dlZFZhbHVlcygpIDpcbiAgICAgICAgICAgIGZpZWxkLmFsbG93ZWRWYWx1ZXNcblxuICAgICAgICBtZXNzYWdlID0gKGZpZWxkLm1lc3NhZ2UgaW5zdGFuY2VvZiBGdW5jdGlvbikgP1xuICAgICAgICAgICAgZmllbGQubWVzc2FnZSgpIDpcbiAgICAgICAgICAgIGZpZWxkLm1lc3NhZ2VcblxuICAgICAgICBmaWVsZFdyYXBwZXIuaWQgPSAnZGwtZm9ybS1maWVsZC13cmFwcGVyLWZvci0nICsgZmllbGQubmFtZVxuICAgICAgICBmaWVsZFdyYXBwZXIuY2xhc3NMaXN0LmFkZCgnZGwtZm9ybS1maWVsZC13cmFwcGVyJylcblxuICAgICAgICBpZihmaWVsZC50YWIpIHtcbiAgICAgICAgICAgIGZpZWxkV3JhcHBlci5jbGFzc0xpc3QuYWRkKGZpZWxkLnRhYi5yZXBsYWNlKC9cXHMvZywgJycpKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoYWxsb3dlZFZhbHVlcykge1xuICAgICAgICAgICAgZmllbGRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGwtc2VsZWN0JylcbiAgICAgICAgICAgIGZpZWxkV3JhcHBlci5jbGFzc0xpc3QuYWRkKCdkbC1zZWxlY3Qtd3JhcHBlcicpXG4gICAgICAgICAgICBmaWVsZEVsZW1lbnQuc2V0TG9hZGluZ1N0YXR1cygpXG4gICAgICAgICAgICBzZWxmLmluaXRQcm9taXNlc1tmaWVsZC5uYW1lXSA9IFByb21pc2UucmVzb2x2ZShhbGxvd2VkVmFsdWVzKS50aGVuKHZhbHVlcyA9PiB7XG4gICAgICAgICAgICAgICAgdmFsdWVzLmZvckVhY2goKHZhbCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb3B0RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkbC1vcHRpb24nKVxuICAgICAgICAgICAgICAgICAgICBpZihBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdEVsLnNldEF0dHJpYnV0ZSgndmFsdWUnLCB2YWxbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRFbC5pbm5lckhUTUwgPSB2YWxbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHZhbFsyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdEVsLnNldEF0dHJpYnV0ZSgnZGlzcGxheVdoZW5TZWxlY3RlZCcsIHZhbFsyXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdEVsLmlubmVySFRNTCA9IHZhbFxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZmllbGRFbGVtZW50Lm9uY2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi51cGRhdGVGb3JtKGZpZWxkRWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkRWxlbWVudC5hZGRPcHRpb24ob3B0RWwpXG4gICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgIGZpZWxkRWxlbWVudC51bnNldExvYWRpbmdTdGF0dXMoKVxuICAgICAgICAgICAgfSkuY2F0Y2goXyA9PiB7XG4gICAgICAgICAgICAgICAgZmllbGRFbGVtZW50LnVuc2V0TG9hZGluZ1N0YXR1cygpXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICB0aGlzLmFsbFByb21pc2VzLnB1c2goc2VsZi5pbml0UHJvbWlzZXNbZmllbGQubmFtZV0pXG4gICAgICAgIH0gZWxzZSBpZiAoZmllbGQubWVzc2FnZSkge1xuICAgICAgICAgICAgZmllbGRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpXG4gICAgICAgICAgICBmaWVsZEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnbWVzc2FnZScpXG4gICAgICAgICAgICBmaWVsZEVsZW1lbnQuaW5uZXJIVE1MID0gZmllbGQubWVzc2FnZVxuICAgICAgICB9IGVsc2UgaWYgKGZpZWxkLmFycmF5T2YpIHtcbiAgICAgICAgICAgIGZpZWxkRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICAgICAgICBmaWVsZEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnYXJyYXktb2YnKVxuICAgICAgICAgICAgZmllbGRFbGVtZW50LnNldFZhbHVlID0gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgZmllbGRFbGVtZW50LnZhbHVlID0gdmFsdWVcbiAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZUZvcm0oZmllbGRFbGVtZW50KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmaWVsZC5yZW5kZXIgPSAoZG9tLCBmb3JtRGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIGRvbS5pbm5lckhUTUwgPSAnJ1xuXG4gICAgICAgICAgICAgICAgbGV0IHJlbmRlckVudHJ5ID0gZmllbGQucmVuZGVyRW50cnkgfHwgKG9iaiA9PiBPYmplY3QudmFsdWVzKG9iaikuZmlsdGVyKHZhbCA9PiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpICYmIHZhbC50cmltKCkgIT09ICcnKS5qb2luKCcsICcpKVxuXG4gICAgICAgICAgICAgICAgaWYoZmllbGQuc3VnZ2VzdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdWdnZXN0ZWRDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgICAgICAgICAgICAgICBzdWdnZXN0ZWRDb250YWluZXIuY2xhc3NMaXN0LmFkZCgnZGwtZm9ybS1hcnJheS1zdWdnZXN0ZWQtY29udGFpbmVyJylcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN1Z2dlc3RlZEVudHJpZXMgPSB0eXBlb2YgZmllbGQuc3VnZ2VzdGVkID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkLnN1Z2dlc3RlZChmb3JtRGF0YSwgbW9kYWxEaWFsb2dzLm1hcChkID0+IGQuZ2V0VmFsdWVzKCkpKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZC5zdWdnZXN0ZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgKHN1Z2dlc3RlZEVudHJpZXMgfHwgW10pLmZvckVhY2goKHN1Z2dlc3RlZEVudHJ5LCBmaWVsZEluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja2JveEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjYiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiLmlkID0gJ2ZpZWxkLScgKyBmaWVsZEluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICBjYi5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnY2hlY2tib3gnKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2Iub25pbnB1dCA9IGNiLm9uY2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkLmRvbUVsZW1lbnQuYWNjZXB0ZWRTdWdnZXN0aW9ucyA9IGZpZWxkLmRvbUVsZW1lbnQuYWNjZXB0ZWRTdWdnZXN0aW9ucyB8fCBbXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrYm94RWwuc2V0QXR0cmlidXRlKCd2YWx1ZScsIGNiLmNoZWNrZWQpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjYi5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkLmRvbUVsZW1lbnQuYWNjZXB0ZWRTdWdnZXN0aW9ucy5wdXNoKFtzdWdnZXN0ZWRFbnRyeSwgZmllbGRJbmRleF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQuZG9tRWxlbWVudC5hY2NlcHRlZFN1Z2dlc3Rpb25zID0gZmllbGQuZG9tRWxlbWVudC5hY2NlcHRlZFN1Z2dlc3Rpb25zLmZpbHRlcih4ID0+IHhbMV0gIT09IGZpZWxkSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGFiZWxFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsRWwuc2V0QXR0cmlidXRlKCdmb3InLCAnZmllbGQtJyArIGZpZWxkSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbEVsLmlubmVySFRNTCA9IHJlbmRlckVudHJ5KHN1Z2dlc3RlZEVudHJ5KVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja2JveEVsLmNsYXNzTGlzdC5hZGQoJ2NoZWNrJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrYm94RWwuY2xhc3NMaXN0LmFkZCgnZGwtZm9ybS1hcnJheS1vZi1zdWdnZXN0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrYm94RWwuYXBwZW5kQ2hpbGQoY2IpXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja2JveEVsLmFwcGVuZENoaWxkKGxhYmVsRWwpXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja2JveEVsLnNldEF0dHJpYnV0ZSgndmFsdWUnLCBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrYm94RWwuanNvblZhbHVlID0gc3VnZ2VzdGVkRW50cnlcblxuICAgICAgICAgICAgICAgICAgICAgICAgc3VnZ2VzdGVkQ29udGFpbmVyLmFwcGVuZENoaWxkKGNoZWNrYm94RWwpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGVja2JveEVsXG4gICAgICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICAgICAgZG9tLmFwcGVuZENoaWxkKHN1Z2dlc3RlZENvbnRhaW5lcilcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBnZXRDb25maXJtQnV0dG9uID0gYWN0aW9uID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICdPSyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnYWRkSW50ZWdyYXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBY3RpdmU6IGZvcm1EYXRhID0+IGZpZWxkLmlzVmFsaWRSZWNvcmQgPyBmaWVsZC5pc1ZhbGlkUmVjb3JkKGZvcm1EYXRhLCBzZWxmKSA6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgZG9tLnZhbHVlICYmIGRvbS52YWx1ZS5mb3JFYWNoICYmIGRvbS52YWx1ZS5mb3JFYWNoKChlbnRyeU9iaiwgZWxJbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZW50cnlFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICAgICAgICAgICAgICAgIGxldCBkZWxldGVFbEJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpXG4gICAgICAgICAgICAgICAgICAgIGxldCBlZGl0RWxCdG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKVxuICAgICAgICAgICAgICAgICAgICBkZWxldGVFbEJ0bi5pbm5lckhUTUwgPSAnUmVtb3ZlJ1xuICAgICAgICAgICAgICAgICAgICBlZGl0RWxCdG4uaW5uZXJIVE1MID0gJ0VkaXQnXG4gICAgICAgICAgICAgICAgICAgIGVudHJ5RWwuaW5uZXJIVE1MID0gJzxzcGFuPicgKyByZW5kZXJFbnRyeShlbnRyeU9iaikgKyAnPC9zcGFuPidcbiAgICAgICAgICAgICAgICAgICAgZW50cnlFbC5kYXRhc2V0LkVsSW5kZXggPSBlbEluZGV4XG4gICAgICAgICAgICAgICAgICAgIGVudHJ5RWwuY2xhc3NMaXN0LmFkZCgnZGwtZm9ybS1hcnJheS1vZi1lbnRyeScpXG5cbiAgICAgICAgICAgICAgICAgICAgZW50cnlFbC5hcHBlbmRDaGlsZChlZGl0RWxCdG4pXG4gICAgICAgICAgICAgICAgICAgIGVudHJ5RWwuYXBwZW5kQ2hpbGQoZGVsZXRlRWxCdG4pXG5cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlRWxCdG4uY2xhc3NMaXN0LmFkZCgnZGVsZXRlLWFycmF5LW9mLWJ0bicpXG5cbiAgICAgICAgICAgICAgICAgICAgZWRpdEVsQnRuLmNsYXNzTGlzdC5hZGQoJ2VkaXQtYXJyYXktb2YtYnRuJylcbiAgICAgICAgICAgICAgICAgICAgZWRpdEVsQnRuLmRhdGFzZXQuRWxJbmRleCA9IGVsSW5kZXhcbiAgICAgICAgICAgICAgICAgICAgZWRpdEVsQnRuLm9uY2xpY2sgPSBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZWRpdEZpZWRzID0gZmllbGQuYXJyYXlPZi5tYXAoZmllbGQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmZpZWxkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IGRvbS52YWx1ZVtkZWxldGVFbEJ0bi5kYXRhc2V0LkVsSW5kZXhdW2ZpZWxkLm5hbWVdIHx8ICcnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBEZWNsYXJhdGl2Rm9ybSh7IGNsYXNzTmFtZXM6IFtgZm9ybS1mb3ItYXJyYXktb2YtJHtmaWVsZC5uYW1lfWBdLCBmaWVsZHM6IGVkaXRGaWVkcywgYnV0dG9uczogZ2V0Q29uZmlybUJ1dHRvbihmb3JtRGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tLnZhbHVlID0gZG9tLnZhbHVlIHx8IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tLnZhbHVlW2RlbGV0ZUVsQnRuLmRhdGFzZXQuRWxJbmRleF0gPSBmb3JtRGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbS5zZXRWYWx1ZShkb20udmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZmllbGQub25DaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5hbGxTZXR0bGVkKHRoaXMuYWxsUHJvbWlzZXMpLnRoZW4oKCkgPT4gZmllbGQub25DaGFuZ2UodGhpcy5nZXRWYWx1ZXMoKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkgfSwgKCkgPT4ge30sICgpID0+IHt9KS5vcGVuSW5Nb2RhbCgpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBkZWxldGVFbEJ0bi5kYXRhc2V0LkVsSW5kZXggPSBlbEluZGV4XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZUVsQnRuLm9uY2xpY2sgPSBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbS52YWx1ZS5zcGxpY2UoZGVsZXRlRWxCdG4uZGF0YXNldC5FbEluZGV4LCAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tLnNldFZhbHVlKGRvbS52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZmllbGQub25DaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLmFsbFNldHRsZWQodGhpcy5hbGxQcm9taXNlcykudGhlbigoKSA9PiBmaWVsZC5vbkNoYW5nZSh0aGlzLmdldFZhbHVlcygpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGRvbS5hcHBlbmRDaGlsZChlbnRyeUVsKVxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICBsZXQgYWRkQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJylcbiAgICAgICAgICAgICAgICBhZGRCdXR0b24uY2xhc3NMaXN0LmFkZCgnZGwtZm9ybS1hcnJheS1vZi1hZGQtZW50cnknKVxuICAgICAgICAgICAgICAgIGFkZEJ1dHRvbi5pbm5lckhUTUwgPSBmaWVsZC5uZXdCdXR0b25MYWJlbCB8fCAnQWRkJ1xuXG4gICAgICAgICAgICAgICAgYWRkQnV0dG9uLm9uY2xpY2sgPSBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbmV3IERlY2xhcmF0aXZGb3JtKHsgY2xhc3NOYW1lczogW2Bmb3JtLWZvci1hcnJheS1vZi0ke2ZpZWxkLm5hbWV9YF0sIGZpZWxkczogZmllbGQuYXJyYXlPZiwgYnV0dG9uczogZ2V0Q29uZmlybUJ1dHRvbihmb3JtRGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb20udmFsdWUgPSBkb20udmFsdWUgfHwgW11cbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbS52YWx1ZS5wdXNoKGZvcm1EYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tLnNldFZhbHVlKGRvbS52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGZpZWxkLm9uQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwodGhpcy5hbGxQcm9taXNlcykudGhlbigoKSA9PiBmaWVsZC5vbkNoYW5nZSh0aGlzLmdldFZhbHVlcygpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSl9LCAoKSA9PiB7fSwgKCkgPT4ge30pLm9wZW5Jbk1vZGFsKClcblxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkb20uYXBwZW5kQ2hpbGQoYWRkQnV0dG9uKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmaWVsZC5yZW5kZXIoZmllbGRFbGVtZW50LCBzZWxmLmZvcm1EYXRhLCBzZWxmKVxuICAgICAgICB9IGVsc2UgaWYgKGZpZWxkLnJlbmRlcikge1xuICAgICAgICAgICAgZmllbGRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpXG4gICAgICAgICAgICBmaWVsZEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgncmVuZGVyJylcblxuICAgICAgICAgICAgZmllbGRFbGVtZW50Lm9uQ2hhbmdlID0gZnVuY3Rpb24gKGZvcmNlRm9ybVVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlRm9ybShmaWVsZEVsZW1lbnQsIGZvcmNlRm9ybVVwZGF0ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZpZWxkLnJlbmRlcihmaWVsZEVsZW1lbnQsIHNlbGYuZm9ybURhdGEsIHNlbGYpXG4gICAgICAgIH0gZWxzZSBpZiAoZmllbGQubGFyZ2V0ZXh0KSB7XG4gICAgICAgICAgICBmaWVsZEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpXG4gICAgICAgICAgICBmaWVsZEVsZW1lbnQub25pbnB1dCA9IGZpZWxkRWxlbWVudC5vbmNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlRm9ybShmaWVsZEVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGZpZWxkLmNoZWNrKSB7XG4gICAgICAgICAgICBmaWVsZEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJylcblxuICAgICAgICAgICAgbGV0IGNiID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKVxuICAgICAgICAgICAgY2IuaWQgPSAnZmllbGQtJyArIGZpZWxkSW5kZXhcbiAgICAgICAgICAgIGNiLnNldEF0dHJpYnV0ZSgndHlwZScsICdjaGVja2JveCcpXG4gICAgICAgICAgICBjYi5vbmlucHV0ID0gY2Iub25jaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmaWVsZEVsZW1lbnQuc2V0QXR0cmlidXRlKCd2YWx1ZScsIGNiLmNoZWNrZWQpXG4gICAgICAgICAgICAgICAgc2VsZi51cGRhdGVGb3JtKGNiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGxhYmVsRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpXG4gICAgICAgICAgICBsYWJlbEVsLnNldEF0dHJpYnV0ZSgnZm9yJywgJ2ZpZWxkLScgKyBmaWVsZEluZGV4KVxuICAgICAgICAgICAgbGFiZWxFbC5pbm5lckhUTUwgPSBmaWVsZC5jaGVja1xuXG4gICAgICAgICAgICBmaWVsZEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnY2hlY2snKVxuICAgICAgICAgICAgZmllbGRFbGVtZW50LmFwcGVuZENoaWxkKGNiKVxuICAgICAgICAgICAgZmllbGRFbGVtZW50LmFwcGVuZENoaWxkKGxhYmVsRWwpXG4gICAgICAgICAgICBmaWVsZEVsZW1lbnQuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHR5cGVvZiBmaWVsZC5kZWZhdWx0VmFsdWUgPT09ICdmdW5jdGlvbicgPyBmaWVsZC5kZWZhdWx0VmFsdWUoc2VsZi5mb3JtRGF0YSkgOiBmaWVsZC5kZWZhdWx0VmFsdWUpXG4gICAgICAgICAgICBmaWVsZEVsZW1lbnQuc2V0VmFsdWUgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICBjYi5jaGVja2VkID0gISF2YWxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChmaWVsZC5kZXRhaWxlZE9wdGlvbnMpIHtcbiAgICAgICAgICAgIGZpZWxkRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICAgICAgICBmaWVsZEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnZGV0YWlsZWQtb3B0aW9ucycpXG5cbiAgICAgICAgICAgIGZpZWxkLmRldGFpbGVkT3B0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKG9wdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb25FbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgIG9wdGlvbkVsLmNsYXNzTGlzdC5hZGQoJ2RldGFpbGVkLW9wdGlvbicpO1xuXG4gICAgICAgICAgICAgICAgb3B0aW9uRWwuaW5uZXJIVE1MID0gb3B0aW9uLmh0bWw7XG4gICAgICAgICAgICAgICAgb3B0aW9uRWwuc2V0QXR0cmlidXRlKCdkYXRhLXZhbHVlJywgb3B0aW9uLnZhbHVlKTtcblxuICAgICAgICAgICAgICAgIG9wdGlvbkVsLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRFbGVtZW50LnZhbHVlID0gb3B0aW9uLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBmaWVsZEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmRldGFpbGVkLW9wdGlvbicpLmZvckVhY2goZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb24uY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbkVsLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZUZvcm0ob3B0aW9uRWwpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZmllbGRFbGVtZW50LmFwcGVuZENoaWxkKG9wdGlvbkVsKVxuICAgICAgICAgICAgICAgIGZpZWxkRWxlbWVudC5zZXRWYWx1ZSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSBmaWVsZEVsZW1lbnQucXVlcnlTZWxlY3RvcihgZGl2W2RhdGEtdmFsdWU9XCIke3ZhbH1cIl1gKTtcblxuICAgICAgICAgICAgICAgICAgICBpZighZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkRWxlbWVudC52YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5kZXRhaWxlZC1vcHRpb24nKS5mb3JFYWNoKGZ1bmN0aW9uKG9wdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWVsZC5jYWxjdWxhdGUpIHtcbiAgICAgICAgICAgIGZpZWxkRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JylcbiAgICAgICAgICAgIGZpZWxkRWxlbWVudC50eXBlID0gJ2hpZGRlbidcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpZWxkRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JylcbiAgICAgICAgICAgIGZpZWxkRWxlbWVudC5zZXRWYWx1ZSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgIGZpZWxkRWxlbWVudC52YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoZmllbGQuaW5wdXRUeXBlKSB7XG4gICAgICAgICAgICAgICAgZmllbGRFbGVtZW50LnNldEF0dHJpYnV0ZSgndHlwZScsIGZpZWxkLmlucHV0VHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGZpZWxkLmF1dG9jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIGZpZWxkRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2F1dG9jb21wbGV0ZScsIGZpZWxkLmF1dG9jb21wbGV0ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGZpZWxkLnBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgZmllbGRFbGVtZW50LnBsYWNlaG9sZGVyID0gZmllbGQucGxhY2Vob2xkZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZpZWxkRWxlbWVudC5vbmlucHV0ID0gZmllbGRFbGVtZW50Lm9uY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi51cGRhdGVGb3JtKGZpZWxkRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmaWVsZC5kb21FbGVtZW50ID0gZmllbGRFbGVtZW50XG4gICAgICAgIGZpZWxkRWxlbWVudC5uYW1lID0gZmllbGQubmFtZVxuICAgICAgICBmaWVsZEVsZW1lbnQuc2V0QXR0cmlidXRlKCduYW1lJywgZmllbGQubmFtZSlcblxuICAgICAgICBpZihmaWVsZC5kaXNwbGF5TmFtZSkge1xuICAgICAgICAgICAgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpXG4gICAgICAgICAgICBsYWJlbC5pbm5lckhUTUwgPSBmaWVsZC5kaXNwbGF5TmFtZVxuICAgICAgICAgICAgbGFiZWwuc2V0QXR0cmlidXRlKCdmb3InLCBmaWVsZC5uYW1lKVxuICAgICAgICAgICAgZmllbGRXcmFwcGVyLmFwcGVuZENoaWxkKGxhYmVsKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmllbGRXcmFwcGVyLmNsYXNzTGlzdC5hZGQoJ3dpdGhvdXRMYWJlbCcpXG4gICAgICAgIH1cblxuICAgICAgICBpZihmaWVsZC50b29sdGlwKSB7XG4gICAgICAgICAgICB0b29sdGlwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpXG4gICAgICAgICAgICB0b29sdGlwLmRhdGFzZXRbJ3RpcHB5Q29udGVudCddID0gZmllbGQudG9vbHRpcC50ZXh0IHx8IGZpZWxkLnRvb2x0aXBcbiAgICAgICAgICAgIHRvb2x0aXAuZGF0YXNldFsnaW5pdGlhbFRpcHB5Q29udGVudCddID0gZmllbGQudG9vbHRpcC50ZXh0IHx8IGZpZWxkLnRvb2x0aXBcbiAgICAgICAgICAgIHRvb2x0aXAuY2xhc3NMaXN0LmFkZCgnZGwtdG9vbHRpcCcpXG4gICAgICAgICAgICB0b29sdGlwLmlubmVySFRNTCA9ICc/J1xuXG4gICAgICAgICAgICBpZihsYWJlbCAmJiAhZmllbGQudG9vbHRpcC5pbklucHV0KSB7XG4gICAgICAgICAgICAgICAgbGFiZWwuYXBwZW5kQ2hpbGQodG9vbHRpcClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcC5jbGFzc0xpc3QuYWRkKCdkbC10b29sdGlwLWluLWlucHV0JylcbiAgICAgICAgICAgICAgICBmaWVsZEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnZGwtdG9vbHRpcC1pbnNpZGUnKVxuICAgICAgICAgICAgICAgIGZpZWxkV3JhcHBlci5hcHBlbmRDaGlsZCh0b29sdGlwKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoZmllbGRFbGVtZW50LnR5cGUgPT09ICdoaWRkZW4nKSB7XG4gICAgICAgICAgICBmaWVsZFdyYXBwZXIuY2xhc3NMaXN0LmFkZCgnZGwtZm9ybS1oaWRkZW4tZmllbGQnKVxuICAgICAgICB9XG5cbiAgICAgICAgZmllbGRXcmFwcGVyLmFwcGVuZENoaWxkKGZpZWxkRWxlbWVudClcbiAgICAgICAgc2VsZi5kb20uY2hpbGRyZW5bMF0uYXBwZW5kQ2hpbGQoZmllbGRXcmFwcGVyKVxuXG4gICAgICAgIGlmKGZpZWxkLmRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5hbGxQcm9taXNlcy5wdXNoKFByb21pc2UucmVzb2x2ZShzZWxmLmluaXRQcm9taXNlc1tmaWVsZC5uYW1lXSkudGhlbihfID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgdG1wRGVmYXVsdFZhbHVlID0gdHlwZW9mIGZpZWxkLmRlZmF1bHRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IGZpZWxkLmRlZmF1bHRWYWx1ZShzZWxmLmZvcm1EYXRhKSA6IGZpZWxkLmRlZmF1bHRWYWx1ZVxuXG4gICAgICAgICAgICAgICAgaWYoZmllbGRFbGVtZW50LnNldFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkRWxlbWVudC5zZXRWYWx1ZSh0bXBEZWZhdWx0VmFsdWUpXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmaWVsZEVsZW1lbnQudGFnTmFtZSA9PT0gJ0lOUFVUJyB8fCBmaWVsZEVsZW1lbnQudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJykge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZEVsZW1lbnQudmFsdWUgPSB0bXBEZWZhdWx0VmFsdWVcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZEVsZW1lbnQuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHRtcERlZmF1bHRWYWx1ZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICBQcm9taXNlLmFsbFNldHRsZWQodGhpcy5hbGxQcm9taXNlcykudGhlbihfID0+IHNlbGYudXBkYXRlRm9ybSgpKVxufVxuXG5EZWNsYXJhdGl2Rm9ybS5wcm90b3R5cGUgPSB7XG5cbiAgICB1cGRhdGVGb3JtOiBmdW5jdGlvbih0cmlnZ2VyRWxlbWVudCwgZm9yY2VGb3JtVXBkYXRlKSB7XG4gICAgICAgIHZhciBmb3JtRGF0YSA9IHRoaXMuZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpc1xuICAgICAgICB2YXIgdHJpZ2dlckZpZWxkTmFtZSA9IHRyaWdnZXJFbGVtZW50ICYmIHRyaWdnZXJFbGVtZW50Lm5hbWVcblxuICAgICAgICBpZih0aGlzLl9sYXN0RnJvbVVwZGF0U2F0ZSA9PT0gSlNPTi5zdHJpbmdpZnkoZm9ybURhdGEpICYmICFmb3JjZUZvcm1VcGRhdGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xhc3RGcm9tVXBkYXRTYXRlID0gSlNPTi5zdHJpbmdpZnkoZm9ybURhdGEpXG5cbiAgICAgICAgdGhpcy5maWVsZHMuZm9yRWFjaChmaWVsZCA9PiB7XG4gICAgICAgICAgICB2YXIgc2hvdWxkUmVsb2FkID0gKCF0cmlnZ2VyRmllbGROYW1lIHx8IChmaWVsZC5yZWxvYWRPbkNoYW5nZU9mICYmIGZpZWxkLnJlbG9hZE9uQ2hhbmdlT2YuaW5jbHVkZXModHJpZ2dlckZpZWxkTmFtZSkpKVxuXG4gICAgICAgICAgICBpZighZmllbGQuZG9tRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoZmllbGQuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBsZXQgdG1wSXNBY3RpdmUgPSBmaWVsZC5pc0FjdGl2ZShmb3JtRGF0YSwgbW9kYWxEaWFsb2dzLm1hcChkID0+IGQuZ2V0VmFsdWVzKCkpKVxuICAgICAgICAgICAgICAgIGlmKHRtcElzQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkLmRvbUVsZW1lbnQucGFyZW50RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdpbmFjdGl2ZScpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQuZG9tRWxlbWVudC5wYXJlbnRFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2luYWN0aXZlJylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGZpZWxkLm9uRm9ybUNoYW5nZSkge1xuICAgICAgICAgICAgICAgIGZpZWxkLm9uRm9ybUNoYW5nZShmb3JtRGF0YSwgc2VsZiwgdHJpZ2dlckVsZW1lbnQpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGZpZWxkLnJlbmRlcikge1xuICAgICAgICAgICAgICAgIGZpZWxkLnJlbmRlcihmaWVsZC5kb21FbGVtZW50LCBmb3JtRGF0YSwgc2VsZilcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoZmllbGQuYWxsb3dlZFZhbHVlcyBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIHNob3VsZFJlbG9hZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFsbG93ZWRWYWx1ZXMgPSBmaWVsZC5hbGxvd2VkVmFsdWVzKGZvcm1EYXRhKVxuICAgICAgICAgICAgICAgIGZpZWxkLmRvbUVsZW1lbnQuc2V0TG9hZGluZ1N0YXR1cygpXG4gICAgICAgICAgICAgICAgdGhpcy5hbGxQcm9taXNlcy5wdXNoKGFsbG93ZWRWYWx1ZXMpXG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoYWxsb3dlZFZhbHVlcykudGhlbih2YWx1ZXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0VG9vbHRpcChmaWVsZC5uYW1lKVxuICAgICAgICAgICAgICAgICAgICBmaWVsZC5kb21FbGVtZW50LnJlbW92ZUFsbE9wdGlvbnMoKVxuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcyAmJiB2YWx1ZXMuZm9yRWFjaCgodmFsKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgb3B0RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkbC1vcHRpb24nKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0RWwuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHZhbFswXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRFbC5pbm5lckhUTUwgPSB2YWxbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih2YWxbMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0RWwuc2V0QXR0cmlidXRlKCdkaXNwbGF5V2hlblNlbGVjdGVkJywgdmFsWzJdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0RWwuaW5uZXJIVE1MID0gdmFsXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkLmRvbUVsZW1lbnQub25jaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZUZvcm0oZmllbGQuZG9tRWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQuZG9tRWxlbWVudC5hZGRPcHRpb24ob3B0RWwpXG4gICAgICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICAgICAgZmllbGQuZG9tRWxlbWVudC51bnNldExvYWRpbmdTdGF0dXMoKVxuICAgICAgICAgICAgICAgICAgICBmaWVsZC5kb21FbGVtZW50LnNldFZhbHVlKGZpZWxkLmRvbUVsZW1lbnQuZ2V0VmFsdWUoKSlcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZC5kb21FbGVtZW50LnVuc2V0TG9hZGluZ1N0YXR1cygpXG4gICAgICAgICAgICAgICAgICAgIGlmKGZpZWxkLm9uVmFsdWVzQ2FsY3VsYXRpb25GYWlsZWRNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gZmllbGQub25WYWx1ZXNDYWxjdWxhdGlvbkZhaWxlZE1lc3NhZ2UoZm9ybURhdGEsIGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihtZXNzYWdlLmxldmVsID09PSAnaW5mbycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFRvb2x0aXBXYXJuaW5nKGZpZWxkLm5hbWUsIG1lc3NhZ2UudGV4dClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihtZXNzYWdlLmxldmVsID09PSAnd2FybmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFRvb2x0aXBXYXJuaW5nKGZpZWxkLm5hbWUsIG1lc3NhZ2UudGV4dClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihtZXNzYWdlLmxldmVsID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRUb29sdGlwRXJyb3IoZmllbGQubmFtZSwgbWVzc2FnZS50ZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgUHJvbWlzZS5hbGxTZXR0bGVkKHRoaXMuYWxsUHJvbWlzZXMpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgZm9ybURhdGEgPSB0aGlzLmdldFZhbHVlcygpO1xuXG4gICAgICAgICAgICBPYmplY3QudmFsdWVzKHRoaXMuYnV0dG9ucylcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGJ0biA9PiAoYnRuLmlzQWN0aXZlICYmIGJ0bi5pZCkpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goYnRuID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJ1dHRvbkVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYnRuLmlkKVxuICAgICAgICAgICAgICAgICAgICBpZighYnV0dG9uRWwpIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICBidXR0b25FbC5jbGFzc0xpc3QuYWRkKCdkaXNhYmxlZCcpXG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzQWN0aXZlQ2hlY2tQcm1pc2UgPSBidG4uaXNBY3RpdmUoZm9ybURhdGEpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWxsUHJvbWlzZXMucHVzaChpc0FjdGl2ZUNoZWNrUHJtaXNlKVxuXG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShpc0FjdGl2ZUNoZWNrUHJtaXNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oQnRuSXNBY3RpdmUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKEJ0bklzQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkVsLmNsYXNzTGlzdC5yZW1vdmUoJ2Rpc2FibGVkJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25FbC5jbGFzc0xpc3QuYWRkKCdkaXNhYmxlZCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICB9LFxuXG4gICAgdXBkYXRlQ2FsY3VsYXRlZEZpZWxkcyh0cmlnZ2VyRmllbGROYW1lLCBmb3JtRGF0YSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGxTZXR0bGVkKHRoaXMuZmllbGRzLm1hcChmaWVsZCA9PiBuZXcgUHJvbWlzZShkb25lID0+IHtcbiAgICAgICAgICAgIHZhciBzaG91bGRSZWxvYWQgPSAoIXRyaWdnZXJGaWVsZE5hbWUgfHwgKGZpZWxkLnJlbG9hZE9uQ2hhbmdlT2YgJiYgZmllbGQucmVsb2FkT25DaGFuZ2VPZi5pbmNsdWRlcyh0cmlnZ2VyRmllbGROYW1lKSkpXG5cbiAgICAgICAgICAgIGlmKGZpZWxkLmNhbGN1bGF0ZSAmJiBzaG91bGRSZWxvYWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGxTZXR0bGVkKHRoaXMuYWxsUHJvbWlzZXMpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aGlzVXBkYXRlUHJvbWlzZSA9IGZpZWxkLmNhbGN1bGF0ZShmb3JtRGF0YSB8fCB0aGlzLmdldFZhbHVlcygpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFsbFByb21pc2VzLnB1c2godGhpc1VwZGF0ZVByb21pc2UpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpc1VwZGF0ZVByb21pc2UpLnRoZW4odiA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZC5kb21FbGVtZW50Ll92YWx1ZSA9IHZcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvbmUoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSkpXG4gICAgfSxcblxuICAgIGdldEhUTUw6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb20ub3V0ZXJIVE1MO1xuICAgIH0sXG5cbiAgICBvcGVuSW5Nb2RhbDogZnVuY3Rpb24oYXR0cikge1xuICAgICAgICBtb2RhbERpYWxvZ3MucHVzaCh0aGlzKTtcblxuICAgICAgICB0aGlzLm1vZGFsRWwgPSB0aGlzLm1vZGFsRWwgfHwgdGhpcy5jcmVhdGVNb2RhbEVsZW1lbnQoYXR0cilcblxuICAgICAgICB2YXIgbW9kYWxDb250ZW50ID0gdGhpcy5tb2RhbEVsLnF1ZXJ5U2VsZWN0b3IoJy5tb2RhbC1jb250ZW50JylcbiAgICAgICAgdmFyIG1vZGFsV2luZG93ID0gdGhpcy5tb2RhbEVsLnF1ZXJ5U2VsZWN0b3IoJy5tb2RhbCcpXG5cbiAgICAgICAgdGhpcy51cGRhdGVUYWJzKClcbiAgICAgICAgbW9kYWxDb250ZW50LmFwcGVuZENoaWxkKHRoaXMuZG9tKVxuICAgICAgICB0aGlzLm1vZGFsRWwuc3R5bGUuZGlzcGxheSA9ICdibG9jaydcblxuICAgICAgICBpZihhdHRyICYmIGF0dHIuY2xhc3NOYW1lcykge1xuICAgICAgICAgICAgYXR0ci5jbGFzc05hbWVzLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgIG1vZGFsV2luZG93LmNsYXNzTGlzdC5hZGQobmFtZSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZVRvb2x0aXBzKCk7XG5cbiAgICAgICAgaWYobW9kYWxEaWFsb2dzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICBtb2RhbERpYWxvZ3NbbW9kYWxEaWFsb2dzLmxlbmd0aC0yXS5oaWRlKClcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBhcHBlbmRJbkVsZW1lbnQ6IGZ1bmN0aW9uKGVsLCBhdHRyKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpc1xuICAgICAgICB0aGlzLm1vZGFsRWwgPSB0aGlzLm1vZGFsRWwgfHwgdGhpcy5jcmVhdGVNb2RhbEVsZW1lbnQoYXR0ciwgdHJ1ZSlcbiAgICAgICAgdGhpcy5tb2RhbEVsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snXG5cbiAgICAgICAgdmFyIG1vZGFsQ29udGVudCA9IHRoaXMubW9kYWxFbC5xdWVyeVNlbGVjdG9yKCcubW9kYWwtY29udGVudCcpXG5cbiAgICAgICAgdGhpcy5tb2RhbEVsLmNsYXNzTGlzdC5hZGQoJ25vTW9kYWxEaWFsb2cnKVxuXG4gICAgICAgIGlmKGF0dHIgJiYgYXR0ci5jbGFzc05hbWVzKSB7XG4gICAgICAgICAgICBhdHRyLmNsYXNzTmFtZXMuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5tb2RhbEVsLmNsYXNzTGlzdC5hZGQobmFtZSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBtb2RhbENvbnRlbnQuYXBwZW5kQ2hpbGQodGhpcy5kb20pXG4gICAgICAgIGVsLmFwcGVuZENoaWxkKHRoaXMubW9kYWxFbClcbiAgICAgICAgdGhpcy51cGRhdGVUYWJzKClcblxuICAgICAgICB0aGlzLnVwZGF0ZVRvb2x0aXBzKClcbiAgICB9LFxuXG4gICAgaGlkZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubW9kYWxFbCAmJiB0aGlzLm1vZGFsRWwuY2xhc3NMaXN0LmFkZCgnZGwtbW9kYWwtaGlkZGVuJylcbiAgICB9LFxuXG4gICAgc2hvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubW9kYWxFbCAmJiB0aGlzLm1vZGFsRWwuY2xhc3NMaXN0LnJlbW92ZSgnZGwtbW9kYWwtaGlkZGVuJylcbiAgICB9LFxuXG4gICAgdXBkYXRlVG9vbHRpcHM6IGZ1bmN0aW9uKHNlbCkge1xuICAgICAgICBzZWwgPSBzZWwgfHwgJ1tkYXRhLXRpcHB5LWNvbnRlbnRdJztcblxuICAgICAgICB2YXIgZG9tRWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbCk7XG5cbiAgICAgICAgZG9tRWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICBpZih0aXBweUluc3RhbmNlcy5nZXQoZWwpKSB7XG4gICAgICAgICAgICAgICAgdGlwcHlJbnN0YW5jZXMuZ2V0KGVsKS5mb3JFYWNoKGVsID0+IGVsLmRlc3Ryb3koKSk7XG4gICAgICAgICAgICAgICAgdGlwcHlJbnN0YW5jZXMuZGVsZXRlKGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICB2YXIgdGlwcGllcyA9IHRpcHB5KHNlbCwge1xuICAgICAgICAgICAgcGxhY2VtZW50OiAncmlnaHQnLFxuICAgICAgICAgICAgYWxsb3dIVE1MOiB0cnVlLFxuICAgICAgICAgICAgaW50ZXJhY3RpdmU6IHRydWVcbiAgICAgICAgfSlcblxuICAgICAgICB0aXBwaWVzLmZvckVhY2godGlwcHkgPT4ge1xuICAgICAgICAgICAgaWYodGlwcHlJbnN0YW5jZXMuZ2V0KHRpcHB5LnJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgICAgICB0aXBweUluc3RhbmNlcy5nZXQodGlwcHkucmVmZXJlbmNlKS5wdXNoKHRpcHB5KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aXBweUluc3RhbmNlcy5zZXQodGlwcHkucmVmZXJlbmNlLCBbdGlwcHldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHNldFRvb2x0aXA6IGZ1bmN0aW9uKGZpZWxkTmFtZSwgdGV4dCwgaWNvbkNvbnRlbnQsIGNsYXNzTmFtZSkge1xuICAgICAgICBjbGFzc05hbWUgPSBjbGFzc05hbWUgfHwgJyc7XG4gICAgICAgIHZhciB0b29sdGlwU2VsZWN0b3IgPSBgI2RsLWZvcm0tZmllbGQtd3JhcHBlci1mb3ItJHtmaWVsZE5hbWV9IC5kbC10b29sdGlwYDtcbiAgICAgICAgdmFyIHRvb2x0aXBFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodG9vbHRpcFNlbGVjdG9yKTtcblxuICAgICAgICBpZih0b29sdGlwRWwuY2xhc3NMaXN0LnZhbHVlLmluY2x1ZGVzKCdkbC10b29sdGlwLWluLWlucHV0JykpIHtcbiAgICAgICAgICAgIHRvb2x0aXBFbC5jbGFzc0xpc3QudmFsdWUgPSBgZGwtdG9vbHRpcCBkbC10b29sdGlwLWluLWlucHV0ICR7Y2xhc3NOYW1lfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b29sdGlwRWwuY2xhc3NMaXN0LnZhbHVlID0gYGRsLXRvb2x0aXAgJHtjbGFzc05hbWV9YDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRvb2x0aXBFbC5kYXRhc2V0Wyd0aXBweUNvbnRlbnQnXSA9IHRleHQ7XG4gICAgICAgIHRvb2x0aXBFbC5pbm5lckhUTUwgPSBpY29uQ29udGVudDtcblxuICAgICAgICB0aGlzLnVwZGF0ZVRvb2x0aXBzKHRvb2x0aXBTZWxlY3Rvcik7XG4gICAgfSxcblxuICAgIHNldFRvb2x0aXBTdWNjZXNzOiBmdW5jdGlvbihmaWVsZE5hbWUsIHRleHQpIHtcbiAgICAgICAgdGhpcy5zZXRUb29sdGlwKGZpZWxkTmFtZSwgdGV4dCwgJyYjMTAwMDM7JywgJ3Rvb2x0aXAtc3VjY2VzcycpXG4gICAgfSxcblxuICAgIHNldFRvb2x0aXBXYXJuaW5nOiBmdW5jdGlvbihmaWVsZE5hbWUsIHRleHQpIHtcbiAgICAgICAgdGhpcy5zZXRUb29sdGlwKGZpZWxkTmFtZSwgdGV4dCwgJyEnLCAndG9vbHRpcC13YXJuaW5nJyk7XG4gICAgfSxcblxuICAgIHNldFRvb2x0aXBFcnJvcjogZnVuY3Rpb24oZmllbGROYW1lLCB0ZXh0KSB7XG4gICAgICAgIHRoaXMuc2V0VG9vbHRpcChmaWVsZE5hbWUsIHRleHQsICchJywgJ3Rvb2x0aXAtZXJyb3InKTtcbiAgICB9LFxuXG4gICAgcmVzZXRUb29sdGlwOiBmdW5jdGlvbihmaWVsZE5hbWUpIHtcbiAgICAgICAgdmFyIHRvb2x0aXBFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYCNkbC1mb3JtLWZpZWxkLXdyYXBwZXItZm9yLSR7ZmllbGROYW1lfSAuZGwtdG9vbHRpcGApO1xuXG4gICAgICAgIGlmKHRvb2x0aXBFbCkge1xuICAgICAgICAgICAgdGhpcy5zZXRUb29sdGlwKGZpZWxkTmFtZSwgdG9vbHRpcEVsLmRhdGFzZXRbJ2luaXRpYWxUaXBweUNvbnRlbnQnXSwgJz8nLCAnJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVzZXRUb29sdGlwczogZnVuY3Rpb24oZmllbGROYW1lcykge1xuICAgICAgICBmaWVsZE5hbWVzLmZvckVhY2goZmllbGROYW1lID0+IHRoaXMucmVzZXRUb29sdGlwKGZpZWxkTmFtZSkpXG4gICAgfSxcblxuICAgIHVwZGF0ZVRhYnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdGFic1dyYXBwZXIgPSB0aGlzLm1vZGFsRWwucXVlcnlTZWxlY3RvcignLnRhYldyYXBwZXInKSxcbiAgICAgICAgICAgIHRhYnMgPSB0aGlzLmZpZWxkcy5maWx0ZXIoZiA9PiBmLnRhYikubWFwKGYgPT4gZi50YWIpLmZpbHRlcigodmFsdWUsIGluZGV4LCBzZWxmKSA9PiBzZWxmLmluZGV4T2YodmFsdWUpID09PSBpbmRleCksXG4gICAgICAgICAgICBzZWxmID0gdGhpcywgdG1wVGFiRWxcblxuICAgICAgICB0YWJzV3JhcHBlci5pbm5lckhUTUwgPSAnJ1xuXG4gICAgICAgIHRhYnMuZm9yRWFjaCgodGFiKSA9PiB7XG4gICAgICAgICAgICB0bXBUYWJFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICAgICAgICB0bXBUYWJFbC5jbGFzc0xpc3QuYWRkKCdkbC10YWItYnRuJylcbiAgICAgICAgICAgIHRtcFRhYkVsLmNsYXNzTGlzdC5hZGQodGFiLnJlcGxhY2UoL1xccy9nLCAnJykpXG4gICAgICAgICAgICB0bXBUYWJFbC5pbm5lckhUTUwgPSB0YWJcbiAgICAgICAgICAgIHRtcFRhYkVsLm9uY2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNldEFjdGl2ZVRhYih0YWIpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YWJzV3JhcHBlci5hcHBlbmRDaGlsZCh0bXBUYWJFbClcbiAgICAgICAgfSlcblxuICAgICAgICBpZih0YWJzWzBdKSB7XG4gICAgICAgICAgICB0aGlzLnNldEFjdGl2ZVRhYih0YWJzWzBdKVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNldEFjdGl2ZVRhYjogZnVuY3Rpb24odGFiKSB7XG4gICAgICAgIGlmKCF0YWIpIHtcbiAgICAgICAgICAgIHRhYiA9IHRoaXMuYWN0aXZlVGFiXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGFiQ2xhc3NOYW1lID0gdGFiLnJlcGxhY2UoL1xccy9nLCAnJyksXG4gICAgICAgICAgICBjdXJyZW50QWN0aXZlVGFiQnRuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmRsLXRhYi1idG4uYWN0aXZlJyksXG4gICAgICAgICAgICB0YWJCdG4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZGwtdGFiLWJ0bi4nICsgdGFiQ2xhc3NOYW1lKVxuXG4gICAgICAgIGlmKGN1cnJlbnRBY3RpdmVUYWJCdG4pIHtcbiAgICAgICAgICAgIGN1cnJlbnRBY3RpdmVUYWJCdG4uY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJylcbiAgICAgICAgfVxuXG4gICAgICAgIHRhYkJ0bi5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKVxuXG4gICAgICAgIHRoaXMuYWN0aXZlVGFiID0gdGFiO1xuICAgICAgICB0aGlzLmZpZWxkcy5mb3JFYWNoKGZpZWxkID0+IHtcbiAgICAgICAgICAgIGlmKCFmaWVsZC5kb21FbGVtZW50KSB7IHJldHVybiB9XG4gICAgICAgICAgICBpZihmaWVsZC50YWIgPT09IHRhYikge1xuICAgICAgICAgICAgICAgIGZpZWxkLmRvbUVsZW1lbnQucGFyZW50RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdub3RJblRhYicpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpZWxkLmRvbUVsZW1lbnQucGFyZW50RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdub3RJblRhYicpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfSxcblxuICAgIGRlbGV0ZUZyb21TdGFjazogZnVuY3Rpb24oKSB7XG4gICAgICAgIG1vZGFsRGlhbG9ncyA9IG1vZGFsRGlhbG9ncy5maWx0ZXIoZGlhID0+IGRpYSAhPT0gdGhpcylcbiAgICB9LFxuXG4gICAgY2FuY2VsTW9kYWxJZkNhbmNlbGFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZih0aGlzLm9uQ2FuY2VsQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmKHRoaXMubW9kYWxFbCkge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kYWxFbC5yZW1vdmUoKVxuICAgICAgICAgICAgICAgIHRoaXMubW9kYWxFbCA9IG51bGxcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5vbkNhbmNlbENhbGxiYWNrKClcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlRnJvbVN0YWNrKClcblxuICAgICAgICAgICAgaWYobW9kYWxEaWFsb2dzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG1vZGFsRGlhbG9nc1ttb2RhbERpYWxvZ3MubGVuZ3RoLTFdLnNob3coKVxuICAgICAgICAgICAgICAgIG1vZGFsRGlhbG9nc1ttb2RhbERpYWxvZ3MubGVuZ3RoLTFdLnNldEFjdGl2ZVRhYigpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY2xvc2VNb2RhbElmT3BlbjogZnVuY3Rpb24oY2FsbGFiYWNrKSB7XG4gICAgICAgIGNhbGxhYmFjayA9IGNhbGxhYmFjayB8fCB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2tcblxuICAgICAgICBpZih0aGlzLm1vZGFsRWwpIHtcbiAgICAgICAgICAgIHRoaXMubW9kYWxFbC5yZW1vdmUoKVxuICAgICAgICAgICAgdGhpcy5tb2RhbEVsID0gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgaWYoY2FsbGFiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYWJhY2sodGhpcy5nZXRWYWx1ZXMoKSlcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGVsZXRlRnJvbVN0YWNrKClcblxuICAgICAgICBpZihtb2RhbERpYWxvZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBtb2RhbERpYWxvZ3NbbW9kYWxEaWFsb2dzLmxlbmd0aC0xXS5zaG93KClcbiAgICAgICAgICAgIG1vZGFsRGlhbG9nc1ttb2RhbERpYWxvZ3MubGVuZ3RoLTFdLnNldEFjdGl2ZVRhYigpXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0VmFsdWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlc3VsdCAgPSB7fVxuXG4gICAgICAgIC8vVE9ETzogZmlsdGVyIGNhbGN1bGF0ZWQgZmllbGRzXG4gICAgICAgIHRoaXMuZmllbGRzLmZpbHRlcihmdW5jdGlvbihmaWVsZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkLmRvbUVsZW1lbnQgJiYgIWZpZWxkLmRvbUVsZW1lbnQucGFyZW50RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2luYWN0aXZlJylcbiAgICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbihmaWVsZCkge1xuICAgICAgICAgICAgaWYoIWZpZWxkLmRvbUVsZW1lbnQpIHsgcmV0dXJuIH1cbiAgICAgICAgICAgIHJlc3VsdFtmaWVsZC5uYW1lXSA9IGZpZWxkLmRvbUVsZW1lbnQuZ2V0QXR0cmlidXRlKCd2YWx1ZScpIHx8IGZpZWxkLmRvbUVsZW1lbnQuX3ZhbHVlIHx8IGZpZWxkLmRvbUVsZW1lbnQudmFsdWVcblxuICAgICAgICAgICAgaWYoZmllbGQuZG9tRWxlbWVudC5hY2NlcHRlZFN1Z2dlc3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ZpZWxkLm5hbWVdID0gcmVzdWx0W2ZpZWxkLm5hbWVdIHx8IFtdO1xuICAgICAgICAgICAgICAgIGZpZWxkLmRvbUVsZW1lbnQuYWNjZXB0ZWRTdWdnZXN0aW9uc1xuICAgICAgICAgICAgICAgICAgICAubWFwKGVsID0+IGVsWzBdKVxuICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaChjYW5kaWRhdGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIXJlc3VsdFtmaWVsZC5uYW1lXS5maW5kKHByb2Nlc3NlZCA9PiBKU09OLnN0cmluZ2lmeShjYW5kaWRhdGUpID09PSBKU09OLnN0cmluZ2lmeShwcm9jZXNzZWQpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtmaWVsZC5uYW1lXS5wdXNoKGNhbmRpZGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIXJlc3VsdFtmaWVsZC5uYW1lXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtmaWVsZC5uYW1lXSA9ICcnXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGZpZWxkLmNoZWNrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ZpZWxkLm5hbWVdID0gcmVzdWx0W2ZpZWxkLm5hbWVdID09PSAndHJ1ZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICByZXN1bHQuYWN0aXZlVGFiID0gdGhpcy5hY3RpdmVUYWI7XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICB9LFxuXG4gICAgY3JlYXRlTW9kYWxFbGVtZW50OiBmdW5jdGlvbihhdHRyLCBkb05vdE1vdW50KSB7XG5cbiAgICAgICAgYXR0ciA9IGF0dHIgfHwge31cbiAgICAgICAgYXR0ci5jbGFzc05hbWVzID0gYXR0ci5jbGFzc05hbWVzIHx8IFtdXG5cbiAgICAgICAgdmFyIG1vZGFsV3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICAgICAgbW9kYWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgICAgICAgIG1vZGFsQ29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICAgICAgbG93QmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICAgICAgICB1cEJhciAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgICAgICAgIGNhbmNlbEJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICAgICAgdGFiV3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICAgICAgdG1wQnRuXG5cbiAgICAgICAgbW9kYWxXcmFwcGVyLmNsYXNzTGlzdC5hZGQoJ2RsLW1vZGFsJylcbiAgICAgICAgbW9kYWxXcmFwcGVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgICAgICAgbW9kYWwuY2xhc3NMaXN0LmFkZCgnbW9kYWwnKVxuICAgICAgICBtb2RhbENvbnRlbnQuY2xhc3NMaXN0LmFkZCgnbW9kYWwtY29udGVudCcpXG4gICAgICAgIHRhYldyYXBwZXIuY2xhc3NMaXN0LmFkZCgndGFiV3JhcHBlcicpXG4gICAgICAgIGxvd0Jhci5jbGFzc0xpc3QuYWRkKCdsb3ctYmFyJylcblxuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmJ1dHRvbnMpLmZvckVhY2goKGJ0biA9PiB7XG4gICAgICAgICAgICBsZXQgY2FsbGJhY2sgPSB0eXBlb2YgdGhpcy5idXR0b25zW2J0bl0gPT09ICdmdW5jdGlvbicgPyB0aGlzLmJ1dHRvbnNbYnRuXSA6IHRoaXMuYnV0dG9uc1tidG5dLmFjdGlvblxuICAgICAgICAgICAgdG1wQnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgICAgICAgIHRtcEJ0bi5jbGFzc0xpc3QuYWRkKCdidG4nKVxuICAgICAgICAgICAgdG1wQnRuLmlubmVySFRNTCA9IGJ0blxuXG4gICAgICAgICAgICBpZih0aGlzLmJ1dHRvbnNbYnRuXS5pZCkge1xuICAgICAgICAgICAgICAgIHRtcEJ0bi5pZCA9IHRoaXMuYnV0dG9uc1tidG5dLmlkXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRtcEJ0bi5vbmNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xhc3NlcyA9IGV2ZW50LnRhcmdldC5jbGFzc0xpc3RcblxuICAgICAgICAgICAgICAgIGlmKGNsYXNzZXMuY29udGFpbnMoJ2xvYWRpbmctYnRuJykgfHwgY2xhc3Nlcy5jb250YWlucygnZGlzYWJsZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLmFsbFNldHRsZWQodGhpcy5hbGxQcm9taXNlcykudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmKCFjbGFzc2VzLmNvbnRhaW5zKCdkaXNhYmxlZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUNhbGN1bGF0ZWRGaWVsZHMoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlTW9kYWxJZk9wZW4oY2FsbGJhY2spXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5yZW1vdmUoJ2xvYWRpbmctYnRuJylcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsb3dCYXIuYXBwZW5kQ2hpbGQodG1wQnRuKVxuICAgICAgICB9KSlcblxuICAgICAgICBpZih0aGlzLm9uQ2FuY2VsQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHVwQmFyLmNsYXNzTGlzdC5hZGQoJ3VwLWJhcicpXG4gICAgICAgICAgICBjYW5jZWxCdG4uY2xhc3NMaXN0LmFkZCgnY2FuY2VsQnRuJylcbiAgICAgICAgICAgIGNhbmNlbEJ0bi5vbmNsaWNrID0gKCkgPT4geyB0aGlzLmNhbmNlbE1vZGFsSWZDYW5jZWxhYmxlKCkgfVxuICAgICAgICAgICAgdXBCYXIuYXBwZW5kQ2hpbGQoY2FuY2VsQnRuKVxuICAgICAgICB9XG5cbiAgICAgICAgbW9kYWxXcmFwcGVyLmFwcGVuZENoaWxkKG1vZGFsKVxuICAgICAgICBtb2RhbC5hcHBlbmRDaGlsZCh1cEJhcilcbiAgICAgICAgbW9kYWwuYXBwZW5kQ2hpbGQodGFiV3JhcHBlcilcbiAgICAgICAgbW9kYWwuYXBwZW5kQ2hpbGQobW9kYWxDb250ZW50KVxuICAgICAgICBtb2RhbC5hcHBlbmRDaGlsZChsb3dCYXIpXG5cbiAgICAgICAgaWYoIWRvTm90TW91bnQpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobW9kYWxXcmFwcGVyKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1vZGFsV3JhcHBlclxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEZWNsYXJhdGl2Rm9ybVxuIiwidmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKSxcbiAgICB4bWxucyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zydcblxuc3R5bGUudGV4dENvbnRlbnQgPSBgXG4gICAgQGtleWZyYW1lcyBwbGFjZUhvbGRlclNoaW1tZXJ7XG4gICAgICAgIDAle1xuICAgICAgICAgICAgYmFja2dyb3VuZC1wb3NpdGlvbjogLTQ2OHB4IDBcbiAgICAgICAgfVxuICAgICAgICAxMDAle1xuICAgICAgICAgICAgYmFja2dyb3VuZC1wb3NpdGlvbjogNDY4cHggMFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGwtc2VsZWN0IHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBmb250LXdlaWdodDogMzAwO1xuICAgICAgICBmb250LWZhbWlseTogJ1J1YmlrJywgc2Fucy1zZXJpZjtcbiAgICB9XG5cbiAgICBkbC1zZWxlY3QgLmlucHV0LXdyYXBwZXIge1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgIGJvcmRlcjogMnB4IHNvbGlkICNkZGQ7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICB9XG5cbiAgICBkbC1zZWxlY3QuZGwtZm9jdXNlZCAuaW5wdXQtd3JhcHBlciB7XG4gICAgICAgIGJvcmRlcjogMnB4IHNvbGlkICNiYmI7XG4gICAgfVxuXG4gICAgZGwtc2VsZWN0LmRsLWZvY3VzZWQgLmlucHV0LXdyYXBwZXIgc3ZnIHtcbiAgICAgICAgYm9yZGVyLWxlZnQ6IDFweCBzb2xpZCAjYmJiO1xuICAgICAgICBmaWxsOiAjYmJiO1xuICAgIH1cblxuICAgIGRsLXNlbGVjdCAub3B0aW9ucy13cmFwcGVyIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBsZWZ0OiAwcHg7XG4gICAgICAgIHRvcDogMjBweDtcbiAgICAgICAgZm9udC1zaXplOiAwLjllbTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIG1heC1oZWlnaHQ6IDIzMHB4O1xuICAgICAgICBvdmVyZmxvdzogc2Nyb2xsO1xuICAgICAgICBib3gtc2hhZG93OiAwcHggMHB4IDEwcHggLTJweCByZ2JhKDAsMCwwLDAuNCk7XG4gICAgICAgIHotaW5kZXg6IDEwMDtcbiAgICB9XG5cbiAgICBkbC1zZWxlY3QgLm9wdGlvbnMtd3JhcHBlciBkbC1vcHRpb24ge1xuICAgICAgICBib3JkZXItbGVmdDogMXB4IHNvbGlkICNiYmI7XG4gICAgICAgIGJvcmRlci1yaWdodDogMXB4IHNvbGlkICNiYmI7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICB9XG5cbiAgICBkbC1zZWxlY3QgLm9wdGlvbnMtd3JhcHBlciAubm9NYXRjaGVzSGludCB7XG4gICAgICAgIGJvcmRlci1sZWZ0OiAxcHggc29saWQgI2JiYjtcbiAgICAgICAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgI2JiYjtcbiAgICAgICAgcGFkZGluZzogNXB4O1xuICAgICAgICBmb250LXN0eWxlOiBpdGFsaWM7XG4gICAgfVxuXG4gICAgZGwtc2VsZWN0IC5vcHRpb25zLXdyYXBwZXIge1xuICAgICAgICBib3JkZXItdG9wOiAxcHggc29saWQgI2JiYjtcbiAgICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNiYmI7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICB9XG5cbiAgICBkbC1zZWxlY3QgLmlucHV0LXdyYXBwZXIgaW5wdXQge1xuICAgICAgICB3aWR0aDogMzcxcHg7XG4gICAgICAgIG91dGxpbmUtd2lkdGg6IDA7XG4gICAgICAgIG1hcmdpbi10b3A6IDJweDtcbiAgICAgICAgcGFkZGluZzogNnB4O1xuICAgICAgICBmb250LXNpemU6IDAuOWVtO1xuICAgICAgICBmb250LWZhbWlseTogJ1J1YmlrJywgc2Fucy1zZXJpZjtcbiAgICAgICAgZm9udC13ZWlnaHQ6IDMwMDtcbiAgICAgICAgYm9yZGVyOiAwcHg7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgZmxvYXQ6IGxlZnQ7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgYm94LXNpemluZzogY29udGVudC1ib3g7XG4gICAgfVxuXG4gICAgZGwtc2VsZWN0IC5pbnB1dC13cmFwcGVyIHN2ZyB7XG4gICAgICAgIHdpZHRoOiAyMHB4O1xuICAgICAgICBoZWlnaHQ6IDIwcHg7XG4gICAgICAgIG1hcmdpbi10b3A6IDVweDtcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiA0cHg7XG4gICAgICAgIHBhZGRpbmctbGVmdDogNHB4O1xuICAgICAgICBmaWxsOiAjZGRkO1xuICAgICAgICBmbG9hdDogcmlnaHQ7XG4gICAgICAgIGJvcmRlci1sZWZ0OiAxcHggc29saWQgI2RkZDtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIH1cblxuICAgIGRsLXNlbGVjdCAub3B0aW9ucy13cmFwcGVyIGRsLW9wdGlvbiB7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICBwYWRkaW5nOiA1cHg7XG4gICAgICAgIGNvbG9yOiAjNTQ1NDU0O1xuICAgIH1cblxuICAgIGRsLXNlbGVjdCAub3B0aW9ucy13cmFwcGVyIGRsLW9wdGlvbjpob3ZlciB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjI0LCAyNDAsIDIyNywgMC40KTtcbiAgICB9XG5cbiAgICBkbC1zZWxlY3QgLm9wdGlvbnMtd3JhcHBlciBkbC1vcHRpb24uZGwtZm9jdXNlZCB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjI0LCAyNDAsIDIyNywgMC40KTtcbiAgICB9XG5cbiAgICBkbC1zZWxlY3QgLmRsLW9wdGlvbi10YWcge1xuICAgICAgICBmbG9hdDogcmlnaHQ7XG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkICM4ODg7XG4gICAgICAgIGZvbnQtc2l6ZTogMC44ZW07XG4gICAgICAgIHBhZGRpbmc6IDJweDtcbiAgICAgICAgZm9udC1mYW1pbHk6ICdTb3VyY2UgQ29kZSBQcm8nLCBtb25vc3BhY2U7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDJweDtcbiAgICAgICAgbWFyZ2luLXRvcDogLTFweDtcbiAgICB9XG5cbiAgICBkbC1zZWxlY3QgLmRsLW9wdGlvbi10YWc6bGFzdC1jaGlsZCB7XG4gICAgICAgbWFyZ2luLXJpZ2h0OiAxMHB4O1xuICAgIH1cblxuICAgIC5kbC1zZWxlY3QtbG9hZGluZyB7XG5cbiAgICB9XG5cbiAgICAuZGwtc2VsZWN0LW5vLW9wdGlvbnMtYXZhaWxhYmxlIHN2ZyBwYXRoIHtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICB9XG5cbiAgICAuZGwtc2VsZWN0LW5vLW9wdGlvbnMtYXZhaWxhYmxlIHN2ZyB7XG4gICAgICAgIGJvcmRlci1sZWZ0OiBub25lICFpbXBvcnRhbnQ7XG4gICAgfVxuXG4gICAgLmRsLXNlbGVjdC1sb2FkaW5nIHN2ZywgLmRsLXNlbGVjdC1uby1vcHRpb25zLWF2YWlsYWJsZSBzdmcge1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICB9XG5cbiAgICAuZGwtc2VsZWN0LWxvYWRpbmcgaW5wdXQsIC5kbC1zZWxlY3Qtbm8tb3B0aW9ucy1hdmFpbGFibGUgaW5wdXQge1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICB9XG5cbiAgICBib2R5LmRhcmstdGhlbWUgZGwtc2VsZWN0IHtcbiAgICAgICAgLS1kbC1zZWxlY3QtbG9hZGluZy1jb2wxOiAjMjgyNzI3O1xuICAgICAgICAtLWRsLXNlbGVjdC1sb2FkaW5nLWNvbDI6ICM1MDU2NTY7XG4gICAgfVxuXG4gICAgZGwtc2VsZWN0IHtcbiAgICAgICAgLS1kbC1zZWxlY3QtbG9hZGluZy1jb2wxOiAjZWVlZWVlO1xuICAgICAgICAtLWRsLXNlbGVjdC1sb2FkaW5nLWNvbDI6ICNkZGRkZGQ7XG4gICAgfVxuXG4gICAgLmRsLXNlbGVjdC1sb2FkaW5nIC5pbnB1dC13cmFwcGVyIHtcbiAgICAgICAgYW5pbWF0aW9uLWR1cmF0aW9uOiAxLjI1cztcbiAgICAgICAgYW5pbWF0aW9uLWZpbGwtbW9kZTogZm9yd2FyZHM7XG4gICAgICAgIGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IGluZmluaXRlO1xuICAgICAgICBhbmltYXRpb24tbmFtZTogcGxhY2VIb2xkZXJTaGltbWVyO1xuICAgICAgICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBsaW5lYXI7XG4gICAgICAgIGJhY2tncm91bmQ6IGRhcmtncmF5O1xuICAgICAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQsIHZhcigtLWRsLXNlbGVjdC1sb2FkaW5nLWNvbDEpIDEwJSwgdmFyKC0tZGwtc2VsZWN0LWxvYWRpbmctY29sMikgMTglLCB2YXIoLS1kbC1zZWxlY3QtbG9hZGluZy1jb2wxKSAzMyUpO1xuICAgICAgICBiYWNrZ3JvdW5kLXNpemU6IDgwMHB4IDEwNHB4O1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHdpZHRoOiA0MTJweDtcbiAgICAgICAgaGVpZ2h0OiAzMXB4O1xuICAgIH1cbiAgICAuZGwtc2VsZWN0LWxvYWRpbmcgaW5wdXQge1xuICAgICAgICBkaXNwbGF5OiBub25lO1xuICAgIH1cbmBcblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdHlsZSlcbn0pXG5cbmNsYXNzIERsU2VsZWN0IGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpXG4gICAgICAgIHRoaXMubG9hZGluZ1NjcmVlblRpbWVvdXRzID0gW11cbiAgICAgICAgdGhpcy5sb2FkaW5nU3RhcnRlZEF0ID0gdW5kZWZpbmVkXG4gICAgICAgIHRoaXMub3B0aW9uc1dyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgICB0aGlzLmlucHV0V3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKVxuICAgICAgICB0aGlzLm5vTWF0Y2hlc0hpbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJylcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKVxuICAgICAgICB0aGlzLmFycm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHhtbG5zLCAnc3ZnJylcbiAgICB9XG5cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgICAgICAgaWYodGhpcy5pc0luaXRpYWxpemVkKSB7IHJldHVybiB9XG5cbiAgICAgICAgdGhpcy5pbnB1dFdyYXBwZXIuY2xhc3NMaXN0LmFkZCgnaW5wdXQtd3JhcHBlcicpXG4gICAgICAgIHRoaXMub3B0aW9uc1dyYXBwZXIuY2xhc3NMaXN0LmFkZCgnb3B0aW9ucy13cmFwcGVyJylcbiAgICAgICAgdGhpcy5vcHRpb25zV3JhcHBlci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICAgIHRoaXMuaW5wdXRGaWVsZC5wbGFjZWhvbGRlciA9ICdTZWxlY3QgLi4uJ1xuICAgICAgICB0aGlzLm5vTWF0Y2hlc0hpbnQuY2xhc3NMaXN0LmFkZCgnbm9NYXRjaGVzSGludCcpXG4gICAgICAgIHRoaXMubm9NYXRjaGVzSGludC5pbm5lckhUTUwgPSAnTm8gTWF0Y2hlcydcbiAgICAgICAgdGhpcy5ub01hdGNoZXNIaW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkLm9uZm9jdXMgPSAoKSA9PiB7IHNlbGYuZm9jdXMoKSB9XG4gICAgICAgIHRoaXMuaW5wdXRGaWVsZC5vbmJsdXIgPSAoZSkgPT4geyBzZWxmLnVuZm9jdXMoKSB9XG4gICAgICAgIHRoaXMuaW5wdXRGaWVsZC5vbmlucHV0ID0gKCkgPT4geyBzZWxmLmZpbHRlck9wdGlvbnModGhpcy5pbnB1dEZpZWxkLnZhbHVlKSB9XG4gICAgICAgIHRoaXMuYXJyb3cub25jbGljayA9ICgpID0+IHsgc2VsZi5pbnB1dEZpZWxkLmZvY3VzKCkgfVxuICAgICAgICB0aGlzLmFycm93LmlubmVySFRNTCA9ICc8cGF0aCBkPVwiTTQuNTE2IDcuNTQ4YzAuNDM2LTAuNDQ2IDEuMDQzLTAuNDgxIDEuNTc2IDBsMy45MDggMy43NDcgMy45MDgtMy43NDdjMC41MzMtMC40ODEgMS4xNDEtMC40NDYgMS41NzQgMCAwLjQzNiAwLjQ0NSAwLjQwOCAxLjE5NyAwIDEuNjE1LTAuNDA2IDAuNDE4LTQuNjk1IDQuNTAyLTQuNjk1IDQuNTAyLTAuMjE3IDAuMjIzLTAuNTAyIDAuMzM1LTAuNzg3IDAuMzM1cy0wLjU3LTAuMTEyLTAuNzg5LTAuMzM1YzAgMC00LjI4Ny00LjA4NC00LjY5NS00LjUwMnMtMC40MzYtMS4xNyAwLTEuNjE1elwiPjwvcGF0aD4nXG5cbiAgICAgICAgdGhpcy5vcHRpb25zV3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLm5vTWF0Y2hlc0hpbnQpXG5cbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdkbC1zZWxlY3Qtbm8tb3B0aW9ucy1hdmFpbGFibGUnKVxuXG4gICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlICE9PSAnbG9hZGluZycpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZE9wdGlvbnMoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7c2VsZi5sb2FkT3B0aW9ucygpfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgKGUpID0+IHtcbiAgICAgICAgICAgIHZhciBvcHRpb24gPSBzZWxmLmZvY3VzZWRPcHRpb24oKVxuICAgICAgICAgICAgaWYoZS5rZXkgPT09ICdBcnJvd0Rvd24nKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5mb2N1c09wdGlvbihzZWxmLm5leHRWaXNpYmxlT3B0aW9uQWZ0ZXIob3B0aW9uKSlcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgICAgICB9IGVsc2UgaWYoZS5rZXkgPT09ICdBcnJvd1VwJykge1xuICAgICAgICAgICAgICAgIHNlbGYuZm9jdXNPcHRpb24oc2VsZi5wcmV2aW91c1Zpc2libGVPcHRpb25BZnRlcihvcHRpb24pKVxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgICAgIH0gZWxzZSBpZihlLmtleSA9PT0gJ0VudGVyJykge1xuICAgICAgICAgICAgICAgIHNlbGYuc2V0T3B0aW9uKG9wdGlvbilcbiAgICAgICAgICAgICAgICBzZWxmLnVuZm9jdXMoKVxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHNldExvYWRpbmdTdGF0dXMoKSB7XG4gICAgICAgIHRoaXMubG9hZGluZ1NjcmVlblRpbWVvdXRzLnB1c2goc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2RsLXNlbGVjdC1sb2FkaW5nJylcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc1dyYXBwZXIucmVtb3ZlKClcbiAgICAgICAgICAgIHRoaXMubG9hZGluZ1N0YXJ0ZWRBdCA9IERhdGUubm93KClcbiAgICAgICAgfSwgMTAwKSlcbiAgICB9XG5cbiAgICB1bnNldExvYWRpbmdTdGF0dXMoKSB7XG4gICAgICAgIHRoaXMubG9hZGluZ1NjcmVlblRpbWVvdXRzLmZvckVhY2goY2xlYXJUaW1lb3V0KVxuICAgICAgICB0aGlzLmxvYWRpbmdTY3JlZW5UaW1lb3V0cyA9IFtdXG5cbiAgICAgICAgY29uc3QgbWluTG9hZFRpbWVJblNlY29uZHMgPSAxLjVcbiAgICAgICAgY29uc3QgZGVsYXkgPSB0aGlzLmxvYWRpbmdTdGFydGVkQXQgP1xuICAgICAgICAgICAgKG1pbkxvYWRUaW1lSW5TZWNvbmRzICogMTAwMCkgLSAoRGF0ZS5ub3coKSAtIHRoaXMubG9hZGluZ1N0YXJ0ZWRBdClcbiAgICAgICAgICAgIDogMFxuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZCh0aGlzLm9wdGlvbnNXcmFwcGVyKVxuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCdkbC1zZWxlY3QtbG9hZGluZycpXG4gICAgICAgIH0sIGRlbGF5KVxuICAgIH1cblxuICAgIGxvYWRPcHRpb25zKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICAgICAgd2hpbGUoc2VsZi5maXJzdEVsZW1lbnRDaGlsZCkge1xuICAgICAgICAgICAgc2VsZi5maXJzdEVsZW1lbnRDaGlsZC5vbm1vdXNlZG93biA9IGZ1bmN0aW9uKCkgeyBzZWxmLnNldE9wdGlvbih0aGlzKSB9XG4gICAgICAgICAgICBzZWxmLmZpcnN0RWxlbWVudENoaWxkLm9ubW91c2VvdmVyID0gZnVuY3Rpb24oKSB7IHNlbGYuY2xlYXJGb2N1c2VkT3B0aW9uKCkgfVxuICAgICAgICAgICAgc2VsZi5vcHRpb25zV3JhcHBlci5hcHBlbmRDaGlsZChzZWxmLmZpcnN0RWxlbWVudENoaWxkKVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5pbnB1dFdyYXBwZXIuYXBwZW5kQ2hpbGQoc2VsZi5pbnB1dEZpZWxkKVxuICAgICAgICBzZWxmLmlucHV0V3JhcHBlci5hcHBlbmRDaGlsZChzZWxmLmFycm93KVxuICAgICAgICBzZWxmLmFwcGVuZENoaWxkKHNlbGYuaW5wdXRXcmFwcGVyKVxuICAgICAgICBzZWxmLmFwcGVuZENoaWxkKHNlbGYub3B0aW9uc1dyYXBwZXIpXG4gICAgICAgIHNlbGYuc2V0VmFsdWUoc2VsZi5nZXRWYWx1ZSgpKVxuICAgICAgICB0aGlzLnVwZGF0ZVBsYWNlaG9sZGVyVGV4dCgpXG4gICAgfVxuXG4gICAgcmVtb3ZlQWxsT3B0aW9ucygpIHtcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdkbC1zZWxlY3Qtbm8tb3B0aW9ucy1hdmFpbGFibGUnKVxuICAgICAgICB0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoJ2RsLW9wdGlvbicpLmZvckVhY2gob3B0ID0+IG9wdC5yZW1vdmUoKSlcbiAgICAgICAgdGhpcy51cGRhdGVQbGFjZWhvbGRlclRleHQoKVxuICAgIH1cblxuICAgIGFkZE9wdGlvbihvcHRpb25FbCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXNcblxuICAgICAgICBvcHRpb25FbC5vbm1vdXNlZG93biA9IGZ1bmN0aW9uKCkgeyBzZWxmLnNldE9wdGlvbih0aGlzKSB9XG4gICAgICAgIG9wdGlvbkVsLm9ubW91c2VvdmVyID0gZnVuY3Rpb24oKSB7IHNlbGYuY2xlYXJGb2N1c2VkT3B0aW9uKCkgfVxuICAgICAgICBzZWxmLm9wdGlvbnNXcmFwcGVyLmFwcGVuZENoaWxkKG9wdGlvbkVsKVxuXG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSgnZGwtc2VsZWN0LW5vLW9wdGlvbnMtYXZhaWxhYmxlJylcbiAgICAgICAgdGhpcy51cGRhdGVQbGFjZWhvbGRlclRleHQoKVxuICAgIH1cblxuICAgIGNsZWFyRm9jdXNlZE9wdGlvbigpIHtcbiAgICAgICAgdGhpcy5fZm9jdXNlZE9wdGlvbiA9IG51bGxcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbCh0aGlzLm9wdGlvbnNXcmFwcGVyLmNoaWxkcmVuLCAob3B0KSA9PiB7XG4gICAgICAgICAgICBvcHQuY2xhc3NMaXN0LnJlbW92ZSgnZGwtZm9jdXNlZCcpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgZm9jdXNlZE9wdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvY3VzZWRPcHRpb25cbiAgICB9XG5cbiAgICBmb2N1c09wdGlvbihvcHRpb24pIHtcbiAgICAgICAgb3B0aW9uID0gb3B0aW9uIHx8IHRoaXMubmV4dFZpc2libGVPcHRpb25BZnRlcihvcHRpb24pXG5cbiAgICAgICAgdGhpcy5jbGVhckZvY3VzZWRPcHRpb24oKVxuXG4gICAgICAgIHRoaXMuX2ZvY3VzZWRPcHRpb24gPSBvcHRpb25cbiAgICAgICAgaWYob3B0aW9uKSB7XG4gICAgICAgICAgICBvcHRpb24uY2xhc3NMaXN0LmFkZCgnZGwtZm9jdXNlZCcpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZXh0VmlzaWJsZU9wdGlvbkFmdGVyKG9wdGlvbikge1xuICAgICAgICBvcHRpb24gPSBvcHRpb24gfHwgdGhpcy5vcHRpb25zV3JhcHBlci5jaGlsZHJlblswXVxuICAgICAgICB3aGlsZShvcHRpb24pIHtcbiAgICAgICAgICAgIGlmKG9wdGlvbi5uZXh0U2libGluZyAmJiBvcHRpb24ubmV4dFNpYmxpbmcuc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbi5uZXh0U2libGluZ1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvcHRpb24gPSBvcHRpb24ubmV4dFNpYmxpbmdcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByZXZpb3VzVmlzaWJsZU9wdGlvbkFmdGVyKG9wdGlvbikge1xuICAgICAgICBvcHRpb24gPSBvcHRpb24gfHwgdGhpcy5vcHRpb25zV3JhcHBlci5jaGlsZHJlblswXVxuICAgICAgICB3aGlsZShvcHRpb24pIHtcbiAgICAgICAgICAgIGlmKG9wdGlvbi5wcmV2aW91c1NpYmxpbmcgJiYgb3B0aW9uLnByZXZpb3VzU2libGluZy5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9uLnByZXZpb3VzU2libGluZ1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvcHRpb24gPSBvcHRpb24ucHJldmlvdXNTaWJsaW5nXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmaWx0ZXJPcHRpb25zKHN0cikge1xuICAgICAgICB2YXIgaGFzTWF0Y2hlZCA9IGZhbHNlO1xuICAgICAgICBzdHIgPSBzdHIudG9Mb3dlckNhc2UoKVxuXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwodGhpcy5vcHRpb25zV3JhcHBlci5jaGlsZHJlbiwgKG9wdCkgPT4ge1xuICAgICAgICAgICAgaWYoc3RyID09PSAnJyB8fCBzdHIuc3BsaXQoJyAnKS5ldmVyeSh0ZXJtID0+IG9wdC5pbm5lclRleHQudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyh0ZXJtKSkpIHtcbiAgICAgICAgICAgICAgICBvcHQuc3R5bGUuZGlzcGxheSA9ICdibG9jaydcbiAgICAgICAgICAgICAgICBoYXNNYXRjaGVkID0gdHJ1ZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHQuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIHRoaXMubm9NYXRjaGVzSGludC5zdHlsZS5kaXNwbGF5ID0gaGFzTWF0Y2hlZCA/ICdub25lJyA6ICdibG9jaydcbiAgICB9XG5cbiAgICBzZXRWYWx1ZSh2YWwpIHtcbiAgICAgICAgaWYoIXZhbCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3B0aW9uID0gdGhpcy5xdWVyeVNlbGVjdG9yKCdkbC1vcHRpb25bdmFsdWU9XCInK3ZhbCsnXCJdJykgfHxcbiAgICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5maW5kLmNhbGwodGhpcy5xdWVyeVNlbGVjdG9yQWxsKCdkbC1vcHRpb24nKSwgZnVuY3Rpb24oZWwpIHtyZXR1cm4gZWwuaW5uZXJUZXh0ID09IHZhbH0pXG5cbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3RtcC12YWx1ZScsIHZhbClcbiAgICAgICAgdGhpcy5zZXRPcHRpb24ob3B0aW9uKVxuICAgIH1cblxuICAgIHNldE9wdGlvbihvcHRpb25FbCkge1xuICAgICAgICBpZighb3B0aW9uRWwpIHsgcmV0dXJuIGZhbHNlIH1cblxuICAgICAgICB0aGlzLnNlbGVjdGVkT3B0aW9uRWwgPSBvcHRpb25FbFxuICAgICAgICB0aGlzLmlucHV0RmllbGQudmFsdWUgPSB0aGlzLmdldERpc3BsYXllZFRleHQoKVxuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgndmFsdWUnLCBvcHRpb25FbC5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJykgfHwgb3B0aW9uRWwuaW5uZXJUZXh0KVxuXG4gICAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkhUTUxFdmVudHNcIilcbiAgICAgICAgZXZ0LmluaXRFdmVudChcImNoYW5nZVwiLCBmYWxzZSwgdHJ1ZSlcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2dClcbiAgICB9XG5cbiAgICBnZXREaXNwbGF5ZWRUZXh0KCkge1xuICAgICAgICBpZih0aGlzLnNlbGVjdGVkT3B0aW9uRWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkT3B0aW9uRWwuZ2V0QXR0cmlidXRlKCdkaXNwbGF5V2hlblNlbGVjdGVkJykgfHwgdGhpcy5zZWxlY3RlZE9wdGlvbkVsLmlubmVyVGV4dFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICcnXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRQbGFjZWhvbGRlclRleHQoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNXcmFwcGVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ2RsLW9wdGlvbicpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICdObyBPcHRpb25zIEF2YWlsYWJsZSdcbiAgICAgICAgfSBlbHNlIGlmKHRoaXMuc2VsZWN0ZWRPcHRpb25FbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRPcHRpb25FbC5pbm5lclRleHRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnU2VsZWN0IC4uLidcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZVBsYWNlaG9sZGVyVGV4dCgpIHtcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnBsYWNlaG9sZGVyID0gdGhpcy5nZXRQbGFjZWhvbGRlclRleHQoKVxuICAgIH1cblxuICAgIGdldFZhbHVlKCkge1xuICAgICAgICBpZih0aGlzLmdldEF0dHJpYnV0ZSgndmFsdWUnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCd2YWx1ZScpXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG1wVmFsdWUgPSB0aGlzLmdldEF0dHJpYnV0ZSgndG1wLXZhbHVlJylcbiAgICAgICAgdmFyIG9wdGlvbiA9IHRoaXMucXVlcnlTZWxlY3RvcignZGwtb3B0aW9uW3ZhbHVlPVwiJyt0aGlzLmdldEF0dHJpYnV0ZSgndG1wLXZhbHVlJykrJ1wiXScpXG5cbiAgICAgICAgaWYob3B0aW9uICYmIHRtcFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdG1wVmFsdWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvY3VzKCkge1xuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2RsLWZvY3VzZWQnKVxuICAgICAgICB0aGlzLnVwZGF0ZVBsYWNlaG9sZGVyVGV4dCgpXG4gICAgICAgIHRoaXMuaW5wdXRGaWVsZC52YWx1ZSA9ICcnXG4gICAgICAgIHRoaXMub3B0aW9uc1dyYXBwZXIuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snXG4gICAgICAgIHRoaXMuZmlsdGVyT3B0aW9ucyh0aGlzLmlucHV0RmllbGQudmFsdWUpXG4gICAgfVxuXG4gICAgdW5mb2N1cygpIHtcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCdkbC1mb2N1c2VkJylcbiAgICAgICAgdGhpcy5vcHRpb25zV3JhcHBlci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICAgIHRoaXMuaW5wdXRGaWVsZC52YWx1ZSA9IHRoaXMuZ2V0RGlzcGxheWVkVGV4dCgpXG4gICAgICAgIHRoaXMuaW5wdXRGaWVsZC5ibHVyKClcbiAgICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnZGwtc2VsZWN0JywgRGxTZWxlY3QpXG4iLCJ2YXIgTW9kaWZpY2F0aW9uTG9nRW50cnkgPSByZXF1aXJlKCcuL21vZGlmaWNhdGlvbl9sb2cnKSxcbiAgICB1dGlscyA9IHJlcXVpcmUoJy4uL3BpeGVsc2NodWJzZXIvdXRpbHMnKSxcbiAgICBkaWZmTWF0Y2hQYXRjaCA9IHJlcXVpcmUoJ2RpZmZfbWF0Y2hfcGF0Y2gnKSxcbiAgICBkaWZmRW5naW5lID0gbmV3IGRpZmZNYXRjaFBhdGNoLmRpZmZfbWF0Y2hfcGF0Y2gsXG4gICAgd2l0aExvb2thaGVhZCA9IHJlcXVpcmUoJy4uL2dlbmVyYXRvcmxvb2thaGVhZCcpO1xuXG4vLyBUaGlzIGNyZWF0ZXMgYSB2aXR1YWwgRE9NIGZvciB0aGUgcGFzc2VkIGBjb250ZW50RWxlbWVudGBcbi8vIFVzaW5nIHRoZSB1cGRhdGVIVE1MIGZ1bmN0aW9uIG9mIHRoaXMgb2JqZWN0IHByb3ZpZGVzIHRoZSBmb2xsb3dpbmcgYWR2YW50YWdlczpcbi8vIC0gUGFzc2VkIEhUTUwgaXMgc2FuaXRpemVkIGJhc2VkIG9uIHRoZSBjb250ZW50IHJ1bGVzIG9mIHRoZSBgaHRtbFJhem9yYC5cbi8vIC0gSXQgcmV0dXJucyBhIG1vZGlmaWNhdGlvbkxvZ0VudHJ5IHdoaWNoIGluY2x1ZGVzIHRoZSBjaGFuZ2VzIG1hZGUuXG4vLyAtIE9ubHkgdXBkYXRlcyB0aGUgZG9tIGZyYWN0aW9ucyB0aGF0IG11c3QgYmUgY2hhbmdlZCAob3B0aW1pemVkXG4vLyAgIGZvciBsb25nIGFuZCBxdWl0ZSBmbGF0IGRvY3VtZW50cylcbmZ1bmN0aW9uIERvY3VtZW50dXBkYXRlcihjb250ZW50RWxlbWVudCwgaHRtbFJhem9yKSB7XG4gICAgdGhpcy5jb250ZW50RWxlbWVudCA9IGNvbnRlbnRFbGVtZW50O1xuICAgIHRoaXMuaHRtbFJhem9yID0gaHRtbFJhem9yO1xufVxuXG5Eb2N1bWVudHVwZGF0ZXIucHJvdG90eXBlID0ge1xuICAgIHVwZGF0ZUhUTUw6IGZ1bmN0aW9uKGNvbnRlbnQsIGZvY3VzZWRTZWN0aW9uLCBhcmdzKSB7XG4gICAgICAgIGFyZ3MgPSBhcmdzIHx8IHt9O1xuXG4gICAgICAgIGlmKHRoaXMuY29udGVudEVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRFbGVtZW50LmlubmVySFRNTCA9ICc8cD48L3A+JztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGFyZ3MuYWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudEVsZW1lbnRcbiAgICAgICAgICAgICAgICAucXVlcnlTZWxlY3RvckFsbCgnLmZvY3VzZWQtYnktYXBpLWFjdG9yJyArIGFyZ3MuYWN0b3IuaWQgKyAnLWZiYWFlbmQnKVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGVsID0+IGVsLmNsYXNzTGlzdC5yZW1vdmUoJ2ZvY3VzZWQtYnktYXBpLWFjdG9yJysgYXJncy5hY3Rvci5pZCArICctZmJhYWVuZCcpKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeSA9IGFyZ3MubW9kaWZpY2F0aW9uTG9nRW50cnkgfHwgbmV3IE1vZGlmaWNhdGlvbkxvZ0VudHJ5KCk7XG4gICAgICAgIHRoaXMubW9kaWZpY2F0aW9uTG9nRW50cnkuaW5zZXJ0ZWRCZWZvcmVTZWxlY3Rpb25SYW5nZVN0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeS5pbnNlcnRlZEJlZm9yZVNlbGVjdGlvblJhbmdlRW5kID0gMDtcblxuICAgICAgICB2YXIgZmlyc3RTZWN0aW9uVG9VcGRhdGUgPSBhcmdzLnNlY3Rpb24gfHwgYXJncy5zdGFydFNlY3Rpb24gfHwgdGhpcy5jb250ZW50RWxlbWVudC5jaGlsZHJlblswXSxcbiAgICAgICAgICAgIGxhc3RTZWN0aW9uVG9VcGRhdGUgPSAgYXJncy5zZWN0aW9uIHx8IGFyZ3MuZW5kU2VjdGlvbiB8fCB0aGlzLmNvbnRlbnRFbGVtZW50LmNoaWxkcmVuW3RoaXMuY29udGVudEVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoLTFdLFxuICAgICAgICAgICAgbmV3U2VjdGlvblN0cmVhbSxcbiAgICAgICAgICAgIHBhaXJTdHJlYW0sXG4gICAgICAgICAgICBsYXN0VXBkYXRlZFNlY3Rpb24sXG4gICAgICAgICAgICBwYWlyO1xuXG4gICAgICAgIGlmKGFyZ3Muc3RhcnRTZWN0aW9uICYmXG4gICAgICAgICAgIGFyZ3MuZW5kU2VjdGlvbiAmJlxuICAgICAgICAvLyAgICB0aGlzLmNvbnRlbnRFbGVtZW50LmNoaWxkcmVuWzBdICE9PSBhcmdzLnN0YXJ0U2VjdGlvbiAmJlxuICAgICAgICAvLyAgICB0aGlzLmNvbnRlbnRFbGVtZW50LmNoaWxkcmVuW3RoaXMuY29udGVudEVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoLTFdICE9PSBhcmdzLmVuZFNlY3Rpb24gJiZcbiAgICAgICAgICAgY29udGVudCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgIGNvbnRlbnQgIT09IG51bGwgJiZcbiAgICAgICAgICAgY29udGVudC50cmltKCkgPT09ICcnKSB7XG4gICAgICAgICAgICBwYWlyU3RyZWFtID0gdGhpcy5fZGVsZXRlT2xkU2VjdGlvbnNQYWlyU3RyZWFtKGZpcnN0U2VjdGlvblRvVXBkYXRlLCBsYXN0U2VjdGlvblRvVXBkYXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld1NlY3Rpb25TdHJlYW0gPSB0aGlzLmh0bWxSYXpvci5jbGVhbnVwSFRNTEFuZEF0dGFjaEV2ZW50SGFuZGxlcnMoY29udGVudCwgdGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeSk7XG4gICAgICAgICAgICBwYWlyU3RyZWFtID0gdGhpcy5fb2xkQW5kTmV3U2VjdGlvblBhaXJTdHJlYW0obmV3U2VjdGlvblN0cmVhbSwgZmlyc3RTZWN0aW9uVG9VcGRhdGUsIGxhc3RTZWN0aW9uVG9VcGRhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mb2N1c2VkU2VjdGlvbiA9IGZvY3VzZWRTZWN0aW9uO1xuICAgICAgICB0aGlzLm1vZGlmaWNhdGlvbkxvZ0VudHJ5LnJldGFpbkFsbFNlY3Rpb25zQmVmb3JlKGZpcnN0U2VjdGlvblRvVXBkYXRlKTtcblxuICAgICAgICB3aGlsZShwYWlyID0gcGFpclN0cmVhbS5uZXh0KCkudmFsdWUpIHtcbiAgICAgICAgICAgIGlmKHBhaXIub2xkICYmIHBhaXIubmV3KSB7XG4gICAgICAgICAgICAgICAgbGFzdFVwZGF0ZWRTZWN0aW9uID0gdGhpcy5fcmVwbGFjZVNlY3Rpb25zKHBhaXIub2xkLCBwYWlyLm5ldywgYXJncyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYocGFpci5uZXcpIHtcbiAgICAgICAgICAgICAgICBpZihsYXN0VXBkYXRlZFNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFVwZGF0ZWRTZWN0aW9uID0gdGhpcy5faW5zZXJ0U2VjdGlvbkFmdGVyKGxhc3RVcGRhdGVkU2VjdGlvbiwgcGFpci5uZXcsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZihmaXJzdFNlY3Rpb25Ub1VwZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0VXBkYXRlZFNlY3Rpb24gPSB0aGlzLl9pbnNlcnRTZWN0aW9uQmVmb3JlKGZpcnN0U2VjdGlvblRvVXBkYXRlLCBwYWlyLm5ldywgYXJncyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFVwZGF0ZWRTZWN0aW9uID0gdGhpcy5faW5zZXJ0U2VjdGlvbkF0QmVnaW5uaW5nKHBhaXIubmV3LCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZihwYWlyLm9sZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZVNlY3Rpb24ocGFpci5vbGQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihsYXN0VXBkYXRlZFNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZighbGFzdFVwZGF0ZWRTZWN0aW9uLndvcmRDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0VXBkYXRlZFNlY3Rpb24ud29yZENvdW50ID0gbGFzdFVwZGF0ZWRTZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAuaW5uZXJUZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAuc3BsaXQoL1tcXHNcXC46XFw/XFwhJ10vKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcih3ID0+IHcudHJpbSgpLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubW9kaWZpY2F0aW9uTG9nRW50cnkucmV0YWluQWxsU2VjdGlvbnNBZnRlcihsYXN0VXBkYXRlZFNlY3Rpb24pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLm1vZGlmaWNhdGlvbkxvZ0VudHJ5O1xuICAgIH0sXG5cbiAgICBfZGVsZXRlT2xkU2VjdGlvbnNQYWlyU3RyZWFtOiBmdW5jdGlvbiooZmlyc3RTZWN0aW9uVG9VcGRhdGUsIGxhc3RTZWN0aW9uVG9VcGRhdGUpIHtcbiAgICAgICAgdmFyIG5leHRPbGRTZWN0aW9uID0gZmlyc3RTZWN0aW9uVG9VcGRhdGUsXG4gICAgICAgICAgICBuZXh0TmV4dE9sZFNlY3Rpb247XG5cbiAgICAgICAgaWYoZmlyc3RTZWN0aW9uVG9VcGRhdGUgPT09IGxhc3RTZWN0aW9uVG9VcGRhdGUpIHtcbiAgICAgICAgICAgIHlpZWxkIHsgb2xkOiBmaXJzdFNlY3Rpb25Ub1VwZGF0ZSwgbmV3OiBudWxsIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGlsZShuZXh0T2xkU2VjdGlvbikge1xuICAgICAgICAgICAgICAgIG5leHROZXh0T2xkU2VjdGlvbiA9IG5leHRPbGRTZWN0aW9uLm5leHRTaWJsaW5nO1xuXG4gICAgICAgICAgICAgICAgeWllbGQgeyBvbGQ6IG5leHRPbGRTZWN0aW9uLCBuZXc6IG51bGwgfTtcbiAgICAgICAgICAgICAgICBuZXh0T2xkU2VjdGlvbiA9IG5leHROZXh0T2xkU2VjdGlvbjtcblxuICAgICAgICAgICAgICAgIGlmKG5leHRPbGRTZWN0aW9uID09PSBsYXN0U2VjdGlvblRvVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHsgb2xkOiBuZXh0T2xkU2VjdGlvbiwgbmV3OiBudWxsIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfb2xkQW5kTmV3U2VjdGlvblBhaXJTdHJlYW06IGZ1bmN0aW9uKihuZXdTZWN0aW9uU3RyZWFtLCBmaXJzdFNlY3Rpb25Ub1VwZGF0ZSwgbGFzdFNlY3Rpb25Ub1VwZGF0ZSkge1xuICAgICAgICBuZXdTZWN0aW9uU3RyZWFtID0gd2l0aExvb2thaGVhZChuZXdTZWN0aW9uU3RyZWFtKVxuXG4gICAgICAgIHZhciBuZXh0T2xkU2VjdGlvbiA9IGZpcnN0U2VjdGlvblRvVXBkYXRlLFxuICAgICAgICAgICAgbmV4dE5leHRPbGRTZWN0aW9uLCBuZXh0U2VjdGlvblRvQmVJbnNlcnRlZCxcbiAgICAgICAgICAgIG5ld1NlY3Rpb24sIG5leHROZXdTZWN0aW9uO1xuXG4gICAgICAgIHdoaWxlKG5leHRPbGRTZWN0aW9uKSB7XG4gICAgICAgICAgICBuZXh0TmV4dE9sZFNlY3Rpb24gPSBuZXh0T2xkU2VjdGlvbi5uZXh0U2libGluZztcbiAgICAgICAgICAgIG5ld1NlY3Rpb24gPSBuZXdTZWN0aW9uU3RyZWFtLm5leHQoKS52YWx1ZTtcbiAgICAgICAgICAgIG5leHROZXdTZWN0aW9uID0gbmV3U2VjdGlvblN0cmVhbS5sb29rYWhlYWQoKS52YWx1ZTtcblxuICAgICAgICAgICAgaWYoIXRoaXMuX2FyZUVxdWFsU2VjdGlvbnMobmV4dE9sZFNlY3Rpb24sIG5ld1NlY3Rpb24pICYmXG4gICAgICAgICAgICAgICAhdGhpcy5fYXJlRXF1YWxTZWN0aW9ucyhuZXh0TmV4dE9sZFNlY3Rpb24sIG5leHRPbGRTZWN0aW9uKSAmJlxuICAgICAgICAgICAgICAgdGhpcy5fYXJlRXF1YWxTZWN0aW9ucyhuZXh0T2xkU2VjdGlvbiwgbmV4dE5ld1NlY3Rpb24pXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB7IG9sZDogdW5kZWZpbmVkLCBuZXc6IG5ld1NlY3Rpb24gfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeWllbGQgeyBvbGQ6IG5leHRPbGRTZWN0aW9uLCBuZXc6IG5ld1NlY3Rpb24gfTtcbiAgICAgICAgICAgICAgICBpZihuZXh0T2xkU2VjdGlvbiA9PT0gbGFzdFNlY3Rpb25Ub1VwZGF0ZSkgeyBicmVhayB9XG4gICAgICAgICAgICAgICAgbmV4dE9sZFNlY3Rpb24gPSBuZXh0TmV4dE9sZFNlY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZShuZXh0U2VjdGlvblRvQmVJbnNlcnRlZCA9IG5ld1NlY3Rpb25TdHJlYW0ubmV4dCgpLnZhbHVlKSB7XG4gICAgICAgICAgICB5aWVsZCB7IG9sZDogbnVsbCwgbmV3OiBuZXh0U2VjdGlvblRvQmVJbnNlcnRlZCB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9yZW1vdmVTZWN0aW9uOiBmdW5jdGlvbihzZWN0aW9uKSB7XG4gICAgICAgIGlmKCFzZWN0aW9uKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgaWYoc2VjdGlvbiA9PT0gdGhpcy5mb2N1c2VkU2VjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeS5mb2N1c2VkU2VjdGlvbkhhc0JlZW5Nb2RpZmllZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1vZGlmaWNhdGlvbkxvZ0VudHJ5LmRlbGV0ZVNlY3Rpb24oc2VjdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHNlY3Rpb24pO1xuICAgIH0sXG5cbiAgICBfaW5zZXJ0U2VjdGlvbkF0QmVnaW5uaW5nOiBmdW5jdGlvbihzZWN0aW9uVG9JbnNlcnQsIGFyZ3MpIHtcbiAgICAgICAgaWYoIXNlY3Rpb25Ub0luc2VydCkgeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgICAgIHNlY3Rpb25Ub0luc2VydC5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScsIHRydWUpO1xuXG4gICAgICAgIGlmKHNlY3Rpb25Ub0luc2VydC5vbk1hcmt1cENsZWFuaW5nRmluc2hlZCkge1xuICAgICAgICAgICAgc2VjdGlvblRvSW5zZXJ0Lm9uTWFya3VwQ2xlYW5pbmdGaW5zaGVkKHNlY3Rpb25Ub0luc2VydCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihhcmdzLmFjdG9yKSB7XG4gICAgICAgICAgICBzZWN0aW9uVG9JbnNlcnQuY2xhc3NMaXN0LmFkZCgnZm9jdXNlZC1ieS1hcGktYWN0b3InICsgYXJncy5hY3Rvci5pZCArICctZmJhYWVuZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeS5pbnNlcnRTZWN0aW9uKHNlY3Rpb25Ub0luc2VydCk7XG5cbiAgICAgICAgaWYodGhpcy5jb250ZW50RWxlbWVudC5jaGlsZHJlblswXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudEVsZW1lbnQuaW5zZXJ0QmVmb3JlKHNlY3Rpb25Ub0luc2VydCwgdGhpcy5jb250ZW50RWxlbWVudC5jaGlsZHJlblswXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50RWxlbWVudC5hcHBlbmRDaGlsZChzZWN0aW9uVG9JbnNlcnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9pbnNlcnRTZWN0aW9uQWZ0ZXI6IGZ1bmN0aW9uKHByZWRlY2Vzc29yU2VjdGlvbiwgc2VjdGlvblRvSW5zZXJ0LCBhcmdzKSB7XG4gICAgICAgIGlmKCFwcmVkZWNlc3NvclNlY3Rpb24gfHwgIXNlY3Rpb25Ub0luc2VydCkgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgICBzZWN0aW9uVG9JbnNlcnQuc2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnLCB0cnVlKTtcblxuICAgICAgICBpZihzZWN0aW9uVG9JbnNlcnQub25NYXJrdXBDbGVhbmluZ0ZpbnNoZWQpIHtcbiAgICAgICAgICAgIHNlY3Rpb25Ub0luc2VydC5vbk1hcmt1cENsZWFuaW5nRmluc2hlZChzZWN0aW9uVG9JbnNlcnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoYXJncy5hY3Rvcikge1xuICAgICAgICAgICAgc2VjdGlvblRvSW5zZXJ0LmNsYXNzTGlzdC5hZGQoJ2ZvY3VzZWQtYnktYXBpLWFjdG9yJysgYXJncy5hY3Rvci5pZCArICctZmJhYWVuZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeS5pbnNlcnRTZWN0aW9uKHNlY3Rpb25Ub0luc2VydCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRFbGVtZW50Lmluc2VydEJlZm9yZShzZWN0aW9uVG9JbnNlcnQsIHByZWRlY2Vzc29yU2VjdGlvbi5uZXh0U2libGluZyk7ICAgLy8gaWYgcHJlZGVjZXNzb3JTZWN0aW9uLm5leHRTaWJsaW5nIGlzIG51bGwsIHRoZSBuZXdOb2RlIGlzIGluc2VydGVkIGF0IHRoZSBlbmQgb2YgdGhlIGxpc3Qgb2YgY2hpbGQgbm9kZXMuXG4gICAgfSxcblxuICAgIF9pbnNlcnRTZWN0aW9uQmVmb3JlOiBmdW5jdGlvbihwcmVkZWNlc3NvclNlY3Rpb24sIHNlY3Rpb25Ub0luc2VydCwgYXJncykge1xuICAgICAgICBpZighcHJlZGVjZXNzb3JTZWN0aW9uIHx8ICFzZWN0aW9uVG9JbnNlcnQpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgICAgc2VjdGlvblRvSW5zZXJ0LnNldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJywgdHJ1ZSk7XG5cbiAgICAgICAgaWYoc2VjdGlvblRvSW5zZXJ0Lm9uTWFya3VwQ2xlYW5pbmdGaW5zaGVkKSB7XG4gICAgICAgICAgICBzZWN0aW9uVG9JbnNlcnQub25NYXJrdXBDbGVhbmluZ0ZpbnNoZWQoc2VjdGlvblRvSW5zZXJ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGFyZ3MuYWN0b3IpIHtcbiAgICAgICAgICAgIHNlY3Rpb25Ub0luc2VydC5jbGFzc0xpc3QuYWRkKCdmb2N1c2VkLWJ5LWFwaS1hY3RvcicrIGFyZ3MuYWN0b3IuaWQgKyAnLWZiYWFlbmQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubW9kaWZpY2F0aW9uTG9nRW50cnkuaW5zZXJ0U2VjdGlvbihzZWN0aW9uVG9JbnNlcnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50RWxlbWVudC5pbnNlcnRCZWZvcmUoc2VjdGlvblRvSW5zZXJ0LCBwcmVkZWNlc3NvclNlY3Rpb24pOyAgIC8vIGlmIHByZWRlY2Vzc29yU2VjdGlvbi5uZXh0U2libGluZyBpcyBudWxsLCB0aGUgbmV3Tm9kZSBpcyBpbnNlcnRlZCBhdCB0aGUgZW5kIG9mIHRoZSBsaXN0IG9mIGNoaWxkIG5vZGVzLlxuICAgIH0sXG5cbiAgICBfaXNTYW1lU2VjdGlvblR5cGU6IGZ1bmN0aW9uKHNlY3Rpb24xLCBzZWN0aW9uMikge1xuICAgICAgICBpZighc2VjdGlvbjEgfHwgIXNlY3Rpb24yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2FtZUNsYXNzZXMgPSBzZWN0aW9uMS5jbGFzc0xpc3QudG9TdHJpbmcoKS5yZXBsYWNlKC9mb2N1c2VkLWJ5LWFwaS1hY3Rvci4qLWZiYWFlbmQvZywgJycpLnJlcGxhY2UoL2ZvY3VzZWQvZywgJycpLnJlcGxhY2UoL1xccy9nLCAnJykgPT09IHNlY3Rpb24yLmNsYXNzTGlzdC50b1N0cmluZygpLnJlcGxhY2UoL2ZvY3VzZWQtYnktYXBpLWFjdG9yLiotZmJhYWVuZC9nLCAnJykucmVwbGFjZSgvZm9jdXNlZC9nLCAnJykucmVwbGFjZSgvXFxzL2csICcnKSxcbiAgICAgICAgICBzYW1lVGFncyA9IHNlY3Rpb24xLnRhZ05hbWUgPT09IHNlY3Rpb24yLnRhZ05hbWU7XG5cbiAgICAgICAgcmV0dXJuIHNhbWVUYWdzICYmIHNhbWVDbGFzc2VzO1xuICAgIH0sXG5cbiAgICBfZ2V0U2VjdGlvbkF0dHJpYnV0ZVNpZ25pdHVyZTogZnVuY3Rpb24oc2VjdGlvbikge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoT2JqZWN0LnZhbHVlcyhzZWN0aW9uLmF0dHJpYnV0ZXMpXG4gICAgICAgICAgICAuZmlsdGVyKGF0dHIgPT4gYXR0ci5uYW1lICE9PSAnY2xhc3MnICYmIGF0dHIubmFtZSAhPT0gJ2NvbnRlbnRlZGl0YWJsZScpXG4gICAgICAgICAgICAubWFwKGF0dHIgPT4gKHsgW2F0dHIubmFtZV06IGF0dHIudmFsdWUgfSkpKVxuICAgIH0sXG5cbiAgICBfYXJlRXF1YWxTZWN0aW9uczogZnVuY3Rpb24oc2VjdGlvbjEsIHNlY3Rpb24yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1NhbWVTZWN0aW9uVHlwZShzZWN0aW9uMSwgc2VjdGlvbjIpICYmXG4gICAgICAgICAgICBzZWN0aW9uMS5pbm5lckhUTUwubGVuZ3RoID09PSBzZWN0aW9uMi5pbm5lckhUTUwubGVuZ3RoICYmXG4gICAgICAgICAgICB0aGlzLl9nZXRTZWN0aW9uQXR0cmlidXRlU2lnbml0dXJlKHNlY3Rpb24xKSA9PT0gdGhpcy5fZ2V0U2VjdGlvbkF0dHJpYnV0ZVNpZ25pdHVyZShzZWN0aW9uMikgJiZcbiAgICAgICAgICAgIHNlY3Rpb24xLmlubmVySFRNTCA9PT0gc2VjdGlvbjIuaW5uZXJIVE1MXG4gICAgfSxcblxuICAgIF9yZXBsYWNlU2VjdGlvbnM6IGZ1bmN0aW9uKG9sZFNlY3Rpb24sIG5ld1NlY3Rpb24sIGFyZ3MpIHtcbiAgICAgICAgbmV3U2VjdGlvbi5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScsIHRydWUpO1xuXG4gICAgICAgIG9sZFNlY3Rpb24uc3VtbWFyaXplZENvbnRlbnRMZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgICAgIG5ld1NlY3Rpb24uc3VtbWFyaXplZENvbnRlbnRMZW5ndGggPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYodGhpcy5faXNTYW1lU2VjdGlvblR5cGUob2xkU2VjdGlvbiwgbmV3U2VjdGlvbikpIHtcbiAgICAgICAgICAgIHV0aWxzLmNvcHlFdmVudExpc3RlbmVyc1JlY3Vyc2l2ZWx5KG9sZFNlY3Rpb24sIG5ld1NlY3Rpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYobmV3U2VjdGlvbi5vbk1hcmt1cENsZWFuaW5nRmluc2hlZCkge1xuICAgICAgICAgICAgbmV3U2VjdGlvbi5vbk1hcmt1cENsZWFuaW5nRmluc2hlZChuZXdTZWN0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCF0aGlzLl9hcmVFcXVhbFNlY3Rpb25zKG5ld1NlY3Rpb24sIG9sZFNlY3Rpb24pIHx8IChuZXdTZWN0aW9uICYmIG5ld1NlY3Rpb24uY2hpbGROb2Rlcy5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmaWNhdGlvbkxvZ0VudHJ5LnJlcGxhY2VTZWN0aW9uKG9sZFNlY3Rpb24sIG5ld1NlY3Rpb24pO1xuXG4gICAgICAgICAgICBpZihhcmdzLmFjdG9yKSB7XG4gICAgICAgICAgICAgICAgbmV3U2VjdGlvbi5jbGFzc0xpc3QuYWRkKCdmb2N1c2VkLWJ5LWFwaS1hY3RvcicrIGFyZ3MuYWN0b3IuaWQgKyAnLWZiYWFlbmQnKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGhUaWxsU2VjdGlvblN0YXJ0ID0gYXJncy5jYXJldC5nZXRDb250ZW50TGVuZ3RoVGlsbFNlY3Rpb24ob2xkU2VjdGlvbik7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlmZiA9IGRpZmZFbmdpbmVcbiAgICAgICAgICAgICAgICAgICAgLmRpZmZfbWFpbihhcmdzLmNhcmV0Ll9nZXRDb250ZW50TGVuZ3RoSW5jcmVtZW50TWFza2VkVGV4dChvbGRTZWN0aW9uKSwgYXJncy5jYXJldC5fZ2V0Q29udGVudExlbmd0aEluY3JlbWVudE1hc2tlZFRleHQobmV3U2VjdGlvbikpXG4gICAgICAgICAgICAgICAgICAgIC5mbGF0TWFwKGEgPT4gYVsxXS5zcGxpdCgnJykubWFwKGlhID0+IGFbMF0pKTtcblxuICAgICAgICAgICAgICAgIGlmKGFyZ3MuY2FyZXQucmFuZ2VTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3Rpb25TdGFydE9mZnNldFdpdGhpblNlY3Rpb24gPSBhcmdzLmNhcmV0LnJhbmdlU3RhcnQgLSBjb250ZW50TGVuZ3RoVGlsbFNlY3Rpb25TdGFydDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeS5pbnNlcnRlZEJlZm9yZVNlbGVjdGlvblJhbmdlU3RhcnQgKz0gZGlmZlxuICAgICAgICAgICAgICAgICAgICAgICAgLnNsaWNlKDAsIHNlbGVjdGlvblN0YXJ0T2Zmc2V0V2l0aGluU2VjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MgKyB2YWwsIDApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKGFyZ3MuY2FyZXQucmFuZ2VFbmQgJiYgYXJncy5jYXJldC5yYW5nZUVuZCAhPT0gYXJncy5jYXJldC5yYW5nZVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvblN0YXJ0T2Zmc2V0V2l0aGluU2VjdGlvbiA9IGFyZ3MuY2FyZXQucmFuZ2VFbmQgLSBjb250ZW50TGVuZ3RoVGlsbFNlY3Rpb25TdGFydDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeS5pbnNlcnRlZEJlZm9yZVNlbGVjdGlvblJhbmdlRW5kICs9IGRpZmZcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zbGljZSgwLCBzZWxlY3Rpb25TdGFydE9mZnNldFdpdGhpblNlY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjICsgdmFsLCAwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoYXJncy5jYXJldC5yYW5nZUVuZCA9PT0gYXJncy5jYXJldC5yYW5nZVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9kaWZpY2F0aW9uTG9nRW50cnkuaW5zZXJ0ZWRCZWZvcmVTZWxlY3Rpb25SYW5nZUVuZCA9IHRoaXMubW9kaWZpY2F0aW9uTG9nRW50cnkuaW5zZXJ0ZWRCZWZvcmVTZWxlY3Rpb25SYW5nZVN0YXJ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jb250ZW50RWxlbWVudC5yZXBsYWNlQ2hpbGQobmV3U2VjdGlvbiwgb2xkU2VjdGlvbik7XG5cbiAgICAgICAgICAgIGlmKG9sZFNlY3Rpb24gPT09IHRoaXMuZm9jdXNlZFNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmaWNhdGlvbkxvZ0VudHJ5LmZvY3VzZWRTZWN0aW9uSGFzQmVlbk1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGlmaWNhdGlvbkxvZ0VudHJ5LmZvY3VzZWRTZWN0aW9uUmVwbGFjZW1lbnQgPSBuZXdTZWN0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3U2VjdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmKG9sZFNlY3Rpb24ub3JpZ2luYWxIVE1MICE9PSBuZXdTZWN0aW9uLm9yaWdpbmFsSFRNTCkge1xuICAgICAgICAgICAgLy8gd2UgZW5kIHVwIGluIHRoaXMgYnJhbmNoIHdoZW4gd2Ugc2ltcGx5IHR5cGUgdGV4dCBpbnRvIGEgc2VjdGlvbi5cbiAgICAgICAgICAgIC8vIGluIHRoaXMgY2FzZSB0aGUgYWN0dWFsIERPTSBpcyBhbHJlYWR5IG9uIHRoZSBhY3R1YWwgc3RhdGUsIG9ubHlcbiAgICAgICAgICAgIC8vIHRoZSBvcmlnaW5hbEhUTUwgYXR0cmlidXRlIG11c3QgYmUgdXBkYXRlZC5cbiAgICAgICAgICAgIHRoaXMubW9kaWZpY2F0aW9uTG9nRW50cnkucmVwbGFjZVNlY3Rpb24ob2xkU2VjdGlvbiwgbmV3U2VjdGlvbik7XG5cbiAgICAgICAgICAgIG9sZFNlY3Rpb24ub3JpZ2luYWxIVE1MID0gbmV3U2VjdGlvbi5vcmlnaW5hbEhUTUw7XG5cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMubW9kaWZpY2F0aW9uTG9nRW50cnkubW9kTG9nRmxhZ3MpLmZvckVhY2goZnVuY3Rpb24oZmxhZykge1xuICAgICAgICAgICAgICAgIG9sZFNlY3Rpb25bJ29yaWdpbmFsSFRNTENvbnRhaW5zJyArIGZsYWddID0gbmV3U2VjdGlvblsnb3JpZ2luYWxIVE1MQ29udGFpbnMnICsgZmxhZ107XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYob2xkU2VjdGlvbiA9PT0gdGhpcy5mb2N1c2VkU2VjdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZpY2F0aW9uTG9nRW50cnkuZm9jdXNlZFNlY3Rpb25IYXNCZWVuTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMubW9kaWZpY2F0aW9uTG9nRW50cnkuZm9jdXNlZFNlY3Rpb25ET01XYXNOb3RNb2RpZmllZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeS5mb2N1c2VkU2VjdGlvblJlcGxhY2VtZW50ID0gbmV3U2VjdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2xkU2VjdGlvbi53b3JkQ291bnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXR1cm4gb2xkU2VjdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubW9kaWZpY2F0aW9uTG9nRW50cnkucmV0YWluU2VjdGlvbihvbGRTZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIG9sZFNlY3Rpb247XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERvY3VtZW50dXBkYXRlcjtcbiIsInZhciBkaWZmTWF0Y2hQYXRjaCA9IHJlcXVpcmUoJ2RpZmZfbWF0Y2hfcGF0Y2gnKSxcbiAgICBkaWZmRW5naW5lID0gbmV3IGRpZmZNYXRjaFBhdGNoLmRpZmZfbWF0Y2hfcGF0Y2g7XG5cbnZhciBESUZGX0RFTEVURSA9IC0xO1xudmFyIERJRkZfSU5TRVJUID0gMTtcbnZhciBESUZGX0VRVUFMID0gMDtcblxuZnVuY3Rpb24gTW9kaWZpY2F0aW9uTG9nRW50cnkoKSB7XG4gICAgdGhpcy5sb2cgPSBbXTtcbn1cblxuTW9kaWZpY2F0aW9uTG9nRW50cnkucHJvdG90eXBlID0ge1xuXG4gICAgc2V0RmxhZ3NGb3I6IGZ1bmN0aW9uKHNlY3Rpb24pIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgbW9kTG9nRmxhZ3MgPSB0aGlzLm1vZExvZ0ZsYWdzO1xuXG4gICAgICAgIGlmKCFtb2RMb2dGbGFncykgeyByZXR1cm47IH1cblxuICAgICAgICBPYmplY3Qua2V5cyhtb2RMb2dGbGFncykuZm9yRWFjaChmdW5jdGlvbihmbGFnKSB7XG4gICAgICAgICAgICBpZihzZWxmWydtaWdodEluY2x1ZGUnICsgZmxhZyArICdVcGRhdGVzJ10pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHNlY3Rpb25bJ29yaWdpbmFsSFRNTENvbnRhaW5zJyArIGZsYWddKSB7XG4gICAgICAgICAgICAgICAgc2VsZlsnbWlnaHRJbmNsdWRlJyArIGZsYWcgKyAnVXBkYXRlcyddID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGZbJ21pZ2h0SW5jbHVkZScgKyBmbGFnICsgJ1VwZGF0ZXMnXSA9IG1vZExvZ0ZsYWdzW2ZsYWddLnNvbWUoZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VjdGlvbi5tYXRjaGVzKHNlbGVjdG9yKSB8fCBzZWN0aW9uLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHRvQ2hhbmdlc2V0OiBmdW5jdGlvbihDaGFuZ2VzZXQpIHtcbiAgICAgICAgdmFyIGNzID0gQ2hhbmdlc2V0LmNyZWF0ZSgpO1xuICAgICAgICB2YXIgd2FzTGFzdE9wVHlwZVJldGFpbiA9IGZhbHNlLCBsYXN0T3B0VHlwZUxlbmd0aCA9IDA7XG5cbiAgICAgICAgdGhpcy5sb2cuZm9yRWFjaChmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICAgICAgaWYoZW50cnkudHlwZSA9PT0gJ3JldGFpbicpIHtcbiAgICAgICAgICAgICAgICB3YXNMYXN0T3BUeXBlUmV0YWluID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBsYXN0T3B0VHlwZUxlbmd0aCArPSBlbnRyeS5zZWN0aW9uSFRNTC5sZW5ndGg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHdhc0xhc3RPcFR5cGVSZXRhaW4pIHtcbiAgICAgICAgICAgICAgICBjcy5yZXRhaW4obGFzdE9wdFR5cGVMZW5ndGgpO1xuICAgICAgICAgICAgICAgIHdhc0xhc3RPcFR5cGVSZXRhaW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBsYXN0T3B0VHlwZUxlbmd0aCA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbnRyeS50eXBlID09PSAnZGVsZXRlJykge1xuICAgICAgICAgICAgICAgIGNzLmRlbGV0ZShlbnRyeS5zZWN0aW9uSFRNTCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVudHJ5LnR5cGUgPT09ICdpbnNlcnQnKSB7XG4gICAgICAgICAgICAgICAgY3MuaW5zZXJ0KGVudHJ5LnNlY3Rpb25IVE1MKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZW50cnkudHlwZSA9PT0gJ3JlcGxhY2UnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpZmYgPSBkaWZmRW5naW5lLmRpZmZfbWFpbihlbnRyeS5vbGRTZWN0aW9uSFRNTCwgZW50cnkubmV3U2VjdGlvbkhUTUwpO1xuXG4gICAgICAgICAgICAgICAgZGlmZi5mb3JFYWNoKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKERJRkZfREVMRVRFID09IGRbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzLmRlbGV0ZShkWzFdKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKERJRkZfSU5TRVJUID09IGRbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzLmluc2VydChkWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmKERJRkZfRVFVQUwgPT0gZFswXSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNzLnJldGFpbihkWzFdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHdhc0xhc3RPcFR5cGVSZXRhaW4pIHtcbiAgICAgICAgICAgIGNzLnJldGFpbihsYXN0T3B0VHlwZUxlbmd0aCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3MuZW5kKCk7XG4gICAgfSxcblxuICAgIGFmdGVyU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgIHRoaXMubG9nLmZvckVhY2goZnVuY3Rpb24obG9nKSB7XG4gICAgICAgICAgICBpZihsb2cudHlwZSA9PT0gJ3JldGFpbicgfHwgbG9nLnR5cGUgPT09ICdpbnNlcnQnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGxvZy5zZWN0aW9uSFRNTDtcbiAgICAgICAgICAgIH0gZWxzZSBpZihsb2cudHlwZSA9PT0gJ3JlcGxhY2UnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGxvZy5uZXdTZWN0aW9uSFRNTDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYmVmb3JlU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgIHRoaXMubG9nLmZvckVhY2goZnVuY3Rpb24obG9nKSB7XG4gICAgICAgICAgICBpZihsb2cudHlwZSA9PT0gJ3JldGFpbicgfHwgbG9nLnR5cGUgPT09ICdkZWxldGUnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGxvZy5zZWN0aW9uSFRNTDtcbiAgICAgICAgICAgIH0gZWxzZSBpZihsb2cudHlwZSA9PT0gJ3JlcGxhY2UnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGxvZy5vbGRTZWN0aW9uSFRNTDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgcmV0YWluU2VjdGlvbjogZnVuY3Rpb24oc2VjdGlvbikge1xuICAgICAgICB0aGlzLmxvZy5wdXNoKHt0eXBlOiAncmV0YWluJywgc2VjdGlvbkhUTUw6IHNlY3Rpb24ub3JpZ2luYWxIVE1MfSk7XG4gICAgfSxcblxuICAgIGRlbGV0ZVNlY3Rpb246IGZ1bmN0aW9uKHNlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5sb2cucHVzaCh7dHlwZTogJ2RlbGV0ZScsIHNlY3Rpb25IVE1MOiBzZWN0aW9uLm9yaWdpbmFsSFRNTH0pO1xuICAgICAgICB0aGlzLnNldEZsYWdzRm9yKHNlY3Rpb24pO1xuICAgIH0sXG5cbiAgICByZXBsYWNlU2VjdGlvbjogZnVuY3Rpb24ob2xkU2VjLCBuZXdTZWMpIHtcbiAgICAgICAgdGhpcy5sb2cucHVzaCh7dHlwZTogJ3JlcGxhY2UnLCBvbGRTZWN0aW9uSFRNTDogb2xkU2VjLm9yaWdpbmFsSFRNTCwgbmV3U2VjdGlvbkhUTUw6IG5ld1NlYy5vcmlnaW5hbEhUTUx9KTtcbiAgICAgICAgdGhpcy5zZXRGbGFnc0ZvcihuZXdTZWMpO1xuICAgICAgICB0aGlzLnNldEZsYWdzRm9yKG9sZFNlYyk7XG4gICAgfSxcblxuICAgIGluc2VydFNlY3Rpb246IGZ1bmN0aW9uKHNlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5sb2cucHVzaCh7dHlwZTogJ2luc2VydCcsIHNlY3Rpb25IVE1MOiBzZWN0aW9uLm9yaWdpbmFsSFRNTH0pXG4gICAgICAgIHRoaXMuc2V0RmxhZ3NGb3Ioc2VjdGlvbik7XG4gICAgfSxcblxuICAgIGRlbGV0ZVNlY3Rpb25BdDogZnVuY3Rpb24oaW5kZXgsIHNlY3Rpb24pIHtcbiAgICAgICAgdmFyIG9sZExvZztcblxuICAgICAgICBpZih0aGlzLmxvZ1tpbmRleF0gJiYgdGhpcy5sb2dbaW5kZXhdLnR5cGUgIT09ICdpbnNlcnQnKSB7XG4gICAgICAgICAgICBvbGRMb2cgPSB0aGlzLmxvZ1tpbmRleF07XG4gICAgICAgICAgICB0aGlzLmxvZ1tpbmRleF0gPSB7IHR5cGU6ICdkZWxldGUnLCBzZWN0aW9uSFRNTDogdGhpcy5sb2dbaW5kZXhdLm9sZFNlY3Rpb25IVE1MIHx8IHRoaXMubG9nW2luZGV4XS5zZWN0aW9uSFRNTCB9O1xuICAgICAgICB9IGVsc2UgaWYodGhpcy5sb2dbaW5kZXhdICYmIHRoaXMubG9nW2luZGV4XS50eXBlID09PSAnaW5zZXJ0Jykge1xuICAgICAgICAgICAgb2xkTG9nID0gdGhpcy5sb2cuc3BsaWNlKGluZGV4LCAxKVswXTsgLy9yZW1vdmUgYXJyYXkgZWxlbWVudCB3aXRoIGluZGV4IFwiaW5kZXhcIlxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRGbGFnc0ZvcihzZWN0aW9uKTtcblxuICAgICAgICByZXR1cm4gb2xkTG9nO1xuICAgIH0sXG5cbiAgICByZXRhaW5BbGxTZWN0aW9uc0JlZm9yZTogZnVuY3Rpb24oc2VjdGlvbikge1xuICAgICAgICBpZighc2VjdGlvbikgcmV0dXJuO1xuICAgICAgICB2YXIgdG1wU2VjID0gc2VjdGlvbi5wYXJlbnRFbGVtZW50LmNoaWxkcmVuWzBdO1xuICAgICAgICB3aGlsZSh0bXBTZWMgIT09IHNlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMucmV0YWluU2VjdGlvbih0bXBTZWMpO1xuICAgICAgICAgICAgdG1wU2VjID0gdG1wU2VjLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJldGFpbkFsbFNlY3Rpb25zQWZ0ZXI6IGZ1bmN0aW9uKHNlY3Rpb24pIHtcbiAgICAgICAgaWYoIXNlY3Rpb24pIHJldHVybjtcbiAgICAgICAgdmFyIHRtcFNlYyA9IHNlY3Rpb24ubmV4dFNpYmxpbmc7XG4gICAgICAgIHdoaWxlKHRtcFNlYykge1xuICAgICAgICAgICAgdGhpcy5yZXRhaW5TZWN0aW9uKHRtcFNlYyk7XG4gICAgICAgICAgICB0bXBTZWMgPSB0bXBTZWMubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaW5jbHVkZXNIZWFkaW5nVXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5pbmNsdWRlc0hlYWRpbmdVcGRhdGVzO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTW9kaWZpY2F0aW9uTG9nRW50cnk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICB2YXIgbmV4dFZhbHVlID0gc3RyZWFtLm5leHQoKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY29uc3QgdGhpc1JvdW5kID0gbmV4dFZhbHVlO1xuICAgICAgICAgICAgbmV4dFZhbHVlID0gc3RyZWFtLm5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzUm91bmQ7XG4gICAgICAgIH0sXG4gICAgICAgIGxvb2thaGVhZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dFZhbHVlXG4gICAgICAgIH1cbiAgICB9O1xufSIsInZhciBTdGF0ZU1hY2hpbmUgPSByZXF1aXJlKCcuL3N0YXRlX21hY2hpbmUuanMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3BpeGVsc2NodWJzZXIvdXRpbHMnKTtcbnZhciBuYW1lZEVuY29kaW5ncyA9IHtxdW90OiAzNCwgYW1wOiAzOCwgbHQ6IDYwLCBndDogNjIsIG5ic3A6IDE2MCwgY29weTogMTY5LCByZWc6IDE3NCwgZGVnOiAxNzYsIGZyYXNsOiA0NywgdHJhZGU6IDg0ODIsIGV1cm86IDgzNjQsIEFncmF2ZTogMTkyLCBBYWN1dGU6IDE5MywgQWNpcmM6IDE5NCwgQXRpbGRlOiAxOTUsIEF1bWw6IDE5NiwgQXJpbmc6IDE5NywgQUVsaWc6IDE5OCwgQ2NlZGlsOiAxOTksIEVncmF2ZTogMjAwLCBFYWN1dGU6IDIwMSwgRWNpcmM6IDIwMiwgRXVtbDogMjAzLCBJZ3JhdmU6IDIwNCwgSWFjdXRlOiAyMDUsIEljaXJjOiAyMDYsIEl1bWw6IDIwNywgRVRIOiAyMDgsIE50aWxkZTogMjA5LCBPZ3JhdmU6IDIxMCwgT2FjdXRlOiAyMTEsIE9jaXJjOiAyMTIsIE90aWxkZTogMjEzLCBPdW1sOiAyMTQsIHRpbWVzOiAyMTUsIE9zbGFzaDogMjE2LCBVZ3JhdmU6IDIxNywgVWFjdXRlOiAyMTgsIFVjaXJjOiAyMTksIFV1bWw6IDIyMCwgWWFjdXRlOiAyMjEsIFRIT1JOOiAyMjIsIHN6bGlnOiAyMjMsIGFncmF2ZTogMjI0LCBhYWN1dGU6IDIyNSwgYWNpcmM6IDIyNiwgYXRpbGRlOiAyMjcsIGF1bWw6IDIyOCwgYXJpbmc6IDIyOSwgYWVsaWc6IDIzMCwgY2NlZGlsOiAyMzEsIGVncmF2ZTogMjMyLCBlYWN1dGU6IDIzMywgZWNpcmM6IDIzNCwgZXVtbDogMjM1LCBpZ3JhdmU6IDIzNiwgaWFjdXRlOiAyMzcsIGljaXJjOiAyMzgsIGl1bWw6IDIzOSwgZXRoOiAyNDAsIG50aWxkZTogMjQxLCBvZ3JhdmU6IDI0Miwgb2FjdXRlOiAyNDMsIG9jaXJjOiAyNDQsIG90aWxkZTogMjQ1LCBvdW1sOiAyNDYsIGRpdmlkZTogMjQ3LCBvc2xhc2g6IDI0OCwgdWdyYXZlOiAyNDksIHVhY3V0ZTogMjUwLCB1Y2lyYzogMjUxLCB1dW1sOiAyNTIsIHlhY3V0ZTogMjUzLCB0aG9ybjogMjU0LCB5dW1sOiAyNTUsIGxzcXVvOiA4MjE2LCByc3F1bzogODIxNywgc2JxdW86IDgyMTgsIGxkcXVvOiA4MjIwLCByZHF1bzogODIyMSwgYmRxdW86IDgyMjIsIGRhZ2dlcjogODIyNCwgRGFnZ2VyOiA4MjI1LCBwZXJtaWw6IDgyNDAsIGxzYXF1bzogODI0OSwgcnNhcXVvOiA4MjUwLCBzcGFkZXM6IDk4MjQsIGNsdWJzOiA5ODI3LCBoZWFydHM6IDk4MjksIGRpYW1zOiA5ODMwLCBvbGluZTogODI1NCwgbGFycjogODU5MiwgdWFycjogODU5MywgcmFycjogODU5NCwgZGFycjogODU5NSwgaGVsbGlwOiAxMzMsIG5kYXNoOiAxNTAsIG1kYXNoOiAxNTEsIGlleGNsOiAxNjEsIGNlbnQ6IDE2MiwgcG91bmQ6IDE2MywgY3VycmVuOiAxNjQsIHllbjogMTY1LCBicnZiYXI6IDE2NiwgYnJrYmFyOiAxNjYsIHNlY3Q6IDE2NywgdW1sOiAxNjgsIGRpZTogMTY4LCBvcmRmOiAxNzAsIGxhcXVvOiAxNzEsIG5vdDogMTcyLCBzaHk6IDE3MywgbWFjcjogMTc1LCBoaWJhcjogMTc1LCBwbHVzbW46IDE3Nywgc3VwMjogMTc4LCBzdXAzOiAxNzksIGFjdXRlOiAxODAsIG1pY3JvOiAxODEsIHBhcmE6IDE4MiwgbWlkZG90OiAxODMsIGNlZGlsOiAxODQsIHN1cDE6IDE4NSwgb3JkbTogMTg2LCByYXF1bzogMTg3LCBmcmFjMTQ6IDE4OCwgZnJhYzEyOiAxODksIGZyYWMzNDogMTkwLCBpcXVlc3Q6IDE5MSwgQWxwaGE6IDkxMywgYWxwaGE6IDk0NSwgQmV0YTogOTE0LCBiZXRhOiA5NDYsIEdhbW1hOiA5MTUsIGdhbW1hOiA5NDcsIERlbHRhOiA5MTYsIGRlbHRhOiA5NDgsIEVwc2lsb246IDkxNywgZXBzaWxvbjogOTQ5LCBaZXRhOiA5MTgsIHpldGE6IDk1MCwgRXRhOiA5MTksIGV0YTogOTUxLCBUaGV0YTogOTIwLCB0aGV0YTogOTUyLCBJb3RhOiA5MjEsIGlvdGE6IDk1MywgS2FwcGE6IDkyMiwga2FwcGE6IDk1NCwgTGFtYmRhOiA5MjMsIGxhbWJkYTogOTU1LCBNdTogOTI0LCBtdTogOTU2LCBOdTogOTI1LCBudTogOTU3LCBYaTogOTI2LCB4aTogOTU4LCBPbWljcm9uOiA5MjcsIG9taWNyb246IDk1OSwgUGk6IDkyOCwgcGk6IDk2MCwgUmhvOiA5MjksIHJobzogOTYxLCBTaWdtYTogOTMxLCBzaWdtYTogOTYzLCBUYXU6IDkzMiwgdGF1OiA5NjQsIFVwc2lsb246IDkzMywgdXBzaWxvbjogOTY1LCBQaGk6IDkzNCwgcGhpOiA5NjYsIENoaTogOTM1LCBjaGk6IDk2NywgUHNpOiA5MzYsIHBzaTogOTY4LCBPbWVnYTogOTM3LCBvbWVnYTogOTY5fTtcblxuZnVuY3Rpb24gSFRNTFJhem9yKHRhZ1RyYW5zZm9ybWF0aW9ucywgcnVsZXMpIHtcbiAgICB0aGlzLnRhZ1RyYW5zZm9ybWF0aW9ucyA9IHRhZ1RyYW5zZm9ybWF0aW9ucyAgfHwge307XG4gICAgdGhpcy5ydWxlcyA9IHJ1bGVzO1xuICAgIHRoaXMucnVsZU5hbWVCeUVsZW1lbnRDYWNoZSA9IHt9O1xuICAgIHRoaXMucnVsZU5hbWVCeVRva2VuQ2FjaGUgPSB7fTtcbiAgICB0aGlzLnRhZ1RyYW5zZm9ybWF0aW9uQnlOb2RlQ2FjaGUgPSB7fTtcbiAgICB0aGlzLnN0YXRlTWFjaGluZSA9IG5ldyBTdGF0ZU1hY2hpbmUoKTtcbiAgICB0aGlzLnRlbXByb2FyeVBydW5lUHJvdGVjdGVkV2hpdGVzcGFjZSA9ICdcXHUyNTg4Jztcbn1cblxuSFRNTFJhem9yLnByb3RvdHlwZSA9IHtcblxuICAgIGdldFJ1bGVOYW1lc0J5VGFnOiBmdW5jdGlvbih0YWdOYW1lKSB7XG4gICAgICAgIHRoaXMucnVsZUVudHJpZXMgPSB0aGlzLnJ1bGVFbnRyaWVzIHx8IE9iamVjdC5lbnRyaWVzKHRoaXMucnVsZXMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnJ1bGVFbnRyaWVzLmZpbHRlcihmdW5jdGlvbihydWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gcnVsZVsxXS50YWdOYW1lID09PSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0pLm1hcChmdW5jdGlvbihydWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gcnVsZVswXTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGRvZXNFbGVtZW50TWF0Y2hSdWxlOiBmdW5jdGlvbihlbGVtZW50LCBydWxlKSB7XG4gICAgICAgIGlmKCFlbGVtZW50IHx8ICFydWxlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmKHJ1bGUudGFnTmFtZSAhPT0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmKHJ1bGUuY2xhc3NOYW1lICYmICFlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhydWxlLmNsYXNzTmFtZSkpIHJldHVybiBmYWxzZTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgZG9lc0VsZW1lbnRNYXRjaE9uZVJ1bGU6IGZ1bmN0aW9uKGVsZW1lbnQsIHJ1bGVOYW1lcykge1xuICAgICAgICBmb3IobGV0IGk9MDsgaTxydWxlTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmKHRoaXMuZG9lc0VsZW1lbnRNYXRjaFJ1bGUoZWxlbWVudCwgdGhpcy5ydWxlc1tydWxlTmFtZXNbaV1dKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgbG9va3VwUnVsZU5hbWVDYWNoZUZvcjogZnVuY3Rpb24odCkge1xuICAgICAgICBpZih0Lm5vZGVOYW1lICYmIHRoaXMucnVsZU5hbWVCeUVsZW1lbnRDYWNoZVt0Lm5vZGVOYW1lXSAmJiB0aGlzLnJ1bGVOYW1lQnlFbGVtZW50Q2FjaGVbdC5ub2RlTmFtZV1bdC5jbGFzc05hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ydWxlTmFtZUJ5RWxlbWVudENhY2hlW3Qubm9kZU5hbWVdW3QuY2xhc3NOYW1lXTtcbiAgICAgICAgfSBlbHNlIGlmKHRoaXMucnVsZU5hbWVCeVRva2VuQ2FjaGVbdC52YWx1ZV0gJiYgdGhpcy5ydWxlTmFtZUJ5VG9rZW5DYWNoZVt0LnZhbHVlXSl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ydWxlTmFtZUJ5VG9rZW5DYWNoZVt0LnZhbHVlXVt0LmNsYXNzTmFtZXNdO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNhY2hlUnVsZU5hbWVGb3I6IGZ1bmN0aW9uKHQsIHJlc3VsdCkge1xuXG4gICAgICAgIGlmKCFyZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHQgPSAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHQubm9kZU5hbWUpIHtcbiAgICAgICAgICAgIGlmKCF0aGlzLnJ1bGVOYW1lQnlFbGVtZW50Q2FjaGVbdC5ub2RlTmFtZV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bGVOYW1lQnlFbGVtZW50Q2FjaGVbdC5ub2RlTmFtZV0gPSB7fVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnJ1bGVOYW1lQnlFbGVtZW50Q2FjaGVbdC5ub2RlTmFtZV1bdC5jbGFzc05hbWVdID0gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYoIXRoaXMucnVsZU5hbWVCeVRva2VuQ2FjaGVbdC52YWx1ZV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bGVOYW1lQnlUb2tlbkNhY2hlW3QudmFsdWVdID0ge31cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5ydWxlTmFtZUJ5VG9rZW5DYWNoZVt0LnZhbHVlXVt0LmNsYXNzTmFtZXNdID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldFJ1bGVOYW1lQnlFbGVtZW50OiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHZhciBydWxlcyA9IHRoaXMucnVsZXMsXG4gICAgICAgICAgICByZXN1bHQsIHRva2VuQ2xhc3NOYW1lcywgcmVzdWx0Q2FuZGlkYXRlcywgdG1wUmVzdWx0O1xuXG4gICAgICAgIGlmKCF0KSByZXR1cm47XG4gICAgICAgIGlmKHQubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSByZXR1cm4gJyN0ZXh0JztcblxuICAgICAgICByZXN1bHQgPSB0aGlzLmxvb2t1cFJ1bGVOYW1lQ2FjaGVGb3IodCk7XG4gICAgICAgIGlmKHJlc3VsdCA9PT0gLTEpIHJldHVybjtcbiAgICAgICAgaWYocmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgIHRva2VuQ2xhc3NOYW1lcyA9ICh0ICYmIHQuYXR0cmlidXRlcyAmJiB0LmF0dHJpYnV0ZXNbJ2NsYXNzTmFtZXMnXSkgfHwgdC5jbGFzc0xpc3QgfHwgW107XG4gICAgICAgIHJlc3VsdENhbmRpZGF0ZXMgPSB0aGlzLmdldFJ1bGVOYW1lc0J5VGFnKHQudmFsdWUgfHwgdC5ub2RlTmFtZSk7XG5cbiAgICAgICAgaWYodG9rZW5DbGFzc05hbWVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgdG1wUmVzdWx0ID0gcmVzdWx0Q2FuZGlkYXRlcy5maW5kKGZ1bmN0aW9uKHJjKSB7XG4gICAgICAgICAgICAgICAgaWYoIXJ1bGVzW3JjXS5jbGFzc05hbWUpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPHRva2VuQ2xhc3NOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZihydWxlc1tyY10uY2xhc3NOYW1lID09PSB0b2tlbkNsYXNzTmFtZXNbaV0pIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gdG1wUmVzdWx0IHx8IHJlc3VsdENhbmRpZGF0ZXMuZmluZChmdW5jdGlvbihyYykge1xuICAgICAgICAgICAgcmV0dXJuICFydWxlc1tyY10uY2xhc3NOYW1lO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmNhY2hlUnVsZU5hbWVGb3IodCwgcmVzdWx0KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBnZXRSdWxlQnlFbGVtZW50OiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJ1bGVzW3RoaXMuZ2V0UnVsZU5hbWVCeUVsZW1lbnQoZWxlbWVudCldO1xuICAgIH0sXG5cbiAgICBpc1Rva2VuQWxsb3dlZFRvQmVSb290RWxlbWVudDogZnVuY3Rpb24odCkge1xuICAgICAgICB2YXIgcnVsZSA9IHRoaXMucnVsZXMgJiYgdGhpcy5ydWxlc1t0aGlzLmdldFJ1bGVOYW1lQnlFbGVtZW50KHQpXTtcbiAgICAgICAgcmV0dXJuIHJ1bGUgJiYgcnVsZS5hbGxvd2VkVG9CZVJvb3Q7XG4gICAgfSxcblxuICAgIGlzVG9rZW5BbGxvd2VkVG9Db250YWluSXRzZWxmOiBmdW5jdGlvbih0KSB7XG4gICAgICB2YXIgcnVsZU5hbWUgPSB0aGlzLmdldFJ1bGVOYW1lQnlFbGVtZW50KHQpLFxuICAgICAgICAgIHJ1bGUgPSB0aGlzLnJ1bGVzICYmIHRoaXMucnVsZXNbcnVsZU5hbWVdO1xuXG4gICAgICAgIGlmKCFydWxlLmFsbG93ZWRDaGlsZHJlbikgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gcnVsZS5hbGxvd2VkQ2hpbGRyZW4uaW5kZXhPZihydWxlTmFtZSkgIT09IC0xO1xuICAgIH0sXG5cbiAgICByb290RWxlbWVudHNTaG91bGROb3RCcmVha091dEZyb206IGZ1bmN0aW9uKHBhcmVudE5vZGUpIHtcbiAgICAgICAgdmFyIHJ1bGUgPSB0aGlzLmdldFJ1bGVCeUVsZW1lbnQocGFyZW50Tm9kZSk7XG4gICAgICAgIGlmKCFydWxlKSB7IHJldHVybiBmYWxzZSB9XG5cbiAgICAgICAgcmV0dXJuICEhcnVsZS5kb05vdEJyZWFrT3V0Um9vdEVsZW1lbnRzO1xuICAgIH0sXG5cbiAgICBjYWNoZVRhZ1RyYW5zZm9ybWF0aW9uRm9yOiBmdW5jdGlvbih0b2tlblBhdGhJblBhcnNlZFRyZWUsIHJlc3VsdCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQgfHwgLTE7XG4gICAgICAgIHRoaXMudGFnVHJhbnNmb3JtYXRpb25CeU5vZGVDYWNoZVt0b2tlblBhdGhJblBhcnNlZFRyZWVdID0gcmVzdWx0O1xuICAgICAgICByZXR1cm4gcmVzdWx0ID09IC0xID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICAgIH0sXG5cbiAgICBsb29ja3VwVGFnVHJhbnNmb3JtYXRpb25DYWNoZUZvcjogZnVuY3Rpb24odG9rZW5QYXRoSW5QYXJzZWRUcmVlLCBjbGFzc0xpc3QpIHtcbiAgICAgICAgaWYoY2xhc3NMaXN0ICYmIGNsYXNzTGlzdC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMudGFnVHJhbnNmb3JtYXRpb25CeU5vZGVDYWNoZVt0b2tlblBhdGhJblBhcnNlZFRyZWVdID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy50YWdUcmFuc2Zvcm1hdGlvbkJ5Tm9kZUNhY2hlW3Rva2VuUGF0aEluUGFyc2VkVHJlZV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRhZ1RyYW5zZm9ybWF0aW9uQnlOb2RlQ2FjaGVbdG9rZW5QYXRoSW5QYXJzZWRUcmVlXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB0YWdUcmFuc2Zvcm1hdGlvbkJ5Tm9kZTogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBjbGFzc0xpc3QgPSBub2RlLmNsYXNzTGlzdCxcbiAgICAgICAgICAgIG9yaU5vZGUgPSBub2RlLFxuICAgICAgICAgICAgdG9rZW5QYXRoSW5QYXJzZWRUcmVlID0gJycsXG4gICAgICAgICAgICBtYXRjaGVzQnlQYXRoID0gW10sXG4gICAgICAgICAgICBrZXlzID0gT2JqZWN0LmtleXModGhpcy50YWdUcmFuc2Zvcm1hdGlvbnMpLFxuICAgICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgICAgdGssIHNwbGl0O1xuXG4gICAgICAgIGlmKCFvcmlOb2RlLmNsYXNzTGlzdCkgeyBvcmlOb2RlLmNsYXNzTGlzdCA9IFtdIH1cblxuICAgICAgICB3aGlsZShub2RlKSB7XG4gICAgICAgICAgICBpZihub2RlLnRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgICB0b2tlblBhdGhJblBhcnNlZFRyZWUgPSAnLycgKyBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSArIHRva2VuUGF0aEluUGFyc2VkVHJlZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZihub2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSl7XG4gICAgICAgICAgICAgICAgdG9rZW5QYXRoSW5QYXJzZWRUcmVlID0gJy8jdGV4dCcgKyB0b2tlblBhdGhJblBhcnNlZFRyZWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSB0aGlzLmxvb2NrdXBUYWdUcmFuc2Zvcm1hdGlvbkNhY2hlRm9yKHRva2VuUGF0aEluUGFyc2VkVHJlZSwgY2xhc3NMaXN0KVxuXG4gICAgICAgIGlmKHJlc3VsdCA9PT0gLTEpIHtyZXR1cm59XG4gICAgICAgIGlmKHJlc3VsdCkge3JldHVybiByZXN1bHR9XG5cbiAgICAgICAgZm9yKHZhciBpPTA7IGk8a2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGsgPSBrZXlzW2ldO1xuICAgICAgICAgICAgc3BsaXQgPSB0ay5zcGxpdCgnLicpO1xuXG4gICAgICAgICAgICBpZihzcGxpdFswXSA9PT0gdG9rZW5QYXRoSW5QYXJzZWRUcmVlKSB7XG4gICAgICAgICAgICAgICAgaWYoIXNwbGl0WzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXNCeVBhdGgucHVzaCh0aylcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYob3JpTm9kZS5jbGFzc0xpc3QuY29udGFpbnMoc3BsaXRbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRhZ1RyYW5zZm9ybWF0aW9uc1t0a107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGYuY2FjaGVUYWdUcmFuc2Zvcm1hdGlvbkZvcihcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5QYXRoSW5QYXJzZWRUcmVlLFxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzQnlQYXRoWzBdID8gdGhpcy50YWdUcmFuc2Zvcm1hdGlvbnNbbWF0Y2hlc0J5UGF0aFswXV0gOiAtMSk7XG4gICAgfSxcblxuICAgIGlzTm9kZUFsbG93ZWRUb0JlUm9vdEVsZW1lbnQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIHJ1bGUgPSB0aGlzLnJ1bGVzW3RoaXMuZ2V0UnVsZU5hbWVCeUVsZW1lbnQobm9kZSldO1xuICAgICAgICByZXR1cm4gcnVsZSAmJiBydWxlLmFsbG93ZWRUb0JlUm9vdDtcbiAgICB9LFxuXG4gICAgaXNOb2RlRm9yYmlkZGVuQnlBbGxvd2VkQ2hpbGRyZW5EZWZpbml0aW9uOiBmdW5jdGlvbihyb290RWxlbWVudCwgY2hpbGROb2RlUnVsZU5hbWUsIHBhcmVudEVsZW1lbnRSdWxlKSB7XG4gICAgICAgIHBhcmVudEVsZW1lbnRSdWxlID0gcGFyZW50RWxlbWVudFJ1bGUgfHwgdGhpcy5nZXRSdWxlQnlFbGVtZW50KHJvb3RFbGVtZW50KTtcbiAgICAgICAgaWYoIWNoaWxkTm9kZVJ1bGVOYW1lKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmKCFwYXJlbnRFbGVtZW50UnVsZS5hbGxvd2VkQ2hpbGRyZW4pIHJldHVybiBmYWxzZTtcblxuICAgICAgICByZXR1cm4gcGFyZW50RWxlbWVudFJ1bGUuYWxsb3dlZENoaWxkcmVuLmluZGV4T2YoY2hpbGROb2RlUnVsZU5hbWUpID09PSAtMVxuICAgIH0sXG5cbiAgICBpc05vZGVGb3JiaWRkZW5CeUNhcmRpbmFsaXR5RGVmaW5pdGlvbjogZnVuY3Rpb24oY2FyZGluYWxpdGllcywgY2hpbGROb2RlUnVsZU5hbWUsIHBhcmVudEVsZW1lbnRSdWxlKSB7XG4gICAgICAgIHZhciBtYXhBbGxvd2VkO1xuXG4gICAgICAgIGNhcmRpbmFsaXRpZXNbY2hpbGROb2RlUnVsZU5hbWVdID0gY2FyZGluYWxpdGllc1tjaGlsZE5vZGVSdWxlTmFtZV0gfHwgMDtcblxuICAgICAgICBtYXhBbGxvd2VkID0gcGFyZW50RWxlbWVudFJ1bGUgJiZcbiAgICAgICAgICAgICAgICAgICAgIHBhcmVudEVsZW1lbnRSdWxlLmNoaWxkcmVuQ2FyZGluYWxpdHkgJiZcbiAgICAgICAgICAgICAgICAgICAgIHBhcmVudEVsZW1lbnRSdWxlLmNoaWxkcmVuQ2FyZGluYWxpdHlbY2hpbGROb2RlUnVsZU5hbWVdICYmXG4gICAgICAgICAgICAgICAgICAgICBwYXJlbnRFbGVtZW50UnVsZS5jaGlsZHJlbkNhcmRpbmFsaXR5W2NoaWxkTm9kZVJ1bGVOYW1lXS5tYXg7XG5cbiAgICAgICAgaWYoIW1heEFsbG93ZWQpIHJldHVybiBmYWxzZTtcblxuICAgICAgICByZXR1cm4gbWF4QWxsb3dlZCA8PSBjYXJkaW5hbGl0aWVzW2NoaWxkTm9kZVJ1bGVOYW1lXTtcbiAgICB9LFxuXG4gICAgZ2V0Um9vdE5vZGVPZjogZnVuY3Rpb24obm9kZSkgIHtcbiAgICAgICAgdmFyIHJvb3QgPSBub2RlO1xuXG4gICAgICAgIHdoaWxlKHJvb3QgJiYgcm9vdC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICByb290ID0gcm9vdC5wYXJlbnROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfSxcblxuICAgIGNyZWF0ZURPTUVsZW1lbnRGcm9tVG9rZW46IGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcywgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodG9rZW4udmFsdWUpO1xuICAgICAgICBPYmplY3Qua2V5cyh0b2tlbi5hdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgaWYoa2V5ID09PSAnY2xhc3NOYW1lcycpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCB0b2tlbi5hdHRyaWJ1dGVzW2tleV0uam9pbignICcpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCBzZWxmLnN0cmlwKHRva2VuLmF0dHJpYnV0ZXNba2V5XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9LFxuXG4gICAgY2xvbmVET01FbGVtZW50QW5kQ2hhbmdlVGFnTmFtZTogZnVuY3Rpb24obm9kZSwgdGFnTmFtZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcblxuICAgICAgICByZXN1bHQuYXR0cmlidXRlcyA9IG5vZGUuYXR0cmlidXRlcztcblxuICAgICAgICBmb3IodmFyIGk9MDsgaTxub2RlLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5zZXRBdHRyaWJ1dGUobm9kZS5hdHRyaWJ1dGVzW2ldLm5hbWUsIG5vZGUuYXR0cmlidXRlc1tpXS52YWx1ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5pbm5lckhUTUwgPSBub2RlLmlubmVySFRNTDtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBzdHJpcDogZnVuY3Rpb24oaHRtbCkge1xuICAgICAgICBpZighaHRtbC5yZXBsYWNlKSB7IHJldHVybiBodG1sIH1cblxuICAgICAgICByZXR1cm4gaHRtbC5yZXBsYWNlKC8mIz8oXFx3Kyk7L2csIGZ1bmN0aW9uKG1hdGNoLCBkZWMpIHtcbiAgICAgICAgICAgIGlmKGlzTmFOKGRlYykgJiYgbmFtZWRFbmNvZGluZ3NbZGVjXSkge1xuICAgICAgICAgICAgICAgIGRlYyA9IG5hbWVkRW5jb2RpbmdzW2RlY107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGRlYyk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICB0b2tlbml6ZUhUTUw6IGZ1bmN0aW9uKihodG1sKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdGVNYWNoaW5lLnJlc2V0U3RhdGVNYWNoaW5lKCk7XG4gICAgICAgIGZvcihsZXQgaT0wOyBpPD1odG1sLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMuc3RhdGVNYWNoaW5lLnByb2Nlc3MoaHRtbFtpXSB8fCAnRU9GJyk7XG4gICAgICAgICAgICBpZih0b2tlbikgeyB5aWVsZCB0b2tlbjsgdG9rZW4gPSBudWxsIH07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgYnVpbGRUcmVlczogZnVuY3Rpb24qKGh0bWwpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgdG9rZW5TdHJlYW0gPSB0aGlzLnRva2VuaXplSFRNTChodG1sKSxcbiAgICAgICAgICAgIHRva2VuID0gbnVsbCxcbiAgICAgICAgICAgIG5ld0NoaWxkID0gbnVsbCxcbiAgICAgICAgICAgIGN1cnJlbnROb2RlSW5UcmVlID0gbnVsbCxcbiAgICAgICAgICAgIHRtcEhhbmRsZXJSZXN1bHQgPSBudWxsO1xuXG4gICAgICAgIHZhciB0b2tlbkhhbmRsZXIgPSAge1xuICAgICAgICAgICAgT1BFTl9UQUc6IGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICAgICAgICAgIGlmKFsnYnInLCAnaW1nJywgJ2lucHV0J10uaW5kZXhPZih0b2tlbi52YWx1ZS50b0xvd2VyQ2FzZSgpKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuSGFuZGxlclsnRU1QVFlfVEFHJ10odG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG5ld0NoaWxkID0gc2VsZi5jcmVhdGVET01FbGVtZW50RnJvbVRva2VuKHRva2VuKTtcblxuICAgICAgICAgICAgICAgIGlmKGN1cnJlbnROb2RlSW5UcmVlICYmXG4gICAgICAgICAgICAgICAgICAgc2VsZi5pc1Rva2VuQWxsb3dlZFRvQmVSb290RWxlbWVudCh0b2tlbikgJiZcbiAgICAgICAgICAgICAgICAgICAhc2VsZi5pc1Rva2VuQWxsb3dlZFRvQ29udGFpbkl0c2VsZih0b2tlbikgJiZcbiAgICAgICAgICAgICAgICAgICAhc2VsZi5yb290RWxlbWVudHNTaG91bGROb3RCcmVha091dEZyb20oY3VycmVudE5vZGVJblRyZWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNlbGYuZ2V0Um9vdE5vZGVPZihjdXJyZW50Tm9kZUluVHJlZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlSW5UcmVlID0gbmV3Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKGN1cnJlbnROb2RlSW5UcmVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlSW5UcmVlLmFwcGVuZENoaWxkKG5ld0NoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGVJblRyZWUgPSBuZXdDaGlsZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZUluVHJlZSA9IG5ld0NoaWxkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIENMT1NFX1RBRzogZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgICAgICAgICBpZighY3VycmVudE5vZGVJblRyZWUpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIHZhciB0bXBDdXJyZW50Tm9kZUluVHJlZTtcblxuICAgICAgICAgICAgICAgIGlmKGN1cnJlbnROb2RlSW5UcmVlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGVJblRyZWUgPSBjdXJyZW50Tm9kZUluVHJlZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcEN1cnJlbnROb2RlSW5UcmVlID0gY3VycmVudE5vZGVJblRyZWU7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlSW5UcmVlID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICBpZih0bXBDdXJyZW50Tm9kZUluVHJlZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT09IHRva2VuLnZhbHVlICYmIHRva2VuLnZhbHVlICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG1wQ3VycmVudE5vZGVJblRyZWUgPSBzZWxmLmNsb25lRE9NRWxlbWVudEFuZENoYW5nZVRhZ05hbWUodG1wQ3VycmVudE5vZGVJblRyZWUsIHRva2VuLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0bXBDdXJyZW50Tm9kZUluVHJlZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBFTVBUWV9UQUc6IGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgbmV3Q2hpbGQgPSBzZWxmLmNyZWF0ZURPTUVsZW1lbnRGcm9tVG9rZW4odG9rZW4pO1xuXG4gICAgICAgICAgICAgICAgaWYoY3VycmVudE5vZGVJblRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGVJblRyZWUuYXBwZW5kQ2hpbGQobmV3Q2hpbGQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdDaGlsZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBURVhUOiBmdW5jdGlvbih0b2tlbikge1xuICAgICAgICAgICAgICAgIG5ld0NoaWxkID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc2VsZi5zdHJpcCh0b2tlbi52YWx1ZSkpO1xuXG4gICAgICAgICAgICAgICAgaWYoIWN1cnJlbnROb2RlSW5UcmVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRva2VuLnZhbHVlLnRyaW0oKS5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGVJblRyZWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlSW5UcmVlLmFwcGVuZENoaWxkKG5ld0NoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlKHRva2VuID0gdG9rZW5TdHJlYW0ubmV4dCgpLnZhbHVlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRtcEhhbmRsZXJSZXN1bHQgPSB0b2tlbkhhbmRsZXJbdG9rZW4udHlwZV0odG9rZW4pO1xuICAgICAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgICAgIHRva2VuID0gdG9rZW5TdHJlYW0ubmV4dCgpLnZhbHVlO1xuICAgICAgICAgICAgICAgIHRtcEhhbmRsZXJSZXN1bHQgPSB0b2tlbkhhbmRsZXJbdG9rZW4udHlwZV0odG9rZW4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZih0bXBIYW5kbGVyUmVzdWx0KSB5aWVsZCB0bXBIYW5kbGVyUmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoY3VycmVudE5vZGVJblRyZWUpIHtcbiAgICAgICAgICAgIHlpZWxkIHNlbGYuZ2V0Um9vdE5vZGVPZihjdXJyZW50Tm9kZUluVHJlZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdHJhbnNmb3JtVHJlZVdpdGhSZXJ1bnM6IGZ1bmN0aW9uKHJvb3RFbGVtZW50LCB0cmFuc1J1bGUsIGNsYXNzTmFtZSwgbW9kTG9nKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIHJlcyA9IHRoaXMudHJhbnNmb3JtVHJlZShyb290RWxlbWVudCwgdHJhbnNSdWxlLCBjbGFzc05hbWUsIG1vZExvZyk7XG5cbiAgICAgICAgaWYoQXJyYXkuaXNBcnJheShyZXMpKSB7XG4gICAgICAgICAgICByZXMgPSByZXMubWFwKGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi50cmFuc2Zvcm1UcmVlV2l0aFJlcnVucyhyLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgbW9kTG9nKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXMgPSByZXMucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjLmNvbmNhdCh2YWwpLCBbXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG5cbiAgICAvLyByZXR1cm5zIGFuIGFycmF5IG9mIERPTSBlbGVtZW50cyB3aGljaCBzaG91bGQgcmVwbGFjZSB0aGUgcGFzc2VkIGVsZW1lbnRcbiAgICB0cmFuc2Zvcm1UcmVlOiBmdW5jdGlvbihyb290RWxlbWVudCwgdHJhbnNSdWxlLCBjbGFzc05hbWUsIG1vZExvZykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICB0cmFuc1J1bGVXaXRoQ2xhc3MgPSB0aGlzLnRhZ1RyYW5zZm9ybWF0aW9uQnlOb2RlKHJvb3RFbGVtZW50KSxcbiAgICAgICAgICAgIHRyYW5zUnVsZUFyLCB0b1J1bGVDb25kaWRhdGVzLCBuZXdDb250ZW50LFxuICAgICAgICAgICAgbm9ybWFsaXplZElubmVyVGV4dCwgcHJhZWZpeFRvQmVSZXBsYWNlZCwgcHJhZWZpeE1hdGNoLCBkaXJlY3RpdmVQYXJhbXMsXG4gICAgICAgICAgICB0b1RyYW5zZm9ybWF0aW9uLCB0bXBEaXJlY3RpdmVQYXJhbXM7XG5cbiAgICAgICAgbW9kTG9nID0gbW9kTG9nIHx8IHt9O1xuICAgICAgICBtb2RMb2cuZGVsZXRlZENoYXJzQnlNYXJrdXBUcmFuc2Zvcm1hdGlvbnMgPSBtb2RMb2cuZGVsZXRlZENoYXJzQnlNYXJrdXBUcmFuc2Zvcm1hdGlvbnMgfHwgMDtcblxuICAgICAgICBpZighQXJyYXkuaXNBcnJheSh0cmFuc1J1bGVXaXRoQ2xhc3MpKSB7XG4gICAgICAgICAgICB0cmFuc1J1bGVBciA9IHRyYW5zUnVsZVdpdGhDbGFzcyA/IHRyYW5zUnVsZVdpdGhDbGFzcy5zcGxpdCgnLicpIDogW107XG4gICAgICAgICAgICB0cmFuc1J1bGUgPSB0cmFuc1J1bGUgfHwgdHJhbnNSdWxlQXJbMF07XG4gICAgICAgICAgICBjbGFzc05hbWUgPSBjbGFzc05hbWUgfHwgdHJhbnNSdWxlQXJbMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cmFuc1J1bGUgPSB0cmFuc1J1bGUgfHwgdHJhbnNSdWxlV2l0aENsYXNzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYW5zUnVsZSA9PT0gJyNjb250ZW50Jykge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20ocm9vdEVsZW1lbnQuY2hpbGROb2RlcylcbiAgICAgICAgfSBlbHNlIGlmICh0cmFuc1J1bGUgPT09ICcjbm8tY29udGVudCcpIHtcbiAgICAgICAgICAgIHJvb3RFbGVtZW50LmlubmVySFRNTCA9ICcnO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3RFbGVtZW50O1xuICAgICAgICB9IGVsc2UgaWYgKHRyYW5zUnVsZSA9PT0gJyN0ZXh0LWNvbnRlbnQnKSB7XG4gICAgICAgICAgICByb290RWxlbWVudC5pbm5lckhUTUwgPSByb290RWxlbWVudC5pbm5lclRleHQucmVwbGFjZSgvPC9nLCAnJmx0OycpLnJlcGxhY2UoLz4vZywgJyZndDsnKTtcbiAgICAgICAgICAgIHJldHVybiByb290RWxlbWVudDtcbiAgICAgICAgfSBlbHNlIGlmICh0cmFuc1J1bGUgJiYgcm9vdEVsZW1lbnQubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICAvL3RleHQgbm9kZSBpbiB0aGUgbGVmdCBwYXJ0IG9mIHRoZSBydWxlIGlzIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgfSBlbHNlIGlmKEFycmF5LmlzQXJyYXkodHJhbnNSdWxlKSkge1xuICAgICAgICAgICAgZm9yKGxldCBpPTA7IGk8dHJhbnNSdWxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZElubmVyVGV4dCA9IHJvb3RFbGVtZW50LmlubmVyVGV4dC5yZXBsYWNlKG5ldyBSZWdFeHAoU3RyaW5nLmZyb21DaGFyQ29kZSgxNjApLFwiZ1wiKSwgJyAnKTtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkSW5uZXJUZXh0ID0gbm9ybWFsaXplZElubmVyVGV4dC5yZXBsYWNlKHRoaXMudGVtcHJvYXJ5UHJ1bmVQcm90ZWN0ZWRXaGl0ZXNwYWNlLCAnICcpO1xuICAgICAgICAgICAgICAgIHByYWVmaXhNYXRjaCA9IG5vcm1hbGl6ZWRJbm5lclRleHQubWF0Y2gobmV3IFJlZ0V4cCgnXicgKyB0cmFuc1J1bGVbaV0ucHJhZWZpeCArICcoXFxcXCgoLio/KVxcXFwpKT9cXFxccycpKTtcblxuICAgICAgICAgICAgICAgIGlmKHByYWVmaXhNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBwcmFlZml4VG9CZVJlcGxhY2VkID0gcHJhZWZpeE1hdGNoWzBdO1xuICAgICAgICAgICAgICAgICAgICBpZihwcmFlZml4TWF0Y2hbMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGl2ZVBhcmFtcyA9IHByYWVmaXhNYXRjaFsyXS5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbihlKSB7IHJldHVybiBlLnRyaW0oKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGl2ZVBhcmFtcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdG9UcmFuc2Zvcm1hdGlvbiA9IHRyYW5zUnVsZVtpXS50by5zcGxpdCgvXFwofFxcKS8pWzBdO1xuICAgICAgICAgICAgICAgICAgICB0bXBEaXJlY3RpdmVQYXJhbXMgPSB0cmFuc1J1bGVbaV0udG8uc3BsaXQoL1xcKHxcXCkvKVsxXTtcblxuICAgICAgICAgICAgICAgICAgICBpZih0bXBEaXJlY3RpdmVQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcERpcmVjdGl2ZVBhcmFtcyA9IHRtcERpcmVjdGl2ZVBhcmFtcy5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbihlKSB7IHJldHVybiBlLnRyaW0oKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGl2ZVBhcmFtcyA9IGRpcmVjdGl2ZVBhcmFtcy5jb25jYXQodG1wRGlyZWN0aXZlUGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRvUnVsZUNvbmRpZGF0ZXMgPSB0aGlzLmdldFJ1bGVOYW1lc0J5VGFnKHRvVHJhbnNmb3JtYXRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihydWxlTmFtZSkgeyByZXR1cm4gc2VsZi5ydWxlc1tydWxlTmFtZV0gfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKHJ1bGUpIHsgcmV0dXJuIHJ1bGUuYWxsb3dlZFRvQmVSb290ICYmIHJ1bGUuYnVpbGRFbXB0eUVsZW1lbnQgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgbmV3Q29udGVudCA9IHJvb3RFbGVtZW50LmlubmVySFRNTC5yZXBsYWNlKCcmbmJzcDsnLCAnICcpLnJlcGxhY2UodGhpcy50ZW1wcm9hcnlQcnVuZVByb3RlY3RlZFdoaXRlc3BhY2UsICcgJykucmVwbGFjZShwcmFlZml4VG9CZVJlcGxhY2VkLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIG1vZExvZy5kZWxldGVkQ2hhcnNCeU1hcmt1cFRyYW5zZm9ybWF0aW9ucyArPSBwcmFlZml4VG9CZVJlcGxhY2VkLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgbW9kTG9nLmNoYW5nZVNlY3Rpb25UeXBlID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICBpZih0b1J1bGVDb25kaWRhdGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdEVsZW1lbnQgPSB0b1J1bGVDb25kaWRhdGVzWzBdLmJ1aWxkRW1wdHlFbGVtZW50KG5ld0NvbnRlbnQsIGRpcmVjdGl2ZVBhcmFtcywgdG9SdWxlQ29uZGlkYXRlc1swXSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb290RWxlbWVudCA9IHRoaXMuY2xvbmVET01FbGVtZW50QW5kQ2hhbmdlVGFnTmFtZShyb290RWxlbWVudCwgdG9UcmFuc2Zvcm1hdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICByb290RWxlbWVudC5pbm5lckhUTUwgPSBuZXdDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYodHJhbnNSdWxlKSB7XG4gICAgICAgICAgICByb290RWxlbWVudCA9IHRoaXMuY2xvbmVET01FbGVtZW50QW5kQ2hhbmdlVGFnTmFtZShyb290RWxlbWVudCwgdHJhbnNSdWxlKTtcbiAgICAgICAgICAgIGlmKGNsYXNzTmFtZSkgcm9vdEVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpXG4gICAgICAgIH1cblxuICAgICAgICBpZihyb290RWxlbWVudC5jaGlsZE5vZGVzKSB7XG4gICAgICAgICAgICBmb3IobGV0IGk9MDsgaTxyb290RWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgICB0cmFuc1J1bGVXaXRoQ2xhc3MgPSB0aGlzLnRhZ1RyYW5zZm9ybWF0aW9uQnlOb2RlKHJvb3RFbGVtZW50LmNoaWxkTm9kZXNbaV0pO1xuICAgICAgICAgICAgICAgIHRyYW5zUnVsZUFyID0gdHJhbnNSdWxlV2l0aENsYXNzID8gdHJhbnNSdWxlV2l0aENsYXNzLnNwbGl0KCcuJykgOiBbXTtcbiAgICAgICAgICAgICAgICB0cmFuc1J1bGUgPSB0cmFuc1J1bGVBclswXTtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWUgPSB0cmFuc1J1bGVBclsxXTtcblxuICAgICAgICAgICAgICAgIGlmKHRyYW5zUnVsZSA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXMgPSBbcm9vdEVsZW1lbnQsIHJvb3RFbGVtZW50LnJlbW92ZUNoaWxkKHJvb3RFbGVtZW50LmNoaWxkTm9kZXNbaV0pXVxuXG4gICAgICAgICAgICAgICAgICAgIGlmKHJvb3RFbGVtZW50LmNoaWxkTm9kZXNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXdFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQocm9vdEVsZW1lbnQudGFnTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZShyb290RWxlbWVudC5jaGlsZE5vZGVzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RWwuYXBwZW5kQ2hpbGQocm9vdEVsZW1lbnQucmVtb3ZlQ2hpbGQocm9vdEVsZW1lbnQuY2hpbGROb2Rlc1tpXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKG5ld0VsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmKHJvb3RFbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKHRyYW5zUnVsZSAmJiB0cmFuc1J1bGVbMF0gPT09ICc9JykgIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlcyA9IFtyb290RWxlbWVudCwgcm9vdEVsZW1lbnQucmVtb3ZlQ2hpbGQocm9vdEVsZW1lbnQuY2hpbGROb2Rlc1tpXSldO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3RWxlbWVudFRhZ05hbWUgPSB0cmFuc1J1bGUuc3Vic3RyaW5nKDEsIHRyYW5zUnVsZS5sZW5ndGgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmV3RWxlbWVudFRhZ05hbWUgPT09ICcnID8gcm9vdEVsZW1lbnQudGFnTmFtZSA6IG5ld0VsZW1lbnRUYWdOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdXRpbHMuY29weU5vZGVBdHRyaWJ1dGVzKHJvb3RFbGVtZW50LCBuZXdFbCwgWydjbGFzcyddKTtcblxuICAgICAgICAgICAgICAgICAgICB3aGlsZShyb290RWxlbWVudC5jaGlsZE5vZGVzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdFbC5hcHBlbmRDaGlsZChyb290RWxlbWVudC5yZW1vdmVDaGlsZChyb290RWxlbWVudC5jaGlsZE5vZGVzW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKG5ld0VsKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzID0gdGhpcy50cmFuc2Zvcm1UcmVlKHJvb3RFbGVtZW50LmNoaWxkTm9kZXNbaV0sIHRyYW5zUnVsZSwgY2xhc3NOYW1lLCBtb2RMb2cpO1xuICAgICAgICAgICAgICAgICAgICBpZihyZXMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdEVsZW1lbnQuY2hpbGROb2Rlc1tpXS5yZXBsYWNlV2l0aCguLi5yZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb290RWxlbWVudC5jaGlsZE5vZGVzW2ldLnJlcGxhY2VXaXRoKHJlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcm9vdEVsZW1lbnQ7XG4gICAgfSxcblxuICAgIGNsZWFudXBDbGFzc0F0dHJpYnRlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciBydWxlID0gdGhpcy5nZXRSdWxlQnlFbGVtZW50KG5vZGUpLFxuICAgICAgICAgICAgY2xhc3NOYW1lc1RvUmVtb3ZlID0gW107XG5cbiAgICAgICAgaWYocnVsZSAmJiBydWxlLmFsbG93ZWRDbGFzc05hbWVzKSB7XG4gICAgICAgICAgICBmb3IobGV0IGk9MDsgaTxub2RlLmNsYXNzTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmKHJ1bGUuYWxsb3dlZENsYXNzTmFtZXMuaW5kZXhPZihub2RlLmNsYXNzTGlzdFtpXSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXNUb1JlbW92ZS5wdXNoKG5vZGUuY2xhc3NMaXN0W2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGFzc05hbWVzVG9SZW1vdmUuZm9yRWFjaChmdW5jdGlvbihjbikge25vZGUuY2xhc3NMaXN0LnJlbW92ZShjbik7fSlcbiAgICAgICAgfSBlbHNlIGlmIChydWxlICYmIG5vZGUuYXR0cmlidXRlcyAmJiBub2RlLmF0dHJpYnV0ZXMuY2xhc3MpIHtcbiAgICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNsZWFudXBOb2RlQXR0cmlidXRlczogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAvLyBmaXJzdCBjaGVjayB3aGV0aGVyIHRoZSBjbGVhbmluZyBwcm9jZXNzIHdpbGwgcmVtb3ZlIHRoZSBjbGFzcyBhdHRyaWJ1dGVcbiAgICAgICAgdmFyIHJ1bGUgPSB0aGlzLmdldFJ1bGVCeUVsZW1lbnQobm9kZSksXG4gICAgICAgICAgICBhdHRyaWJ1dGVzVG9SZW1vdmUgPSBbXTtcblxuICAgICAgICBpZighcnVsZSkgcmV0dXJuO1xuXG4gICAgICAgIGlmKG5vZGUuYXR0cmlidXRlcykge1xuICAgICAgICAgICAgZm9yKGxldCBpPTA7IGk8bm9kZS5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYoIXJ1bGUuYWxsb3dlZEF0dHJpYnV0ZXMgfHxcbiAgICAgICAgICAgICAgICAgICBydWxlLmFsbG93ZWRBdHRyaWJ1dGVzLmluZGV4T2Yobm9kZS5hdHRyaWJ1dGVzW2ldLm5hbWUpID09PSAtMSB8fFxuICAgICAgICAgICAgICAgICAgbm9kZS5hdHRyaWJ1dGVzW2ldLnZhbHVlID09PSAnJ1xuICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNUb1JlbW92ZS5wdXNoKG5vZGUuYXR0cmlidXRlc1tpXS5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhdHRyaWJ1dGVzVG9SZW1vdmUuZm9yRWFjaChmdW5jdGlvbihhdHRyKSB7XG4gICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGJ1aWxkRW1wdHlFbGVtZW50QnlSdWxlTmFtZTogZnVuY3Rpb24ocnVsZU5hbWUpIHtcbiAgICAgICAgdmFyIGVsLCBydWxlID0gdGhpcy5ydWxlc1tydWxlTmFtZV07XG5cbiAgICAgICAgaWYocnVsZS5idWlsZEVtcHR5RWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHJ1bGUuYnVpbGRFbXB0eUVsZW1lbnQobnVsbCwgbnVsbCwgcnVsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQocnVsZS50YWdOYW1lKTtcbiAgICAgICAgaWYocnVsZS5jbGFzc05hbWUpIHtcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQocnVsZS5jbGFzc05hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9LFxuXG4gICAgY2xlYW51cFRyZWU6IGZ1bmN0aW9uKHJvb3RFbGVtZW50LCBtb2RpZmljYXRpb25Mb2dFbnRyeSwgcHJldmlvdXNET01UcmVlLCBuZXh0RE9NVHJlZSkge1xuICAgICAgICB0aGlzLmNsZWFudXBDbGFzc0F0dHJpYnRlKHJvb3RFbGVtZW50KTtcbiAgICAgICAgdGhpcy5jbGVhbnVwTm9kZUF0dHJpYnV0ZXMocm9vdEVsZW1lbnQpO1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIHJ1bGVOYW1lID0gdGhpcy5nZXRSdWxlTmFtZUJ5RWxlbWVudChyb290RWxlbWVudCksXG4gICAgICAgICAgICBydWxlID0gdGhpcy5ydWxlc1tydWxlTmFtZV0sXG4gICAgICAgICAgICBjaGlsZE5vZGVSdWxlTmFtZSxcbiAgICAgICAgICAgIGNhcmRpbmFsaXR5TWFwID0ge30sXG4gICAgICAgICAgICByZXN1bHQgPSB7fSxcbiAgICAgICAgICAgIGRlbGV0ZWRDaGFyc0J5TWFya3VwVHJhbnNmb3JtYXRpb25zQ2FsdWxhdGlvbkhlbHBlcixcbiAgICAgICAgICAgIGNUUmVzdWx0O1xuXG4gICAgICAgIGlmKCFydWxlTmFtZSB8fCAocnVsZSAmJiBydWxlLmRlbGV0ZUlmRW1wdHkgJiYgcm9vdEVsZW1lbnQuaW5uZXJUZXh0Lmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHJlbW92ZVRoaXNOb2RlOiB0cnVlIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZihydWxlICYmIHJ1bGUuYnVpbGRBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBydWxlLmJ1aWxkQXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uKGJhKSB7XG4gICAgICAgICAgICAgICAgaWYoIXJvb3RFbGVtZW50Lmhhc0F0dHJpYnV0ZShiYS5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICByb290RWxlbWVudC5zZXRBdHRyaWJ1dGUoYmEubmFtZSwgYmEuYnVpbGQoKSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yKGxldCBpPTA7IGk8cm9vdEVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2hpbGROb2RlUnVsZU5hbWUgPSB0aGlzLmdldFJ1bGVOYW1lQnlFbGVtZW50KHJvb3RFbGVtZW50LmNoaWxkTm9kZXNbaV0pO1xuXG4gICAgICAgICAgICBpZih0aGlzLmlzTm9kZUZvcmJpZGRlbkJ5QWxsb3dlZENoaWxkcmVuRGVmaW5pdGlvbihyb290RWxlbWVudCwgY2hpbGROb2RlUnVsZU5hbWUsIHJ1bGUpIHx8XG4gICAgICAgICAgICAgICB0aGlzLmlzTm9kZUZvcmJpZGRlbkJ5Q2FyZGluYWxpdHlEZWZpbml0aW9uKGNhcmRpbmFsaXR5TWFwLCBjaGlsZE5vZGVSdWxlTmFtZSwgcnVsZSkpIHtcbiAgICAgICAgICAgICAgICByb290RWxlbWVudC5yZW1vdmVDaGlsZChyb290RWxlbWVudC5jaGlsZE5vZGVzW2ktLV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYXJkaW5hbGl0eU1hcFtjaGlsZE5vZGVSdWxlTmFtZV0rKztcblxuICAgICAgICAgICAgICAgIGlmKHJ1bGUucHJ1bmVTcGFjZXMgJiYgcm9vdEVsZW1lbnQuY2hpbGROb2Rlc1tpXS5ub2RlVHlwZSA9PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGVkQ2hhcnNCeU1hcmt1cFRyYW5zZm9ybWF0aW9uc0NhbHVsYXRpb25IZWxwZXIgPSByb290RWxlbWVudC5jaGlsZE5vZGVzW2ldLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RFbGVtZW50LmNoaWxkTm9kZXNbaV0ubm9kZVZhbHVlID0gcm9vdEVsZW1lbnQuY2hpbGROb2Rlc1tpXS5ub2RlVmFsdWUucmVwbGFjZSgvKFxcc3xcXHUwMEEwKSsvZywgJyAnKS5yZXBsYWNlKC9cXHMkLywgJ1xcdTAwQTAnKTtcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpY2F0aW9uTG9nRW50cnkuZGVsZXRlZENoYXJzQnlNYXJrdXBUcmFuc2Zvcm1hdGlvbnMgKz0gKGRlbGV0ZWRDaGFyc0J5TWFya3VwVHJhbnNmb3JtYXRpb25zQ2FsdWxhdGlvbkhlbHBlciAtIHJvb3RFbGVtZW50LmNoaWxkTm9kZXNbaV0ubm9kZVZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYocm9vdEVsZW1lbnQuY2hpbGROb2Rlc1tpXS5ub2RlVHlwZSA9PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgICByb290RWxlbWVudC5jaGlsZE5vZGVzW2ldLm5vZGVWYWx1ZSA9IHJvb3RFbGVtZW50LmNoaWxkTm9kZXNbaV0ubm9kZVZhbHVlLnJlcGxhY2UodGhpcy50ZW1wcm9hcnlQcnVuZVByb3RlY3RlZFdoaXRlc3BhY2UsICdcXHUwMEEwJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY1RSZXN1bHQgPSB0aGlzLmNsZWFudXBUcmVlKHJvb3RFbGVtZW50LmNoaWxkTm9kZXNbaV0sIG1vZGlmaWNhdGlvbkxvZ0VudHJ5KTtcblxuICAgICAgICAgICAgICAgIGlmKGNUUmVzdWx0LnJlbW92ZVRoaXNOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RFbGVtZW50LnJlbW92ZUNoaWxkKHJvb3RFbGVtZW50LmNoaWxkTm9kZXNbaS0tXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYoY1RSZXN1bHQuaW5zZXJ0Tm9kZUFmdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RFbGVtZW50Lmluc2VydEJlZm9yZShjVFJlc3VsdC5pbnNlcnROb2RlQWZ0ZXIsIHJvb3RFbGVtZW50LmNoaWxkTm9kZXNbaV0ubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKGNUUmVzdWx0Lmluc2VydE5vZGVCZWZvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdEVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNUUmVzdWx0Lmluc2VydE5vZGVCZWZvcmUsIHJvb3RFbGVtZW50LmNoaWxkTm9kZXNbaSsrXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYocnVsZSAmJiBydWxlLmFsbG93ZWRTdWNjZXNzb3JzICYmIHJ1bGUuYWxsb3dlZFN1Y2Nlc3NvcnMubGVuZ3RoICE9PSAwICYmICF0aGlzLmRvZXNFbGVtZW50TWF0Y2hPbmVSdWxlKG5leHRET01UcmVlIHx8IHJvb3RFbGVtZW50Lm5leHRTaWJsaW5nLCBydWxlLmFsbG93ZWRTdWNjZXNzb3JzKSkge1xuICAgICAgICAgICAgcmVzdWx0Lmluc2VydE5vZGVBZnRlciA9IHRoaXMuYnVpbGRFbXB0eUVsZW1lbnRCeVJ1bGVOYW1lKHJ1bGUuYWxsb3dlZFN1Y2Nlc3NvcnNbMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYocnVsZSAmJiBydWxlLmFsbG93ZWRQcmVkZWNlc3NvcnMgJiYgcnVsZS5hbGxvd2VkUHJlZGVjZXNzb3JzLmxlbmd0aCAhPT0gMCAmJiAhdGhpcy5kb2VzRWxlbWVudE1hdGNoT25lUnVsZShwcmV2aW91c0RPTVRyZWUgfHwgcm9vdEVsZW1lbnQucHJldmlvdXNTaWJsaW5nLCBydWxlLmFsbG93ZWRQcmVkZWNlc3NvcnMpKSB7XG4gICAgICAgICAgICByZXN1bHQuaW5zZXJ0Tm9kZUJlZm9yZSA9IHRoaXMuYnVpbGRFbXB0eUVsZW1lbnRCeVJ1bGVOYW1lKHJ1bGUuYWxsb3dlZFByZWRlY2Vzc29yc1swXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBIVE1MVG9UcmFuc2Zvcm1lZFRyZWVTdHJlYW06IGZ1bmN0aW9uKihodG1sLCBtb2RpZmljYXRpb25Mb2dFbnRyeSkge1xuICAgICAgICB2YXIgRE9NVHJlZVN0cmVhbSA9IHRoaXMuYnVpbGRUcmVlcyhodG1sKSxcbiAgICAgICAgICAgIERPTVRyZWUgPSBET01UcmVlU3RyZWFtLm5leHQoKS52YWx1ZTtcblxuICAgICAgICB3aGlsZShET01UcmVlKSB7XG4gICAgICAgICAgICBET01UcmVlID0gdGhpcy50cmFuc2Zvcm1UcmVlV2l0aFJlcnVucyhET01UcmVlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgbW9kaWZpY2F0aW9uTG9nRW50cnkpO1xuXG4gICAgICAgICAgICBpZihBcnJheS5pc0FycmF5KERPTVRyZWUpKSB7XG4gICAgICAgICAgICAgICAgZm9yKGxldCBpPTA7IGk8RE9NVHJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBET01UcmVlW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeWllbGQgRE9NVHJlZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgRE9NVHJlZSA9IERPTVRyZWVTdHJlYW0ubmV4dCgpLnZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNsZWFudXBIVE1MOiBmdW5jdGlvbiooaHRtbCwgbW9kaWZpY2F0aW9uTG9nRW50cnkpICB7XG4gICAgICAgIGlmKCFodG1sIHx8IGh0bWwgPT09ICcnKSB7IGh0bWwgPSAnPHA+PC9wPicgfVxuXG4gICAgICAgIG1vZGlmaWNhdGlvbkxvZ0VudHJ5ID0gbW9kaWZpY2F0aW9uTG9nRW50cnkgfHwge31cbiAgICAgICAgbW9kaWZpY2F0aW9uTG9nRW50cnkuZGVsZXRlZENoYXJzQnlNYXJrdXBUcmFuc2Zvcm1hdGlvbnMgPSAwO1xuXG4gICAgICAgIHZhciBET01UcmVlU3RyZWFtID0gdGhpcy5IVE1MVG9UcmFuc2Zvcm1lZFRyZWVTdHJlYW0oaHRtbCwgbW9kaWZpY2F0aW9uTG9nRW50cnkpLFxuICAgICAgICAgICAgY1RSZXN1bHQsXG4gICAgICAgICAgICBwcmV2aW91c0RPTVRyZWUsXG4gICAgICAgICAgICBET01UcmVlID0gRE9NVHJlZVN0cmVhbS5uZXh0KCkudmFsdWUsXG4gICAgICAgICAgICBuZXh0RE9NVHJlZSA9IERPTVRyZWVTdHJlYW0ubmV4dCgpLnZhbHVlO1xuXG4gICAgICAgIHdoaWxlKERPTVRyZWUpIHtcbiAgICAgICAgICAgIGlmKHRoaXMuaXNOb2RlQWxsb3dlZFRvQmVSb290RWxlbWVudChET01UcmVlKSkge1xuICAgICAgICAgICAgICAgIGNUUmVzdWx0ID0gdGhpcy5jbGVhbnVwVHJlZShET01UcmVlLCBtb2RpZmljYXRpb25Mb2dFbnRyeSwgcHJldmlvdXNET01UcmVlLCBuZXh0RE9NVHJlZSk7XG4gICAgICAgICAgICAgICAgaWYoY1RSZXN1bHQuaW5zZXJ0Tm9kZUJlZm9yZSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLm1lbW9yaXplZE5vZGUoY1RSZXN1bHQuaW5zZXJ0Tm9kZUJlZm9yZSwgbW9kaWZpY2F0aW9uTG9nRW50cnkubW9kTG9nRmxhZ3MpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKCFjVFJlc3VsdC5yZW1vdmVUaGlzTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLm1lbW9yaXplZE5vZGUoRE9NVHJlZSwgbW9kaWZpY2F0aW9uTG9nRW50cnkubW9kTG9nRmxhZ3MpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKGNUUmVzdWx0Lmluc2VydE5vZGVBZnRlcikge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLm1lbW9yaXplZE5vZGUoY1RSZXN1bHQuaW5zZXJ0Tm9kZUFmdGVyLCBtb2RpZmljYXRpb25Mb2dFbnRyeS5tb2RMb2dGbGFncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcmV2aW91c0RPTVRyZWUgPSBET01UcmVlO1xuICAgICAgICAgICAgRE9NVHJlZSA9IG5leHRET01UcmVlO1xuICAgICAgICAgICAgbmV4dERPTVRyZWUgPSBET01UcmVlU3RyZWFtLm5leHQoKS52YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZW1vcml6ZWROb2RlOiBmdW5jdGlvbihub2RlLCBtb2RMb2dGbGFncykge1xuXG4gICAgICAgIG1vZExvZ0ZsYWdzID0gbW9kTG9nRmxhZ3MgfHwge307XG4gICAgICAgIG5vZGUub3JpZ2luYWxIVE1MID0gbm9kZS5vdXRlckhUTUw7XG5cbiAgICAgICAgT2JqZWN0LmtleXMobW9kTG9nRmxhZ3MpLmZvckVhY2goZnVuY3Rpb24oZmxhZykge1xuICAgICAgICAgICAgbm9kZVsnb3JpZ2luYWxIVE1MQ29udGFpbnMnICsgZmxhZ10gPSBtb2RMb2dGbGFnc1tmbGFnXS5zb21lKGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUubWF0Y2hlcyhzZWxlY3RvcikgfHwgbm9kZS5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG5cbiAgICBjbGVhbnVwSFRNTEFuZEF0dGFjaEV2ZW50SGFuZGxlcnM6IGZ1bmN0aW9uKihodG1sLCBtb2RpZmljYXRpb25Mb2dFbnRyeSkge1xuICAgICAgICAgIHZhciBET01UcmVlU3RyZWFtID0gdGhpcy5jbGVhbnVwSFRNTChodG1sLCBtb2RpZmljYXRpb25Mb2dFbnRyeSksXG4gICAgICAgICAgICBET01UcmVlID0gRE9NVHJlZVN0cmVhbS5uZXh0KCkudmFsdWUsXG4gICAgICAgICAgICBkdW1teUVsZW1lbnQsIHJ1bGU7XG5cbiAgICAgICAgd2hpbGUoRE9NVHJlZSkge1xuICAgICAgICAgICAgcnVsZSA9IHRoaXMuZ2V0UnVsZUJ5RWxlbWVudChET01UcmVlKTtcbiAgICAgICAgICAgIGlmKHJ1bGUuYnVpbGRFbXB0eUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBkdW1teUVsZW1lbnQgPSBydWxlLmJ1aWxkRW1wdHlFbGVtZW50KG51bGwsIG51bGwsIHJ1bGUpO1xuICAgICAgICAgICAgICAgIHV0aWxzLmNvcHlFdmVudExpc3RlbmVyc1JlY3Vyc2l2ZWx5KGR1bW15RWxlbWVudCwgRE9NVHJlZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHlpZWxkIERPTVRyZWU7XG4gICAgICAgICAgICBET01UcmVlID0gRE9NVHJlZVN0cmVhbS5uZXh0KCkudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSFRNTFJhem9yO1xuIiwidmFyIGk9MCxcbiAgICBXQUlUX0ZPUl9ORVhUX1RPS0VOX1RPX1NUQVJUID0gaSsrLFxuICAgIFJFQURJTkdfVEFHX05BTUUgPSBpKyssXG4gICAgREVURVJNSU5JTkdfVEFHX1RZUEUgPSBpKyssXG4gICAgUkVBRElOR19BVFRSSUJVVEVfTkFNRSA9IGkrKyxcbiAgICBFWFBFQ1RJTkdfUVVPVEVfVE9fU1RBUlRfQVRUUklCVVRFX1ZBTFVFID0gaSsrLFxuICAgIFJFQURJTkdfQVRUUklCVVRFX1ZBTFVFID0gaSsrLFxuICAgIFdBSVRfRk9SX05FWFRfQVRUUklCVVRFX1RPX1NUQVJUID0gaSsrLFxuICAgIFJFQURJTkdfVEVYVCA9IGkrKyxcbiAgICBXQUlUSU5HX0ZPUl9FTVBUWV9UQUdfVE9fQkVfQ0xPU0VEID0gaSsrO1xuXG5mdW5jdGlvbiBhZGRDaGFyUmFuZ2VUb1RyYW5zaXRpb24odHJhbnNpdGlvbiwgQ2hhclJhbmdlU3RhcnQsIENoYXJSYW5nZUVuZCwgVHJhbnNpdGlvbkFjdGlvbikge1xuICAgIGZvcihsZXQgYXNjaUNvZGU9Q2hhclJhbmdlU3RhcnQuY2hhckNvZGVBdCgwKTsgYXNjaUNvZGU8PUNoYXJSYW5nZUVuZC5jaGFyQ29kZUF0KDApOyBhc2NpQ29kZSsrKSB7XG4gICAgICAgIHRyYW5zaXRpb25bU3RyaW5nLmZyb21DaGFyQ29kZShhc2NpQ29kZSldID0gVHJhbnNpdGlvbkFjdGlvbjtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdsb2JDaGFyUmFuZ2VzSW5UcmFuc3Rpb24odHJhbnNpdGlvbikge1xuICAgIE9iamVjdC5rZXlzKHRyYW5zaXRpb24pLmZpbHRlcihmdW5jdGlvbih0aykge1xuICAgICAgICByZXR1cm4gdGsubWF0Y2goL15cXFsoLnxcXHMpKlxcXSQvKTtcbiAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uKHRrKSB7XG4gICAgICAgIHZhciB0ZiA9IHRyYW5zaXRpb25bdGtdO1xuXG4gICAgICAgIGlmKHRrLmluZGV4T2YoJ0EtWicpICE9PSAtMSkge2FkZENoYXJSYW5nZVRvVHJhbnNpdGlvbih0cmFuc2l0aW9uLCAnQScsICdaJywgdGYpO31cbiAgICAgICAgaWYodGsuaW5kZXhPZignYS16JykgIT09IC0xKSB7YWRkQ2hhclJhbmdlVG9UcmFuc2l0aW9uKHRyYW5zaXRpb24sICdhJywgJ3onLCB0Zik7fVxuICAgICAgICBpZih0ay5pbmRleE9mKCcwLTknKSAhPT0gLTEpIHthZGRDaGFyUmFuZ2VUb1RyYW5zaXRpb24odHJhbnNpdGlvbiwgJzAnLCAnOScsIHRmKTt9XG5cbiAgICAgICAgaWYodGsuaW5kZXhPZignIFxcbicpICE9PSAtMSkge1xuICAgICAgICAgICB0cmFuc2l0aW9uWycgJ10gPSB0ZjtcbiAgICAgICAgICAgdHJhbnNpdGlvblsnXFxuJ10gPSB0ZjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vdGsucmVwbGFjZSgvXFxbfFxcXXxBXFwtWnxhXFwtenwwXFwtOS9nLCAnJykgLT4gXCJbQS1aYS16LSddXCIgaXMgcmVwbGFjZWQgdG8gXCItJ1wiLCBhbmQgdGhlbiBcIi1cIiBhbmQgXCInXCIgYXJlIGFkZGVkIHRvIHRoZSB0cmFuc2l0aW9uXG4gICAgICAgIHRrLnJlcGxhY2UoL1xcW3xcXF18QVxcLVp8YVxcLXp8MFxcLTkvZywgJycpLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb25bY10gPSB0ZjtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cblxuZnVuY3Rpb24gU3RhdGVNYWNoaW5lKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMudHJhbnNpc3Rpb25zID0gW107XG4gICAgdGhpcy50b2tlbnMgPSBbXTtcbiAgICB0aGlzLnN0YXRlID0gV0FJVF9GT1JfTkVYVF9UT0tFTl9UT19TVEFSVDtcblxuICAgIHRoaXMucmVzZXRTdGF0ZSgpO1xuXG4gICAgdGhpcy50cmFuc2lzdGlvbnNbV0FJVF9GT1JfTkVYVF9UT0tFTl9UT19TVEFSVF0gPSB7XG4gICAgICAgICc8JzogICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkgICAgIHsgc2VsZi5zdGF0ZSA9IERFVEVSTUlOSU5HX1RBR19UWVBFOyB9LFxuICAgICAgICAnZWxzZSc6ICAgICAgICAgICAgICBmdW5jdGlvbihjaGFyKSB7IHNlbGYuc3RhdGUgPSBSRUFESU5HX1RFWFQ7IHNlbGYuY3VycmVudFRva2VuLnR5cGUgPSAnVEVYVCc7IHNlbGYuY3VycmVudFRva2VuLnZhbHVlICs9IGNoYXI7IH1cbiAgICB9O1xuXG4gICAgdGhpcy50cmFuc2lzdGlvbnNbREVURVJNSU5JTkdfVEFHX1RZUEVdID0ge1xuICAgICAgICAnW2EtekEtWl0nOiAgICAgICAgICBmdW5jdGlvbihjaGFyKSAgeyBzZWxmLnN0YXRlID0gUkVBRElOR19UQUdfTkFNRTsgc2VsZi5jdXJyZW50VG9rZW4udHlwZSA9ICdPUEVOX1RBRyc7IHNlbGYuY3VycmVudFRva2VuLnZhbHVlICs9IGNoYXI7IH0sXG4gICAgICAgICcvJzogICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkgICAgICB7IHNlbGYuc3RhdGUgPSBSRUFESU5HX1RBR19OQU1FOyBzZWxmLmN1cnJlbnRUb2tlbi50eXBlID0gJ0NMT1NFX1RBRyc7IH0sXG4gICAgfTtcblxuICAgIHRoaXMudHJhbnNpc3Rpb25zW1JFQURJTkdfVEFHX05BTUVdID0ge1xuICAgICAgICAnW2EtekEtWjAtOV0nOiAgICAgICBmdW5jdGlvbihjaGFyKSB7IHNlbGYuY3VycmVudFRva2VuLnZhbHVlICs9IGNoYXIgfSxcbiAgICAgICAgJ1sgXFxuXSc6ICAgICAgICAgICAgIGZ1bmN0aW9uKCkgICAgIHsgc2VsZi5jdXJyZW50VG9rZW4udHlwZSA9PT0gJ0NMT1NFX1RBRycgPyBzZWxmLnRyYW5zaXN0aW9uc1tSRUFESU5HX1RBR19OQU1FXVsnPiddKCkgOiBzZWxmLnN0YXRlID0gV0FJVF9GT1JfTkVYVF9BVFRSSUJVVEVfVE9fU1RBUlQgfSxcbiAgICAgICAgJz4nOiAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKSAgICAgeyBzZWxmLnN0YXRlID0gV0FJVF9GT1JfTkVYVF9UT0tFTl9UT19TVEFSVCwgc2VsZi5maW5pc2hUb2tlbigpIH0sXG4gICAgICAgICcvJzogICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkgICAgIHsgc2VsZi5zdGF0ZSA9IFdBSVRJTkdfRk9SX0VNUFRZX1RBR19UT19CRV9DTE9TRUQsIHNlbGYuY3VycmVudFRva2VuLnR5cGUgPSAnRU1QVFlfVEFHJzsgfVxuICAgIH07XG5cbiAgICB0aGlzLnRyYW5zaXN0aW9uc1tSRUFESU5HX0FUVFJJQlVURV9OQU1FXSA9IHtcbiAgICAgICAgJ1thLXpBLVotXSc6ICAgICAgICAgZnVuY3Rpb24oY2hhcikgeyBzZWxmLmN1cnJlbnRBdHRyaWJ1dGUubmFtZSArPSBjaGFyIH0sXG4gICAgICAgICcgJzogICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkgICAgIHsgc2VsZi5zdGF0ZSA9IFdBSVRfRk9SX05FWFRfQVRUUklCVVRFX1RPX1NUQVJUOyBzZWxmLmZpbmlzaEF0dHJpYnV0ZSgpIH0sXG4gICAgICAgICdcXG4nOiAgICAgICAgICAgICAgICBmdW5jdGlvbigpICAgICB7fSxcbiAgICAgICAgJz0nOiAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKSAgICAgeyBzZWxmLnN0YXRlID0gRVhQRUNUSU5HX1FVT1RFX1RPX1NUQVJUX0FUVFJJQlVURV9WQUxVRSB9LFxuICAgICAgICAnPic6ICAgICAgICAgICAgICAgICBmdW5jdGlvbigpICAgICB7IHNlbGYuc3RhdGUgPSBXQUlUX0ZPUl9ORVhUX1RPS0VOX1RPX1NUQVJUOyBzZWxmLmZpbmlzaEF0dHJpYnV0ZSgpOyBzZWxmLmZpbmlzaFRva2VuKCkgIH0sXG4gICAgICAgICc8JzogICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkgICAgIHsgc2VsZi5zdGF0ZSA9IERFVEVSTUlOSU5HX1RBR19UWVBFOyBzZWxmLmhhbmRsZUJyb2tlbk9wZW5UYWcoUkVBRElOR19BVFRSSUJVVEVfTkFNRSk7IH0sXG4gICAgICAgICcvJzogICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkgICAgIHsgc2VsZi5zdGF0ZSA9IFdBSVRJTkdfRk9SX0VNUFRZX1RBR19UT19CRV9DTE9TRUQsIHNlbGYuY3VycmVudFRva2VuLnR5cGUgPSAnRU1QVFlfVEFHJzsgc2VsZi5maW5pc2hBdHRyaWJ1dGUoKSB9XG4gICAgfTtcblxuICAgIHRoaXMudHJhbnNpc3Rpb25zW0VYUEVDVElOR19RVU9URV9UT19TVEFSVF9BVFRSSUJVVEVfVkFMVUVdID0ge1xuICAgICAgICAnW1wiXFwnXSc6ICAgICAgICAgICAgIGZ1bmN0aW9uKCkgICAgIHsgc2VsZi5zdGF0ZSA9IFJFQURJTkdfQVRUUklCVVRFX1ZBTFVFIH1cbiAgICB9O1xuXG4gICAgdGhpcy50cmFuc2lzdGlvbnNbUkVBRElOR19BVFRSSUJVVEVfVkFMVUVdID0ge1xuICAgICAgICAnW1wiXFwnXSc6ICAgICAgICAgICAgIGZ1bmN0aW9uKCkgICAgIHsgc2VsZi5zdGF0ZSA9IFdBSVRfRk9SX05FWFRfQVRUUklCVVRFX1RPX1NUQVJUOyBzZWxmLmZpbmlzaEF0dHJpYnV0ZSgpIH0sXG4gICAgICAgICc8JzogICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkgICAgIHsgc2VsZi5zdGF0ZSA9IERFVEVSTUlOSU5HX1RBR19UWVBFOyBzZWxmLmhhbmRsZUJyb2tlbk9wZW5UYWcoUkVBRElOR19BVFRSSUJVVEVfVkFMVUUpOyB9LFxuICAgICAgICAnZWxzZSc6ICAgICAgICAgICAgICBmdW5jdGlvbihjaGFyKSB7IHNlbGYuY3VycmVudEF0dHJpYnV0ZS52YWx1ZSArPSBjaGFyIH1cbiAgICB9O1xuXG4gICAgdGhpcy50cmFuc2lzdGlvbnNbV0FJVF9GT1JfTkVYVF9BVFRSSUJVVEVfVE9fU1RBUlRdID0ge1xuICAgICAgICAnWyBcXG5dJzogICAgICAgICAgICAgZnVuY3Rpb24oKSAgICAgeyB9LFxuICAgICAgICAnW2EtekEtWl0nOiAgICAgICAgICBmdW5jdGlvbihjaGFyKSB7IHNlbGYuc3RhdGUgPSBSRUFESU5HX0FUVFJJQlVURV9OQU1FOyBzZWxmLmN1cnJlbnRBdHRyaWJ1dGUubmFtZSArPSBjaGFyIH0sXG4gICAgICAgICc+JzogICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkgICAgIHsgc2VsZi5zdGF0ZSA9IFdBSVRfRk9SX05FWFRfVE9LRU5fVE9fU1RBUlQsIHNlbGYuZmluaXNoVG9rZW4oKSB9LFxuICAgICAgICAnLyc6ICAgICAgICAgICAgICAgICBmdW5jdGlvbigpICAgICB7IHNlbGYuc3RhdGUgPSBXQUlUSU5HX0ZPUl9FTVBUWV9UQUdfVE9fQkVfQ0xPU0VELCBzZWxmLmN1cnJlbnRUb2tlbi50eXBlID0gJ0VNUFRZX1RBRyc7IH1cbiAgICB9O1xuXG4gICAgdGhpcy50cmFuc2lzdGlvbnNbV0FJVElOR19GT1JfRU1QVFlfVEFHX1RPX0JFX0NMT1NFRF0gPSB7XG4gICAgICAgICdcXG4nOiAgICAgICAgICAgICAgICBmdW5jdGlvbigpICAgICB7fSxcbiAgICAgICAgJz4nOiAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKSAgICAgeyBzZWxmLnN0YXRlID0gV0FJVF9GT1JfTkVYVF9UT0tFTl9UT19TVEFSVCwgc2VsZi5maW5pc2hUb2tlbigpIH0sXG4gICAgfTtcblxuICAgIHRoaXMudHJhbnNpc3Rpb25zW1JFQURJTkdfVEVYVF0gPSB7XG4gICAgICAgICc8JzogICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkgICAgIHsgc2VsZi5zdGF0ZSA9IERFVEVSTUlOSU5HX1RBR19UWVBFOyBzZWxmLmZpbmlzaFRva2VuKCk7IH0sXG4gICAgICAgICdlbHNlJzogICAgICAgICAgICAgIGZ1bmN0aW9uKGNoYXIpIHsgc2VsZi5jdXJyZW50VG9rZW4udmFsdWUgKz0gY2hhcjsgfSxcbiAgICAgICAgJ0VPRic6ICAgICAgICAgICAgICAgZnVuY3Rpb24oKSAgICAgeyBzZWxmLmZpbmlzaFRva2VuKCk7IH1cbiAgICB9O1xuXG4gICAgdGhpcy50cmFuc2lzdGlvbnMuZm9yRWFjaChmdW5jdGlvbih0KSB7XG4gICAgICAgIGdsb2JDaGFyUmFuZ2VzSW5UcmFuc3Rpb24odCk7XG4gICAgfSlcbn07XG5cblN0YXRlTWFjaGluZS5wcm90b3R5cGUuZmluaXNoQXR0cmlidXRlID0gZnVuY3Rpb24oKSB7XG5cbiAgICBpZih0aGlzLmN1cnJlbnRBdHRyaWJ1dGUubmFtZSA9PT0gJ2NsYXNzJykge1xuICAgICAgICB0aGlzLmN1cnJlbnRBdHRyaWJ1dGUubmFtZSA9ICdjbGFzc05hbWVzJztcbiAgICAgICAgdGhpcy5jdXJyZW50QXR0cmlidXRlLnZhbHVlID0gdGhpcy5jdXJyZW50QXR0cmlidXRlLnZhbHVlLnNwbGl0KCcgJyk7XG4gICAgICAgIHRoaXMuY3VycmVudEF0dHJpYnV0ZS52YWx1ZSA9IHRoaXMuY3VycmVudEF0dHJpYnV0ZS52YWx1ZS5tYXAoZnVuY3Rpb24oYykgeyByZXR1cm4gYy50cmltKCkgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50VG9rZW4uYXR0cmlidXRlc1t0aGlzLmN1cnJlbnRBdHRyaWJ1dGUubmFtZV0gPSB0aGlzLmN1cnJlbnRBdHRyaWJ1dGUudmFsdWUgfHwgdHJ1ZTtcbiAgICB0aGlzLmN1cnJlbnRBdHRyaWJ1dGUgPSB7bmFtZTogJycsIHZhbHVlOiAnJ307XG59O1xuXG5TdGF0ZU1hY2hpbmUucHJvdG90eXBlLmZpbmlzaFRva2VuID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50b2tlbnMucHVzaCh0aGlzLmN1cnJlbnRUb2tlbik7XG4gICAgdGhpcy5yZXNldFN0YXRlKCk7XG59O1xuXG5TdGF0ZU1hY2hpbmUucHJvdG90eXBlLnJlc2V0U3RhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmN1cnJlbnRUb2tlbiA9IHt2YWx1ZTogJycsIHR5cGU6ICdVTktOT1dOJywgYXR0cmlidXRlczoge319O1xuICAgIHRoaXMuY3VycmVudEF0dHJpYnV0ZSA9IHtuYW1lOiAnJywgdmFsdWU6ICcnfTtcbn07XG5cblN0YXRlTWFjaGluZS5wcm90b3R5cGUucmVzZXRTdGF0ZU1hY2hpbmUgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlc2V0U3RhdGUoKTtcbiAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgIHRoaXMuc3RhdGUgPSBXQUlUX0ZPUl9ORVhUX1RPS0VOX1RPX1NUQVJUO1xufVxuXG4vLyBTdGF0ZSBQYXJhbTogdGhlIFN0YXRlTWFjaGluZSBzdGF0ZSBpbiB3aGljaCB0aGUgYnJva2VuIG9wZW4gdGFnIGhhcyBiZWVuIGRldGVjdGVkXG5TdGF0ZU1hY2hpbmUucHJvdG90eXBlLmhhbmRsZUJyb2tlbk9wZW5UYWcgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmKHN0YXRlID09PSBSRUFESU5HX0FUVFJJQlVURV9OQU1FIHx8IHN0YXRlID09PSBSRUFESU5HX0FUVFJJQlVURV9WQUxVRSkge1xuICAgICAgICB0aGlzLmZpbmlzaFRva2VuKCk7XG4gICAgICAgIHRoaXMuY3VycmVudFRva2VuID0ge3ZhbHVlOiAnJywgdHlwZTogJ1RFWFQnLCBhdHRyaWJ1dGVzOiB7fX07XG4gICAgICAgIHRoaXMuZmluaXNoVG9rZW4oKTtcbiAgICB9XG59XG5cblN0YXRlTWFjaGluZS5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uKGNoYXIpIHtcblxuICAgIGlmKHRoaXMudHJhbnNpc3Rpb25zW3RoaXMuc3RhdGVdW2NoYXJdKSB7XG4gICAgICAgIHRoaXMudHJhbnNpc3Rpb25zW3RoaXMuc3RhdGVdW2NoYXJdKGNoYXIpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50cmFuc2lzdGlvbnNbdGhpcy5zdGF0ZV1bJ2Vsc2UnXSkgIHtcbiAgICAgICAgdGhpcy50cmFuc2lzdGlvbnNbdGhpcy5zdGF0ZV1bJ2Vsc2UnXShjaGFyKVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdlcnJvciBwYXJzaW5nIGNvbnRlbnQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50b2tlbnMucG9wKCk7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVNYWNoaW5lXG4iLCJ2YXIgVGFnVHJhbnNmb3JtYXRpb25zID0gZnVuY3Rpb24oKSB7XG4gICAgT2JqZWN0LmNhbGwodGhpcyk7XG59XG5cblRhZ1RyYW5zZm9ybWF0aW9ucy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5wcm90b3R5cGUpO1xuXG5UYWdUcmFuc2Zvcm1hdGlvbnMucHJvdG90eXBlLmFsbG93T25seVRleHRJbiA9IGZ1bmN0aW9uKHBhdGgsIGFyZ3MpIHtcbiAgICB2YXIgdCA9IHRoaXMsXG4gICAgICAgIHAgPSBwYXRoLFxuICAgICAgICBjID0gJyNjb250ZW50JztcblxuICAgIGFyZ3MgPSBhcmdzIHx8IHt9O1xuXG4gICAgdFtwKycvc3BhbiddID1cbiAgICB0W3ArJy91bCddID1cbiAgICB0W3ArJy9saSddID1cbiAgICB0W3ArJy91bC9saSddID1cbiAgICB0W3ArJy9vbCddID1cbiAgICB0W3ArJy9vbC9saSddID1cbiAgICB0W3ArJy9zdHJvbmcnXSA9XG4gICAgdFtwKycvZW0nXSA9XG4gICAgdFtwKycvYS9zcGFuJ10gPVxuICAgIHRbcCsnL2IvYiddID1cbiAgICB0W3ArJy91L3UnXSA9XG4gICAgdFtwKycvaS9pJ10gPVxuICAgIHRbcCsnL2ZvbnQnXSA9IGM7XG5cbiAgICBpZighYXJncy5hbGxvd0JvbGRJdGFsaWNVbmRlcmxpbmUpIHtcbiAgICAgICAgdFtwKycvYiddID1cbiAgICAgICAgdFtwKycvdSddID1cbiAgICAgICAgdFtwKycvaSddID1cbiAgICAgICAgdFtwKycvY29kZSddID0gYztcbiAgICB9IGVsc2Uge1xuICAgICAgICB0W3ArJy9pbmxpbmVjb2RlL2InXSA9XG4gICAgICAgIHRbcCsnL2lubGluZWNvZGUvaSddID1cbiAgICAgICAgdFtwKycvaW5saW5lY29kZS91J10gPVxuICAgICAgICB0W3ArJy9pbmxpbmVjb2RlL2EnXSA9IGM7XG4gICAgICAgIHRbcCsnL2NvZGUnXSA9ICdpbmxpbmVjb2RlJztcbiAgICAgICAgdFtwKycvaW5saW5lY29kZS9pbmxpbmVjb2RlJ10gPSAnI2NvbnRlbnQnO1xuICAgICAgICB0W3ArJy9iL2lubGluZWNvZGUnXSA9ICctJztcbiAgICAgICAgdFtwKycvdS9pbmxpbmVjb2RlJ10gPSAnLSc7XG4gICAgICAgIHRbcCsnL2kvaW5saW5lY29kZSddID0gJy0nO1xuICAgICAgICB0W3ArJy9hL2NvZGUnXSA9ICdpbmxpbmVjb2RlJztcbiAgICB9XG5cbiAgICBpZighYXJncy5hbGxvd0xpbmtzKSB7XG4gICAgICB0W3ArJy9hJ10gPSBjO1xuICAgICAgdFtwKycvY29kZSddID0gYztcbiAgICAgIHRbcCsnL2lubGluZWNvZGUnXSA9IGM7XG4gICAgfVxuXG4gICAgaWYoIWFyZ3MuYWxsb3dSb290RWxlbWVudHMpIHtcbiAgICAgICAgdFtwKycvaDEnXSA9XG4gICAgICAgIHRbcCsnL2gyJ10gPVxuICAgICAgICB0W3ArJy9oMyddID1cbiAgICAgICAgdFtwKycvaDQnXSA9XG4gICAgICAgIHRbcCsnL2g1J10gPVxuICAgICAgICB0W3ArJy9oNiddID1cbiAgICAgICAgdFtwKycvaDcnXSA9XG4gICAgICAgIHRbcCsnL2RpdiddID1cbiAgICAgICAgdFtwKycvcCddID0gYztcbiAgICB9XG5cbiAgICBpZihhcmdzLmFsbG93RXF1YXRpb25zKSB7XG4gICAgICAgIHQuYWxsb3dJbmxpbmVlcXVhdGlvbnNJbihwKVxuICAgIH1cblxuICAgIGlmKGFyZ3MuYWxsb3dSZWZzKSB7XG4gICAgICAgIHQuYWxsb3dSZWZzSW4ocCk7XG5cbiAgICAgICAgaWYoYXJncy5hbGxvd0JvbGRJdGFsaWNVbmRlcmxpbmUpIHtcbiAgICAgICAgICAgIHQuYWxsb3dSZWZzSW4ocCArICcvYicpO1xuICAgICAgICAgICAgdC5hbGxvd1JlZnNJbihwICsgJy91Jyk7XG4gICAgICAgICAgICB0LmFsbG93UmVmc0luKHAgKyAnL2knKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGFyZ3MuYWxsb3dMaW5rcykge1xuICAgICAgICAgICAgdC5hbGxvd1JlZnNJbihwICsgJy9hJyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5UYWdUcmFuc2Zvcm1hdGlvbnMucHJvdG90eXBlLmFsbG93SW5saW5lZXF1YXRpb25zSW4gPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgdmFyIHQgPSB0aGlzLFxuICAgICAgICBwID0gcGF0aDtcblxuICAgIHRbcCsnL2lubGluZWVxdWF0aW9uJ10gPSAnI25vLWNvbnRlbnQnO1xuICAgIHRbcCsnL2IvaW5saW5lZXF1YXRpb24nXSA9XG4gICAgdFtwKycvdS9pbmxpbmVlcXVhdGlvbiddID1cbiAgICB0W3ArJy9pL2lubGluZWVxdWF0aW9uJ10gPVxuICAgIHRbcCsnL2EvaW5saW5lZXF1YXRpb24nXSA9XG4gICAgdFtwKycvYi9pL2lubGluZWVxdWF0aW9uJ10gPVxuICAgIHRbcCsnL2kvYi9pbmxpbmVlcXVhdGlvbiddID1cbiAgICB0W3ArJy9iL3UvaW5saW5lZXF1YXRpb24nXSA9XG4gICAgdFtwKycvdS9iL2lubGluZWVxdWF0aW9uJ10gPVxuICAgIHRbcCsnL2kvdS9pbmxpbmVlcXVhdGlvbiddID1cbiAgICB0W3ArJy91L2kvaW5saW5lZXF1YXRpb24nXSA9XG4gICAgdFtwKycvYS9pL2lubGluZWVxdWF0aW9uJ10gPVxuICAgIHRbcCsnL2kvYS9pbmxpbmVlcXVhdGlvbiddID1cbiAgICB0W3ArJy9hL3UvaW5saW5lZXF1YXRpb24nXSA9XG4gICAgdFtwKycvdS9hL2lubGluZWVxdWF0aW9uJ10gPVxuICAgIHRbcCsnL2EvYi9pbmxpbmVlcXVhdGlvbiddID1cbiAgICB0W3ArJy9iL2EvaW5saW5lZXF1YXRpb24nXSA9ICctJ1xufTtcblxuXG5cblRhZ1RyYW5zZm9ybWF0aW9ucy5wcm90b3R5cGUuYWxsb3dSZWZzSW4gPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgdGhpc1twYXRoKycvc3BhbiddID0gJyNjb250ZW50JztcbiAgICB0aGlzW3BhdGgrJy9zcGFuLmZvb3Rub3RlJ10gPSAnc3Bhbi5mb290bm90ZSc7XG4gICAgdGhpc1twYXRoKycvc3Bhbi5yZWZlcmVuY2UnXSA9ICdzcGFuLnJlZmVyZW5jZSc7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gVGFnVHJhbnNmb3JtYXRpb25zXG4iLCJjbGFzcyBOb3RGb3VuZCBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihsb29rdXBJRCkge1xuICAgICAgICBzdXBlcihgTm8gcmVjb3JkIGZvdW5kIGZvciAke2xvb2t1cElEfWApXG4gICAgfVxufVxuXG5jbGFzcyBJbnZhbGlkSUQgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobG9va3VwSUQpIHtcbiAgICAgICAgc3VwZXIoYElEIGlzIGludmFsaWQ6ICR7bG9va3VwSUR9YClcbiAgICB9XG59XG5cbmNsYXNzIEVtcHR5SUQgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdJRCBhcmd1bWVudCBzaG91bGQgbm90IGJlIG51bGwgZm9yIGZldGNoaW5nIHJlZmVyZW5jZSBkYXRhLiBOZWVkcyB0byBiZSBhIERPSS9JU0JOJylcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIE5vdEZvdW5kLFxuICAgIEludmFsaWRJRCxcbiAgICBFbXB0eUlEXG59OyIsInZhciBsb29rdXBCeURPSSA9IHJlcXVpcmUoJy4vbG9va3VwX2J5X2RvaScpO1xudmFyIGxvb2t1cEJ5SVNCTiA9IHJlcXVpcmUoJy4vbG9va3VwX2J5X2lzYm4nKTtcbnZhciBsb29rdXBCeVVSTCA9IHJlcXVpcmUoJy4vbG9va3VwX2J5X3VybCcpO1xudmFyIGxvb2t1cEJ5QXJ4aXYgPSByZXF1aXJlKCcuL2xvb2t1cF9ieV9hcnhpdicpO1xudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGZldGNoSlNPTjogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgaWYoIWlkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKF8sIHJlaikgPT4gcmVqKG5ldyBlcnJvcnMuRW1wdHlJRCgpKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZCA9IGlkLnRyaW0oKTtcblxuICAgICAgICBpZihsb29rdXBCeURPSS5pc1ZhbGlkSUQoaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9va3VwQnlET0kuZmV0Y2hKU09OKGlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGxvb2t1cEJ5SVNCTi5pc1ZhbGlkSUQoaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9va3VwQnlJU0JOLmZldGNoSlNPTihpZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihsb29rdXBCeVVSTC5pc1ZhbGlkSUQoaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9va3VwQnlVUkwuZmV0Y2hKU09OKGlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGxvb2t1cEJ5QXJ4aXYuaXNWYWxpZElEKGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvb2t1cEJ5QXJ4aXYuZmV0Y2hKU09OKGlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoXywgcmVqKSA9PiByZWoobmV3IGVycm9ycy5JbnZhbGlkSUQoaWQpKSk7XG4gICAgfSxcblxuICAgIGxvb2t1cEJ5RE9JOiBsb29rdXBCeURPSS5mZXRjaEpTT04sXG4gICAgbG9va3VwQnlJU0JOOiBsb29rdXBCeUlTQk4uZmV0Y2hKU09OLFxuICAgIGxvb2t1cEJ5VVJMOiBsb29rdXBCeVVSTC5mZXRjaEpTT04sXG4gICAgZXJyb3JzOiBlcnJvcnMsXG59IiwiLy8gZmV0Y2goJ2h0dHA6Ly9leHBvcnQuYXJ4aXYub3JnL2FwaS9xdWVyeT9pZF9saXN0PTE5MDYuMDE3MzgnKS50aGVuKHIgPT4gci50ZXh0KCkpLnRoZW4odGV4dCA9PiApXG5cbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xudmFyIG1vbnRocyA9IFsnSmFuLicsICdGZWIuJywgJ01hci4nLCAnQXByLicsICdNYXkuJywgJ0p1bi4nLCAnSnVsLicsICdBdWcuJywgJ1NlcC4nLCAnT2N0LicsICdOb3YuJywgJ0RlYyddO1xudmFyIGxvb2t1cENhY2hlID0ge31cblxuZnVuY3Rpb24gZ2V0UHVibGlzaGVkTW9udGgoZW50cnkpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKGVudHJ5LnF1ZXJ5U2VsZWN0b3IoJ3B1Ymxpc2hlZCcpLmlubmVySFRNTClcblxuICAgICAgICBpZighZGF0ZSB8fCBkYXRlID09ICdJbnZhbGlkIERhdGUnKSB7XG4gICAgICAgICAgICB0aHJvdyAnaW52YWxpZCBwdWJsaWNhdGlvbiBkYXRlJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtb250aHNbZGF0ZS5nZXRNb250aCgpXVxuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdlcnJvciBwYXJzaW5nIHB1YmxpY2F0aW9uIGRhdGUnLCBleClcbiAgICAgICAgcmV0dXJuICcnXG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRQdWJsaXNoZWRZZWFyKGVudHJ5KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShlbnRyeS5xdWVyeVNlbGVjdG9yKCdwdWJsaXNoZWQnKS5pbm5lckhUTUwpXG5cbiAgICAgICAgaWYoIWRhdGUgfHwgZGF0ZSA9PSAnSW52YWxpZCBEYXRlJykge1xuICAgICAgICAgICAgdGhyb3cgJ2ludmFsaWQgcHVibGljYXRpb24gZGF0ZSdcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRlLmdldEZ1bGxZZWFyKClcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBjb25zb2xlLmxvZygnZXJyb3IgcGFyc2luZyBwdWJsaWNhdGlvbiBkYXRlJywgZXgpXG4gICAgICAgIHJldHVybiAnJ1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVzdWx0RnJvbVJlc3Bub3NlKHhtbERvYykge1xuICAgIHZhciBlbnRyeSA9IHhtbERvYy5xdWVyeVNlbGVjdG9yKCdlbnRyeScpXG4gICAgdmFyIHRpdGxlRWwgPSBlbnRyeS5xdWVyeVNlbGVjdG9yKCd0aXRsZScpXG4gICAgdmFyIGF1dGhvcnMgPSBlbnRyeS5xdWVyeVNlbGVjdG9yQWxsKCdhdXRob3InKS5tYXAoYXV0aG9yID0+IHtcbiAgICAgICAgYXV0aG9yID0gYXV0aG9yICYmIGF1dGhvci5xdWVyeVNlbGVjdG9yKCduYW1lJylcbiAgICAgICAgaWYoYXV0aG9yICYmIGF1dGhvci5pbm5lckhUTUwpIHtcbiAgICAgICAgICAgIHJldHVybiBhdXRob3IuaW5uZXJIVE1MXG4gICAgICAgIH1cbiAgICB9KS5qb2luKCcgYW5kICcpXG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnQXJ0aWNsZScsXG4gICAgICAgIHRpdGxlOiAodGl0bGVFbCAmJiB0aXRsZUVsLmlubmVySFRNTCkgfHwgJycsXG4gICAgICAgIGF1dGhvcjogYXV0aG9ycyxcbiAgICAgICAgeWVhcjogZ2V0UHVibGlzaGVkWWVhcihlbnRyeSksXG4gICAgICAgIG1vbnRoOiBnZXRQdWJsaXNoZWRNb250aChlbnRyeSlcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgaXNWYWxpZElEOiBmdW5jdGlvbihpZCkge1xuICAgICAgICByZXR1cm4gaWQgJiYgaWQudHJpbSgpLm1hdGNoKC9eKGFyWGl2Oik/WzAtOV17NH1cXC5bMC05XSsodi4pPyQvKVxuICAgIH0sXG5cbiAgICBmZXRjaEpTT046IGFzeW5jIGZ1bmN0aW9uKGlkKSB7XG5cbiAgICAgICAgaWYoIXRoaXMuaXNWYWxpZElEKGlkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5JbnZhbGlkSUQoaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoaWQudHJpbSgpLm1hdGNoKC9eYXJYaXY6LykpIHtcbiAgICAgICAgICAgIGlkID0gaWQudHJpbSgpLnJlcGxhY2UoL15hclhpdjovLCAnJylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGxvb2t1cENhY2hlW2lkXSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvb2t1cENhY2hlW2lkXVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlcyA9IGF3YWl0IGZldGNoKGBodHRwOi8vZXhwb3J0LmFyeGl2Lm9yZy9hcGkvcXVlcnk/aWRfbGlzdD0ke2lkfWApXG5cbiAgICAgICAgaWYoIXJlcy5vaykge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3JzLk5vdEZvdW5kXG4gICAgICAgIH1cblxuICAgICAgICBsb29rdXBDYWNoZVtpZF0gPSByZXN1bHRGcm9tUmVzcG5vc2UoXG4gICAgICAgICAgICBuZXcgd2luZG93LkRPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhhd2FpdCByZXMudGV4dCgpLCBcInRleHQveG1sXCIpXG4gICAgICAgIClcblxuICAgICAgICByZXR1cm4gbG9va3VwQ2FjaGVbaWRdXG4gICAgfVxufSIsInZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xudmFyIGRvaUxvb2t1cENhY2hlID0ge31cblxudmFyIG1vbnRocyA9IFsnSmFuLicsICdGZWIuJywgJ01hci4nLCAnQXByLicsICdNYXkuJywgJ0p1bi4nLCAnSnVsLicsICdBdWcuJywgJ1NlcC4nLCAnT2N0LicsICdOb3YuJywgJ0RlYyddO1xuXG52YXIgZG9pVHlwZTJiaWJUZVhUeXBlID0ge1xuICAgICdqb3VybmFsLWFydGljbGUnOiAnQXJ0aWNsZScsXG4gICAgJ3Byb2NlZWRpbmdzLWFydGljbGUnOiAnQ29uZmVyZW5jZS9JbnByb2NlZWRpbmdzJyxcbiAgICAnZGlzc2VydGF0aW9uJzogJ1BoZHRoZXNpcycsXG5cbiAgICAnYm9vayc6ICdCb29rJyxcbiAgICAnYm9vay1zZXJpZXMnOiAnQm9vaycsXG4gICAgJ2Jvb2stc2V0JzogJ0Jvb2snLFxuICAgICdib29rLXRyYWNrJzogJ0Jvb2snLFxuICAgICdtb25vZ3JhcGgnOiAnQm9vaycsXG4gICAgJ3JlZmVyZW5jZS1ib29rJzogJ0Jvb2snLFxuXG4gICAgJ2Jvb2stY2hhcHRlcic6ICdJbmJvb2snLFxuICAgICdib29rLXBhcnQnOiAnSW5ib29rJyxcbiAgICAnYm9vay1zZWN0aW9uJzogJ0luYm9vaycsXG4gICAgJ3JlZmVyZW5jZS1lbnRyeSc6ICdJbmJvb2snLFxuXG4gICAgJ2RhdGFzZXQnOiAnVGVjaHJlcG9ydCcsXG4gICAgJ3Bvc3RlZC1jb250ZW50JzogJ1RlY2hyZXBvcnQnLFxuICAgICdyZXBvcnQnOiAnVGVjaHJlcG9ydCcsXG4gICAgJ3JlcG9ydC1zZXJpZXMnOiAnVGVjaHJlcG9ydCcsXG4gICAgJ3N0YW5kYXJkJzogJ1RlY2hyZXBvcnQnLFxufTtcblxudmFyIHNlbGVjdGVkRmllbGRzID0gW1xuICAgICd0eXBlJyxcbiAgICAnY29udGFpbmVyLXRpdGxlJywgLy8gLT4gam91cm5hbCwgYm9va3RpdGxlLCBldmVudHRpdGxlXG4gICAgJ3ZvbHVtZScsXG4gICAgJ2lzc3VlJyxcbiAgICAncHVibGlzaGVyJyxcbiAgICAnaXNzdWVkJywgLy8gLT4geWVhciwgbW9udGhcbiAgICAndGl0bGUnLFxuICAgICdzdWJ0aXRsZScsXG4gICAgJ2F1dGhvcicsXG4gICAgJ2VkaXRvcicsXG5dO1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Eb2lBdXRob3JzKGRvaURhdGEsIGZpZWxkKSB7XG4gICAgcmV0dXJuIChkb2lEYXRhWyhmaWVsZCldIHx8IFtdKVxuICAgICAgICAubWFwKGEgPT4gYCR7YS5mYW1pbHl9LCAke2EuZ2l2ZW59YClcbiAgICAgICAgLmpvaW4oJyBhbmQgJylcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtRG9pTW9udGgoZG9pRGF0YSkge1xuICAgIGlmKGRvaURhdGEgJiYgZG9pRGF0YS5pc3N1ZWQgJiYgZG9pRGF0YS5pc3N1ZWRbJ2RhdGUtcGFydHMnXSAmJiBkb2lEYXRhLmlzc3VlZFsnZGF0ZS1wYXJ0cyddWzBdICYmIGRvaURhdGEuaXNzdWVkWydkYXRlLXBhcnRzJ11bMF1bMV0pIHtcbiAgICAgICAgcmV0dXJuIG1vbnRoc1tkb2lEYXRhLmlzc3VlZFsnZGF0ZS1wYXJ0cyddWzBdWzFdLTFdO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtRG9pWWVhcihkb2lEYXRhKSB7XG4gICAgaWYoZG9pRGF0YSAmJiBkb2lEYXRhLmlzc3VlZCAmJiBkb2lEYXRhLmlzc3VlZFsnZGF0ZS1wYXJ0cyddICYmIGRvaURhdGEuaXNzdWVkWydkYXRlLXBhcnRzJ11bMF0gJiYgZG9pRGF0YS5pc3N1ZWRbJ2RhdGUtcGFydHMnXVswXVswXSkge1xuICAgICAgICByZXR1cm4gZG9pRGF0YS5pc3N1ZWRbJ2RhdGUtcGFydHMnXVswXVswXTtcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybURvaVB1Ymxpc2hlcihkb2lEYXRhKSB7XG4gICAgaWYoWydib29rLWNoYXB0ZXInLFxuICAgICAgJ2Jvb2stcGFydCcsXG4gICAgICAnYm9vay1zZWN0aW9uJyxcbiAgICAgICdyZWZlcmVuY2UtZW50cnknLFxuICAgICAgJ3Byb2NlZWRpbmdzLWFydGljbGUnLFxuICAgICAgJ2Jvb2snLFxuICAgICAgJ2Jvb2stc2VyaWVzJyxcbiAgICAgICdib29rLXNldCcsXG4gICAgICAnYm9vay10cmFjaycsXG4gICAgICAnbW9ub2dyYXBoJyxcbiAgICAgICdyZWZlcmVuY2UtYm9vayddLmluY2x1ZGVzKGRvaURhdGEudHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGRvaURhdGEucHVibGlzaGVyIHx8ICcnO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybURvaU9yZ2FuaXphdGlvbihkb2lEYXRhKSB7XG4gICAgaWYoWydwcm9jZWVkaW5ncy1hcnRpY2xlJ10uaW5jbHVkZXMoZG9pRGF0YS50eXBlKSkge1xuICAgICAgICByZXR1cm4gZG9pRGF0YS5wdWJsaXNoZXIgfHwgJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Eb2lTY2hvb2woZG9pRGF0YSkge1xuICAgIGlmKFsnZGlzc2VydGF0aW9uJ10uaW5jbHVkZXMoZG9pRGF0YS50eXBlKSkge1xuICAgICAgICByZXR1cm4gZG9pRGF0YS5wdWJsaXNoZXIgfHwgJyc7XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZGVjb2RlKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgnJmFtcDsnLCAnJicpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgaXNWYWxpZElEOiBmdW5jdGlvbihkb2kpIHtcbiAgICAgICAgcmV0dXJuIGRvaS5tYXRjaCgvXjEwLlxcZHs0LDl9XFwvLiskL2kpO1xuICAgIH0sXG5cbiAgICBmZXRjaEpTT046IGZ1bmN0aW9uKGRvaSkge1xuICAgICAgICByZXR1cm4gbW9kdWxlLmV4cG9ydHMucXVlcnlDcm9zc3JlZihkb2kpLnRoZW4ocmVzdWx0RGF0YSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IHJlc3VsdERhdGEudHlwZSA/IGRvaVR5cGUyYmliVGVYVHlwZVtyZXN1bHREYXRhLnR5cGVdIDogJ0FydGljbGUnLFxuICAgICAgICAgICAgICAgIGF1dGhvcjogdHJhbnNmb3JtRG9pQXV0aG9ycyhyZXN1bHREYXRhLCAnYXV0aG9yJyksXG4gICAgICAgICAgICAgICAgZWRpdG9yOiB0cmFuc2Zvcm1Eb2lBdXRob3JzKHJlc3VsdERhdGEsICdlZGl0b3InKSxcbiAgICAgICAgICAgICAgICB0aXRsZTogZGVjb2RlKHJlc3VsdERhdGEudGl0bGUgPyByZXN1bHREYXRhLnRpdGxlLmpvaW4oJyAtICcpIDogJycpLFxuICAgICAgICAgICAgICAgIHN1YnRpdGxlOiBkZWNvZGUocmVzdWx0RGF0YS5zdWJ0aXRsZSA/IHJlc3VsdERhdGEuc3VidGl0bGUuam9pbignIC0gJykgOiAnJyksXG4gICAgICAgICAgICAgICAgam91cm5hbDogZGVjb2RlKHJlc3VsdERhdGFbJ2NvbnRhaW5lci10aXRsZSddID8gcmVzdWx0RGF0YVsnY29udGFpbmVyLXRpdGxlJ10uam9pbignIC0gJykgOiAnJyksXG4gICAgICAgICAgICAgICAgbnVtYmVyOiByZXN1bHREYXRhLmlzc3VlIHx8ICcnLFxuICAgICAgICAgICAgICAgIHZvbHVtZTogcmVzdWx0RGF0YS52b2x1bWUgfHwgJycsXG4gICAgICAgICAgICAgICAgcHVibGlzaGVyOiBkZWNvZGUodHJhbnNmb3JtRG9pUHVibGlzaGVyKHJlc3VsdERhdGEpKSxcbiAgICAgICAgICAgICAgICBvcmdhbml6YXRpb246IGRlY29kZSh0cmFuc2Zvcm1Eb2lPcmdhbml6YXRpb24ocmVzdWx0RGF0YSkpLFxuICAgICAgICAgICAgICAgIHllYXI6IHRyYW5zZm9ybURvaVllYXIocmVzdWx0RGF0YSksXG4gICAgICAgICAgICAgICAgbW9udGg6IHRyYW5zZm9ybURvaU1vbnRoKHJlc3VsdERhdGEpLFxuICAgICAgICAgICAgICAgIHNjaG9vbDogdHJhbnNmb3JtRG9pU2Nob29sKHJlc3VsdERhdGEpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBxdWVyeUNyb3NzcmVmOiBmdW5jdGlvbihkb2kpIHtcbiAgICAgICAgaWYoIWRvaSB8fCAhdGhpcy5pc1ZhbGlkSUQoZG9pKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4gcmVqKCdpbnZhbGlkIERPSScpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGRvaUxvb2t1cENhY2hlW2RvaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBkb2lMb29rdXBDYWNoZVtkb2ldXG4gICAgICAgIH1cblxuICAgICAgICBkb2lMb29rdXBDYWNoZVtkb2ldID0gZmV0Y2goYGh0dHBzOi8vYXBpLmNyb3NzcmVmLm9yZy93b3Jrcy8/ZmlsdGVyPWRvaToke2VuY29kZVVSSUNvbXBvbmVudChkb2kpfSZzZWxlY3Q9JHtlbmNvZGVVUklDb21wb25lbnQoc2VsZWN0ZWRGaWVsZHMuam9pbignLCcpKX1gKVxuICAgICAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuanNvbigpKVxuICAgICAgICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgaWYoZGF0YSAmJiBkYXRhLm1lc3NhZ2UgJiYgZGF0YS5tZXNzYWdlLml0ZW1zLCBkYXRhLm1lc3NhZ2UuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLm1lc3NhZ2UuaXRlbXNbMF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChfLCByZWopID0+IHJlaihuZXcgZXJyb3JzLk5vdEZvdW5kKGRvaSkpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBkb2lMb29rdXBDYWNoZVtkb2ldO1xuICAgIH1cbn0iLCJ2YXIgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbnZhciBmZXRjaENhY2hlID0ge31cbnZhciBtb250aHMgPSBbJ0phbi4nLCAnRmViLicsICdNYXIuJywgJ0Fwci4nLCAnTWF5LicsICdKdW4uJywgJ0p1bC4nLCAnQXVnLicsICdTZXAuJywgJ09jdC4nLCAnTm92LicsICdEZWMnXTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgaXNWYWxpZElEOiBmdW5jdGlvbihpc2JuKSB7XG4gICAgICAgIHJldHVybiBpc2JuLm1hdGNoKC9eKD89KD86XFxEKlxcZCl7MTB9KD86KD86XFxEKlxcZCl7M30pPyQpW1xcZC1dKyQvKTtcbiAgICB9LFxuXG4gICAgZmV0Y2hKU09OOiBhc3luYyBmdW5jdGlvbihpc2JuKSB7XG4gICAgICAgIGlmKCF0aGlzLmlzVmFsaWRJRChpc2JuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5JbnZhbGlkSUQoaXNibik7XG4gICAgICAgIH1cblxuICAgICAgICBpZihmZXRjaENhY2hlW2lzYm5dKSB7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2hDYWNoZVtpc2JuXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByYXdEYXRhID0gYXdhaXQgZmV0Y2goYGh0dHBzOi8vb3BlbmxpYnJhcnkub3JnL2lzYm4vJHtpc2JufS5qc29uYCk7XG5cbiAgICAgICAgaWYocmF3RGF0YS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHdpbmRvdy5zZXRUaW1lb3V0KHJlcywgMTAwMCkpO1xuICAgICAgICAgICAgcmF3RGF0YSA9IGF3YWl0IGZldGNoKGBodHRwczovL29wZW5saWJyYXJ5Lm9yZy9pc2JuLyR7aXNibn0uanNvbmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYocmF3RGF0YS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5Ob3RGb3VuZChpc2JuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJhd0RhdGEgPSBhd2FpdCByYXdEYXRhLmpzb24oKTtcblxuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIHJlc3VsdC5hdXRob3IgPSAoYXdhaXQgdGhpcy5nZXRBdXRob3JzKHJhd0RhdGEpKS5qb2luKCcgYW5kICcpO1xuICAgICAgICByZXN1bHQudHlwZSA9ICdCb29rJztcblxuICAgICAgICBpZihyYXdEYXRhLnRpdGxlKSB7XG4gICAgICAgICAgICByZXN1bHQudGl0bGUgPSByYXdEYXRhLnRpdGxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYocmF3RGF0YS5zdWJ0aXRsZSkge1xuICAgICAgICAgICAgcmVzdWx0LnN1YnRpdGxlID0gcmF3RGF0YS5zdWJ0aXRsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHJhd0RhdGEucHVibGlzaGVycyAmJiByYXdEYXRhLnB1Ymxpc2hlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQucHVibGlzaGVyID0gcmF3RGF0YS5wdWJsaXNoZXJzWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYocmF3RGF0YS5wdWJsaXNoX2RhdGUpIHtcbiAgICAgICAgICAgIHZhciBwdWJsaXNoRGF0ZSA9IG5ldyBEYXRlKHJhd0RhdGEucHVibGlzaF9kYXRlKTtcbiAgICAgICAgICAgIGlmKHB1Ymxpc2hEYXRlIGluc3RhbmNlb2YgRGF0ZSAmJiAhaXNOYU4ocHVibGlzaERhdGUpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnllYXIgPSBwdWJsaXNoRGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5tb250aCA9IG1vbnRoc1twdWJsaXNoRGF0ZS5nZXRNb250aCgpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHJhd0RhdGEuaXNibl8xMyAmJiByYXdEYXRhLmlzYm5fMTMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQuaXNibiA9IHJhd0RhdGEuaXNibl8xM1swXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZldGNoQ2FjaGVbaXNibl0gPSByZXN1bHQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGdldEF1dGhvcnM6IGFzeW5jIGZ1bmN0aW9uKHBheWxvYWQpIHtcbiAgICAgICAgdmFyIGF1dGhvcnMgPSBbXTtcblxuICAgICAgICBpZihwYXlsb2FkLmF1dGhvcnMgJiYgcGF5bG9hZC5hdXRob3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGk8cGF5bG9hZC5hdXRob3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF1dGhvckRhdGEgPSBhd2FpdCBmZXRjaChgaHR0cHM6Ly9vcGVubGlicmFyeS5vcmcke3BheWxvYWQuYXV0aG9yc1tpXS5rZXl9Lmpzb25gKTtcblxuICAgICAgICAgICAgICAgIGlmKCFhdXRob3JEYXRhLm9rKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9ycy5Ob3RGb3VuZFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGF1dGhvckRhdGEgPSBhd2FpdCBhdXRob3JEYXRhLmpzb24oKTtcbiAgICAgICAgICAgICAgICBpZihhdXRob3JEYXRhICYmIGF1dGhvckRhdGEubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBhdXRob3JzLnB1c2goYXV0aG9yRGF0YS5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZihwYXlsb2FkLmNvbnRyaWJ1dG9ycyAmJiBwYXlsb2FkLmNvbnRyaWJ1dG9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPHBheWxvYWQuY29udHJpYnV0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYocGF5bG9hZC5jb250cmlidXRvcnNbaV0ucm9sZSA9PT0gJ0F1dGhvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgYXV0aG9ycy5wdXNoKHBheWxvYWQuY29udHJpYnV0b3JzW2ldLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhdXRob3JzLm1hcCh0aGlzLmF1dGhvck5hbWVUb0JpYlRlWEZvcm1hdCk7XG4gICAgfSxcblxuICAgIGF1dGhvck5hbWVUb0JpYlRlWEZvcm1hdDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB2YXIgbmFtZXMgPSBuYW1lLnNwbGl0KCcgJyk7XG4gICAgICAgIHZhciBsYXN0TmFtZSA9IG5hbWVzLnBvcCgpO1xuXG4gICAgICAgIGlmKCFuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBsYXN0TmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBgJHtsYXN0TmFtZX0sICR7bmFtZXMuam9pbignICcpfWA7XG4gICAgfSxcbn0iLCJ2YXIgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbnZhciBsb29rdXBDYWNoZSA9IHt9XG52YXIgbW9udGhzID0gWydKYW4uJywgJ0ZlYi4nLCAnTWFyLicsICdBcHIuJywgJ01heS4nLCAnSnVuLicsICdKdWwuJywgJ0F1Zy4nLCAnU2VwLicsICdPY3QuJywgJ05vdi4nLCAnRGVjJ107XG52YXIgYXBpRW5kcG9pbnQgPSAnaHR0cHM6Ly9kamFwaS5ldS1nYi5teWJsdWVtaXgubmV0J1xuLy8gdmFyIGFwaUVuZHBvaW50ID0gJ2h0dHA6Ly9sb2NhbGhvc3Q6ODA4MCdcblxuZnVuY3Rpb24gZ2V0UHVibGlzaGVkTW9udGgodXJsTWV0YSkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUodXJsTWV0YVsnYXJ0aWNsZTpwdWJsaXNoZWRfdGltZSddKVxuXG4gICAgICAgIGlmKCFkYXRlIHx8IGRhdGUgPT0gJ0ludmFsaWQgRGF0ZScpIHtcbiAgICAgICAgICAgIHRocm93ICdpbnZhbGlkIHB1YmxpY2F0aW9uIGRhdGUnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1vbnRoc1tkYXRlLmdldE1vbnRoKCldXG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ2Vycm9yIHBhcnNpbmcgcHVibGljYXRpb24gZGF0ZScsIGV4KVxuICAgICAgICByZXR1cm4gJydcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldFB1Ymxpc2hlZFllYXIodXJsTWV0YSkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUodXJsTWV0YVsnYXJ0aWNsZTpwdWJsaXNoZWRfdGltZSddKVxuXG4gICAgICAgIGlmKCFkYXRlIHx8IGRhdGUgPT0gJ0ludmFsaWQgRGF0ZScpIHtcbiAgICAgICAgICAgIHRocm93ICdpbnZhbGlkIHB1YmxpY2F0aW9uIGRhdGUnXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0ZS5nZXRGdWxsWWVhcigpXG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ2Vycm9yIHBhcnNpbmcgcHVibGljYXRpb24gZGF0ZScsIGV4KVxuICAgICAgICByZXR1cm4gJydcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VsdEZyb21SZXNwbm9zZSh1cmxNZXRhLCB1cmwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnV2Vic2l0ZScsXG4gICAgICAgIHRpdGxlOiAodXJsTWV0YS50aXRsZSAmJiB1cmxNZXRhLnRpdGxlLnRyaW0oKSAhPT0gJycgPyB1cmxNZXRhLnRpdGxlIDogdXJsTWV0YS5kZXNjcmlwdGlvbikgfHwgJycsXG4gICAgICAgIGF1dGhvcjogdXJsTWV0YS5hdXRob3IgfHwgJycsXG4gICAgICAgIHVybDogdXJsIHx8IHVybE1ldGEudXJsIHx8ICcnLFxuICAgICAgICB5ZWFyOiBnZXRQdWJsaXNoZWRZZWFyKHVybE1ldGEpLFxuICAgICAgICBtb250aDogZ2V0UHVibGlzaGVkTW9udGgodXJsTWV0YSlcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgaXNWYWxpZElEOiBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgcmV0dXJuIHVybCAmJiB1cmwudHJpbSgpLm1hdGNoKC9eaHR0cHM/OlxcL1xcLy8pXG4gICAgfSxcblxuICAgIGZldGNoSlNPTjogYXN5bmMgZnVuY3Rpb24odXJsKSB7XG5cbiAgICAgICAgaWYoIXRoaXMuaXNWYWxpZElEKHVybCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnMuSW52YWxpZElEKHVybCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihsb29rdXBDYWNoZVt1cmxdKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9va3VwQ2FjaGVbdXJsXVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHVybE1ldGEgPSBhd2FpdCBmZXRjaChgJHthcGlFbmRwb2ludH0vYXBpL3YyL3N5bmNqb2JzL2dldHVybG1ldGFkYXRhP3VybD0ke2VuY29kZVVSSUNvbXBvbmVudCh1cmwpfWApXG5cbiAgICAgICAgaWYoIXVybE1ldGEub2spIHtcbiAgICAgICAgICAgIHRocm93IGVycm9ycy5Ob3RGb3VuZFxuICAgICAgICB9XG5cbiAgICAgICAgbG9va3VwQ2FjaGVbdXJsXSA9IHJlc3VsdEZyb21SZXNwbm9zZShhd2FpdCB1cmxNZXRhLmpzb24oKSwgdXJsKVxuXG4gICAgICAgIHJldHVybiBsb29rdXBDYWNoZVt1cmxdXG4gICAgfVxufSIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZ2V0RWxlbWVudFBvc2l0aW9uOiBmdW5jdGlvbihlbCkge1xuICAgICAgICB2YXIgeFBvcyA9IDAsXG4gICAgICAgICAgICB5UG9zID0gMDtcblxuICAgICAgICB3aGlsZSAoZWwpIHtcbiAgICAgICAgICAgIHhQb3MgKz0gZWwub2Zmc2V0TGVmdCArIGVsLmNsaWVudExlZnQ7XG4gICAgICAgICAgICB5UG9zICs9IGVsLm9mZnNldFRvcCAgKyBlbC5jbGllbnRUb3A7XG5cbiAgICAgICAgICAgIGVsID0gZWwub2Zmc2V0UGFyZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHhQb3MsXG4gICAgICAgICAgICB5OiB5UG9zXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGdldERpc3RhbmNlVG9SaWdodFdpbmRvd0JvcmRlcjogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgdmFyIHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYoIXJlY3QpIHJldHVybjtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5pbm5lcldpZHRoIC0gcmVjdC54IC0gcmVjdC53aWR0aDtcbiAgICB9LFxuXG4gICAgY29weU5vZGVBdHRyaWJ1dGVzOiBmdW5jdGlvbihzcmNOb2RlLCB0YXJnZXROb2RlLCBza2lwQXR0cmlidXRlcykge1xuICAgICAgICBza2lwQXR0cmlidXRlcyA9IHNraXBBdHRyaWJ1dGVzIHx8IFtdO1xuXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHNyY05vZGUuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYoc2tpcEF0dHJpYnV0ZXMuaW5kZXhPZihzcmNOb2RlLmF0dHJpYnV0ZXNbaV0ubmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZS5zZXRBdHRyaWJ1dGUoc3JjTm9kZS5hdHRyaWJ1dGVzW2ldLm5hbWUsIHNyY05vZGUuYXR0cmlidXRlc1tpXS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0Rmlyc3RQYXJlbnRXaXRoVGFnTmFtZTogZnVuY3Rpb24oZWwsIHRhZ05hbWUpIHtcbiAgICAgICAgd2hpbGUoZWwgJiYgIWVsLnRhZ05hbWUgPT09IHRhZ05hbWUpIHtcbiAgICAgICAgICAgIGVsID0gZWwucGFyZW50RWxlbWVudFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsXG4gICAgfSxcblxuICAgIGdldEFsbFRleHROb2Rlc09mRWxlbWVudDogZnVuY3Rpb24oZWwpIHtcbiAgICAgIHZhciBuLCBhPVtdLCB3YWxrID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihlbCwgTm9kZUZpbHRlci5TSE9XX1RFWFQsIG51bGwsIGZhbHNlKTtcblxuICAgICAgd2hpbGUobiA9IHdhbGsubmV4dE5vZGUoKSkgeyBhLnB1c2gobik7IH1cbiAgICAgIHJldHVybiBhO1xuICAgIH0sXG5cbiAgICBnZXRMYXN0VmlzaWJsZUNoaWxkT2ZFbGVtZW50OiBmdW5jdGlvbihlbCkge1xuICAgICAgICB2YXIgd2FsayA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoZWwsIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5UIHwgTm9kZUZpbHRlci5TSE9XX1RFWFQsIG51bGwsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHdhbGsubGFzdENoaWxkKCk7XG4gICAgfSxcblxuICAgIGdldEZpcnN0VmlzaWJsZUNoaWxkT2ZFbGVtZW50OiBmdW5jdGlvbihlbCkge1xuICAgICAgICB2YXIgd2FsayA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoZWwsIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5UIHwgTm9kZUZpbHRlci5TSE9XX1RFWFQsIG51bGwsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHdhbGsubmV4dE5vZGUoKTtcbiAgICB9LFxuXG4gICAgY29weUV2ZW50TGlzdGVuZXJzUmVjdXJzaXZlbHk6IGZ1bmN0aW9uKHNyY05vZGUsIHRhcmdldE5vZGUpIHtcbiAgICAgICAgaWYoc3JjTm9kZSAmJiB0YXJnZXROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmNvcHlFdmVudExpc3RlbmVycyhzcmNOb2RlLCB0YXJnZXROb2RlKTtcbiAgICAgICAgICAgIGZvcihsZXQgaT0wOyBpPHNyY05vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuY29weUV2ZW50TGlzdGVuZXJzUmVjdXJzaXZlbHkoc3JjTm9kZS5jaGlsZE5vZGVzW2ldLCB0YXJnZXROb2RlLmNoaWxkTm9kZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNvcHlFdmVudExpc3RlbmVyczogZnVuY3Rpb24oc3JjTm9kZSwgdGFyZ2V0Tm9kZSkge1xuICAgICAgICB0YXJnZXROb2RlLm9uY2xpY2sgPSB0YXJnZXROb2RlLm9uY2xpY2sgfHwgc3JjTm9kZS5vbmNsaWNrO1xuICAgICAgICB0YXJnZXROb2RlLm9uZHJhZ292ZXIgPSB0YXJnZXROb2RlLm9uZHJhZ292ZXIgfHwgc3JjTm9kZS5vbmRyYWdvdmVyO1xuICAgICAgICB0YXJnZXROb2RlLm9uZHJhZ2xlYXZlID0gdGFyZ2V0Tm9kZS5vbmRyYWdsZWF2ZSB8fCBzcmNOb2RlLm9uZHJhZ2xlYXZlO1xuICAgICAgICB0YXJnZXROb2RlLm9uZHJvcCA9IHRhcmdldE5vZGUub25kcm9wIHx8IHNyY05vZGUub25kcm9wO1xuICAgICAgICB0YXJnZXROb2RlLm9uY2hhbmdlID0gdGFyZ2V0Tm9kZS5vbmNoYW5nZSB8fCBzcmNOb2RlLm9uY2hhbmdlO1xuICAgICAgICB0YXJnZXROb2RlLm9uS2V5VXAgPSB0YXJnZXROb2RlLm9uS2V5VXAgfHwgc3JjTm9kZS5vbktleVVwO1xuICAgICAgICB0YXJnZXROb2RlLm9uS2V5RG93biA9IHRhcmdldE5vZGUub25LZXlEb3duIHx8IHNyY05vZGUub25LZXlEb3duO1xuICAgICAgICB0YXJnZXROb2RlLm9uS2V5RW50ZXIgPSB0YXJnZXROb2RlLm9uS2V5RW50ZXIgfHwgc3JjTm9kZS5vbktleUVudGVyO1xuICAgICAgICB0YXJnZXROb2RlLm9uS2V5VGFiID0gdGFyZ2V0Tm9kZS5vbktleVRhYiB8fCBzcmNOb2RlLm9uS2V5VGFiO1xuICAgICAgICB0YXJnZXROb2RlLm9uS2V5QmFja3NwYWNlID0gdGFyZ2V0Tm9kZS5vbktleUJhY2tzcGFjZSB8fCBzcmNOb2RlLm9uS2V5QmFja3NwYWNlO1xuICAgICAgICB0YXJnZXROb2RlLm9uS2V5Q29tYmluYXRpb24gPSB0YXJnZXROb2RlLm9uS2V5Q29tYmluYXRpb24gfHwgc3JjTm9kZS5vbktleUNvbWJpbmF0aW9uO1xuICAgICAgICB0YXJnZXROb2RlLm9uTWFya3VwQ2xlYW5pbmdGaW5zaGVkID0gdGFyZ2V0Tm9kZS5vbk1hcmt1cENsZWFuaW5nRmluc2hlZCB8fCBzcmNOb2RlLm9uTWFya3VwQ2xlYW5pbmdGaW5zaGVkO1xuICAgICAgICB0YXJnZXROb2RlLnNldENvbnRlbnRlZGl0YWJsZSA9IHRhcmdldE5vZGUuc2V0Q29udGVudGVkaXRhYmxlIHx8IHNyY05vZGUuc2V0Q29udGVudGVkaXRhYmxlO1xuICAgICAgICB0YXJnZXROb2RlLm9uU2VsZWN0aW9uQ2hhbmdlID0gdGFyZ2V0Tm9kZS5vblNlbGVjdGlvbkNoYW5nZSB8fCBzcmNOb2RlLm9uU2VsZWN0aW9uQ2hhbmdlO1xuICAgICAgICB0YXJnZXROb2RlLm9uVW5mb2N1cyA9IHRhcmdldE5vZGUub25VbmZvY3VzIHx8IHNyY05vZGUub25VbmZvY3VzO1xuICAgICAgICB0YXJnZXROb2RlLm9uV2luZG93UmVzaXplID0gdGFyZ2V0Tm9kZS5vbldpbmRvd1Jlc2l6ZSB8fCBzcmNOb2RlLm9uV2luZG93UmVzaXplO1xuXG4gICAgICAgIHRhcmdldE5vZGUuc2VjdGlvblR5cGUgPSB0YXJnZXROb2RlLnNlY3Rpb25UeXBlIHx8IHNyY05vZGUuc2VjdGlvblR5cGU7XG4gICAgfSxcblxuICAgIGdldE5vZGVJdGVyYXRvclBvaW50aW5nVG86IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgaWYoIW5vZGUpIHsgcmV0dXJuOyB9XG4gICAgICAgIHZhciBub2RlSXRlcmF0b3IgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKFxuICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LFxuICAgICAgICAgICAgICBOb2RlRmlsdGVyLlNIT1dfVEVYVCB8IE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5ULFxuICAgICAgICAgICAgICBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gKG5vZGUubGVuZ3RoID09PSAwIHx8IG5vZGUuaW5uZXJIVE1MID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgICAgTm9kZUZpbHRlci5GSUxURVJfUkVKRUNUIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIG5vZGVJdGVyYXRvci5jdXJyZW50Tm9kZSA9IG5vZGU7XG5cbiAgICAgICAgcmV0dXJuIG5vZGVJdGVyYXRvcjtcbiAgICB9LFxuXG4gICAgcmVzY3VlTGFUZVhDaGFyc0Zyb21Fc2NhcGU6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICB2YXIgbWFwcGluZyA9IHtcbiAgICAgICAgICAgICdcXFxcJzogJ2xhdGV4c2xhc2gnLFxuICAgICAgICAgICAgJ3snOiAnbGF0ZXhjbWRzdGFydCcsXG4gICAgICAgICAgICAnfSc6ICdsYXRleGNtZGVuZCcsXG4gICAgICAgICAgICAnJCc6ICdsYXRleGNkb2xsYXInLFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvW1xcXFx7fSRdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gIG1hcHBpbmdbbWF0Y2hdID8gKCctLScrbWFwcGluZ1ttYXRjaF0rJy0tJykgOiAnJztcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHJlc3RvcmVSZXNjdWVkTGFUZVhDaGFyczogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIHZhciBtYXBwaW5nID0ge1xuICAgICAgICAgICAgJ2xhdGV4c2xhc2gnOiAnXFxcXCcsXG4gICAgICAgICAgICAnbGF0ZXhjbWRzdGFydCc6ICd7JyxcbiAgICAgICAgICAgICdsYXRleGNtZGVuZCc6ICd9JyxcbiAgICAgICAgICAgICdsYXRleGNkb2xsYXInOiAnJCdcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoLy0tKGxhdGV4Lns1LDh9PyktLS9nLCBmdW5jdGlvbihtYXRjaCwgY29kZW5hbWUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGNvZGVuYW1lLCBtYXBwaW5nW2NvZGVuYW1lXSlcbiAgICAgICAgICAgIHJldHVybiAgbWFwcGluZ1tjb2RlbmFtZV0gPyBtYXBwaW5nW2NvZGVuYW1lXSA6ICcnO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgc3RyaW5nVG9BdHRyaWJ1dGVTYXZlU3RyaW5nOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSB7XG4gICAgICAgICAgICAnPCc6ICdsdCcsXG4gICAgICAgICAgICAnPic6ICdndCcsXG4gICAgICAgICAgICAnXFwnJzogJ2Fwb3MnLFxuICAgICAgICAgICAgJ1wiJzogJ3F1b3QnXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bPD4nXCJdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gIG1hcHBpbmdbbWF0Y2hdID8gKCctLScrbWFwcGluZ1ttYXRjaF0rJy0tJykgOiAnJztcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGF0dHJpYnV0ZVNhdmVTdHJpbmdUb1N0cmluZzogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIHZhciBtYXBwaW5nID0ge1xuICAgICAgICAgICAgJ2x0JzogJzwnLFxuICAgICAgICAgICAgJ2d0JzogJz4nLFxuICAgICAgICAgICAgJ2Fwb3MnOiAnXFwnJyxcbiAgICAgICAgICAgICdxdW90JzogJ1wiJ1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvLS0oLnsyLDR9PyktLS9nLCBmdW5jdGlvbihtYXRjaCwgY29kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG1hcHBpbmdbY29kZV0gfHwgJyc7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBhdHRyaWJ1dGVTYXZlU3RyaW5nVG9IVE1MRW5jb2RlZDogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvLS0oLnsyLDR9PyktLS9nLCBmdW5jdGlvbihtYXRjaCwgY29kZSkge1xuICAgICAgICAgICAgcmV0dXJuICAnJicgKyBjb2RlICsgJzsnO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgZ2V0U3VidHJlZUJ5Q2hpbGROb2RlOiBmdW5jdGlvbihjb250YWluZXIsIGNoaWxkKSB7XG4gICAgICAgIHdoaWxlKGNoaWxkKSB7XG4gICAgICAgICAgICBpZihjaGlsZCAmJiBjaGlsZC5wYXJlbnRFbGVtZW50ID09PSBjb250YWluZXIgJiYgY2hpbGQubm9kZVR5cGUgIT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsIi8vc2VlOiBodHRwczovL2NvZGVidXJzdC5pby90aHJvdHRsaW5nLWFuZC1kZWJvdW5jaW5nLWluLWphdmFzY3JpcHQtYjAxY2FkNWM4ZWRmXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpbWl0LCBmdW5jKSB7XG4gIGxldCBsYXN0RnVuYztcbiAgbGV0IGxhc3RSYW47XG4gIGxldCBsYXN0UmVqZWN0O1xuXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzO1xuICAgICAgY29uc3QgYXJncyA9IGFyZ3VtZW50cztcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBpZiAoIWxhc3RSYW4pIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpKTtcbiAgICAgICAgICAgICAgbGFzdFJhbiA9IERhdGUubm93KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGxhc3RGdW5jKTtcblxuICAgICAgICAgICAgICBpZihsYXN0UmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICBsYXN0UmVqZWN0KCdjYW5jZWxlZCBieSB0aHJvdHRsZScpXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBsYXN0UmVqZWN0ID0gcmVqZWN0XG5cbiAgICAgICAgICAgICAgbGFzdEZ1bmMgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIGxhc3RSYW4gPj0gbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0UmFuID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LCBsaW1pdCAtIChEYXRlLm5vdygpIC0gbGFzdFJhbikpO1xuICAgICAgICAgIH1cbiAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpXG5cbiAgICAgICAgICBpZihlcnIgIT09ICdjYW5jZWxlZCBieSB0aHJvdHRsZScpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHJlamVjdChlcnIpKVxuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICB9O1xufTtcbiIsImZ1bmN0aW9uIGdldE51bWJlclByZWFmaXhIVE1MKG51bWJlcmluZykge1xuICAgIGlmKCFudW1iZXJpbmcgfHwgbnVtYmVyaW5nLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gJycgfVxuXG4gICAgcmV0dXJuICc8c3BhbiBjbGFzcz1cImluZGV4LXByZWFmaXhcIj4nICsgbnVtYmVyaW5nICsgJy4gPC9zcGFuPidcbn1cblxuZnVuY3Rpb24gVE9DRW50cnlGcm9tRWxlbWVudChoLCBhcmdzKSB7XG4gICAgdmFyIGxpbmssIHJlc3VsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJylcblxuICAgIGlmKGguZWwuaGFzQXR0cmlidXRlKCdpZCcpICYmIGFyZ3Mud2l0aExpbmtzKSB7XG4gICAgICAgIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJylcbiAgICAgICAgbGluay5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCAnIycgKyBoLmVsLmdldEF0dHJpYnV0ZSgnaWQnKSlcbiAgICAgICAgbGluay5pbm5lckhUTUwgPSBoLmNvbnRlbnRcbiAgICAgICAgcmVzdWx0LmFwcGVuZENoaWxkKGxpbmspXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0LmlubmVySFRNTCA9IGguY29udGVudFxuICAgIH1cblxuICAgIGlmKGgubnVtYmVyaW5nKSB7XG4gICAgICAgIHJlc3VsdC5pbm5lckhUTUwgPSBnZXROdW1iZXJQcmVhZml4SFRNTChoLm51bWJlcmluZykgKyByZXN1bHQuaW5uZXJIVE1MXG4gICAgfVxuXG4gICAgaWYoaC5lbC5jbGFzc0xpc3QuY29udGFpbnMoJ21pc3NpbmdMZXZlbEhpbnQnKSkge1xuICAgICAgICByZXN1bHQuY2xhc3NMaXN0ID0gaC5lbC5jbGFzc0xpc3RcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBtaXNzaW5nTGV2ZWxXYXJpbmcobGV2ZWwpIHtcbiAgdmFyIHJlc3VsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0gnICsgbGV2ZWwpXG4gIHJlc3VsdC5jbGFzc0xpc3QuYWRkKCdtaXNzaW5nTGV2ZWxIaW50JylcbiAgcmVzdWx0LmNsYXNzTGlzdC5hZGQoJ2xldmVsLScgKyBsZXZlbClcblxuICByZXR1cm4ge1xuICAgICAgbGV2ZWw6IGxldmVsLFxuICAgICAgY29udGVudDogJycsXG4gICAgICBlbDogcmVzdWx0XG4gIH1cbn1cblxuZnVuY3Rpb24gYW5ub3RhdGVIZWFkaW5nTnVtYmVyaW5nKERPTUVsZW1lbnQsIGFyZ3MpIHtcbiAgICB2YXIgYzEgPSBjMiA9IGMzID0gYzQgPSBjNSA9IGM2ID0gMDtcblxuICAgIGlmKCFOdW1iZXIuaXNJbnRlZ2VyKGFyZ3Muc3RhcnROdW1iZXJpbmdBdExldmVsKSB8fFxuICAgICAgIGFyZ3Muc3RhcnROdW1iZXJpbmdBdExldmVsIDwgMSB8fFxuICAgICAgIGFyZ3Muc3RhcnROdW1iZXJpbmdBdExldmVsID4gNikge1xuICAgICAgICByZXR1cm4gRE9NRWxlbWVudDtcbiAgICB9XG5cbiAgICBET01FbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2gxLCBoMiwgaDMsIGg0LCBoNSwgaDYnKS5mb3JFYWNoKGZ1bmN0aW9uKGhlYWRpbmcpIHtcbiAgICAgICAgdmFyIG51bWJlcmluZ1xuXG4gICAgICAgIGlmKGhlYWRpbmcuZ2V0QXR0cmlidXRlKCd1bm51bWJlcmVkLWhlYWRpbmcnKSA9PT0gJ1llcycpIHtcbiAgICAgICAgICAgIGhlYWRpbmcubnVtYmVyaW5nID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoaGVhZGluZy50YWdOYW1lID09PSAnSDEnKSB7XG4gICAgICAgICAgICBjMiA9IGMzID0gYzQgPSBjNSA9IGM2ID0gMFxuICAgICAgICAgICAgYzErK1xuICAgICAgICAgICAgaGVhZGluZy5udW1iZXJpbmcgPSBjMVxuICAgICAgICAgICAgbnVtYmVyaW5nID0gW2MxXVxuICAgICAgICB9IGVsc2UgaWYoaGVhZGluZy50YWdOYW1lID09PSAnSDInKSB7XG4gICAgICAgICAgICBjMyA9IGM0ID0gYzUgPSBjNiA9IDBcbiAgICAgICAgICAgIGMyKytcbiAgICAgICAgICAgIGhlYWRpbmcubnVtYmVyaW5nID0gYzJcbiAgICAgICAgICAgIG51bWJlcmluZyA9IFtjMSwgYzJdXG4gICAgICAgIH0gZWxzZSBpZihoZWFkaW5nLnRhZ05hbWUgPT09ICdIMycpIHtcbiAgICAgICAgICAgIGM0ID0gYzUgPSBjNiA9IDBcbiAgICAgICAgICAgIGMzKytcbiAgICAgICAgICAgIG51bWJlcmluZyA9IFtjMSwgYzIsIGMzXVxuICAgICAgICB9IGVsc2UgaWYoaGVhZGluZy50YWdOYW1lID09PSAnSDQnKSB7XG4gICAgICAgICAgICBjNSA9IGM2ID0gMFxuICAgICAgICAgICAgYzQrK1xuICAgICAgICAgICAgbnVtYmVyaW5nID0gW2MxLCBjMiwgYzMsIGM0XVxuICAgICAgICB9IGVsc2UgaWYoaGVhZGluZy50YWdOYW1lID09PSAnSDUnKSB7XG4gICAgICAgICAgICBjNiA9IDBcbiAgICAgICAgICAgIGM1KytcbiAgICAgICAgICAgIG51bWJlcmluZyA9IFtjMSwgYzIsIGMzLCBjNCwgYzVdXG4gICAgICAgIH0gZWxzZSBpZihoZWFkaW5nLnRhZ05hbWUgPT09ICdINicpIHtcbiAgICAgICAgICAgIGM2KytcbiAgICAgICAgICAgIG51bWJlcmluZyA9IFtjMSwgYzIsIGMzLCBjNCwgYzUsIGM2XVxuICAgICAgICB9XG5cbiAgICAgICAgaWYobnVtYmVyaW5nKSB7XG4gICAgICAgICAgICBudW1iZXJpbmcuc3BsaWNlKDAsIGFyZ3Muc3RhcnROdW1iZXJpbmdBdExldmVsLTEpXG4gICAgICAgICAgICBoZWFkaW5nLm51bWJlcmluZyA9IG51bWJlcmluZy5qb2luKCcuJylcbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gRE9NRWxlbWVudFxufVxuXG5mdW5jdGlvbiBleHRyYWN0SGVhZGluZ3MoRE9NRWxlbWVudCkge1xuICAgIHZhciB0bXBNYXRjaCwgaGVhZGluZ3MgPSBbXTtcblxuICAgIERPTUVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaDEsIGgyLCBoMywgaDQsIGg1LCBoNicpLmZvckVhY2goZnVuY3Rpb24oaGVhZGluZykge1xuICAgICAgICBpZigodG1wTWF0Y2ggPSBoZWFkaW5nLnRhZ05hbWUubWF0Y2goL15IKFxcZCspJC8pKSAmJiAhaGVhZGluZy5jbGFzc0xpc3QuY29udGFpbnMoJ25vLXRvYy1saXN0aW5nJykpIHtcbiAgICAgICAgICAgIGhlYWRpbmdzLnB1c2goe1xuICAgICAgICAgICAgICAgIGxldmVsOiBwYXJzZUludCh0bXBNYXRjaFsxXSksXG4gICAgICAgICAgICAgICAgY29udGVudDogaGVhZGluZy5pbm5lclRleHQsXG4gICAgICAgICAgICAgICAgZWw6IGhlYWRpbmcsXG4gICAgICAgICAgICAgICAgbnVtYmVyaW5nOiBoZWFkaW5nLm51bWJlcmluZ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGhlYWRpbmdzO1xufVxuXG5mdW5jdGlvbiByZXBhaXJIaWVyYXJjaHkoaGVhZGluZ3MpIHtcbiAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgIGN1cnJlbnRMZXZlbCA9IDFcblxuICAgIGhlYWRpbmdzLmZvckVhY2goKGhlYWRpbmcpID0+IHtcbiAgICAgICAgbGV0IG1pc3NpbmdMZXZlbHMgPSAoaGVhZGluZy5sZXZlbCAtIGN1cnJlbnRMZXZlbClcblxuICAgICAgICBmb3IobGV0IGk9MDsgbWlzc2luZ0xldmVscz4xOyBtaXNzaW5nTGV2ZWxzLS0pIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG1pc3NpbmdMZXZlbFdhcmluZygrK2N1cnJlbnRMZXZlbCkpXG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQucHVzaChoZWFkaW5nKVxuXG4gICAgICAgIGlmKG1pc3NpbmdMZXZlbHMgPiAwKSB7XG4gICAgICAgICAgICBjdXJyZW50TGV2ZWwrK1xuICAgICAgICB9IGVsc2UgaWYobWlzc2luZ0xldmVscyA8IDApIHtcbiAgICAgICAgICAgIGN1cnJlbnRMZXZlbC0tXG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBUT0NGcm9tRE9NRWxlbWVudChET01FbGVtZW50LCBhcmdzKSB7XG4gICAgYXJncyA9IGFyZ3MgfHwge31cbiAgICB2YXIgaGVhZGluZ3MgPSByZXBhaXJIaWVyYXJjaHkoZXh0cmFjdEhlYWRpbmdzKGFubm90YXRlSGVhZGluZ051bWJlcmluZyhET01FbGVtZW50LCBhcmdzKSkpLFxuICAgICAgICByZXN1bHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvbCcpLFxuICAgICAgICBjdXJyZW50TGlzdCA9IHJlc3VsdCxcbiAgICAgICAgY3VycmVudExldmVsID0gMVxuXG4gICAgaGVhZGluZ3MuZm9yRWFjaCgoaGVhZGluZykgPT4ge1xuICAgICAgICBpZihjdXJyZW50TGV2ZWwgPCBoZWFkaW5nLmxldmVsKSB7XG4gICAgICAgICAgICBsZXQgdG1wTGlzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29sJylcbiAgICAgICAgICAgIGN1cnJlbnRMaXN0LmFwcGVuZENoaWxkKHRtcExpc3QpXG4gICAgICAgICAgICBjdXJyZW50TGlzdCA9IHRtcExpc3RcbiAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IGN1cnJlbnRMZXZlbCsxXG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZShjdXJyZW50TGV2ZWwgPiBoZWFkaW5nLmxldmVsKSB7XG4gICAgICAgICAgICBjdXJyZW50TGlzdCA9IGN1cnJlbnRMaXN0LnBhcmVudE5vZGVcbiAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IGN1cnJlbnRMZXZlbC0xXG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50TGlzdC5hcHBlbmRDaGlsZChUT0NFbnRyeUZyb21FbGVtZW50KGhlYWRpbmcsIGFyZ3MpKVxuICAgIH0pXG5cbiAgICByZXR1cm4gcmVzdWx0XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVE9DRnJvbURPTUVsZW1lbnRcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAgIFpvdGVyb09ubGluZTogcmVxdWlyZSgnLi9vbmxpbmUnKVxufSIsInZhciBtb250aHMgPSBbJ0phbi4nLCAnRmViLicsICdNYXIuJywgJ0Fwci4nLCAnTWF5LicsICdKdW4uJywgJ0p1bC4nLCAnQXVnLicsICdTZXAuJywgJ09jdC4nLCAnTm92LicsICdEZWMnXVxuXG5mdW5jdGlvbiBnZXROZXh0TGluayhyZXN1bHQpIHtcbiAgICBjb25zdCBsaW5rSGVhZGVyID0gcmVzdWx0LmhlYWRlcnMuZ2V0KCdMaW5rJylcbiAgICBjb25zdCBuZXh0TWF0Y2ggPSBsaW5rSGVhZGVyLnNwbGl0KCcsJykubWFwKHggPT4geC5tYXRjaCgvPCguKz8pPjsgcmVsPVwiKC4rPylcIi8pKS5maW5kKHggPT4geFswXSAmJiB4WzFdICYmIHhbMl0gPT09ICduZXh0JylcblxuICAgIGlmKG5leHRNYXRjaCAmJiBuZXh0TWF0Y2hbMV0pIHtcbiAgICAgICAgcmV0dXJuIG5leHRNYXRjaFsxXVxuICAgIH1cbn1cblxuY2xhc3MgWm90ZXJvT25saW5lIHtcblxuICAgIHN0YXRpYyB0cmFuc2Zvcm1SZXNwb25zZUl0ZW0oaXRlbSwgbGFzdE1vZFZlcnNpb24pIHtcbiAgICAgICAgY29uc3QgdHlwZU1hcCA9IHtcbiAgICAgICAgICAgICdib29rJzogJ0Jvb2snLFxuICAgICAgICAgICAgJ3dlYnBhZ2UnOiAnV2Vic2l0ZScsXG4gICAgICAgICAgICAnZW5jeWNsb3BlZGlhQXJ0aWNsZSc6ICdXZWJzaXRlJyxcbiAgICAgICAgICAgICdibG9nUG9zdCc6ICdXZWJzaXRlJyxcbiAgICAgICAgICAgICd0aGVzaXMnOiAnTWFzdGVyc3RoZXNpcycsXG4gICAgICAgICAgICAnY29uZmVyZW5jZVBhcGVyJzogJ0NvbmZlcmVuY2UnLFxuICAgICAgICAgICAgJ2pvdXJuYWxBcnRpY2xlJzogJ0FydGljbGUnLFxuICAgICAgICAgICAgJ2Jvb2tTZWN0aW9uJzogJ0luYm9vaydcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGdldENyZWF0b3JzQnlUeXBldCA9IHR5cGUgPT4ge1xuICAgICAgICAgICAgaWYoIWl0ZW0gfHwgIWl0ZW0uZGF0YSB8fCAhaXRlbS5kYXRhLmNyZWF0b3JzIHx8ICFpdGVtLmRhdGEuY3JlYXRvcnMuZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpdGVtLmRhdGEuY3JlYXRvcnNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGMgPT4gYylcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGMgPT4gYy5jcmVhdG9yVHlwZSA9PT0gdHlwZSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGMgPT4gYy5sYXN0TmFtZSAmJiBjLmZpcnN0TmFtZSlcbiAgICAgICAgICAgICAgICAubWFwKGMgPT4gYCR7Yy5sYXN0TmFtZX0sICR7Yy5maXJzdE5hbWV9YClcbiAgICAgICAgICAgICAgICAuam9pbignIGFuZCAnKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdHJ5VG9QYXJzZVllYXIgPSBkYXRlID0+IHtcbiAgICAgICAgICAgIGlmKCFkYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChuZXcgRGF0ZShkYXRlKSkuZ2V0RnVsbFllYXIoKS50b1N0cmluZygpXG4gICAgICAgICAgICB9IGNhdGNoKGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0cnlUb1BhcnNlTW9udGggPSBkYXRlID0+IHtcbiAgICAgICAgICAgIGlmKCFkYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vbnRoc1sobmV3IERhdGUoZGF0ZSkpLmdldE1vbnRoKCldXG4gICAgICAgICAgICB9IGNhdGNoKGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0cnlUb1BhcnNlRGF0ZSA9IGRhdGUgPT4ge1xuICAgICAgICAgICAgaWYoIWRhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJydcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZS5zcGxpdCgnVCcpWzBdXG4gICAgICAgICAgICB9IGNhdGNoKGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZihpdGVtLmRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbG9va3VwSWQ6IGl0ZW0uZGF0YS5JU0JOIHx8IGl0ZW0uZGF0YS5ET0ksXG4gICAgICAgICAgICAgICAgaWQ6IGl0ZW0ua2V5LFxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGVNYXBbaXRlbS5kYXRhLml0ZW1UeXBlXSB8fCAnQXJ0aWNsZScsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlU291cmNlOiBgem90ZXJvLW9ubGluZS0ke2l0ZW0ubGlicmFyeS50eXBlfS0ke2l0ZW0ubGlicmFyeS5pZH1gLFxuICAgICAgICAgICAgICAgIHRpdGxlOiBpdGVtLmRhdGEudGl0bGUsXG4gICAgICAgICAgICAgICAgYXV0aG9yOiBnZXRDcmVhdG9yc0J5VHlwZXQoJ2F1dGhvcicpLFxuICAgICAgICAgICAgICAgIHBhZ2VzOiBpdGVtLmRhdGEubnVtUGFnZXMsXG4gICAgICAgICAgICAgICAgdm9sdW1lOiBpdGVtLmRhdGEudmFsdW1lLFxuICAgICAgICAgICAgICAgIHVybDogaXRlbS5kYXRhLnVybCxcbiAgICAgICAgICAgICAgICBzZXJpZXM6IGl0ZW0uZGF0YS5zZXJpZXMsXG4gICAgICAgICAgICAgICAgcHVibGlzaGVyOiBpdGVtLmRhdGEucHVibGlzaGVyLFxuICAgICAgICAgICAgICAgIGVkaXRpb246IGl0ZW0uZGF0YS5lZGl0aW9uLFxuICAgICAgICAgICAgICAgIGRhdGU6IHRyeVRvUGFyc2VEYXRlKGl0ZW0uZGF0YS5hY2Nlc3NEYXRlKSxcbiAgICAgICAgICAgICAgICBzZXJpZXM6IGl0ZW0uZGF0YS5zZXJpZXNOdW1iZXIsXG4gICAgICAgICAgICAgICAgYm9va3RpdGxlOiBpdGVtLmRhdGEuYm9va1RpdGxlLFxuICAgICAgICAgICAgICAgIHllYXI6IHRyeVRvUGFyc2VZZWFyKGl0ZW0uZGF0YS5kYXRlKSxcbiAgICAgICAgICAgICAgICBtb250aDogdHJ5VG9QYXJzZU1vbnRoKGl0ZW0uZGF0YS5kYXRlKSxcbiAgICAgICAgICAgICAgICBlZGl0b3I6IGdldENyZWF0b3JzQnlUeXBldCgnZWRpdG9yJyksXG4gICAgICAgICAgICAgICAgem90ZXJvTGFzdE1vZFZlcnNpb246IGxhc3RNb2RWZXJzaW9uXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihhcGlLZXksIHN0b3JlKSB7XG4gICAgICAgIHRoaXMuYXBpS2V5ID0gYXBpS2V5XG4gICAgICAgIHRoaXMuc3RvcmUgPSBzdG9yZSB8fCBuZXcgTWFwKClcbiAgICAgICAgdGhpcy5hdXRoSGVhZGVyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dGhpcy5hcGlLZXl9YFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0TGFzdE1vZGlmaWVkVmVyc2lvbihzY29wZSwgc2NvcGVJRCkge1xuICAgICAgICBzY29wZSA9IHNjb3BlID09PSAndXNlcnMnID8gJ3VzZXInIDogJ2dyb3VwJ1xuXG4gICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuc3RvcmUuYWxsKHRydWUpKVxuICAgICAgICAgICAgLmZpbHRlcihpdGVtID0+IGl0ZW0uaWQuc3RhcnRzV2l0aChgem90ZXJvLW9ubGluZS1pdGVtLSR7c2NvcGVJRH1gKSlcbiAgICAgICAgICAgIC5tYXAoaXRlbSA9PiBpdGVtLnpvdGVyb0xhc3RNb2RWZXJzaW9uIHx8IDApXG4gICAgICAgICAgICAucmVkdWNlKChhLCBiKSA9PiBNYXRoLm1heChhLCBiKSwgMClcbiAgICB9XG5cbiAgICBhc3luYyBzYXZlSXRlbShpdGVtLCBzY29wZUlEKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UucmVzb2x2ZSh0aGlzLnN0b3JlLnNldChgem90ZXJvLW9ubGluZS1pdGVtLSR7c2NvcGVJRH0tJHtpdGVtLmlkfWAsIGl0ZW0pKVxuICAgICAgICByZXR1cm4gaXRlbVxuICAgIH1cblxuICAgIHNhdmVBbGxJdGVtKGl0ZW1zLCBsYXN0TW9kVmVyc2lvbiwgc2NvcGVJRCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoaXRlbXMubWFwKGl0ZW0gPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2F2ZUl0ZW0oWm90ZXJvT25saW5lLnRyYW5zZm9ybVJlc3BvbnNlSXRlbShpdGVtLCBsYXN0TW9kVmVyc2lvbiksIHNjb3BlSUQpXG4gICAgICAgIH0pKVxuICAgIH1cblxuICAgIGFzeW5jIGxvYWRVc2VySW5mbygpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZmV0Y2goYGh0dHBzOi8vYXBpLnpvdGVyby5vcmcva2V5cy8ke3RoaXMuYXBpS2V5fWApXG4gICAgICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXN1bHQuanNvbigpXG4gICAgICAgIHRoaXMudXNlcklEID0gYm9keS51c2VySURcbiAgICAgICAgdGhpcy51c2VyTmFtZSA9IGJvZHkudXNlcm5hbWVcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBhc3luYyBncm91cHMoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZldGNoKGBodHRwczovL2FwaS56b3Rlcm8ub3JnL3VzZXJzLyR7dGhpcy51c2VySUR9L2dyb3Vwc2AsIHRoaXMuYXV0aEhlYWRlck9wdGlvbnMpXG4gICAgICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXN1bHQuanNvbigpXG4gICAgICAgIHRoaXMuX2dyb3VwcyA9IGJvZHkubWFwKHIgPT4gci5kYXRhKVxuICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXBzXG4gICAgfVxuXG4gICAgYXN5bmMgaXRlbXMoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMucmVxdWVzdEl0ZW1zKCd1c2VycycsIHRoaXMudXNlcklEKVxuXG4gICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuc3RvcmUuYWxsKHRydWUpKVxuICAgICAgICAgICAgLmZpbHRlcihpdGVtID0+IGl0ZW0uaWQuc3RhcnRzV2l0aChgem90ZXJvLW9ubGluZS1pdGVtLSR7dGhpcy51c2VySUR9YCkpXG4gICAgfVxuXG4gICAgYXN5bmMgaXRlbXNCeUdyb3VwSUQoZ3JvdXBJRCkge1xuICAgICAgICBhd2FpdCB0aGlzLnJlcXVlc3RJdGVtcygnZ3JvdXBzJywgZ3JvdXBJRClcblxuICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLnN0b3JlLmFsbCh0cnVlKSlcbiAgICAgICAgICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtLmlkLnN0YXJ0c1dpdGgoYHpvdGVyby1vbmxpbmUtaXRlbS0ke2dyb3VwSUR9YCkpXG4gICAgfVxuXG4gICAgYXN5bmMgcmVxdWVzdEl0ZW1zKHNjb3BlLCBzY29wZUlEKSB7XG4gICAgICAgIHZhciBbIGJvZHksIG5leHRMaW5rLCBsYXN0TW9kVmVyc2lvbl0gPSBhd2FpdCB0aGlzLnJlcXVlc3RKc29uKGBodHRwczovL2FwaS56b3Rlcm8ub3JnLyR7c2NvcGV9LyR7c2NvcGVJRH0vaXRlbXM/c2luY2U9JHthd2FpdCB0aGlzLmdldExhc3RNb2RpZmllZFZlcnNpb24oc2NvcGUsIHNjb3BlSUQpfWApXG4gICAgICAgIHZhciBuZXh0TGluaztcblxuICAgICAgICB2YXIgc3RvcmVkVmFsdWVzID0gYXdhaXQgdGhpcy5zYXZlQWxsSXRlbShib2R5LCBsYXN0TW9kVmVyc2lvbiwgc2NvcGVJRClcblxuICAgICAgICB3aGlsZShuZXh0TGluaykge1xuICAgICAgICAgICAgWyBib2R5LCBuZXh0TGluayBdID0gYXdhaXQgdGhpcy5yZXF1ZXN0SnNvbihuZXh0TGluaylcbiAgICAgICAgICAgIHN0b3JlZFZhbHVlcy5wdXNoKC4uLihhd2FpdCB0aGlzLnNhdmVBbGxJdGVtKGJvZHksIGxhc3RNb2RWZXJzaW9uLCBzY29wZUlEKSkpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhzdG9yZWRWYWx1ZXMpXG4gICAgfVxuXG4gICAgYXN5bmMgcmVxdWVzdEpzb24odXJsKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZldGNoKHVybCwgdGhpcy5hdXRoSGVhZGVyT3B0aW9ucylcblxuICAgICAgICBpZihyZXN1bHQuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICAgIHRocm93ICdFcnJvciB3aGlsZSBjb25uZWN0aW5nIHRvIFpvdGVybyBBUEknXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgYXdhaXQgcmVzdWx0Lmpzb24oKSxcbiAgICAgICAgICAgIGdldE5leHRMaW5rKHJlc3VsdCksXG4gICAgICAgICAgICByZXN1bHQuaGVhZGVycy5nZXQoJ0xhc3QtTW9kaWZpZWQtVmVyc2lvbicpXG4gICAgICAgIF1cbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gWm90ZXJvT25saW5lIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29udGFpbnMocGFyZW50LCBjaGlsZCkge1xuICAvLyAkRmxvd0ZpeE1lOiBoYXNPd25Qcm9wZXJ0eSBkb2Vzbid0IHNlZW0gdG8gd29yayBpbiB0ZXN0c1xuICB2YXIgaXNTaGFkb3cgPSBCb29sZWFuKGNoaWxkLmdldFJvb3ROb2RlICYmIGNoaWxkLmdldFJvb3ROb2RlKCkuaG9zdCk7IC8vIEZpcnN0LCBhdHRlbXB0IHdpdGggZmFzdGVyIG5hdGl2ZSBtZXRob2RcblxuICBpZiAocGFyZW50LmNvbnRhaW5zKGNoaWxkKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIHRoZW4gZmFsbGJhY2sgdG8gY3VzdG9tIGltcGxlbWVudGF0aW9uIHdpdGggU2hhZG93IERPTSBzdXBwb3J0XG4gIGVsc2UgaWYgKGlzU2hhZG93KSB7XG4gICAgICB2YXIgbmV4dCA9IGNoaWxkO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChuZXh0ICYmIHBhcmVudC5pc1NhbWVOb2RlKG5leHQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gLy8gJEZsb3dGaXhNZTogbmVlZCBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXMuLi5cblxuXG4gICAgICAgIG5leHQgPSBuZXh0LnBhcmVudE5vZGUgfHwgbmV4dC5ob3N0O1xuICAgICAgfSB3aGlsZSAobmV4dCk7XG4gICAgfSAvLyBHaXZlIHVwLCB0aGUgcmVzdWx0IGlzIGZhbHNlXG5cblxuICByZXR1cm4gZmFsc2U7XG59IiwiaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcblxuZnVuY3Rpb24gdG9OdW1iZXIoY3NzVmFsdWUpIHtcbiAgcmV0dXJuIHBhcnNlRmxvYXQoY3NzVmFsdWUpIHx8IDA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEJvcmRlcnMoZWxlbWVudCkge1xuICB2YXIgY29tcHV0ZWRTdHlsZSA9IGlzSFRNTEVsZW1lbnQoZWxlbWVudCkgPyBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpIDoge307XG4gIHJldHVybiB7XG4gICAgdG9wOiB0b051bWJlcihjb21wdXRlZFN0eWxlLmJvcmRlclRvcFdpZHRoKSxcbiAgICByaWdodDogdG9OdW1iZXIoY29tcHV0ZWRTdHlsZS5ib3JkZXJSaWdodFdpZHRoKSxcbiAgICBib3R0b206IHRvTnVtYmVyKGNvbXB1dGVkU3R5bGUuYm9yZGVyQm90dG9tV2lkdGgpLFxuICAgIGxlZnQ6IHRvTnVtYmVyKGNvbXB1dGVkU3R5bGUuYm9yZGVyTGVmdFdpZHRoKVxuICB9O1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KSB7XG4gIHZhciByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0LFxuICAgIHRvcDogcmVjdC50b3AsXG4gICAgcmlnaHQ6IHJlY3QucmlnaHQsXG4gICAgYm90dG9tOiByZWN0LmJvdHRvbSxcbiAgICBsZWZ0OiByZWN0LmxlZnQsXG4gICAgeDogcmVjdC5sZWZ0LFxuICAgIHk6IHJlY3QudG9wXG4gIH07XG59IiwiaW1wb3J0IHsgdmlld3BvcnQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBnZXRWaWV3cG9ydFJlY3QgZnJvbSBcIi4vZ2V0Vmlld3BvcnRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRSZWN0IGZyb20gXCIuL2dldERvY3VtZW50UmVjdC5qc1wiO1xuaW1wb3J0IGxpc3RTY3JvbGxQYXJlbnRzIGZyb20gXCIuL2xpc3RTY3JvbGxQYXJlbnRzLmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCB7IGlzRWxlbWVudCwgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0RGVjb3JhdGlvbnMgZnJvbSBcIi4vZ2V0RGVjb3JhdGlvbnMuanNcIjtcbmltcG9ydCBjb250YWlucyBmcm9tIFwiLi9jb250YWlucy5qc1wiO1xuaW1wb3J0IHJlY3RUb0NsaWVudFJlY3QgZnJvbSBcIi4uL3V0aWxzL3JlY3RUb0NsaWVudFJlY3QuanNcIjtcblxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgY2xpcHBpbmdQYXJlbnQpIHtcbiAgcmV0dXJuIGNsaXBwaW5nUGFyZW50ID09PSB2aWV3cG9ydCA/IHJlY3RUb0NsaWVudFJlY3QoZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQpKSA6IGlzSFRNTEVsZW1lbnQoY2xpcHBpbmdQYXJlbnQpID8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGNsaXBwaW5nUGFyZW50KSA6IHJlY3RUb0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkpO1xufSAvLyBBIFwiY2xpcHBpbmcgcGFyZW50XCIgaXMgYW4gb3ZlcmZsb3dhYmxlIGNvbnRhaW5lciB3aXRoIHRoZSBjaGFyYWN0ZXJpc3RpYyBvZlxuLy8gY2xpcHBpbmcgKG9yIGhpZGluZykgb3ZlcmZsb3dpbmcgZWxlbWVudHMgd2l0aCBhIHBvc2l0aW9uIGRpZmZlcmVudCBmcm9tXG4vLyBgaW5pdGlhbGBcblxuXG5mdW5jdGlvbiBnZXRDbGlwcGluZ1BhcmVudHMoZWxlbWVudCkge1xuICB2YXIgY2xpcHBpbmdQYXJlbnRzID0gbGlzdFNjcm9sbFBhcmVudHMoZWxlbWVudCk7XG4gIHZhciBjYW5Fc2NhcGVDbGlwcGluZyA9IFsnYWJzb2x1dGUnLCAnZml4ZWQnXS5pbmRleE9mKGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24pID49IDA7XG4gIHZhciBjbGlwcGVyRWxlbWVudCA9IGNhbkVzY2FwZUNsaXBwaW5nICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkgPyBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkgOiBlbGVtZW50O1xuXG4gIGlmICghaXNFbGVtZW50KGNsaXBwZXJFbGVtZW50KSkge1xuICAgIHJldHVybiBbXTtcbiAgfSAvLyAkRmxvd0ZpeE1lOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMTQxNFxuXG5cbiAgcmV0dXJuIGNsaXBwaW5nUGFyZW50cy5maWx0ZXIoZnVuY3Rpb24gKGNsaXBwaW5nUGFyZW50KSB7XG4gICAgcmV0dXJuIGlzRWxlbWVudChjbGlwcGluZ1BhcmVudCkgJiYgY29udGFpbnMoY2xpcHBpbmdQYXJlbnQsIGNsaXBwZXJFbGVtZW50KTtcbiAgfSk7XG59IC8vIEdldHMgdGhlIG1heGltdW0gYXJlYSB0aGF0IHRoZSBlbGVtZW50IGlzIHZpc2libGUgaW4gZHVlIHRvIGFueSBudW1iZXIgb2Zcbi8vIGNsaXBwaW5nIHBhcmVudHNcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRDbGlwcGluZ1JlY3QoZWxlbWVudCwgYm91bmRhcnksIHJvb3RCb3VuZGFyeSkge1xuICB2YXIgbWFpbkNsaXBwaW5nUGFyZW50cyA9IGJvdW5kYXJ5ID09PSAnY2xpcHBpbmdQYXJlbnRzJyA/IGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50KSA6IFtdLmNvbmNhdChib3VuZGFyeSk7XG4gIHZhciBjbGlwcGluZ1BhcmVudHMgPSBbXS5jb25jYXQobWFpbkNsaXBwaW5nUGFyZW50cywgW3Jvb3RCb3VuZGFyeV0pO1xuICB2YXIgZmlyc3RDbGlwcGluZ1BhcmVudCA9IGNsaXBwaW5nUGFyZW50c1swXTtcbiAgdmFyIGNsaXBwaW5nUmVjdCA9IGNsaXBwaW5nUGFyZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjY1JlY3QsIGNsaXBwaW5nUGFyZW50KSB7XG4gICAgdmFyIHJlY3QgPSBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBjbGlwcGluZ1BhcmVudCk7XG4gICAgdmFyIGRlY29yYXRpb25zID0gZ2V0RGVjb3JhdGlvbnMoaXNIVE1MRWxlbWVudChjbGlwcGluZ1BhcmVudCkgPyBjbGlwcGluZ1BhcmVudCA6IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSk7XG4gICAgYWNjUmVjdC50b3AgPSBNYXRoLm1heChyZWN0LnRvcCArIGRlY29yYXRpb25zLnRvcCwgYWNjUmVjdC50b3ApO1xuICAgIGFjY1JlY3QucmlnaHQgPSBNYXRoLm1pbihyZWN0LnJpZ2h0IC0gZGVjb3JhdGlvbnMucmlnaHQsIGFjY1JlY3QucmlnaHQpO1xuICAgIGFjY1JlY3QuYm90dG9tID0gTWF0aC5taW4ocmVjdC5ib3R0b20gLSBkZWNvcmF0aW9ucy5ib3R0b20sIGFjY1JlY3QuYm90dG9tKTtcbiAgICBhY2NSZWN0LmxlZnQgPSBNYXRoLm1heChyZWN0LmxlZnQgKyBkZWNvcmF0aW9ucy5sZWZ0LCBhY2NSZWN0LmxlZnQpO1xuICAgIHJldHVybiBhY2NSZWN0O1xuICB9LCBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBmaXJzdENsaXBwaW5nUGFyZW50KSk7XG4gIGNsaXBwaW5nUmVjdC53aWR0aCA9IGNsaXBwaW5nUmVjdC5yaWdodCAtIGNsaXBwaW5nUmVjdC5sZWZ0O1xuICBjbGlwcGluZ1JlY3QuaGVpZ2h0ID0gY2xpcHBpbmdSZWN0LmJvdHRvbSAtIGNsaXBwaW5nUmVjdC50b3A7XG4gIGNsaXBwaW5nUmVjdC54ID0gY2xpcHBpbmdSZWN0LmxlZnQ7XG4gIGNsaXBwaW5nUmVjdC55ID0gY2xpcHBpbmdSZWN0LnRvcDtcbiAgcmV0dXJuIGNsaXBwaW5nUmVjdDtcbn0iLCJpbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGdldE5vZGVTY3JvbGwgZnJvbSBcIi4vZ2V0Tm9kZVNjcm9sbC5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbEJhclggZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsQmFyWC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBpc1Njcm9sbFBhcmVudCBmcm9tIFwiLi9pc1Njcm9sbFBhcmVudC5qc1wiOyAvLyBSZXR1cm5zIHRoZSBjb21wb3NpdGUgcmVjdCBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIGl0cyBvZmZzZXRQYXJlbnQuXG4vLyBDb21wb3NpdGUgbWVhbnMgaXQgdGFrZXMgaW50byBhY2NvdW50IHRyYW5zZm9ybXMgYXMgd2VsbCBhcyBsYXlvdXQuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENvbXBvc2l0ZVJlY3QoZWxlbWVudE9yVmlydHVhbEVsZW1lbnQsIG9mZnNldFBhcmVudCwgaXNGaXhlZCkge1xuICBpZiAoaXNGaXhlZCA9PT0gdm9pZCAwKSB7XG4gICAgaXNGaXhlZCA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIGRvY3VtZW50RWxlbWVudCA9IGdldERvY3VtZW50RWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICB2YXIgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCk7XG4gIHZhciBzY3JvbGwgPSB7XG4gICAgc2Nyb2xsTGVmdDogMCxcbiAgICBzY3JvbGxUb3A6IDBcbiAgfTtcbiAgdmFyIG9mZnNldHMgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG5cbiAgaWYgKCFpc0ZpeGVkKSB7XG4gICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdib2R5JyB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzEwNzhcbiAgICBpc1Njcm9sbFBhcmVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgfVxuXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgb2Zmc2V0cyA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQpO1xuICAgICAgb2Zmc2V0cy54ICs9IG9mZnNldFBhcmVudC5jbGllbnRMZWZ0O1xuICAgICAgb2Zmc2V0cy55ICs9IG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIG9mZnNldHMueCA9IGdldFdpbmRvd1Njcm9sbEJhclgoZG9jdW1lbnRFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IHJlY3QubGVmdCArIHNjcm9sbC5zY3JvbGxMZWZ0IC0gb2Zmc2V0cy54LFxuICAgIHk6IHJlY3QudG9wICsgc2Nyb2xsLnNjcm9sbFRvcCAtIG9mZnNldHMueSxcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gIH07XG59IiwiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0V2luZG93KGVsZW1lbnQpLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG59IiwiaW1wb3J0IGdldEJvcmRlcnMgZnJvbSBcIi4vZ2V0Qm9yZGVycy5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbEJhclggZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsQmFyWC5qc1wiOyAvLyBCb3JkZXJzICsgc2Nyb2xsYmFyc1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXREZWNvcmF0aW9ucyhlbGVtZW50KSB7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIHZhciBib3JkZXJzID0gZ2V0Qm9yZGVycyhlbGVtZW50KTtcbiAgdmFyIGlzSFRNTCA9IGdldE5vZGVOYW1lKGVsZW1lbnQpID09PSAnaHRtbCc7XG4gIHZhciB3aW5TY3JvbGxCYXJYID0gZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KTtcbiAgdmFyIHggPSBlbGVtZW50LmNsaWVudFdpZHRoICsgYm9yZGVycy5yaWdodDtcbiAgdmFyIHkgPSBlbGVtZW50LmNsaWVudEhlaWdodCArIGJvcmRlcnMuYm90dG9tOyAvLyBIQUNLOlxuICAvLyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0IG9uIGlPUyByZXBvcnRzIHRoZSBoZWlnaHQgb2YgdGhlXG4gIC8vIHZpZXdwb3J0IGluY2x1ZGluZyB0aGUgYm90dG9tIGJhciwgZXZlbiBpZiB0aGUgYm90dG9tIGJhciBpc24ndCB2aXNpYmxlLlxuICAvLyBJZiB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHdpbmRvdyBpbm5lckhlaWdodCBhbmQgaHRtbCBjbGllbnRIZWlnaHQgaXMgbW9yZVxuICAvLyB0aGFuIDUwLCB3ZSBhc3N1bWUgaXQncyBhIG1vYmlsZSBib3R0b20gYmFyIGFuZCBpZ25vcmUgc2Nyb2xsYmFycy5cbiAgLy8gKiBBIDUwcHggdGhpY2sgc2Nyb2xsYmFyIGlzIGxpa2VseSBub24tZXhpc3RlbnQgKG1hY09TIGlzIDE1cHggYW5kIFdpbmRvd3NcbiAgLy8gICBpcyBhYm91dCAxN3B4KVxuICAvLyAqIFRoZSBtb2JpbGUgYmFyIGlzIDExNHB4IHRhbGxcblxuICBpZiAoaXNIVE1MICYmIHdpbi5pbm5lckhlaWdodCAtIGVsZW1lbnQuY2xpZW50SGVpZ2h0ID4gNTApIHtcbiAgICB5ID0gd2luLmlubmVySGVpZ2h0IC0gYm9yZGVycy5ib3R0b207XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRvcDogaXNIVE1MID8gMCA6IGVsZW1lbnQuY2xpZW50VG9wLFxuICAgIHJpZ2h0OiAvLyBSVEwgc2Nyb2xsYmFyIChzY3JvbGxpbmcgY29udGFpbmVycyBvbmx5KVxuICAgIGVsZW1lbnQuY2xpZW50TGVmdCA+IGJvcmRlcnMubGVmdCA/IGJvcmRlcnMucmlnaHQgOiAvLyBMVFIgc2Nyb2xsYmFyXG4gICAgaXNIVE1MID8gd2luLmlubmVyV2lkdGggLSB4IC0gd2luU2Nyb2xsQmFyWCA6IGVsZW1lbnQub2Zmc2V0V2lkdGggLSB4LFxuICAgIGJvdHRvbTogaXNIVE1MID8gd2luLmlubmVySGVpZ2h0IC0geSA6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0IC0geSxcbiAgICBsZWZ0OiBpc0hUTUwgPyB3aW5TY3JvbGxCYXJYIDogZWxlbWVudC5jbGllbnRMZWZ0XG4gIH07XG59IiwiaW1wb3J0IHsgaXNFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpIHtcbiAgLy8gJEZsb3dGaXhNZTogYXNzdW1lIGJvZHkgaXMgYWx3YXlzIGF2YWlsYWJsZVxuICByZXR1cm4gKGlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQub3duZXJEb2N1bWVudCA6IGVsZW1lbnQuZG9jdW1lbnQpLmRvY3VtZW50RWxlbWVudDtcbn0iLCJpbXBvcnQgZ2V0Q29tcG9zaXRlUmVjdCBmcm9tIFwiLi9nZXRDb21wb3NpdGVSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGwgZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXREb2N1bWVudFJlY3QoZWxlbWVudCkge1xuICB2YXIgd2luID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICB2YXIgd2luU2Nyb2xsID0gZ2V0V2luZG93U2Nyb2xsKGVsZW1lbnQpO1xuICB2YXIgZG9jdW1lbnRSZWN0ID0gZ2V0Q29tcG9zaXRlUmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCksIHdpbik7XG4gIGRvY3VtZW50UmVjdC5oZWlnaHQgPSBNYXRoLm1heChkb2N1bWVudFJlY3QuaGVpZ2h0LCB3aW4uaW5uZXJIZWlnaHQpO1xuICBkb2N1bWVudFJlY3Qud2lkdGggPSBNYXRoLm1heChkb2N1bWVudFJlY3Qud2lkdGgsIHdpbi5pbm5lcldpZHRoKTtcbiAgZG9jdW1lbnRSZWN0LnggPSAtd2luU2Nyb2xsLnNjcm9sbExlZnQ7XG4gIGRvY3VtZW50UmVjdC55ID0gLXdpblNjcm9sbC5zY3JvbGxUb3A7XG4gIHJldHVybiBkb2N1bWVudFJlY3Q7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0SFRNTEVsZW1lbnRTY3JvbGwoZWxlbWVudCkge1xuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IGVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICBzY3JvbGxUb3A6IGVsZW1lbnQuc2Nyb2xsVG9wXG4gIH07XG59IiwiLy8gUmV0dXJucyB0aGUgbGF5b3V0IHJlY3Qgb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byBpdHMgb2Zmc2V0UGFyZW50LiBMYXlvdXRcbi8vIG1lYW5zIGl0IGRvZXNuJ3QgdGFrZSBpbnRvIGFjY291bnQgdHJhbnNmb3Jtcy5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldExheW91dFJlY3QoZWxlbWVudCkge1xuICByZXR1cm4ge1xuICAgIHg6IGVsZW1lbnQub2Zmc2V0TGVmdCxcbiAgICB5OiBlbGVtZW50Lm9mZnNldFRvcCxcbiAgICB3aWR0aDogZWxlbWVudC5vZmZzZXRXaWR0aCxcbiAgICBoZWlnaHQ6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0XG4gIH07XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Tm9kZU5hbWUoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudCA/IChlbGVtZW50Lm5vZGVOYW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcbn0iLCJpbXBvcnQgZ2V0V2luZG93U2Nyb2xsIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgZ2V0SFRNTEVsZW1lbnRTY3JvbGwgZnJvbSBcIi4vZ2V0SFRNTEVsZW1lbnRTY3JvbGwuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE5vZGVTY3JvbGwobm9kZSkge1xuICBpZiAobm9kZSA9PT0gZ2V0V2luZG93KG5vZGUpIHx8ICFpc0hUTUxFbGVtZW50KG5vZGUpKSB7XG4gICAgcmV0dXJuIGdldFdpbmRvd1Njcm9sbChub2RlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2V0SFRNTEVsZW1lbnRTY3JvbGwobm9kZSk7XG4gIH1cbn0iLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IGlzVGFibGVFbGVtZW50IGZyb20gXCIuL2lzVGFibGVFbGVtZW50LmpzXCI7XG5cbmZ1bmN0aW9uIGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy84MzdcbiAgZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQub2Zmc2V0UGFyZW50O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICB2YXIgd2luZG93ID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50KTsgLy8gRmluZCB0aGUgbmVhcmVzdCBub24tdGFibGUgb2Zmc2V0UGFyZW50XG5cbiAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBpc1RhYmxlRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChvZmZzZXRQYXJlbnQpO1xuICB9XG5cbiAgaWYgKG9mZnNldFBhcmVudCAmJiBnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnYm9keScgJiYgZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJykge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0UGFyZW50IHx8IHdpbmRvdztcbn0iLCJpbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRQYXJlbnROb2RlKGVsZW1lbnQpIHtcbiAgaWYgKGdldE5vZGVOYW1lKGVsZW1lbnQpID09PSAnaHRtbCcpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiAoLy8gJEZsb3dGaXhNZTogdGhpcyBpcyBhIHF1aWNrZXIgKGJ1dCBsZXNzIHR5cGUgc2FmZSkgd2F5IHRvIHNhdmUgcXVpdGUgc29tZSBieXRlcyBmcm9tIHRoZSBidW5kbGVcbiAgICBlbGVtZW50LmFzc2lnbmVkU2xvdCB8fCAvLyBzdGVwIGludG8gdGhlIHNoYWRvdyBET00gb2YgdGhlIHBhcmVudCBvZiBhIHNsb3R0ZWQgbm9kZVxuICAgIGVsZW1lbnQucGFyZW50Tm9kZSB8fCAvLyBET00gRWxlbWVudCBkZXRlY3RlZFxuICAgIC8vICRGbG93Rml4TWU6IG5lZWQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzLi4uXG4gICAgZWxlbWVudC5ob3N0IHx8IC8vIFNoYWRvd1Jvb3QgZGV0ZWN0ZWRcbiAgICAvLyAkRmxvd0ZpeE1lOiBIVE1MRWxlbWVudCBpcyBhIE5vZGVcbiAgICBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkgLy8gZmFsbGJhY2tcblxuICApO1xufSIsImltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBpc1Njcm9sbFBhcmVudCBmcm9tIFwiLi9pc1Njcm9sbFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KG5vZGUpIHtcbiAgaWYgKFsnaHRtbCcsICdib2R5JywgJyNkb2N1bWVudCddLmluZGV4T2YoZ2V0Tm9kZU5hbWUobm9kZSkpID49IDApIHtcbiAgICAvLyAkRmxvd0ZpeE1lOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudC5ib2R5O1xuICB9XG5cbiAgaWYgKGlzSFRNTEVsZW1lbnQobm9kZSkgJiYgaXNTY3JvbGxQYXJlbnQobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHJldHVybiBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShub2RlKSk7XG59IiwiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFZpZXdwb3J0UmVjdChlbGVtZW50KSB7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIHZhciB2aXN1YWxWaWV3cG9ydCA9IHdpbi52aXN1YWxWaWV3cG9ydDtcbiAgdmFyIHdpZHRoID0gd2luLmlubmVyV2lkdGg7XG4gIHZhciBoZWlnaHQgPSB3aW4uaW5uZXJIZWlnaHQ7IC8vIFdlIGRvbid0IGtub3cgd2hpY2ggYnJvd3NlcnMgaGF2ZSBidWdneSBvciBvZGQgaW1wbGVtZW50YXRpb25zIG9mIHRoaXMsIHNvXG4gIC8vIGZvciBub3cgd2UncmUgb25seSBhcHBseWluZyBpdCB0byBpT1MgdG8gZml4IHRoZSBrZXlib2FyZCBpc3N1ZS5cbiAgLy8gSW52ZXN0aWdhdGlvbiByZXF1aXJlZFxuXG4gIGlmICh2aXN1YWxWaWV3cG9ydCAmJiAvaVBob25lfGlQb2R8aVBhZC8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pKSB7XG4gICAgd2lkdGggPSB2aXN1YWxWaWV3cG9ydC53aWR0aDtcbiAgICBoZWlnaHQgPSB2aXN1YWxWaWV3cG9ydC5oZWlnaHQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcbn0iLCIvKjo6IGltcG9ydCB0eXBlIHsgV2luZG93IH0gZnJvbSAnLi4vdHlwZXMnOyAqL1xuXG4vKjo6IGRlY2xhcmUgZnVuY3Rpb24gZ2V0V2luZG93KG5vZGU6IE5vZGUgfCBXaW5kb3cpOiBXaW5kb3c7ICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3cobm9kZSkge1xuICBpZiAobm9kZS50b1N0cmluZygpICE9PSAnW29iamVjdCBXaW5kb3ddJykge1xuICAgIHZhciBvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50O1xuICAgIHJldHVybiBvd25lckRvY3VtZW50ID8gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyA6IHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufSIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGwobm9kZSkge1xuICB2YXIgd2luID0gZ2V0V2luZG93KG5vZGUpO1xuICB2YXIgc2Nyb2xsTGVmdCA9IHdpbi5wYWdlWE9mZnNldDtcbiAgdmFyIHNjcm9sbFRvcCA9IHdpbi5wYWdlWU9mZnNldDtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBzY3JvbGxMZWZ0LFxuICAgIHNjcm9sbFRvcDogc2Nyb2xsVG9wXG4gIH07XG59IiwiaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KSB7XG4gIC8vIElmIDxodG1sPiBoYXMgYSBDU1Mgd2lkdGggZ3JlYXRlciB0aGFuIHRoZSB2aWV3cG9ydCwgdGhlbiB0aGlzIHdpbGwgYmVcbiAgLy8gaW5jb3JyZWN0IGZvciBSVEwuXG4gIC8vIFBvcHBlciAxIGlzIGJyb2tlbiBpbiB0aGlzIGNhc2UgYW5kIG5ldmVyIGhhZCBhIGJ1ZyByZXBvcnQgc28gbGV0J3MgYXNzdW1lXG4gIC8vIGl0J3Mgbm90IGFuIGlzc3VlLiBJIGRvbid0IHRoaW5rIGFueW9uZSBldmVyIHNwZWNpZmllcyB3aWR0aCBvbiA8aHRtbD5cbiAgLy8gYW55d2F5LlxuICAvLyBCcm93c2VycyB3aGVyZSB0aGUgbGVmdCBzY3JvbGxiYXIgZG9lc24ndCBjYXVzZSBhbiBpc3N1ZSByZXBvcnQgYDBgIGZvclxuICAvLyB0aGlzIChlLmcuIEVkZ2UgMjAxOSwgSUUxMSwgU2FmYXJpKVxuICByZXR1cm4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkubGVmdCArIGdldFdpbmRvd1Njcm9sbChlbGVtZW50KS5zY3JvbGxMZWZ0O1xufSIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG4vKjo6IGRlY2xhcmUgZnVuY3Rpb24gaXNFbGVtZW50KG5vZGU6IG1peGVkKTogYm9vbGVhbiAlY2hlY2tzKG5vZGUgaW5zdGFuY2VvZlxuICBFbGVtZW50KTsgKi9cblxuZnVuY3Rpb24gaXNFbGVtZW50KG5vZGUpIHtcbiAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuRWxlbWVudDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50O1xufVxuLyo6OiBkZWNsYXJlIGZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQobm9kZTogbWl4ZWQpOiBib29sZWFuICVjaGVja3Mobm9kZSBpbnN0YW5jZW9mXG4gIEhUTUxFbGVtZW50KTsgKi9cblxuXG5mdW5jdGlvbiBpc0hUTUxFbGVtZW50KG5vZGUpIHtcbiAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuSFRNTEVsZW1lbnQ7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG59XG5cbmV4cG9ydCB7IGlzRWxlbWVudCwgaXNIVE1MRWxlbWVudCB9OyIsImltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzU2Nyb2xsUGFyZW50KGVsZW1lbnQpIHtcbiAgLy8gRmlyZWZveCB3YW50cyB1cyB0byBjaGVjayBgLXhgIGFuZCBgLXlgIHZhcmlhdGlvbnMgYXMgd2VsbFxuICB2YXIgX2dldENvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLFxuICAgICAgb3ZlcmZsb3cgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5vdmVyZmxvdyxcbiAgICAgIG92ZXJmbG93WCA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93WCxcbiAgICAgIG92ZXJmbG93WSA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93WTtcblxuICByZXR1cm4gL2F1dG98c2Nyb2xsfG92ZXJsYXl8aGlkZGVuLy50ZXN0KG92ZXJmbG93ICsgb3ZlcmZsb3dZICsgb3ZlcmZsb3dYKTtcbn0iLCJpbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzVGFibGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIFsndGFibGUnLCAndGQnLCAndGgnXS5pbmRleE9mKGdldE5vZGVOYW1lKGVsZW1lbnQpKSA+PSAwO1xufSIsImltcG9ydCBnZXRTY3JvbGxQYXJlbnQgZnJvbSBcIi4vZ2V0U2Nyb2xsUGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tIFwiLi9nZXRQYXJlbnROb2RlLmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgaXNTY3JvbGxQYXJlbnQgZnJvbSBcIi4vaXNTY3JvbGxQYXJlbnQuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxpc3RTY3JvbGxQYXJlbnRzKGVsZW1lbnQsIGxpc3QpIHtcbiAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgIGxpc3QgPSBbXTtcbiAgfVxuXG4gIHZhciBzY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQoZWxlbWVudCk7XG4gIHZhciBpc0JvZHkgPSBnZXROb2RlTmFtZShzY3JvbGxQYXJlbnQpID09PSAnYm9keSc7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3coc2Nyb2xsUGFyZW50KTtcbiAgdmFyIHRhcmdldCA9IGlzQm9keSA/IFt3aW5dLmNvbmNhdCh3aW4udmlzdWFsVmlld3BvcnQgfHwgW10sIGlzU2Nyb2xsUGFyZW50KHNjcm9sbFBhcmVudCkgPyBzY3JvbGxQYXJlbnQgOiBbXSkgOiBzY3JvbGxQYXJlbnQ7XG4gIHZhciB1cGRhdGVkTGlzdCA9IGxpc3QuY29uY2F0KHRhcmdldCk7XG4gIHJldHVybiBpc0JvZHkgPyB1cGRhdGVkTGlzdCA6IC8vICRGbG93Rml4TWU6IGlzQm9keSB0ZWxscyB1cyB0YXJnZXQgd2lsbCBiZSBhbiBIVE1MRWxlbWVudCBoZXJlXG4gIHVwZGF0ZWRMaXN0LmNvbmNhdChsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKHRhcmdldCkpKTtcbn0iLCJleHBvcnQgdmFyIHRvcCA9ICd0b3AnO1xuZXhwb3J0IHZhciBib3R0b20gPSAnYm90dG9tJztcbmV4cG9ydCB2YXIgcmlnaHQgPSAncmlnaHQnO1xuZXhwb3J0IHZhciBsZWZ0ID0gJ2xlZnQnO1xuZXhwb3J0IHZhciBhdXRvID0gJ2F1dG8nO1xuZXhwb3J0IHZhciBiYXNlUGxhY2VtZW50cyA9IFt0b3AsIGJvdHRvbSwgcmlnaHQsIGxlZnRdO1xuZXhwb3J0IHZhciBzdGFydCA9ICdzdGFydCc7XG5leHBvcnQgdmFyIGVuZCA9ICdlbmQnO1xuZXhwb3J0IHZhciBjbGlwcGluZ1BhcmVudHMgPSAnY2xpcHBpbmdQYXJlbnRzJztcbmV4cG9ydCB2YXIgdmlld3BvcnQgPSAndmlld3BvcnQnO1xuZXhwb3J0IHZhciBwb3BwZXIgPSAncG9wcGVyJztcbmV4cG9ydCB2YXIgcmVmZXJlbmNlID0gJ3JlZmVyZW5jZSc7XG5leHBvcnQgdmFyIHZhcmlhdGlvblBsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovYmFzZVBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICByZXR1cm4gYWNjLmNvbmNhdChbcGxhY2VtZW50ICsgXCItXCIgKyBzdGFydCwgcGxhY2VtZW50ICsgXCItXCIgKyBlbmRdKTtcbn0sIFtdKTtcbmV4cG9ydCB2YXIgcGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9bXS5jb25jYXQoYmFzZVBsYWNlbWVudHMsIFthdXRvXSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICByZXR1cm4gYWNjLmNvbmNhdChbcGxhY2VtZW50LCBwbGFjZW1lbnQgKyBcIi1cIiArIHN0YXJ0LCBwbGFjZW1lbnQgKyBcIi1cIiArIGVuZF0pO1xufSwgW10pOyAvLyBtb2RpZmllcnMgdGhhdCBuZWVkIHRvIHJlYWQgdGhlIERPTVxuXG5leHBvcnQgdmFyIGJlZm9yZVJlYWQgPSAnYmVmb3JlUmVhZCc7XG5leHBvcnQgdmFyIHJlYWQgPSAncmVhZCc7XG5leHBvcnQgdmFyIGFmdGVyUmVhZCA9ICdhZnRlclJlYWQnOyAvLyBwdXJlLWxvZ2ljIG1vZGlmaWVyc1xuXG5leHBvcnQgdmFyIGJlZm9yZU1haW4gPSAnYmVmb3JlTWFpbic7XG5leHBvcnQgdmFyIG1haW4gPSAnbWFpbic7XG5leHBvcnQgdmFyIGFmdGVyTWFpbiA9ICdhZnRlck1haW4nOyAvLyBtb2RpZmllciB3aXRoIHRoZSBwdXJwb3NlIHRvIHdyaXRlIHRvIHRoZSBET00gKG9yIHdyaXRlIGludG8gYSBmcmFtZXdvcmsgc3RhdGUpXG5cbmV4cG9ydCB2YXIgYmVmb3JlV3JpdGUgPSAnYmVmb3JlV3JpdGUnO1xuZXhwb3J0IHZhciB3cml0ZSA9ICd3cml0ZSc7XG5leHBvcnQgdmFyIGFmdGVyV3JpdGUgPSAnYWZ0ZXJXcml0ZSc7XG5leHBvcnQgdmFyIG1vZGlmaWVyUGhhc2VzID0gW2JlZm9yZVJlYWQsIHJlYWQsIGFmdGVyUmVhZCwgYmVmb3JlTWFpbiwgbWFpbiwgYWZ0ZXJNYWluLCBiZWZvcmVXcml0ZSwgd3JpdGUsIGFmdGVyV3JpdGVdOyIsImltcG9ydCBnZXRDb21wb3NpdGVSZWN0IGZyb20gXCIuL2RvbS11dGlscy9nZXRDb21wb3NpdGVSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0TGF5b3V0UmVjdCBmcm9tIFwiLi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qc1wiO1xuaW1wb3J0IGxpc3RTY3JvbGxQYXJlbnRzIGZyb20gXCIuL2RvbS11dGlscy9saXN0U2Nyb2xsUGFyZW50cy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9kb20tdXRpbHMvZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IG9yZGVyTW9kaWZpZXJzIGZyb20gXCIuL3V0aWxzL29yZGVyTW9kaWZpZXJzLmpzXCI7XG5pbXBvcnQgZGVib3VuY2UgZnJvbSBcIi4vdXRpbHMvZGVib3VuY2UuanNcIjtcbmltcG9ydCB2YWxpZGF0ZU1vZGlmaWVycyBmcm9tIFwiLi91dGlscy92YWxpZGF0ZU1vZGlmaWVycy5qc1wiO1xuaW1wb3J0IHVuaXF1ZUJ5IGZyb20gXCIuL3V0aWxzL3VuaXF1ZUJ5LmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgbWVyZ2VCeU5hbWUgZnJvbSBcIi4vdXRpbHMvbWVyZ2VCeU5hbWUuanNcIjtcbmltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gXCIuL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgeyBhdXRvIH0gZnJvbSBcIi4vZW51bXMuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2VudW1zLmpzXCI7XG52YXIgSU5WQUxJRF9FTEVNRU5UX0VSUk9SID0gJ1BvcHBlcjogSW52YWxpZCByZWZlcmVuY2Ugb3IgcG9wcGVyIGFyZ3VtZW50IHByb3ZpZGVkLiBUaGV5IG11c3QgYmUgZWl0aGVyIGEgRE9NIGVsZW1lbnQgb3IgdmlydHVhbCBlbGVtZW50Lic7XG52YXIgSU5GSU5JVEVfTE9PUF9FUlJPUiA9ICdQb3BwZXI6IEFuIGluZmluaXRlIGxvb3AgaW4gdGhlIG1vZGlmaWVycyBjeWNsZSBoYXMgYmVlbiBkZXRlY3RlZCEgVGhlIGN5Y2xlIGhhcyBiZWVuIGludGVycnVwdGVkIHRvIHByZXZlbnQgYSBicm93c2VyIGNyYXNoLic7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICBtb2RpZmllcnM6IFtdLFxuICBzdHJhdGVneTogJ2Fic29sdXRlJ1xufTtcblxuZnVuY3Rpb24gYXJlVmFsaWRFbGVtZW50cygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiAhYXJncy5zb21lKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgcmV0dXJuICEoZWxlbWVudCAmJiB0eXBlb2YgZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPT09ICdmdW5jdGlvbicpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvcHBlckdlbmVyYXRvcihnZW5lcmF0b3JPcHRpb25zKSB7XG4gIGlmIChnZW5lcmF0b3JPcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBnZW5lcmF0b3JPcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX2dlbmVyYXRvck9wdGlvbnMgPSBnZW5lcmF0b3JPcHRpb25zLFxuICAgICAgX2dlbmVyYXRvck9wdGlvbnMkZGVmID0gX2dlbmVyYXRvck9wdGlvbnMuZGVmYXVsdE1vZGlmaWVycyxcbiAgICAgIGRlZmF1bHRNb2RpZmllcnMgPSBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYgPT09IHZvaWQgMCA/IFtdIDogX2dlbmVyYXRvck9wdGlvbnMkZGVmLFxuICAgICAgX2dlbmVyYXRvck9wdGlvbnMkZGVmMiA9IF9nZW5lcmF0b3JPcHRpb25zLmRlZmF1bHRPcHRpb25zLFxuICAgICAgZGVmYXVsdE9wdGlvbnMgPSBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyID09PSB2b2lkIDAgPyBERUZBVUxUX09QVElPTlMgOiBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyO1xuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlUG9wcGVyKHJlZmVyZW5jZSwgcG9wcGVyLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuICAgIH1cblxuICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gICAgICBvcmRlcmVkTW9kaWZpZXJzOiBbXSxcbiAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywge30sIGRlZmF1bHRPcHRpb25zKSxcbiAgICAgIG1vZGlmaWVyc0RhdGE6IHt9LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgcmVmZXJlbmNlOiByZWZlcmVuY2UsXG4gICAgICAgIHBvcHBlcjogcG9wcGVyXG4gICAgICB9LFxuICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfTtcbiAgICB2YXIgZWZmZWN0Q2xlYW51cEZucyA9IFtdO1xuICAgIHZhciBpc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHZhciBpbnN0YW5jZSA9IHtcbiAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgIHNldE9wdGlvbnM6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIHN0YXRlLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywge30sIHN0YXRlLm9wdGlvbnMsIHt9LCBvcHRpb25zKTtcbiAgICAgICAgc3RhdGUuc2Nyb2xsUGFyZW50cyA9IHtcbiAgICAgICAgICByZWZlcmVuY2U6IGlzRWxlbWVudChyZWZlcmVuY2UpID8gbGlzdFNjcm9sbFBhcmVudHMocmVmZXJlbmNlKSA6IHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudCA/IGxpc3RTY3JvbGxQYXJlbnRzKHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudCkgOiBbXSxcbiAgICAgICAgICBwb3BwZXI6IGxpc3RTY3JvbGxQYXJlbnRzKHBvcHBlcilcbiAgICAgICAgfTsgLy8gT3JkZXJzIHRoZSBtb2RpZmllcnMgYmFzZWQgb24gdGhlaXIgZGVwZW5kZW5jaWVzIGFuZCBgcGhhc2VgXG4gICAgICAgIC8vIHByb3BlcnRpZXNcblxuICAgICAgICB2YXIgb3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyTW9kaWZpZXJzKG1lcmdlQnlOYW1lKFtdLmNvbmNhdChkZWZhdWx0TW9kaWZpZXJzLCBzdGF0ZS5vcHRpb25zLm1vZGlmaWVycykpKTsgLy8gU3RyaXAgb3V0IGRpc2FibGVkIG1vZGlmaWVyc1xuXG4gICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMgPSBvcmRlcmVkTW9kaWZpZXJzLmZpbHRlcihmdW5jdGlvbiAobSkge1xuICAgICAgICAgIHJldHVybiBtLmVuYWJsZWQ7XG4gICAgICAgIH0pOyAvLyBWYWxpZGF0ZSB0aGUgcHJvdmlkZWQgbW9kaWZpZXJzIHNvIHRoYXQgdGhlIGNvbnN1bWVyIHdpbGwgZ2V0IHdhcm5lZFxuICAgICAgICAvLyBpZiBvbmUgb2YgdGhlIG1vZGlmaWVycyBpcyBpbnZhbGlkIGZvciBhbnkgcmVhc29uXG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgIHZhciBtb2RpZmllcnMgPSB1bmlxdWVCeShbXS5jb25jYXQob3JkZXJlZE1vZGlmaWVycywgc3RhdGUub3B0aW9ucy5tb2RpZmllcnMpLCBmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBfcmVmLm5hbWU7XG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YWxpZGF0ZU1vZGlmaWVycyhtb2RpZmllcnMpO1xuXG4gICAgICAgICAgaWYgKGdldEJhc2VQbGFjZW1lbnQoc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQpID09PSBhdXRvKSB7XG4gICAgICAgICAgICB2YXIgZmxpcE1vZGlmaWVyID0gc3RhdGUub3JkZXJlZE1vZGlmaWVycy5maW5kKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICAgICAgICB2YXIgbmFtZSA9IF9yZWYyLm5hbWU7XG4gICAgICAgICAgICAgIHJldHVybiBuYW1lID09PSAnZmxpcCc7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFmbGlwTW9kaWZpZXIpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogXCJhdXRvXCIgcGxhY2VtZW50cyByZXF1aXJlIHRoZSBcImZsaXBcIiBtb2RpZmllciBiZScsICdwcmVzZW50IGFuZCBlbmFibGVkIHRvIHdvcmsuJ10uam9pbignICcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX2dldENvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHBvcHBlciksXG4gICAgICAgICAgICAgIG1hcmdpblRvcCA9IF9nZXRDb21wdXRlZFN0eWxlLm1hcmdpblRvcCxcbiAgICAgICAgICAgICAgbWFyZ2luUmlnaHQgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5tYXJnaW5SaWdodCxcbiAgICAgICAgICAgICAgbWFyZ2luQm90dG9tID0gX2dldENvbXB1dGVkU3R5bGUubWFyZ2luQm90dG9tLFxuICAgICAgICAgICAgICBtYXJnaW5MZWZ0ID0gX2dldENvbXB1dGVkU3R5bGUubWFyZ2luTGVmdDsgLy8gV2Ugbm8gbG9uZ2VyIHRha2UgaW50byBhY2NvdW50IGBtYXJnaW5zYCBvbiB0aGUgcG9wcGVyLCBhbmQgaXQgY2FuXG4gICAgICAgICAgLy8gY2F1c2UgYnVncyB3aXRoIHBvc2l0aW9uaW5nLCBzbyB3ZSdsbCB3YXJuIHRoZSBjb25zdW1lclxuXG5cbiAgICAgICAgICBpZiAoW21hcmdpblRvcCwgbWFyZ2luUmlnaHQsIG1hcmdpbkJvdHRvbSwgbWFyZ2luTGVmdF0uc29tZShmdW5jdGlvbiAobWFyZ2luKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChtYXJnaW4pO1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oWydQb3BwZXI6IENTUyBcIm1hcmdpblwiIHN0eWxlcyBjYW5ub3QgYmUgdXNlZCB0byBhcHBseSBwYWRkaW5nJywgJ2JldHdlZW4gdGhlIHBvcHBlciBhbmQgaXRzIHJlZmVyZW5jZSBlbGVtZW50IG9yIGJvdW5kYXJ5LicsICdUbyByZXBsaWNhdGUgbWFyZ2luLCB1c2UgdGhlIGBvZmZzZXRgIG1vZGlmaWVyLCBhcyB3ZWxsIGFzJywgJ3RoZSBgcGFkZGluZ2Agb3B0aW9uIGluIHRoZSBgcHJldmVudE92ZXJmbG93YCBhbmQgYGZsaXBgJywgJ21vZGlmaWVycy4nXS5qb2luKCcgJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJ1bk1vZGlmaWVyRWZmZWN0cygpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICB9LFxuICAgICAgLy8gU3luYyB1cGRhdGUg4oCTIGl0IHdpbGwgYWx3YXlzIGJlIGV4ZWN1dGVkLCBldmVuIGlmIG5vdCBuZWNlc3NhcnkuIFRoaXNcbiAgICAgIC8vIGlzIHVzZWZ1bCBmb3IgbG93IGZyZXF1ZW5jeSB1cGRhdGVzIHdoZXJlIHN5bmMgYmVoYXZpb3Igc2ltcGxpZmllcyB0aGVcbiAgICAgIC8vIGxvZ2ljLlxuICAgICAgLy8gRm9yIGhpZ2ggZnJlcXVlbmN5IHVwZGF0ZXMgKGUuZy4gYHJlc2l6ZWAgYW5kIGBzY3JvbGxgIGV2ZW50cyksIGFsd2F5c1xuICAgICAgLy8gcHJlZmVyIHRoZSBhc3luYyBQb3BwZXIjdXBkYXRlIG1ldGhvZFxuICAgICAgZm9yY2VVcGRhdGU6IGZ1bmN0aW9uIGZvcmNlVXBkYXRlKCkge1xuICAgICAgICBpZiAoaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX3N0YXRlJGVsZW1lbnRzID0gc3RhdGUuZWxlbWVudHMsXG4gICAgICAgICAgICByZWZlcmVuY2UgPSBfc3RhdGUkZWxlbWVudHMucmVmZXJlbmNlLFxuICAgICAgICAgICAgcG9wcGVyID0gX3N0YXRlJGVsZW1lbnRzLnBvcHBlcjsgLy8gRG9uJ3QgcHJvY2VlZCBpZiBgcmVmZXJlbmNlYCBvciBgcG9wcGVyYCBhcmUgbm90IHZhbGlkIGVsZW1lbnRzXG4gICAgICAgIC8vIGFueW1vcmVcblxuICAgICAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihJTlZBTElEX0VMRU1FTlRfRVJST1IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBTdG9yZSB0aGUgcmVmZXJlbmNlIGFuZCBwb3BwZXIgcmVjdHMgdG8gYmUgcmVhZCBieSBtb2RpZmllcnNcblxuXG4gICAgICAgIHN0YXRlLnJlY3RzID0ge1xuICAgICAgICAgIHJlZmVyZW5jZTogZ2V0Q29tcG9zaXRlUmVjdChyZWZlcmVuY2UsIGdldE9mZnNldFBhcmVudChwb3BwZXIpLCBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5ID09PSAnZml4ZWQnKSxcbiAgICAgICAgICBwb3BwZXI6IGdldExheW91dFJlY3QocG9wcGVyKVxuICAgICAgICB9OyAvLyBNb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byByZXNldCB0aGUgY3VycmVudCB1cGRhdGUgY3ljbGUuIFRoZVxuICAgICAgICAvLyBtb3N0IGNvbW1vbiB1c2UgY2FzZSBmb3IgdGhpcyBpcyB0aGUgYGZsaXBgIG1vZGlmaWVyIGNoYW5naW5nIHRoZVxuICAgICAgICAvLyBwbGFjZW1lbnQsIHdoaWNoIHRoZW4gbmVlZHMgdG8gcmUtcnVuIGFsbCB0aGUgbW9kaWZpZXJzLCBiZWNhdXNlIHRoZVxuICAgICAgICAvLyBsb2dpYyB3YXMgcHJldmlvdXNseSByYW4gZm9yIHRoZSBwcmV2aW91cyBwbGFjZW1lbnQgYW5kIGlzIHRoZXJlZm9yZVxuICAgICAgICAvLyBzdGFsZS9pbmNvcnJlY3RcblxuICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5wbGFjZW1lbnQgPSBzdGF0ZS5vcHRpb25zLnBsYWNlbWVudDsgLy8gT24gZWFjaCB1cGRhdGUgY3ljbGUsIHRoZSBgbW9kaWZpZXJzRGF0YWAgcHJvcGVydHkgZm9yIGVhY2ggbW9kaWZpZXJcbiAgICAgICAgLy8gaXMgZmlsbGVkIHdpdGggdGhlIGluaXRpYWwgZGF0YSBzcGVjaWZpZWQgYnkgdGhlIG1vZGlmaWVyLiBUaGlzIG1lYW5zXG4gICAgICAgIC8vIGl0IGRvZXNuJ3QgcGVyc2lzdCBhbmQgaXMgZnJlc2ggb24gZWFjaCB1cGRhdGUuXG4gICAgICAgIC8vIFRvIGVuc3VyZSBwZXJzaXN0ZW50IGRhdGEsIHVzZSBgJHtuYW1lfSNwZXJzaXN0ZW50YFxuXG4gICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGUubW9kaWZpZXJzRGF0YVttb2RpZmllci5uYW1lXSA9IE9iamVjdC5hc3NpZ24oe30sIG1vZGlmaWVyLmRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIF9fZGVidWdfbG9vcHNfXyA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHN0YXRlLm9yZGVyZWRNb2RpZmllcnMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgX19kZWJ1Z19sb29wc19fICs9IDE7XG5cbiAgICAgICAgICAgIGlmIChfX2RlYnVnX2xvb3BzX18gPiAxMDApIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihJTkZJTklURV9MT09QX0VSUk9SKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN0YXRlLnJlc2V0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xuICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfc3RhdGUkb3JkZXJlZE1vZGlmaWUgPSBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzW2luZGV4XSxcbiAgICAgICAgICAgICAgZm4gPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUuZm4sXG4gICAgICAgICAgICAgIF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUub3B0aW9ucyxcbiAgICAgICAgICAgICAgX29wdGlvbnMgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyID09PSB2b2lkIDAgPyB7fSA6IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIsXG4gICAgICAgICAgICAgIG5hbWUgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUubmFtZTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHN0YXRlID0gZm4oe1xuICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICAgIG9wdGlvbnM6IF9vcHRpb25zLFxuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2VcbiAgICAgICAgICAgIH0pIHx8IHN0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIEFzeW5jIGFuZCBvcHRpbWlzdGljYWxseSBvcHRpbWl6ZWQgdXBkYXRlIOKAkyBpdCB3aWxsIG5vdCBiZSBleGVjdXRlZCBpZlxuICAgICAgLy8gbm90IG5lY2Vzc2FyeSAoZGVib3VuY2VkIHRvIHJ1biBhdCBtb3N0IG9uY2UtcGVyLXRpY2spXG4gICAgICB1cGRhdGU6IGRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICByZXNvbHZlKHN0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgaXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoSU5WQUxJRF9FTEVNRU5UX0VSUk9SKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cblxuICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucykudGhlbihmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIGlmICghaXNEZXN0cm95ZWQgJiYgb3B0aW9ucy5vbkZpcnN0VXBkYXRlKSB7XG4gICAgICAgIG9wdGlvbnMub25GaXJzdFVwZGF0ZShzdGF0ZSk7XG4gICAgICB9XG4gICAgfSk7IC8vIE1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIGV4ZWN1dGUgYXJiaXRyYXJ5IGNvZGUgYmVmb3JlIHRoZSBmaXJzdFxuICAgIC8vIHVwZGF0ZSBjeWNsZSBydW5zLiBUaGV5IHdpbGwgYmUgZXhlY3V0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlIHVwZGF0ZVxuICAgIC8vIGN5Y2xlLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGEgbW9kaWZpZXIgYWRkcyBzb21lIHBlcnNpc3RlbnQgZGF0YSB0aGF0XG4gICAgLy8gb3RoZXIgbW9kaWZpZXJzIG5lZWQgdG8gdXNlLCBidXQgdGhlIG1vZGlmaWVyIGlzIHJ1biBhZnRlciB0aGUgZGVwZW5kZW50XG4gICAgLy8gb25lLlxuXG4gICAgZnVuY3Rpb24gcnVuTW9kaWZpZXJFZmZlY3RzKCkge1xuICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmMykge1xuICAgICAgICB2YXIgbmFtZSA9IF9yZWYzLm5hbWUsXG4gICAgICAgICAgICBfcmVmMyRvcHRpb25zID0gX3JlZjMub3B0aW9ucyxcbiAgICAgICAgICAgIG9wdGlvbnMgPSBfcmVmMyRvcHRpb25zID09PSB2b2lkIDAgPyB7fSA6IF9yZWYzJG9wdGlvbnMsXG4gICAgICAgICAgICBlZmZlY3QgPSBfcmVmMy5lZmZlY3Q7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlZmZlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgY2xlYW51cEZuID0gZWZmZWN0KHtcbiAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgbm9vcEZuID0gZnVuY3Rpb24gbm9vcEZuKCkge307XG5cbiAgICAgICAgICBlZmZlY3RDbGVhbnVwRm5zLnB1c2goY2xlYW51cEZuIHx8IG5vb3BGbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKSB7XG4gICAgICBlZmZlY3RDbGVhbnVwRm5zLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgICAgfSk7XG4gICAgICBlZmZlY3RDbGVhbnVwRm5zID0gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xufVxuZXhwb3J0IHZhciBjcmVhdGVQb3BwZXIgPSAvKiNfX1BVUkVfXyovcG9wcGVyR2VuZXJhdG9yKCk7IiwiaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi4vZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcIjsgLy8gVGhpcyBtb2RpZmllciB0YWtlcyB0aGUgc3R5bGVzIHByZXBhcmVkIGJ5IHRoZSBgY29tcHV0ZVN0eWxlc2AgbW9kaWZpZXJcbi8vIGFuZCBhcHBsaWVzIHRoZW0gdG8gdGhlIEhUTUxFbGVtZW50cyBzdWNoIGFzIHBvcHBlciBhbmQgYXJyb3dcblxuZnVuY3Rpb24gYXBwbHlTdHlsZXMoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlO1xuICBPYmplY3Qua2V5cyhzdGF0ZS5lbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBzdHlsZSA9IHN0YXRlLnN0eWxlc1tuYW1lXSB8fCB7fTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XG4gICAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1tuYW1lXTsgLy8gYXJyb3cgaXMgb3B0aW9uYWwgKyB2aXJ0dWFsIGVsZW1lbnRzXG5cbiAgICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgIWdldE5vZGVOYW1lKGVsZW1lbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBGbG93IGRvZXNuJ3Qgc3VwcG9ydCB0byBleHRlbmQgdGhpcyBwcm9wZXJ0eSwgYnV0IGl0J3MgdGhlIG1vc3RcbiAgICAvLyBlZmZlY3RpdmUgd2F5IHRvIGFwcGx5IHN0eWxlcyB0byBhbiBIVE1MRWxlbWVudFxuICAgIC8vICRGbG93Rml4TWVcblxuXG4gICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdHlsZSk7XG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlc1tuYW1lXTtcblxuICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlID09PSB0cnVlID8gJycgOiB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGU7XG4gIHZhciBpbml0aWFsU3R5bGVzID0ge1xuICAgIHBvcHBlcjoge1xuICAgICAgcG9zaXRpb246IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBsZWZ0OiAnMCcsXG4gICAgICB0b3A6ICcwJyxcbiAgICAgIG1hcmdpbjogJzAnXG4gICAgfSxcbiAgICBhcnJvdzoge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgICB9LFxuICAgIHJlZmVyZW5jZToge31cbiAgfTtcbiAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5wb3BwZXIuc3R5bGUsIGluaXRpYWxTdHlsZXMucG9wcGVyKTtcblxuICBpZiAoc3RhdGUuZWxlbWVudHMuYXJyb3cpIHtcbiAgICBPYmplY3QuYXNzaWduKHN0YXRlLmVsZW1lbnRzLmFycm93LnN0eWxlLCBpbml0aWFsU3R5bGVzLmFycm93KTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgT2JqZWN0LmtleXMoc3RhdGUuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbbmFtZV07XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XG4gICAgICB2YXIgc3R5bGVQcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMoc3RhdGUuc3R5bGVzLmhhc093blByb3BlcnR5KG5hbWUpID8gc3RhdGUuc3R5bGVzW25hbWVdIDogaW5pdGlhbFN0eWxlc1tuYW1lXSk7IC8vIFNldCBhbGwgdmFsdWVzIHRvIGFuIGVtcHR5IHN0cmluZyB0byB1bnNldCB0aGVtXG5cbiAgICAgIHZhciBzdHlsZSA9IHN0eWxlUHJvcGVydGllcy5yZWR1Y2UoZnVuY3Rpb24gKHN0eWxlLCBwcm9wZXJ0eSkge1xuICAgICAgICBzdHlsZVtwcm9wZXJ0eV0gPSAnJztcbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgfSwge30pOyAvLyBhcnJvdyBpcyBvcHRpb25hbCArIHZpcnR1YWwgZWxlbWVudHNcblxuICAgICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8ICFnZXROb2RlTmFtZShlbGVtZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIEZsb3cgZG9lc24ndCBzdXBwb3J0IHRvIGV4dGVuZCB0aGlzIHByb3BlcnR5LCBidXQgaXQncyB0aGUgbW9zdFxuICAgICAgLy8gZWZmZWN0aXZlIHdheSB0byBhcHBseSBzdHlsZXMgdG8gYW4gSFRNTEVsZW1lbnRcbiAgICAgIC8vICRGbG93Rml4TWVcblxuXG4gICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcbiAgICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdhcHBseVN0eWxlcycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnd3JpdGUnLFxuICBmbjogYXBwbHlTdHlsZXMsXG4gIGVmZmVjdDogZWZmZWN0LFxuICByZXF1aXJlczogWydjb21wdXRlU3R5bGVzJ11cbn07IiwiaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qc1wiO1xuaW1wb3J0IGNvbnRhaW5zIGZyb20gXCIuLi9kb20tdXRpbHMvY29udGFpbnMuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHdpdGhpbiBmcm9tIFwiLi4vdXRpbHMvd2l0aGluLmpzXCI7XG5pbXBvcnQgbWVyZ2VQYWRkaW5nT2JqZWN0IGZyb20gXCIuLi91dGlscy9tZXJnZVBhZGRpbmdPYmplY3QuanNcIjtcbmltcG9ydCBleHBhbmRUb0hhc2hNYXAgZnJvbSBcIi4uL3V0aWxzL2V4cGFuZFRvSGFzaE1hcC5qc1wiO1xuaW1wb3J0IHsgbGVmdCwgcmlnaHQsIGJhc2VQbGFjZW1lbnRzLCB0b3AsIGJvdHRvbSB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmZ1bmN0aW9uIGFycm93KF9yZWYpIHtcbiAgdmFyIF9zdGF0ZSRtb2RpZmllcnNEYXRhJDtcblxuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgdmFyIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93O1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cztcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCk7XG4gIHZhciBheGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpO1xuICB2YXIgaXNWZXJ0aWNhbCA9IFtsZWZ0LCByaWdodF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwO1xuICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICBpZiAoIWFycm93RWxlbWVudCB8fCAhcG9wcGVyT2Zmc2V0cykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwYWRkaW5nT2JqZWN0ID0gc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lICsgXCIjcGVyc2lzdGVudFwiXS5wYWRkaW5nO1xuICB2YXIgYXJyb3dSZWN0ID0gZ2V0TGF5b3V0UmVjdChhcnJvd0VsZW1lbnQpO1xuICB2YXIgbWluUHJvcCA9IGF4aXMgPT09ICd5JyA/IHRvcCA6IGxlZnQ7XG4gIHZhciBtYXhQcm9wID0gYXhpcyA9PT0gJ3knID8gYm90dG9tIDogcmlnaHQ7XG4gIHZhciBlbmREaWZmID0gc3RhdGUucmVjdHMucmVmZXJlbmNlW2xlbl0gKyBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbYXhpc10gLSBwb3BwZXJPZmZzZXRzW2F4aXNdIC0gc3RhdGUucmVjdHMucG9wcGVyW2xlbl07XG4gIHZhciBzdGFydERpZmYgPSBwb3BwZXJPZmZzZXRzW2F4aXNdIC0gc3RhdGUucmVjdHMucmVmZXJlbmNlW2F4aXNdO1xuICB2YXIgYXJyb3dPZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQoYXJyb3dFbGVtZW50KTtcbiAgdmFyIGNsaWVudFNpemUgPSBhcnJvd09mZnNldFBhcmVudCA/IGF4aXMgPT09ICd5JyA/IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudEhlaWdodCB8fCAwIDogYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50V2lkdGggfHwgMCA6IDA7XG4gIHZhciBjZW50ZXJUb1JlZmVyZW5jZSA9IGVuZERpZmYgLyAyIC0gc3RhcnREaWZmIC8gMjsgLy8gTWFrZSBzdXJlIHRoZSBhcnJvdyBkb2Vzbid0IG92ZXJmbG93IHRoZSBwb3BwZXIgaWYgdGhlIGNlbnRlciBwb2ludCBpc1xuICAvLyBvdXRzaWRlIG9mIHRoZSBwb3BwZXIgYm91bmRzXG5cbiAgdmFyIG1pbiA9IHBhZGRpbmdPYmplY3RbbWluUHJvcF07XG4gIHZhciBtYXggPSBjbGllbnRTaXplIC0gYXJyb3dSZWN0W2xlbl0gLSBwYWRkaW5nT2JqZWN0W21heFByb3BdO1xuICB2YXIgY2VudGVyID0gY2xpZW50U2l6ZSAvIDIgLSBhcnJvd1JlY3RbbGVuXSAvIDIgKyBjZW50ZXJUb1JlZmVyZW5jZTtcbiAgdmFyIG9mZnNldCA9IHdpdGhpbihtaW4sIGNlbnRlciwgbWF4KTsgLy8gUHJldmVudHMgYnJlYWtpbmcgc3ludGF4IGhpZ2hsaWdodGluZy4uLlxuXG4gIHZhciBheGlzUHJvcCA9IGF4aXM7XG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSAoX3N0YXRlJG1vZGlmaWVyc0RhdGEkID0ge30sIF9zdGF0ZSRtb2RpZmllcnNEYXRhJFtheGlzUHJvcF0gPSBvZmZzZXQsIF9zdGF0ZSRtb2RpZmllcnNEYXRhJC5jZW50ZXJPZmZzZXQgPSBvZmZzZXQgLSBjZW50ZXIsIF9zdGF0ZSRtb2RpZmllcnNEYXRhJCk7XG59XG5cbmZ1bmN0aW9uIGVmZmVjdChfcmVmMikge1xuICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmMi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYyLm5hbWU7XG4gIHZhciBfb3B0aW9ucyRlbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50LFxuICAgICAgYXJyb3dFbGVtZW50ID0gX29wdGlvbnMkZWxlbWVudCA9PT0gdm9pZCAwID8gJ1tkYXRhLXBvcHBlci1hcnJvd10nIDogX29wdGlvbnMkZWxlbWVudCxcbiAgICAgIF9vcHRpb25zJHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmcsXG4gICAgICBwYWRkaW5nID0gX29wdGlvbnMkcGFkZGluZyA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJHBhZGRpbmc7XG5cbiAgaWYgKGFycm93RWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIENTUyBzZWxlY3RvclxuXG5cbiAgaWYgKHR5cGVvZiBhcnJvd0VsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMucG9wcGVyLnF1ZXJ5U2VsZWN0b3IoYXJyb3dFbGVtZW50KTtcblxuICAgIGlmICghYXJyb3dFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICghaXNIVE1MRWxlbWVudChhcnJvd0VsZW1lbnQpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFsnUG9wcGVyOiBcImFycm93XCIgZWxlbWVudCBtdXN0IGJlIGFuIEhUTUxFbGVtZW50IChub3QgYW4gU1ZHRWxlbWVudCkuJywgJ1RvIHVzZSBhbiBTVkcgYXJyb3csIHdyYXAgaXQgaW4gYW4gSFRNTEVsZW1lbnQgdGhhdCB3aWxsIGJlIHVzZWQgYXMnLCAndGhlIGFycm93LiddLmpvaW4oJyAnKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb250YWlucyhzdGF0ZS5lbGVtZW50cy5wb3BwZXIsIGFycm93RWxlbWVudCkpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFsnUG9wcGVyOiBcImFycm93XCIgbW9kaWZpZXJcXCdzIGBlbGVtZW50YCBtdXN0IGJlIGEgY2hpbGQgb2YgdGhlIHBvcHBlcicsICdlbGVtZW50LiddLmpvaW4oJyAnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3RhdGUuZWxlbWVudHMuYXJyb3cgPSBhcnJvd0VsZW1lbnQ7XG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZSArIFwiI3BlcnNpc3RlbnRcIl0gPSB7XG4gICAgcGFkZGluZzogbWVyZ2VQYWRkaW5nT2JqZWN0KHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IHBhZGRpbmcgOiBleHBhbmRUb0hhc2hNYXAocGFkZGluZywgYmFzZVBsYWNlbWVudHMpKVxuICB9O1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnYXJyb3cnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogYXJyb3csXG4gIGVmZmVjdDogZWZmZWN0LFxuICByZXF1aXJlczogWydwb3BwZXJPZmZzZXRzJ10sXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsncHJldmVudE92ZXJmbG93J11cbn07IiwiaW1wb3J0IHsgdG9wLCBsZWZ0LCByaWdodCwgYm90dG9tIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxudmFyIHVuc2V0U2lkZXMgPSB7XG4gIHRvcDogJ2F1dG8nLFxuICByaWdodDogJ2F1dG8nLFxuICBib3R0b206ICdhdXRvJyxcbiAgbGVmdDogJ2F1dG8nXG59OyAvLyBSb3VuZCB0aGUgb2Zmc2V0cyB0byB0aGUgbmVhcmVzdCBzdWl0YWJsZSBzdWJwaXhlbCBiYXNlZCBvbiB0aGUgRFBSLlxuLy8gWm9vbWluZyBjYW4gY2hhbmdlIHRoZSBEUFIsIGJ1dCBpdCBzZWVtcyB0byByZXBvcnQgYSB2YWx1ZSB0aGF0IHdpbGxcbi8vIGNsZWFubHkgZGl2aWRlIHRoZSB2YWx1ZXMgaW50byB0aGUgYXBwcm9wcmlhdGUgc3VicGl4ZWxzLlxuXG5mdW5jdGlvbiByb3VuZE9mZnNldHMoX3JlZikge1xuICB2YXIgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnk7XG4gIHZhciB3aW4gPSB3aW5kb3c7XG4gIHZhciBkcHIgPSB3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICByZXR1cm4ge1xuICAgIHg6IE1hdGgucm91bmQoeCAqIGRwcikgLyBkcHIgfHwgMCxcbiAgICB5OiBNYXRoLnJvdW5kKHkgKiBkcHIpIC8gZHByIHx8IDBcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hcFRvU3R5bGVzKF9yZWYyKSB7XG4gIHZhciBfT2JqZWN0JGFzc2lnbjI7XG5cbiAgdmFyIHBvcHBlciA9IF9yZWYyLnBvcHBlcixcbiAgICAgIHBvcHBlclJlY3QgPSBfcmVmMi5wb3BwZXJSZWN0LFxuICAgICAgcGxhY2VtZW50ID0gX3JlZjIucGxhY2VtZW50LFxuICAgICAgb2Zmc2V0cyA9IF9yZWYyLm9mZnNldHMsXG4gICAgICBwb3NpdGlvbiA9IF9yZWYyLnBvc2l0aW9uLFxuICAgICAgZ3B1QWNjZWxlcmF0aW9uID0gX3JlZjIuZ3B1QWNjZWxlcmF0aW9uLFxuICAgICAgYWRhcHRpdmUgPSBfcmVmMi5hZGFwdGl2ZTtcblxuICB2YXIgX3JvdW5kT2Zmc2V0cyA9IHJvdW5kT2Zmc2V0cyhvZmZzZXRzKSxcbiAgICAgIHggPSBfcm91bmRPZmZzZXRzLngsXG4gICAgICB5ID0gX3JvdW5kT2Zmc2V0cy55O1xuXG4gIHZhciBoYXNYID0gb2Zmc2V0cy5oYXNPd25Qcm9wZXJ0eSgneCcpO1xuICB2YXIgaGFzWSA9IG9mZnNldHMuaGFzT3duUHJvcGVydHkoJ3knKTtcbiAgdmFyIHNpZGVYID0gbGVmdDtcbiAgdmFyIHNpZGVZID0gdG9wO1xuICB2YXIgd2luID0gd2luZG93O1xuXG4gIGlmIChhZGFwdGl2ZSkge1xuICAgIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQocG9wcGVyKTtcblxuICAgIGlmIChvZmZzZXRQYXJlbnQgPT09IGdldFdpbmRvdyhwb3BwZXIpKSB7XG4gICAgICBvZmZzZXRQYXJlbnQgPSBnZXREb2N1bWVudEVsZW1lbnQocG9wcGVyKTtcbiAgICB9IC8vICRGbG93Rml4TWU6IGZvcmNlIHR5cGUgcmVmaW5lbWVudCwgd2UgY29tcGFyZSBvZmZzZXRQYXJlbnQgd2l0aCB3aW5kb3cgYWJvdmUsIGJ1dCBGbG93IGRvZXNuJ3QgZGV0ZWN0IGl0XG5cbiAgICAvKjo6IG9mZnNldFBhcmVudCA9IChvZmZzZXRQYXJlbnQ6IEVsZW1lbnQpOyAqL1xuXG5cbiAgICBpZiAocGxhY2VtZW50ID09PSB0b3ApIHtcbiAgICAgIHNpZGVZID0gYm90dG9tO1xuICAgICAgeSAtPSBvZmZzZXRQYXJlbnQuY2xpZW50SGVpZ2h0IC0gcG9wcGVyUmVjdC5oZWlnaHQ7XG4gICAgICB5ICo9IGdwdUFjY2VsZXJhdGlvbiA/IDEgOiAtMTtcbiAgICB9XG5cbiAgICBpZiAocGxhY2VtZW50ID09PSBsZWZ0KSB7XG4gICAgICBzaWRlWCA9IHJpZ2h0O1xuICAgICAgeCAtPSBvZmZzZXRQYXJlbnQuY2xpZW50V2lkdGggLSBwb3BwZXJSZWN0LndpZHRoO1xuICAgICAgeCAqPSBncHVBY2NlbGVyYXRpb24gPyAxIDogLTE7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbW1vblN0eWxlcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICB9LCBhZGFwdGl2ZSAmJiB1bnNldFNpZGVzKTtcblxuICBpZiAoZ3B1QWNjZWxlcmF0aW9uKSB7XG4gICAgdmFyIF9PYmplY3QkYXNzaWduO1xuXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywgKF9PYmplY3QkYXNzaWduID0ge30sIF9PYmplY3QkYXNzaWduW3NpZGVZXSA9IGhhc1kgPyAnMCcgOiAnJywgX09iamVjdCRhc3NpZ25bc2lkZVhdID0gaGFzWCA/ICcwJyA6ICcnLCBfT2JqZWN0JGFzc2lnbi50cmFuc2Zvcm0gPSAod2luLmRldmljZVBpeGVsUmF0aW8gfHwgMSkgPCAyID8gXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweClcIiA6IFwidHJhbnNsYXRlM2QoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweCwgMClcIiwgX09iamVjdCRhc3NpZ24pKTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIChfT2JqZWN0JGFzc2lnbjIgPSB7fSwgX09iamVjdCRhc3NpZ24yW3NpZGVZXSA9IGhhc1kgPyB5ICsgXCJweFwiIDogJycsIF9PYmplY3QkYXNzaWduMltzaWRlWF0gPSBoYXNYID8geCArIFwicHhcIiA6ICcnLCBfT2JqZWN0JGFzc2lnbjIudHJhbnNmb3JtID0gJycsIF9PYmplY3QkYXNzaWduMikpO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlU3R5bGVzKF9yZWYzKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYzLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYzLm9wdGlvbnM7XG4gIHZhciBfb3B0aW9ucyRncHVBY2NlbGVyYXQgPSBvcHRpb25zLmdwdUFjY2VsZXJhdGlvbixcbiAgICAgIGdwdUFjY2VsZXJhdGlvbiA9IF9vcHRpb25zJGdwdUFjY2VsZXJhdCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGdwdUFjY2VsZXJhdCxcbiAgICAgIF9vcHRpb25zJGFkYXB0aXZlID0gb3B0aW9ucy5hZGFwdGl2ZSxcbiAgICAgIGFkYXB0aXZlID0gX29wdGlvbnMkYWRhcHRpdmUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRhZGFwdGl2ZTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFyIHRyYW5zaXRpb25Qcm9wZXJ0eSA9IGdldENvbXB1dGVkU3R5bGUoc3RhdGUuZWxlbWVudHMucG9wcGVyKS50cmFuc2l0aW9uUHJvcGVydHkgfHwgJyc7XG5cbiAgICBpZiAoYWRhcHRpdmUgJiYgWyd0cmFuc2Zvcm0nLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10uc29tZShmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgIHJldHVybiB0cmFuc2l0aW9uUHJvcGVydHkuaW5kZXhPZihwcm9wZXJ0eSkgPj0gMDtcbiAgICB9KSkge1xuICAgICAgY29uc29sZS53YXJuKFsnUG9wcGVyOiBEZXRlY3RlZCBDU1MgdHJhbnNpdGlvbnMgb24gYXQgbGVhc3Qgb25lIG9mIHRoZSBmb2xsb3dpbmcnLCAnQ1NTIHByb3BlcnRpZXM6IFwidHJhbnNmb3JtXCIsIFwidG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCIuJywgJ1xcblxcbicsICdEaXNhYmxlIHRoZSBcImNvbXB1dGVTdHlsZXNcIiBtb2RpZmllclxcJ3MgYGFkYXB0aXZlYCBvcHRpb24gdG8gYWxsb3cnLCAnZm9yIHNtb290aCB0cmFuc2l0aW9ucywgb3IgcmVtb3ZlIHRoZXNlIHByb3BlcnRpZXMgZnJvbSB0aGUgQ1NTJywgJ3RyYW5zaXRpb24gZGVjbGFyYXRpb24gb24gdGhlIHBvcHBlciBlbGVtZW50IGlmIG9ubHkgdHJhbnNpdGlvbmluZycsICdvcGFjaXR5IG9yIGJhY2tncm91bmQtY29sb3IgZm9yIGV4YW1wbGUuJywgJ1xcblxcbicsICdXZSByZWNvbW1lbmQgdXNpbmcgdGhlIHBvcHBlciBlbGVtZW50IGFzIGEgd3JhcHBlciBhcm91bmQgYW4gaW5uZXInLCAnZWxlbWVudCB0aGF0IGNhbiBoYXZlIGFueSBDU1MgcHJvcGVydHkgdHJhbnNpdGlvbmVkIGZvciBhbmltYXRpb25zLiddLmpvaW4oJyAnKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbW1vblN0eWxlcyA9IHtcbiAgICBwbGFjZW1lbnQ6IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KSxcbiAgICBwb3BwZXI6IHN0YXRlLmVsZW1lbnRzLnBvcHBlcixcbiAgICBwb3BwZXJSZWN0OiBzdGF0ZS5yZWN0cy5wb3BwZXIsXG4gICAgZ3B1QWNjZWxlcmF0aW9uOiBncHVBY2NlbGVyYXRpb25cbiAgfTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcbiAgICBzdGF0ZS5zdHlsZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuc3R5bGVzLnBvcHBlciwge30sIG1hcFRvU3R5bGVzKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywge1xuICAgICAgb2Zmc2V0czogc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLFxuICAgICAgcG9zaXRpb246IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBhZGFwdGl2ZTogYWRhcHRpdmVcbiAgICB9KSkpO1xuICB9XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEuYXJyb3cgIT0gbnVsbCkge1xuICAgIHN0YXRlLnN0eWxlcy5hcnJvdyA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnN0eWxlcy5hcnJvdywge30sIG1hcFRvU3R5bGVzKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywge1xuICAgICAgb2Zmc2V0czogc3RhdGUubW9kaWZpZXJzRGF0YS5hcnJvdyxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgYWRhcHRpdmU6IGZhbHNlXG4gICAgfSkpKTtcbiAgfVxuXG4gIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIsIHtcbiAgICAnZGF0YS1wb3BwZXItcGxhY2VtZW50Jzogc3RhdGUucGxhY2VtZW50XG4gIH0pO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnY29tcHV0ZVN0eWxlcycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnYmVmb3JlV3JpdGUnLFxuICBmbjogY29tcHV0ZVN0eWxlcyxcbiAgZGF0YToge31cbn07IiwiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldFdpbmRvdy5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbnZhciBwYXNzaXZlID0ge1xuICBwYXNzaXZlOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgaW5zdGFuY2UgPSBfcmVmLmluc3RhbmNlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJHNjcm9sbCA9IG9wdGlvbnMuc2Nyb2xsLFxuICAgICAgc2Nyb2xsID0gX29wdGlvbnMkc2Nyb2xsID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkc2Nyb2xsLFxuICAgICAgX29wdGlvbnMkcmVzaXplID0gb3B0aW9ucy5yZXNpemUsXG4gICAgICByZXNpemUgPSBfb3B0aW9ucyRyZXNpemUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRyZXNpemU7XG4gIHZhciB3aW5kb3cgPSBnZXRXaW5kb3coc3RhdGUuZWxlbWVudHMucG9wcGVyKTtcbiAgdmFyIHNjcm9sbFBhcmVudHMgPSBbXS5jb25jYXQoc3RhdGUuc2Nyb2xsUGFyZW50cy5yZWZlcmVuY2UsIHN0YXRlLnNjcm9sbFBhcmVudHMucG9wcGVyKTtcblxuICBpZiAoc2Nyb2xsKSB7XG4gICAgc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzY3JvbGxQYXJlbnQpIHtcbiAgICAgIHNjcm9sbFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHJlc2l6ZSkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2Nyb2xsKSB7XG4gICAgICBzY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbFBhcmVudCkge1xuICAgICAgICBzY3JvbGxQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyZXNpemUpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH1cbiAgfTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2V2ZW50TGlzdGVuZXJzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICd3cml0ZScsXG4gIGZuOiBmdW5jdGlvbiBmbigpIHt9LFxuICBlZmZlY3Q6IGVmZmVjdCxcbiAgZGF0YToge31cbn07IiwiaW1wb3J0IGdldE9wcG9zaXRlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRPcHBvc2l0ZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBjb21wdXRlQXV0b1BsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvY29tcHV0ZUF1dG9QbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IGJvdHRvbSwgdG9wLCBzdGFydCwgcmlnaHQsIGxlZnQsIGF1dG8gfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4uL3V0aWxzL2dldFZhcmlhdGlvbi5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmZ1bmN0aW9uIGdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzKHBsYWNlbWVudCkge1xuICBpZiAoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIG9wcG9zaXRlUGxhY2VtZW50ID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgcmV0dXJuIFtnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChwbGFjZW1lbnQpLCBvcHBvc2l0ZVBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQob3Bwb3NpdGVQbGFjZW1lbnQpXTtcbn1cblxuZnVuY3Rpb24gZmxpcChfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyRtYWluQXhpcyA9IG9wdGlvbnMubWFpbkF4aXMsXG4gICAgICBjaGVja01haW5BeGlzID0gX29wdGlvbnMkbWFpbkF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRtYWluQXhpcyxcbiAgICAgIF9vcHRpb25zJGFsdEF4aXMgPSBvcHRpb25zLmFsdEF4aXMsXG4gICAgICBjaGVja0FsdEF4aXMgPSBfb3B0aW9ucyRhbHRBeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkYWx0QXhpcyxcbiAgICAgIHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyA9IG9wdGlvbnMuZmFsbGJhY2tQbGFjZW1lbnRzLFxuICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgIGJvdW5kYXJ5ID0gb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IG9wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBvcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkZmxpcFZhcmlhdGlvID0gb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyxcbiAgICAgIGZsaXBWYXJpYXRpb25zID0gX29wdGlvbnMkZmxpcFZhcmlhdGlvID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkZmxpcFZhcmlhdGlvLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gb3B0aW9ucy5hbGxvd2VkQXV0b1BsYWNlbWVudHM7XG4gIHZhciBwcmVmZXJyZWRQbGFjZW1lbnQgPSBzdGF0ZS5vcHRpb25zLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHByZWZlcnJlZFBsYWNlbWVudCk7XG4gIHZhciBpc0Jhc2VQbGFjZW1lbnQgPSBiYXNlUGxhY2VtZW50ID09PSBwcmVmZXJyZWRQbGFjZW1lbnQ7XG4gIHZhciBmYWxsYmFja1BsYWNlbWVudHMgPSBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgfHwgKGlzQmFzZVBsYWNlbWVudCB8fCAhZmxpcFZhcmlhdGlvbnMgPyBbZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocHJlZmVycmVkUGxhY2VtZW50KV0gOiBnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyhwcmVmZXJyZWRQbGFjZW1lbnQpKTtcbiAgdmFyIHBsYWNlbWVudHMgPSBbcHJlZmVycmVkUGxhY2VtZW50XS5jb25jYXQoZmFsbGJhY2tQbGFjZW1lbnRzKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGFjYy5jb25jYXQoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvID8gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgICAgZmxpcFZhcmlhdGlvbnM6IGZsaXBWYXJpYXRpb25zLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzOiBhbGxvd2VkQXV0b1BsYWNlbWVudHNcbiAgICB9KSA6IHBsYWNlbWVudCk7XG4gIH0sIFtdKTtcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgY2hlY2tzTWFwID0gbmV3IE1hcCgpO1xuICB2YXIgbWFrZUZhbGxiYWNrQ2hlY2tzID0gdHJ1ZTtcbiAgdmFyIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudHNbMF07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbGFjZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBsYWNlbWVudCA9IHBsYWNlbWVudHNbaV07XG5cbiAgICB2YXIgX2Jhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XG5cbiAgICB2YXIgaXNTdGFydFZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpID09PSBzdGFydDtcbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFt0b3AsIGJvdHRvbV0uaW5kZXhPZihfYmFzZVBsYWNlbWVudCkgPj0gMDtcbiAgICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICB2YXIgb3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5OiBhbHRCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmdcbiAgICB9KTtcbiAgICB2YXIgbWFpblZhcmlhdGlvblNpZGUgPSBpc1ZlcnRpY2FsID8gaXNTdGFydFZhcmlhdGlvbiA/IHJpZ2h0IDogbGVmdCA6IGlzU3RhcnRWYXJpYXRpb24gPyBib3R0b20gOiB0b3A7XG5cbiAgICBpZiAocmVmZXJlbmNlUmVjdFtsZW5dID4gcG9wcGVyUmVjdFtsZW5dKSB7XG4gICAgICBtYWluVmFyaWF0aW9uU2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5WYXJpYXRpb25TaWRlKTtcbiAgICB9XG5cbiAgICB2YXIgYWx0VmFyaWF0aW9uU2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5WYXJpYXRpb25TaWRlKTtcbiAgICB2YXIgY2hlY2tzID0gW107XG5cbiAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgY2hlY2tzLnB1c2gob3ZlcmZsb3dbX2Jhc2VQbGFjZW1lbnRdIDw9IDApO1xuICAgIH1cblxuICAgIGlmIChjaGVja0FsdEF4aXMpIHtcbiAgICAgIGNoZWNrcy5wdXNoKG92ZXJmbG93W21haW5WYXJpYXRpb25TaWRlXSA8PSAwLCBvdmVyZmxvd1thbHRWYXJpYXRpb25TaWRlXSA8PSAwKTtcbiAgICB9XG5cbiAgICBpZiAoY2hlY2tzLmV2ZXJ5KGZ1bmN0aW9uIChjaGVjaykge1xuICAgICAgcmV0dXJuIGNoZWNrO1xuICAgIH0pKSB7XG4gICAgICBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gICAgICBtYWtlRmFsbGJhY2tDaGVja3MgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNoZWNrc01hcC5zZXQocGxhY2VtZW50LCBjaGVja3MpO1xuICB9XG5cbiAgaWYgKG1ha2VGYWxsYmFja0NoZWNrcykge1xuICAgIC8vIGAyYCBtYXkgYmUgZGVzaXJlZCBpbiBzb21lIGNhc2VzIOKAkyByZXNlYXJjaCBsYXRlclxuICAgIHZhciBudW1iZXJPZkNoZWNrcyA9IGZsaXBWYXJpYXRpb25zID8gMyA6IDE7XG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChfaSkge1xuICAgICAgdmFyIGZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnRzLmZpbmQoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgICAgICB2YXIgY2hlY2tzID0gY2hlY2tzTWFwLmdldChwbGFjZW1lbnQpO1xuXG4gICAgICAgIGlmIChjaGVja3MpIHtcbiAgICAgICAgICByZXR1cm4gY2hlY2tzLnNsaWNlKDAsIF9pKS5ldmVyeShmdW5jdGlvbiAoY2hlY2spIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVjaztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChmaXR0aW5nUGxhY2VtZW50KSB7XG4gICAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IGZpdHRpbmdQbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiBcImJyZWFrXCI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIF9pID0gbnVtYmVyT2ZDaGVja3M7IF9pID4gMDsgX2ktLSkge1xuICAgICAgdmFyIF9yZXQgPSBfbG9vcChfaSk7XG5cbiAgICAgIGlmIChfcmV0ID09PSBcImJyZWFrXCIpIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGF0ZS5wbGFjZW1lbnQgIT09IGZpcnN0Rml0dGluZ1BsYWNlbWVudCkge1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0uX3NraXAgPSB0cnVlO1xuICAgIHN0YXRlLnBsYWNlbWVudCA9IGZpcnN0Rml0dGluZ1BsYWNlbWVudDtcbiAgICBzdGF0ZS5yZXNldCA9IHRydWU7XG4gIH1cbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2ZsaXAnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogZmxpcCxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydvZmZzZXQnXSxcbiAgZGF0YToge1xuICAgIF9za2lwOiBmYWxzZVxuICB9XG59OyIsImltcG9ydCB7IHRvcCwgYm90dG9tLCBsZWZ0LCByaWdodCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuXG5mdW5jdGlvbiBnZXRTaWRlT2Zmc2V0cyhvdmVyZmxvdywgcmVjdCwgcHJldmVudGVkT2Zmc2V0cykge1xuICBpZiAocHJldmVudGVkT2Zmc2V0cyA9PT0gdm9pZCAwKSB7XG4gICAgcHJldmVudGVkT2Zmc2V0cyA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG9wOiBvdmVyZmxvdy50b3AgLSByZWN0LmhlaWdodCAtIHByZXZlbnRlZE9mZnNldHMueSxcbiAgICByaWdodDogb3ZlcmZsb3cucmlnaHQgLSByZWN0LndpZHRoICsgcHJldmVudGVkT2Zmc2V0cy54LFxuICAgIGJvdHRvbTogb3ZlcmZsb3cuYm90dG9tIC0gcmVjdC5oZWlnaHQgKyBwcmV2ZW50ZWRPZmZzZXRzLnksXG4gICAgbGVmdDogb3ZlcmZsb3cubGVmdCAtIHJlY3Qud2lkdGggLSBwcmV2ZW50ZWRPZmZzZXRzLnhcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKG92ZXJmbG93KSB7XG4gIHJldHVybiBbdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XS5zb21lKGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgcmV0dXJuIG92ZXJmbG93W3NpZGVdID49IDA7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBoaWRlKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG4gIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIHByZXZlbnRlZE9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnByZXZlbnRPdmVyZmxvdztcbiAgdmFyIHJlZmVyZW5jZU92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBlbGVtZW50Q29udGV4dDogJ3JlZmVyZW5jZSdcbiAgfSk7XG4gIHZhciBwb3BwZXJBbHRPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgYWx0Qm91bmRhcnk6IHRydWVcbiAgfSk7XG4gIHZhciByZWZlcmVuY2VDbGlwcGluZ09mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhyZWZlcmVuY2VPdmVyZmxvdywgcmVmZXJlbmNlUmVjdCk7XG4gIHZhciBwb3BwZXJFc2NhcGVPZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMocG9wcGVyQWx0T3ZlcmZsb3csIHBvcHBlclJlY3QsIHByZXZlbnRlZE9mZnNldHMpO1xuICB2YXIgaXNSZWZlcmVuY2VIaWRkZW4gPSBpc0FueVNpZGVGdWxseUNsaXBwZWQocmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzKTtcbiAgdmFyIGhhc1BvcHBlckVzY2FwZWQgPSBpc0FueVNpZGVGdWxseUNsaXBwZWQocG9wcGVyRXNjYXBlT2Zmc2V0cyk7XG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSB7XG4gICAgcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzOiByZWZlcmVuY2VDbGlwcGluZ09mZnNldHMsXG4gICAgcG9wcGVyRXNjYXBlT2Zmc2V0czogcG9wcGVyRXNjYXBlT2Zmc2V0cyxcbiAgICBpc1JlZmVyZW5jZUhpZGRlbjogaXNSZWZlcmVuY2VIaWRkZW4sXG4gICAgaGFzUG9wcGVyRXNjYXBlZDogaGFzUG9wcGVyRXNjYXBlZFxuICB9O1xuICBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyLCB7XG4gICAgJ2RhdGEtcG9wcGVyLXJlZmVyZW5jZS1oaWRkZW4nOiBpc1JlZmVyZW5jZUhpZGRlbixcbiAgICAnZGF0YS1wb3BwZXItZXNjYXBlZCc6IGhhc1BvcHBlckVzY2FwZWRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdoaWRlJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydwcmV2ZW50T3ZlcmZsb3cnXSxcbiAgZm46IGhpZGVcbn07IiwiaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IHRvcCwgbGVmdCwgcmlnaHQsIHBsYWNlbWVudHMgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZUFuZFNraWRkaW5nVG9YWShwbGFjZW1lbnQsIHJlY3RzLCBvZmZzZXQpIHtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHZhciBpbnZlcnREaXN0YW5jZSA9IFtsZWZ0LCB0b3BdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMCA/IC0xIDogMTtcblxuICB2YXIgX3JlZiA9IHR5cGVvZiBvZmZzZXQgPT09ICdmdW5jdGlvbicgPyBvZmZzZXQoT2JqZWN0LmFzc2lnbih7fSwgcmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudFxuICB9KSkgOiBvZmZzZXQsXG4gICAgICBza2lkZGluZyA9IF9yZWZbMF0sXG4gICAgICBkaXN0YW5jZSA9IF9yZWZbMV07XG5cbiAgc2tpZGRpbmcgPSBza2lkZGluZyB8fCAwO1xuICBkaXN0YW5jZSA9IChkaXN0YW5jZSB8fCAwKSAqIGludmVydERpc3RhbmNlO1xuICByZXR1cm4gW2xlZnQsIHJpZ2h0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDAgPyB7XG4gICAgeDogZGlzdGFuY2UsXG4gICAgeTogc2tpZGRpbmdcbiAgfSA6IHtcbiAgICB4OiBza2lkZGluZyxcbiAgICB5OiBkaXN0YW5jZVxuICB9O1xufVxuXG5mdW5jdGlvbiBvZmZzZXQoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjIub3B0aW9ucyxcbiAgICAgIG5hbWUgPSBfcmVmMi5uYW1lO1xuICB2YXIgX29wdGlvbnMkb2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQsXG4gICAgICBvZmZzZXQgPSBfb3B0aW9ucyRvZmZzZXQgPT09IHZvaWQgMCA/IFswLCAwXSA6IF9vcHRpb25zJG9mZnNldDtcbiAgdmFyIGRhdGEgPSBwbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICBhY2NbcGxhY2VtZW50XSA9IGRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZKHBsYWNlbWVudCwgc3RhdGUucmVjdHMsIG9mZnNldCk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICB2YXIgX2RhdGEkc3RhdGUkcGxhY2VtZW50ID0gZGF0YVtzdGF0ZS5wbGFjZW1lbnRdLFxuICAgICAgeCA9IF9kYXRhJHN0YXRlJHBsYWNlbWVudC54LFxuICAgICAgeSA9IF9kYXRhJHN0YXRlJHBsYWNlbWVudC55O1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy54ICs9IHg7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnkgKz0geTtcbiAgfVxuXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBkYXRhO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnb2Zmc2V0JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgcmVxdWlyZXM6IFsncG9wcGVyT2Zmc2V0cyddLFxuICBmbjogb2Zmc2V0XG59OyIsImltcG9ydCBjb21wdXRlT2Zmc2V0cyBmcm9tIFwiLi4vdXRpbHMvY29tcHV0ZU9mZnNldHMuanNcIjtcblxuZnVuY3Rpb24gcG9wcGVyT2Zmc2V0cyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICAvLyBPZmZzZXRzIGFyZSB0aGUgYWN0dWFsIHBvc2l0aW9uIHRoZSBwb3BwZXIgbmVlZHMgdG8gaGF2ZSB0byBiZVxuICAvLyBwcm9wZXJseSBwb3NpdGlvbmVkIG5lYXIgaXRzIHJlZmVyZW5jZSBlbGVtZW50XG4gIC8vIFRoaXMgaXMgdGhlIG1vc3QgYmFzaWMgcGxhY2VtZW50LCBhbmQgd2lsbCBiZSBhZGp1c3RlZCBieVxuICAvLyB0aGUgbW9kaWZpZXJzIGluIHRoZSBuZXh0IHN0ZXBcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGNvbXB1dGVPZmZzZXRzKHtcbiAgICByZWZlcmVuY2U6IHN0YXRlLnJlY3RzLnJlZmVyZW5jZSxcbiAgICBlbGVtZW50OiBzdGF0ZS5yZWN0cy5wb3BwZXIsXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdwb3BwZXJPZmZzZXRzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdyZWFkJyxcbiAgZm46IHBvcHBlck9mZnNldHMsXG4gIGRhdGE6IHt9XG59OyIsImltcG9ydCB7IHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgc3RhcnQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRBbHRBeGlzIGZyb20gXCIuLi91dGlscy9nZXRBbHRBeGlzLmpzXCI7XG5pbXBvcnQgd2l0aGluIGZyb20gXCIuLi91dGlscy93aXRoaW4uanNcIjtcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi4vdXRpbHMvZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgZ2V0RnJlc2hTaWRlT2JqZWN0IGZyb20gXCIuLi91dGlscy9nZXRGcmVzaFNpZGVPYmplY3QuanNcIjtcblxuZnVuY3Rpb24gcHJldmVudE92ZXJmbG93KF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICB2YXIgX29wdGlvbnMkbWFpbkF4aXMgPSBvcHRpb25zLm1haW5BeGlzLFxuICAgICAgY2hlY2tNYWluQXhpcyA9IF9vcHRpb25zJG1haW5BeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkbWFpbkF4aXMsXG4gICAgICBfb3B0aW9ucyRhbHRBeGlzID0gb3B0aW9ucy5hbHRBeGlzLFxuICAgICAgY2hlY2tBbHRBeGlzID0gX29wdGlvbnMkYWx0QXhpcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRhbHRBeGlzLFxuICAgICAgYm91bmRhcnkgPSBvcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IG9wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgX29wdGlvbnMkdGV0aGVyID0gb3B0aW9ucy50ZXRoZXIsXG4gICAgICB0ZXRoZXIgPSBfb3B0aW9ucyR0ZXRoZXIgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyR0ZXRoZXIsXG4gICAgICBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQgPSBvcHRpb25zLnRldGhlck9mZnNldCxcbiAgICAgIHRldGhlck9mZnNldCA9IF9vcHRpb25zJHRldGhlck9mZnNldCA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJHRldGhlck9mZnNldDtcbiAgdmFyIG92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgcGFkZGluZzogcGFkZGluZyxcbiAgICBhbHRCb3VuZGFyeTogYWx0Qm91bmRhcnlcbiAgfSk7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHN0YXRlLnBsYWNlbWVudCk7XG4gIHZhciBpc0Jhc2VQbGFjZW1lbnQgPSAhdmFyaWF0aW9uO1xuICB2YXIgbWFpbkF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCk7XG4gIHZhciBhbHRBeGlzID0gZ2V0QWx0QXhpcyhtYWluQXhpcyk7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzO1xuICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciB0ZXRoZXJPZmZzZXRWYWx1ZSA9IHR5cGVvZiB0ZXRoZXJPZmZzZXQgPT09ICdmdW5jdGlvbicgPyB0ZXRoZXJPZmZzZXQoT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUucmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KSkgOiB0ZXRoZXJPZmZzZXQ7XG4gIHZhciBkYXRhID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuXG4gIGlmICghcG9wcGVyT2Zmc2V0cykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgdmFyIG1haW5TaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/IHRvcCA6IGxlZnQ7XG4gICAgdmFyIGFsdFNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gYm90dG9tIDogcmlnaHQ7XG4gICAgdmFyIGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgdmFyIG9mZnNldCA9IHBvcHBlck9mZnNldHNbbWFpbkF4aXNdO1xuICAgIHZhciBtaW4gPSBwb3BwZXJPZmZzZXRzW21haW5BeGlzXSArIG92ZXJmbG93W21haW5TaWRlXTtcbiAgICB2YXIgbWF4ID0gcG9wcGVyT2Zmc2V0c1ttYWluQXhpc10gLSBvdmVyZmxvd1thbHRTaWRlXTtcbiAgICB2YXIgYWRkaXRpdmUgPSB0ZXRoZXIgPyAtcG9wcGVyUmVjdFtsZW5dIC8gMiA6IDA7XG4gICAgdmFyIG1pbkxlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gOiBwb3BwZXJSZWN0W2xlbl07XG4gICAgdmFyIG1heExlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyAtcG9wcGVyUmVjdFtsZW5dIDogLXJlZmVyZW5jZVJlY3RbbGVuXTsgLy8gV2UgbmVlZCB0byBpbmNsdWRlIHRoZSBhcnJvdyBpbiB0aGUgY2FsY3VsYXRpb24gc28gdGhlIGFycm93IGRvZXNuJ3QgZ29cbiAgICAvLyBvdXRzaWRlIHRoZSByZWZlcmVuY2UgYm91bmRzXG5cbiAgICB2YXIgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3c7XG4gICAgdmFyIGFycm93UmVjdCA9IHRldGhlciAmJiBhcnJvd0VsZW1lbnQgPyBnZXRMYXlvdXRSZWN0KGFycm93RWxlbWVudCkgOiB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH07XG4gICAgdmFyIGFycm93UGFkZGluZ09iamVjdCA9IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXSA/IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXS5wYWRkaW5nIDogZ2V0RnJlc2hTaWRlT2JqZWN0KCk7XG4gICAgdmFyIGFycm93UGFkZGluZ01pbiA9IGFycm93UGFkZGluZ09iamVjdFttYWluU2lkZV07XG4gICAgdmFyIGFycm93UGFkZGluZ01heCA9IGFycm93UGFkZGluZ09iamVjdFthbHRTaWRlXTsgLy8gSWYgdGhlIHJlZmVyZW5jZSBsZW5ndGggaXMgc21hbGxlciB0aGFuIHRoZSBhcnJvdyBsZW5ndGgsIHdlIGRvbid0IHdhbnRcbiAgICAvLyB0byBpbmNsdWRlIGl0cyBmdWxsIHNpemUgaW4gdGhlIGNhbGN1bGF0aW9uLiBJZiB0aGUgcmVmZXJlbmNlIGlzIHNtYWxsXG4gICAgLy8gYW5kIG5lYXIgdGhlIGVkZ2Ugb2YgYSBib3VuZGFyeSwgdGhlIHBvcHBlciBjYW4gb3ZlcmZsb3cgZXZlbiBpZiB0aGVcbiAgICAvLyByZWZlcmVuY2UgaXMgbm90IG92ZXJmbG93aW5nIGFzIHdlbGwgKGUuZy4gdmlydHVhbCBlbGVtZW50cyB3aXRoIG5vXG4gICAgLy8gd2lkdGggb3IgaGVpZ2h0KVxuXG4gICAgdmFyIGFycm93TGVuID0gd2l0aGluKDAsIHJlZmVyZW5jZVJlY3RbbGVuXSwgYXJyb3dSZWN0W2xlbl0pO1xuICAgIHZhciBtaW5PZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gLyAyIC0gYWRkaXRpdmUgLSBhcnJvd0xlbiAtIGFycm93UGFkZGluZ01pbiAtIHRldGhlck9mZnNldFZhbHVlIDogbWluTGVuIC0gYXJyb3dMZW4gLSBhcnJvd1BhZGRpbmdNaW4gLSB0ZXRoZXJPZmZzZXRWYWx1ZTtcbiAgICB2YXIgbWF4T2Zmc2V0ID0gaXNCYXNlUGxhY2VtZW50ID8gLXJlZmVyZW5jZVJlY3RbbGVuXSAvIDIgKyBhZGRpdGl2ZSArIGFycm93TGVuICsgYXJyb3dQYWRkaW5nTWF4ICsgdGV0aGVyT2Zmc2V0VmFsdWUgOiBtYXhMZW4gKyBhcnJvd0xlbiArIGFycm93UGFkZGluZ01heCArIHRldGhlck9mZnNldFZhbHVlO1xuICAgIHZhciBhcnJvd09mZnNldFBhcmVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93ICYmIGdldE9mZnNldFBhcmVudChzdGF0ZS5lbGVtZW50cy5hcnJvdyk7XG4gICAgdmFyIGNsaWVudE9mZnNldCA9IGFycm93T2Zmc2V0UGFyZW50ID8gbWFpbkF4aXMgPT09ICd5JyA/IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudFRvcCB8fCAwIDogYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50TGVmdCB8fCAwIDogMDtcbiAgICB2YXIgb2Zmc2V0TW9kaWZpZXJWYWx1ZSA9IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0ID8gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXRbc3RhdGUucGxhY2VtZW50XVttYWluQXhpc10gOiAwO1xuICAgIHZhciB0ZXRoZXJNaW4gPSBwb3BwZXJPZmZzZXRzW21haW5BeGlzXSArIG1pbk9mZnNldCAtIG9mZnNldE1vZGlmaWVyVmFsdWUgLSBjbGllbnRPZmZzZXQ7XG4gICAgdmFyIHRldGhlck1heCA9IHBvcHBlck9mZnNldHNbbWFpbkF4aXNdICsgbWF4T2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZTtcbiAgICB2YXIgcHJldmVudGVkT2Zmc2V0ID0gd2l0aGluKHRldGhlciA/IE1hdGgubWluKG1pbiwgdGV0aGVyTWluKSA6IG1pbiwgb2Zmc2V0LCB0ZXRoZXIgPyBNYXRoLm1heChtYXgsIHRldGhlck1heCkgOiBtYXgpO1xuICAgIHBvcHBlck9mZnNldHNbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0O1xuICAgIGRhdGFbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0IC0gb2Zmc2V0O1xuICB9XG5cbiAgaWYgKGNoZWNrQWx0QXhpcykge1xuICAgIHZhciBfbWFpblNpZGUgPSBtYWluQXhpcyA9PT0gJ3gnID8gdG9wIDogbGVmdDtcblxuICAgIHZhciBfYWx0U2lkZSA9IG1haW5BeGlzID09PSAneCcgPyBib3R0b20gOiByaWdodDtcblxuICAgIHZhciBfb2Zmc2V0ID0gcG9wcGVyT2Zmc2V0c1thbHRBeGlzXTtcblxuICAgIHZhciBfbWluID0gX29mZnNldCArIG92ZXJmbG93W19tYWluU2lkZV07XG5cbiAgICB2YXIgX21heCA9IF9vZmZzZXQgLSBvdmVyZmxvd1tfYWx0U2lkZV07XG5cbiAgICB2YXIgX3ByZXZlbnRlZE9mZnNldCA9IHdpdGhpbihfbWluLCBfb2Zmc2V0LCBfbWF4KTtcblxuICAgIHBvcHBlck9mZnNldHNbYWx0QXhpc10gPSBfcHJldmVudGVkT2Zmc2V0O1xuICAgIGRhdGFbYWx0QXhpc10gPSBfcHJldmVudGVkT2Zmc2V0IC0gX29mZnNldDtcbiAgfVxuXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBkYXRhO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgZm46IHByZXZlbnRPdmVyZmxvdyxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydvZmZzZXQnXVxufTsiLCJpbXBvcnQgeyBwb3BwZXJHZW5lcmF0b3IgfSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IGV2ZW50TGlzdGVuZXJzIGZyb20gXCIuL21vZGlmaWVycy9ldmVudExpc3RlbmVycy5qc1wiO1xuaW1wb3J0IHBvcHBlck9mZnNldHMgZnJvbSBcIi4vbW9kaWZpZXJzL3BvcHBlck9mZnNldHMuanNcIjtcbmltcG9ydCBjb21wdXRlU3R5bGVzIGZyb20gXCIuL21vZGlmaWVycy9jb21wdXRlU3R5bGVzLmpzXCI7XG5pbXBvcnQgYXBwbHlTdHlsZXMgZnJvbSBcIi4vbW9kaWZpZXJzL2FwcGx5U3R5bGVzLmpzXCI7XG5pbXBvcnQgb2Zmc2V0IGZyb20gXCIuL21vZGlmaWVycy9vZmZzZXQuanNcIjtcbmltcG9ydCBmbGlwIGZyb20gXCIuL21vZGlmaWVycy9mbGlwLmpzXCI7XG5pbXBvcnQgcHJldmVudE92ZXJmbG93IGZyb20gXCIuL21vZGlmaWVycy9wcmV2ZW50T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBhcnJvdyBmcm9tIFwiLi9tb2RpZmllcnMvYXJyb3cuanNcIjtcbmltcG9ydCBoaWRlIGZyb20gXCIuL21vZGlmaWVycy9oaWRlLmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbnZhciBkZWZhdWx0TW9kaWZpZXJzID0gW2V2ZW50TGlzdGVuZXJzLCBwb3BwZXJPZmZzZXRzLCBjb21wdXRlU3R5bGVzLCBhcHBseVN0eWxlcywgb2Zmc2V0LCBmbGlwLCBwcmV2ZW50T3ZlcmZsb3csIGFycm93LCBoaWRlXTtcbnZhciBjcmVhdGVQb3BwZXIgPSAvKiNfX1BVUkVfXyovcG9wcGVyR2VuZXJhdG9yKHtcbiAgZGVmYXVsdE1vZGlmaWVyczogZGVmYXVsdE1vZGlmaWVyc1xufSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgY3JlYXRlUG9wcGVyLCBwb3BwZXJHZW5lcmF0b3IsIGRlZmF1bHRNb2RpZmllcnMsIGRldGVjdE92ZXJmbG93IH07IiwiaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCB7IHZhcmlhdGlvblBsYWNlbWVudHMsIGJhc2VQbGFjZW1lbnRzLCBwbGFjZW1lbnRzIGFzIGFsbFBsYWNlbWVudHMgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4vZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuXG4vKjo6IHR5cGUgT3ZlcmZsb3dzTWFwID0geyBbQ29tcHV0ZWRQbGFjZW1lbnRdOiBudW1iZXIgfTsgKi9cblxuLyo7OyB0eXBlIE92ZXJmbG93c01hcCA9IHsgW2tleSBpbiBDb21wdXRlZFBsYWNlbWVudF06IG51bWJlciB9OyAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZyA9IF9vcHRpb25zLnBhZGRpbmcsXG4gICAgICBmbGlwVmFyaWF0aW9ucyA9IF9vcHRpb25zLmZsaXBWYXJpYXRpb25zLFxuICAgICAgX29wdGlvbnMkYWxsb3dlZEF1dG9QID0gX29wdGlvbnMuYWxsb3dlZEF1dG9QbGFjZW1lbnRzLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gX29wdGlvbnMkYWxsb3dlZEF1dG9QID09PSB2b2lkIDAgPyBhbGxQbGFjZW1lbnRzIDogX29wdGlvbnMkYWxsb3dlZEF1dG9QO1xuICB2YXIgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCk7XG4gIHZhciBwbGFjZW1lbnRzID0gKHZhcmlhdGlvbiA/IGZsaXBWYXJpYXRpb25zID8gdmFyaWF0aW9uUGxhY2VtZW50cyA6IHZhcmlhdGlvblBsYWNlbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgPT09IHZhcmlhdGlvbjtcbiAgfSkgOiBiYXNlUGxhY2VtZW50cykuZmlsdGVyKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gYWxsb3dlZEF1dG9QbGFjZW1lbnRzLmluZGV4T2YocGxhY2VtZW50KSA+PSAwO1xuICB9KTsgLy8gJEZsb3dGaXhNZTogRmxvdyBzZWVtcyB0byBoYXZlIHByb2JsZW1zIHdpdGggdHdvIGFycmF5IHVuaW9ucy4uLlxuXG4gIHZhciBvdmVyZmxvd3MgPSBwbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICBhY2NbcGxhY2VtZW50XSA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgIH0pW2dldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KV07XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICByZXR1cm4gT2JqZWN0LmtleXMob3ZlcmZsb3dzKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIG92ZXJmbG93c1thXSAtIG92ZXJmbG93c1tiXTtcbiAgfSk7XG59IiwiaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4vZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQgZnJvbSBcIi4vZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgeyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHN0YXJ0LCBlbmQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXB1dGVPZmZzZXRzKF9yZWYpIHtcbiAgdmFyIHJlZmVyZW5jZSA9IF9yZWYucmVmZXJlbmNlLFxuICAgICAgZWxlbWVudCA9IF9yZWYuZWxlbWVudCxcbiAgICAgIHBsYWNlbWVudCA9IF9yZWYucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudCA/IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA6IG51bGw7XG4gIHZhciB2YXJpYXRpb24gPSBwbGFjZW1lbnQgPyBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA6IG51bGw7XG4gIHZhciBjb21tb25YID0gcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGggLyAyIC0gZWxlbWVudC53aWR0aCAvIDI7XG4gIHZhciBjb21tb25ZID0gcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0IC8gMiAtIGVsZW1lbnQuaGVpZ2h0IC8gMjtcbiAgdmFyIG9mZnNldHM7XG5cbiAgc3dpdGNoIChiYXNlUGxhY2VtZW50KSB7XG4gICAgY2FzZSB0b3A6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSAtIGVsZW1lbnQuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIGJvdHRvbTpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSByaWdodDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIGxlZnQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCAtIGVsZW1lbnQud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnlcbiAgICAgIH07XG4gIH1cblxuICB2YXIgbWFpbkF4aXMgPSBiYXNlUGxhY2VtZW50ID8gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpIDogbnVsbDtcblxuICBpZiAobWFpbkF4aXMgIT0gbnVsbCkge1xuICAgIHZhciBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gICAgc3dpdGNoICh2YXJpYXRpb24pIHtcbiAgICAgIGNhc2Ugc3RhcnQ6XG4gICAgICAgIG9mZnNldHNbbWFpbkF4aXNdID0gTWF0aC5mbG9vcihvZmZzZXRzW21haW5BeGlzXSkgLSBNYXRoLmZsb29yKHJlZmVyZW5jZVtsZW5dIC8gMiAtIGVsZW1lbnRbbGVuXSAvIDIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBlbmQ6XG4gICAgICAgIG9mZnNldHNbbWFpbkF4aXNdID0gTWF0aC5mbG9vcihvZmZzZXRzW21haW5BeGlzXSkgKyBNYXRoLmNlaWwocmVmZXJlbmNlW2xlbl0gLyAyIC0gZWxlbWVudFtsZW5dIC8gMik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvZmZzZXRzO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRlYm91bmNlKGZuKSB7XG4gIHZhciBwZW5kaW5nO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghcGVuZGluZykge1xuICAgICAgcGVuZGluZyA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHBlbmRpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgcmVzb2x2ZShmbigpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGVuZGluZztcbiAgfTtcbn0iLCJpbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0Q2xpcHBpbmdSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0Q2xpcHBpbmdSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgY29tcHV0ZU9mZnNldHMgZnJvbSBcIi4vY29tcHV0ZU9mZnNldHMuanNcIjtcbmltcG9ydCByZWN0VG9DbGllbnRSZWN0IGZyb20gXCIuL3JlY3RUb0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCB7IGNsaXBwaW5nUGFyZW50cywgcmVmZXJlbmNlLCBwb3BwZXIsIGJvdHRvbSwgdG9wLCByaWdodCwgYmFzZVBsYWNlbWVudHMsIHZpZXdwb3J0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgeyBpc0VsZW1lbnQgfSBmcm9tIFwiLi4vZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBtZXJnZVBhZGRpbmdPYmplY3QgZnJvbSBcIi4vbWVyZ2VQYWRkaW5nT2JqZWN0LmpzXCI7XG5pbXBvcnQgZXhwYW5kVG9IYXNoTWFwIGZyb20gXCIuL2V4cGFuZFRvSGFzaE1hcC5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRldGVjdE92ZXJmbG93KHN0YXRlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgX29wdGlvbnMkcGxhY2VtZW50ID0gX29wdGlvbnMucGxhY2VtZW50LFxuICAgICAgcGxhY2VtZW50ID0gX29wdGlvbnMkcGxhY2VtZW50ID09PSB2b2lkIDAgPyBzdGF0ZS5wbGFjZW1lbnQgOiBfb3B0aW9ucyRwbGFjZW1lbnQsXG4gICAgICBfb3B0aW9ucyRib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgYm91bmRhcnkgPSBfb3B0aW9ucyRib3VuZGFyeSA9PT0gdm9pZCAwID8gY2xpcHBpbmdQYXJlbnRzIDogX29wdGlvbnMkYm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRyb290Qm91bmRhcnkgPSBfb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBfb3B0aW9ucyRyb290Qm91bmRhcnkgPT09IHZvaWQgMCA/IHZpZXdwb3J0IDogX29wdGlvbnMkcm9vdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkZWxlbWVudENvbnRlID0gX29wdGlvbnMuZWxlbWVudENvbnRleHQsXG4gICAgICBlbGVtZW50Q29udGV4dCA9IF9vcHRpb25zJGVsZW1lbnRDb250ZSA9PT0gdm9pZCAwID8gcG9wcGVyIDogX29wdGlvbnMkZWxlbWVudENvbnRlLFxuICAgICAgX29wdGlvbnMkYWx0Qm91bmRhcnkgPSBfb3B0aW9ucy5hbHRCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5ID0gX29wdGlvbnMkYWx0Qm91bmRhcnkgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkYWx0Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRwYWRkaW5nID0gX29wdGlvbnMucGFkZGluZyxcbiAgICAgIHBhZGRpbmcgPSBfb3B0aW9ucyRwYWRkaW5nID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkcGFkZGluZztcbiAgdmFyIHBhZGRpbmdPYmplY3QgPSBtZXJnZVBhZGRpbmdPYmplY3QodHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gcGFkZGluZyA6IGV4cGFuZFRvSGFzaE1hcChwYWRkaW5nLCBiYXNlUGxhY2VtZW50cykpO1xuICB2YXIgYWx0Q29udGV4dCA9IGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgPyByZWZlcmVuY2UgOiBwb3BwZXI7XG4gIHZhciByZWZlcmVuY2VFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMucmVmZXJlbmNlO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1thbHRCb3VuZGFyeSA/IGFsdENvbnRleHQgOiBlbGVtZW50Q29udGV4dF07XG4gIHZhciBjbGlwcGluZ0NsaWVudFJlY3QgPSBnZXRDbGlwcGluZ1JlY3QoaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudCA6IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgfHwgZ2V0RG9jdW1lbnRFbGVtZW50KHN0YXRlLmVsZW1lbnRzLnBvcHBlciksIGJvdW5kYXJ5LCByb290Qm91bmRhcnkpO1xuICB2YXIgcmVmZXJlbmNlQ2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChyZWZlcmVuY2VFbGVtZW50KTtcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBjb21wdXRlT2Zmc2V0cyh7XG4gICAgcmVmZXJlbmNlOiByZWZlcmVuY2VDbGllbnRSZWN0LFxuICAgIGVsZW1lbnQ6IHBvcHBlclJlY3QsXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcbiAgfSk7XG4gIHZhciBwb3BwZXJDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChPYmplY3QuYXNzaWduKHt9LCBwb3BwZXJSZWN0LCB7fSwgcG9wcGVyT2Zmc2V0cykpO1xuICB2YXIgZWxlbWVudENsaWVudFJlY3QgPSBlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyID8gcG9wcGVyQ2xpZW50UmVjdCA6IHJlZmVyZW5jZUNsaWVudFJlY3Q7IC8vIHBvc2l0aXZlID0gb3ZlcmZsb3dpbmcgdGhlIGNsaXBwaW5nIHJlY3RcbiAgLy8gMCBvciBuZWdhdGl2ZSA9IHdpdGhpbiB0aGUgY2xpcHBpbmcgcmVjdFxuXG4gIHZhciBvdmVyZmxvd09mZnNldHMgPSB7XG4gICAgdG9wOiBjbGlwcGluZ0NsaWVudFJlY3QudG9wIC0gZWxlbWVudENsaWVudFJlY3QudG9wICsgcGFkZGluZ09iamVjdC50b3AsXG4gICAgYm90dG9tOiBlbGVtZW50Q2xpZW50UmVjdC5ib3R0b20gLSBjbGlwcGluZ0NsaWVudFJlY3QuYm90dG9tICsgcGFkZGluZ09iamVjdC5ib3R0b20sXG4gICAgbGVmdDogY2xpcHBpbmdDbGllbnRSZWN0LmxlZnQgLSBlbGVtZW50Q2xpZW50UmVjdC5sZWZ0ICsgcGFkZGluZ09iamVjdC5sZWZ0LFxuICAgIHJpZ2h0OiBlbGVtZW50Q2xpZW50UmVjdC5yaWdodCAtIGNsaXBwaW5nQ2xpZW50UmVjdC5yaWdodCArIHBhZGRpbmdPYmplY3QucmlnaHRcbiAgfTtcbiAgdmFyIG9mZnNldERhdGEgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldDsgLy8gT2Zmc2V0cyBjYW4gYmUgYXBwbGllZCBvbmx5IHRvIHRoZSBwb3BwZXIgZWxlbWVudFxuXG4gIGlmIChlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyICYmIG9mZnNldERhdGEpIHtcbiAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0RGF0YVtwbGFjZW1lbnRdO1xuICAgIE9iamVjdC5rZXlzKG92ZXJmbG93T2Zmc2V0cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgbXVsdGlwbHkgPSBbcmlnaHQsIGJvdHRvbV0uaW5kZXhPZihrZXkpID49IDAgPyAxIDogLTE7XG4gICAgICB2YXIgYXhpcyA9IFt0b3AsIGJvdHRvbV0uaW5kZXhPZihrZXkpID49IDAgPyAneScgOiAneCc7XG4gICAgICBvdmVyZmxvd09mZnNldHNba2V5XSArPSBvZmZzZXRbYXhpc10gKiBtdWx0aXBseTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBvdmVyZmxvd09mZnNldHM7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZXhwYW5kVG9IYXNoTWFwKHZhbHVlLCBrZXlzKSB7XG4gIHJldHVybiBrZXlzLnJlZHVjZShmdW5jdGlvbiAoaGFzaE1hcCwga2V5KSB7XG4gICAgaGFzaE1hcFtrZXldID0gdmFsdWU7XG4gICAgcmV0dXJuIGhhc2hNYXA7XG4gIH0sIHt9KTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmb3JtYXQoc3RyKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBbXS5jb25jYXQoYXJncykucmVkdWNlKGZ1bmN0aW9uIChwLCBjKSB7XG4gICAgcmV0dXJuIHAucmVwbGFjZSgvJXMvLCBjKTtcbiAgfSwgc3RyKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRBbHRBeGlzKGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09ICd4JyA/ICd5JyA6ICd4Jztcbn0iLCJpbXBvcnQgeyBhdXRvIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RnJlc2hTaWRlT2JqZWN0KCkge1xuICByZXR1cm4ge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMFxuICB9O1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSA+PSAwID8gJ3gnIDogJ3knO1xufSIsInZhciBoYXNoID0ge1xuICBsZWZ0OiAncmlnaHQnLFxuICByaWdodDogJ2xlZnQnLFxuICBib3R0b206ICd0b3AnLFxuICB0b3A6ICdib3R0b20nXG59O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGhhc2hbbWF0Y2hlZF07XG4gIH0pO1xufSIsInZhciBoYXNoID0ge1xuICBzdGFydDogJ2VuZCcsXG4gIGVuZDogJ3N0YXJ0J1xufTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL3N0YXJ0fGVuZC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xuICAgIHJldHVybiBoYXNoW21hdGNoZWRdO1xuICB9KTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZXJnZUJ5TmFtZShtb2RpZmllcnMpIHtcbiAgdmFyIG1lcmdlZCA9IG1vZGlmaWVycy5yZWR1Y2UoZnVuY3Rpb24gKG1lcmdlZCwgY3VycmVudCkge1xuICAgIHZhciBleGlzdGluZyA9IG1lcmdlZFtjdXJyZW50Lm5hbWVdO1xuICAgIG1lcmdlZFtjdXJyZW50Lm5hbWVdID0gZXhpc3RpbmcgPyBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZywge30sIGN1cnJlbnQsIHtcbiAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLm9wdGlvbnMsIHt9LCBjdXJyZW50Lm9wdGlvbnMpLFxuICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmcuZGF0YSwge30sIGN1cnJlbnQuZGF0YSlcbiAgICB9KSA6IGN1cnJlbnQ7XG4gICAgcmV0dXJuIG1lcmdlZDtcbiAgfSwge30pOyAvLyBJRTExIGRvZXMgbm90IHN1cHBvcnQgT2JqZWN0LnZhbHVlc1xuXG4gIHJldHVybiBPYmplY3Qua2V5cyhtZXJnZWQpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIG1lcmdlZFtrZXldO1xuICB9KTtcbn0iLCJpbXBvcnQgZ2V0RnJlc2hTaWRlT2JqZWN0IGZyb20gXCIuL2dldEZyZXNoU2lkZU9iamVjdC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVyZ2VQYWRkaW5nT2JqZWN0KHBhZGRpbmdPYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGdldEZyZXNoU2lkZU9iamVjdCgpLCB7fSwgcGFkZGluZ09iamVjdCk7XG59IiwiaW1wb3J0IHsgbW9kaWZpZXJQaGFzZXMgfSBmcm9tIFwiLi4vZW51bXMuanNcIjsgLy8gc291cmNlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80OTg3NTI1NVxuXG5mdW5jdGlvbiBvcmRlcihtb2RpZmllcnMpIHtcbiAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcbiAgdmFyIHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgbWFwLnNldChtb2RpZmllci5uYW1lLCBtb2RpZmllcik7XG4gIH0pOyAvLyBPbiB2aXNpdGluZyBvYmplY3QsIGNoZWNrIGZvciBpdHMgZGVwZW5kZW5jaWVzIGFuZCB2aXNpdCB0aGVtIHJlY3Vyc2l2ZWx5XG5cbiAgZnVuY3Rpb24gc29ydChtb2RpZmllcikge1xuICAgIHZpc2l0ZWQuYWRkKG1vZGlmaWVyLm5hbWUpO1xuICAgIHZhciByZXF1aXJlcyA9IFtdLmNvbmNhdChtb2RpZmllci5yZXF1aXJlcyB8fCBbXSwgbW9kaWZpZXIucmVxdWlyZXNJZkV4aXN0cyB8fCBbXSk7XG4gICAgcmVxdWlyZXMuZm9yRWFjaChmdW5jdGlvbiAoZGVwKSB7XG4gICAgICBpZiAoIXZpc2l0ZWQuaGFzKGRlcCkpIHtcbiAgICAgICAgdmFyIGRlcE1vZGlmaWVyID0gbWFwLmdldChkZXApO1xuXG4gICAgICAgIGlmIChkZXBNb2RpZmllcikge1xuICAgICAgICAgIHNvcnQoZGVwTW9kaWZpZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmVzdWx0LnB1c2gobW9kaWZpZXIpO1xuICB9XG5cbiAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgaWYgKCF2aXNpdGVkLmhhcyhtb2RpZmllci5uYW1lKSkge1xuICAgICAgLy8gY2hlY2sgZm9yIHZpc2l0ZWQgb2JqZWN0XG4gICAgICBzb3J0KG1vZGlmaWVyKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBvcmRlck1vZGlmaWVycyhtb2RpZmllcnMpIHtcbiAgLy8gb3JkZXIgYmFzZWQgb24gZGVwZW5kZW5jaWVzXG4gIHZhciBvcmRlcmVkTW9kaWZpZXJzID0gb3JkZXIobW9kaWZpZXJzKTsgLy8gb3JkZXIgYmFzZWQgb24gcGhhc2VcblxuICByZXR1cm4gbW9kaWZpZXJQaGFzZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBoYXNlKSB7XG4gICAgcmV0dXJuIGFjYy5jb25jYXQob3JkZXJlZE1vZGlmaWVycy5maWx0ZXIoZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgICByZXR1cm4gbW9kaWZpZXIucGhhc2UgPT09IHBoYXNlO1xuICAgIH0pKTtcbiAgfSwgW10pO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlY3RUb0NsaWVudFJlY3QocmVjdCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcmVjdCwge1xuICAgIGxlZnQ6IHJlY3QueCxcbiAgICB0b3A6IHJlY3QueSxcbiAgICByaWdodDogcmVjdC54ICsgcmVjdC53aWR0aCxcbiAgICBib3R0b206IHJlY3QueSArIHJlY3QuaGVpZ2h0XG4gIH0pO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVuaXF1ZUJ5KGFyciwgZm4pIHtcbiAgdmFyIGlkZW50aWZpZXJzID0gbmV3IFNldCgpO1xuICByZXR1cm4gYXJyLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgIHZhciBpZGVudGlmaWVyID0gZm4oaXRlbSk7XG5cbiAgICBpZiAoIWlkZW50aWZpZXJzLmhhcyhpZGVudGlmaWVyKSkge1xuICAgICAgaWRlbnRpZmllcnMuYWRkKGlkZW50aWZpZXIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcbn0iLCJpbXBvcnQgZm9ybWF0IGZyb20gXCIuL2Zvcm1hdC5qc1wiO1xuaW1wb3J0IHsgbW9kaWZpZXJQaGFzZXMgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbnZhciBJTlZBTElEX01PRElGSUVSX0VSUk9SID0gJ1BvcHBlcjogbW9kaWZpZXIgXCIlc1wiIHByb3ZpZGVkIGFuIGludmFsaWQgJXMgcHJvcGVydHksIGV4cGVjdGVkICVzIGJ1dCBnb3QgJXMnO1xudmFyIE1JU1NJTkdfREVQRU5ERU5DWV9FUlJPUiA9ICdQb3BwZXI6IG1vZGlmaWVyIFwiJXNcIiByZXF1aXJlcyBcIiVzXCIsIGJ1dCBcIiVzXCIgbW9kaWZpZXIgaXMgbm90IGF2YWlsYWJsZSc7XG52YXIgVkFMSURfUFJPUEVSVElFUyA9IFsnbmFtZScsICdlbmFibGVkJywgJ3BoYXNlJywgJ2ZuJywgJ2VmZmVjdCcsICdyZXF1aXJlcycsICdvcHRpb25zJ107XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB2YWxpZGF0ZU1vZGlmaWVycyhtb2RpZmllcnMpIHtcbiAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgT2JqZWN0LmtleXMobW9kaWZpZXIpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgY2FzZSAnbmFtZSc6XG4gICAgICAgICAgaWYgKHR5cGVvZiBtb2RpZmllci5uYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihmb3JtYXQoSU5WQUxJRF9NT0RJRklFUl9FUlJPUiwgU3RyaW5nKG1vZGlmaWVyLm5hbWUpLCAnXCJuYW1lXCInLCAnXCJzdHJpbmdcIicsIFwiXFxcIlwiICsgU3RyaW5nKG1vZGlmaWVyLm5hbWUpICsgXCJcXFwiXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdlbmFibGVkJzpcbiAgICAgICAgICBpZiAodHlwZW9mIG1vZGlmaWVyLmVuYWJsZWQgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihmb3JtYXQoSU5WQUxJRF9NT0RJRklFUl9FUlJPUiwgbW9kaWZpZXIubmFtZSwgJ1wiZW5hYmxlZFwiJywgJ1wiYm9vbGVhblwiJywgXCJcXFwiXCIgKyBTdHJpbmcobW9kaWZpZXIuZW5hYmxlZCkgKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdwaGFzZSc6XG4gICAgICAgICAgaWYgKG1vZGlmaWVyUGhhc2VzLmluZGV4T2YobW9kaWZpZXIucGhhc2UpIDwgMCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihmb3JtYXQoSU5WQUxJRF9NT0RJRklFUl9FUlJPUiwgbW9kaWZpZXIubmFtZSwgJ1wicGhhc2VcIicsIFwiZWl0aGVyIFwiICsgbW9kaWZpZXJQaGFzZXMuam9pbignLCAnKSwgXCJcXFwiXCIgKyBTdHJpbmcobW9kaWZpZXIucGhhc2UpICsgXCJcXFwiXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmbic6XG4gICAgICAgICAgaWYgKHR5cGVvZiBtb2RpZmllci5mbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihmb3JtYXQoSU5WQUxJRF9NT0RJRklFUl9FUlJPUiwgbW9kaWZpZXIubmFtZSwgJ1wiZm5cIicsICdcImZ1bmN0aW9uXCInLCBcIlxcXCJcIiArIFN0cmluZyhtb2RpZmllci5mbikgKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2VmZmVjdCc6XG4gICAgICAgICAgaWYgKHR5cGVvZiBtb2RpZmllci5lZmZlY3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZm9ybWF0KElOVkFMSURfTU9ESUZJRVJfRVJST1IsIG1vZGlmaWVyLm5hbWUsICdcImVmZmVjdFwiJywgJ1wiZnVuY3Rpb25cIicsIFwiXFxcIlwiICsgU3RyaW5nKG1vZGlmaWVyLmZuKSArIFwiXFxcIlwiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncmVxdWlyZXMnOlxuICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtb2RpZmllci5yZXF1aXJlcykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZm9ybWF0KElOVkFMSURfTU9ESUZJRVJfRVJST1IsIG1vZGlmaWVyLm5hbWUsICdcInJlcXVpcmVzXCInLCAnXCJhcnJheVwiJywgXCJcXFwiXCIgKyBTdHJpbmcobW9kaWZpZXIucmVxdWlyZXMpICsgXCJcXFwiXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdyZXF1aXJlc0lmRXhpc3RzJzpcbiAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobW9kaWZpZXIucmVxdWlyZXNJZkV4aXN0cykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZm9ybWF0KElOVkFMSURfTU9ESUZJRVJfRVJST1IsIG1vZGlmaWVyLm5hbWUsICdcInJlcXVpcmVzSWZFeGlzdHNcIicsICdcImFycmF5XCInLCBcIlxcXCJcIiArIFN0cmluZyhtb2RpZmllci5yZXF1aXJlc0lmRXhpc3RzKSArIFwiXFxcIlwiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnb3B0aW9ucyc6XG4gICAgICAgIGNhc2UgJ2RhdGEnOlxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIlBvcHBlckpTOiBhbiBpbnZhbGlkIHByb3BlcnR5IGhhcyBiZWVuIHByb3ZpZGVkIHRvIHRoZSBcXFwiXCIgKyBtb2RpZmllci5uYW1lICsgXCJcXFwiIG1vZGlmaWVyLCB2YWxpZCBwcm9wZXJ0aWVzIGFyZSBcIiArIFZBTElEX1BST1BFUlRJRVMubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcXFwiXCIgKyBzICsgXCJcXFwiXCI7XG4gICAgICAgICAgfSkuam9pbignLCAnKSArIFwiOyBidXQgXFxcIlwiICsga2V5ICsgXCJcXFwiIHdhcyBwcm92aWRlZC5cIik7XG4gICAgICB9XG5cbiAgICAgIG1vZGlmaWVyLnJlcXVpcmVzICYmIG1vZGlmaWVyLnJlcXVpcmVzLmZvckVhY2goZnVuY3Rpb24gKHJlcXVpcmVtZW50KSB7XG4gICAgICAgIGlmIChtb2RpZmllcnMuZmluZChmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgICAgcmV0dXJuIG1vZC5uYW1lID09PSByZXF1aXJlbWVudDtcbiAgICAgICAgfSkgPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZm9ybWF0KE1JU1NJTkdfREVQRU5ERU5DWV9FUlJPUiwgU3RyaW5nKG1vZGlmaWVyLm5hbWUpLCByZXF1aXJlbWVudCwgcmVxdWlyZW1lbnQpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHdpdGhpbihtaW4sIHZhbHVlLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4odmFsdWUsIG1heCkpO1xufSIsInZhciBDaGFuZ2VzZXQgPSByZXF1aXJlKCcuL0NoYW5nZXNldCcpXG4gICwgUmV0YWluID0gcmVxdWlyZSgnLi9vcGVyYXRpb25zL1JldGFpbicpXG4gICwgU2tpcCA9IHJlcXVpcmUoJy4vb3BlcmF0aW9ucy9Ta2lwJylcbiAgLCBJbnNlcnQgPSByZXF1aXJlKCcuL29wZXJhdGlvbnMvSW5zZXJ0JylcblxuZnVuY3Rpb24gQnVpbGRlcigpIHtcbiAgdGhpcy5vcHMgPSBbXVxuICB0aGlzLmFkZGVuZHVtID0gJydcbiAgdGhpcy5yZW1vdmVuZHVtID0gJydcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCdWlsZGVyXG5cbkJ1aWxkZXIucHJvdG90eXBlLmtlZXAgPVxuQnVpbGRlci5wcm90b3R5cGUucmV0YWluID0gZnVuY3Rpb24obGVuKSB7XG4gIHRoaXMub3BzLnB1c2gobmV3IFJldGFpbihsZW4pKVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWlsZGVyLnByb3RvdHlwZS5kZWxldGUgPVxuQnVpbGRlci5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uKHN0cikge1xuICB0aGlzLnJlbW92ZW5kdW0gKz0gc3RyXG4gIHRoaXMub3BzLnB1c2gobmV3IFNraXAoc3RyLmxlbmd0aCkpXG4gIHJldHVybiB0aGlzXG59XG5cbkJ1aWxkZXIucHJvdG90eXBlLmFkZCA9XG5CdWlsZGVyLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbihzdHIpIHtcbiAgdGhpcy5hZGRlbmR1bSArPSBzdHJcbiAgdGhpcy5vcHMucHVzaChuZXcgSW5zZXJ0KHN0ci5sZW5ndGgpKVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWlsZGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNzID0gbmV3IENoYW5nZXNldCh0aGlzLm9wcylcbiAgY3MuYWRkZW5kdW0gPSB0aGlzLmFkZGVuZHVtXG4gIGNzLnJlbW92ZW5kdW0gPSB0aGlzLnJlbW92ZW5kdW1cbiAgcmV0dXJuIGNzXG59XG4iLCIvKiFcbiAqIGNoYW5nZXNldHNcbiAqIEEgQ2hhbmdlc2V0IGxpYnJhcnkgaW5jb3Jwb3JhdGluZyBvcGVyYXRpb25hbCB0cmFuc2Zvcm1hdGlvbiAoT1QpXG4gKiBDb3B5cmlnaHQgMjAxMiBieSBNYXJjZWwgS2xlaHIgPG1rbGVockBnbXgubmV0PlxuICpcbiAqIChNSVQgTElDRU5TRSlcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyoqXG4gKiBBIHNlcXVlbmNlIG9mIGNvbnNlY3V0aXZlIG9wZXJhdGlvbnNcbiAqXG4gKiBAcGFyYW0gb3BzLi4gPE9wZXJhdGlvbj4gYWxsIHBhc3NlZCBvcGVyYXRpb25zIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGNoYW5nZXNldFxuICovXG5mdW5jdGlvbiBDaGFuZ2VzZXQob3BzLypvciBvcHMuLiovKSB7XG4gIHRoaXMuYWRkZW5kdW0gPSBcIlwiXG4gIHRoaXMucmVtb3ZlbmR1bSA9IFwiXCJcbiAgdGhpcy5pbnB1dExlbmd0aCA9IDBcbiAgdGhpcy5vdXRwdXRMZW5ndGggPSAwXG5cbiAgaWYoIUFycmF5LmlzQXJyYXkob3BzKSkgb3BzID0gYXJndW1lbnRzXG4gIGZvcih2YXIgaT0wOyBpPG9wcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMucHVzaChvcHNbaV0pXG4gICAgdGhpcy5pbnB1dExlbmd0aCArPSBvcHNbaV0uaW5wdXRcbiAgICB0aGlzLm91dHB1dExlbmd0aCArPSBvcHNbaV0ub3V0cHV0XG4gIH1cbn1cblxuLy8gVHJ1ZSBpbmhlcml0YW5jZVxuQ2hhbmdlc2V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQXJyYXkucHJvdG90eXBlLCB7XG4gIGNvbnN0cnVjdG9yOiB7XG4gICAgdmFsdWU6IENoYW5nZXNldCxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IENoYW5nZXNldFxuXG52YXIgVGV4dFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVGV4dFRyYW5zZm9ybScpXG4gICwgQ2hhbmdlc2V0VHJhbnNmb3JtID0gcmVxdWlyZSgnLi9DaGFuZ2VzZXRUcmFuc2Zvcm0nKVxuXG52YXIgUmV0YWluID0gcmVxdWlyZSgnLi9vcGVyYXRpb25zL1JldGFpbicpXG4gICwgU2tpcCA9IHJlcXVpcmUoJy4vb3BlcmF0aW9ucy9Ta2lwJylcbiAgLCBJbnNlcnQgPSByZXF1aXJlKCcuL29wZXJhdGlvbnMvSW5zZXJ0JylcblxudmFyIEJ1aWxkZXIgPSByZXF1aXJlKCcuL0J1aWxkZXInKVxuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgb3BzIHRoYXQgYXJlIHdpdGhpbiB0aGUgcGFzc2VkIHJhbmdlXG4gKiAob25seSBvcC5pbnB1dCBpcyBjb3VudGVkOyB0aHVzIG5vdCBjb3VudGluZyBpbnNlcnRzIHRvIHRoZSByYW5nZSBsZW5ndGgsIHlldCB0aGV5IGFyZSBwYXJ0IG9mIHRoZSByYW5nZSlcbiAqL1xuQ2hhbmdlc2V0LnByb3RvdHlwZS5zdWJyYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBsZW4pIHtcbiAgdmFyIHJhbmdlID0gW11cbiAgICAsIG9wLCBvcGxlblxuICAgICwgbD0wXG4gIGZvcih2YXIgaT0wLCBwb3M9MDsgaTx0aGlzLmxlbmd0aCAmJiBsIDwgbGVuOyBpKyspIHtcbiAgICBvcCA9IHRoaXNbaV1cbiAgICBpZihvcC5pbnB1dCtwb3MgPj0gc3RhcnQpIHtcbiAgICAgIGlmKG9wLmlucHV0KSB7XG4gICAgICAgIGlmKG9wLmxlbmd0aCAhPSBJbmZpbml0eSkgb3BsZW4gPSBvcC5sZW5ndGggLU1hdGgubWF4KDAsIHN0YXJ0LXBvcykgLU1hdGgubWF4KDAsIChvcC5sZW5ndGgrcG9zKS0oc3RhcnQrbGVuKSlcbiAgICAgICAgZWxzZSBvcGxlbiA9IGxlblxuICAgICAgICBpZiAob3BsZW4gIT09IDApIHJhbmdlLnB1c2goIG9wLmRlcml2ZShvcGxlbikgKSAvLyAoRG9uJ3QgY29weSBvdmVyIG1vcmUgdGhhbiBsZW4gcGFyYW0gYWxsb3dzKVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJhbmdlLnB1c2goIG9wLmRlcml2ZShvcC5sZW5ndGgpIClcbiAgICAgICAgb3BsZW4gPSAwXG4gICAgICB9XG4gICAgICBsICs9IG9wbGVuXG4gICAgfVxuICAgIHBvcyArPSBvcC5pbnB1dFxuICB9XG4gIHJldHVybiByYW5nZVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBjaGFuZ2VzZXRzICh0aGF0IGFyZSBiYXNlZCBvbiB0aGUgc2FtZSBzdGF0ZSEpIHNvIHRoYXQgdGhlIHJlc3VsdGluZyBjaGFuZ3Nlc2V0XG4gKiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzIGJvdGggb3JpZ25hbCBvbmVzIGFwcGxpZWQgb25lIGFmdGVyIHRoZSBvdGhlclxuICpcbiAqIEBwYXJhbSBvdGhlckNzIDxDaGFuZ2VzZXQ+XG4gKiBAcGFyYW0gbGVmdCA8Ym9vbGVhbj4gV2hpY2ggb3AgdG8gY2hvb3NlIGlmIHRoZXJlJ3MgYW4gaW5zZXJ0IHRpZSAoSWYgeW91IHVzZSB0aGlzIGZ1bmN0aW9uIGluIGEgZGlzdHJpYnV0ZWQsIHN5bmNocm9ub3VzIGVudmlyb25tZW50LCBiZSBzdXJlIHRvIGludmVydCB0aGlzIHBhcmFtIG9uIHRoZSBvdGhlciBzaXRlLCBvdGhlcndpc2UgaXQgY2FuIGJlIG9taXR0ZWQgc2FmZWx5KSlcbiAqIEByZXR1cm5zIDxDaGFuZ2VzZXQ+XG4gKi9cbkNoYW5nZXNldC5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbihvdGhlckNzLCBsZWZ0KSB7XG4gIGlmKCEob3RoZXJDcyBpbnN0YW5jZW9mIENoYW5nZXNldCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSAjPENoYW5nZXNldD4sIGJ1dCByZWNlaXZlZCAnK290aGVyQ3MuX19wcm90b19fLmNvbnN0cnVjdG9yLm5hbWUpXG4gIH1cblxuICBpZihvdGhlckNzLmlucHV0TGVuZ3RoICE9PSB0aGlzLm91dHB1dExlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNoYW5nZXNldCBsZW5ndGhzIGZvciBtZXJnaW5nIGRvbid0IG1hdGNoISBJbnB1dCBsZW5ndGggb2YgeW91bmdlciBjczogXCIrb3RoZXJDcy5pbnB1dExlbmd0aCsnLCBvdXRwdXQgbGVuZ3RoIG9mIG9sZGVyIGNzOicrdGhpcy5vdXRwdXRMZW5ndGgpXG4gIH1cblxuICB2YXIgbmV3b3BzID0gW11cbiAgICAsIGFkZFB0cjEgPSAwXG4gICAgLCByZW1QdHIxID0gMFxuICAgICwgYWRkUHRyMiA9IDBcbiAgICAsIHJlbVB0cjIgPSAwXG4gICAgLCBuZXdhZGRlbmR1bSA9ICcnXG4gICAgLCBuZXdyZW1vdmVuZHVtID0gJydcblxuICB6aXAodGhpcywgb3RoZXJDcywgZnVuY3Rpb24ob3AxLCBvcDIpIHtcbiAgICAvLyBjb25zb2xlLmxvZyhuZXdvcHMpXG4gICAgLy8gY29uc29sZS5sb2cob3AxLCBvcDIpXG5cbiAgICAvLyBJJ20gZGVsZXRpbmcgc29tZXRoaW5nIC0tIHRoZSBvdGhlciBjcyBjYW4ndCBrbm93IHRoYXQsIHNvIGp1c3Qgb3ZlcnRha2UgbXkgb3BcbiAgICBpZihvcDEgJiYgIW9wMS5vdXRwdXQpIHtcbiAgICAgIG5ld29wcy5wdXNoKG9wMS5tZXJnZSgpLmNsb25lKCkpXG4gICAgICBuZXdyZW1vdmVuZHVtICs9IHRoaXMucmVtb3ZlbmR1bS5zdWJzdHIocmVtUHRyMSwgb3AxLmxlbmd0aCkgLy8gb3ZlcnRha2UgYWRkZWQgY2hhcnNcbiAgICAgIHJlbVB0cjEgKz0gb3AxLmxlbmd0aFxuICAgICAgb3AxLmxlbmd0aCA9IDAgLy8gZG9uJ3QgZ2ltbWUgdGhhdCBvbmUgYWdhaW4uXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBvcDIgaXMgYW4gaW5zZXJ0XG4gICAgaWYob3AyICYmICFvcDIuaW5wdXQpIHtcbiAgICAgIG5ld29wcy5wdXNoKG9wMi5tZXJnZSgpLmNsb25lKCkpXG4gICAgICBuZXdhZGRlbmR1bSArPSBvdGhlckNzLmFkZGVuZHVtLnN1YnN0cihhZGRQdHIyLCBvcDIubGVuZ3RoKSAvLyBvdmVydGFrZSBhZGRlZCBjaGFyc1xuICAgICAgYWRkUHRyMiArPSBvcDIubGVuZ3RoXG4gICAgICBvcDIubGVuZ3RoID0gMCAvLyBkb24ndCBnaW1tZSB0aGF0IG9uZSBhZ2Fpbi5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIG9wMiBpcyBlaXRoZXIgYSByZXRhaW4gb3IgYSBza2lwXG4gICAgaWYob3AyICYmIG9wMi5pbnB1dCAmJiBvcDEpIHtcbiAgICAgIC8vIG9wMiByZXRhaW5zIHdoYXRldmVyIHdlIGRvIGhlcmUgKHJldGFpbiBvciBpbnNlcnQpLCBzbyBqdXN0IGNsb25lIG15IG9wXG4gICAgICBpZihvcDIub3V0cHV0KSB7XG4gICAgICAgIG5ld29wcy5wdXNoKG9wMS5tZXJnZShvcDIpLmNsb25lKCkpXG4gICAgICAgIGlmKCFvcDEuaW5wdXQpIHsgLy8gb3ZlcnRha2UgYWRkZW5kdW1cbiAgICAgICAgICBuZXdhZGRlbmR1bSArPSB0aGlzLmFkZGVuZHVtLnN1YnN0cihhZGRQdHIxLCBvcDEubGVuZ3RoKVxuICAgICAgICAgIGFkZFB0cjEgKz0gb3AxLmxlbmd0aFxuICAgICAgICB9XG4gICAgICAgIG9wMS5sZW5ndGggPSAwIC8vIGRvbid0IGdpbW1lIHRoZXNlIGFnYWluXG4gICAgICAgIG9wMi5sZW5ndGggPSAwXG4gICAgICB9ZWxzZVxuXG4gICAgICAvLyBvcDIgZGVsZXRlcyBteSByZXRhaW4gaGVyZSwgc28ganVzdCBjbG9uZSB0aGUgZGVsZXRlXG4gICAgICAvLyAob3AxIGNhbiBvbmx5IGJlIGEgcmV0YWluIGFuZCBubyBza2lwIGhlcmUsIGNhdXNlIHdlJ3ZlIGhhbmRsZWQgc2tpcHMgYWJvdmUgYWxyZWFkeSlcbiAgICAgIGlmKCFvcDIub3V0cHV0ICYmIG9wMS5pbnB1dCkge1xuICAgICAgICBuZXdvcHMucHVzaChvcDIubWVyZ2Uob3AxKS5jbG9uZSgpKVxuICAgICAgICBuZXdyZW1vdmVuZHVtICs9IG90aGVyQ3MucmVtb3ZlbmR1bS5zdWJzdHIocmVtUHRyMiwgb3AyLmxlbmd0aCkgLy8gb3ZlcnRha2UgYWRkZWQgY2hhcnNcbiAgICAgICAgcmVtUHRyMiArPSBvcDIubGVuZ3RoXG4gICAgICAgIG9wMS5sZW5ndGggPSAwIC8vIGRvbid0IGdpbW1lIHRoZXNlIGFnYWluXG4gICAgICAgIG9wMi5sZW5ndGggPSAwXG4gICAgICB9ZWxzZVxuXG4gICAgICAvL290aGVyQ3MgZGVsZXRlcyBzb21ldGhpbmcgSSBhZGRlZCAoLTEpICsxID0gMFxuICAgICAge1xuICAgICAgICBhZGRQdHIxICs9IG9wMS5sZW5ndGhcbiAgICAgICAgb3AxLmxlbmd0aCA9IDAgLy8gZG9uJ3QgZ2ltbWUgdGhlc2UgYWdhaW5cbiAgICAgICAgb3AyLmxlbmd0aCA9IDBcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCdvb3BzJywgYXJndW1lbnRzKVxuICAgIHRocm93IG5ldyBFcnJvcignb29wcy4gVGhpcyBjYXNlIGhhc25cXCd0IGJlZW4gY29uc2lkZXJlZCBieSB0aGUgZGV2ZWxvcGVyIChlcnJvciBjb2RlOiBQQkNBQyknKVxuICB9LmJpbmQodGhpcykpXG5cbiAgdmFyIG5ld0NzID0gbmV3IENoYW5nZXNldChuZXdvcHMpXG4gIG5ld0NzLmFkZGVuZHVtID0gbmV3YWRkZW5kdW1cbiAgbmV3Q3MucmVtb3ZlbmR1bSA9IG5ld3JlbW92ZW5kdW1cblxuICByZXR1cm4gbmV3Q3Ncbn1cblxuLyoqXG4gKiBBIHByaXZhdGUgYW5kIHF1aXRlIGhhbmR5IGZ1bmN0aW9uIHRoYXQgc2xpY2VzIG9wcyBpbnRvIGVxdWFsbHkgbG9uZyBwaWVjZXMgYW5kIGFwcGxpZXMgdGhlbSBvbiBhIG1hcHBpbmcgZnVuY3Rpb25cbiAqIHRoYXQgY2FuIGRldGVybWluZSB0aGUgaXRlcmF0aW9uIHN0ZXBzIGJ5IHNldHRpbmcgb3AubGVuZ3RoIHRvIDAgb24gYW4gb3AgKGVxdWFscyB1c2luZyAubmV4dCgpIGluIGEgdXN1YWwgaXRlcmF0b3IpXG4gKi9cbmZ1bmN0aW9uIHppcChjczEsIGNzMiwgZnVuYykge1xuICB2YXIgb3BzdGFjazEgPSBjczEubWFwKGZ1bmN0aW9uKG9wKSB7cmV0dXJuIG9wLmNsb25lKCl9KSAvLyBjb3B5IG9wc1xuICAgICwgb3BzdGFjazIgPSBjczIubWFwKGZ1bmN0aW9uKG9wKSB7cmV0dXJuIG9wLmNsb25lKCl9KVxuXG4gIHZhciBvcDIsIG9wMVxuICB3aGlsZShvcHN0YWNrMS5sZW5ndGggfHwgb3BzdGFjazIubGVuZ3RoKSB7Ly8gaXRlcmF0ZSB0aHJvdWdoIGFsbCBvdXRzdGFuZGluZyBvcHMgb2YgdGhpcyBjc1xuICAgIG9wMSA9IG9wc3RhY2sxWzBdPyBvcHN0YWNrMVswXS5jbG9uZSgpIDogbnVsbFxuICAgIG9wMiA9IG9wc3RhY2syWzBdPyBvcHN0YWNrMlswXS5jbG9uZSgpIDogbnVsbFxuXG4gICAgaWYob3AxKSB7XG4gICAgICBpZihvcDIpIG9wMSA9IG9wMS5kZXJpdmUoTWF0aC5taW4ob3AxLmxlbmd0aCwgb3AyLmxlbmd0aCkpIC8vIHNsaWNlICdlbSBpbnRvIGVxdWFsbHkgbG9uZyBwaWVjZXNcbiAgICAgIGlmKG9wc3RhY2sxWzBdLmxlbmd0aCA+IG9wMS5sZW5ndGgpIG9wc3RhY2sxWzBdID0gb3BzdGFjazFbMF0uZGVyaXZlKG9wc3RhY2sxWzBdLmxlbmd0aC1vcDEubGVuZ3RoKVxuICAgICAgZWxzZSBvcHN0YWNrMS5zaGlmdCgpXG4gICAgfVxuXG4gICAgaWYob3AyKSB7XG4gICAgICBpZihvcDEpIG9wMiA9IG9wMi5kZXJpdmUoTWF0aC5taW4ob3AxLmxlbmd0aCwgb3AyLmxlbmd0aCkpIC8vIHNsaWNlICdlbSBpbnRvIGVxdWFsbHkgbG9uZyBwaWVjZXNcbiAgICAgIGlmKG9wc3RhY2syWzBdLmxlbmd0aCA+IG9wMi5sZW5ndGgpIG9wc3RhY2syWzBdID0gb3BzdGFjazJbMF0uZGVyaXZlKG9wc3RhY2syWzBdLmxlbmd0aC1vcDIubGVuZ3RoKVxuICAgICAgZWxzZSBvcHN0YWNrMi5zaGlmdCgpXG4gICAgfVxuXG4gICAgZnVuYyhvcDEsIG9wMilcblxuICAgIGlmKG9wMSAmJiBvcDEubGVuZ3RoKSBvcHN0YWNrMS51bnNoaWZ0KG9wMSlcbiAgICBpZihvcDIgJiYgb3AyLmxlbmd0aCkgb3BzdGFjazIudW5zaGlmdChvcDIpXG4gIH1cbn1cblxuLyoqXG4gKiBJbmNsdXNpb24gVHJhbnNmb3JtYXRpb24gKElUKSBvciBGb3J3YXJkIFRyYW5zZm9ybWF0aW9uXG4gKlxuICogdHJhbnNmb3JtcyB0aGUgb3BlcmF0aW9ucyBvZiB0aGUgY3VycmVudCBjaGFuZ2VzZXQgYWdhaW5zdCB0aGVcbiAqIGFsbCBvcGVyYXRpb25zIGluIGFub3RoZXIgY2hhbmdlc2V0IGluIHN1Y2ggYSB3YXkgdGhhdCB0aGVcbiAqIGVmZmVjdHMgb2YgdGhlIGxhdHRlciBhcmUgZWZmZWN0aXZlbHkgaW5jbHVkZWQuXG4gKiBUaGlzIGlzIGJhc2ljYWxseSBsaWtlIGEgYXBwbHlpbmcgdGhlIG90aGVyIGNzIG9uIHRoaXMgb25lLlxuICpcbiAqIEBwYXJhbSBvdGhlckNzIDxDaGFuZ2VzZXQ+XG4gKiBAcGFyYW0gbGVmdCA8Ym9vbGVhbj4gV2hpY2ggb3AgdG8gY2hvb3NlIGlmIHRoZXJlJ3MgYW4gaW5zZXJ0IHRpZSAoSWYgeW91IHVzZSB0aGlzIGZ1bmN0aW9uIGluIGEgZGlzdHJpYnV0ZWQsIHN5bmNocm9ub3VzIGVudmlyb25tZW50LCBiZSBzdXJlIHRvIGludmVydCB0aGlzIHBhcmFtIG9uIHRoZSBvdGhlciBzaXRlLCBvdGhlcndpc2UgaXQgY2FuIGJlIG9taXR0ZWQgc2FmZWx5KVxuICpcbiAqIEByZXR1cm5zIDxDaGFuZ2VzZXQ+XG4gKi9cbkNoYW5nZXNldC5wcm90b3R5cGUudHJhbnNmb3JtQWdhaW5zdCA9IGZ1bmN0aW9uKG90aGVyQ3MsIGxlZnQpIHtcbiAgaWYoIShvdGhlckNzIGluc3RhbmNlb2YgQ2hhbmdlc2V0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQXJndW1lbnQgdG8gQ2hhbmdlc2V0I3RyYW5zZm9ybUFnYWluc3QgbXVzdCBiZSBhICM8Q2hhbmdlc2V0PiwgYnV0IHJlY2VpdmVkICcrb3RoZXJDcy5fX3Byb3RvX18uY29uc3RydWN0b3IubmFtZSlcbiAgfVxuXG4gIGlmKHRoaXMuaW5wdXRMZW5ndGggIT0gb3RoZXJDcy5pbnB1dExlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCB0cmFuc2Zvcm0gY2hhbmdlc2V0cyB3aXRoIGRpZmZlcmluZyBpbnB1dExlbmd0aDogJyt0aGlzLmlucHV0TGVuZ3RoKycgYW5kICcrb3RoZXJDcy5pbnB1dExlbmd0aClcbiAgfVxuXG4gIHZhciB0cmFuc2Zvcm1hdGlvbiA9IG5ldyBDaGFuZ2VzZXRUcmFuc2Zvcm0odGhpcywgW25ldyBSZXRhaW4oSW5maW5pdHkpXSlcbiAgb3RoZXJDcy5mb3JFYWNoKGZ1bmN0aW9uKG9wKSB7XG4gICAgdmFyIG5leHRPcCA9IHRoaXMuc3VicmFuZ2UodHJhbnNmb3JtYXRpb24ucG9zLCBJbmZpbml0eSlbMF0gLy8gbmV4dCBvcCBvZiB0aGlzIGNzXG4gICAgaWYobmV4dE9wICYmICFuZXh0T3AuaW5wdXQgJiYgIW9wLmlucHV0KSB7IC8vIHR3byBpbnNlcnRzIHRpZWQ7IGxlZnQgYnJlYWtzIGl0XG4gICAgICBpZiAobGVmdCkgdHJhbnNmb3JtYXRpb24ud3JpdGVPdXRwdXQodHJhbnNmb3JtYXRpb24ucmVhZElucHV0KG5leHRPcC5sZW5ndGgpKVxuICAgIH1cbiAgICBvcC5hcHBseSh0cmFuc2Zvcm1hdGlvbilcbiAgfS5iaW5kKHRoaXMpKVxuXG4gIHJldHVybiB0cmFuc2Zvcm1hdGlvbi5yZXN1bHQoKVxufVxuXG4vKipcbiAqIEV4Y2x1c2lvbiBUcmFuc2Zvcm1hdGlvbiAoRVQpIG9yIEJhY2t3YXJkcyBUcmFuc2Zvcm1hdGlvblxuICpcbiAqIHRyYW5zZm9ybXMgYWxsIG9wZXJhdGlvbnMgaW4gdGhlIGN1cnJlbnQgY2hhbmdlc2V0IGFnYWluc3QgdGhlIG9wZXJhdGlvbnNcbiAqIGluIGFub3RoZXIgY2hhbmdlc2V0IGluIHN1Y2ggYSB3YXkgdGhhdCB0aGUgaW1wYWN0IG9mIHRoZSBsYXR0ZXIgYXJlIGVmZmVjdGl2ZWx5IGV4Y2x1ZGVkXG4gKlxuICogQHBhcmFtIGNoYW5nZXNldCA8Q2hhbmdlc2V0PiB0aGUgY2hhbmdlc2V0IHRvIHN1YnN0cmFjdCBmcm9tIHRoaXMgb25lXG4gKiBAcGFyYW0gbGVmdCA8Ym9vbGVhbj4gV2hpY2ggb3AgdG8gY2hvb3NlIGlmIHRoZXJlJ3MgYW4gaW5zZXJ0IHRpZSAoSWYgeW91IHVzZSB0aGlzIGZ1bmN0aW9uIGluIGEgZGlzdHJpYnV0ZWQsIHN5bmNocm9ub3VzIGVudmlyb25tZW50LCBiZSBzdXJlIHRvIGludmVydCB0aGlzIHBhcmFtIG9uIHRoZSBvdGhlciBzaXRlLCBvdGhlcndpc2UgaXQgY2FuIGJlIG9taXR0ZWQgc2FmZWx5KVxuICogQHJldHVybnMgPENoYW5nZXNldD5cbiAqL1xuQ2hhbmdlc2V0LnByb3RvdHlwZS5zdWJzdHJhY3QgPSBmdW5jdGlvbihjaGFuZ2VzZXQsIGxlZnQpIHtcbiAgLy8gVGhlIGN1cnJlbnQgb3BlcmF0aW9ucyBhc3N1bWUgdGhhdCB0aGUgY2hhbmdlcyBpblxuICAvLyBgY2hhbmdlc2V0YCBoYXBwZW5lZCBiZWZvcmUsIHNvIGZvciBlYWNoIG9mIHRob3NlIG9wc1xuICAvLyB3ZSBjcmVhdGUgYW4gb3BlcmF0aW9uIHRoYXQgdW5kb2VzIGl0cyBlZmZlY3QgYW5kXG4gIC8vIHRyYW5zZm9ybSBhbGwgb3VyIG9wZXJhdGlvbnMgb24gdG9wIG9mIHRoZSBpbnZlcnNlIGNoYW5nZXNcbiAgcmV0dXJuIHRoaXMudHJhbnNmb3JtQWdhaW5zdChjaGFuZ2VzZXQuaW52ZXJ0KCksIGxlZnQpXG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBDaGFuZ2VzZXQgb2YgdGhlIGN1cnJlbnQgb25lXG4gKlxuICogQ2hhbmdlc2V0LmludmVydCgpLmFwcGx5KENoYW5nZXNldC5hcHBseShkb2N1bWVudCkpID09IGRvY3VtZW50XG4gKi9cbkNoYW5nZXNldC5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24oKSB7XG4gIC8vIGludmVydCBhbGwgb3BzXG4gIHZhciBuZXdDcyA9IG5ldyBDaGFuZ2VzZXQodGhpcy5tYXAoZnVuY3Rpb24ob3ApIHtcbiAgICByZXR1cm4gb3AuaW52ZXJ0KClcbiAgfSkpXG5cbiAgLy8gcmVtb3ZlbmR1bSBiZWNvbWVzIGFkZGVuZHVtIGFuZCB2aWNlIHZlcnNhXG4gIG5ld0NzLmFkZGVuZHVtID0gdGhpcy5yZW1vdmVuZHVtXG4gIG5ld0NzLnJlbW92ZW5kdW0gPSB0aGlzLmFkZGVuZHVtXG5cbiAgcmV0dXJuIG5ld0NzXG59XG5cbi8qKlxuICogQXBwbGllcyB0aGlzIGNoYW5nZXNldCBvbiBhIHRleHRcbiAqL1xuQ2hhbmdlc2V0LnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIC8vIHByZS1yZXF1aXNpdGVzXG4gIGlmKGlucHV0Lmxlbmd0aCAhPSB0aGlzLmlucHV0TGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGxlbmd0aCBkb2VzblxcJ3QgbWF0Y2ggZXhwZWN0ZWQgbGVuZ3RoLiBleHBlY3RlZDogJyt0aGlzLmlucHV0TGVuZ3RoKyc7IGFjdHVhbDogJytpbnB1dC5sZW5ndGgpXG5cbiAgdmFyIG9wZXJhdGlvbiA9IG5ldyBUZXh0VHJhbnNmb3JtKGlucHV0LCB0aGlzLmFkZGVuZHVtLCB0aGlzLnJlbW92ZW5kdW0pXG5cbiAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKG9wKSB7XG4gICAgLy8gZWFjaCBPcGVyYXRpb24gaGFzIGFjY2VzcyB0byBhbGwgcG9pbnRlcnMgYXMgd2VsbCBhcyB0aGUgaW5wdXQsIGFkZGVuZHVtIGFuZCByZW1vdmVuZHVtICh0aGUgbGF0dGVyIGFyZSBpbW11dGFibGUpXG4gICAgb3AuYXBwbHkob3BlcmF0aW9uKVxuICB9LmJpbmQodGhpcykpXG5cbiAgcmV0dXJuIG9wZXJhdGlvbi5yZXN1bHQoKVxufVxuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2Ygc3RyaW5ncyBkZXNjcmliaW5nIHRoaXMgY2hhbmdlc2V0J3Mgb3BlcmF0aW9uc1xuICovXG5DaGFuZ2VzZXQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGogPSAwXG4gIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihvcCkge1xuICAgIHZhciBzdHJpbmcgPSAnJ1xuXG4gICAgaWYoIW9wLmlucHV0KSB7IC8vIGlmIEluc2VydFxuICAgICAgc3RyaW5nID0gdGhpcy5hZGRlbmR1bS5zdWJzdHIoaixvcC5sZW5ndGgpXG4gICAgICBqICs9IG9wLmxlbmd0aFxuICAgICAgcmV0dXJuIHN0cmluZ1xuICAgIH1cblxuICAgIGZvcih2YXIgaT0wOyBpPG9wLmxlbmd0aDsgaSsrKSBzdHJpbmcgKz0gb3Auc3ltYm9sXG4gICAgcmV0dXJuIHN0cmluZ1xuICB9LmJpbmQodGhpcykpLmpvaW4oJycpXG59XG5cbi8qKlxuICogU2VyaWFsaXplcyB0aGUgZ2l2ZW4gY2hhbmdlc2V0IGluIG9yZGVyIHRvIHJldHVybiBhIChob3BlZnVsbHkpIG1vcmUgY29tcGFjdCByZXByZXNlbnRhdGlvblxuICogdGhhbiBqc29uIHRoYXQgY2FuIGJlIHNlbnQgdGhyb3VnaCBhIG5ldHdvcmsgb3Igc3RvcmVkIGluIGEgZGF0YWJhc2VcbiAqXG4gKiBOdW1iZXJzIGFyZSBjb252ZXJ0ZWQgdG8gdGhlIGJhc2UgMzYsIHVuc2FmZSBjaGFycyBpbiB0aGUgdGV4dCBhcmUgdXJsZW5jb2RlZFxuICpcbiAqIEBwYXJhbSBjcyA8Q2hhbmdlc2V0PiBUaGUgY2hhbmdlc2V0IHRvIGJlIHNlcmlhbGl6ZWRcbiAqIEByZXR1cm5zIDxTdHJpbmc+IFRoZSBzZXJpYWxpemVkIGNoYW5nZXNldFxuICovXG5DaGFuZ2VzZXQucHJvdG90eXBlLnBhY2sgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBhY2tlZCA9IHRoaXMubWFwKGZ1bmN0aW9uKG9wKSB7XG4gICAgcmV0dXJuIG9wLnBhY2soKVxuICB9KS5qb2luKCcnKVxuXG4gIHZhciBhZGRlbmR1bSA9IHRoaXMuYWRkZW5kdW0ucmVwbGFjZSgvJS9nLCAnJTI1JykucmVwbGFjZSgvXFx8L2csICclN0MnKVxuICAgICwgcmVtb3ZlbmR1bSA9IHRoaXMucmVtb3ZlbmR1bS5yZXBsYWNlKC8lL2csICclMjUnKS5yZXBsYWNlKC9cXHwvZywgJyU3QycpXG4gIHJldHVybiBwYWNrZWQrJ3wnK2FkZGVuZHVtKyd8JytyZW1vdmVuZHVtXG59XG5DaGFuZ2VzZXQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnBhY2soKVxufVxuXG4vKipcbiAqIFVuc2VyaWFsaXplcyB0aGUgb3V0cHV0IG9mIGNzLnRleHQuQ2hhbmdlc2V0I3RvU3RyaW5nKClcbiAqXG4gKiBAcGFyYW0gcGFja2VkIDxTdHJpbmc+IFRoZSBzZXJpYWxpemVkIGNoYW5nZXNldFxuICogQHBhcmFtIDxjcy5DaGFuZ2VzZXQ+XG4gKi9cbkNoYW5nZXNldC51bnBhY2sgPSBmdW5jdGlvbihwYWNrZWQpIHtcbiAgaWYocGFja2VkID09ICcnKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1bnBhY2sgZnJvbSBlbXB0eSBzdHJpbmcnKVxuICB2YXIgY29tcG9uZW50cyA9IHBhY2tlZC5zcGxpdCgnfCcpXG4gICAgLCBvcHN0cmluZyA9IGNvbXBvbmVudHNbMF1cbiAgICAsIGFkZGVuZHVtID0gY29tcG9uZW50c1sxXS5yZXBsYWNlKC8lN2MvZ2ksICd8JykucmVwbGFjZSgvJTI1L2csICclJylcbiAgICAsIHJlbW92ZW5kdW0gPSBjb21wb25lbnRzWzJdLnJlcGxhY2UoLyU3Yy9naSwgJ3wnKS5yZXBsYWNlKC8lMjUvZywgJyUnKVxuXG4gIHZhciBtYXRjaGVzID0gb3BzdHJpbmcubWF0Y2goL1s9Ky1dKFtePSstXSkrL2cpXG4gIGlmKCFtYXRjaGVzKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1bnBhY2sgaW52YWxpZGx5IHNlcmlhbGl6ZWQgb3Agc3RyaW5nJylcblxuICB2YXIgb3BzID0gW11cbiAgbWF0Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uKHMpIHtcbiAgICB2YXIgc3ltYm9sID0gcy5zdWJzdHIoMCwxKVxuICAgICAgLCBkYXRhID0gcy5zdWJzdHIoMSlcbiAgICBpZihTa2lwLnByb3RvdHlwZS5zeW1ib2wgPT0gc3ltYm9sKSByZXR1cm4gb3BzLnB1c2goU2tpcC51bnBhY2soZGF0YSkpXG4gICAgaWYoSW5zZXJ0LnByb3RvdHlwZS5zeW1ib2wgPT0gc3ltYm9sKSByZXR1cm4gb3BzLnB1c2goSW5zZXJ0LnVucGFjayhkYXRhKSlcbiAgICBpZihSZXRhaW4ucHJvdG90eXBlLnN5bWJvbCA9PSBzeW1ib2wpIHJldHVybiBvcHMucHVzaChSZXRhaW4udW5wYWNrKGRhdGEpKVxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjaGFuZ2VzZXQgcmVwcmVzZW50YXRpb24gcGFzc2VkIHRvIENoYW5nZXNldC51bnBhY2snKVxuICB9KVxuXG4gIHZhciBjcyA9IG5ldyBDaGFuZ2VzZXQob3BzKVxuICBjcy5hZGRlbmR1bSA9IGFkZGVuZHVtXG4gIGNzLnJlbW92ZW5kdW0gPSByZW1vdmVuZHVtXG5cbiAgcmV0dXJuIGNzXG59XG5cbkNoYW5nZXNldC5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBCdWlsZGVyXG59XG5cbi8qKlxuICogUmV0dXJucyBhIENoYW5nZXNldCBjb250YWluaW5nIHRoZSBvcGVyYXRpb25zIG5lZWRlZCB0byB0cmFuc2Zvcm0gdGV4dDEgaW50byB0ZXh0MlxuICpcbiAqIEBwYXJhbSB0ZXh0MSA8U3RyaW5nPlxuICogQHBhcmFtIHRleHQyIDxTdHJpbmc+XG4gKi9cbkNoYW5nZXNldC5mcm9tRGlmZiA9IGZ1bmN0aW9uKGRpZmYpIHtcbiAgLyoqXG4gICAqIFRoZSBkYXRhIHN0cnVjdHVyZSByZXByZXNlbnRpbmcgYSBkaWZmIGlzIGFuIGFycmF5IG9mIHR1cGxlczpcbiAgICogW1tESUZGX0RFTEVURSwgJ0hlbGxvJ10sIFtESUZGX0lOU0VSVCwgJ0dvb2RieWUnXSwgW0RJRkZfRVFVQUwsICcgd29ybGQuJ11dXG4gICAqIHdoaWNoIG1lYW5zOiBkZWxldGUgJ0hlbGxvJywgYWRkICdHb29kYnllJyBhbmQga2VlcCAnIHdvcmxkLidcbiAgICovXG4gIHZhciBESUZGX0RFTEVURSA9IC0xO1xuICB2YXIgRElGRl9JTlNFUlQgPSAxO1xuICB2YXIgRElGRl9FUVVBTCA9IDA7XG5cbiAgdmFyIG9wcyA9IFtdXG4gICAgLCByZW1vdmVuZHVtID0gJydcbiAgICAsIGFkZGVuZHVtID0gJydcblxuICBkaWZmLmZvckVhY2goZnVuY3Rpb24oZCkge1xuICAgIGlmIChESUZGX0RFTEVURSA9PSBkWzBdKSB7XG4gICAgICBvcHMucHVzaChuZXcgU2tpcChkWzFdLmxlbmd0aCkpXG4gICAgICByZW1vdmVuZHVtICs9IGRbMV1cbiAgICB9XG5cbiAgICBpZiAoRElGRl9JTlNFUlQgPT0gZFswXSkge1xuICAgICAgb3BzLnB1c2gobmV3IEluc2VydChkWzFdLmxlbmd0aCkpXG4gICAgICBhZGRlbmR1bSArPSBkWzFdXG4gICAgfVxuXG4gICAgaWYoRElGRl9FUVVBTCA9PSBkWzBdKSB7XG4gICAgICBvcHMucHVzaChuZXcgUmV0YWluKGRbMV0ubGVuZ3RoKSlcbiAgICB9XG4gIH0pXG5cbiAgdmFyIGNzID0gbmV3IENoYW5nZXNldChvcHMpXG4gIGNzLmFkZGVuZHVtID0gYWRkZW5kdW1cbiAgY3MucmVtb3ZlbmR1bSA9IHJlbW92ZW5kdW1cbiAgcmV0dXJuIGNzXG59XG4iLCIvKiFcbiAqIGNoYW5nZXNldHNcbiAqIEEgQ2hhbmdlc2V0IGxpYnJhcnkgaW5jb3Jwb3JhdGluZyBvcGVyYXRpb25hbCBDaGFuZ2VzZXRUcmFuc2Zvcm0gKE9UKVxuICogQ29weXJpZ2h0IDIwMTIgYnkgTWFyY2VsIEtsZWhyIDxta2xlaHJAZ214Lm5ldD5cbiAqXG4gKiAoTUlUIExJQ0VOU0UpXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbnZhciBSZXRhaW4gPSByZXF1aXJlKCcuL29wZXJhdGlvbnMvUmV0YWluJylcbiAgLCBTa2lwID0gcmVxdWlyZSgnLi9vcGVyYXRpb25zL1NraXAnKVxuICAsIEluc2VydCA9IHJlcXVpcmUoJy4vb3BlcmF0aW9ucy9JbnNlcnQnKVxuICAsIENoYW5nZXNldCA9IHJlcXVpcmUoJy4vQ2hhbmdlc2V0JylcblxuXG5mdW5jdGlvbiBDaGFuZ2VzZXRUcmFuc2Zvcm0oaW5wdXRDcywgYWRkZW5kdW0pIHtcbiAgdGhpcy5vdXRwdXQgPSBbXVxuICB0aGlzLmFkZGVuZHVtID0gYWRkZW5kdW1cbiAgdGhpcy5uZXdSZW1vdmVuZHVtID0gJydcbiAgdGhpcy5uZXdBZGRlbmR1bSA9ICcnXG5cbiAgdGhpcy5jcyA9IGlucHV0Q3NcbiAgdGhpcy5wb3MgPSAwXG4gIHRoaXMuYWRkZW5kdW1Qb2ludGVyID0gMFxuICB0aGlzLnJlbW92ZW5kdW1Qb2ludGVyID0gMFxufVxubW9kdWxlLmV4cG9ydHMgPSBDaGFuZ2VzZXRUcmFuc2Zvcm1cblxuQ2hhbmdlc2V0VHJhbnNmb3JtLnByb3RvdHlwZS5yZWFkSW5wdXQgPSBmdW5jdGlvbiAobGVuKSB7XG4gIHZhciByZXQgPSB0aGlzLmNzLnN1YnJhbmdlKHRoaXMucG9zLCBsZW4pXG4gIHRoaXMucG9zICs9IGxlblxuICByZXR1cm4gcmV0XG59XG5cbkNoYW5nZXNldFRyYW5zZm9ybS5wcm90b3R5cGUucmVhZEFkZGVuZHVtID0gZnVuY3Rpb24gKGxlbikge1xuICAvL3JldHVybiBbbmV3IFJldGFpbihsZW4pXVxuICB2YXIgcmV0ID0gdGhpcy5zdWJyYW5nZSh0aGlzLmFkZGVuZHVtLCB0aGlzLmFkZGVuZHVtUG9pbnRlciwgbGVuKVxuICB0aGlzLmFkZGVuZHVtUG9pbnRlciArPSBsZW5cbiAgcmV0dXJuIHJldFxufVxuXG5DaGFuZ2VzZXRUcmFuc2Zvcm0ucHJvdG90eXBlLndyaXRlUmVtb3ZlbmR1bSA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICByYW5nZVxuICAgIC5maWx0ZXIoZnVuY3Rpb24ob3ApIHtyZXR1cm4gIW9wLm91dHB1dH0pXG4gICAgLmZvckVhY2goZnVuY3Rpb24ob3ApIHtcbiAgICAgIHRoaXMucmVtb3ZlbmR1bVBvaW50ZXIgKz0gb3AubGVuZ3RoXG4gICAgfS5iaW5kKHRoaXMpKVxufVxuXG5DaGFuZ2VzZXRUcmFuc2Zvcm0ucHJvdG90eXBlLndyaXRlT3V0cHV0ID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gIHRoaXMub3V0cHV0ID0gdGhpcy5vdXRwdXQuY29uY2F0KHJhbmdlKVxuICByYW5nZVxuICAgIC5maWx0ZXIoZnVuY3Rpb24ob3ApIHtyZXR1cm4gIW9wLm91dHB1dH0pXG4gICAgLmZvckVhY2goZnVuY3Rpb24ob3ApIHtcbiAgICAgIHRoaXMubmV3UmVtb3ZlbmR1bSArPSB0aGlzLmNzLnJlbW92ZW5kdW0uc3Vic3RyKHRoaXMucmVtb3ZlbmR1bVBvaW50ZXIsIG9wLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlbmR1bVBvaW50ZXIgKz0gb3AubGVuZ3RoXG4gICAgfS5iaW5kKHRoaXMpKVxufVxuXG5DaGFuZ2VzZXRUcmFuc2Zvcm0ucHJvdG90eXBlLnN1YnJhbmdlID0gZnVuY3Rpb24gKHJhbmdlLCBzdGFydCwgbGVuKSB7XG4gIGlmKGxlbikgcmV0dXJuIHRoaXMuY3Muc3VicmFuZ2UuY2FsbChyYW5nZSwgc3RhcnQsIGxlbilcbiAgZWxzZSByZXR1cm4gcmFuZ2UuZmlsdGVyKGZ1bmN0aW9uKG9wKXsgcmV0dXJuICFvcC5pbnB1dH0pXG59XG5cbkNoYW5nZXNldFRyYW5zZm9ybS5wcm90b3R5cGUucmVzdWx0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMud3JpdGVPdXRwdXQodGhpcy5yZWFkSW5wdXQoSW5maW5pdHkpKVxuICB2YXIgbmV3Q3MgPSBuZXcgQ2hhbmdlc2V0KHRoaXMub3V0cHV0KVxuICBuZXdDcy5hZGRlbmR1bSA9IHRoaXMuY3MuYWRkZW5kdW1cbiAgbmV3Q3MucmVtb3ZlbmR1bSA9IHRoaXMubmV3UmVtb3ZlbmR1bVxuICByZXR1cm4gbmV3Q3Ncbn1cbiIsImZ1bmN0aW9uIE9wZXJhdG9yKCkge1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE9wZXJhdG9yXG5cbk9wZXJhdG9yLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5kZXJpdmUodGhpcy5sZW5ndGgpXG59XG5cbk9wZXJhdG9yLnByb3RvdHlwZS5kZXJpdmUgPSBmdW5jdGlvbihsZW4pIHtcbiAgcmV0dXJuIG5ldyAodGhpcy5jb25zdHJ1Y3RvcikobGVuKVxufVxuXG5PcGVyYXRvci5wcm90b3R5cGUucGFjayA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5zeW1ib2wgKyAodGhpcy5sZW5ndGgpLnRvU3RyaW5nKDM2KVxufVxuIiwiLyohXG4gKiBjaGFuZ2VzZXRzXG4gKiBBIENoYW5nZXNldCBsaWJyYXJ5IGluY29ycG9yYXRpbmcgb3BlcmF0aW9uYWwgQXBwbHkgKE9UKVxuICogQ29weXJpZ2h0IDIwMTIgYnkgTWFyY2VsIEtsZWhyIDxta2xlaHJAZ214Lm5ldD5cbiAqXG4gKiAoTUlUIExJQ0VOU0UpXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbnZhciBSZXRhaW4gPSByZXF1aXJlKCcuL29wZXJhdGlvbnMvUmV0YWluJylcbiAgLCBTa2lwID0gcmVxdWlyZSgnLi9vcGVyYXRpb25zL1NraXAnKVxuICAsIEluc2VydCA9IHJlcXVpcmUoJy4vb3BlcmF0aW9ucy9JbnNlcnQnKVxuICAsIEluc2VydCA9IHJlcXVpcmUoJy4vQ2hhbmdlc2V0JylcblxuXG5mdW5jdGlvbiBUZXh0VHJhbnNmb3JtKGlucHV0LCBhZGRlbmR1bSwgcmVtb3ZlbmR1bSkge1xuICB0aGlzLm91dHB1dCA9ICcnXG5cbiAgdGhpcy5pbnB1dCA9IGlucHV0XG4gIHRoaXMuYWRkZW5kdW0gPSBhZGRlbmR1bVxuICB0aGlzLnJlbW92ZW5kdW0gPSByZW1vdmVuZHVtXG4gIHRoaXMucG9zID0gMFxuICB0aGlzLmFkZFBvcyA9IDBcbiAgdGhpcy5yZW1Qb3MgPSAwXG59XG5tb2R1bGUuZXhwb3J0cyA9IFRleHRUcmFuc2Zvcm1cblxuVGV4dFRyYW5zZm9ybS5wcm90b3R5cGUucmVhZElucHV0ID0gZnVuY3Rpb24gKGxlbikge1xuICB2YXIgcmV0ID0gdGhpcy5pbnB1dC5zdWJzdHIodGhpcy5wb3MsIGxlbilcbiAgdGhpcy5wb3MgKz0gbGVuXG4gIHJldHVybiByZXRcbn1cblxuVGV4dFRyYW5zZm9ybS5wcm90b3R5cGUucmVhZEFkZGVuZHVtID0gZnVuY3Rpb24gKGxlbikge1xuICB2YXIgcmV0ID0gdGhpcy5hZGRlbmR1bS5zdWJzdHIodGhpcy5hZGRQb3MsIGxlbilcbiAgdGhpcy5hZGRQb3MgKz0gbGVuXG4gIHJldHVybiByZXRcbn1cblxuVGV4dFRyYW5zZm9ybS5wcm90b3R5cGUud3JpdGVSZW1vdmVuZHVtID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gIC8vdmFyIGV4cGVjdGVkID0gdGhpcy5yZW1vdmVuZHVtLnN1YnN0cih0aGlzLnJlbVBvcywgcmFuZ2UubGVuZ3RoKVxuICAvL2lmKHJhbmdlICE9IGV4cGVjdGVkKSB0aHJvdyBuZXcgRXJyb3IoJ1JlbW92ZWQgY2hhcnMgZG9uXFwndCBtYXRjaCByZW1vdmVuZHVtLiBleHBlY3RlZDogJytleHBlY3RlZCsnOyBhY3R1YWw6ICcrcmFuZ2UpXG4gIHRoaXMucmVtUG9zICs9IHJhbmdlLmxlbmd0aFxufVxuXG5UZXh0VHJhbnNmb3JtLnByb3RvdHlwZS53cml0ZU91dHB1dCA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICB0aGlzLm91dHB1dCArPSByYW5nZVxufVxuXG5UZXh0VHJhbnNmb3JtLnByb3RvdHlwZS5zdWJyYW5nZSA9IGZ1bmN0aW9uIChyYW5nZSwgc3RhcnQsIGxlbikge1xuICByZXR1cm4gcmFuZ2Uuc3Vic3RyKHN0YXJ0LCBsZW4pXG59XG5cblRleHRUcmFuc2Zvcm0ucHJvdG90eXBlLnJlc3VsdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLndyaXRlT3V0cHV0KHRoaXMucmVhZElucHV0KEluZmluaXR5KSlcbiAgcmV0dXJuIHRoaXMub3V0cHV0XG59XG4iLCIvKiFcbiAqIGNoYW5nZXNldHNcbiAqIEEgQ2hhbmdlc2V0IGxpYnJhcnkgaW5jb3Jwb3JhdGluZyBvcGVyYXRpb25hbCB0cmFuc2Zvcm1hdGlvbiAoT1QpXG4gKiBDb3B5cmlnaHQgMjAxMiBieSBNYXJjZWwgS2xlaHIgPG1rbGVockBnbXgubmV0PlxuICpcbiAqIChNSVQgTElDRU5TRSlcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxudmFyIENoYW5nZXNldCA9IHJlcXVpcmUoJy4vQ2hhbmdlc2V0JylcbiAgLCBSZXRhaW4gPSByZXF1aXJlKCcuL29wZXJhdGlvbnMvUmV0YWluJylcbiAgLCBTa2lwID0gcmVxdWlyZSgnLi9vcGVyYXRpb25zL1NraXAnKVxuICAsIEluc2VydCA9IHJlcXVpcmUoJy4vb3BlcmF0aW9ucy9JbnNlcnQnKVxuXG5leHBvcnRzLk9wZXJhdG9yID0gcmVxdWlyZSgnLi9PcGVyYXRvcicpXG5leHBvcnRzLkNoYW5nZXNldCA9IENoYW5nZXNldFxuZXhwb3J0cy5JbnNlcnQgPSBJbnNlcnRcbmV4cG9ydHMuUmV0YWluID0gUmV0YWluXG5leHBvcnRzLlNraXAgPSBTa2lwXG5cbmlmKCd1bmRlZmluZWQnICE9IHR5cGVvZiB3aW5kb3cpIHdpbmRvdy5jaGFuZ2VzZXRzID0gZXhwb3J0c1xuXG4vKipcbiAqIFNlcmlhbGl6ZXMgdGhlIGdpdmVuIGNoYW5nZXNldCBpbiBvcmRlciB0byByZXR1cm4gYSAoaG9wZWZ1bGx5KSBtb3JlIGNvbXBhY3QgcmVwcmVzZW50YXRpb25cbiAqIHRoYXQgY2FuIGJlIHNlbnQgdGhyb3VnaCBhIG5ldHdvcmsgb3Igc3RvcmVkIGluIGEgZGF0YWJhc2VcbiAqIEBhbGlhcyBjcy50ZXh0LkNoYW5nZXNldCNwYWNrXG4gKi9cbmV4cG9ydHMucGFjayA9IGZ1bmN0aW9uKGNzKSB7XG4gIHJldHVybiBjcy5wYWNrKClcbn1cblxuLyoqXG4gKiBVbnNlcmlhbGl6ZXMgdGhlIG91dHB1dCBvZiBjcy50ZXh0LnBhY2tcbiAqIEBhbGlhcyBjcy50ZXh0LkNoYW5nZXNldC51bnBhY2tcbiAqL1xuZXhwb3J0cy51bnBhY2sgPSBmdW5jdGlvbihwYWNrZWQpIHtcbiAgcmV0dXJuIENoYW5nZXNldC51bnBhY2socGFja2VkKVxufVxuXG5cblxuXG4vKipcbiAqIHNoYXJlSlMgb3QgdHlwZSBBUEkgc2VwYyBzdXBwb3J0XG4gKi9cblxuZXhwb3J0cy5uYW1lID0gJ2NoYW5nZXNldHMnXG5leHBvcnRzLnVybCA9ICdodHRwczovL2dpdGh1Yi5jb20vbWFyY2Vsa2xlaHIvY2hhbmdlc2V0cydcblxuLyoqXG4gKiBjcmVhdGUoW2luaXRpYWxUZXh0XSlcbiAqXG4gKiBjcmVhdGVzIGEgc25hcHNob3QgKG9wdGlvbmFsbHkgd2l0aCBzdXBwbGllZCBpbnRpYWwgdGV4dClcbiAqL1xuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbihpbml0VGV4dCkge1xuICByZXR1cm4gaW5pdFRleHQgfHwgJydcbn1cblxuLyoqXG4gKiBBcHBseSBhIGNoYW5nZXNldCBvbiBhIHNuYXBzaG90IGNyZWF0aW5nIGEgbmV3IG9uZVxuICpcbiAqIFRoZSBvbGQgc25hcHNob3Qgb2JqZWN0IG11c3RuJ3QgYmUgdXNlZCBhZnRlciBjYWxsaW5nIGFwcGx5IG9uIGl0XG4gKiByZXR1cm5zIHRoZSByZXN1bHRpbmdcbiAqL1xuZXhwb3J0cy5hcHBseSA9IGZ1bmN0aW9uKHNuYXBzaG90LCBvcCkge1xuICBvcCA9IGV4cG9ydHMudW5wYWNrKG9wKVxuICByZXR1cm4gb3AuYXBwbHkoc25hcHNob3QpXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGNoYW5nZXNldDEgYWdhaW5zdCBjaGFuZ2VzZXQyXG4gKi9cbmV4cG9ydHMudHJhbnNmb3JtID0gZnVuY3Rpb24gKG9wMSwgb3AyLCBzaWRlKSB7XG4gIG9wMSA9IGV4cG9ydHMudW5wYWNrKG9wMSlcbiAgb3AyID0gZXhwb3J0cy51bnBhY2sob3AyKVxuICByZXR1cm4gZXhwb3J0cy5wYWNrKG9wMS50cmFuc2Zvcm1BZ2FpbnN0KG9wMiwgKCdsZWZ0Jz09c2lkZSkpKVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBjaGFuZ2VzZXRzIGludG8gb25lXG4gKi9cbmV4cG9ydHMuY29tcG9zZSA9IGZ1bmN0aW9uIChvcDEsIG9wMikge1xuICBvcDEgPSBleHBvcnRzLnVucGFjayhvcDEpXG4gIG9wMiA9IGV4cG9ydHMudW5wYWNrKG9wMilcbiAgcmV0dXJuIGV4cG9ydHMucGFjayhvcDEubWVyZ2Uob3AyKSlcbn1cblxuLyoqXG4gKiBJbnZlcnQgYSBjaGFuZ2VzZXRcbiAqL1xuZXhwb3J0cy5pbnZlcnQgPSBmdW5jdGlvbihvcCkge1xuICByZXR1cm4gZXhwb3J0cy5wYWNrKGV4cG9ydHMudW5wYWNrKG9wKS5pbnZlcnQoKSlcbn1cbiIsIi8qIVxuICogY2hhbmdlc2V0c1xuICogQSBDaGFuZ2VzZXQgbGlicmFyeSBpbmNvcnBvcmF0aW5nIG9wZXJhdGlvbmFsIHRyYW5zZm9ybWF0aW9uIChPVClcbiAqIENvcHlyaWdodCAyMDEyIGJ5IE1hcmNlbCBLbGVociA8bWtsZWhyQGdteC5uZXQ+XG4gKlxuICogKE1JVCBMSUNFTlNFKVxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG52YXIgT3BlcmF0b3IgPSByZXF1aXJlKCcuLi9PcGVyYXRvcicpXG5cbi8qKlxuICogSW5zZXJ0IE9wZXJhdG9yXG4gKiBEZWZpbmVkIGJ5OlxuICogLSBsZW5ndGhcbiAqIC0gaW5wdXQ9MFxuICogLSBvdXRwdXQ9bGVuZ3RoXG4gKlxuICogQHBhcmFtIGxlbmd0aCA8TnVtYmVyPiBIb3cgbWFueSBjaGFycyB0byBiZSBpbnNlcnRlZFxuICovXG5mdW5jdGlvbiBJbnNlcnQobGVuZ3RoKSB7XG4gIHRoaXMubGVuZ3RoID0gbGVuZ3RoXG4gIHRoaXMuaW5wdXQgPSAwXG4gIHRoaXMub3V0cHV0ID0gbGVuZ3RoXG59XG5cbi8vIFRydWUgaW5oZXJpdGFuY2Vcbkluc2VydC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE9wZXJhdG9yLnByb3RvdHlwZSwge1xuICBjb25zdHJ1Y3Rvcjoge1xuICAgIHZhbHVlOiBJbnNlcnQsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH1cbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBJbnNlcnRcbkluc2VydC5wcm90b3R5cGUuc3ltYm9sID0gJysnXG5cbnZhciBTa2lwID0gcmVxdWlyZSgnLi9Ta2lwJylcbiAgLCBSZXRhaW4gPSByZXF1aXJlKCcuL1JldGFpbicpXG5cbkluc2VydC5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbih0KSB7XG4gIHQud3JpdGVPdXRwdXQodC5yZWFkQWRkZW5kdW0odGhpcy5vdXRwdXQpKVxufVxuXG5JbnNlcnQucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzXG59XG5cbkluc2VydC5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgU2tpcCh0aGlzLmxlbmd0aClcbn1cblxuSW5zZXJ0LnVucGFjayA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgcmV0dXJuIG5ldyBJbnNlcnQocGFyc2VJbnQoZGF0YSwgMzYpKVxufVxuIiwiLyohXG4gKiBjaGFuZ2VzZXRzXG4gKiBBIENoYW5nZXNldCBsaWJyYXJ5IGluY29ycG9yYXRpbmcgb3BlcmF0aW9uYWwgdHJhbnNmb3JtYXRpb24gKE9UKVxuICogQ29weXJpZ2h0IDIwMTIgYnkgTWFyY2VsIEtsZWhyIDxta2xlaHJAZ214Lm5ldD5cbiAqXG4gKiAoTUlUIExJQ0VOU0UpXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbnZhciBPcGVyYXRvciA9IHJlcXVpcmUoJy4uL09wZXJhdG9yJylcblxuLyoqXG4gKiBSZXRhaW4gT3BlcmF0b3JcbiAqIERlZmluZWQgYnk6XG4gKiAtIGxlbmd0aFxuICogLSBpbnB1dD1vdXRwdXQ9bGVuZ3RoXG4gKlxuICogQHBhcmFtIGxlbmd0aCA8TnVtYmVyPiBIb3cgbWFueSBjaGFycyB0byByZXRhaW5cbiAqL1xuZnVuY3Rpb24gUmV0YWluKGxlbmd0aCkge1xuICB0aGlzLmxlbmd0aCA9IGxlbmd0aFxuICB0aGlzLmlucHV0ID0gbGVuZ3RoXG4gIHRoaXMub3V0cHV0ID0gbGVuZ3RoXG59XG5cbi8vIFRydWUgaW5oZXJpdGFuY2VcblJldGFpbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE9wZXJhdG9yLnByb3RvdHlwZSwge1xuICBjb25zdHJ1Y3Rvcjoge1xuICAgIHZhbHVlOiBSZXRhaW4sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH1cbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBSZXRhaW5cblJldGFpbi5wcm90b3R5cGUuc3ltYm9sID0gJz0nXG5cblJldGFpbi5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbih0KSB7XG4gIHQud3JpdGVPdXRwdXQodC5yZWFkSW5wdXQodGhpcy5pbnB1dCkpXG59XG5cblJldGFpbi5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzXG59XG5cblJldGFpbi5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbihvcDIpIHtcbiAgcmV0dXJuIHRoaXNcbn1cblxuUmV0YWluLnVucGFjayA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgcmV0dXJuIG5ldyBSZXRhaW4ocGFyc2VJbnQoZGF0YSwgMzYpKVxufVxuIiwiLyohXG4gKiBjaGFuZ2VzZXRzXG4gKiBBIENoYW5nZXNldCBsaWJyYXJ5IGluY29ycG9yYXRpbmcgb3BlcmF0aW9uYWwgdHJhbnNmb3JtYXRpb24gKE9UKVxuICogQ29weXJpZ2h0IDIwMTIgYnkgTWFyY2VsIEtsZWhyIDxta2xlaHJAZ214Lm5ldD5cbiAqXG4gKiAoTUlUIExJQ0VOU0UpXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbnZhciBPcGVyYXRvciA9IHJlcXVpcmUoJy4uL09wZXJhdG9yJylcblxuLyoqXG4gKiBTa2lwIE9wZXJhdG9yXG4gKiBEZWZpbmVkIGJ5OlxuICogLSBsZW5ndGhcbiAqIC0gaW5wdXQ9bGVuZ3RoXG4gKiAtIG91dHB1dD0wXG4gKlxuICogQHBhcmFtIGxlbmd0aCA8TnVtYmVyPiBIb3cgbWFueSBjaGFycyB0byBiZSBTa2lwXG4gKi9cbmZ1bmN0aW9uIFNraXAobGVuZ3RoKSB7XG4gIHRoaXMubGVuZ3RoID0gbGVuZ3RoXG4gIHRoaXMuaW5wdXQgPSBsZW5ndGhcbiAgdGhpcy5vdXRwdXQgPSAwXG59XG5cbi8vIFRydWUgaW5oZXJpdGFuY2VcblNraXAucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShPcGVyYXRvci5wcm90b3R5cGUsIHtcbiAgY29uc3RydWN0b3I6IHtcbiAgICB2YWx1ZTogU2tpcCxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IFNraXBcblNraXAucHJvdG90eXBlLnN5bWJvbCA9ICctJ1xuXG52YXIgSW5zZXJ0ID0gcmVxdWlyZSgnLi9JbnNlcnQnKVxuICAsIFJldGFpbiA9IHJlcXVpcmUoJy4vUmV0YWluJylcbiAgLCBDaGFuZ2VzZXQgPSByZXF1aXJlKCcuLi9DaGFuZ2VzZXQnKVxuXG5Ta2lwLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKHQpIHtcbiAgdmFyIGlucHV0ID0gdC5yZWFkSW5wdXQodGhpcy5pbnB1dClcbiAgdC53cml0ZVJlbW92ZW5kdW0oaW5wdXQpXG4gIHQud3JpdGVPdXRwdXQodC5zdWJyYW5nZShpbnB1dCwgMCwgdGhpcy5vdXRwdXQpKSAvLyByZXRhaW4gSW5zZXJ0cyBpbiBteSByYW5nZVxufVxuXG5Ta2lwLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uKG9wMikge1xuICByZXR1cm4gdGhpc1xufVxuXG5Ta2lwLnByb3RvdHlwZS5pbnZlcnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBJbnNlcnQodGhpcy5sZW5ndGgpXG59XG5cblNraXAudW5wYWNrID0gZnVuY3Rpb24oZGF0YSkge1xuICByZXR1cm4gbmV3IFNraXAocGFyc2VJbnQoZGF0YSwgMzYpKVxufVxuIiwiLyoqXG4gKiBEaWZmIE1hdGNoIGFuZCBQYXRjaFxuICpcbiAqIENvcHlyaWdodCAyMDA2IEdvb2dsZSBJbmMuXG4gKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvZ29vZ2xlLWRpZmYtbWF0Y2gtcGF0Y2gvXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ29tcHV0ZXMgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0d28gdGV4dHMgdG8gY3JlYXRlIGEgcGF0Y2guXG4gKiBBcHBsaWVzIHRoZSBwYXRjaCBvbnRvIGFub3RoZXIgdGV4dCwgYWxsb3dpbmcgZm9yIGVycm9ycy5cbiAqIEBhdXRob3IgZnJhc2VyQGdvb2dsZS5jb20gKE5laWwgRnJhc2VyKVxuICovXG5cbi8qKlxuICogQ2xhc3MgY29udGFpbmluZyB0aGUgZGlmZiwgbWF0Y2ggYW5kIHBhdGNoIG1ldGhvZHMuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gZGlmZl9tYXRjaF9wYXRjaCgpIHtcblxuICAvLyBEZWZhdWx0cy5cbiAgLy8gUmVkZWZpbmUgdGhlc2UgaW4geW91ciBwcm9ncmFtIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0cy5cblxuICAvLyBOdW1iZXIgb2Ygc2Vjb25kcyB0byBtYXAgYSBkaWZmIGJlZm9yZSBnaXZpbmcgdXAgKDAgZm9yIGluZmluaXR5KS5cbiAgdGhpcy5EaWZmX1RpbWVvdXQgPSAxLjA7XG4gIC8vIENvc3Qgb2YgYW4gZW1wdHkgZWRpdCBvcGVyYXRpb24gaW4gdGVybXMgb2YgZWRpdCBjaGFyYWN0ZXJzLlxuICB0aGlzLkRpZmZfRWRpdENvc3QgPSA0O1xuICAvLyBUaGUgc2l6ZSBiZXlvbmQgd2hpY2ggdGhlIGRvdWJsZS1lbmRlZCBkaWZmIGFjdGl2YXRlcy5cbiAgLy8gRG91YmxlLWVuZGluZyBpcyB0d2ljZSBhcyBmYXN0LCBidXQgbGVzcyBhY2N1cmF0ZS5cbiAgdGhpcy5EaWZmX0R1YWxUaHJlc2hvbGQgPSAzMjtcbiAgLy8gQXQgd2hhdCBwb2ludCBpcyBubyBtYXRjaCBkZWNsYXJlZCAoMC4wID0gcGVyZmVjdGlvbiwgMS4wID0gdmVyeSBsb29zZSkuXG4gIHRoaXMuTWF0Y2hfVGhyZXNob2xkID0gMC41O1xuICAvLyBIb3cgZmFyIHRvIHNlYXJjaCBmb3IgYSBtYXRjaCAoMCA9IGV4YWN0IGxvY2F0aW9uLCAxMDAwKyA9IGJyb2FkIG1hdGNoKS5cbiAgLy8gQSBtYXRjaCB0aGlzIG1hbnkgY2hhcmFjdGVycyBhd2F5IGZyb20gdGhlIGV4cGVjdGVkIGxvY2F0aW9uIHdpbGwgYWRkXG4gIC8vIDEuMCB0byB0aGUgc2NvcmUgKDAuMCBpcyBhIHBlcmZlY3QgbWF0Y2gpLlxuICB0aGlzLk1hdGNoX0Rpc3RhbmNlID0gMTAwMDtcbiAgLy8gV2hlbiBkZWxldGluZyBhIGxhcmdlIGJsb2NrIG9mIHRleHQgKG92ZXIgfjY0IGNoYXJhY3RlcnMpLCBob3cgY2xvc2UgZG9lc1xuICAvLyB0aGUgY29udGVudHMgaGF2ZSB0byBtYXRjaCB0aGUgZXhwZWN0ZWQgY29udGVudHMuICgwLjAgPSBwZXJmZWN0aW9uLFxuICAvLyAxLjAgPSB2ZXJ5IGxvb3NlKS4gIE5vdGUgdGhhdCBNYXRjaF9UaHJlc2hvbGQgY29udHJvbHMgaG93IGNsb3NlbHkgdGhlXG4gIC8vIGVuZCBwb2ludHMgb2YgYSBkZWxldGUgbmVlZCB0byBtYXRjaC5cbiAgdGhpcy5QYXRjaF9EZWxldGVUaHJlc2hvbGQgPSAwLjU7XG4gIC8vIENodW5rIHNpemUgZm9yIGNvbnRleHQgbGVuZ3RoLlxuICB0aGlzLlBhdGNoX01hcmdpbiA9IDQ7XG5cbiAgLyoqXG4gICAqIENvbXB1dGUgdGhlIG51bWJlciBvZiBiaXRzIGluIGFuIGludC5cbiAgICogVGhlIG5vcm1hbCBhbnN3ZXIgZm9yIEphdmFTY3JpcHQgaXMgMzIuXG4gICAqIEByZXR1cm4ge251bWJlcn0gTWF4IGJpdHNcbiAgICovXG4gIGZ1bmN0aW9uIGdldE1heEJpdHMoKSB7XG4gICAgdmFyIG1heGJpdHMgPSAwO1xuICAgIHZhciBvbGRpID0gMTtcbiAgICB2YXIgbmV3aSA9IDI7XG4gICAgd2hpbGUgKG9sZGkgIT0gbmV3aSkge1xuICAgICAgbWF4Yml0cysrO1xuICAgICAgb2xkaSA9IG5ld2k7XG4gICAgICBuZXdpID0gbmV3aSA8PCAxO1xuICAgIH1cbiAgICByZXR1cm4gbWF4Yml0cztcbiAgfVxuICAvLyBIb3cgbWFueSBiaXRzIGluIGEgbnVtYmVyP1xuICB0aGlzLk1hdGNoX01heEJpdHMgPSBnZXRNYXhCaXRzKCk7XG59XG5cblxuLy8gIERJRkYgRlVOQ1RJT05TXG5cblxuLyoqXG4gKiBUaGUgZGF0YSBzdHJ1Y3R1cmUgcmVwcmVzZW50aW5nIGEgZGlmZiBpcyBhbiBhcnJheSBvZiB0dXBsZXM6XG4gKiBbW0RJRkZfREVMRVRFLCAnSGVsbG8nXSwgW0RJRkZfSU5TRVJULCAnR29vZGJ5ZSddLCBbRElGRl9FUVVBTCwgJyB3b3JsZC4nXV1cbiAqIHdoaWNoIG1lYW5zOiBkZWxldGUgJ0hlbGxvJywgYWRkICdHb29kYnllJyBhbmQga2VlcCAnIHdvcmxkLidcbiAqL1xudmFyIERJRkZfREVMRVRFID0gLTE7XG52YXIgRElGRl9JTlNFUlQgPSAxO1xudmFyIERJRkZfRVFVQUwgPSAwO1xuXG5cbi8qKlxuICogRmluZCB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiB0d28gdGV4dHMuICBTaW1wbGlmaWVzIHRoZSBwcm9ibGVtIGJ5IHN0cmlwcGluZ1xuICogYW55IGNvbW1vbiBwcmVmaXggb3Igc3VmZml4IG9mZiB0aGUgdGV4dHMgYmVmb3JlIGRpZmZpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgT2xkIHN0cmluZyB0byBiZSBkaWZmZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgTmV3IHN0cmluZyB0byBiZSBkaWZmZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdF9jaGVja2xpbmVzIE9wdGlvbmFsIHNwZWVkdXAgZmxhZy4gIElmIHByZXNlbnQgYW5kIGZhbHNlLFxuICogICAgIHRoZW4gZG9uJ3QgcnVuIGEgbGluZS1sZXZlbCBkaWZmIGZpcnN0IHRvIGlkZW50aWZ5IHRoZSBjaGFuZ2VkIGFyZWFzLlxuICogICAgIERlZmF1bHRzIHRvIHRydWUsIHdoaWNoIGRvZXMgYSBmYXN0ZXIsIHNsaWdodGx5IGxlc3Mgb3B0aW1hbCBkaWZmXG4gKiBAcmV0dXJuIHtBcnJheS48QXJyYXkuPG51bWJlcnxzdHJpbmc+Pn0gQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfbWFpbiA9IGZ1bmN0aW9uKHRleHQxLCB0ZXh0Miwgb3B0X2NoZWNrbGluZXMpIHtcbiAgLy8gQ2hlY2sgZm9yIG51bGwgaW5wdXRzLlxuICBpZiAodGV4dDEgPT0gbnVsbCB8fCB0ZXh0MiA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOdWxsIGlucHV0LiAoZGlmZl9tYWluKScpO1xuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIGVxdWFsaXR5IChzcGVlZHVwKS5cbiAgaWYgKHRleHQxID09IHRleHQyKSB7XG4gICAgcmV0dXJuIFtbRElGRl9FUVVBTCwgdGV4dDFdXTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0X2NoZWNrbGluZXMgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBvcHRfY2hlY2tsaW5lcyA9IHRydWU7XG4gIH1cbiAgdmFyIGNoZWNrbGluZXMgPSBvcHRfY2hlY2tsaW5lcztcblxuICAvLyBUcmltIG9mZiBjb21tb24gcHJlZml4IChzcGVlZHVwKS5cbiAgdmFyIGNvbW1vbmxlbmd0aCA9IHRoaXMuZGlmZl9jb21tb25QcmVmaXgodGV4dDEsIHRleHQyKTtcbiAgdmFyIGNvbW1vbnByZWZpeCA9IHRleHQxLnN1YnN0cmluZygwLCBjb21tb25sZW5ndGgpO1xuICB0ZXh0MSA9IHRleHQxLnN1YnN0cmluZyhjb21tb25sZW5ndGgpO1xuICB0ZXh0MiA9IHRleHQyLnN1YnN0cmluZyhjb21tb25sZW5ndGgpO1xuXG4gIC8vIFRyaW0gb2ZmIGNvbW1vbiBzdWZmaXggKHNwZWVkdXApLlxuICBjb21tb25sZW5ndGggPSB0aGlzLmRpZmZfY29tbW9uU3VmZml4KHRleHQxLCB0ZXh0Mik7XG4gIHZhciBjb21tb25zdWZmaXggPSB0ZXh0MS5zdWJzdHJpbmcodGV4dDEubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcbiAgdGV4dDEgPSB0ZXh0MS5zdWJzdHJpbmcoMCwgdGV4dDEubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcbiAgdGV4dDIgPSB0ZXh0Mi5zdWJzdHJpbmcoMCwgdGV4dDIubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcblxuICAvLyBDb21wdXRlIHRoZSBkaWZmIG9uIHRoZSBtaWRkbGUgYmxvY2suXG4gIHZhciBkaWZmcyA9IHRoaXMuZGlmZl9jb21wdXRlKHRleHQxLCB0ZXh0MiwgY2hlY2tsaW5lcyk7XG5cbiAgLy8gUmVzdG9yZSB0aGUgcHJlZml4IGFuZCBzdWZmaXguXG4gIGlmIChjb21tb25wcmVmaXgpIHtcbiAgICBkaWZmcy51bnNoaWZ0KFtESUZGX0VRVUFMLCBjb21tb25wcmVmaXhdKTtcbiAgfVxuICBpZiAoY29tbW9uc3VmZml4KSB7XG4gICAgZGlmZnMucHVzaChbRElGRl9FUVVBTCwgY29tbW9uc3VmZml4XSk7XG4gIH1cbiAgdGhpcy5kaWZmX2NsZWFudXBNZXJnZShkaWZmcyk7XG4gIHJldHVybiBkaWZmcztcbn07XG5cblxuLyoqXG4gKiBGaW5kIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHR3byB0ZXh0cy4gIEFzc3VtZXMgdGhhdCB0aGUgdGV4dHMgZG8gbm90XG4gKiBoYXZlIGFueSBjb21tb24gcHJlZml4IG9yIHN1ZmZpeC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBPbGQgc3RyaW5nIHRvIGJlIGRpZmZlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBOZXcgc3RyaW5nIHRvIGJlIGRpZmZlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY2hlY2tsaW5lcyBTcGVlZHVwIGZsYWcuICBJZiBmYWxzZSwgdGhlbiBkb24ndCBydW4gYVxuICogICAgIGxpbmUtbGV2ZWwgZGlmZiBmaXJzdCB0byBpZGVudGlmeSB0aGUgY2hhbmdlZCBhcmVhcy5cbiAqICAgICBJZiB0cnVlLCB0aGVuIHJ1biBhIGZhc3Rlciwgc2xpZ2h0bHkgbGVzcyBvcHRpbWFsIGRpZmZcbiAqIEByZXR1cm4ge0FycmF5LjxBcnJheS48bnVtYmVyfHN0cmluZz4+fSBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqIEBwcml2YXRlXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfY29tcHV0ZSA9IGZ1bmN0aW9uKHRleHQxLCB0ZXh0MiwgY2hlY2tsaW5lcykge1xuICB2YXIgZGlmZnM7XG5cbiAgaWYgKCF0ZXh0MSkge1xuICAgIC8vIEp1c3QgYWRkIHNvbWUgdGV4dCAoc3BlZWR1cCkuXG4gICAgcmV0dXJuIFtbRElGRl9JTlNFUlQsIHRleHQyXV07XG4gIH1cblxuICBpZiAoIXRleHQyKSB7XG4gICAgLy8gSnVzdCBkZWxldGUgc29tZSB0ZXh0IChzcGVlZHVwKS5cbiAgICByZXR1cm4gW1tESUZGX0RFTEVURSwgdGV4dDFdXTtcbiAgfVxuXG4gIHZhciBsb25ndGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQxIDogdGV4dDI7XG4gIHZhciBzaG9ydHRleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MiA6IHRleHQxO1xuICB2YXIgaSA9IGxvbmd0ZXh0LmluZGV4T2Yoc2hvcnR0ZXh0KTtcbiAgaWYgKGkgIT0gLTEpIHtcbiAgICAvLyBTaG9ydGVyIHRleHQgaXMgaW5zaWRlIHRoZSBsb25nZXIgdGV4dCAoc3BlZWR1cCkuXG4gICAgZGlmZnMgPSBbW0RJRkZfSU5TRVJULCBsb25ndGV4dC5zdWJzdHJpbmcoMCwgaSldLFxuICAgICAgICAgICAgIFtESUZGX0VRVUFMLCBzaG9ydHRleHRdLFxuICAgICAgICAgICAgIFtESUZGX0lOU0VSVCwgbG9uZ3RleHQuc3Vic3RyaW5nKGkgKyBzaG9ydHRleHQubGVuZ3RoKV1dO1xuICAgIC8vIFN3YXAgaW5zZXJ0aW9ucyBmb3IgZGVsZXRpb25zIGlmIGRpZmYgaXMgcmV2ZXJzZWQuXG4gICAgaWYgKHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCkge1xuICAgICAgZGlmZnNbMF1bMF0gPSBkaWZmc1syXVswXSA9IERJRkZfREVMRVRFO1xuICAgIH1cbiAgICByZXR1cm4gZGlmZnM7XG4gIH1cbiAgbG9uZ3RleHQgPSBzaG9ydHRleHQgPSBudWxsOyAgLy8gR2FyYmFnZSBjb2xsZWN0LlxuXG4gIC8vIENoZWNrIHRvIHNlZSBpZiB0aGUgcHJvYmxlbSBjYW4gYmUgc3BsaXQgaW4gdHdvLlxuICB2YXIgaG0gPSB0aGlzLmRpZmZfaGFsZk1hdGNoKHRleHQxLCB0ZXh0Mik7XG4gIGlmIChobSkge1xuICAgIC8vIEEgaGFsZi1tYXRjaCB3YXMgZm91bmQsIHNvcnQgb3V0IHRoZSByZXR1cm4gZGF0YS5cbiAgICB2YXIgdGV4dDFfYSA9IGhtWzBdO1xuICAgIHZhciB0ZXh0MV9iID0gaG1bMV07XG4gICAgdmFyIHRleHQyX2EgPSBobVsyXTtcbiAgICB2YXIgdGV4dDJfYiA9IGhtWzNdO1xuICAgIHZhciBtaWRfY29tbW9uID0gaG1bNF07XG4gICAgLy8gU2VuZCBib3RoIHBhaXJzIG9mZiBmb3Igc2VwYXJhdGUgcHJvY2Vzc2luZy5cbiAgICB2YXIgZGlmZnNfYSA9IHRoaXMuZGlmZl9tYWluKHRleHQxX2EsIHRleHQyX2EsIGNoZWNrbGluZXMpO1xuICAgIHZhciBkaWZmc19iID0gdGhpcy5kaWZmX21haW4odGV4dDFfYiwgdGV4dDJfYiwgY2hlY2tsaW5lcyk7XG4gICAgLy8gTWVyZ2UgdGhlIHJlc3VsdHMuXG4gICAgcmV0dXJuIGRpZmZzX2EuY29uY2F0KFtbRElGRl9FUVVBTCwgbWlkX2NvbW1vbl1dLCBkaWZmc19iKTtcbiAgfVxuXG4gIC8vIFBlcmZvcm0gYSByZWFsIGRpZmYuXG4gIGlmIChjaGVja2xpbmVzICYmICh0ZXh0MS5sZW5ndGggPCAxMDAgfHwgdGV4dDIubGVuZ3RoIDwgMTAwKSkge1xuICAgIC8vIFRvbyB0cml2aWFsIGZvciB0aGUgb3ZlcmhlYWQuXG4gICAgY2hlY2tsaW5lcyA9IGZhbHNlO1xuICB9XG4gIHZhciBsaW5lYXJyYXk7XG4gIGlmIChjaGVja2xpbmVzKSB7XG4gICAgLy8gU2NhbiB0aGUgdGV4dCBvbiBhIGxpbmUtYnktbGluZSBiYXNpcyBmaXJzdC5cbiAgICB2YXIgYSA9IHRoaXMuZGlmZl9saW5lc1RvQ2hhcnModGV4dDEsIHRleHQyKTtcbiAgICB0ZXh0MSA9IGFbMF07XG4gICAgdGV4dDIgPSBhWzFdO1xuICAgIGxpbmVhcnJheSA9IGFbMl07XG4gIH1cbiAgZGlmZnMgPSB0aGlzLmRpZmZfbWFwKHRleHQxLCB0ZXh0Mik7XG4gIGlmICghZGlmZnMpIHtcbiAgICAvLyBObyBhY2NlcHRhYmxlIHJlc3VsdC5cbiAgICBkaWZmcyA9IFtbRElGRl9ERUxFVEUsIHRleHQxXSwgW0RJRkZfSU5TRVJULCB0ZXh0Ml1dO1xuICB9XG4gIGlmIChjaGVja2xpbmVzKSB7XG4gICAgLy8gQ29udmVydCB0aGUgZGlmZiBiYWNrIHRvIG9yaWdpbmFsIHRleHQuXG4gICAgdGhpcy5kaWZmX2NoYXJzVG9MaW5lcyhkaWZmcywgbGluZWFycmF5KTtcbiAgICAvLyBFbGltaW5hdGUgZnJlYWsgbWF0Y2hlcyAoZS5nLiBibGFuayBsaW5lcylcbiAgICB0aGlzLmRpZmZfY2xlYW51cFNlbWFudGljKGRpZmZzKTtcblxuICAgIC8vIFJlZGlmZiBhbnkgcmVwbGFjZW1lbnQgYmxvY2tzLCB0aGlzIHRpbWUgY2hhcmFjdGVyLWJ5LWNoYXJhY3Rlci5cbiAgICAvLyBBZGQgYSBkdW1teSBlbnRyeSBhdCB0aGUgZW5kLlxuICAgIGRpZmZzLnB1c2goW0RJRkZfRVFVQUwsICcnXSk7XG4gICAgdmFyIHBvaW50ZXIgPSAwO1xuICAgIHZhciBjb3VudF9kZWxldGUgPSAwO1xuICAgIHZhciBjb3VudF9pbnNlcnQgPSAwO1xuICAgIHZhciB0ZXh0X2RlbGV0ZSA9ICcnO1xuICAgIHZhciB0ZXh0X2luc2VydCA9ICcnO1xuICAgIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoKSB7XG4gICAgICBzd2l0Y2ggKGRpZmZzW3BvaW50ZXJdWzBdKSB7XG4gICAgICAgIGNhc2UgRElGRl9JTlNFUlQ6XG4gICAgICAgICAgY291bnRfaW5zZXJ0Kys7XG4gICAgICAgICAgdGV4dF9pbnNlcnQgKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRElGRl9ERUxFVEU6XG4gICAgICAgICAgY291bnRfZGVsZXRlKys7XG4gICAgICAgICAgdGV4dF9kZWxldGUgKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRElGRl9FUVVBTDpcbiAgICAgICAgICAvLyBVcG9uIHJlYWNoaW5nIGFuIGVxdWFsaXR5LCBjaGVjayBmb3IgcHJpb3IgcmVkdW5kYW5jaWVzLlxuICAgICAgICAgIGlmIChjb3VudF9kZWxldGUgPj0gMSAmJiBjb3VudF9pbnNlcnQgPj0gMSkge1xuICAgICAgICAgICAgLy8gRGVsZXRlIHRoZSBvZmZlbmRpbmcgcmVjb3JkcyBhbmQgYWRkIHRoZSBtZXJnZWQgb25lcy5cbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5kaWZmX21haW4odGV4dF9kZWxldGUsIHRleHRfaW5zZXJ0LCBmYWxzZSk7XG4gICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudF9kZWxldGUgKyBjb3VudF9pbnNlcnQpO1xuICAgICAgICAgICAgcG9pbnRlciA9IHBvaW50ZXIgLSBjb3VudF9kZWxldGUgLSBjb3VudF9pbnNlcnQ7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gYS5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciwgMCwgYVtqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2ludGVyID0gcG9pbnRlciArIGEubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb3VudF9pbnNlcnQgPSAwO1xuICAgICAgICAgIGNvdW50X2RlbGV0ZSA9IDA7XG4gICAgICAgICAgdGV4dF9kZWxldGUgPSAnJztcbiAgICAgICAgICB0ZXh0X2luc2VydCA9ICcnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICBwb2ludGVyKys7XG4gICAgfVxuICAgIGRpZmZzLnBvcCgpOyAgLy8gUmVtb3ZlIHRoZSBkdW1teSBlbnRyeSBhdCB0aGUgZW5kLlxuICB9XG4gIHJldHVybiBkaWZmcztcbn07XG5cblxuLyoqXG4gKiBTcGxpdCB0d28gdGV4dHMgaW50byBhbiBhcnJheSBvZiBzdHJpbmdzLiAgUmVkdWNlIHRoZSB0ZXh0cyB0byBhIHN0cmluZyBvZlxuICogaGFzaGVzIHdoZXJlIGVhY2ggVW5pY29kZSBjaGFyYWN0ZXIgcmVwcmVzZW50cyBvbmUgbGluZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBGaXJzdCBzdHJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgU2Vjb25kIHN0cmluZy5cbiAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmd8QXJyYXkuPHN0cmluZz4+fSBUaHJlZSBlbGVtZW50IEFycmF5LCBjb250YWluaW5nIHRoZVxuICogICAgIGVuY29kZWQgdGV4dDEsIHRoZSBlbmNvZGVkIHRleHQyIGFuZCB0aGUgYXJyYXkgb2YgdW5pcXVlIHN0cmluZ3MuICBUaGVcbiAqICAgICB6ZXJvdGggZWxlbWVudCBvZiB0aGUgYXJyYXkgb2YgdW5pcXVlIHN0cmluZ3MgaXMgaW50ZW50aW9uYWxseSBibGFuay5cbiAqIEBwcml2YXRlXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfbGluZXNUb0NoYXJzID0gZnVuY3Rpb24odGV4dDEsIHRleHQyKSB7XG4gIHZhciBsaW5lQXJyYXkgPSBbXTsgIC8vIGUuZy4gbGluZUFycmF5WzRdID09ICdIZWxsb1xcbidcbiAgdmFyIGxpbmVIYXNoID0ge307ICAgLy8gZS5nLiBsaW5lSGFzaFsnSGVsbG9cXG4nXSA9PSA0XG5cbiAgLy8gJ1xceDAwJyBpcyBhIHZhbGlkIGNoYXJhY3RlciwgYnV0IHZhcmlvdXMgZGVidWdnZXJzIGRvbid0IGxpa2UgaXQuXG4gIC8vIFNvIHdlJ2xsIGluc2VydCBhIGp1bmsgZW50cnkgdG8gYXZvaWQgZ2VuZXJhdGluZyBhIG51bGwgY2hhcmFjdGVyLlxuICBsaW5lQXJyYXlbMF0gPSAnJztcblxuICAvKipcbiAgICogU3BsaXQgYSB0ZXh0IGludG8gYW4gYXJyYXkgb2Ygc3RyaW5ncy4gIFJlZHVjZSB0aGUgdGV4dHMgdG8gYSBzdHJpbmcgb2ZcbiAgICogaGFzaGVzIHdoZXJlIGVhY2ggVW5pY29kZSBjaGFyYWN0ZXIgcmVwcmVzZW50cyBvbmUgbGluZS5cbiAgICogTW9kaWZpZXMgbGluZWFycmF5IGFuZCBsaW5laGFzaCB0aHJvdWdoIGJlaW5nIGEgY2xvc3VyZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgU3RyaW5nIHRvIGVuY29kZS5cbiAgICogQHJldHVybiB7c3RyaW5nfSBFbmNvZGVkIHN0cmluZy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGRpZmZfbGluZXNUb0NoYXJzTXVuZ2UodGV4dCkge1xuICAgIHZhciBjaGFycyA9ICcnO1xuICAgIC8vIFdhbGsgdGhlIHRleHQsIHB1bGxpbmcgb3V0IGEgc3Vic3RyaW5nIGZvciBlYWNoIGxpbmUuXG4gICAgLy8gdGV4dC5zcGxpdCgnXFxuJykgd291bGQgd291bGQgdGVtcG9yYXJpbHkgZG91YmxlIG91ciBtZW1vcnkgZm9vdHByaW50LlxuICAgIC8vIE1vZGlmeWluZyB0ZXh0IHdvdWxkIGNyZWF0ZSBtYW55IGxhcmdlIHN0cmluZ3MgdG8gZ2FyYmFnZSBjb2xsZWN0LlxuICAgIHZhciBsaW5lU3RhcnQgPSAwO1xuICAgIHZhciBsaW5lRW5kID0gLTE7XG4gICAgLy8gS2VlcGluZyBvdXIgb3duIGxlbmd0aCB2YXJpYWJsZSBpcyBmYXN0ZXIgdGhhbiBsb29raW5nIGl0IHVwLlxuICAgIHZhciBsaW5lQXJyYXlMZW5ndGggPSBsaW5lQXJyYXkubGVuZ3RoO1xuICAgIHdoaWxlIChsaW5lRW5kIDwgdGV4dC5sZW5ndGggLSAxKSB7XG4gICAgICBsaW5lRW5kID0gdGV4dC5pbmRleE9mKCdcXG4nLCBsaW5lU3RhcnQpO1xuICAgICAgaWYgKGxpbmVFbmQgPT0gLTEpIHtcbiAgICAgICAgbGluZUVuZCA9IHRleHQubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICAgIHZhciBsaW5lID0gdGV4dC5zdWJzdHJpbmcobGluZVN0YXJ0LCBsaW5lRW5kICsgMSk7XG4gICAgICBsaW5lU3RhcnQgPSBsaW5lRW5kICsgMTtcblxuICAgICAgaWYgKGxpbmVIYXNoLmhhc093blByb3BlcnR5ID8gbGluZUhhc2guaGFzT3duUHJvcGVydHkobGluZSkgOlxuICAgICAgICAgIChsaW5lSGFzaFtsaW5lXSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBjaGFycyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxpbmVIYXNoW2xpbmVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoYXJzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGluZUFycmF5TGVuZ3RoKTtcbiAgICAgICAgbGluZUhhc2hbbGluZV0gPSBsaW5lQXJyYXlMZW5ndGg7XG4gICAgICAgIGxpbmVBcnJheVtsaW5lQXJyYXlMZW5ndGgrK10gPSBsaW5lO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hhcnM7XG4gIH1cblxuICB2YXIgY2hhcnMxID0gZGlmZl9saW5lc1RvQ2hhcnNNdW5nZSh0ZXh0MSk7XG4gIHZhciBjaGFyczIgPSBkaWZmX2xpbmVzVG9DaGFyc011bmdlKHRleHQyKTtcbiAgcmV0dXJuIFtjaGFyczEsIGNoYXJzMiwgbGluZUFycmF5XTtcbn07XG5cblxuLyoqXG4gKiBSZWh5ZHJhdGUgdGhlIHRleHQgaW4gYSBkaWZmIGZyb20gYSBzdHJpbmcgb2YgbGluZSBoYXNoZXMgdG8gcmVhbCBsaW5lcyBvZlxuICogdGV4dC5cbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXJ8c3RyaW5nPj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gbGluZUFycmF5IEFycmF5IG9mIHVuaXF1ZSBzdHJpbmdzLlxuICogQHByaXZhdGVcbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jaGFyc1RvTGluZXMgPSBmdW5jdGlvbihkaWZmcywgbGluZUFycmF5KSB7XG4gIGZvciAodmFyIHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICB2YXIgY2hhcnMgPSBkaWZmc1t4XVsxXTtcbiAgICB2YXIgdGV4dCA9IFtdO1xuICAgIGZvciAodmFyIHkgPSAwOyB5IDwgY2hhcnMubGVuZ3RoOyB5KyspIHtcbiAgICAgIHRleHRbeV0gPSBsaW5lQXJyYXlbY2hhcnMuY2hhckNvZGVBdCh5KV07XG4gICAgfVxuICAgIGRpZmZzW3hdWzFdID0gdGV4dC5qb2luKCcnKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEV4cGxvcmUgdGhlIGludGVyc2VjdGlvbiBwb2ludHMgYmV0d2VlbiB0aGUgdHdvIHRleHRzLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIE9sZCBzdHJpbmcgdG8gYmUgZGlmZmVkLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIE5ldyBzdHJpbmcgdG8gYmUgZGlmZmVkLlxuICogQHJldHVybiB7P0FycmF5LjxBcnJheS48bnVtYmVyfHN0cmluZz4+fSBBcnJheSBvZiBkaWZmIHR1cGxlcyBvciBudWxsIGlmIG5vXG4gKiAgICAgZGlmZiBhdmFpbGFibGUuXG4gKiBAcHJpdmF0ZVxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX21hcCA9IGZ1bmN0aW9uKHRleHQxLCB0ZXh0Mikge1xuICAvLyBEb24ndCBydW4gZm9yIHRvbyBsb25nLlxuICB2YXIgbXNfZW5kID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSArIHRoaXMuRGlmZl9UaW1lb3V0ICogMTAwMDtcbiAgLy8gQ2FjaGUgdGhlIHRleHQgbGVuZ3RocyB0byBwcmV2ZW50IG11bHRpcGxlIGNhbGxzLlxuICB2YXIgdGV4dDFfbGVuZ3RoID0gdGV4dDEubGVuZ3RoO1xuICB2YXIgdGV4dDJfbGVuZ3RoID0gdGV4dDIubGVuZ3RoO1xuICB2YXIgbWF4X2QgPSB0ZXh0MV9sZW5ndGggKyB0ZXh0Ml9sZW5ndGggLSAxO1xuICB2YXIgZG91YmxlRW5kID0gdGhpcy5EaWZmX0R1YWxUaHJlc2hvbGQgKiAyIDwgbWF4X2Q7XG4gIC8vIEphdmFTY3JpcHQgZWZmaWNpZW5jeSBub3RlOiAoeCA8PCAzMikgKyB5IGRvZXNuJ3Qgd29yayBzaW5jZSBudW1iZXJzIGFyZVxuICAvLyBvbmx5IDMyIGJpdC4gIFVzZSB4ICsgJywnICsgeSB0byBjcmVhdGUgYSBoYXNoIGluc3RlYWQuXG4gIHZhciB2X21hcDEgPSBbXTtcbiAgdmFyIHZfbWFwMiA9IFtdO1xuICB2YXIgdjEgPSB7fTtcbiAgdmFyIHYyID0ge307XG4gIHYxWzFdID0gMDtcbiAgdjJbMV0gPSAwO1xuICB2YXIgeCwgeTtcbiAgdmFyIGZvb3RzdGVwOyAgLy8gVXNlZCB0byB0cmFjayBvdmVybGFwcGluZyBwYXRocy5cbiAgdmFyIGZvb3RzdGVwcyA9IHt9O1xuICB2YXIgZG9uZSA9IGZhbHNlO1xuICAvLyBJZiB0aGUgdG90YWwgbnVtYmVyIG9mIGNoYXJhY3RlcnMgaXMgb2RkLCB0aGVuIHRoZSBmcm9udCBwYXRoIHdpbGwgY29sbGlkZVxuICAvLyB3aXRoIHRoZSByZXZlcnNlIHBhdGguXG4gIHZhciBmcm9udCA9ICh0ZXh0MV9sZW5ndGggKyB0ZXh0Ml9sZW5ndGgpICUgMjtcbiAgZm9yICh2YXIgZCA9IDA7IGQgPCBtYXhfZDsgZCsrKSB7XG4gICAgLy8gQmFpbCBvdXQgaWYgdGltZW91dCByZWFjaGVkLlxuICAgIGlmICh0aGlzLkRpZmZfVGltZW91dCA+IDAgJiYgKG5ldyBEYXRlKCkpLmdldFRpbWUoKSA+IG1zX2VuZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gV2FsayB0aGUgZnJvbnQgcGF0aCBvbmUgc3RlcC5cbiAgICB2X21hcDFbZF0gPSB7fTtcbiAgICBmb3IgKHZhciBrID0gLWQ7IGsgPD0gZDsgayArPSAyKSB7XG4gICAgICBpZiAoayA9PSAtZCB8fCBrICE9IGQgJiYgdjFbayAtIDFdIDwgdjFbayArIDFdKSB7XG4gICAgICAgIHggPSB2MVtrICsgMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gdjFbayAtIDFdICsgMTtcbiAgICAgIH1cbiAgICAgIHkgPSB4IC0gaztcbiAgICAgIGlmIChkb3VibGVFbmQpIHtcbiAgICAgICAgZm9vdHN0ZXAgPSB4ICsgJywnICsgeTtcbiAgICAgICAgaWYgKGZyb250ICYmIGZvb3RzdGVwc1tmb290c3RlcF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZnJvbnQpIHtcbiAgICAgICAgICBmb290c3RlcHNbZm9vdHN0ZXBdID0gZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKCFkb25lICYmIHggPCB0ZXh0MV9sZW5ndGggJiYgeSA8IHRleHQyX2xlbmd0aCAmJlxuICAgICAgICAgICAgIHRleHQxLmNoYXJBdCh4KSA9PSB0ZXh0Mi5jaGFyQXQoeSkpIHtcbiAgICAgICAgeCsrO1xuICAgICAgICB5Kys7XG4gICAgICAgIGlmIChkb3VibGVFbmQpIHtcbiAgICAgICAgICBmb290c3RlcCA9IHggKyAnLCcgKyB5O1xuICAgICAgICAgIGlmIChmcm9udCAmJiBmb290c3RlcHNbZm9vdHN0ZXBdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWZyb250KSB7XG4gICAgICAgICAgICBmb290c3RlcHNbZm9vdHN0ZXBdID0gZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHYxW2tdID0geDtcbiAgICAgIHZfbWFwMVtkXVt4ICsgJywnICsgeV0gPSB0cnVlO1xuICAgICAgaWYgKHggPT0gdGV4dDFfbGVuZ3RoICYmIHkgPT0gdGV4dDJfbGVuZ3RoKSB7XG4gICAgICAgIC8vIFJlYWNoZWQgdGhlIGVuZCBpbiBzaW5nbGUtcGF0aCBtb2RlLlxuICAgICAgICByZXR1cm4gdGhpcy5kaWZmX3BhdGgxKHZfbWFwMSwgdGV4dDEsIHRleHQyKTtcbiAgICAgIH0gZWxzZSBpZiAoZG9uZSkge1xuICAgICAgICAvLyBGcm9udCBwYXRoIHJhbiBvdmVyIHJldmVyc2UgcGF0aC5cbiAgICAgICAgdl9tYXAyID0gdl9tYXAyLnNsaWNlKDAsIGZvb3RzdGVwc1tmb290c3RlcF0gKyAxKTtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmRpZmZfcGF0aDEodl9tYXAxLCB0ZXh0MS5zdWJzdHJpbmcoMCwgeCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQyLnN1YnN0cmluZygwLCB5KSk7XG4gICAgICAgIHJldHVybiBhLmNvbmNhdCh0aGlzLmRpZmZfcGF0aDIodl9tYXAyLCB0ZXh0MS5zdWJzdHJpbmcoeCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDIuc3Vic3RyaW5nKHkpKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRvdWJsZUVuZCkge1xuICAgICAgLy8gV2FsayB0aGUgcmV2ZXJzZSBwYXRoIG9uZSBzdGVwLlxuICAgICAgdl9tYXAyW2RdID0ge307XG4gICAgICBmb3IgKHZhciBrID0gLWQ7IGsgPD0gZDsgayArPSAyKSB7XG4gICAgICAgIGlmIChrID09IC1kIHx8IGsgIT0gZCAmJiB2MltrIC0gMV0gPCB2MltrICsgMV0pIHtcbiAgICAgICAgICB4ID0gdjJbayArIDFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHggPSB2MltrIC0gMV0gKyAxO1xuICAgICAgICB9XG4gICAgICAgIHkgPSB4IC0gaztcbiAgICAgICAgZm9vdHN0ZXAgPSAodGV4dDFfbGVuZ3RoIC0geCkgKyAnLCcgKyAodGV4dDJfbGVuZ3RoIC0geSk7XG4gICAgICAgIGlmICghZnJvbnQgJiYgZm9vdHN0ZXBzW2Zvb3RzdGVwXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb250KSB7XG4gICAgICAgICAgZm9vdHN0ZXBzW2Zvb3RzdGVwXSA9IGQ7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKCFkb25lICYmIHggPCB0ZXh0MV9sZW5ndGggJiYgeSA8IHRleHQyX2xlbmd0aCAmJlxuICAgICAgICAgICAgICAgdGV4dDEuY2hhckF0KHRleHQxX2xlbmd0aCAtIHggLSAxKSA9PVxuICAgICAgICAgICAgICAgdGV4dDIuY2hhckF0KHRleHQyX2xlbmd0aCAtIHkgLSAxKSkge1xuICAgICAgICAgIHgrKztcbiAgICAgICAgICB5Kys7XG4gICAgICAgICAgZm9vdHN0ZXAgPSAodGV4dDFfbGVuZ3RoIC0geCkgKyAnLCcgKyAodGV4dDJfbGVuZ3RoIC0geSk7XG4gICAgICAgICAgaWYgKCFmcm9udCAmJiBmb290c3RlcHNbZm9vdHN0ZXBdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZnJvbnQpIHtcbiAgICAgICAgICAgIGZvb3RzdGVwc1tmb290c3RlcF0gPSBkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2MltrXSA9IHg7XG4gICAgICAgIHZfbWFwMltkXVt4ICsgJywnICsgeV0gPSB0cnVlO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIC8vIFJldmVyc2UgcGF0aCByYW4gb3ZlciBmcm9udCBwYXRoLlxuICAgICAgICAgIHZfbWFwMSA9IHZfbWFwMS5zbGljZSgwLCBmb290c3RlcHNbZm9vdHN0ZXBdICsgMSk7XG4gICAgICAgICAgdmFyIGEgPSB0aGlzLmRpZmZfcGF0aDEodl9tYXAxLCB0ZXh0MS5zdWJzdHJpbmcoMCwgdGV4dDFfbGVuZ3RoIC0geCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDIuc3Vic3RyaW5nKDAsIHRleHQyX2xlbmd0aCAtIHkpKTtcbiAgICAgICAgICByZXR1cm4gYS5jb25jYXQodGhpcy5kaWZmX3BhdGgyKHZfbWFwMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDEuc3Vic3RyaW5nKHRleHQxX2xlbmd0aCAtIHgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Mi5zdWJzdHJpbmcodGV4dDJfbGVuZ3RoIC0geSkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBOdW1iZXIgb2YgZGlmZnMgZXF1YWxzIG51bWJlciBvZiBjaGFyYWN0ZXJzLCBubyBjb21tb25hbGl0eSBhdCBhbGwuXG4gIHJldHVybiBudWxsO1xufTtcblxuXG4vKipcbiAqIFdvcmsgZnJvbSB0aGUgbWlkZGxlIGJhY2sgdG8gdGhlIHN0YXJ0IHRvIGRldGVybWluZSB0aGUgcGF0aC5cbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IHZfbWFwIEFycmF5IG9mIHBhdGhzLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIE9sZCBzdHJpbmcgZnJhZ21lbnQgdG8gYmUgZGlmZmVkLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIE5ldyBzdHJpbmcgZnJhZ21lbnQgdG8gYmUgZGlmZmVkLlxuICogQHJldHVybiB7QXJyYXkuPEFycmF5LjxudW1iZXJ8c3RyaW5nPj59IEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICogQHByaXZhdGVcbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9wYXRoMSA9IGZ1bmN0aW9uKHZfbWFwLCB0ZXh0MSwgdGV4dDIpIHtcbiAgdmFyIHBhdGggPSBbXTtcbiAgdmFyIHggPSB0ZXh0MS5sZW5ndGg7XG4gIHZhciB5ID0gdGV4dDIubGVuZ3RoO1xuICAvKiogQHR5cGUgez9udW1iZXJ9ICovXG4gIHZhciBsYXN0X29wID0gbnVsbDtcbiAgZm9yICh2YXIgZCA9IHZfbWFwLmxlbmd0aCAtIDI7IGQgPj0gMDsgZC0tKSB7XG4gICAgd2hpbGUgKDEpIHtcbiAgICAgIGlmICh2X21hcFtkXVsoeCAtIDEpICsgJywnICsgeV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB4LS07XG4gICAgICAgIGlmIChsYXN0X29wID09PSBESUZGX0RFTEVURSkge1xuICAgICAgICAgIHBhdGhbMF1bMV0gPSB0ZXh0MS5jaGFyQXQoeCkgKyBwYXRoWzBdWzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGgudW5zaGlmdChbRElGRl9ERUxFVEUsIHRleHQxLmNoYXJBdCh4KV0pO1xuICAgICAgICB9XG4gICAgICAgIGxhc3Rfb3AgPSBESUZGX0RFTEVURTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKHZfbWFwW2RdW3ggKyAnLCcgKyAoeSAtIDEpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHktLTtcbiAgICAgICAgaWYgKGxhc3Rfb3AgPT09IERJRkZfSU5TRVJUKSB7XG4gICAgICAgICAgcGF0aFswXVsxXSA9IHRleHQyLmNoYXJBdCh5KSArIHBhdGhbMF1bMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aC51bnNoaWZ0KFtESUZGX0lOU0VSVCwgdGV4dDIuY2hhckF0KHkpXSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdF9vcCA9IERJRkZfSU5TRVJUO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgtLTtcbiAgICAgICAgeS0tO1xuICAgICAgICBpZiAodGV4dDEuY2hhckF0KHgpICE9IHRleHQyLmNoYXJBdCh5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZGlhZ29uYWwuICBDYW5cXCd0IGhhcHBlbi4gKGRpZmZfcGF0aDEpJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3Rfb3AgPT09IERJRkZfRVFVQUwpIHtcbiAgICAgICAgICBwYXRoWzBdWzFdID0gdGV4dDEuY2hhckF0KHgpICsgcGF0aFswXVsxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRoLnVuc2hpZnQoW0RJRkZfRVFVQUwsIHRleHQxLmNoYXJBdCh4KV0pO1xuICAgICAgICB9XG4gICAgICAgIGxhc3Rfb3AgPSBESUZGX0VRVUFMO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcGF0aDtcbn07XG5cblxuLyoqXG4gKiBXb3JrIGZyb20gdGhlIG1pZGRsZSBiYWNrIHRvIHRoZSBlbmQgdG8gZGV0ZXJtaW5lIHRoZSBwYXRoLlxuICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gdl9tYXAgQXJyYXkgb2YgcGF0aHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgT2xkIHN0cmluZyBmcmFnbWVudCB0byBiZSBkaWZmZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgTmV3IHN0cmluZyBmcmFnbWVudCB0byBiZSBkaWZmZWQuXG4gKiBAcmV0dXJuIHtBcnJheS48QXJyYXkuPG51bWJlcnxzdHJpbmc+Pn0gQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX3BhdGgyID0gZnVuY3Rpb24odl9tYXAsIHRleHQxLCB0ZXh0Mikge1xuICB2YXIgcGF0aCA9IFtdO1xuICB2YXIgcGF0aExlbmd0aCA9IDA7XG4gIHZhciB4ID0gdGV4dDEubGVuZ3RoO1xuICB2YXIgeSA9IHRleHQyLmxlbmd0aDtcbiAgLyoqIEB0eXBlIHs/bnVtYmVyfSAqL1xuICB2YXIgbGFzdF9vcCA9IG51bGw7XG4gIGZvciAodmFyIGQgPSB2X21hcC5sZW5ndGggLSAyOyBkID49IDA7IGQtLSkge1xuICAgIHdoaWxlICgxKSB7XG4gICAgICBpZiAodl9tYXBbZF1bKHggLSAxKSArICcsJyArIHldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgeC0tO1xuICAgICAgICBpZiAobGFzdF9vcCA9PT0gRElGRl9ERUxFVEUpIHtcbiAgICAgICAgICBwYXRoW3BhdGhMZW5ndGggLSAxXVsxXSArPSB0ZXh0MS5jaGFyQXQodGV4dDEubGVuZ3RoIC0geCAtIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGhbcGF0aExlbmd0aCsrXSA9XG4gICAgICAgICAgICAgIFtESUZGX0RFTEVURSwgdGV4dDEuY2hhckF0KHRleHQxLmxlbmd0aCAtIHggLSAxKV07XG4gICAgICAgIH1cbiAgICAgICAgbGFzdF9vcCA9IERJRkZfREVMRVRFO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAodl9tYXBbZF1beCArICcsJyArICh5IC0gMSldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgeS0tO1xuICAgICAgICBpZiAobGFzdF9vcCA9PT0gRElGRl9JTlNFUlQpIHtcbiAgICAgICAgICBwYXRoW3BhdGhMZW5ndGggLSAxXVsxXSArPSB0ZXh0Mi5jaGFyQXQodGV4dDIubGVuZ3RoIC0geSAtIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGhbcGF0aExlbmd0aCsrXSA9XG4gICAgICAgICAgICAgIFtESUZGX0lOU0VSVCwgdGV4dDIuY2hhckF0KHRleHQyLmxlbmd0aCAtIHkgLSAxKV07XG4gICAgICAgIH1cbiAgICAgICAgbGFzdF9vcCA9IERJRkZfSU5TRVJUO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgtLTtcbiAgICAgICAgeS0tO1xuICAgICAgICBpZiAodGV4dDEuY2hhckF0KHRleHQxLmxlbmd0aCAtIHggLSAxKSAhPVxuICAgICAgICAgICAgdGV4dDIuY2hhckF0KHRleHQyLmxlbmd0aCAtIHkgLSAxKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZGlhZ29uYWwuICBDYW5cXCd0IGhhcHBlbi4gKGRpZmZfcGF0aDIpJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3Rfb3AgPT09IERJRkZfRVFVQUwpIHtcbiAgICAgICAgICBwYXRoW3BhdGhMZW5ndGggLSAxXVsxXSArPSB0ZXh0MS5jaGFyQXQodGV4dDEubGVuZ3RoIC0geCAtIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGhbcGF0aExlbmd0aCsrXSA9XG4gICAgICAgICAgICAgIFtESUZGX0VRVUFMLCB0ZXh0MS5jaGFyQXQodGV4dDEubGVuZ3RoIC0geCAtIDEpXTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0X29wID0gRElGRl9FUVVBTDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59O1xuXG5cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSBjb21tb24gcHJlZml4IG9mIHR3byBzdHJpbmdzXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgRmlyc3Qgc3RyaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIFNlY29uZCBzdHJpbmcuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBjb21tb24gdG8gdGhlIHN0YXJ0IG9mIGVhY2hcbiAqICAgICBzdHJpbmcuXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfY29tbW9uUHJlZml4ID0gZnVuY3Rpb24odGV4dDEsIHRleHQyKSB7XG4gIC8vIFF1aWNrIGNoZWNrIGZvciBjb21tb24gbnVsbCBjYXNlcy5cbiAgaWYgKCF0ZXh0MSB8fCAhdGV4dDIgfHwgdGV4dDEuY2hhckF0KDApICE9IHRleHQyLmNoYXJBdCgwKSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIC8vIEJpbmFyeSBzZWFyY2guXG4gIC8vIFBlcmZvcm1hbmNlIGFuYWx5c2lzOiBodHRwOi8vbmVpbC5mcmFzZXIubmFtZS9uZXdzLzIwMDcvMTAvMDkvXG4gIHZhciBwb2ludGVybWluID0gMDtcbiAgdmFyIHBvaW50ZXJtYXggPSBNYXRoLm1pbih0ZXh0MS5sZW5ndGgsIHRleHQyLmxlbmd0aCk7XG4gIHZhciBwb2ludGVybWlkID0gcG9pbnRlcm1heDtcbiAgdmFyIHBvaW50ZXJzdGFydCA9IDA7XG4gIHdoaWxlIChwb2ludGVybWluIDwgcG9pbnRlcm1pZCkge1xuICAgIGlmICh0ZXh0MS5zdWJzdHJpbmcocG9pbnRlcnN0YXJ0LCBwb2ludGVybWlkKSA9PVxuICAgICAgICB0ZXh0Mi5zdWJzdHJpbmcocG9pbnRlcnN0YXJ0LCBwb2ludGVybWlkKSkge1xuICAgICAgcG9pbnRlcm1pbiA9IHBvaW50ZXJtaWQ7XG4gICAgICBwb2ludGVyc3RhcnQgPSBwb2ludGVybWluO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludGVybWF4ID0gcG9pbnRlcm1pZDtcbiAgICB9XG4gICAgcG9pbnRlcm1pZCA9IE1hdGguZmxvb3IoKHBvaW50ZXJtYXggLSBwb2ludGVybWluKSAvIDIgKyBwb2ludGVybWluKTtcbiAgfVxuICByZXR1cm4gcG9pbnRlcm1pZDtcbn07XG5cblxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIGNvbW1vbiBzdWZmaXggb2YgdHdvIHN0cmluZ3NcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBGaXJzdCBzdHJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgU2Vjb25kIHN0cmluZy5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGNvbW1vbiB0byB0aGUgZW5kIG9mIGVhY2ggc3RyaW5nLlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2NvbW1vblN1ZmZpeCA9IGZ1bmN0aW9uKHRleHQxLCB0ZXh0Mikge1xuICAvLyBRdWljayBjaGVjayBmb3IgY29tbW9uIG51bGwgY2FzZXMuXG4gIGlmICghdGV4dDEgfHwgIXRleHQyIHx8IHRleHQxLmNoYXJBdCh0ZXh0MS5sZW5ndGggLSAxKSAhPVxuICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Mi5jaGFyQXQodGV4dDIubGVuZ3RoIC0gMSkpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICAvLyBCaW5hcnkgc2VhcmNoLlxuICAvLyBQZXJmb3JtYW5jZSBhbmFseXNpczogaHR0cDovL25laWwuZnJhc2VyLm5hbWUvbmV3cy8yMDA3LzEwLzA5L1xuICB2YXIgcG9pbnRlcm1pbiA9IDA7XG4gIHZhciBwb2ludGVybWF4ID0gTWF0aC5taW4odGV4dDEubGVuZ3RoLCB0ZXh0Mi5sZW5ndGgpO1xuICB2YXIgcG9pbnRlcm1pZCA9IHBvaW50ZXJtYXg7XG4gIHZhciBwb2ludGVyZW5kID0gMDtcbiAgd2hpbGUgKHBvaW50ZXJtaW4gPCBwb2ludGVybWlkKSB7XG4gICAgaWYgKHRleHQxLnN1YnN0cmluZyh0ZXh0MS5sZW5ndGggLSBwb2ludGVybWlkLCB0ZXh0MS5sZW5ndGggLSBwb2ludGVyZW5kKSA9PVxuICAgICAgICB0ZXh0Mi5zdWJzdHJpbmcodGV4dDIubGVuZ3RoIC0gcG9pbnRlcm1pZCwgdGV4dDIubGVuZ3RoIC0gcG9pbnRlcmVuZCkpIHtcbiAgICAgIHBvaW50ZXJtaW4gPSBwb2ludGVybWlkO1xuICAgICAgcG9pbnRlcmVuZCA9IHBvaW50ZXJtaW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50ZXJtYXggPSBwb2ludGVybWlkO1xuICAgIH1cbiAgICBwb2ludGVybWlkID0gTWF0aC5mbG9vcigocG9pbnRlcm1heCAtIHBvaW50ZXJtaW4pIC8gMiArIHBvaW50ZXJtaW4pO1xuICB9XG4gIHJldHVybiBwb2ludGVybWlkO1xufTtcblxuXG4vKipcbiAqIERvIHRoZSB0d28gdGV4dHMgc2hhcmUgYSBzdWJzdHJpbmcgd2hpY2ggaXMgYXQgbGVhc3QgaGFsZiB0aGUgbGVuZ3RoIG9mIHRoZVxuICogbG9uZ2VyIHRleHQ/XG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgRmlyc3Qgc3RyaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIFNlY29uZCBzdHJpbmcuXG4gKiBAcmV0dXJuIHs/QXJyYXkuPHN0cmluZz59IEZpdmUgZWxlbWVudCBBcnJheSwgY29udGFpbmluZyB0aGUgcHJlZml4IG9mXG4gKiAgICAgdGV4dDEsIHRoZSBzdWZmaXggb2YgdGV4dDEsIHRoZSBwcmVmaXggb2YgdGV4dDIsIHRoZSBzdWZmaXggb2ZcbiAqICAgICB0ZXh0MiBhbmQgdGhlIGNvbW1vbiBtaWRkbGUuICBPciBudWxsIGlmIHRoZXJlIHdhcyBubyBtYXRjaC5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9oYWxmTWF0Y2ggPSBmdW5jdGlvbih0ZXh0MSwgdGV4dDIpIHtcbiAgdmFyIGxvbmd0ZXh0ID0gdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gdGV4dDEgOiB0ZXh0MjtcbiAgdmFyIHNob3J0dGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQyIDogdGV4dDE7XG4gIGlmIChsb25ndGV4dC5sZW5ndGggPCAxMCB8fCBzaG9ydHRleHQubGVuZ3RoIDwgMSkge1xuICAgIHJldHVybiBudWxsOyAgLy8gUG9pbnRsZXNzLlxuICB9XG4gIHZhciBkbXAgPSB0aGlzOyAgLy8gJ3RoaXMnIGJlY29tZXMgJ3dpbmRvdycgaW4gYSBjbG9zdXJlLlxuXG4gIC8qKlxuICAgKiBEb2VzIGEgc3Vic3RyaW5nIG9mIHNob3J0dGV4dCBleGlzdCB3aXRoaW4gbG9uZ3RleHQgc3VjaCB0aGF0IHRoZSBzdWJzdHJpbmdcbiAgICogaXMgYXQgbGVhc3QgaGFsZiB0aGUgbGVuZ3RoIG9mIGxvbmd0ZXh0P1xuICAgKiBDbG9zdXJlLCBidXQgZG9lcyBub3QgcmVmZXJlbmNlIGFueSBleHRlcm5hbCB2YXJpYWJsZXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsb25ndGV4dCBMb25nZXIgc3RyaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2hvcnR0ZXh0IFNob3J0ZXIgc3RyaW5nLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaSBTdGFydCBpbmRleCBvZiBxdWFydGVyIGxlbmd0aCBzdWJzdHJpbmcgd2l0aGluIGxvbmd0ZXh0XG4gICAqIEByZXR1cm4gez9BcnJheS48c3RyaW5nPn0gRml2ZSBlbGVtZW50IEFycmF5LCBjb250YWluaW5nIHRoZSBwcmVmaXggb2ZcbiAgICogICAgIGxvbmd0ZXh0LCB0aGUgc3VmZml4IG9mIGxvbmd0ZXh0LCB0aGUgcHJlZml4IG9mIHNob3J0dGV4dCwgdGhlIHN1ZmZpeFxuICAgKiAgICAgb2Ygc2hvcnR0ZXh0IGFuZCB0aGUgY29tbW9uIG1pZGRsZS4gIE9yIG51bGwgaWYgdGhlcmUgd2FzIG5vIG1hdGNoLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZGlmZl9oYWxmTWF0Y2hJKGxvbmd0ZXh0LCBzaG9ydHRleHQsIGkpIHtcbiAgICAvLyBTdGFydCB3aXRoIGEgMS80IGxlbmd0aCBzdWJzdHJpbmcgYXQgcG9zaXRpb24gaSBhcyBhIHNlZWQuXG4gICAgdmFyIHNlZWQgPSBsb25ndGV4dC5zdWJzdHJpbmcoaSwgaSArIE1hdGguZmxvb3IobG9uZ3RleHQubGVuZ3RoIC8gNCkpO1xuICAgIHZhciBqID0gLTE7XG4gICAgdmFyIGJlc3RfY29tbW9uID0gJyc7XG4gICAgdmFyIGJlc3RfbG9uZ3RleHRfYSwgYmVzdF9sb25ndGV4dF9iLCBiZXN0X3Nob3J0dGV4dF9hLCBiZXN0X3Nob3J0dGV4dF9iO1xuICAgIHdoaWxlICgoaiA9IHNob3J0dGV4dC5pbmRleE9mKHNlZWQsIGogKyAxKSkgIT0gLTEpIHtcbiAgICAgIHZhciBwcmVmaXhMZW5ndGggPSBkbXAuZGlmZl9jb21tb25QcmVmaXgobG9uZ3RleHQuc3Vic3RyaW5nKGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG9ydHRleHQuc3Vic3RyaW5nKGopKTtcbiAgICAgIHZhciBzdWZmaXhMZW5ndGggPSBkbXAuZGlmZl9jb21tb25TdWZmaXgobG9uZ3RleHQuc3Vic3RyaW5nKDAsIGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG9ydHRleHQuc3Vic3RyaW5nKDAsIGopKTtcbiAgICAgIGlmIChiZXN0X2NvbW1vbi5sZW5ndGggPCBzdWZmaXhMZW5ndGggKyBwcmVmaXhMZW5ndGgpIHtcbiAgICAgICAgYmVzdF9jb21tb24gPSBzaG9ydHRleHQuc3Vic3RyaW5nKGogLSBzdWZmaXhMZW5ndGgsIGopICtcbiAgICAgICAgICAgIHNob3J0dGV4dC5zdWJzdHJpbmcoaiwgaiArIHByZWZpeExlbmd0aCk7XG4gICAgICAgIGJlc3RfbG9uZ3RleHRfYSA9IGxvbmd0ZXh0LnN1YnN0cmluZygwLCBpIC0gc3VmZml4TGVuZ3RoKTtcbiAgICAgICAgYmVzdF9sb25ndGV4dF9iID0gbG9uZ3RleHQuc3Vic3RyaW5nKGkgKyBwcmVmaXhMZW5ndGgpO1xuICAgICAgICBiZXN0X3Nob3J0dGV4dF9hID0gc2hvcnR0ZXh0LnN1YnN0cmluZygwLCBqIC0gc3VmZml4TGVuZ3RoKTtcbiAgICAgICAgYmVzdF9zaG9ydHRleHRfYiA9IHNob3J0dGV4dC5zdWJzdHJpbmcoaiArIHByZWZpeExlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChiZXN0X2NvbW1vbi5sZW5ndGggPj0gbG9uZ3RleHQubGVuZ3RoIC8gMikge1xuICAgICAgcmV0dXJuIFtiZXN0X2xvbmd0ZXh0X2EsIGJlc3RfbG9uZ3RleHRfYixcbiAgICAgICAgICAgICAgYmVzdF9zaG9ydHRleHRfYSwgYmVzdF9zaG9ydHRleHRfYiwgYmVzdF9jb21tb25dO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvLyBGaXJzdCBjaGVjayBpZiB0aGUgc2Vjb25kIHF1YXJ0ZXIgaXMgdGhlIHNlZWQgZm9yIGEgaGFsZi1tYXRjaC5cbiAgdmFyIGhtMSA9IGRpZmZfaGFsZk1hdGNoSShsb25ndGV4dCwgc2hvcnR0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguY2VpbChsb25ndGV4dC5sZW5ndGggLyA0KSk7XG4gIC8vIENoZWNrIGFnYWluIGJhc2VkIG9uIHRoZSB0aGlyZCBxdWFydGVyLlxuICB2YXIgaG0yID0gZGlmZl9oYWxmTWF0Y2hJKGxvbmd0ZXh0LCBzaG9ydHRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5jZWlsKGxvbmd0ZXh0Lmxlbmd0aCAvIDIpKTtcbiAgdmFyIGhtO1xuICBpZiAoIWhtMSAmJiAhaG0yKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAoIWhtMikge1xuICAgIGhtID0gaG0xO1xuICB9IGVsc2UgaWYgKCFobTEpIHtcbiAgICBobSA9IGhtMjtcbiAgfSBlbHNlIHtcbiAgICAvLyBCb3RoIG1hdGNoZWQuICBTZWxlY3QgdGhlIGxvbmdlc3QuXG4gICAgaG0gPSBobTFbNF0ubGVuZ3RoID4gaG0yWzRdLmxlbmd0aCA/IGhtMSA6IGhtMjtcbiAgfVxuXG4gIC8vIEEgaGFsZi1tYXRjaCB3YXMgZm91bmQsIHNvcnQgb3V0IHRoZSByZXR1cm4gZGF0YS5cbiAgdmFyIHRleHQxX2EsIHRleHQxX2IsIHRleHQyX2EsIHRleHQyX2I7XG4gIGlmICh0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGgpIHtcbiAgICB0ZXh0MV9hID0gaG1bMF07XG4gICAgdGV4dDFfYiA9IGhtWzFdO1xuICAgIHRleHQyX2EgPSBobVsyXTtcbiAgICB0ZXh0Ml9iID0gaG1bM107XG4gIH0gZWxzZSB7XG4gICAgdGV4dDJfYSA9IGhtWzBdO1xuICAgIHRleHQyX2IgPSBobVsxXTtcbiAgICB0ZXh0MV9hID0gaG1bMl07XG4gICAgdGV4dDFfYiA9IGhtWzNdO1xuICB9XG4gIHZhciBtaWRfY29tbW9uID0gaG1bNF07XG4gIHJldHVybiBbdGV4dDFfYSwgdGV4dDFfYiwgdGV4dDJfYSwgdGV4dDJfYiwgbWlkX2NvbW1vbl07XG59O1xuXG5cbi8qKlxuICogUmVkdWNlIHRoZSBudW1iZXIgb2YgZWRpdHMgYnkgZWxpbWluYXRpbmcgc2VtYW50aWNhbGx5IHRyaXZpYWwgZXF1YWxpdGllcy5cbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXJ8c3RyaW5nPj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2NsZWFudXBTZW1hbnRpYyA9IGZ1bmN0aW9uKGRpZmZzKSB7XG4gIHZhciBjaGFuZ2VzID0gZmFsc2U7XG4gIHZhciBlcXVhbGl0aWVzID0gW107ICAvLyBTdGFjayBvZiBpbmRpY2VzIHdoZXJlIGVxdWFsaXRpZXMgYXJlIGZvdW5kLlxuICB2YXIgZXF1YWxpdGllc0xlbmd0aCA9IDA7ICAvLyBLZWVwaW5nIG91ciBvd24gbGVuZ3RoIHZhciBpcyBmYXN0ZXIgaW4gSlMuXG4gIHZhciBsYXN0ZXF1YWxpdHkgPSBudWxsOyAgLy8gQWx3YXlzIGVxdWFsIHRvIGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aC0xXVsxXVxuICB2YXIgcG9pbnRlciA9IDA7ICAvLyBJbmRleCBvZiBjdXJyZW50IHBvc2l0aW9uLlxuICAvLyBOdW1iZXIgb2YgY2hhcmFjdGVycyB0aGF0IGNoYW5nZWQgcHJpb3IgdG8gdGhlIGVxdWFsaXR5LlxuICB2YXIgbGVuZ3RoX2NoYW5nZXMxID0gMDtcbiAgLy8gTnVtYmVyIG9mIGNoYXJhY3RlcnMgdGhhdCBjaGFuZ2VkIGFmdGVyIHRoZSBlcXVhbGl0eS5cbiAgdmFyIGxlbmd0aF9jaGFuZ2VzMiA9IDA7XG4gIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoKSB7XG4gICAgaWYgKGRpZmZzW3BvaW50ZXJdWzBdID09IERJRkZfRVFVQUwpIHsgIC8vIGVxdWFsaXR5IGZvdW5kXG4gICAgICBlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGgrK10gPSBwb2ludGVyO1xuICAgICAgbGVuZ3RoX2NoYW5nZXMxID0gbGVuZ3RoX2NoYW5nZXMyO1xuICAgICAgbGVuZ3RoX2NoYW5nZXMyID0gMDtcbiAgICAgIGxhc3RlcXVhbGl0eSA9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgIH0gZWxzZSB7ICAvLyBhbiBpbnNlcnRpb24gb3IgZGVsZXRpb25cbiAgICAgIGxlbmd0aF9jaGFuZ2VzMiArPSBkaWZmc1twb2ludGVyXVsxXS5sZW5ndGg7XG4gICAgICBpZiAobGFzdGVxdWFsaXR5ICE9PSBudWxsICYmIChsYXN0ZXF1YWxpdHkubGVuZ3RoIDw9IGxlbmd0aF9jaGFuZ2VzMSkgJiZcbiAgICAgICAgICAobGFzdGVxdWFsaXR5Lmxlbmd0aCA8PSBsZW5ndGhfY2hhbmdlczIpKSB7XG4gICAgICAgIC8vIER1cGxpY2F0ZSByZWNvcmRcbiAgICAgICAgZGlmZnMuc3BsaWNlKGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdLCAwLFxuICAgICAgICAgICAgICAgICAgICAgW0RJRkZfREVMRVRFLCBsYXN0ZXF1YWxpdHldKTtcbiAgICAgICAgLy8gQ2hhbmdlIHNlY29uZCBjb3B5IHRvIGluc2VydC5cbiAgICAgICAgZGlmZnNbZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0gKyAxXVswXSA9IERJRkZfSU5TRVJUO1xuICAgICAgICAvLyBUaHJvdyBhd2F5IHRoZSBlcXVhbGl0eSB3ZSBqdXN0IGRlbGV0ZWQuXG4gICAgICAgIGVxdWFsaXRpZXNMZW5ndGgtLTtcbiAgICAgICAgLy8gVGhyb3cgYXdheSB0aGUgcHJldmlvdXMgZXF1YWxpdHkgKGl0IG5lZWRzIHRvIGJlIHJlZXZhbHVhdGVkKS5cbiAgICAgICAgZXF1YWxpdGllc0xlbmd0aC0tO1xuICAgICAgICBwb2ludGVyID0gZXF1YWxpdGllc0xlbmd0aCA+IDAgPyBlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSA6IC0xO1xuICAgICAgICBsZW5ndGhfY2hhbmdlczEgPSAwOyAgLy8gUmVzZXQgdGhlIGNvdW50ZXJzLlxuICAgICAgICBsZW5ndGhfY2hhbmdlczIgPSAwO1xuICAgICAgICBsYXN0ZXF1YWxpdHkgPSBudWxsO1xuICAgICAgICBjaGFuZ2VzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcG9pbnRlcisrO1xuICB9XG4gIGlmIChjaGFuZ2VzKSB7XG4gICAgdGhpcy5kaWZmX2NsZWFudXBNZXJnZShkaWZmcyk7XG4gIH1cbiAgdGhpcy5kaWZmX2NsZWFudXBTZW1hbnRpY0xvc3NsZXNzKGRpZmZzKTtcbn07XG5cblxuLyoqXG4gKiBMb29rIGZvciBzaW5nbGUgZWRpdHMgc3Vycm91bmRlZCBvbiBib3RoIHNpZGVzIGJ5IGVxdWFsaXRpZXNcbiAqIHdoaWNoIGNhbiBiZSBzaGlmdGVkIHNpZGV3YXlzIHRvIGFsaWduIHRoZSBlZGl0IHRvIGEgd29yZCBib3VuZGFyeS5cbiAqIGUuZzogVGhlIGM8aW5zPmF0IGM8L2lucz5hbWUuIC0+IFRoZSA8aW5zPmNhdCA8L2lucz5jYW1lLlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcnxzdHJpbmc+Pn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfY2xlYW51cFNlbWFudGljTG9zc2xlc3MgPSBmdW5jdGlvbihkaWZmcykge1xuICAvLyBEZWZpbmUgc29tZSByZWdleCBwYXR0ZXJucyBmb3IgbWF0Y2hpbmcgYm91bmRhcmllcy5cbiAgdmFyIHB1bmN0dWF0aW9uID0gL1teYS16QS1aMC05XS87XG4gIHZhciB3aGl0ZXNwYWNlID0gL1xccy87XG4gIHZhciBsaW5lYnJlYWsgPSAvW1xcclxcbl0vO1xuICB2YXIgYmxhbmtsaW5lRW5kID0gL1xcblxccj9cXG4kLztcbiAgdmFyIGJsYW5rbGluZVN0YXJ0ID0gL15cXHI/XFxuXFxyP1xcbi87XG5cbiAgLyoqXG4gICAqIEdpdmVuIHR3byBzdHJpbmdzLCBjb21wdXRlIGEgc2NvcmUgcmVwcmVzZW50aW5nIHdoZXRoZXIgdGhlIGludGVybmFsXG4gICAqIGJvdW5kYXJ5IGZhbGxzIG9uIGxvZ2ljYWwgYm91bmRhcmllcy5cbiAgICogU2NvcmVzIHJhbmdlIGZyb20gNSAoYmVzdCkgdG8gMCAod29yc3QpLlxuICAgKiBDbG9zdXJlLCBtYWtlcyByZWZlcmVuY2UgdG8gcmVnZXggcGF0dGVybnMgZGVmaW5lZCBhYm92ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9uZSBGaXJzdCBzdHJpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0d28gU2Vjb25kIHN0cmluZy5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgc2NvcmUuXG4gICAqL1xuICBmdW5jdGlvbiBkaWZmX2NsZWFudXBTZW1hbnRpY1Njb3JlKG9uZSwgdHdvKSB7XG4gICAgaWYgKCFvbmUgfHwgIXR3bykge1xuICAgICAgLy8gRWRnZXMgYXJlIHRoZSBiZXN0LlxuICAgICAgcmV0dXJuIDU7XG4gICAgfVxuXG4gICAgLy8gRWFjaCBwb3J0IG9mIHRoaXMgZnVuY3Rpb24gYmVoYXZlcyBzbGlnaHRseSBkaWZmZXJlbnRseSBkdWUgdG9cbiAgICAvLyBzdWJ0bGUgZGlmZmVyZW5jZXMgaW4gZWFjaCBsYW5ndWFnZSdzIGRlZmluaXRpb24gb2YgdGhpbmdzIGxpa2VcbiAgICAvLyAnd2hpdGVzcGFjZScuICBTaW5jZSB0aGlzIGZ1bmN0aW9uJ3MgcHVycG9zZSBpcyBsYXJnZWx5IGNvc21ldGljLFxuICAgIC8vIHRoZSBjaG9pY2UgaGFzIGJlZW4gbWFkZSB0byB1c2UgZWFjaCBsYW5ndWFnZSdzIG5hdGl2ZSBmZWF0dXJlc1xuICAgIC8vIHJhdGhlciB0aGFuIGZvcmNlIHRvdGFsIGNvbmZvcm1pdHkuXG4gICAgdmFyIHNjb3JlID0gMDtcbiAgICAvLyBPbmUgcG9pbnQgZm9yIG5vbi1hbHBoYW51bWVyaWMuXG4gICAgaWYgKG9uZS5jaGFyQXQob25lLmxlbmd0aCAtIDEpLm1hdGNoKHB1bmN0dWF0aW9uKSB8fFxuICAgICAgICB0d28uY2hhckF0KDApLm1hdGNoKHB1bmN0dWF0aW9uKSkge1xuICAgICAgc2NvcmUrKztcbiAgICAgIC8vIFR3byBwb2ludHMgZm9yIHdoaXRlc3BhY2UuXG4gICAgICBpZiAob25lLmNoYXJBdChvbmUubGVuZ3RoIC0gMSkubWF0Y2god2hpdGVzcGFjZSkgfHxcbiAgICAgICAgICB0d28uY2hhckF0KDApLm1hdGNoKHdoaXRlc3BhY2UpKSB7XG4gICAgICAgIHNjb3JlKys7XG4gICAgICAgIC8vIFRocmVlIHBvaW50cyBmb3IgbGluZSBicmVha3MuXG4gICAgICAgIGlmIChvbmUuY2hhckF0KG9uZS5sZW5ndGggLSAxKS5tYXRjaChsaW5lYnJlYWspIHx8XG4gICAgICAgICAgICB0d28uY2hhckF0KDApLm1hdGNoKGxpbmVicmVhaykpIHtcbiAgICAgICAgICBzY29yZSsrO1xuICAgICAgICAgIC8vIEZvdXIgcG9pbnRzIGZvciBibGFuayBsaW5lcy5cbiAgICAgICAgICBpZiAob25lLm1hdGNoKGJsYW5rbGluZUVuZCkgfHwgdHdvLm1hdGNoKGJsYW5rbGluZVN0YXJ0KSkge1xuICAgICAgICAgICAgc2NvcmUrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNjb3JlO1xuICB9XG5cbiAgdmFyIHBvaW50ZXIgPSAxO1xuICAvLyBJbnRlbnRpb25hbGx5IGlnbm9yZSB0aGUgZmlyc3QgYW5kIGxhc3QgZWxlbWVudCAoZG9uJ3QgbmVlZCBjaGVja2luZykuXG4gIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoIC0gMSkge1xuICAgIGlmIChkaWZmc1twb2ludGVyIC0gMV1bMF0gPT0gRElGRl9FUVVBTCAmJlxuICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMF0gPT0gRElGRl9FUVVBTCkge1xuICAgICAgLy8gVGhpcyBpcyBhIHNpbmdsZSBlZGl0IHN1cnJvdW5kZWQgYnkgZXF1YWxpdGllcy5cbiAgICAgIHZhciBlcXVhbGl0eTEgPSBkaWZmc1twb2ludGVyIC0gMV1bMV07XG4gICAgICB2YXIgZWRpdCA9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgdmFyIGVxdWFsaXR5MiA9IGRpZmZzW3BvaW50ZXIgKyAxXVsxXTtcblxuICAgICAgLy8gRmlyc3QsIHNoaWZ0IHRoZSBlZGl0IGFzIGZhciBsZWZ0IGFzIHBvc3NpYmxlLlxuICAgICAgdmFyIGNvbW1vbk9mZnNldCA9IHRoaXMuZGlmZl9jb21tb25TdWZmaXgoZXF1YWxpdHkxLCBlZGl0KTtcbiAgICAgIGlmIChjb21tb25PZmZzZXQpIHtcbiAgICAgICAgdmFyIGNvbW1vblN0cmluZyA9IGVkaXQuc3Vic3RyaW5nKGVkaXQubGVuZ3RoIC0gY29tbW9uT2Zmc2V0KTtcbiAgICAgICAgZXF1YWxpdHkxID0gZXF1YWxpdHkxLnN1YnN0cmluZygwLCBlcXVhbGl0eTEubGVuZ3RoIC0gY29tbW9uT2Zmc2V0KTtcbiAgICAgICAgZWRpdCA9IGNvbW1vblN0cmluZyArIGVkaXQuc3Vic3RyaW5nKDAsIGVkaXQubGVuZ3RoIC0gY29tbW9uT2Zmc2V0KTtcbiAgICAgICAgZXF1YWxpdHkyID0gY29tbW9uU3RyaW5nICsgZXF1YWxpdHkyO1xuICAgICAgfVxuXG4gICAgICAvLyBTZWNvbmQsIHN0ZXAgY2hhcmFjdGVyIGJ5IGNoYXJhY3RlciByaWdodCwgbG9va2luZyBmb3IgdGhlIGJlc3QgZml0LlxuICAgICAgdmFyIGJlc3RFcXVhbGl0eTEgPSBlcXVhbGl0eTE7XG4gICAgICB2YXIgYmVzdEVkaXQgPSBlZGl0O1xuICAgICAgdmFyIGJlc3RFcXVhbGl0eTIgPSBlcXVhbGl0eTI7XG4gICAgICB2YXIgYmVzdFNjb3JlID0gZGlmZl9jbGVhbnVwU2VtYW50aWNTY29yZShlcXVhbGl0eTEsIGVkaXQpICtcbiAgICAgICAgICBkaWZmX2NsZWFudXBTZW1hbnRpY1Njb3JlKGVkaXQsIGVxdWFsaXR5Mik7XG4gICAgICB3aGlsZSAoZWRpdC5jaGFyQXQoMCkgPT09IGVxdWFsaXR5Mi5jaGFyQXQoMCkpIHtcbiAgICAgICAgZXF1YWxpdHkxICs9IGVkaXQuY2hhckF0KDApO1xuICAgICAgICBlZGl0ID0gZWRpdC5zdWJzdHJpbmcoMSkgKyBlcXVhbGl0eTIuY2hhckF0KDApO1xuICAgICAgICBlcXVhbGl0eTIgPSBlcXVhbGl0eTIuc3Vic3RyaW5nKDEpO1xuICAgICAgICB2YXIgc2NvcmUgPSBkaWZmX2NsZWFudXBTZW1hbnRpY1Njb3JlKGVxdWFsaXR5MSwgZWRpdCkgK1xuICAgICAgICAgICAgZGlmZl9jbGVhbnVwU2VtYW50aWNTY29yZShlZGl0LCBlcXVhbGl0eTIpO1xuICAgICAgICAvLyBUaGUgPj0gZW5jb3VyYWdlcyB0cmFpbGluZyByYXRoZXIgdGhhbiBsZWFkaW5nIHdoaXRlc3BhY2Ugb24gZWRpdHMuXG4gICAgICAgIGlmIChzY29yZSA+PSBiZXN0U2NvcmUpIHtcbiAgICAgICAgICBiZXN0U2NvcmUgPSBzY29yZTtcbiAgICAgICAgICBiZXN0RXF1YWxpdHkxID0gZXF1YWxpdHkxO1xuICAgICAgICAgIGJlc3RFZGl0ID0gZWRpdDtcbiAgICAgICAgICBiZXN0RXF1YWxpdHkyID0gZXF1YWxpdHkyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkaWZmc1twb2ludGVyIC0gMV1bMV0gIT0gYmVzdEVxdWFsaXR5MSkge1xuICAgICAgICAvLyBXZSBoYXZlIGFuIGltcHJvdmVtZW50LCBzYXZlIGl0IGJhY2sgdG8gdGhlIGRpZmYuXG4gICAgICAgIGlmIChiZXN0RXF1YWxpdHkxKSB7XG4gICAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdID0gYmVzdEVxdWFsaXR5MTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciAtIDEsIDEpO1xuICAgICAgICAgIHBvaW50ZXItLTtcbiAgICAgICAgfVxuICAgICAgICBkaWZmc1twb2ludGVyXVsxXSA9IGJlc3RFZGl0O1xuICAgICAgICBpZiAoYmVzdEVxdWFsaXR5Mikge1xuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSA9IGJlc3RFcXVhbGl0eTI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgKyAxLCAxKTtcbiAgICAgICAgICBwb2ludGVyLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcG9pbnRlcisrO1xuICB9XG59O1xuXG5cbi8qKlxuICogUmVkdWNlIHRoZSBudW1iZXIgb2YgZWRpdHMgYnkgZWxpbWluYXRpbmcgb3BlcmF0aW9uYWxseSB0cml2aWFsIGVxdWFsaXRpZXMuXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyfHN0cmluZz4+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jbGVhbnVwRWZmaWNpZW5jeSA9IGZ1bmN0aW9uKGRpZmZzKSB7XG4gIHZhciBjaGFuZ2VzID0gZmFsc2U7XG4gIHZhciBlcXVhbGl0aWVzID0gW107ICAvLyBTdGFjayBvZiBpbmRpY2VzIHdoZXJlIGVxdWFsaXRpZXMgYXJlIGZvdW5kLlxuICB2YXIgZXF1YWxpdGllc0xlbmd0aCA9IDA7ICAvLyBLZWVwaW5nIG91ciBvd24gbGVuZ3RoIHZhciBpcyBmYXN0ZXIgaW4gSlMuXG4gIHZhciBsYXN0ZXF1YWxpdHkgPSAnJzsgIC8vIEFsd2F5cyBlcXVhbCB0byBlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGgtMV1bMV1cbiAgdmFyIHBvaW50ZXIgPSAwOyAgLy8gSW5kZXggb2YgY3VycmVudCBwb3NpdGlvbi5cbiAgLy8gSXMgdGhlcmUgYW4gaW5zZXJ0aW9uIG9wZXJhdGlvbiBiZWZvcmUgdGhlIGxhc3QgZXF1YWxpdHkuXG4gIHZhciBwcmVfaW5zID0gZmFsc2U7XG4gIC8vIElzIHRoZXJlIGEgZGVsZXRpb24gb3BlcmF0aW9uIGJlZm9yZSB0aGUgbGFzdCBlcXVhbGl0eS5cbiAgdmFyIHByZV9kZWwgPSBmYWxzZTtcbiAgLy8gSXMgdGhlcmUgYW4gaW5zZXJ0aW9uIG9wZXJhdGlvbiBhZnRlciB0aGUgbGFzdCBlcXVhbGl0eS5cbiAgdmFyIHBvc3RfaW5zID0gZmFsc2U7XG4gIC8vIElzIHRoZXJlIGEgZGVsZXRpb24gb3BlcmF0aW9uIGFmdGVyIHRoZSBsYXN0IGVxdWFsaXR5LlxuICB2YXIgcG9zdF9kZWwgPSBmYWxzZTtcbiAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGgpIHtcbiAgICBpZiAoZGlmZnNbcG9pbnRlcl1bMF0gPT0gRElGRl9FUVVBTCkgeyAgLy8gZXF1YWxpdHkgZm91bmRcbiAgICAgIGlmIChkaWZmc1twb2ludGVyXVsxXS5sZW5ndGggPCB0aGlzLkRpZmZfRWRpdENvc3QgJiZcbiAgICAgICAgICAocG9zdF9pbnMgfHwgcG9zdF9kZWwpKSB7XG4gICAgICAgIC8vIENhbmRpZGF0ZSBmb3VuZC5cbiAgICAgICAgZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoKytdID0gcG9pbnRlcjtcbiAgICAgICAgcHJlX2lucyA9IHBvc3RfaW5zO1xuICAgICAgICBwcmVfZGVsID0gcG9zdF9kZWw7XG4gICAgICAgIGxhc3RlcXVhbGl0eSA9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm90IGEgY2FuZGlkYXRlLCBhbmQgY2FuIG5ldmVyIGJlY29tZSBvbmUuXG4gICAgICAgIGVxdWFsaXRpZXNMZW5ndGggPSAwO1xuICAgICAgICBsYXN0ZXF1YWxpdHkgPSAnJztcbiAgICAgIH1cbiAgICAgIHBvc3RfaW5zID0gcG9zdF9kZWwgPSBmYWxzZTtcbiAgICB9IGVsc2UgeyAgLy8gYW4gaW5zZXJ0aW9uIG9yIGRlbGV0aW9uXG4gICAgICBpZiAoZGlmZnNbcG9pbnRlcl1bMF0gPT0gRElGRl9ERUxFVEUpIHtcbiAgICAgICAgcG9zdF9kZWwgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zdF9pbnMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgLypcbiAgICAgICAqIEZpdmUgdHlwZXMgdG8gYmUgc3BsaXQ6XG4gICAgICAgKiA8aW5zPkE8L2lucz48ZGVsPkI8L2RlbD5YWTxpbnM+QzwvaW5zPjxkZWw+RDwvZGVsPlxuICAgICAgICogPGlucz5BPC9pbnM+WDxpbnM+QzwvaW5zPjxkZWw+RDwvZGVsPlxuICAgICAgICogPGlucz5BPC9pbnM+PGRlbD5CPC9kZWw+WDxpbnM+QzwvaW5zPlxuICAgICAgICogPGlucz5BPC9kZWw+WDxpbnM+QzwvaW5zPjxkZWw+RDwvZGVsPlxuICAgICAgICogPGlucz5BPC9pbnM+PGRlbD5CPC9kZWw+WDxkZWw+QzwvZGVsPlxuICAgICAgICovXG4gICAgICBpZiAobGFzdGVxdWFsaXR5ICYmICgocHJlX2lucyAmJiBwcmVfZGVsICYmIHBvc3RfaW5zICYmIHBvc3RfZGVsKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKChsYXN0ZXF1YWxpdHkubGVuZ3RoIDwgdGhpcy5EaWZmX0VkaXRDb3N0IC8gMikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAocHJlX2lucyArIHByZV9kZWwgKyBwb3N0X2lucyArIHBvc3RfZGVsKSA9PSAzKSkpIHtcbiAgICAgICAgLy8gRHVwbGljYXRlIHJlY29yZFxuICAgICAgICBkaWZmcy5zcGxpY2UoZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0sIDAsXG4gICAgICAgICAgICAgICAgICAgICBbRElGRl9ERUxFVEUsIGxhc3RlcXVhbGl0eV0pO1xuICAgICAgICAvLyBDaGFuZ2Ugc2Vjb25kIGNvcHkgdG8gaW5zZXJ0LlxuICAgICAgICBkaWZmc1tlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSArIDFdWzBdID0gRElGRl9JTlNFUlQ7XG4gICAgICAgIGVxdWFsaXRpZXNMZW5ndGgtLTsgIC8vIFRocm93IGF3YXkgdGhlIGVxdWFsaXR5IHdlIGp1c3QgZGVsZXRlZDtcbiAgICAgICAgbGFzdGVxdWFsaXR5ID0gJyc7XG4gICAgICAgIGlmIChwcmVfaW5zICYmIHByZV9kZWwpIHtcbiAgICAgICAgICAvLyBObyBjaGFuZ2VzIG1hZGUgd2hpY2ggY291bGQgYWZmZWN0IHByZXZpb3VzIGVudHJ5LCBrZWVwIGdvaW5nLlxuICAgICAgICAgIHBvc3RfaW5zID0gcG9zdF9kZWwgPSB0cnVlO1xuICAgICAgICAgIGVxdWFsaXRpZXNMZW5ndGggPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVxdWFsaXRpZXNMZW5ndGgtLTsgIC8vIFRocm93IGF3YXkgdGhlIHByZXZpb3VzIGVxdWFsaXR5O1xuICAgICAgICAgIHBvaW50ZXIgPSBlcXVhbGl0aWVzTGVuZ3RoID4gMCA/XG4gICAgICAgICAgICAgIGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdIDogLTE7XG4gICAgICAgICAgcG9zdF9pbnMgPSBwb3N0X2RlbCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNoYW5nZXMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBwb2ludGVyKys7XG4gIH1cblxuICBpZiAoY2hhbmdlcykge1xuICAgIHRoaXMuZGlmZl9jbGVhbnVwTWVyZ2UoZGlmZnMpO1xuICB9XG59O1xuXG5cbi8qKlxuICogUmVvcmRlciBhbmQgbWVyZ2UgbGlrZSBlZGl0IHNlY3Rpb25zLiAgTWVyZ2UgZXF1YWxpdGllcy5cbiAqIEFueSBlZGl0IHNlY3Rpb24gY2FuIG1vdmUgYXMgbG9uZyBhcyBpdCBkb2Vzbid0IGNyb3NzIGFuIGVxdWFsaXR5LlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcnxzdHJpbmc+Pn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfY2xlYW51cE1lcmdlID0gZnVuY3Rpb24oZGlmZnMpIHtcbiAgZGlmZnMucHVzaChbRElGRl9FUVVBTCwgJyddKTsgIC8vIEFkZCBhIGR1bW15IGVudHJ5IGF0IHRoZSBlbmQuXG4gIHZhciBwb2ludGVyID0gMDtcbiAgdmFyIGNvdW50X2RlbGV0ZSA9IDA7XG4gIHZhciBjb3VudF9pbnNlcnQgPSAwO1xuICB2YXIgdGV4dF9kZWxldGUgPSAnJztcbiAgdmFyIHRleHRfaW5zZXJ0ID0gJyc7XG4gIHZhciBjb21tb25sZW5ndGg7XG4gIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoKSB7XG4gICAgc3dpdGNoIChkaWZmc1twb2ludGVyXVswXSkge1xuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcbiAgICAgICAgY291bnRfaW5zZXJ0Kys7XG4gICAgICAgIHRleHRfaW5zZXJ0ICs9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgICBwb2ludGVyKys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0RFTEVURTpcbiAgICAgICAgY291bnRfZGVsZXRlKys7XG4gICAgICAgIHRleHRfZGVsZXRlICs9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgICBwb2ludGVyKys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgICAvLyBVcG9uIHJlYWNoaW5nIGFuIGVxdWFsaXR5LCBjaGVjayBmb3IgcHJpb3IgcmVkdW5kYW5jaWVzLlxuICAgICAgICBpZiAoY291bnRfZGVsZXRlICE9PSAwIHx8IGNvdW50X2luc2VydCAhPT0gMCkge1xuICAgICAgICAgIGlmIChjb3VudF9kZWxldGUgIT09IDAgJiYgY291bnRfaW5zZXJ0ICE9PSAwKSB7XG4gICAgICAgICAgICAvLyBGYWN0b3Igb3V0IGFueSBjb21tb24gcHJlZml4aWVzLlxuICAgICAgICAgICAgY29tbW9ubGVuZ3RoID0gdGhpcy5kaWZmX2NvbW1vblByZWZpeCh0ZXh0X2luc2VydCwgdGV4dF9kZWxldGUpO1xuICAgICAgICAgICAgaWYgKGNvbW1vbmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICBpZiAoKHBvaW50ZXIgLSBjb3VudF9kZWxldGUgLSBjb3VudF9pbnNlcnQpID4gMCAmJlxuICAgICAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCAtIDFdWzBdID09XG4gICAgICAgICAgICAgICAgICBESUZGX0VRVUFMKSB7XG4gICAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCAtIDFdWzFdICs9XG4gICAgICAgICAgICAgICAgICAgIHRleHRfaW5zZXJ0LnN1YnN0cmluZygwLCBjb21tb25sZW5ndGgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpZmZzLnNwbGljZSgwLCAwLCBbRElGRl9FUVVBTCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dF9pbnNlcnQuc3Vic3RyaW5nKDAsIGNvbW1vbmxlbmd0aCldKTtcbiAgICAgICAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGV4dF9pbnNlcnQgPSB0ZXh0X2luc2VydC5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgdGV4dF9kZWxldGUgPSB0ZXh0X2RlbGV0ZS5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZhY3RvciBvdXQgYW55IGNvbW1vbiBzdWZmaXhpZXMuXG4gICAgICAgICAgICBjb21tb25sZW5ndGggPSB0aGlzLmRpZmZfY29tbW9uU3VmZml4KHRleHRfaW5zZXJ0LCB0ZXh0X2RlbGV0ZSk7XG4gICAgICAgICAgICBpZiAoY29tbW9ubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdID0gdGV4dF9pbnNlcnQuc3Vic3RyaW5nKHRleHRfaW5zZXJ0Lmxlbmd0aCAtXG4gICAgICAgICAgICAgICAgICBjb21tb25sZW5ndGgpICsgZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgICAgICAgIHRleHRfaW5zZXJ0ID0gdGV4dF9pbnNlcnQuc3Vic3RyaW5nKDAsIHRleHRfaW5zZXJ0Lmxlbmd0aCAtXG4gICAgICAgICAgICAgICAgICBjb21tb25sZW5ndGgpO1xuICAgICAgICAgICAgICB0ZXh0X2RlbGV0ZSA9IHRleHRfZGVsZXRlLnN1YnN0cmluZygwLCB0ZXh0X2RlbGV0ZS5sZW5ndGggLVxuICAgICAgICAgICAgICAgICAgY29tbW9ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gRGVsZXRlIHRoZSBvZmZlbmRpbmcgcmVjb3JkcyBhbmQgYWRkIHRoZSBtZXJnZWQgb25lcy5cbiAgICAgICAgICBpZiAoY291bnRfZGVsZXRlID09PSAwKSB7XG4gICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCxcbiAgICAgICAgICAgICAgICBjb3VudF9kZWxldGUgKyBjb3VudF9pbnNlcnQsIFtESUZGX0lOU0VSVCwgdGV4dF9pbnNlcnRdKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvdW50X2luc2VydCA9PT0gMCkge1xuICAgICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSBjb3VudF9kZWxldGUgLSBjb3VudF9pbnNlcnQsXG4gICAgICAgICAgICAgICAgY291bnRfZGVsZXRlICsgY291bnRfaW5zZXJ0LCBbRElGRl9ERUxFVEUsIHRleHRfZGVsZXRlXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0LFxuICAgICAgICAgICAgICAgIGNvdW50X2RlbGV0ZSArIGNvdW50X2luc2VydCwgW0RJRkZfREVMRVRFLCB0ZXh0X2RlbGV0ZV0sXG4gICAgICAgICAgICAgICAgW0RJRkZfSU5TRVJULCB0ZXh0X2luc2VydF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb2ludGVyID0gcG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCArXG4gICAgICAgICAgICAgICAgICAgIChjb3VudF9kZWxldGUgPyAxIDogMCkgKyAoY291bnRfaW5zZXJ0ID8gMSA6IDApICsgMTtcbiAgICAgICAgfSBlbHNlIGlmIChwb2ludGVyICE9PSAwICYmIGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PSBESUZGX0VRVUFMKSB7XG4gICAgICAgICAgLy8gTWVyZ2UgdGhpcyBlcXVhbGl0eSB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdICs9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyLCAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgIH1cbiAgICAgICAgY291bnRfaW5zZXJ0ID0gMDtcbiAgICAgICAgY291bnRfZGVsZXRlID0gMDtcbiAgICAgICAgdGV4dF9kZWxldGUgPSAnJztcbiAgICAgICAgdGV4dF9pbnNlcnQgPSAnJztcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVsxXSA9PT0gJycpIHtcbiAgICBkaWZmcy5wb3AoKTsgIC8vIFJlbW92ZSB0aGUgZHVtbXkgZW50cnkgYXQgdGhlIGVuZC5cbiAgfVxuXG4gIC8vIFNlY29uZCBwYXNzOiBsb29rIGZvciBzaW5nbGUgZWRpdHMgc3Vycm91bmRlZCBvbiBib3RoIHNpZGVzIGJ5IGVxdWFsaXRpZXNcbiAgLy8gd2hpY2ggY2FuIGJlIHNoaWZ0ZWQgc2lkZXdheXMgdG8gZWxpbWluYXRlIGFuIGVxdWFsaXR5LlxuICAvLyBlLmc6IEE8aW5zPkJBPC9pbnM+QyAtPiA8aW5zPkFCPC9pbnM+QUNcbiAgdmFyIGNoYW5nZXMgPSBmYWxzZTtcbiAgcG9pbnRlciA9IDE7XG4gIC8vIEludGVudGlvbmFsbHkgaWdub3JlIHRoZSBmaXJzdCBhbmQgbGFzdCBlbGVtZW50IChkb24ndCBuZWVkIGNoZWNraW5nKS5cbiAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGggLSAxKSB7XG4gICAgaWYgKGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PSBESUZGX0VRVUFMICYmXG4gICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVswXSA9PSBESUZGX0VRVUFMKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgc2luZ2xlIGVkaXQgc3Vycm91bmRlZCBieSBlcXVhbGl0aWVzLlxuICAgICAgaWYgKGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZyhkaWZmc1twb2ludGVyXVsxXS5sZW5ndGggLVxuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXS5sZW5ndGgpID09IGRpZmZzW3BvaW50ZXIgLSAxXVsxXSkge1xuICAgICAgICAvLyBTaGlmdCB0aGUgZWRpdCBvdmVyIHRoZSBwcmV2aW91cyBlcXVhbGl0eS5cbiAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0gPSBkaWZmc1twb2ludGVyIC0gMV1bMV0gK1xuICAgICAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKDAsIGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aCAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdLmxlbmd0aCk7XG4gICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSA9IGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArIGRpZmZzW3BvaW50ZXIgKyAxXVsxXTtcbiAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSAxLCAxKTtcbiAgICAgICAgY2hhbmdlcyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZygwLCBkaWZmc1twb2ludGVyICsgMV1bMV0ubGVuZ3RoKSA9PVxuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSkge1xuICAgICAgICAvLyBTaGlmdCB0aGUgZWRpdCBvdmVyIHRoZSBuZXh0IGVxdWFsaXR5LlxuICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0gKz0gZGlmZnNbcG9pbnRlciArIDFdWzFdO1xuICAgICAgICBkaWZmc1twb2ludGVyXVsxXSA9XG4gICAgICAgICAgICBkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoZGlmZnNbcG9pbnRlciArIDFdWzFdLmxlbmd0aCkgK1xuICAgICAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzFdO1xuICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciArIDEsIDEpO1xuICAgICAgICBjaGFuZ2VzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcG9pbnRlcisrO1xuICB9XG4gIC8vIElmIHNoaWZ0cyB3ZXJlIG1hZGUsIHRoZSBkaWZmIG5lZWRzIHJlb3JkZXJpbmcgYW5kIGFub3RoZXIgc2hpZnQgc3dlZXAuXG4gIGlmIChjaGFuZ2VzKSB7XG4gICAgdGhpcy5kaWZmX2NsZWFudXBNZXJnZShkaWZmcyk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBsb2MgaXMgYSBsb2NhdGlvbiBpbiB0ZXh0MSwgY29tcHV0ZSBhbmQgcmV0dXJuIHRoZSBlcXVpdmFsZW50IGxvY2F0aW9uIGluXG4gKiB0ZXh0Mi5cbiAqIGUuZy4gJ1RoZSBjYXQnIHZzICdUaGUgYmlnIGNhdCcsIDEtPjEsIDUtPjhcbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXJ8c3RyaW5nPj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IGxvYyBMb2NhdGlvbiB3aXRoaW4gdGV4dDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IExvY2F0aW9uIHdpdGhpbiB0ZXh0Mi5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl94SW5kZXggPSBmdW5jdGlvbihkaWZmcywgbG9jKSB7XG4gIHZhciBjaGFyczEgPSAwO1xuICB2YXIgY2hhcnMyID0gMDtcbiAgdmFyIGxhc3RfY2hhcnMxID0gMDtcbiAgdmFyIGxhc3RfY2hhcnMyID0gMDtcbiAgdmFyIHg7XG4gIGZvciAoeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xuICAgIGlmIChkaWZmc1t4XVswXSAhPT0gRElGRl9JTlNFUlQpIHsgIC8vIEVxdWFsaXR5IG9yIGRlbGV0aW9uLlxuICAgICAgY2hhcnMxICs9IGRpZmZzW3hdWzFdLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKGRpZmZzW3hdWzBdICE9PSBESUZGX0RFTEVURSkgeyAgLy8gRXF1YWxpdHkgb3IgaW5zZXJ0aW9uLlxuICAgICAgY2hhcnMyICs9IGRpZmZzW3hdWzFdLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKGNoYXJzMSA+IGxvYykgeyAgLy8gT3ZlcnNob3QgdGhlIGxvY2F0aW9uLlxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxhc3RfY2hhcnMxID0gY2hhcnMxO1xuICAgIGxhc3RfY2hhcnMyID0gY2hhcnMyO1xuICB9XG4gIC8vIFdhcyB0aGUgbG9jYXRpb24gd2FzIGRlbGV0ZWQ/XG4gIGlmIChkaWZmcy5sZW5ndGggIT0geCAmJiBkaWZmc1t4XVswXSA9PT0gRElGRl9ERUxFVEUpIHtcbiAgICByZXR1cm4gbGFzdF9jaGFyczI7XG4gIH1cbiAgLy8gQWRkIHRoZSByZW1haW5pbmcgY2hhcmFjdGVyIGxlbmd0aC5cbiAgcmV0dXJuIGxhc3RfY2hhcnMyICsgKGxvYyAtIGxhc3RfY2hhcnMxKTtcbn07XG5cblxuLyoqXG4gKiBDb252ZXJ0IGEgZGlmZiBhcnJheSBpbnRvIGEgcHJldHR5IEhUTUwgcmVwb3J0LlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcnxzdHJpbmc+Pn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEhUTUwgcmVwcmVzZW50YXRpb24uXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfcHJldHR5SHRtbCA9IGZ1bmN0aW9uKGRpZmZzKSB7XG4gIHZhciBodG1sID0gW107XG4gIHZhciBpID0gMDtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xuICAgIHZhciBvcCA9IGRpZmZzW3hdWzBdOyAgICAvLyBPcGVyYXRpb24gKGluc2VydCwgZGVsZXRlLCBlcXVhbClcbiAgICB2YXIgZGF0YSA9IGRpZmZzW3hdWzFdOyAgLy8gVGV4dCBvZiBjaGFuZ2UuXG4gICAgdmFyIHRleHQgPSBkYXRhLnJlcGxhY2UoLyYvZywgJyZhbXA7JykucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JykucmVwbGFjZSgvXFxuL2csICcmcGFyYTs8QlI+Jyk7XG4gICAgc3dpdGNoIChvcCkge1xuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcbiAgICAgICAgaHRtbFt4XSA9ICc8SU5TIFNUWUxFPVwiYmFja2dyb3VuZDojRTZGRkU2O1wiIFRJVExFPVwiaT0nICsgaSArICdcIj4nICtcbiAgICAgICAgICAgICAgICB0ZXh0ICsgJzwvSU5TPic7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0RFTEVURTpcbiAgICAgICAgaHRtbFt4XSA9ICc8REVMIFNUWUxFPVwiYmFja2dyb3VuZDojRkZFNkU2O1wiIFRJVExFPVwiaT0nICsgaSArICdcIj4nICtcbiAgICAgICAgICAgICAgICB0ZXh0ICsgJzwvREVMPic7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgICBodG1sW3hdID0gJzxTUEFOIFRJVExFPVwiaT0nICsgaSArICdcIj4nICsgdGV4dCArICc8L1NQQU4+JztcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChvcCAhPT0gRElGRl9ERUxFVEUpIHtcbiAgICAgIGkgKz0gZGF0YS5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiBodG1sLmpvaW4oJycpO1xufTtcblxuXG4vKipcbiAqIENvbXB1dGUgYW5kIHJldHVybiB0aGUgc291cmNlIHRleHQgKGFsbCBlcXVhbGl0aWVzIGFuZCBkZWxldGlvbnMpLlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcnxzdHJpbmc+Pn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFNvdXJjZSB0ZXh0LlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX3RleHQxID0gZnVuY3Rpb24oZGlmZnMpIHtcbiAgdmFyIHRleHQgPSBbXTtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xuICAgIGlmIChkaWZmc1t4XVswXSAhPT0gRElGRl9JTlNFUlQpIHtcbiAgICAgIHRleHRbeF0gPSBkaWZmc1t4XVsxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRleHQuam9pbignJyk7XG59O1xuXG5cbi8qKlxuICogQ29tcHV0ZSBhbmQgcmV0dXJuIHRoZSBkZXN0aW5hdGlvbiB0ZXh0IChhbGwgZXF1YWxpdGllcyBhbmQgaW5zZXJ0aW9ucykuXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyfHN0cmluZz4+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqIEByZXR1cm4ge3N0cmluZ30gRGVzdGluYXRpb24gdGV4dC5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl90ZXh0MiA9IGZ1bmN0aW9uKGRpZmZzKSB7XG4gIHZhciB0ZXh0ID0gW107XG4gIGZvciAodmFyIHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICBpZiAoZGlmZnNbeF1bMF0gIT09IERJRkZfREVMRVRFKSB7XG4gICAgICB0ZXh0W3hdID0gZGlmZnNbeF1bMV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0ZXh0LmpvaW4oJycpO1xufTtcblxuXG4vKipcbiAqIENvbXB1dGUgdGhlIExldmVuc2h0ZWluIGRpc3RhbmNlOyB0aGUgbnVtYmVyIG9mIGluc2VydGVkLCBkZWxldGVkIG9yXG4gKiBzdWJzdGl0dXRlZCBjaGFyYWN0ZXJzLlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcnxzdHJpbmc+Pn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE51bWJlciBvZiBjaGFuZ2VzLlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2xldmVuc2h0ZWluID0gZnVuY3Rpb24oZGlmZnMpIHtcbiAgdmFyIGxldmVuc2h0ZWluID0gMDtcbiAgdmFyIGluc2VydGlvbnMgPSAwO1xuICB2YXIgZGVsZXRpb25zID0gMDtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xuICAgIHZhciBvcCA9IGRpZmZzW3hdWzBdO1xuICAgIHZhciBkYXRhID0gZGlmZnNbeF1bMV07XG4gICAgc3dpdGNoIChvcCkge1xuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcbiAgICAgICAgaW5zZXJ0aW9ucyArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxuICAgICAgICBkZWxldGlvbnMgKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgICAvLyBBIGRlbGV0aW9uIGFuZCBhbiBpbnNlcnRpb24gaXMgb25lIHN1YnN0aXR1dGlvbi5cbiAgICAgICAgbGV2ZW5zaHRlaW4gKz0gTWF0aC5tYXgoaW5zZXJ0aW9ucywgZGVsZXRpb25zKTtcbiAgICAgICAgaW5zZXJ0aW9ucyA9IDA7XG4gICAgICAgIGRlbGV0aW9ucyA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBsZXZlbnNodGVpbiArPSBNYXRoLm1heChpbnNlcnRpb25zLCBkZWxldGlvbnMpO1xuICByZXR1cm4gbGV2ZW5zaHRlaW47XG59O1xuXG5cbi8qKlxuICogQ3J1c2ggdGhlIGRpZmYgaW50byBhbiBlbmNvZGVkIHN0cmluZyB3aGljaCBkZXNjcmliZXMgdGhlIG9wZXJhdGlvbnNcbiAqIHJlcXVpcmVkIHRvIHRyYW5zZm9ybSB0ZXh0MSBpbnRvIHRleHQyLlxuICogRS5nLiA9M1xcdC0yXFx0K2luZyAgLT4gS2VlcCAzIGNoYXJzLCBkZWxldGUgMiBjaGFycywgaW5zZXJ0ICdpbmcnLlxuICogT3BlcmF0aW9ucyBhcmUgdGFiLXNlcGFyYXRlZC4gIEluc2VydGVkIHRleHQgaXMgZXNjYXBlZCB1c2luZyAleHggbm90YXRpb24uXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyfHN0cmluZz4+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqIEByZXR1cm4ge3N0cmluZ30gRGVsdGEgdGV4dC5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl90b0RlbHRhID0gZnVuY3Rpb24oZGlmZnMpIHtcbiAgdmFyIHRleHQgPSBbXTtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xuICAgIHN3aXRjaCAoZGlmZnNbeF1bMF0pIHtcbiAgICAgIGNhc2UgRElGRl9JTlNFUlQ6XG4gICAgICAgIHRleHRbeF0gPSAnKycgKyBlbmNvZGVVUkkoZGlmZnNbeF1bMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XG4gICAgICAgIHRleHRbeF0gPSAnLScgKyBkaWZmc1t4XVsxXS5sZW5ndGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgICB0ZXh0W3hdID0gJz0nICsgZGlmZnNbeF1bMV0ubGVuZ3RoO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgLy8gT3BlcmEgZG9lc24ndCBrbm93IGhvdyB0byBlbmNvZGUgY2hhciAwLlxuICByZXR1cm4gdGV4dC5qb2luKCdcXHQnKS5yZXBsYWNlKC9cXHgwMC9nLCAnJTAwJykucmVwbGFjZSgvJTIwL2csICcgJyk7XG59O1xuXG5cbi8qKlxuICogR2l2ZW4gdGhlIG9yaWdpbmFsIHRleHQxLCBhbmQgYW4gZW5jb2RlZCBzdHJpbmcgd2hpY2ggZGVzY3JpYmVzIHRoZVxuICogb3BlcmF0aW9ucyByZXF1aXJlZCB0byB0cmFuc2Zvcm0gdGV4dDEgaW50byB0ZXh0MiwgY29tcHV0ZSB0aGUgZnVsbCBkaWZmLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIFNvdXJjZSBzdHJpbmcgZm9yIHRoZSBkaWZmLlxuICogQHBhcmFtIHtzdHJpbmd9IGRlbHRhIERlbHRhIHRleHQuXG4gKiBAcmV0dXJuIHtBcnJheS48QXJyYXkuPG51bWJlcnxzdHJpbmc+Pn0gQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgaW52YWxpZCBpbnB1dC5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9mcm9tRGVsdGEgPSBmdW5jdGlvbih0ZXh0MSwgZGVsdGEpIHtcbiAgdmFyIGRpZmZzID0gW107XG4gIHZhciBkaWZmc0xlbmd0aCA9IDA7ICAvLyBLZWVwaW5nIG91ciBvd24gbGVuZ3RoIHZhciBpcyBmYXN0ZXIgaW4gSlMuXG4gIHZhciBwb2ludGVyID0gMDsgIC8vIEN1cnNvciBpbiB0ZXh0MVxuICAvLyBPcGVyYSBkb2Vzbid0IGtub3cgaG93IHRvIGRlY29kZSBjaGFyIDAuXG4gIGRlbHRhID0gZGVsdGEucmVwbGFjZSgvJTAwL2csICdcXDAnKTtcbiAgdmFyIHRva2VucyA9IGRlbHRhLnNwbGl0KC9cXHQvZyk7XG4gIGZvciAodmFyIHggPSAwOyB4IDwgdG9rZW5zLmxlbmd0aDsgeCsrKSB7XG4gICAgLy8gRWFjaCB0b2tlbiBiZWdpbnMgd2l0aCBhIG9uZSBjaGFyYWN0ZXIgcGFyYW1ldGVyIHdoaWNoIHNwZWNpZmllcyB0aGVcbiAgICAvLyBvcGVyYXRpb24gb2YgdGhpcyB0b2tlbiAoZGVsZXRlLCBpbnNlcnQsIGVxdWFsaXR5KS5cbiAgICB2YXIgcGFyYW0gPSB0b2tlbnNbeF0uc3Vic3RyaW5nKDEpO1xuICAgIHN3aXRjaCAodG9rZW5zW3hdLmNoYXJBdCgwKSkge1xuICAgICAgY2FzZSAnKyc6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZGlmZnNbZGlmZnNMZW5ndGgrK10gPSBbRElGRl9JTlNFUlQsIGRlY29kZVVSSShwYXJhbSldO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIC8vIE1hbGZvcm1lZCBVUkkgc2VxdWVuY2UuXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGVzY2FwZSBpbiBkaWZmX2Zyb21EZWx0YTogJyArIHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJy0nOlxuICAgICAgICAvLyBGYWxsIHRocm91Z2guXG4gICAgICBjYXNlICc9JzpcbiAgICAgICAgdmFyIG4gPSBwYXJzZUludChwYXJhbSwgMTApO1xuICAgICAgICBpZiAoaXNOYU4obikgfHwgbiA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbnVtYmVyIGluIGRpZmZfZnJvbURlbHRhOiAnICsgcGFyYW0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ZXh0ID0gdGV4dDEuc3Vic3RyaW5nKHBvaW50ZXIsIHBvaW50ZXIgKz0gbik7XG4gICAgICAgIGlmICh0b2tlbnNbeF0uY2hhckF0KDApID09ICc9Jykge1xuICAgICAgICAgIGRpZmZzW2RpZmZzTGVuZ3RoKytdID0gW0RJRkZfRVFVQUwsIHRleHRdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpZmZzW2RpZmZzTGVuZ3RoKytdID0gW0RJRkZfREVMRVRFLCB0ZXh0XTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIEJsYW5rIHRva2VucyBhcmUgb2sgKGZyb20gYSB0cmFpbGluZyBcXHQpLlxuICAgICAgICAvLyBBbnl0aGluZyBlbHNlIGlzIGFuIGVycm9yLlxuICAgICAgICBpZiAodG9rZW5zW3hdKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRpZmYgb3BlcmF0aW9uIGluIGRpZmZfZnJvbURlbHRhOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zW3hdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAocG9pbnRlciAhPSB0ZXh0MS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlbHRhIGxlbmd0aCAoJyArIHBvaW50ZXIgK1xuICAgICAgICAnKSBkb2VzIG5vdCBlcXVhbCBzb3VyY2UgdGV4dCBsZW5ndGggKCcgKyB0ZXh0MS5sZW5ndGggKyAnKS4nKTtcbiAgfVxuICByZXR1cm4gZGlmZnM7XG59O1xuXG5cbi8vICBNQVRDSCBGVU5DVElPTlNcblxuXG4vKipcbiAqIExvY2F0ZSB0aGUgYmVzdCBpbnN0YW5jZSBvZiAncGF0dGVybicgaW4gJ3RleHQnIG5lYXIgJ2xvYycuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBzZWFyY2guXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0dGVybiBUaGUgcGF0dGVybiB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGxvYyBUaGUgbG9jYXRpb24gdG8gc2VhcmNoIGFyb3VuZC5cbiAqIEByZXR1cm4ge251bWJlcn0gQmVzdCBtYXRjaCBpbmRleCBvciAtMS5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUubWF0Y2hfbWFpbiA9IGZ1bmN0aW9uKHRleHQsIHBhdHRlcm4sIGxvYykge1xuICAvLyBDaGVjayBmb3IgbnVsbCBpbnB1dHMuXG4gIGlmICh0ZXh0ID09IG51bGwgfHwgcGF0dGVybiA9PSBudWxsIHx8IGxvYyA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOdWxsIGlucHV0LiAobWF0Y2hfbWFpbiknKTtcbiAgfVxuXG4gIGxvYyA9IE1hdGgubWF4KDAsIE1hdGgubWluKGxvYywgdGV4dC5sZW5ndGgpKTtcbiAgaWYgKHRleHQgPT0gcGF0dGVybikge1xuICAgIC8vIFNob3J0Y3V0IChwb3RlbnRpYWxseSBub3QgZ3VhcmFudGVlZCBieSB0aGUgYWxnb3JpdGhtKVxuICAgIHJldHVybiAwO1xuICB9IGVsc2UgaWYgKCF0ZXh0Lmxlbmd0aCkge1xuICAgIC8vIE5vdGhpbmcgdG8gbWF0Y2guXG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2UgaWYgKHRleHQuc3Vic3RyaW5nKGxvYywgbG9jICsgcGF0dGVybi5sZW5ndGgpID09IHBhdHRlcm4pIHtcbiAgICAvLyBQZXJmZWN0IG1hdGNoIGF0IHRoZSBwZXJmZWN0IHNwb3QhICAoSW5jbHVkZXMgY2FzZSBvZiBudWxsIHBhdHRlcm4pXG4gICAgcmV0dXJuIGxvYztcbiAgfSBlbHNlIHtcbiAgICAvLyBEbyBhIGZ1enp5IGNvbXBhcmUuXG4gICAgcmV0dXJuIHRoaXMubWF0Y2hfYml0YXAodGV4dCwgcGF0dGVybiwgbG9jKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIExvY2F0ZSB0aGUgYmVzdCBpbnN0YW5jZSBvZiAncGF0dGVybicgaW4gJ3RleHQnIG5lYXIgJ2xvYycgdXNpbmcgdGhlXG4gKiBCaXRhcCBhbGdvcml0aG0uXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBzZWFyY2guXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0dGVybiBUaGUgcGF0dGVybiB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGxvYyBUaGUgbG9jYXRpb24gdG8gc2VhcmNoIGFyb3VuZC5cbiAqIEByZXR1cm4ge251bWJlcn0gQmVzdCBtYXRjaCBpbmRleCBvciAtMS5cbiAqIEBwcml2YXRlXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLm1hdGNoX2JpdGFwID0gZnVuY3Rpb24odGV4dCwgcGF0dGVybiwgbG9jKSB7XG4gIGlmIChwYXR0ZXJuLmxlbmd0aCA+IHRoaXMuTWF0Y2hfTWF4Qml0cykge1xuICAgIHRocm93IG5ldyBFcnJvcignUGF0dGVybiB0b28gbG9uZyBmb3IgdGhpcyBicm93c2VyLicpO1xuICB9XG5cbiAgLy8gSW5pdGlhbGlzZSB0aGUgYWxwaGFiZXQuXG4gIHZhciBzID0gdGhpcy5tYXRjaF9hbHBoYWJldChwYXR0ZXJuKTtcblxuICB2YXIgZG1wID0gdGhpczsgIC8vICd0aGlzJyBiZWNvbWVzICd3aW5kb3cnIGluIGEgY2xvc3VyZS5cblxuICAvKipcbiAgICogQ29tcHV0ZSBhbmQgcmV0dXJuIHRoZSBzY29yZSBmb3IgYSBtYXRjaCB3aXRoIGUgZXJyb3JzIGFuZCB4IGxvY2F0aW9uLlxuICAgKiBBY2Nlc3NlcyBsb2MgYW5kIHBhdHRlcm4gdGhyb3VnaCBiZWluZyBhIGNsb3N1cmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlIE51bWJlciBvZiBlcnJvcnMgaW4gbWF0Y2guXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IExvY2F0aW9uIG9mIG1hdGNoLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE92ZXJhbGwgc2NvcmUgZm9yIG1hdGNoICgwLjAgPSBnb29kLCAxLjAgPSBiYWQpLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gbWF0Y2hfYml0YXBTY29yZShlLCB4KSB7XG4gICAgdmFyIGFjY3VyYWN5ID0gZSAvIHBhdHRlcm4ubGVuZ3RoO1xuICAgIHZhciBwcm94aW1pdHkgPSBNYXRoLmFicyhsb2MgLSB4KTtcbiAgICBpZiAoIWRtcC5NYXRjaF9EaXN0YW5jZSkge1xuICAgICAgLy8gRG9kZ2UgZGl2aWRlIGJ5IHplcm8gZXJyb3IuXG4gICAgICByZXR1cm4gcHJveGltaXR5ID8gMS4wIDogYWNjdXJhY3k7XG4gICAgfVxuICAgIHJldHVybiBhY2N1cmFjeSArIChwcm94aW1pdHkgLyBkbXAuTWF0Y2hfRGlzdGFuY2UpO1xuICB9XG5cbiAgLy8gSGlnaGVzdCBzY29yZSBiZXlvbmQgd2hpY2ggd2UgZ2l2ZSB1cC5cbiAgdmFyIHNjb3JlX3RocmVzaG9sZCA9IHRoaXMuTWF0Y2hfVGhyZXNob2xkO1xuICAvLyBJcyB0aGVyZSBhIG5lYXJieSBleGFjdCBtYXRjaD8gKHNwZWVkdXApXG4gIHZhciBiZXN0X2xvYyA9IHRleHQuaW5kZXhPZihwYXR0ZXJuLCBsb2MpO1xuICBpZiAoYmVzdF9sb2MgIT0gLTEpIHtcbiAgICBzY29yZV90aHJlc2hvbGQgPSBNYXRoLm1pbihtYXRjaF9iaXRhcFNjb3JlKDAsIGJlc3RfbG9jKSwgc2NvcmVfdGhyZXNob2xkKTtcbiAgICAvLyBXaGF0IGFib3V0IGluIHRoZSBvdGhlciBkaXJlY3Rpb24/IChzcGVlZHVwKVxuICAgIGJlc3RfbG9jID0gdGV4dC5sYXN0SW5kZXhPZihwYXR0ZXJuLCBsb2MgKyBwYXR0ZXJuLmxlbmd0aCk7XG4gICAgaWYgKGJlc3RfbG9jICE9IC0xKSB7XG4gICAgICBzY29yZV90aHJlc2hvbGQgPVxuICAgICAgICAgIE1hdGgubWluKG1hdGNoX2JpdGFwU2NvcmUoMCwgYmVzdF9sb2MpLCBzY29yZV90aHJlc2hvbGQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEluaXRpYWxpc2UgdGhlIGJpdCBhcnJheXMuXG4gIHZhciBtYXRjaG1hc2sgPSAxIDw8IChwYXR0ZXJuLmxlbmd0aCAtIDEpO1xuICBiZXN0X2xvYyA9IC0xO1xuXG4gIHZhciBiaW5fbWluLCBiaW5fbWlkO1xuICB2YXIgYmluX21heCA9IHBhdHRlcm4ubGVuZ3RoICsgdGV4dC5sZW5ndGg7XG4gIHZhciBsYXN0X3JkO1xuICBmb3IgKHZhciBkID0gMDsgZCA8IHBhdHRlcm4ubGVuZ3RoOyBkKyspIHtcbiAgICAvLyBTY2FuIGZvciB0aGUgYmVzdCBtYXRjaDsgZWFjaCBpdGVyYXRpb24gYWxsb3dzIGZvciBvbmUgbW9yZSBlcnJvci5cbiAgICAvLyBSdW4gYSBiaW5hcnkgc2VhcmNoIHRvIGRldGVybWluZSBob3cgZmFyIGZyb20gJ2xvYycgd2UgY2FuIHN0cmF5IGF0IHRoaXNcbiAgICAvLyBlcnJvciBsZXZlbC5cbiAgICBiaW5fbWluID0gMDtcbiAgICBiaW5fbWlkID0gYmluX21heDtcbiAgICB3aGlsZSAoYmluX21pbiA8IGJpbl9taWQpIHtcbiAgICAgIGlmIChtYXRjaF9iaXRhcFNjb3JlKGQsIGxvYyArIGJpbl9taWQpIDw9IHNjb3JlX3RocmVzaG9sZCkge1xuICAgICAgICBiaW5fbWluID0gYmluX21pZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJpbl9tYXggPSBiaW5fbWlkO1xuICAgICAgfVxuICAgICAgYmluX21pZCA9IE1hdGguZmxvb3IoKGJpbl9tYXggLSBiaW5fbWluKSAvIDIgKyBiaW5fbWluKTtcbiAgICB9XG4gICAgLy8gVXNlIHRoZSByZXN1bHQgZnJvbSB0aGlzIGl0ZXJhdGlvbiBhcyB0aGUgbWF4aW11bSBmb3IgdGhlIG5leHQuXG4gICAgYmluX21heCA9IGJpbl9taWQ7XG4gICAgdmFyIHN0YXJ0ID0gTWF0aC5tYXgoMSwgbG9jIC0gYmluX21pZCArIDEpO1xuICAgIHZhciBmaW5pc2ggPSBNYXRoLm1pbihsb2MgKyBiaW5fbWlkLCB0ZXh0Lmxlbmd0aCkgKyBwYXR0ZXJuLmxlbmd0aDtcblxuICAgIHZhciByZCA9IEFycmF5KGZpbmlzaCArIDIpO1xuICAgIHJkW2ZpbmlzaCArIDFdID0gKDEgPDwgZCkgLSAxO1xuICAgIGZvciAodmFyIGogPSBmaW5pc2g7IGogPj0gc3RhcnQ7IGotLSkge1xuICAgICAgLy8gVGhlIGFscGhhYmV0IChzKSBpcyBhIHNwYXJzZSBoYXNoLCBzbyB0aGUgZm9sbG93aW5nIGxpbmUgZ2VuZXJhdGVzXG4gICAgICAvLyB3YXJuaW5ncy5cbiAgICAgIHZhciBjaGFyTWF0Y2ggPSBzW3RleHQuY2hhckF0KGogLSAxKV07XG4gICAgICBpZiAoZCA9PT0gMCkgeyAgLy8gRmlyc3QgcGFzczogZXhhY3QgbWF0Y2guXG4gICAgICAgIHJkW2pdID0gKChyZFtqICsgMV0gPDwgMSkgfCAxKSAmIGNoYXJNYXRjaDtcbiAgICAgIH0gZWxzZSB7ICAvLyBTdWJzZXF1ZW50IHBhc3NlczogZnV6enkgbWF0Y2guXG4gICAgICAgIHJkW2pdID0gKChyZFtqICsgMV0gPDwgMSkgfCAxKSAmIGNoYXJNYXRjaCB8XG4gICAgICAgICAgICAgICAgKCgobGFzdF9yZFtqICsgMV0gfCBsYXN0X3JkW2pdKSA8PCAxKSB8IDEpIHxcbiAgICAgICAgICAgICAgICBsYXN0X3JkW2ogKyAxXTtcbiAgICAgIH1cbiAgICAgIGlmIChyZFtqXSAmIG1hdGNobWFzaykge1xuICAgICAgICB2YXIgc2NvcmUgPSBtYXRjaF9iaXRhcFNjb3JlKGQsIGogLSAxKTtcbiAgICAgICAgLy8gVGhpcyBtYXRjaCB3aWxsIGFsbW9zdCBjZXJ0YWlubHkgYmUgYmV0dGVyIHRoYW4gYW55IGV4aXN0aW5nIG1hdGNoLlxuICAgICAgICAvLyBCdXQgY2hlY2sgYW55d2F5LlxuICAgICAgICBpZiAoc2NvcmUgPD0gc2NvcmVfdGhyZXNob2xkKSB7XG4gICAgICAgICAgLy8gVG9sZCB5b3Ugc28uXG4gICAgICAgICAgc2NvcmVfdGhyZXNob2xkID0gc2NvcmU7XG4gICAgICAgICAgYmVzdF9sb2MgPSBqIC0gMTtcbiAgICAgICAgICBpZiAoYmVzdF9sb2MgPiBsb2MpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gcGFzc2luZyBsb2MsIGRvbid0IGV4Y2VlZCBvdXIgY3VycmVudCBkaXN0YW5jZSBmcm9tIGxvYy5cbiAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoMSwgMiAqIGxvYyAtIGJlc3RfbG9jKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQWxyZWFkeSBwYXNzZWQgbG9jLCBkb3duaGlsbCBmcm9tIGhlcmUgb24gaW4uXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gTm8gaG9wZSBmb3IgYSAoYmV0dGVyKSBtYXRjaCBhdCBncmVhdGVyIGVycm9yIGxldmVscy5cbiAgICBpZiAobWF0Y2hfYml0YXBTY29yZShkICsgMSwgbG9jKSA+IHNjb3JlX3RocmVzaG9sZCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxhc3RfcmQgPSByZDtcbiAgfVxuICByZXR1cm4gYmVzdF9sb2M7XG59O1xuXG5cbi8qKlxuICogSW5pdGlhbGlzZSB0aGUgYWxwaGFiZXQgZm9yIHRoZSBCaXRhcCBhbGdvcml0aG0uXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0dGVybiBUaGUgdGV4dCB0byBlbmNvZGUuXG4gKiBAcmV0dXJuIHtPYmplY3R9IEhhc2ggb2YgY2hhcmFjdGVyIGxvY2F0aW9ucy5cbiAqIEBwcml2YXRlXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLm1hdGNoX2FscGhhYmV0ID0gZnVuY3Rpb24ocGF0dGVybikge1xuICB2YXIgcyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdHRlcm4ubGVuZ3RoOyBpKyspIHtcbiAgICBzW3BhdHRlcm4uY2hhckF0KGkpXSA9IDA7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXR0ZXJuLmxlbmd0aDsgaSsrKSB7XG4gICAgc1twYXR0ZXJuLmNoYXJBdChpKV0gfD0gMSA8PCAocGF0dGVybi5sZW5ndGggLSBpIC0gMSk7XG4gIH1cbiAgcmV0dXJuIHM7XG59O1xuXG5cbi8vICBQQVRDSCBGVU5DVElPTlNcblxuXG4vKipcbiAqIEluY3JlYXNlIHRoZSBjb250ZXh0IHVudGlsIGl0IGlzIHVuaXF1ZSxcbiAqIGJ1dCBkb24ndCBsZXQgdGhlIHBhdHRlcm4gZXhwYW5kIGJleW9uZCBNYXRjaF9NYXhCaXRzLlxuICogQHBhcmFtIHtwYXRjaF9vYmp9IHBhdGNoIFRoZSBwYXRjaCB0byBncm93LlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgU291cmNlIHRleHQuXG4gKiBAcHJpdmF0ZVxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5wYXRjaF9hZGRDb250ZXh0ID0gZnVuY3Rpb24ocGF0Y2gsIHRleHQpIHtcbiAgaWYgKHRleHQubGVuZ3RoID09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSB0ZXh0LnN1YnN0cmluZyhwYXRjaC5zdGFydDIsIHBhdGNoLnN0YXJ0MiArIHBhdGNoLmxlbmd0aDEpO1xuICB2YXIgcGFkZGluZyA9IDA7XG5cbiAgLy8gTG9vayBmb3IgdGhlIGZpcnN0IGFuZCBsYXN0IG1hdGNoZXMgb2YgcGF0dGVybiBpbiB0ZXh0LiAgSWYgdHdvIGRpZmZlcmVudFxuICAvLyBtYXRjaGVzIGFyZSBmb3VuZCwgaW5jcmVhc2UgdGhlIHBhdHRlcm4gbGVuZ3RoLlxuICB3aGlsZSAodGV4dC5pbmRleE9mKHBhdHRlcm4pICE9IHRleHQubGFzdEluZGV4T2YocGF0dGVybikgJiZcbiAgICAgICAgIHBhdHRlcm4ubGVuZ3RoIDwgdGhpcy5NYXRjaF9NYXhCaXRzIC0gdGhpcy5QYXRjaF9NYXJnaW4gLVxuICAgICAgICAgdGhpcy5QYXRjaF9NYXJnaW4pIHtcbiAgICBwYWRkaW5nICs9IHRoaXMuUGF0Y2hfTWFyZ2luO1xuICAgIHBhdHRlcm4gPSB0ZXh0LnN1YnN0cmluZyhwYXRjaC5zdGFydDIgLSBwYWRkaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRjaC5zdGFydDIgKyBwYXRjaC5sZW5ndGgxICsgcGFkZGluZyk7XG4gIH1cbiAgLy8gQWRkIG9uZSBjaHVuayBmb3IgZ29vZCBsdWNrLlxuICBwYWRkaW5nICs9IHRoaXMuUGF0Y2hfTWFyZ2luO1xuXG4gIC8vIEFkZCB0aGUgcHJlZml4LlxuICB2YXIgcHJlZml4ID0gdGV4dC5zdWJzdHJpbmcocGF0Y2guc3RhcnQyIC0gcGFkZGluZywgcGF0Y2guc3RhcnQyKTtcbiAgaWYgKHByZWZpeCkge1xuICAgIHBhdGNoLmRpZmZzLnVuc2hpZnQoW0RJRkZfRVFVQUwsIHByZWZpeF0pO1xuICB9XG4gIC8vIEFkZCB0aGUgc3VmZml4LlxuICB2YXIgc3VmZml4ID0gdGV4dC5zdWJzdHJpbmcocGF0Y2guc3RhcnQyICsgcGF0Y2gubGVuZ3RoMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoLnN0YXJ0MiArIHBhdGNoLmxlbmd0aDEgKyBwYWRkaW5nKTtcbiAgaWYgKHN1ZmZpeCkge1xuICAgIHBhdGNoLmRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIHN1ZmZpeF0pO1xuICB9XG5cbiAgLy8gUm9sbCBiYWNrIHRoZSBzdGFydCBwb2ludHMuXG4gIHBhdGNoLnN0YXJ0MSAtPSBwcmVmaXgubGVuZ3RoO1xuICBwYXRjaC5zdGFydDIgLT0gcHJlZml4Lmxlbmd0aDtcbiAgLy8gRXh0ZW5kIHRoZSBsZW5ndGhzLlxuICBwYXRjaC5sZW5ndGgxICs9IHByZWZpeC5sZW5ndGggKyBzdWZmaXgubGVuZ3RoO1xuICBwYXRjaC5sZW5ndGgyICs9IHByZWZpeC5sZW5ndGggKyBzdWZmaXgubGVuZ3RoO1xufTtcblxuXG4vKipcbiAqIENvbXB1dGUgYSBsaXN0IG9mIHBhdGNoZXMgdG8gdHVybiB0ZXh0MSBpbnRvIHRleHQyLlxuICogVXNlIGRpZmZzIGlmIHByb3ZpZGVkLCBvdGhlcndpc2UgY29tcHV0ZSBpdCBvdXJzZWx2ZXMuXG4gKiBUaGVyZSBhcmUgZm91ciB3YXlzIHRvIGNhbGwgdGhpcyBmdW5jdGlvbiwgZGVwZW5kaW5nIG9uIHdoYXQgZGF0YSBpc1xuICogYXZhaWxhYmxlIHRvIHRoZSBjYWxsZXI6XG4gKiBNZXRob2QgMTpcbiAqIGEgPSB0ZXh0MSwgYiA9IHRleHQyXG4gKiBNZXRob2QgMjpcbiAqIGEgPSBkaWZmc1xuICogTWV0aG9kIDMgKG9wdGltYWwpOlxuICogYSA9IHRleHQxLCBiID0gZGlmZnNcbiAqIE1ldGhvZCA0IChkZXByZWNhdGVkLCB1c2UgbWV0aG9kIDMpOlxuICogYSA9IHRleHQxLCBiID0gdGV4dDIsIGMgPSBkaWZmc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxBcnJheS48bnVtYmVyfHN0cmluZz4+fSBhIHRleHQxIChtZXRob2RzIDEsMyw0KSBvclxuICogQXJyYXkgb2YgZGlmZiB0dXBsZXMgZm9yIHRleHQxIHRvIHRleHQyIChtZXRob2QgMikuXG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48QXJyYXkuPG51bWJlcnxzdHJpbmc+Pn0gb3B0X2IgdGV4dDIgKG1ldGhvZHMgMSw0KSBvclxuICogQXJyYXkgb2YgZGlmZiB0dXBsZXMgZm9yIHRleHQxIHRvIHRleHQyIChtZXRob2QgMykgb3IgdW5kZWZpbmVkIChtZXRob2QgMikuXG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48QXJyYXkuPG51bWJlcnxzdHJpbmc+Pn0gb3B0X2MgQXJyYXkgb2YgZGlmZiB0dXBsZXMgZm9yXG4gKiB0ZXh0MSB0byB0ZXh0MiAobWV0aG9kIDQpIG9yIHVuZGVmaW5lZCAobWV0aG9kcyAxLDIsMykuXG4gKiBAcmV0dXJuIHtBcnJheS48cGF0Y2hfb2JqPn0gQXJyYXkgb2YgcGF0Y2ggb2JqZWN0cy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUucGF0Y2hfbWFrZSA9IGZ1bmN0aW9uKGEsIG9wdF9iLCBvcHRfYykge1xuICB2YXIgdGV4dDEsIGRpZmZzO1xuICBpZiAodHlwZW9mIGEgPT0gJ3N0cmluZycgJiYgdHlwZW9mIG9wdF9iID09ICdzdHJpbmcnICYmXG4gICAgICB0eXBlb2Ygb3B0X2MgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBNZXRob2QgMTogdGV4dDEsIHRleHQyXG4gICAgLy8gQ29tcHV0ZSBkaWZmcyBmcm9tIHRleHQxIGFuZCB0ZXh0Mi5cbiAgICB0ZXh0MSA9IGE7XG4gICAgZGlmZnMgPSB0aGlzLmRpZmZfbWFpbih0ZXh0MSwgb3B0X2IsIHRydWUpO1xuICAgIGlmIChkaWZmcy5sZW5ndGggPiAyKSB7XG4gICAgICB0aGlzLmRpZmZfY2xlYW51cFNlbWFudGljKGRpZmZzKTtcbiAgICAgIHRoaXMuZGlmZl9jbGVhbnVwRWZmaWNpZW5jeShkaWZmcyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGEgJiYgdHlwZW9mIGEgPT0gJ29iamVjdCcgJiYgdHlwZW9mIG9wdF9iID09ICd1bmRlZmluZWQnICYmXG4gICAgICB0eXBlb2Ygb3B0X2MgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBNZXRob2QgMjogZGlmZnNcbiAgICAvLyBDb21wdXRlIHRleHQxIGZyb20gZGlmZnMuXG4gICAgZGlmZnMgPSBhO1xuICAgIHRleHQxID0gdGhpcy5kaWZmX3RleHQxKGRpZmZzKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYSA9PSAnc3RyaW5nJyAmJiBvcHRfYiAmJiB0eXBlb2Ygb3B0X2IgPT0gJ29iamVjdCcgJiZcbiAgICAgIHR5cGVvZiBvcHRfYyA9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIE1ldGhvZCAzOiB0ZXh0MSwgZGlmZnNcbiAgICB0ZXh0MSA9IGE7XG4gICAgZGlmZnMgPSBvcHRfYjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYSA9PSAnc3RyaW5nJyAmJiB0eXBlb2Ygb3B0X2IgPT0gJ3N0cmluZycgJiZcbiAgICAgIG9wdF9jICYmIHR5cGVvZiBvcHRfYyA9PSAnb2JqZWN0Jykge1xuICAgIC8vIE1ldGhvZCA0OiB0ZXh0MSwgdGV4dDIsIGRpZmZzXG4gICAgLy8gdGV4dDIgaXMgbm90IHVzZWQuXG4gICAgdGV4dDEgPSBhO1xuICAgIGRpZmZzID0gb3B0X2M7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGNhbGwgZm9ybWF0IHRvIHBhdGNoX21ha2UuJyk7XG4gIH1cblxuICBpZiAoZGlmZnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdOyAgLy8gR2V0IHJpZCBvZiB0aGUgbnVsbCBjYXNlLlxuICB9XG4gIHZhciBwYXRjaGVzID0gW107XG4gIHZhciBwYXRjaCA9IG5ldyBwYXRjaF9vYmooKTtcbiAgdmFyIHBhdGNoRGlmZkxlbmd0aCA9IDA7ICAvLyBLZWVwaW5nIG91ciBvd24gbGVuZ3RoIHZhciBpcyBmYXN0ZXIgaW4gSlMuXG4gIHZhciBjaGFyX2NvdW50MSA9IDA7ICAvLyBOdW1iZXIgb2YgY2hhcmFjdGVycyBpbnRvIHRoZSB0ZXh0MSBzdHJpbmcuXG4gIHZhciBjaGFyX2NvdW50MiA9IDA7ICAvLyBOdW1iZXIgb2YgY2hhcmFjdGVycyBpbnRvIHRoZSB0ZXh0MiBzdHJpbmcuXG4gIC8vIFN0YXJ0IHdpdGggdGV4dDEgKHByZXBhdGNoX3RleHQpIGFuZCBhcHBseSB0aGUgZGlmZnMgdW50aWwgd2UgYXJyaXZlIGF0XG4gIC8vIHRleHQyIChwb3N0cGF0Y2hfdGV4dCkuICBXZSByZWNyZWF0ZSB0aGUgcGF0Y2hlcyBvbmUgYnkgb25lIHRvIGRldGVybWluZVxuICAvLyBjb250ZXh0IGluZm8uXG4gIHZhciBwcmVwYXRjaF90ZXh0ID0gdGV4dDE7XG4gIHZhciBwb3N0cGF0Y2hfdGV4dCA9IHRleHQxO1xuICBmb3IgKHZhciB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgdmFyIGRpZmZfdHlwZSA9IGRpZmZzW3hdWzBdO1xuICAgIHZhciBkaWZmX3RleHQgPSBkaWZmc1t4XVsxXTtcblxuICAgIGlmICghcGF0Y2hEaWZmTGVuZ3RoICYmIGRpZmZfdHlwZSAhPT0gRElGRl9FUVVBTCkge1xuICAgICAgLy8gQSBuZXcgcGF0Y2ggc3RhcnRzIGhlcmUuXG4gICAgICBwYXRjaC5zdGFydDEgPSBjaGFyX2NvdW50MTtcbiAgICAgIHBhdGNoLnN0YXJ0MiA9IGNoYXJfY291bnQyO1xuICAgIH1cblxuICAgIHN3aXRjaCAoZGlmZl90eXBlKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICBwYXRjaC5kaWZmc1twYXRjaERpZmZMZW5ndGgrK10gPSBkaWZmc1t4XTtcbiAgICAgICAgcGF0Y2gubGVuZ3RoMiArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgICAgICBwb3N0cGF0Y2hfdGV4dCA9IHBvc3RwYXRjaF90ZXh0LnN1YnN0cmluZygwLCBjaGFyX2NvdW50MikgKyBkaWZmX3RleHQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RwYXRjaF90ZXh0LnN1YnN0cmluZyhjaGFyX2NvdW50Mik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0RFTEVURTpcbiAgICAgICAgcGF0Y2gubGVuZ3RoMSArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgICAgICBwYXRjaC5kaWZmc1twYXRjaERpZmZMZW5ndGgrK10gPSBkaWZmc1t4XTtcbiAgICAgICAgcG9zdHBhdGNoX3RleHQgPSBwb3N0cGF0Y2hfdGV4dC5zdWJzdHJpbmcoMCwgY2hhcl9jb3VudDIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICBwb3N0cGF0Y2hfdGV4dC5zdWJzdHJpbmcoY2hhcl9jb3VudDIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmX3RleHQubGVuZ3RoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgIGlmIChkaWZmX3RleHQubGVuZ3RoIDw9IDIgKiB0aGlzLlBhdGNoX01hcmdpbiAmJlxuICAgICAgICAgICAgcGF0Y2hEaWZmTGVuZ3RoICYmIGRpZmZzLmxlbmd0aCAhPSB4ICsgMSkge1xuICAgICAgICAgIC8vIFNtYWxsIGVxdWFsaXR5IGluc2lkZSBhIHBhdGNoLlxuICAgICAgICAgIHBhdGNoLmRpZmZzW3BhdGNoRGlmZkxlbmd0aCsrXSA9IGRpZmZzW3hdO1xuICAgICAgICAgIHBhdGNoLmxlbmd0aDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBwYXRjaC5sZW5ndGgyICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSBpZiAoZGlmZl90ZXh0Lmxlbmd0aCA+PSAyICogdGhpcy5QYXRjaF9NYXJnaW4pIHtcbiAgICAgICAgICAvLyBUaW1lIGZvciBhIG5ldyBwYXRjaC5cbiAgICAgICAgICBpZiAocGF0Y2hEaWZmTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnBhdGNoX2FkZENvbnRleHQocGF0Y2gsIHByZXBhdGNoX3RleHQpO1xuICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHBhdGNoKTtcbiAgICAgICAgICAgIHBhdGNoID0gbmV3IHBhdGNoX29iaigpO1xuICAgICAgICAgICAgcGF0Y2hEaWZmTGVuZ3RoID0gMDtcbiAgICAgICAgICAgIC8vIFVubGlrZSBVbmlkaWZmLCBvdXIgcGF0Y2ggbGlzdHMgaGF2ZSBhIHJvbGxpbmcgY29udGV4dC5cbiAgICAgICAgICAgIC8vIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9nb29nbGUtZGlmZi1tYXRjaC1wYXRjaC93aWtpL1VuaWRpZmZcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBwcmVwYXRjaCB0ZXh0ICYgcG9zIHRvIHJlZmxlY3QgdGhlIGFwcGxpY2F0aW9uIG9mIHRoZVxuICAgICAgICAgICAgLy8ganVzdCBjb21wbGV0ZWQgcGF0Y2guXG4gICAgICAgICAgICBwcmVwYXRjaF90ZXh0ID0gcG9zdHBhdGNoX3RleHQ7XG4gICAgICAgICAgICBjaGFyX2NvdW50MSA9IGNoYXJfY291bnQyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGNvdW50LlxuICAgIGlmIChkaWZmX3R5cGUgIT09IERJRkZfSU5TRVJUKSB7XG4gICAgICBjaGFyX2NvdW50MSArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAoZGlmZl90eXBlICE9PSBESUZGX0RFTEVURSkge1xuICAgICAgY2hhcl9jb3VudDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgLy8gUGljayB1cCB0aGUgbGVmdG92ZXIgcGF0Y2ggaWYgbm90IGVtcHR5LlxuICBpZiAocGF0Y2hEaWZmTGVuZ3RoKSB7XG4gICAgdGhpcy5wYXRjaF9hZGRDb250ZXh0KHBhdGNoLCBwcmVwYXRjaF90ZXh0KTtcbiAgICBwYXRjaGVzLnB1c2gocGF0Y2gpO1xuICB9XG5cbiAgcmV0dXJuIHBhdGNoZXM7XG59O1xuXG5cbi8qKlxuICogR2l2ZW4gYW4gYXJyYXkgb2YgcGF0Y2hlcywgcmV0dXJuIGFub3RoZXIgYXJyYXkgdGhhdCBpcyBpZGVudGljYWwuXG4gKiBAcGFyYW0ge0FycmF5LjxwYXRjaF9vYmo+fSBwYXRjaGVzIEFycmF5IG9mIHBhdGNoIG9iamVjdHMuXG4gKiBAcmV0dXJuIHtBcnJheS48cGF0Y2hfb2JqPn0gQXJyYXkgb2YgcGF0Y2ggb2JqZWN0cy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUucGF0Y2hfZGVlcENvcHkgPSBmdW5jdGlvbihwYXRjaGVzKSB7XG4gIC8vIE1ha2luZyBkZWVwIGNvcGllcyBpcyBoYXJkIGluIEphdmFTY3JpcHQuXG4gIHZhciBwYXRjaGVzQ29weSA9IFtdO1xuICBmb3IgKHZhciB4ID0gMDsgeCA8IHBhdGNoZXMubGVuZ3RoOyB4KyspIHtcbiAgICB2YXIgcGF0Y2ggPSBwYXRjaGVzW3hdO1xuICAgIHZhciBwYXRjaENvcHkgPSBuZXcgcGF0Y2hfb2JqKCk7XG4gICAgcGF0Y2hDb3B5LmRpZmZzID0gW107XG4gICAgZm9yICh2YXIgeSA9IDA7IHkgPCBwYXRjaC5kaWZmcy5sZW5ndGg7IHkrKykge1xuICAgICAgcGF0Y2hDb3B5LmRpZmZzW3ldID0gcGF0Y2guZGlmZnNbeV0uc2xpY2UoKTtcbiAgICB9XG4gICAgcGF0Y2hDb3B5LnN0YXJ0MSA9IHBhdGNoLnN0YXJ0MTtcbiAgICBwYXRjaENvcHkuc3RhcnQyID0gcGF0Y2guc3RhcnQyO1xuICAgIHBhdGNoQ29weS5sZW5ndGgxID0gcGF0Y2gubGVuZ3RoMTtcbiAgICBwYXRjaENvcHkubGVuZ3RoMiA9IHBhdGNoLmxlbmd0aDI7XG4gICAgcGF0Y2hlc0NvcHlbeF0gPSBwYXRjaENvcHk7XG4gIH1cbiAgcmV0dXJuIHBhdGNoZXNDb3B5O1xufTtcblxuXG4vKipcbiAqIE1lcmdlIGEgc2V0IG9mIHBhdGNoZXMgb250byB0aGUgdGV4dC4gIFJldHVybiBhIHBhdGNoZWQgdGV4dCwgYXMgd2VsbFxuICogYXMgYSBsaXN0IG9mIHRydWUvZmFsc2UgdmFsdWVzIGluZGljYXRpbmcgd2hpY2ggcGF0Y2hlcyB3ZXJlIGFwcGxpZWQuXG4gKiBAcGFyYW0ge0FycmF5LjxwYXRjaF9vYmo+fSBwYXRjaGVzIEFycmF5IG9mIHBhdGNoIG9iamVjdHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBPbGQgdGV4dC5cbiAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmd8QXJyYXkuPGJvb2xlYW4+Pn0gVHdvIGVsZW1lbnQgQXJyYXksIGNvbnRhaW5pbmcgdGhlXG4gKiAgICAgIG5ldyB0ZXh0IGFuZCBhbiBhcnJheSBvZiBib29sZWFuIHZhbHVlcy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUucGF0Y2hfYXBwbHkgPSBmdW5jdGlvbihwYXRjaGVzLCB0ZXh0KSB7XG4gIGlmIChwYXRjaGVzLmxlbmd0aCA9PSAwKSB7XG4gICAgcmV0dXJuIFt0ZXh0LCBbXV07XG4gIH1cblxuICAvLyBEZWVwIGNvcHkgdGhlIHBhdGNoZXMgc28gdGhhdCBubyBjaGFuZ2VzIGFyZSBtYWRlIHRvIG9yaWdpbmFscy5cbiAgcGF0Y2hlcyA9IHRoaXMucGF0Y2hfZGVlcENvcHkocGF0Y2hlcyk7XG5cbiAgdmFyIG51bGxQYWRkaW5nID0gdGhpcy5wYXRjaF9hZGRQYWRkaW5nKHBhdGNoZXMpO1xuICB0ZXh0ID0gbnVsbFBhZGRpbmcgKyB0ZXh0ICsgbnVsbFBhZGRpbmc7XG5cbiAgdGhpcy5wYXRjaF9zcGxpdE1heChwYXRjaGVzKTtcbiAgLy8gZGVsdGEga2VlcHMgdHJhY2sgb2YgdGhlIG9mZnNldCBiZXR3ZWVuIHRoZSBleHBlY3RlZCBhbmQgYWN0dWFsIGxvY2F0aW9uXG4gIC8vIG9mIHRoZSBwcmV2aW91cyBwYXRjaC4gIElmIHRoZXJlIGFyZSBwYXRjaGVzIGV4cGVjdGVkIGF0IHBvc2l0aW9ucyAxMCBhbmRcbiAgLy8gMjAsIGJ1dCB0aGUgZmlyc3QgcGF0Y2ggd2FzIGZvdW5kIGF0IDEyLCBkZWx0YSBpcyAyIGFuZCB0aGUgc2Vjb25kIHBhdGNoXG4gIC8vIGhhcyBhbiBlZmZlY3RpdmUgZXhwZWN0ZWQgcG9zaXRpb24gb2YgMjIuXG4gIHZhciBkZWx0YSA9IDA7XG4gIHZhciByZXN1bHRzID0gW107XG4gIGZvciAodmFyIHggPSAwOyB4IDwgcGF0Y2hlcy5sZW5ndGg7IHgrKykge1xuICAgIHZhciBleHBlY3RlZF9sb2MgPSBwYXRjaGVzW3hdLnN0YXJ0MiArIGRlbHRhO1xuICAgIHZhciB0ZXh0MSA9IHRoaXMuZGlmZl90ZXh0MShwYXRjaGVzW3hdLmRpZmZzKTtcbiAgICB2YXIgc3RhcnRfbG9jO1xuICAgIHZhciBlbmRfbG9jID0gLTE7XG4gICAgaWYgKHRleHQxLmxlbmd0aCA+IHRoaXMuTWF0Y2hfTWF4Qml0cykge1xuICAgICAgLy8gcGF0Y2hfc3BsaXRNYXggd2lsbCBvbmx5IHByb3ZpZGUgYW4gb3ZlcnNpemVkIHBhdHRlcm4gaW4gdGhlIGNhc2Ugb2ZcbiAgICAgIC8vIGEgbW9uc3RlciBkZWxldGUuXG4gICAgICBzdGFydF9sb2MgPSB0aGlzLm1hdGNoX21haW4odGV4dCwgdGV4dDEuc3Vic3RyaW5nKDAsIHRoaXMuTWF0Y2hfTWF4Qml0cyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWRfbG9jKTtcbiAgICAgIGlmIChzdGFydF9sb2MgIT0gLTEpIHtcbiAgICAgICAgZW5kX2xvYyA9IHRoaXMubWF0Y2hfbWFpbih0ZXh0LFxuICAgICAgICAgICAgdGV4dDEuc3Vic3RyaW5nKHRleHQxLmxlbmd0aCAtIHRoaXMuTWF0Y2hfTWF4Qml0cyksXG4gICAgICAgICAgICBleHBlY3RlZF9sb2MgKyB0ZXh0MS5sZW5ndGggLSB0aGlzLk1hdGNoX01heEJpdHMpO1xuICAgICAgICBpZiAoZW5kX2xvYyA9PSAtMSB8fCBzdGFydF9sb2MgPj0gZW5kX2xvYykge1xuICAgICAgICAgIC8vIENhbid0IGZpbmQgdmFsaWQgdHJhaWxpbmcgY29udGV4dC4gIERyb3AgdGhpcyBwYXRjaC5cbiAgICAgICAgICBzdGFydF9sb2MgPSAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydF9sb2MgPSB0aGlzLm1hdGNoX21haW4odGV4dCwgdGV4dDEsIGV4cGVjdGVkX2xvYyk7XG4gICAgfVxuICAgIGlmIChzdGFydF9sb2MgPT0gLTEpIHtcbiAgICAgIC8vIE5vIG1hdGNoIGZvdW5kLiAgOihcbiAgICAgIHJlc3VsdHNbeF0gPSBmYWxzZTtcbiAgICAgIC8vIFN1YnRyYWN0IHRoZSBkZWx0YSBmb3IgdGhpcyBmYWlsZWQgcGF0Y2ggZnJvbSBzdWJzZXF1ZW50IHBhdGNoZXMuXG4gICAgICBkZWx0YSAtPSBwYXRjaGVzW3hdLmxlbmd0aDIgLSBwYXRjaGVzW3hdLmxlbmd0aDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvdW5kIGEgbWF0Y2guICA6KVxuICAgICAgcmVzdWx0c1t4XSA9IHRydWU7XG4gICAgICBkZWx0YSA9IHN0YXJ0X2xvYyAtIGV4cGVjdGVkX2xvYztcbiAgICAgIHZhciB0ZXh0MjtcbiAgICAgIGlmIChlbmRfbG9jID09IC0xKSB7XG4gICAgICAgIHRleHQyID0gdGV4dC5zdWJzdHJpbmcoc3RhcnRfbG9jLCBzdGFydF9sb2MgKyB0ZXh0MS5sZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dDIgPSB0ZXh0LnN1YnN0cmluZyhzdGFydF9sb2MsIGVuZF9sb2MgKyB0aGlzLk1hdGNoX01heEJpdHMpO1xuICAgICAgfVxuICAgICAgaWYgKHRleHQxID09IHRleHQyKSB7XG4gICAgICAgIC8vIFBlcmZlY3QgbWF0Y2gsIGp1c3Qgc2hvdmUgdGhlIHJlcGxhY2VtZW50IHRleHQgaW4uXG4gICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydF9sb2MpICtcbiAgICAgICAgICAgICAgIHRoaXMuZGlmZl90ZXh0MihwYXRjaGVzW3hdLmRpZmZzKSArXG4gICAgICAgICAgICAgICB0ZXh0LnN1YnN0cmluZyhzdGFydF9sb2MgKyB0ZXh0MS5sZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSW1wZXJmZWN0IG1hdGNoLiAgUnVuIGEgZGlmZiB0byBnZXQgYSBmcmFtZXdvcmsgb2YgZXF1aXZhbGVudFxuICAgICAgICAvLyBpbmRpY2VzLlxuICAgICAgICB2YXIgZGlmZnMgPSB0aGlzLmRpZmZfbWFpbih0ZXh0MSwgdGV4dDIsIGZhbHNlKTtcbiAgICAgICAgaWYgKHRleHQxLmxlbmd0aCA+IHRoaXMuTWF0Y2hfTWF4Qml0cyAmJlxuICAgICAgICAgICAgdGhpcy5kaWZmX2xldmVuc2h0ZWluKGRpZmZzKSAvIHRleHQxLmxlbmd0aCA+XG4gICAgICAgICAgICB0aGlzLlBhdGNoX0RlbGV0ZVRocmVzaG9sZCkge1xuICAgICAgICAgIC8vIFRoZSBlbmQgcG9pbnRzIG1hdGNoLCBidXQgdGhlIGNvbnRlbnQgaXMgdW5hY2NlcHRhYmx5IGJhZC5cbiAgICAgICAgICByZXN1bHRzW3hdID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kaWZmX2NsZWFudXBTZW1hbnRpY0xvc3NsZXNzKGRpZmZzKTtcbiAgICAgICAgICB2YXIgaW5kZXgxID0gMDtcbiAgICAgICAgICB2YXIgaW5kZXgyO1xuICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgcGF0Y2hlc1t4XS5kaWZmcy5sZW5ndGg7IHkrKykge1xuICAgICAgICAgICAgdmFyIG1vZCA9IHBhdGNoZXNbeF0uZGlmZnNbeV07XG4gICAgICAgICAgICBpZiAobW9kWzBdICE9PSBESUZGX0VRVUFMKSB7XG4gICAgICAgICAgICAgIGluZGV4MiA9IHRoaXMuZGlmZl94SW5kZXgoZGlmZnMsIGluZGV4MSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW9kWzBdID09PSBESUZGX0lOU0VSVCkgeyAgLy8gSW5zZXJ0aW9uXG4gICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydF9sb2MgKyBpbmRleDIpICsgbW9kWzFdICtcbiAgICAgICAgICAgICAgICAgICAgIHRleHQuc3Vic3RyaW5nKHN0YXJ0X2xvYyArIGluZGV4Mik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1vZFswXSA9PT0gRElGRl9ERUxFVEUpIHsgIC8vIERlbGV0aW9uXG4gICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydF9sb2MgKyBpbmRleDIpICtcbiAgICAgICAgICAgICAgICAgICAgIHRleHQuc3Vic3RyaW5nKHN0YXJ0X2xvYyArIHRoaXMuZGlmZl94SW5kZXgoZGlmZnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgxICsgbW9kWzFdLmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vZFswXSAhPT0gRElGRl9ERUxFVEUpIHtcbiAgICAgICAgICAgICAgaW5kZXgxICs9IG1vZFsxXS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIFN0cmlwIHRoZSBwYWRkaW5nIG9mZi5cbiAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKG51bGxQYWRkaW5nLmxlbmd0aCwgdGV4dC5sZW5ndGggLSBudWxsUGFkZGluZy5sZW5ndGgpO1xuICByZXR1cm4gW3RleHQsIHJlc3VsdHNdO1xufTtcblxuXG4vKipcbiAqIEFkZCBzb21lIHBhZGRpbmcgb24gdGV4dCBzdGFydCBhbmQgZW5kIHNvIHRoYXQgZWRnZXMgY2FuIG1hdGNoIHNvbWV0aGluZy5cbiAqIEludGVuZGVkIHRvIGJlIGNhbGxlZCBvbmx5IGZyb20gd2l0aGluIHBhdGNoX2FwcGx5LlxuICogQHBhcmFtIHtBcnJheS48cGF0Y2hfb2JqPn0gcGF0Y2hlcyBBcnJheSBvZiBwYXRjaCBvYmplY3RzLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgcGFkZGluZyBzdHJpbmcgYWRkZWQgdG8gZWFjaCBzaWRlLlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5wYXRjaF9hZGRQYWRkaW5nID0gZnVuY3Rpb24ocGF0Y2hlcykge1xuICB2YXIgcGFkZGluZ0xlbmd0aCA9IHRoaXMuUGF0Y2hfTWFyZ2luO1xuICB2YXIgbnVsbFBhZGRpbmcgPSAnJztcbiAgZm9yICh2YXIgeCA9IDE7IHggPD0gcGFkZGluZ0xlbmd0aDsgeCsrKSB7XG4gICAgbnVsbFBhZGRpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh4KTtcbiAgfVxuXG4gIC8vIEJ1bXAgYWxsIHRoZSBwYXRjaGVzIGZvcndhcmQuXG4gIGZvciAodmFyIHggPSAwOyB4IDwgcGF0Y2hlcy5sZW5ndGg7IHgrKykge1xuICAgIHBhdGNoZXNbeF0uc3RhcnQxICs9IHBhZGRpbmdMZW5ndGg7XG4gICAgcGF0Y2hlc1t4XS5zdGFydDIgKz0gcGFkZGluZ0xlbmd0aDtcbiAgfVxuXG4gIC8vIEFkZCBzb21lIHBhZGRpbmcgb24gc3RhcnQgb2YgZmlyc3QgZGlmZi5cbiAgdmFyIHBhdGNoID0gcGF0Y2hlc1swXTtcbiAgdmFyIGRpZmZzID0gcGF0Y2guZGlmZnM7XG4gIGlmIChkaWZmcy5sZW5ndGggPT0gMCB8fCBkaWZmc1swXVswXSAhPSBESUZGX0VRVUFMKSB7XG4gICAgLy8gQWRkIG51bGxQYWRkaW5nIGVxdWFsaXR5LlxuICAgIGRpZmZzLnVuc2hpZnQoW0RJRkZfRVFVQUwsIG51bGxQYWRkaW5nXSk7XG4gICAgcGF0Y2guc3RhcnQxIC09IHBhZGRpbmdMZW5ndGg7ICAvLyBTaG91bGQgYmUgMC5cbiAgICBwYXRjaC5zdGFydDIgLT0gcGFkZGluZ0xlbmd0aDsgIC8vIFNob3VsZCBiZSAwLlxuICAgIHBhdGNoLmxlbmd0aDEgKz0gcGFkZGluZ0xlbmd0aDtcbiAgICBwYXRjaC5sZW5ndGgyICs9IHBhZGRpbmdMZW5ndGg7XG4gIH0gZWxzZSBpZiAocGFkZGluZ0xlbmd0aCA+IGRpZmZzWzBdWzFdLmxlbmd0aCkge1xuICAgIC8vIEdyb3cgZmlyc3QgZXF1YWxpdHkuXG4gICAgdmFyIGV4dHJhTGVuZ3RoID0gcGFkZGluZ0xlbmd0aCAtIGRpZmZzWzBdWzFdLmxlbmd0aDtcbiAgICBkaWZmc1swXVsxXSA9IG51bGxQYWRkaW5nLnN1YnN0cmluZyhkaWZmc1swXVsxXS5sZW5ndGgpICsgZGlmZnNbMF1bMV07XG4gICAgcGF0Y2guc3RhcnQxIC09IGV4dHJhTGVuZ3RoO1xuICAgIHBhdGNoLnN0YXJ0MiAtPSBleHRyYUxlbmd0aDtcbiAgICBwYXRjaC5sZW5ndGgxICs9IGV4dHJhTGVuZ3RoO1xuICAgIHBhdGNoLmxlbmd0aDIgKz0gZXh0cmFMZW5ndGg7XG4gIH1cblxuICAvLyBBZGQgc29tZSBwYWRkaW5nIG9uIGVuZCBvZiBsYXN0IGRpZmYuXG4gIHBhdGNoID0gcGF0Y2hlc1twYXRjaGVzLmxlbmd0aCAtIDFdO1xuICBkaWZmcyA9IHBhdGNoLmRpZmZzO1xuICBpZiAoZGlmZnMubGVuZ3RoID09IDAgfHwgZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMF0gIT0gRElGRl9FUVVBTCkge1xuICAgIC8vIEFkZCBudWxsUGFkZGluZyBlcXVhbGl0eS5cbiAgICBkaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBudWxsUGFkZGluZ10pO1xuICAgIHBhdGNoLmxlbmd0aDEgKz0gcGFkZGluZ0xlbmd0aDtcbiAgICBwYXRjaC5sZW5ndGgyICs9IHBhZGRpbmdMZW5ndGg7XG4gIH0gZWxzZSBpZiAocGFkZGluZ0xlbmd0aCA+IGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzFdLmxlbmd0aCkge1xuICAgIC8vIEdyb3cgbGFzdCBlcXVhbGl0eS5cbiAgICB2YXIgZXh0cmFMZW5ndGggPSBwYWRkaW5nTGVuZ3RoIC0gZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0ubGVuZ3RoO1xuICAgIGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzFdICs9IG51bGxQYWRkaW5nLnN1YnN0cmluZygwLCBleHRyYUxlbmd0aCk7XG4gICAgcGF0Y2gubGVuZ3RoMSArPSBleHRyYUxlbmd0aDtcbiAgICBwYXRjaC5sZW5ndGgyICs9IGV4dHJhTGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIG51bGxQYWRkaW5nO1xufTtcblxuXG4vKipcbiAqIExvb2sgdGhyb3VnaCB0aGUgcGF0Y2hlcyBhbmQgYnJlYWsgdXAgYW55IHdoaWNoIGFyZSBsb25nZXIgdGhhbiB0aGUgbWF4aW11bVxuICogbGltaXQgb2YgdGhlIG1hdGNoIGFsZ29yaXRobS5cbiAqIEBwYXJhbSB7QXJyYXkuPHBhdGNoX29iaj59IHBhdGNoZXMgQXJyYXkgb2YgcGF0Y2ggb2JqZWN0cy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUucGF0Y2hfc3BsaXRNYXggPSBmdW5jdGlvbihwYXRjaGVzKSB7XG4gIGZvciAodmFyIHggPSAwOyB4IDwgcGF0Y2hlcy5sZW5ndGg7IHgrKykge1xuICAgIGlmIChwYXRjaGVzW3hdLmxlbmd0aDEgPiB0aGlzLk1hdGNoX01heEJpdHMpIHtcbiAgICAgIHZhciBiaWdwYXRjaCA9IHBhdGNoZXNbeF07XG4gICAgICAvLyBSZW1vdmUgdGhlIGJpZyBvbGQgcGF0Y2guXG4gICAgICBwYXRjaGVzLnNwbGljZSh4LS0sIDEpO1xuICAgICAgdmFyIHBhdGNoX3NpemUgPSB0aGlzLk1hdGNoX01heEJpdHM7XG4gICAgICB2YXIgc3RhcnQxID0gYmlncGF0Y2guc3RhcnQxO1xuICAgICAgdmFyIHN0YXJ0MiA9IGJpZ3BhdGNoLnN0YXJ0MjtcbiAgICAgIHZhciBwcmVjb250ZXh0ID0gJyc7XG4gICAgICB3aGlsZSAoYmlncGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIC8vIENyZWF0ZSBvbmUgb2Ygc2V2ZXJhbCBzbWFsbGVyIHBhdGNoZXMuXG4gICAgICAgIHZhciBwYXRjaCA9IG5ldyBwYXRjaF9vYmooKTtcbiAgICAgICAgdmFyIGVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgcGF0Y2guc3RhcnQxID0gc3RhcnQxIC0gcHJlY29udGV4dC5sZW5ndGg7XG4gICAgICAgIHBhdGNoLnN0YXJ0MiA9IHN0YXJ0MiAtIHByZWNvbnRleHQubGVuZ3RoO1xuICAgICAgICBpZiAocHJlY29udGV4dCAhPT0gJycpIHtcbiAgICAgICAgICBwYXRjaC5sZW5ndGgxID0gcGF0Y2gubGVuZ3RoMiA9IHByZWNvbnRleHQubGVuZ3RoO1xuICAgICAgICAgIHBhdGNoLmRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIHByZWNvbnRleHRdKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoYmlncGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwICYmXG4gICAgICAgICAgICAgICBwYXRjaC5sZW5ndGgxIDwgcGF0Y2hfc2l6ZSAtIHRoaXMuUGF0Y2hfTWFyZ2luKSB7XG4gICAgICAgICAgdmFyIGRpZmZfdHlwZSA9IGJpZ3BhdGNoLmRpZmZzWzBdWzBdO1xuICAgICAgICAgIHZhciBkaWZmX3RleHQgPSBiaWdwYXRjaC5kaWZmc1swXVsxXTtcbiAgICAgICAgICBpZiAoZGlmZl90eXBlID09PSBESUZGX0lOU0VSVCkge1xuICAgICAgICAgICAgLy8gSW5zZXJ0aW9ucyBhcmUgaGFybWxlc3MuXG4gICAgICAgICAgICBwYXRjaC5sZW5ndGgyICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBzdGFydDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIHBhdGNoLmRpZmZzLnB1c2goYmlncGF0Y2guZGlmZnMuc2hpZnQoKSk7XG4gICAgICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGlmZl90eXBlID09PSBESUZGX0RFTEVURSAmJiBwYXRjaC5kaWZmcy5sZW5ndGggPT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICAgcGF0Y2guZGlmZnNbMF1bMF0gPT0gRElGRl9FUVVBTCAmJlxuICAgICAgICAgICAgICAgICAgICAgZGlmZl90ZXh0Lmxlbmd0aCA+IDIgKiBwYXRjaF9zaXplKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgbGFyZ2UgZGVsZXRpb24uICBMZXQgaXQgcGFzcyBpbiBvbmUgY2h1bmsuXG4gICAgICAgICAgICBwYXRjaC5sZW5ndGgxICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBzdGFydDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKFtkaWZmX3R5cGUsIGRpZmZfdGV4dF0pO1xuICAgICAgICAgICAgYmlncGF0Y2guZGlmZnMuc2hpZnQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRGVsZXRpb24gb3IgZXF1YWxpdHkuICBPbmx5IHRha2UgYXMgbXVjaCBhcyB3ZSBjYW4gc3RvbWFjaC5cbiAgICAgICAgICAgIGRpZmZfdGV4dCA9IGRpZmZfdGV4dC5zdWJzdHJpbmcoMCwgcGF0Y2hfc2l6ZSAtIHBhdGNoLmxlbmd0aDEgLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLlBhdGNoX01hcmdpbik7XG4gICAgICAgICAgICBwYXRjaC5sZW5ndGgxICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBzdGFydDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChkaWZmX3R5cGUgPT09IERJRkZfRVFVQUwpIHtcbiAgICAgICAgICAgICAgcGF0Y2gubGVuZ3RoMiArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgICAgICAgICAgICBzdGFydDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKFtkaWZmX3R5cGUsIGRpZmZfdGV4dF0pO1xuICAgICAgICAgICAgaWYgKGRpZmZfdGV4dCA9PSBiaWdwYXRjaC5kaWZmc1swXVsxXSkge1xuICAgICAgICAgICAgICBiaWdwYXRjaC5kaWZmcy5zaGlmdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYmlncGF0Y2guZGlmZnNbMF1bMV0gPVxuICAgICAgICAgICAgICAgICAgYmlncGF0Y2guZGlmZnNbMF1bMV0uc3Vic3RyaW5nKGRpZmZfdGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlIHRoZSBoZWFkIGNvbnRleHQgZm9yIHRoZSBuZXh0IHBhdGNoLlxuICAgICAgICBwcmVjb250ZXh0ID0gdGhpcy5kaWZmX3RleHQyKHBhdGNoLmRpZmZzKTtcbiAgICAgICAgcHJlY29udGV4dCA9XG4gICAgICAgICAgICBwcmVjb250ZXh0LnN1YnN0cmluZyhwcmVjb250ZXh0Lmxlbmd0aCAtIHRoaXMuUGF0Y2hfTWFyZ2luKTtcbiAgICAgICAgLy8gQXBwZW5kIHRoZSBlbmQgY29udGV4dCBmb3IgdGhpcyBwYXRjaC5cbiAgICAgICAgdmFyIHBvc3Rjb250ZXh0ID0gdGhpcy5kaWZmX3RleHQxKGJpZ3BhdGNoLmRpZmZzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN1YnN0cmluZygwLCB0aGlzLlBhdGNoX01hcmdpbik7XG4gICAgICAgIGlmIChwb3N0Y29udGV4dCAhPT0gJycpIHtcbiAgICAgICAgICBwYXRjaC5sZW5ndGgxICs9IHBvc3Rjb250ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBwYXRjaC5sZW5ndGgyICs9IHBvc3Rjb250ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBpZiAocGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwICYmXG4gICAgICAgICAgICAgIHBhdGNoLmRpZmZzW3BhdGNoLmRpZmZzLmxlbmd0aCAtIDFdWzBdID09PSBESUZGX0VRVUFMKSB7XG4gICAgICAgICAgICBwYXRjaC5kaWZmc1twYXRjaC5kaWZmcy5sZW5ndGggLSAxXVsxXSArPSBwb3N0Y29udGV4dDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0Y2guZGlmZnMucHVzaChbRElGRl9FUVVBTCwgcG9zdGNvbnRleHRdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlbXB0eSkge1xuICAgICAgICAgIHBhdGNoZXMuc3BsaWNlKCsreCwgMCwgcGF0Y2gpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogVGFrZSBhIGxpc3Qgb2YgcGF0Y2hlcyBhbmQgcmV0dXJuIGEgdGV4dHVhbCByZXByZXNlbnRhdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXkuPHBhdGNoX29iaj59IHBhdGNoZXMgQXJyYXkgb2YgcGF0Y2ggb2JqZWN0cy5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGV4dCByZXByZXNlbnRhdGlvbiBvZiBwYXRjaGVzLlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5wYXRjaF90b1RleHQgPSBmdW5jdGlvbihwYXRjaGVzKSB7XG4gIHZhciB0ZXh0ID0gW107XG4gIGZvciAodmFyIHggPSAwOyB4IDwgcGF0Y2hlcy5sZW5ndGg7IHgrKykge1xuICAgIHRleHRbeF0gPSBwYXRjaGVzW3hdO1xuICB9XG4gIHJldHVybiB0ZXh0LmpvaW4oJycpO1xufTtcblxuXG4vKipcbiAqIFBhcnNlIGEgdGV4dHVhbCByZXByZXNlbnRhdGlvbiBvZiBwYXRjaGVzIGFuZCByZXR1cm4gYSBsaXN0IG9mIHBhdGNoIG9iamVjdHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dGxpbmUgVGV4dCByZXByZXNlbnRhdGlvbiBvZiBwYXRjaGVzLlxuICogQHJldHVybiB7QXJyYXkuPHBhdGNoX29iaj59IEFycmF5IG9mIHBhdGNoIG9iamVjdHMuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgaW52YWxpZCBpbnB1dC5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUucGF0Y2hfZnJvbVRleHQgPSBmdW5jdGlvbih0ZXh0bGluZSkge1xuICB2YXIgcGF0Y2hlcyA9IFtdO1xuICBpZiAoIXRleHRsaW5lKSB7XG4gICAgcmV0dXJuIHBhdGNoZXM7XG4gIH1cbiAgLy8gT3BlcmEgZG9lc24ndCBrbm93IGhvdyB0byBkZWNvZGUgY2hhciAwLlxuICB0ZXh0bGluZSA9IHRleHRsaW5lLnJlcGxhY2UoLyUwMC9nLCAnXFwwJyk7XG4gIHZhciB0ZXh0ID0gdGV4dGxpbmUuc3BsaXQoJ1xcbicpO1xuICB2YXIgdGV4dFBvaW50ZXIgPSAwO1xuICB3aGlsZSAodGV4dFBvaW50ZXIgPCB0ZXh0Lmxlbmd0aCkge1xuICAgIHZhciBtID0gdGV4dFt0ZXh0UG9pbnRlcl0ubWF0Y2goL15AQCAtKFxcZCspLD8oXFxkKikgXFwrKFxcZCspLD8oXFxkKikgQEAkLyk7XG4gICAgaWYgKCFtKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGF0Y2ggc3RyaW5nOiAnICsgdGV4dFt0ZXh0UG9pbnRlcl0pO1xuICAgIH1cbiAgICB2YXIgcGF0Y2ggPSBuZXcgcGF0Y2hfb2JqKCk7XG4gICAgcGF0Y2hlcy5wdXNoKHBhdGNoKTtcbiAgICBwYXRjaC5zdGFydDEgPSBwYXJzZUludChtWzFdLCAxMCk7XG4gICAgaWYgKG1bMl0gPT09ICcnKSB7XG4gICAgICBwYXRjaC5zdGFydDEtLTtcbiAgICAgIHBhdGNoLmxlbmd0aDEgPSAxO1xuICAgIH0gZWxzZSBpZiAobVsyXSA9PSAnMCcpIHtcbiAgICAgIHBhdGNoLmxlbmd0aDEgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRjaC5zdGFydDEtLTtcbiAgICAgIHBhdGNoLmxlbmd0aDEgPSBwYXJzZUludChtWzJdLCAxMCk7XG4gICAgfVxuXG4gICAgcGF0Y2guc3RhcnQyID0gcGFyc2VJbnQobVszXSwgMTApO1xuICAgIGlmIChtWzRdID09PSAnJykge1xuICAgICAgcGF0Y2guc3RhcnQyLS07XG4gICAgICBwYXRjaC5sZW5ndGgyID0gMTtcbiAgICB9IGVsc2UgaWYgKG1bNF0gPT0gJzAnKSB7XG4gICAgICBwYXRjaC5sZW5ndGgyID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0Y2guc3RhcnQyLS07XG4gICAgICBwYXRjaC5sZW5ndGgyID0gcGFyc2VJbnQobVs0XSwgMTApO1xuICAgIH1cbiAgICB0ZXh0UG9pbnRlcisrO1xuXG4gICAgd2hpbGUgKHRleHRQb2ludGVyIDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgIHZhciBzaWduID0gdGV4dFt0ZXh0UG9pbnRlcl0uY2hhckF0KDApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGxpbmUgPSBkZWNvZGVVUkkodGV4dFt0ZXh0UG9pbnRlcl0uc3Vic3RyaW5nKDEpKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIC8vIE1hbGZvcm1lZCBVUkkgc2VxdWVuY2UuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBlc2NhcGUgaW4gcGF0Y2hfZnJvbVRleHQ6ICcgKyBsaW5lKTtcbiAgICAgIH1cbiAgICAgIGlmIChzaWduID09ICctJykge1xuICAgICAgICAvLyBEZWxldGlvbi5cbiAgICAgICAgcGF0Y2guZGlmZnMucHVzaChbRElGRl9ERUxFVEUsIGxpbmVdKTtcbiAgICAgIH0gZWxzZSBpZiAoc2lnbiA9PSAnKycpIHtcbiAgICAgICAgLy8gSW5zZXJ0aW9uLlxuICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0lOU0VSVCwgbGluZV0pO1xuICAgICAgfSBlbHNlIGlmIChzaWduID09ICcgJykge1xuICAgICAgICAvLyBNaW5vciBlcXVhbGl0eS5cbiAgICAgICAgcGF0Y2guZGlmZnMucHVzaChbRElGRl9FUVVBTCwgbGluZV0pO1xuICAgICAgfSBlbHNlIGlmIChzaWduID09ICdAJykge1xuICAgICAgICAvLyBTdGFydCBvZiBuZXh0IHBhdGNoLlxuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoc2lnbiA9PT0gJycpIHtcbiAgICAgICAgLy8gQmxhbmsgbGluZT8gIFdoYXRldmVyLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV1RGP1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGF0Y2ggbW9kZSBcIicgKyBzaWduICsgJ1wiIGluOiAnICsgbGluZSk7XG4gICAgICB9XG4gICAgICB0ZXh0UG9pbnRlcisrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGF0Y2hlcztcbn07XG5cblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgb25lIHBhdGNoIG9wZXJhdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBwYXRjaF9vYmooKSB7XG4gIC8qKiBAdHlwZSB7QXJyYXkuPEFycmF5LjxudW1iZXJ8c3RyaW5nPj59ICovXG4gIHRoaXMuZGlmZnMgPSBbXTtcbiAgLyoqIEB0eXBlIHs/bnVtYmVyfSAqL1xuICB0aGlzLnN0YXJ0MSA9IG51bGw7XG4gIC8qKiBAdHlwZSB7P251bWJlcn0gKi9cbiAgdGhpcy5zdGFydDIgPSBudWxsO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdGhpcy5sZW5ndGgxID0gMDtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHRoaXMubGVuZ3RoMiA9IDA7XG59XG5cblxuLyoqXG4gKiBFbW11bGF0ZSBHTlUgZGlmZidzIGZvcm1hdC5cbiAqIEhlYWRlcjogQEAgLTM4Miw4ICs0ODEsOSBAQFxuICogSW5kaWNpZXMgYXJlIHByaW50ZWQgYXMgMS1iYXNlZCwgbm90IDAtYmFzZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBHTlUgZGlmZiBzdHJpbmcuXG4gKi9cbnBhdGNoX29iai5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNvb3JkczEsIGNvb3JkczI7XG4gIGlmICh0aGlzLmxlbmd0aDEgPT09IDApIHtcbiAgICBjb29yZHMxID0gdGhpcy5zdGFydDEgKyAnLDAnO1xuICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoMSA9PSAxKSB7XG4gICAgY29vcmRzMSA9IHRoaXMuc3RhcnQxICsgMTtcbiAgfSBlbHNlIHtcbiAgICBjb29yZHMxID0gKHRoaXMuc3RhcnQxICsgMSkgKyAnLCcgKyB0aGlzLmxlbmd0aDE7XG4gIH1cbiAgaWYgKHRoaXMubGVuZ3RoMiA9PT0gMCkge1xuICAgIGNvb3JkczIgPSB0aGlzLnN0YXJ0MiArICcsMCc7XG4gIH0gZWxzZSBpZiAodGhpcy5sZW5ndGgyID09IDEpIHtcbiAgICBjb29yZHMyID0gdGhpcy5zdGFydDIgKyAxO1xuICB9IGVsc2Uge1xuICAgIGNvb3JkczIgPSAodGhpcy5zdGFydDIgKyAxKSArICcsJyArIHRoaXMubGVuZ3RoMjtcbiAgfVxuICB2YXIgdGV4dCA9IFsnQEAgLScgKyBjb29yZHMxICsgJyArJyArIGNvb3JkczIgKyAnIEBAXFxuJ107XG4gIHZhciBvcDtcbiAgLy8gRXNjYXBlIHRoZSBib2R5IG9mIHRoZSBwYXRjaCB3aXRoICV4eCBub3RhdGlvbi5cbiAgZm9yICh2YXIgeCA9IDA7IHggPCB0aGlzLmRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgc3dpdGNoICh0aGlzLmRpZmZzW3hdWzBdKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICBvcCA9ICcrJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxuICAgICAgICBvcCA9ICctJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgIG9wID0gJyAnO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGV4dFt4ICsgMV0gPSBvcCArIGVuY29kZVVSSSh0aGlzLmRpZmZzW3hdWzFdKSArICdcXG4nO1xuICB9XG4gIC8vIE9wZXJhIGRvZXNuJ3Qga25vdyBob3cgdG8gZW5jb2RlIGNoYXIgMC5cbiAgcmV0dXJuIHRleHQuam9pbignJykucmVwbGFjZSgvXFx4MDAvZywgJyUwMCcpLnJlcGxhY2UoLyUyMC9nLCAnICcpO1xufTtcblxuXG4vLyBFeHBvcnQgdGhlc2UgZ2xvYmFsIHZhcmlhYmxlcyBzbyB0aGF0IHRoZXkgc3Vydml2ZSBHb29nbGUncyBKUyBjb21waWxlci5cbi8qY2hhbmdlZCBieSBsZmJvcmphczogY2hhbmdlZCBgd2luZG93YCBmb3IgYGV4cG9ydHNgIHRvIG1ha2UgaXQgc3VpdGFibGUgZm9yIHRoZSBub2RlLmpzIG1vZHVsZSBjb252ZW50aW9ucyovXG5leHBvcnRzWydkaWZmX21hdGNoX3BhdGNoJ10gPSBkaWZmX21hdGNoX3BhdGNoO1xuZXhwb3J0c1sncGF0Y2hfb2JqJ10gPSBwYXRjaF9vYmo7XG5leHBvcnRzWydESUZGX0RFTEVURSddID0gRElGRl9ERUxFVEU7XG5leHBvcnRzWydESUZGX0lOU0VSVCddID0gRElGRl9JTlNFUlQ7XG5leHBvcnRzWydESUZGX0VRVUFMJ10gPSBESUZGX0VRVUFMO1xuIiwiKGZ1bmN0aW9uIChQcmlzbSkge1xuXHR2YXIgZnVuY1BhdHRlcm4gPSAvXFxcXCg/OlteYS16KClbXFxdXXxbYS16Kl0rKS9pO1xuXHR2YXIgaW5zaWRlRXF1ID0ge1xuXHRcdCdlcXVhdGlvbi1jb21tYW5kJzoge1xuXHRcdFx0cGF0dGVybjogZnVuY1BhdHRlcm4sXG5cdFx0XHRhbGlhczogJ3JlZ2V4J1xuXHRcdH1cblx0fTtcblxuXHRQcmlzbS5sYW5ndWFnZXMubGF0ZXggPSB7XG5cdFx0J2NvbW1lbnQnOiAvJS4qLyxcblx0XHQvLyB0aGUgdmVyYmF0aW0gZW52aXJvbm1lbnQgcHJpbnRzIHdoaXRlc3BhY2UgdG8gdGhlIGRvY3VtZW50XG5cdFx0J2NkYXRhJzoge1xuXHRcdFx0cGF0dGVybjogLyhcXFxcYmVnaW5cXHsoKD86bHN0bGlzdGluZ3x2ZXJiYXRpbSlcXCo/KVxcfSlbXFxzXFxTXSo/KD89XFxcXGVuZFxce1xcMlxcfSkvLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZVxuXHRcdH0sXG5cdFx0Lypcblx0XHQgKiBlcXVhdGlvbnMgY2FuIGJlIGJldHdlZW4gJCQgJCQgb3IgJCAkIG9yIFxcKCBcXCkgb3IgXFxbIFxcXVxuXHRcdCAqIChhbGwgYXJlIG11bHRpbGluZSlcblx0XHQgKi9cblx0XHQnZXF1YXRpb24nOiBbXG5cdFx0XHR7XG5cdFx0XHRcdHBhdHRlcm46IC9cXCRcXCQoPzpcXFxcW1xcc1xcU118W15cXFxcJF0pK1xcJFxcJHxcXCQoPzpcXFxcW1xcc1xcU118W15cXFxcJF0pK1xcJHxcXFxcXFwoW1xcc1xcU10qP1xcXFxcXCl8XFxcXFxcW1tcXHNcXFNdKj9cXFxcXFxdLyxcblx0XHRcdFx0aW5zaWRlOiBpbnNpZGVFcXUsXG5cdFx0XHRcdGFsaWFzOiAnc3RyaW5nJ1xuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0cGF0dGVybjogLyhcXFxcYmVnaW5cXHsoKD86YWxpZ258ZXFuYXJyYXl8ZXF1YXRpb258Z2F0aGVyfG1hdGh8bXVsdGxpbmUpXFwqPylcXH0pW1xcc1xcU10qPyg/PVxcXFxlbmRcXHtcXDJcXH0pLyxcblx0XHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdFx0aW5zaWRlOiBpbnNpZGVFcXUsXG5cdFx0XHRcdGFsaWFzOiAnc3RyaW5nJ1xuXHRcdFx0fVxuXHRcdF0sXG5cdFx0Lypcblx0XHQgKiBhcmd1bWVudHMgd2hpY2ggYXJlIGtleXdvcmRzIG9yIHJlZmVyZW5jZXMgYXJlIGhpZ2hsaWdodGVkXG5cdFx0ICogYXMga2V5d29yZHNcblx0XHQgKi9cblx0XHQna2V5d29yZCc6IHtcblx0XHRcdHBhdHRlcm46IC8oXFxcXCg/OmJlZ2lufGNpdGV8ZG9jdW1lbnRjbGFzc3xlbmR8bGFiZWx8cmVmfHVzZXBhY2thZ2UpKD86XFxbW15cXF1dK1xcXSk/XFx7KVtefV0rKD89XFx9KS8sXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdFx0fSxcblx0XHQndXJsJzoge1xuXHRcdFx0cGF0dGVybjogLyhcXFxcdXJsXFx7KVtefV0rKD89XFx9KS8sXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdFx0fSxcblx0XHQvKlxuXHRcdCAqIHNlY3Rpb24gb3IgY2hhcHRlciBoZWFkbGluZXMgYXJlIGhpZ2hsaWdodGVkIGFzIGJvbGQgc28gdGhhdFxuXHRcdCAqIHRoZXkgc3RhbmQgb3V0IG1vcmVcblx0XHQgKi9cblx0XHQnaGVhZGxpbmUnOiB7XG5cdFx0XHRwYXR0ZXJuOiAvKFxcXFwoPzpjaGFwdGVyfGZyYW1ldGl0bGV8cGFyYWdyYXBofHBhcnR8c2VjdGlvbnxzdWJwYXJhZ3JhcGh8c3Vic2VjdGlvbnxzdWJzdWJwYXJhZ3JhcGh8c3Vic3Vic2VjdGlvbnxzdWJzdWJzdWJwYXJhZ3JhcGgpXFwqPyg/OlxcW1teXFxdXStcXF0pP1xceylbXn1dKyg/PVxcfSkvLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGFsaWFzOiAnY2xhc3MtbmFtZSdcblx0XHR9LFxuXHRcdCdmdW5jdGlvbic6IHtcblx0XHRcdHBhdHRlcm46IGZ1bmNQYXR0ZXJuLFxuXHRcdFx0YWxpYXM6ICdzZWxlY3Rvcidcblx0XHR9LFxuXHRcdCdwdW5jdHVhdGlvbic6IC9bW1xcXXt9Jl0vXG5cdH07XG5cblx0UHJpc20ubGFuZ3VhZ2VzLnRleCA9IFByaXNtLmxhbmd1YWdlcy5sYXRleDtcblx0UHJpc20ubGFuZ3VhZ2VzLmNvbnRleHQgPSBQcmlzbS5sYW5ndWFnZXMubGF0ZXg7XG59KFByaXNtKSk7XG4iLCJcbi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgQmVnaW4gcHJpc20tY29yZS5qc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG4vLy8gPHJlZmVyZW5jZSBsaWI9XCJXZWJXb3JrZXJcIi8+XG5cbnZhciBfc2VsZiA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJylcblx0PyB3aW5kb3cgICAvLyBpZiBpbiBicm93c2VyXG5cdDogKFxuXHRcdCh0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgIT09ICd1bmRlZmluZWQnICYmIHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZSlcblx0XHRcdD8gc2VsZiAvLyBpZiBpbiB3b3JrZXJcblx0XHRcdDoge30gICAvLyBpZiBpbiBub2RlIGpzXG5cdCk7XG5cbi8qKlxuICogUHJpc206IExpZ2h0d2VpZ2h0LCByb2J1c3QsIGVsZWdhbnQgc3ludGF4IGhpZ2hsaWdodGluZ1xuICpcbiAqIEBsaWNlbnNlIE1JVCA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+XG4gKiBAYXV0aG9yIExlYSBWZXJvdSA8aHR0cHM6Ly9sZWEudmVyb3UubWU+XG4gKiBAbmFtZXNwYWNlXG4gKiBAcHVibGljXG4gKi9cbnZhciBQcmlzbSA9IChmdW5jdGlvbiAoX3NlbGYpIHtcblxuXHQvLyBQcml2YXRlIGhlbHBlciB2YXJzXG5cdHZhciBsYW5nID0gLyg/Ol58XFxzKWxhbmcoPzp1YWdlKT8tKFtcXHctXSspKD89XFxzfCQpL2k7XG5cdHZhciB1bmlxdWVJZCA9IDA7XG5cblx0Ly8gVGhlIGdyYW1tYXIgb2JqZWN0IGZvciBwbGFpbnRleHRcblx0dmFyIHBsYWluVGV4dEdyYW1tYXIgPSB7fTtcblxuXG5cdHZhciBfID0ge1xuXHRcdC8qKlxuXHRcdCAqIEJ5IGRlZmF1bHQsIFByaXNtIHdpbGwgYXR0ZW1wdCB0byBoaWdobGlnaHQgYWxsIGNvZGUgZWxlbWVudHMgKGJ5IGNhbGxpbmcge0BsaW5rIFByaXNtLmhpZ2hsaWdodEFsbH0pIG9uIHRoZVxuXHRcdCAqIGN1cnJlbnQgcGFnZSBhZnRlciB0aGUgcGFnZSBmaW5pc2hlZCBsb2FkaW5nLiBUaGlzIG1pZ2h0IGJlIGEgcHJvYmxlbSBpZiBlLmcuIHlvdSB3YW50ZWQgdG8gYXN5bmNocm9ub3VzbHkgbG9hZFxuXHRcdCAqIGFkZGl0aW9uYWwgbGFuZ3VhZ2VzIG9yIHBsdWdpbnMgeW91cnNlbGYuXG5cdFx0ICpcblx0XHQgKiBCeSBzZXR0aW5nIHRoaXMgdmFsdWUgdG8gYHRydWVgLCBQcmlzbSB3aWxsIG5vdCBhdXRvbWF0aWNhbGx5IGhpZ2hsaWdodCBhbGwgY29kZSBlbGVtZW50cyBvbiB0aGUgcGFnZS5cblx0XHQgKlxuXHRcdCAqIFlvdSBvYnZpb3VzbHkgaGF2ZSB0byBjaGFuZ2UgdGhpcyB2YWx1ZSBiZWZvcmUgdGhlIGF1dG9tYXRpYyBoaWdobGlnaHRpbmcgc3RhcnRlZC4gVG8gZG8gdGhpcywgeW91IGNhbiBhZGQgYW5cblx0XHQgKiBlbXB0eSBQcmlzbSBvYmplY3QgaW50byB0aGUgZ2xvYmFsIHNjb3BlIGJlZm9yZSBsb2FkaW5nIHRoZSBQcmlzbSBzY3JpcHQgbGlrZSB0aGlzOlxuXHRcdCAqXG5cdFx0ICogYGBganNcblx0XHQgKiB3aW5kb3cuUHJpc20gPSB3aW5kb3cuUHJpc20gfHwge307XG5cdFx0ICogUHJpc20ubWFudWFsID0gdHJ1ZTtcblx0XHQgKiAvLyBhZGQgYSBuZXcgPHNjcmlwdD4gdG8gbG9hZCBQcmlzbSdzIHNjcmlwdFxuXHRcdCAqIGBgYFxuXHRcdCAqXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAbWVtYmVyb2YgUHJpc21cblx0XHQgKiBAcHVibGljXG5cdFx0ICovXG5cdFx0bWFudWFsOiBfc2VsZi5QcmlzbSAmJiBfc2VsZi5QcmlzbS5tYW51YWwsXG5cdFx0LyoqXG5cdFx0ICogQnkgZGVmYXVsdCwgaWYgUHJpc20gaXMgaW4gYSB3ZWIgd29ya2VyLCBpdCBhc3N1bWVzIHRoYXQgaXQgaXMgaW4gYSB3b3JrZXIgaXQgY3JlYXRlZCBpdHNlbGYsIHNvIGl0IHVzZXNcblx0XHQgKiBgYWRkRXZlbnRMaXN0ZW5lcmAgdG8gY29tbXVuaWNhdGUgd2l0aCBpdHMgcGFyZW50IGluc3RhbmNlLiBIb3dldmVyLCBpZiB5b3UncmUgdXNpbmcgUHJpc20gbWFudWFsbHkgaW4geW91clxuXHRcdCAqIG93biB3b3JrZXIsIHlvdSBkb24ndCB3YW50IGl0IHRvIGRvIHRoaXMuXG5cdFx0ICpcblx0XHQgKiBCeSBzZXR0aW5nIHRoaXMgdmFsdWUgdG8gYHRydWVgLCBQcmlzbSB3aWxsIG5vdCBhZGQgaXRzIG93biBsaXN0ZW5lcnMgdG8gdGhlIHdvcmtlci5cblx0XHQgKlxuXHRcdCAqIFlvdSBvYnZpb3VzbHkgaGF2ZSB0byBjaGFuZ2UgdGhpcyB2YWx1ZSBiZWZvcmUgUHJpc20gZXhlY3V0ZXMuIFRvIGRvIHRoaXMsIHlvdSBjYW4gYWRkIGFuXG5cdFx0ICogZW1wdHkgUHJpc20gb2JqZWN0IGludG8gdGhlIGdsb2JhbCBzY29wZSBiZWZvcmUgbG9hZGluZyB0aGUgUHJpc20gc2NyaXB0IGxpa2UgdGhpczpcblx0XHQgKlxuXHRcdCAqIGBgYGpzXG5cdFx0ICogd2luZG93LlByaXNtID0gd2luZG93LlByaXNtIHx8IHt9O1xuXHRcdCAqIFByaXNtLmRpc2FibGVXb3JrZXJNZXNzYWdlSGFuZGxlciA9IHRydWU7XG5cdFx0ICogLy8gTG9hZCBQcmlzbSdzIHNjcmlwdFxuXHRcdCAqIGBgYFxuXHRcdCAqXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAbWVtYmVyb2YgUHJpc21cblx0XHQgKiBAcHVibGljXG5cdFx0ICovXG5cdFx0ZGlzYWJsZVdvcmtlck1lc3NhZ2VIYW5kbGVyOiBfc2VsZi5QcmlzbSAmJiBfc2VsZi5QcmlzbS5kaXNhYmxlV29ya2VyTWVzc2FnZUhhbmRsZXIsXG5cblx0XHQvKipcblx0XHQgKiBBIG5hbWVzcGFjZSBmb3IgdXRpbGl0eSBtZXRob2RzLlxuXHRcdCAqXG5cdFx0ICogQWxsIGZ1bmN0aW9uIGluIHRoaXMgbmFtZXNwYWNlIHRoYXQgYXJlIG5vdCBleHBsaWNpdGx5IG1hcmtlZCBhcyBfcHVibGljXyBhcmUgZm9yIF9faW50ZXJuYWwgdXNlIG9ubHlfXyBhbmQgbWF5XG5cdFx0ICogY2hhbmdlIG9yIGRpc2FwcGVhciBhdCBhbnkgdGltZS5cblx0XHQgKlxuXHRcdCAqIEBuYW1lc3BhY2Vcblx0XHQgKiBAbWVtYmVyb2YgUHJpc21cblx0XHQgKi9cblx0XHR1dGlsOiB7XG5cdFx0XHRlbmNvZGU6IGZ1bmN0aW9uIGVuY29kZSh0b2tlbnMpIHtcblx0XHRcdFx0aWYgKHRva2VucyBpbnN0YW5jZW9mIFRva2VuKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBUb2tlbih0b2tlbnMudHlwZSwgZW5jb2RlKHRva2Vucy5jb250ZW50KSwgdG9rZW5zLmFsaWFzKTtcblx0XHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRva2VucykpIHtcblx0XHRcdFx0XHRyZXR1cm4gdG9rZW5zLm1hcChlbmNvZGUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiB0b2tlbnMucmVwbGFjZSgvJi9nLCAnJmFtcDsnKS5yZXBsYWNlKC88L2csICcmbHQ7JykucmVwbGFjZSgvXFx1MDBhMC9nLCAnICcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIHR5cGUgb2YgdGhlIGdpdmVuIHZhbHVlLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7YW55fSBvXG5cdFx0XHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIHR5cGUobnVsbCkgICAgICA9PT0gJ051bGwnXG5cdFx0XHQgKiB0eXBlKHVuZGVmaW5lZCkgPT09ICdVbmRlZmluZWQnXG5cdFx0XHQgKiB0eXBlKDEyMykgICAgICAgPT09ICdOdW1iZXInXG5cdFx0XHQgKiB0eXBlKCdmb28nKSAgICAgPT09ICdTdHJpbmcnXG5cdFx0XHQgKiB0eXBlKHRydWUpICAgICAgPT09ICdCb29sZWFuJ1xuXHRcdFx0ICogdHlwZShbMSwgMl0pICAgID09PSAnQXJyYXknXG5cdFx0XHQgKiB0eXBlKHt9KSAgICAgICAgPT09ICdPYmplY3QnXG5cdFx0XHQgKiB0eXBlKFN0cmluZykgICAgPT09ICdGdW5jdGlvbidcblx0XHRcdCAqIHR5cGUoL2FiYysvKSAgICA9PT0gJ1JlZ0V4cCdcblx0XHRcdCAqL1xuXHRcdFx0dHlwZTogZnVuY3Rpb24gKG8pIHtcblx0XHRcdFx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFJldHVybnMgYSB1bmlxdWUgbnVtYmVyIGZvciB0aGUgZ2l2ZW4gb2JqZWN0LiBMYXRlciBjYWxscyB3aWxsIHN0aWxsIHJldHVybiB0aGUgc2FtZSBudW1iZXIuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG9ialxuXHRcdFx0ICogQHJldHVybnMge251bWJlcn1cblx0XHRcdCAqL1xuXHRcdFx0b2JqSWQ6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdFx0aWYgKCFvYmpbJ19faWQnXSkge1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosICdfX2lkJywgeyB2YWx1ZTogKyt1bmlxdWVJZCB9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gb2JqWydfX2lkJ107XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIENyZWF0ZXMgYSBkZWVwIGNsb25lIG9mIHRoZSBnaXZlbiBvYmplY3QuXG5cdFx0XHQgKlxuXHRcdFx0ICogVGhlIG1haW4gaW50ZW5kZWQgdXNlIG9mIHRoaXMgZnVuY3Rpb24gaXMgdG8gY2xvbmUgbGFuZ3VhZ2UgZGVmaW5pdGlvbnMuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtUfSBvXG5cdFx0XHQgKiBAcGFyYW0ge1JlY29yZDxudW1iZXIsIGFueT59IFt2aXNpdGVkXVxuXHRcdFx0ICogQHJldHVybnMge1R9XG5cdFx0XHQgKiBAdGVtcGxhdGUgVFxuXHRcdFx0ICovXG5cdFx0XHRjbG9uZTogZnVuY3Rpb24gZGVlcENsb25lKG8sIHZpc2l0ZWQpIHtcblx0XHRcdFx0dmlzaXRlZCA9IHZpc2l0ZWQgfHwge307XG5cblx0XHRcdFx0dmFyIGNsb25lOyB2YXIgaWQ7XG5cdFx0XHRcdHN3aXRjaCAoXy51dGlsLnR5cGUobykpIHtcblx0XHRcdFx0XHRjYXNlICdPYmplY3QnOlxuXHRcdFx0XHRcdFx0aWQgPSBfLnV0aWwub2JqSWQobyk7XG5cdFx0XHRcdFx0XHRpZiAodmlzaXRlZFtpZF0pIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZpc2l0ZWRbaWRdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y2xvbmUgPSAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIGFueT59ICovICh7fSk7XG5cdFx0XHRcdFx0XHR2aXNpdGVkW2lkXSA9IGNsb25lO1xuXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gbykge1xuXHRcdFx0XHRcdFx0XHRpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2xvbmVba2V5XSA9IGRlZXBDbG9uZShvW2tleV0sIHZpc2l0ZWQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJldHVybiAvKiogQHR5cGUge2FueX0gKi8gKGNsb25lKTtcblxuXHRcdFx0XHRcdGNhc2UgJ0FycmF5Jzpcblx0XHRcdFx0XHRcdGlkID0gXy51dGlsLm9iaklkKG8pO1xuXHRcdFx0XHRcdFx0aWYgKHZpc2l0ZWRbaWRdKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2aXNpdGVkW2lkXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNsb25lID0gW107XG5cdFx0XHRcdFx0XHR2aXNpdGVkW2lkXSA9IGNsb25lO1xuXG5cdFx0XHRcdFx0XHQoLyoqIEB0eXBlIHtBcnJheX0gKi8oLyoqIEB0eXBlIHthbnl9ICovKG8pKSkuZm9yRWFjaChmdW5jdGlvbiAodiwgaSkge1xuXHRcdFx0XHRcdFx0XHRjbG9uZVtpXSA9IGRlZXBDbG9uZSh2LCB2aXNpdGVkKTtcblx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gLyoqIEB0eXBlIHthbnl9ICovIChjbG9uZSk7XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0cmV0dXJuIG87XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogUmV0dXJucyB0aGUgUHJpc20gbGFuZ3VhZ2Ugb2YgdGhlIGdpdmVuIGVsZW1lbnQgc2V0IGJ5IGEgYGxhbmd1YWdlLXh4eHhgIG9yIGBsYW5nLXh4eHhgIGNsYXNzLlxuXHRcdFx0ICpcblx0XHRcdCAqIElmIG5vIGxhbmd1YWdlIGlzIHNldCBmb3IgdGhlIGVsZW1lbnQgb3IgdGhlIGVsZW1lbnQgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLCBgbm9uZWAgd2lsbCBiZSByZXR1cm5lZC5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcblx0XHRcdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdFx0XHQgKi9cblx0XHRcdGdldExhbmd1YWdlOiBmdW5jdGlvbiAoZWxlbWVudCkge1xuXHRcdFx0XHR3aGlsZSAoZWxlbWVudCkge1xuXHRcdFx0XHRcdHZhciBtID0gbGFuZy5leGVjKGVsZW1lbnQuY2xhc3NOYW1lKTtcblx0XHRcdFx0XHRpZiAobSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG1bMV0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxlbWVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gJ25vbmUnO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXRzIHRoZSBQcmlzbSBgbGFuZ3VhZ2UteHh4eGAgY2xhc3Mgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2Vcblx0XHRcdCAqIEByZXR1cm5zIHt2b2lkfVxuXHRcdFx0ICovXG5cdFx0XHRzZXRMYW5ndWFnZTogZnVuY3Rpb24gKGVsZW1lbnQsIGxhbmd1YWdlKSB7XG5cdFx0XHRcdC8vIHJlbW92ZSBhbGwgYGxhbmd1YWdlLXh4eHhgIGNsYXNzZXNcblx0XHRcdFx0Ly8gKHRoaXMgbWlnaHQgbGVhdmUgYmVoaW5kIGEgbGVhZGluZyBzcGFjZSlcblx0XHRcdFx0ZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZS5yZXBsYWNlKFJlZ0V4cChsYW5nLCAnZ2knKSwgJycpO1xuXG5cdFx0XHRcdC8vIGFkZCB0aGUgbmV3IGBsYW5ndWFnZS14eHh4YCBjbGFzc1xuXHRcdFx0XHQvLyAodXNpbmcgYGNsYXNzTGlzdGAgd2lsbCBhdXRvbWF0aWNhbGx5IGNsZWFuIHVwIHNwYWNlcyBmb3IgdXMpXG5cdFx0XHRcdGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnbGFuZ3VhZ2UtJyArIGxhbmd1YWdlKTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogUmV0dXJucyB0aGUgc2NyaXB0IGVsZW1lbnQgdGhhdCBpcyBjdXJyZW50bHkgZXhlY3V0aW5nLlxuXHRcdFx0ICpcblx0XHRcdCAqIFRoaXMgZG9lcyBfX25vdF9fIHdvcmsgZm9yIGxpbmUgc2NyaXB0IGVsZW1lbnQuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHJldHVybnMge0hUTUxTY3JpcHRFbGVtZW50IHwgbnVsbH1cblx0XHRcdCAqL1xuXHRcdFx0Y3VycmVudFNjcmlwdDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICgnY3VycmVudFNjcmlwdCcgaW4gZG9jdW1lbnQgJiYgMSA8IDIgLyogaGFjayB0byB0cmlwIFRTJyBmbG93IGFuYWx5c2lzICovKSB7XG5cdFx0XHRcdFx0cmV0dXJuIC8qKiBAdHlwZSB7YW55fSAqLyAoZG9jdW1lbnQuY3VycmVudFNjcmlwdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJRTExIHdvcmthcm91bmRcblx0XHRcdFx0Ly8gd2UnbGwgZ2V0IHRoZSBzcmMgb2YgdGhlIGN1cnJlbnQgc2NyaXB0IGJ5IHBhcnNpbmcgSUUxMSdzIGVycm9yIHN0YWNrIHRyYWNlXG5cdFx0XHRcdC8vIHRoaXMgd2lsbCBub3Qgd29yayBmb3IgaW5saW5lIHNjcmlwdHNcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcigpO1xuXHRcdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0XHQvLyBHZXQgZmlsZSBzcmMgdXJsIGZyb20gc3RhY2suIFNwZWNpZmljYWxseSB3b3JrcyB3aXRoIHRoZSBmb3JtYXQgb2Ygc3RhY2sgdHJhY2VzIGluIElFLlxuXHRcdFx0XHRcdC8vIEEgc3RhY2sgd2lsbCBsb29rIGxpa2UgdGhpczpcblx0XHRcdFx0XHQvL1xuXHRcdFx0XHRcdC8vIEVycm9yXG5cdFx0XHRcdFx0Ly8gICAgYXQgXy51dGlsLmN1cnJlbnRTY3JpcHQgKGh0dHA6Ly9sb2NhbGhvc3QvY29tcG9uZW50cy9wcmlzbS1jb3JlLmpzOjExOTo1KVxuXHRcdFx0XHRcdC8vICAgIGF0IEdsb2JhbCBjb2RlIChodHRwOi8vbG9jYWxob3N0L2NvbXBvbmVudHMvcHJpc20tY29yZS5qczo2MDY6MSlcblxuXHRcdFx0XHRcdHZhciBzcmMgPSAoL2F0IFteKFxcclxcbl0qXFwoKC4qKTpbXjpdKzpbXjpdK1xcKSQvaS5leGVjKGVyci5zdGFjaykgfHwgW10pWzFdO1xuXHRcdFx0XHRcdGlmIChzcmMpIHtcblx0XHRcdFx0XHRcdHZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSBpbiBzY3JpcHRzKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChzY3JpcHRzW2ldLnNyYyA9PSBzcmMpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gc2NyaXB0c1tpXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBSZXR1cm5zIHdoZXRoZXIgYSBnaXZlbiBjbGFzcyBpcyBhY3RpdmUgZm9yIGBlbGVtZW50YC5cblx0XHRcdCAqXG5cdFx0XHQgKiBUaGUgY2xhc3MgY2FuIGJlIGFjdGl2YXRlZCBpZiBgZWxlbWVudGAgb3Igb25lIG9mIGl0cyBhbmNlc3RvcnMgaGFzIHRoZSBnaXZlbiBjbGFzcyBhbmQgaXQgY2FuIGJlIGRlYWN0aXZhdGVkXG5cdFx0XHQgKiBpZiBgZWxlbWVudGAgb3Igb25lIG9mIGl0cyBhbmNlc3RvcnMgaGFzIHRoZSBuZWdhdGVkIHZlcnNpb24gb2YgdGhlIGdpdmVuIGNsYXNzLiBUaGUgX25lZ2F0ZWQgdmVyc2lvbl8gb2YgdGhlXG5cdFx0XHQgKiBnaXZlbiBjbGFzcyBpcyBqdXN0IHRoZSBnaXZlbiBjbGFzcyB3aXRoIGEgYG5vLWAgcHJlZml4LlxuXHRcdFx0ICpcblx0XHRcdCAqIFdoZXRoZXIgdGhlIGNsYXNzIGlzIGFjdGl2ZSBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBjbG9zZXN0IGFuY2VzdG9yIG9mIGBlbGVtZW50YCAod2hlcmUgYGVsZW1lbnRgIGl0c2VsZiBpc1xuXHRcdFx0ICogY2xvc2VzdCBhbmNlc3RvcikgdGhhdCBoYXMgdGhlIGdpdmVuIGNsYXNzIG9yIHRoZSBuZWdhdGVkIHZlcnNpb24gb2YgaXQuIElmIG5laXRoZXIgYGVsZW1lbnRgIG5vciBhbnkgb2YgaXRzXG5cdFx0XHQgKiBhbmNlc3RvcnMgaGF2ZSB0aGUgZ2l2ZW4gY2xhc3Mgb3IgdGhlIG5lZ2F0ZWQgdmVyc2lvbiBvZiBpdCwgdGhlbiB0aGUgZGVmYXVsdCBhY3RpdmF0aW9uIHdpbGwgYmUgcmV0dXJuZWQuXG5cdFx0XHQgKlxuXHRcdFx0ICogSW4gdGhlIHBhcmFkb3hpY2FsIHNpdHVhdGlvbiB3aGVyZSB0aGUgY2xvc2VzdCBhbmNlc3RvciBjb250YWlucyBfX2JvdGhfXyB0aGUgZ2l2ZW4gY2xhc3MgYW5kIHRoZSBuZWdhdGVkXG5cdFx0XHQgKiB2ZXJzaW9uIG9mIGl0LCB0aGUgY2xhc3MgaXMgY29uc2lkZXJlZCBhY3RpdmUuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG5cdFx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtkZWZhdWx0QWN0aXZhdGlvbj1mYWxzZV1cblx0XHRcdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHRcdFx0ICovXG5cdFx0XHRpc0FjdGl2ZTogZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXNzTmFtZSwgZGVmYXVsdEFjdGl2YXRpb24pIHtcblx0XHRcdFx0dmFyIG5vID0gJ25vLScgKyBjbGFzc05hbWU7XG5cblx0XHRcdFx0d2hpbGUgKGVsZW1lbnQpIHtcblx0XHRcdFx0XHR2YXIgY2xhc3NMaXN0ID0gZWxlbWVudC5jbGFzc0xpc3Q7XG5cdFx0XHRcdFx0aWYgKGNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGNsYXNzTGlzdC5jb250YWlucyhubykpIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxlbWVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gISFkZWZhdWx0QWN0aXZhdGlvbjtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBuYW1lc3BhY2UgY29udGFpbnMgYWxsIGN1cnJlbnRseSBsb2FkZWQgbGFuZ3VhZ2VzIGFuZCB0aGUgc29tZSBoZWxwZXIgZnVuY3Rpb25zIHRvIGNyZWF0ZSBhbmQgbW9kaWZ5IGxhbmd1YWdlcy5cblx0XHQgKlxuXHRcdCAqIEBuYW1lc3BhY2Vcblx0XHQgKiBAbWVtYmVyb2YgUHJpc21cblx0XHQgKiBAcHVibGljXG5cdFx0ICovXG5cdFx0bGFuZ3VhZ2VzOiB7XG5cdFx0XHQvKipcblx0XHRcdCAqIFRoZSBncmFtbWFyIGZvciBwbGFpbiwgdW5mb3JtYXR0ZWQgdGV4dC5cblx0XHRcdCAqL1xuXHRcdFx0cGxhaW46IHBsYWluVGV4dEdyYW1tYXIsXG5cdFx0XHRwbGFpbnRleHQ6IHBsYWluVGV4dEdyYW1tYXIsXG5cdFx0XHR0ZXh0OiBwbGFpblRleHRHcmFtbWFyLFxuXHRcdFx0dHh0OiBwbGFpblRleHRHcmFtbWFyLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIENyZWF0ZXMgYSBkZWVwIGNvcHkgb2YgdGhlIGxhbmd1YWdlIHdpdGggdGhlIGdpdmVuIGlkIGFuZCBhcHBlbmRzIHRoZSBnaXZlbiB0b2tlbnMuXG5cdFx0XHQgKlxuXHRcdFx0ICogSWYgYSB0b2tlbiBpbiBgcmVkZWZgIGFsc28gYXBwZWFycyBpbiB0aGUgY29waWVkIGxhbmd1YWdlLCB0aGVuIHRoZSBleGlzdGluZyB0b2tlbiBpbiB0aGUgY29waWVkIGxhbmd1YWdlXG5cdFx0XHQgKiB3aWxsIGJlIG92ZXJ3cml0dGVuIGF0IGl0cyBvcmlnaW5hbCBwb3NpdGlvbi5cblx0XHRcdCAqXG5cdFx0XHQgKiAjIyBCZXN0IHByYWN0aWNlc1xuXHRcdFx0ICpcblx0XHRcdCAqIFNpbmNlIHRoZSBwb3NpdGlvbiBvZiBvdmVyd3JpdGluZyB0b2tlbnMgKHRva2VuIGluIGByZWRlZmAgdGhhdCBvdmVyd3JpdGUgdG9rZW5zIGluIHRoZSBjb3BpZWQgbGFuZ3VhZ2UpXG5cdFx0XHQgKiBkb2Vzbid0IG1hdHRlciwgdGhleSBjYW4gdGVjaG5pY2FsbHkgYmUgaW4gYW55IG9yZGVyLiBIb3dldmVyLCB0aGlzIGNhbiBiZSBjb25mdXNpbmcgdG8gb3RoZXJzIHRoYXQgdHJ5aW5nIHRvXG5cdFx0XHQgKiB1bmRlcnN0YW5kIHRoZSBsYW5ndWFnZSBkZWZpbml0aW9uIGJlY2F1c2UsIG5vcm1hbGx5LCB0aGUgb3JkZXIgb2YgdG9rZW5zIG1hdHRlcnMgaW4gUHJpc20gZ3JhbW1hcnMuXG5cdFx0XHQgKlxuXHRcdFx0ICogVGhlcmVmb3JlLCBpdCBpcyBlbmNvdXJhZ2VkIHRvIG9yZGVyIG92ZXJ3cml0aW5nIHRva2VucyBhY2NvcmRpbmcgdG8gdGhlIHBvc2l0aW9ucyBvZiB0aGUgb3ZlcndyaXR0ZW4gdG9rZW5zLlxuXHRcdFx0ICogRnVydGhlcm1vcmUsIGFsbCBub24tb3ZlcndyaXRpbmcgdG9rZW5zIHNob3VsZCBiZSBwbGFjZWQgYWZ0ZXIgdGhlIG92ZXJ3cml0aW5nIG9uZXMuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBpZCBvZiB0aGUgbGFuZ3VhZ2UgdG8gZXh0ZW5kLiBUaGlzIGhhcyB0byBiZSBhIGtleSBpbiBgUHJpc20ubGFuZ3VhZ2VzYC5cblx0XHRcdCAqIEBwYXJhbSB7R3JhbW1hcn0gcmVkZWYgVGhlIG5ldyB0b2tlbnMgdG8gYXBwZW5kLlxuXHRcdFx0ICogQHJldHVybnMge0dyYW1tYXJ9IFRoZSBuZXcgbGFuZ3VhZ2UgY3JlYXRlZC5cblx0XHRcdCAqIEBwdWJsaWNcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBQcmlzbS5sYW5ndWFnZXNbJ2Nzcy13aXRoLWNvbG9ycyddID0gUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnY3NzJywge1xuXHRcdFx0ICogICAgIC8vIFByaXNtLmxhbmd1YWdlcy5jc3MgYWxyZWFkeSBoYXMgYSAnY29tbWVudCcgdG9rZW4sIHNvIHRoaXMgdG9rZW4gd2lsbCBvdmVyd3JpdGUgQ1NTJyAnY29tbWVudCcgdG9rZW5cblx0XHRcdCAqICAgICAvLyBhdCBpdHMgb3JpZ2luYWwgcG9zaXRpb25cblx0XHRcdCAqICAgICAnY29tbWVudCc6IHsgLi4uIH0sXG5cdFx0XHQgKiAgICAgLy8gQ1NTIGRvZXNuJ3QgaGF2ZSBhICdjb2xvcicgdG9rZW4sIHNvIHRoaXMgdG9rZW4gd2lsbCBiZSBhcHBlbmRlZFxuXHRcdFx0ICogICAgICdjb2xvcic6IC9cXGIoPzpyZWR8Z3JlZW58Ymx1ZSlcXGIvXG5cdFx0XHQgKiB9KTtcblx0XHRcdCAqL1xuXHRcdFx0ZXh0ZW5kOiBmdW5jdGlvbiAoaWQsIHJlZGVmKSB7XG5cdFx0XHRcdHZhciBsYW5nID0gXy51dGlsLmNsb25lKF8ubGFuZ3VhZ2VzW2lkXSk7XG5cblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIHJlZGVmKSB7XG5cdFx0XHRcdFx0bGFuZ1trZXldID0gcmVkZWZba2V5XTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBsYW5nO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBJbnNlcnRzIHRva2VucyBfYmVmb3JlXyBhbm90aGVyIHRva2VuIGluIGEgbGFuZ3VhZ2UgZGVmaW5pdGlvbiBvciBhbnkgb3RoZXIgZ3JhbW1hci5cblx0XHRcdCAqXG5cdFx0XHQgKiAjIyBVc2FnZVxuXHRcdFx0ICpcblx0XHRcdCAqIFRoaXMgaGVscGVyIG1ldGhvZCBtYWtlcyBpdCBlYXN5IHRvIG1vZGlmeSBleGlzdGluZyBsYW5ndWFnZXMuIEZvciBleGFtcGxlLCB0aGUgQ1NTIGxhbmd1YWdlIGRlZmluaXRpb25cblx0XHRcdCAqIG5vdCBvbmx5IGRlZmluZXMgQ1NTIGhpZ2hsaWdodGluZyBmb3IgQ1NTIGRvY3VtZW50cywgYnV0IGFsc28gbmVlZHMgdG8gZGVmaW5lIGhpZ2hsaWdodGluZyBmb3IgQ1NTIGVtYmVkZGVkXG5cdFx0XHQgKiBpbiBIVE1MIHRocm91Z2ggYDxzdHlsZT5gIGVsZW1lbnRzLiBUbyBkbyB0aGlzLCBpdCBuZWVkcyB0byBtb2RpZnkgYFByaXNtLmxhbmd1YWdlcy5tYXJrdXBgIGFuZCBhZGQgdGhlXG5cdFx0XHQgKiBhcHByb3ByaWF0ZSB0b2tlbnMuIEhvd2V2ZXIsIGBQcmlzbS5sYW5ndWFnZXMubWFya3VwYCBpcyBhIHJlZ3VsYXIgSmF2YVNjcmlwdCBvYmplY3QgbGl0ZXJhbCwgc28gaWYgeW91IGRvXG5cdFx0XHQgKiB0aGlzOlxuXHRcdFx0ICpcblx0XHRcdCAqIGBgYGpzXG5cdFx0XHQgKiBQcmlzbS5sYW5ndWFnZXMubWFya3VwLnN0eWxlID0ge1xuXHRcdFx0ICogICAgIC8vIHRva2VuXG5cdFx0XHQgKiB9O1xuXHRcdFx0ICogYGBgXG5cdFx0XHQgKlxuXHRcdFx0ICogdGhlbiB0aGUgYHN0eWxlYCB0b2tlbiB3aWxsIGJlIGFkZGVkIChhbmQgcHJvY2Vzc2VkKSBhdCB0aGUgZW5kLiBgaW5zZXJ0QmVmb3JlYCBhbGxvd3MgeW91IHRvIGluc2VydCB0b2tlbnNcblx0XHRcdCAqIGJlZm9yZSBleGlzdGluZyB0b2tlbnMuIEZvciB0aGUgQ1NTIGV4YW1wbGUgYWJvdmUsIHlvdSB3b3VsZCB1c2UgaXQgbGlrZSB0aGlzOlxuXHRcdFx0ICpcblx0XHRcdCAqIGBgYGpzXG5cdFx0XHQgKiBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdtYXJrdXAnLCAnY2RhdGEnLCB7XG5cdFx0XHQgKiAgICAgJ3N0eWxlJzoge1xuXHRcdFx0ICogICAgICAgICAvLyB0b2tlblxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqIH0pO1xuXHRcdFx0ICogYGBgXG5cdFx0XHQgKlxuXHRcdFx0ICogIyMgU3BlY2lhbCBjYXNlc1xuXHRcdFx0ICpcblx0XHRcdCAqIElmIHRoZSBncmFtbWFycyBvZiBgaW5zaWRlYCBhbmQgYGluc2VydGAgaGF2ZSB0b2tlbnMgd2l0aCB0aGUgc2FtZSBuYW1lLCB0aGUgdG9rZW5zIGluIGBpbnNpZGVgJ3MgZ3JhbW1hclxuXHRcdFx0ICogd2lsbCBiZSBpZ25vcmVkLlxuXHRcdFx0ICpcblx0XHRcdCAqIFRoaXMgYmVoYXZpb3IgY2FuIGJlIHVzZWQgdG8gaW5zZXJ0IHRva2VucyBhZnRlciBgYmVmb3JlYDpcblx0XHRcdCAqXG5cdFx0XHQgKiBgYGBqc1xuXHRcdFx0ICogUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnbWFya3VwJywgJ2NvbW1lbnQnLCB7XG5cdFx0XHQgKiAgICAgJ2NvbW1lbnQnOiBQcmlzbS5sYW5ndWFnZXMubWFya3VwLmNvbW1lbnQsXG5cdFx0XHQgKiAgICAgLy8gdG9rZW5zIGFmdGVyICdjb21tZW50J1xuXHRcdFx0ICogfSk7XG5cdFx0XHQgKiBgYGBcblx0XHRcdCAqXG5cdFx0XHQgKiAjIyBMaW1pdGF0aW9uc1xuXHRcdFx0ICpcblx0XHRcdCAqIFRoZSBtYWluIHByb2JsZW0gYGluc2VydEJlZm9yZWAgaGFzIHRvIHNvbHZlIGlzIGl0ZXJhdGlvbiBvcmRlci4gU2luY2UgRVMyMDE1LCB0aGUgaXRlcmF0aW9uIG9yZGVyIGZvciBvYmplY3Rcblx0XHRcdCAqIHByb3BlcnRpZXMgaXMgZ3VhcmFudGVlZCB0byBiZSB0aGUgaW5zZXJ0aW9uIG9yZGVyIChleGNlcHQgZm9yIGludGVnZXIga2V5cykgYnV0IHNvbWUgYnJvd3NlcnMgYmVoYXZlXG5cdFx0XHQgKiBkaWZmZXJlbnRseSB3aGVuIGtleXMgYXJlIGRlbGV0ZWQgYW5kIHJlLWluc2VydGVkLiBTbyBgaW5zZXJ0QmVmb3JlYCBjYW4ndCBiZSBpbXBsZW1lbnRlZCBieSB0ZW1wb3JhcmlseVxuXHRcdFx0ICogZGVsZXRpbmcgcHJvcGVydGllcyB3aGljaCBpcyBuZWNlc3NhcnkgdG8gaW5zZXJ0IGF0IGFyYml0cmFyeSBwb3NpdGlvbnMuXG5cdFx0XHQgKlxuXHRcdFx0ICogVG8gc29sdmUgdGhpcyBwcm9ibGVtLCBgaW5zZXJ0QmVmb3JlYCBkb2Vzbid0IGFjdHVhbGx5IGluc2VydCB0aGUgZ2l2ZW4gdG9rZW5zIGludG8gdGhlIHRhcmdldCBvYmplY3QuXG5cdFx0XHQgKiBJbnN0ZWFkLCBpdCB3aWxsIGNyZWF0ZSBhIG5ldyBvYmplY3QgYW5kIHJlcGxhY2UgYWxsIHJlZmVyZW5jZXMgdG8gdGhlIHRhcmdldCBvYmplY3Qgd2l0aCB0aGUgbmV3IG9uZS4gVGhpc1xuXHRcdFx0ICogY2FuIGJlIGRvbmUgd2l0aG91dCB0ZW1wb3JhcmlseSBkZWxldGluZyBwcm9wZXJ0aWVzLCBzbyB0aGUgaXRlcmF0aW9uIG9yZGVyIGlzIHdlbGwtZGVmaW5lZC5cblx0XHRcdCAqXG5cdFx0XHQgKiBIb3dldmVyLCBvbmx5IHJlZmVyZW5jZXMgdGhhdCBjYW4gYmUgcmVhY2hlZCBmcm9tIGBQcmlzbS5sYW5ndWFnZXNgIG9yIGBpbnNlcnRgIHdpbGwgYmUgcmVwbGFjZWQuIEkuZS4gaWZcblx0XHRcdCAqIHlvdSBob2xkIHRoZSB0YXJnZXQgb2JqZWN0IGluIGEgdmFyaWFibGUsIHRoZW4gdGhlIHZhbHVlIG9mIHRoZSB2YXJpYWJsZSB3aWxsIG5vdCBjaGFuZ2UuXG5cdFx0XHQgKlxuXHRcdFx0ICogYGBganNcblx0XHRcdCAqIHZhciBvbGRNYXJrdXAgPSBQcmlzbS5sYW5ndWFnZXMubWFya3VwO1xuXHRcdFx0ICogdmFyIG5ld01hcmt1cCA9IFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ21hcmt1cCcsICdjb21tZW50JywgeyAuLi4gfSk7XG5cdFx0XHQgKlxuXHRcdFx0ICogYXNzZXJ0KG9sZE1hcmt1cCAhPT0gUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cCk7XG5cdFx0XHQgKiBhc3NlcnQobmV3TWFya3VwID09PSBQcmlzbS5sYW5ndWFnZXMubWFya3VwKTtcblx0XHRcdCAqIGBgYFxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBpbnNpZGUgVGhlIHByb3BlcnR5IG9mIGByb290YCAoZS5nLiBhIGxhbmd1YWdlIGlkIGluIGBQcmlzbS5sYW5ndWFnZXNgKSB0aGF0IGNvbnRhaW5zIHRoZVxuXHRcdFx0ICogb2JqZWN0IHRvIGJlIG1vZGlmaWVkLlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IGJlZm9yZSBUaGUga2V5IHRvIGluc2VydCBiZWZvcmUuXG5cdFx0XHQgKiBAcGFyYW0ge0dyYW1tYXJ9IGluc2VydCBBbiBvYmplY3QgY29udGFpbmluZyB0aGUga2V5LXZhbHVlIHBhaXJzIHRvIGJlIGluc2VydGVkLlxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBbcm9vdF0gVGhlIG9iamVjdCBjb250YWluaW5nIGBpbnNpZGVgLCBpLmUuIHRoZSBvYmplY3QgdGhhdCBjb250YWlucyB0aGVcblx0XHRcdCAqIG9iamVjdCB0byBiZSBtb2RpZmllZC5cblx0XHRcdCAqXG5cdFx0XHQgKiBEZWZhdWx0cyB0byBgUHJpc20ubGFuZ3VhZ2VzYC5cblx0XHRcdCAqIEByZXR1cm5zIHtHcmFtbWFyfSBUaGUgbmV3IGdyYW1tYXIgb2JqZWN0LlxuXHRcdFx0ICogQHB1YmxpY1xuXHRcdFx0ICovXG5cdFx0XHRpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uIChpbnNpZGUsIGJlZm9yZSwgaW5zZXJ0LCByb290KSB7XG5cdFx0XHRcdHJvb3QgPSByb290IHx8IC8qKiBAdHlwZSB7YW55fSAqLyAoXy5sYW5ndWFnZXMpO1xuXHRcdFx0XHR2YXIgZ3JhbW1hciA9IHJvb3RbaW5zaWRlXTtcblx0XHRcdFx0LyoqIEB0eXBlIHtHcmFtbWFyfSAqL1xuXHRcdFx0XHR2YXIgcmV0ID0ge307XG5cblx0XHRcdFx0Zm9yICh2YXIgdG9rZW4gaW4gZ3JhbW1hcikge1xuXHRcdFx0XHRcdGlmIChncmFtbWFyLmhhc093blByb3BlcnR5KHRva2VuKSkge1xuXG5cdFx0XHRcdFx0XHRpZiAodG9rZW4gPT0gYmVmb3JlKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIG5ld1Rva2VuIGluIGluc2VydCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChpbnNlcnQuaGFzT3duUHJvcGVydHkobmV3VG9rZW4pKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXRbbmV3VG9rZW5dID0gaW5zZXJ0W25ld1Rva2VuXTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gRG8gbm90IGluc2VydCB0b2tlbiB3aGljaCBhbHNvIG9jY3VyIGluIGluc2VydC4gU2VlICMxNTI1XG5cdFx0XHRcdFx0XHRpZiAoIWluc2VydC5oYXNPd25Qcm9wZXJ0eSh0b2tlbikpIHtcblx0XHRcdFx0XHRcdFx0cmV0W3Rva2VuXSA9IGdyYW1tYXJbdG9rZW5dO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBvbGQgPSByb290W2luc2lkZV07XG5cdFx0XHRcdHJvb3RbaW5zaWRlXSA9IHJldDtcblxuXHRcdFx0XHQvLyBVcGRhdGUgcmVmZXJlbmNlcyBpbiBvdGhlciBsYW5ndWFnZSBkZWZpbml0aW9uc1xuXHRcdFx0XHRfLmxhbmd1YWdlcy5ERlMoXy5sYW5ndWFnZXMsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG5cdFx0XHRcdFx0aWYgKHZhbHVlID09PSBvbGQgJiYga2V5ICE9IGluc2lkZSkge1xuXHRcdFx0XHRcdFx0dGhpc1trZXldID0gcmV0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIFRyYXZlcnNlIGEgbGFuZ3VhZ2UgZGVmaW5pdGlvbiB3aXRoIERlcHRoIEZpcnN0IFNlYXJjaFxuXHRcdFx0REZTOiBmdW5jdGlvbiBERlMobywgY2FsbGJhY2ssIHR5cGUsIHZpc2l0ZWQpIHtcblx0XHRcdFx0dmlzaXRlZCA9IHZpc2l0ZWQgfHwge307XG5cblx0XHRcdFx0dmFyIG9iaklkID0gXy51dGlsLm9iaklkO1xuXG5cdFx0XHRcdGZvciAodmFyIGkgaW4gbykge1xuXHRcdFx0XHRcdGlmIChvLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKG8sIGksIG9baV0sIHR5cGUgfHwgaSk7XG5cblx0XHRcdFx0XHRcdHZhciBwcm9wZXJ0eSA9IG9baV07XG5cdFx0XHRcdFx0XHR2YXIgcHJvcGVydHlUeXBlID0gXy51dGlsLnR5cGUocHJvcGVydHkpO1xuXG5cdFx0XHRcdFx0XHRpZiAocHJvcGVydHlUeXBlID09PSAnT2JqZWN0JyAmJiAhdmlzaXRlZFtvYmpJZChwcm9wZXJ0eSldKSB7XG5cdFx0XHRcdFx0XHRcdHZpc2l0ZWRbb2JqSWQocHJvcGVydHkpXSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdERGUyhwcm9wZXJ0eSwgY2FsbGJhY2ssIG51bGwsIHZpc2l0ZWQpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChwcm9wZXJ0eVR5cGUgPT09ICdBcnJheScgJiYgIXZpc2l0ZWRbb2JqSWQocHJvcGVydHkpXSkge1xuXHRcdFx0XHRcdFx0XHR2aXNpdGVkW29iaklkKHByb3BlcnR5KV0gPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRERlMocHJvcGVydHksIGNhbGxiYWNrLCBpLCB2aXNpdGVkKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0cGx1Z2luczoge30sXG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGlzIHRoZSBtb3N0IGhpZ2gtbGV2ZWwgZnVuY3Rpb24gaW4gUHJpc23igJlzIEFQSS5cblx0XHQgKiBJdCBmZXRjaGVzIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBoYXZlIGEgYC5sYW5ndWFnZS14eHh4YCBjbGFzcyBhbmQgdGhlbiBjYWxscyB7QGxpbmsgUHJpc20uaGlnaGxpZ2h0RWxlbWVudH0gb25cblx0XHQgKiBlYWNoIG9uZSBvZiB0aGVtLlxuXHRcdCAqXG5cdFx0ICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIGBQcmlzbS5oaWdobGlnaHRBbGxVbmRlcihkb2N1bWVudCwgYXN5bmMsIGNhbGxiYWNrKWAuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFthc3luYz1mYWxzZV0gU2FtZSBhcyBpbiB7QGxpbmsgUHJpc20uaGlnaGxpZ2h0QWxsVW5kZXJ9LlxuXHRcdCAqIEBwYXJhbSB7SGlnaGxpZ2h0Q2FsbGJhY2t9IFtjYWxsYmFja10gU2FtZSBhcyBpbiB7QGxpbmsgUHJpc20uaGlnaGxpZ2h0QWxsVW5kZXJ9LlxuXHRcdCAqIEBtZW1iZXJvZiBQcmlzbVxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKi9cblx0XHRoaWdobGlnaHRBbGw6IGZ1bmN0aW9uIChhc3luYywgY2FsbGJhY2spIHtcblx0XHRcdF8uaGlnaGxpZ2h0QWxsVW5kZXIoZG9jdW1lbnQsIGFzeW5jLCBjYWxsYmFjayk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEZldGNoZXMgYWxsIHRoZSBkZXNjZW5kYW50cyBvZiBgY29udGFpbmVyYCB0aGF0IGhhdmUgYSBgLmxhbmd1YWdlLXh4eHhgIGNsYXNzIGFuZCB0aGVuIGNhbGxzXG5cdFx0ICoge0BsaW5rIFByaXNtLmhpZ2hsaWdodEVsZW1lbnR9IG9uIGVhY2ggb25lIG9mIHRoZW0uXG5cdFx0ICpcblx0XHQgKiBUaGUgZm9sbG93aW5nIGhvb2tzIHdpbGwgYmUgcnVuOlxuXHRcdCAqIDEuIGBiZWZvcmUtaGlnaGxpZ2h0YWxsYFxuXHRcdCAqIDIuIGBiZWZvcmUtYWxsLWVsZW1lbnRzLWhpZ2hsaWdodGBcblx0XHQgKiAzLiBBbGwgaG9va3Mgb2Yge0BsaW5rIFByaXNtLmhpZ2hsaWdodEVsZW1lbnR9IGZvciBlYWNoIGVsZW1lbnQuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge1BhcmVudE5vZGV9IGNvbnRhaW5lciBUaGUgcm9vdCBlbGVtZW50LCB3aG9zZSBkZXNjZW5kYW50cyB0aGF0IGhhdmUgYSBgLmxhbmd1YWdlLXh4eHhgIGNsYXNzIHdpbGwgYmUgaGlnaGxpZ2h0ZWQuXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbYXN5bmM9ZmFsc2VdIFdoZXRoZXIgZWFjaCBlbGVtZW50IGlzIHRvIGJlIGhpZ2hsaWdodGVkIGFzeW5jaHJvbm91c2x5IHVzaW5nIFdlYiBXb3JrZXJzLlxuXHRcdCAqIEBwYXJhbSB7SGlnaGxpZ2h0Q2FsbGJhY2t9IFtjYWxsYmFja10gQW4gb3B0aW9uYWwgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCBvbiBlYWNoIGVsZW1lbnQgYWZ0ZXIgaXRzIGhpZ2hsaWdodGluZyBpcyBkb25lLlxuXHRcdCAqIEBtZW1iZXJvZiBQcmlzbVxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKi9cblx0XHRoaWdobGlnaHRBbGxVbmRlcjogZnVuY3Rpb24gKGNvbnRhaW5lciwgYXN5bmMsIGNhbGxiYWNrKSB7XG5cdFx0XHR2YXIgZW52ID0ge1xuXHRcdFx0XHRjYWxsYmFjazogY2FsbGJhY2ssXG5cdFx0XHRcdGNvbnRhaW5lcjogY29udGFpbmVyLFxuXHRcdFx0XHRzZWxlY3RvcjogJ2NvZGVbY2xhc3MqPVwibGFuZ3VhZ2UtXCJdLCBbY2xhc3MqPVwibGFuZ3VhZ2UtXCJdIGNvZGUsIGNvZGVbY2xhc3MqPVwibGFuZy1cIl0sIFtjbGFzcyo9XCJsYW5nLVwiXSBjb2RlJ1xuXHRcdFx0fTtcblxuXHRcdFx0Xy5ob29rcy5ydW4oJ2JlZm9yZS1oaWdobGlnaHRhbGwnLCBlbnYpO1xuXG5cdFx0XHRlbnYuZWxlbWVudHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoZW52LmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKGVudi5zZWxlY3RvcikpO1xuXG5cdFx0XHRfLmhvb2tzLnJ1bignYmVmb3JlLWFsbC1lbGVtZW50cy1oaWdobGlnaHQnLCBlbnYpO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgZWxlbWVudDsgKGVsZW1lbnQgPSBlbnYuZWxlbWVudHNbaSsrXSk7KSB7XG5cdFx0XHRcdF8uaGlnaGxpZ2h0RWxlbWVudChlbGVtZW50LCBhc3luYyA9PT0gdHJ1ZSwgZW52LmNhbGxiYWNrKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSGlnaGxpZ2h0cyB0aGUgY29kZSBpbnNpZGUgYSBzaW5nbGUgZWxlbWVudC5cblx0XHQgKlxuXHRcdCAqIFRoZSBmb2xsb3dpbmcgaG9va3Mgd2lsbCBiZSBydW46XG5cdFx0ICogMS4gYGJlZm9yZS1zYW5pdHktY2hlY2tgXG5cdFx0ICogMi4gYGJlZm9yZS1oaWdobGlnaHRgXG5cdFx0ICogMy4gQWxsIGhvb2tzIG9mIHtAbGluayBQcmlzbS5oaWdobGlnaHR9LiBUaGVzZSBob29rcyB3aWxsIGJlIHJ1biBieSBhbiBhc3luY2hyb25vdXMgd29ya2VyIGlmIGBhc3luY2AgaXMgYHRydWVgLlxuXHRcdCAqIDQuIGBiZWZvcmUtaW5zZXJ0YFxuXHRcdCAqIDUuIGBhZnRlci1oaWdobGlnaHRgXG5cdFx0ICogNi4gYGNvbXBsZXRlYFxuXHRcdCAqXG5cdFx0ICogU29tZSB0aGUgYWJvdmUgaG9va3Mgd2lsbCBiZSBza2lwcGVkIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgY29udGFpbiBhbnkgdGV4dCBvciB0aGVyZSBpcyBubyBncmFtbWFyIGxvYWRlZCBmb3Jcblx0XHQgKiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIGNvZGUuXG5cdFx0ICogSXQgbXVzdCBoYXZlIGEgY2xhc3Mgb2YgYGxhbmd1YWdlLXh4eHhgIHRvIGJlIHByb2Nlc3NlZCwgd2hlcmUgYHh4eHhgIGlzIGEgdmFsaWQgbGFuZ3VhZ2UgaWRlbnRpZmllci5cblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFthc3luYz1mYWxzZV0gV2hldGhlciB0aGUgZWxlbWVudCBpcyB0byBiZSBoaWdobGlnaHRlZCBhc3luY2hyb25vdXNseSB1c2luZyBXZWIgV29ya2Vyc1xuXHRcdCAqIHRvIGltcHJvdmUgcGVyZm9ybWFuY2UgYW5kIGF2b2lkIGJsb2NraW5nIHRoZSBVSSB3aGVuIGhpZ2hsaWdodGluZyB2ZXJ5IGxhcmdlIGNodW5rcyBvZiBjb2RlLiBUaGlzIG9wdGlvbiBpc1xuXHRcdCAqIFtkaXNhYmxlZCBieSBkZWZhdWx0XShodHRwczovL3ByaXNtanMuY29tL2ZhcS5odG1sI3doeS1pcy1hc3luY2hyb25vdXMtaGlnaGxpZ2h0aW5nLWRpc2FibGVkLWJ5LWRlZmF1bHQpLlxuXHRcdCAqXG5cdFx0ICogTm90ZTogQWxsIGxhbmd1YWdlIGRlZmluaXRpb25zIHJlcXVpcmVkIHRvIGhpZ2hsaWdodCB0aGUgY29kZSBtdXN0IGJlIGluY2x1ZGVkIGluIHRoZSBtYWluIGBwcmlzbS5qc2AgZmlsZSBmb3Jcblx0XHQgKiBhc3luY2hyb25vdXMgaGlnaGxpZ2h0aW5nIHRvIHdvcmsuIFlvdSBjYW4gYnVpbGQgeW91ciBvd24gYnVuZGxlIG9uIHRoZVxuXHRcdCAqIFtEb3dubG9hZCBwYWdlXShodHRwczovL3ByaXNtanMuY29tL2Rvd25sb2FkLmh0bWwpLlxuXHRcdCAqIEBwYXJhbSB7SGlnaGxpZ2h0Q2FsbGJhY2t9IFtjYWxsYmFja10gQW4gb3B0aW9uYWwgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCBhZnRlciB0aGUgaGlnaGxpZ2h0aW5nIGlzIGRvbmUuXG5cdFx0ICogTW9zdGx5IHVzZWZ1bCB3aGVuIGBhc3luY2AgaXMgYHRydWVgLCBzaW5jZSBpbiB0aGF0IGNhc2UsIHRoZSBoaWdobGlnaHRpbmcgaXMgZG9uZSBhc3luY2hyb25vdXNseS5cblx0XHQgKiBAbWVtYmVyb2YgUHJpc21cblx0XHQgKiBAcHVibGljXG5cdFx0ICovXG5cdFx0aGlnaGxpZ2h0RWxlbWVudDogZnVuY3Rpb24gKGVsZW1lbnQsIGFzeW5jLCBjYWxsYmFjaykge1xuXHRcdFx0Ly8gRmluZCBsYW5ndWFnZVxuXHRcdFx0dmFyIGxhbmd1YWdlID0gXy51dGlsLmdldExhbmd1YWdlKGVsZW1lbnQpO1xuXHRcdFx0dmFyIGdyYW1tYXIgPSBfLmxhbmd1YWdlc1tsYW5ndWFnZV07XG5cblx0XHRcdC8vIFNldCBsYW5ndWFnZSBvbiB0aGUgZWxlbWVudCwgaWYgbm90IHByZXNlbnRcblx0XHRcdF8udXRpbC5zZXRMYW5ndWFnZShlbGVtZW50LCBsYW5ndWFnZSk7XG5cblx0XHRcdC8vIFNldCBsYW5ndWFnZSBvbiB0aGUgcGFyZW50LCBmb3Igc3R5bGluZ1xuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcblx0XHRcdGlmIChwYXJlbnQgJiYgcGFyZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdwcmUnKSB7XG5cdFx0XHRcdF8udXRpbC5zZXRMYW5ndWFnZShwYXJlbnQsIGxhbmd1YWdlKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGNvZGUgPSBlbGVtZW50LnRleHRDb250ZW50O1xuXG5cdFx0XHR2YXIgZW52ID0ge1xuXHRcdFx0XHRlbGVtZW50OiBlbGVtZW50LFxuXHRcdFx0XHRsYW5ndWFnZTogbGFuZ3VhZ2UsXG5cdFx0XHRcdGdyYW1tYXI6IGdyYW1tYXIsXG5cdFx0XHRcdGNvZGU6IGNvZGVcblx0XHRcdH07XG5cblx0XHRcdGZ1bmN0aW9uIGluc2VydEhpZ2hsaWdodGVkQ29kZShoaWdobGlnaHRlZENvZGUpIHtcblx0XHRcdFx0ZW52LmhpZ2hsaWdodGVkQ29kZSA9IGhpZ2hsaWdodGVkQ29kZTtcblxuXHRcdFx0XHRfLmhvb2tzLnJ1bignYmVmb3JlLWluc2VydCcsIGVudik7XG5cblx0XHRcdFx0ZW52LmVsZW1lbnQuaW5uZXJIVE1MID0gZW52LmhpZ2hsaWdodGVkQ29kZTtcblxuXHRcdFx0XHRfLmhvb2tzLnJ1bignYWZ0ZXItaGlnaGxpZ2h0JywgZW52KTtcblx0XHRcdFx0Xy5ob29rcy5ydW4oJ2NvbXBsZXRlJywgZW52KTtcblx0XHRcdFx0Y2FsbGJhY2sgJiYgY2FsbGJhY2suY2FsbChlbnYuZWxlbWVudCk7XG5cdFx0XHR9XG5cblx0XHRcdF8uaG9va3MucnVuKCdiZWZvcmUtc2FuaXR5LWNoZWNrJywgZW52KTtcblxuXHRcdFx0Ly8gcGx1Z2lucyBtYXkgY2hhbmdlL2FkZCB0aGUgcGFyZW50L2VsZW1lbnRcblx0XHRcdHBhcmVudCA9IGVudi5lbGVtZW50LnBhcmVudEVsZW1lbnQ7XG5cdFx0XHRpZiAocGFyZW50ICYmIHBhcmVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAncHJlJyAmJiAhcGFyZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSkge1xuXHRcdFx0XHRwYXJlbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICcwJyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghZW52LmNvZGUpIHtcblx0XHRcdFx0Xy5ob29rcy5ydW4oJ2NvbXBsZXRlJywgZW52KTtcblx0XHRcdFx0Y2FsbGJhY2sgJiYgY2FsbGJhY2suY2FsbChlbnYuZWxlbWVudCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Xy5ob29rcy5ydW4oJ2JlZm9yZS1oaWdobGlnaHQnLCBlbnYpO1xuXG5cdFx0XHRpZiAoIWVudi5ncmFtbWFyKSB7XG5cdFx0XHRcdGluc2VydEhpZ2hsaWdodGVkQ29kZShfLnV0aWwuZW5jb2RlKGVudi5jb2RlKSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGFzeW5jICYmIF9zZWxmLldvcmtlcikge1xuXHRcdFx0XHR2YXIgd29ya2VyID0gbmV3IFdvcmtlcihfLmZpbGVuYW1lKTtcblxuXHRcdFx0XHR3b3JrZXIub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2dCkge1xuXHRcdFx0XHRcdGluc2VydEhpZ2hsaWdodGVkQ29kZShldnQuZGF0YSk7XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0d29ya2VyLnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHtcblx0XHRcdFx0XHRsYW5ndWFnZTogZW52Lmxhbmd1YWdlLFxuXHRcdFx0XHRcdGNvZGU6IGVudi5jb2RlLFxuXHRcdFx0XHRcdGltbWVkaWF0ZUNsb3NlOiB0cnVlXG5cdFx0XHRcdH0pKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGluc2VydEhpZ2hsaWdodGVkQ29kZShfLmhpZ2hsaWdodChlbnYuY29kZSwgZW52LmdyYW1tYXIsIGVudi5sYW5ndWFnZSkpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBMb3ctbGV2ZWwgZnVuY3Rpb24sIG9ubHkgdXNlIGlmIHlvdSBrbm93IHdoYXQgeW914oCZcmUgZG9pbmcuIEl0IGFjY2VwdHMgYSBzdHJpbmcgb2YgdGV4dCBhcyBpbnB1dFxuXHRcdCAqIGFuZCB0aGUgbGFuZ3VhZ2UgZGVmaW5pdGlvbnMgdG8gdXNlLCBhbmQgcmV0dXJucyBhIHN0cmluZyB3aXRoIHRoZSBIVE1MIHByb2R1Y2VkLlxuXHRcdCAqXG5cdFx0ICogVGhlIGZvbGxvd2luZyBob29rcyB3aWxsIGJlIHJ1bjpcblx0XHQgKiAxLiBgYmVmb3JlLXRva2VuaXplYFxuXHRcdCAqIDIuIGBhZnRlci10b2tlbml6ZWBcblx0XHQgKiAzLiBgd3JhcGA6IE9uIGVhY2gge0BsaW5rIFRva2VufS5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IEEgc3RyaW5nIHdpdGggdGhlIGNvZGUgdG8gYmUgaGlnaGxpZ2h0ZWQuXG5cdFx0ICogQHBhcmFtIHtHcmFtbWFyfSBncmFtbWFyIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSB0b2tlbnMgdG8gdXNlLlxuXHRcdCAqXG5cdFx0ICogVXN1YWxseSBhIGxhbmd1YWdlIGRlZmluaXRpb24gbGlrZSBgUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cGAuXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlIFRoZSBuYW1lIG9mIHRoZSBsYW5ndWFnZSBkZWZpbml0aW9uIHBhc3NlZCB0byBgZ3JhbW1hcmAuXG5cdFx0ICogQHJldHVybnMge3N0cmluZ30gVGhlIGhpZ2hsaWdodGVkIEhUTUwuXG5cdFx0ICogQG1lbWJlcm9mIFByaXNtXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogUHJpc20uaGlnaGxpZ2h0KCd2YXIgZm9vID0gdHJ1ZTsnLCBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdCwgJ2phdmFzY3JpcHQnKTtcblx0XHQgKi9cblx0XHRoaWdobGlnaHQ6IGZ1bmN0aW9uICh0ZXh0LCBncmFtbWFyLCBsYW5ndWFnZSkge1xuXHRcdFx0dmFyIGVudiA9IHtcblx0XHRcdFx0Y29kZTogdGV4dCxcblx0XHRcdFx0Z3JhbW1hcjogZ3JhbW1hcixcblx0XHRcdFx0bGFuZ3VhZ2U6IGxhbmd1YWdlXG5cdFx0XHR9O1xuXHRcdFx0Xy5ob29rcy5ydW4oJ2JlZm9yZS10b2tlbml6ZScsIGVudik7XG5cdFx0XHRpZiAoIWVudi5ncmFtbWFyKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignVGhlIGxhbmd1YWdlIFwiJyArIGVudi5sYW5ndWFnZSArICdcIiBoYXMgbm8gZ3JhbW1hci4nKTtcblx0XHRcdH1cblx0XHRcdGVudi50b2tlbnMgPSBfLnRva2VuaXplKGVudi5jb2RlLCBlbnYuZ3JhbW1hcik7XG5cdFx0XHRfLmhvb2tzLnJ1bignYWZ0ZXItdG9rZW5pemUnLCBlbnYpO1xuXHRcdFx0cmV0dXJuIFRva2VuLnN0cmluZ2lmeShfLnV0aWwuZW5jb2RlKGVudi50b2tlbnMpLCBlbnYubGFuZ3VhZ2UpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGlzIHRoZSBoZWFydCBvZiBQcmlzbSwgYW5kIHRoZSBtb3N0IGxvdy1sZXZlbCBmdW5jdGlvbiB5b3UgY2FuIHVzZS4gSXQgYWNjZXB0cyBhIHN0cmluZyBvZiB0ZXh0IGFzIGlucHV0XG5cdFx0ICogYW5kIHRoZSBsYW5ndWFnZSBkZWZpbml0aW9ucyB0byB1c2UsIGFuZCByZXR1cm5zIGFuIGFycmF5IHdpdGggdGhlIHRva2VuaXplZCBjb2RlLlxuXHRcdCAqXG5cdFx0ICogV2hlbiB0aGUgbGFuZ3VhZ2UgZGVmaW5pdGlvbiBpbmNsdWRlcyBuZXN0ZWQgdG9rZW5zLCB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIHJlY3Vyc2l2ZWx5IG9uIGVhY2ggb2YgdGhlc2UgdG9rZW5zLlxuXHRcdCAqXG5cdFx0ICogVGhpcyBtZXRob2QgY291bGQgYmUgdXNlZnVsIGluIG90aGVyIGNvbnRleHRzIGFzIHdlbGwsIGFzIGEgdmVyeSBjcnVkZSBwYXJzZXIuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBBIHN0cmluZyB3aXRoIHRoZSBjb2RlIHRvIGJlIGhpZ2hsaWdodGVkLlxuXHRcdCAqIEBwYXJhbSB7R3JhbW1hcn0gZ3JhbW1hciBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgdG9rZW5zIHRvIHVzZS5cblx0XHQgKlxuXHRcdCAqIFVzdWFsbHkgYSBsYW5ndWFnZSBkZWZpbml0aW9uIGxpa2UgYFByaXNtLmxhbmd1YWdlcy5tYXJrdXBgLlxuXHRcdCAqIEByZXR1cm5zIHtUb2tlblN0cmVhbX0gQW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQgdG9rZW5zLCBhIHRva2VuIHN0cmVhbS5cblx0XHQgKiBAbWVtYmVyb2YgUHJpc21cblx0XHQgKiBAcHVibGljXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBsZXQgY29kZSA9IGB2YXIgZm9vID0gMDtgO1xuXHRcdCAqIGxldCB0b2tlbnMgPSBQcmlzbS50b2tlbml6ZShjb2RlLCBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdCk7XG5cdFx0ICogdG9rZW5zLmZvckVhY2godG9rZW4gPT4ge1xuXHRcdCAqICAgICBpZiAodG9rZW4gaW5zdGFuY2VvZiBQcmlzbS5Ub2tlbiAmJiB0b2tlbi50eXBlID09PSAnbnVtYmVyJykge1xuXHRcdCAqICAgICAgICAgY29uc29sZS5sb2coYEZvdW5kIG51bWVyaWMgbGl0ZXJhbDogJHt0b2tlbi5jb250ZW50fWApO1xuXHRcdCAqICAgICB9XG5cdFx0ICogfSk7XG5cdFx0ICovXG5cdFx0dG9rZW5pemU6IGZ1bmN0aW9uICh0ZXh0LCBncmFtbWFyKSB7XG5cdFx0XHR2YXIgcmVzdCA9IGdyYW1tYXIucmVzdDtcblx0XHRcdGlmIChyZXN0KSB7XG5cdFx0XHRcdGZvciAodmFyIHRva2VuIGluIHJlc3QpIHtcblx0XHRcdFx0XHRncmFtbWFyW3Rva2VuXSA9IHJlc3RbdG9rZW5dO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIGdyYW1tYXIucmVzdDtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHRva2VuTGlzdCA9IG5ldyBMaW5rZWRMaXN0KCk7XG5cdFx0XHRhZGRBZnRlcih0b2tlbkxpc3QsIHRva2VuTGlzdC5oZWFkLCB0ZXh0KTtcblxuXHRcdFx0bWF0Y2hHcmFtbWFyKHRleHQsIHRva2VuTGlzdCwgZ3JhbW1hciwgdG9rZW5MaXN0LmhlYWQsIDApO1xuXG5cdFx0XHRyZXR1cm4gdG9BcnJheSh0b2tlbkxpc3QpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAbmFtZXNwYWNlXG5cdFx0ICogQG1lbWJlcm9mIFByaXNtXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqL1xuXHRcdGhvb2tzOiB7XG5cdFx0XHRhbGw6IHt9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEFkZHMgdGhlIGdpdmVuIGNhbGxiYWNrIHRvIHRoZSBsaXN0IG9mIGNhbGxiYWNrcyBmb3IgdGhlIGdpdmVuIGhvb2suXG5cdFx0XHQgKlxuXHRcdFx0ICogVGhlIGNhbGxiYWNrIHdpbGwgYmUgaW52b2tlZCB3aGVuIHRoZSBob29rIGl0IGlzIHJlZ2lzdGVyZWQgZm9yIGlzIHJ1bi5cblx0XHRcdCAqIEhvb2tzIGFyZSB1c3VhbGx5IGRpcmVjdGx5IHJ1biBieSBhIGhpZ2hsaWdodCBmdW5jdGlvbiBidXQgeW91IGNhbiBhbHNvIHJ1biBob29rcyB5b3Vyc2VsZi5cblx0XHRcdCAqXG5cdFx0XHQgKiBPbmUgY2FsbGJhY2sgZnVuY3Rpb24gY2FuIGJlIHJlZ2lzdGVyZWQgdG8gbXVsdGlwbGUgaG9va3MgYW5kIHRoZSBzYW1lIGhvb2sgbXVsdGlwbGUgdGltZXMuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGhvb2suXG5cdFx0XHQgKiBAcGFyYW0ge0hvb2tDYWxsYmFja30gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdoaWNoIGlzIGdpdmVuIGVudmlyb25tZW50IHZhcmlhYmxlcy5cblx0XHRcdCAqIEBwdWJsaWNcblx0XHRcdCAqL1xuXHRcdFx0YWRkOiBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2spIHtcblx0XHRcdFx0dmFyIGhvb2tzID0gXy5ob29rcy5hbGw7XG5cblx0XHRcdFx0aG9va3NbbmFtZV0gPSBob29rc1tuYW1lXSB8fCBbXTtcblxuXHRcdFx0XHRob29rc1tuYW1lXS5wdXNoKGNhbGxiYWNrKTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogUnVucyBhIGhvb2sgaW52b2tpbmcgYWxsIHJlZ2lzdGVyZWQgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGVudmlyb25tZW50IHZhcmlhYmxlcy5cblx0XHRcdCAqXG5cdFx0XHQgKiBDYWxsYmFja3Mgd2lsbCBiZSBpbnZva2VkIHN5bmNocm9ub3VzbHkgYW5kIGluIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IHdlcmUgcmVnaXN0ZXJlZC5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgaG9vay5cblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgYW55Pn0gZW52IFRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgb2YgdGhlIGhvb2sgcGFzc2VkIHRvIGFsbCBjYWxsYmFja3MgcmVnaXN0ZXJlZC5cblx0XHRcdCAqIEBwdWJsaWNcblx0XHRcdCAqL1xuXHRcdFx0cnVuOiBmdW5jdGlvbiAobmFtZSwgZW52KSB7XG5cdFx0XHRcdHZhciBjYWxsYmFja3MgPSBfLmhvb2tzLmFsbFtuYW1lXTtcblxuXHRcdFx0XHRpZiAoIWNhbGxiYWNrcyB8fCAhY2FsbGJhY2tzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBjYWxsYmFjazsgKGNhbGxiYWNrID0gY2FsbGJhY2tzW2krK10pOykge1xuXHRcdFx0XHRcdGNhbGxiYWNrKGVudik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0VG9rZW46IFRva2VuXG5cdH07XG5cdF9zZWxmLlByaXNtID0gXztcblxuXG5cdC8vIFR5cGVzY3JpcHQgbm90ZTpcblx0Ly8gVGhlIGZvbGxvd2luZyBjYW4gYmUgdXNlZCB0byBpbXBvcnQgdGhlIFRva2VuIHR5cGUgaW4gSlNEb2M6XG5cdC8vXG5cdC8vICAgQHR5cGVkZWYge0luc3RhbmNlVHlwZTxpbXBvcnQoXCIuL3ByaXNtLWNvcmVcIilbXCJUb2tlblwiXT59IFRva2VuXG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcgdG9rZW4uXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFNlZSB7QGxpbmsgVG9rZW4jdHlwZSB0eXBlfVxuXHQgKiBAcGFyYW0ge3N0cmluZyB8IFRva2VuU3RyZWFtfSBjb250ZW50IFNlZSB7QGxpbmsgVG9rZW4jY29udGVudCBjb250ZW50fVxuXHQgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gW2FsaWFzXSBUaGUgYWxpYXMoZXMpIG9mIHRoZSB0b2tlbi5cblx0ICogQHBhcmFtIHtzdHJpbmd9IFttYXRjaGVkU3RyPVwiXCJdIEEgY29weSBvZiB0aGUgZnVsbCBzdHJpbmcgdGhpcyB0b2tlbiB3YXMgY3JlYXRlZCBmcm9tLlxuXHQgKiBAY2xhc3Ncblx0ICogQGdsb2JhbFxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHRmdW5jdGlvbiBUb2tlbih0eXBlLCBjb250ZW50LCBhbGlhcywgbWF0Y2hlZFN0cikge1xuXHRcdC8qKlxuXHRcdCAqIFRoZSB0eXBlIG9mIHRoZSB0b2tlbi5cblx0XHQgKlxuXHRcdCAqIFRoaXMgaXMgdXN1YWxseSB0aGUga2V5IG9mIGEgcGF0dGVybiBpbiBhIHtAbGluayBHcmFtbWFyfS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQHNlZSBHcmFtbWFyVG9rZW5cblx0XHQgKiBAcHVibGljXG5cdFx0ICovXG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XHQvKipcblx0XHQgKiBUaGUgc3RyaW5ncyBvciB0b2tlbnMgY29udGFpbmVkIGJ5IHRoaXMgdG9rZW4uXG5cdFx0ICpcblx0XHQgKiBUaGlzIHdpbGwgYmUgYSB0b2tlbiBzdHJlYW0gaWYgdGhlIHBhdHRlcm4gbWF0Y2hlZCBhbHNvIGRlZmluZWQgYW4gYGluc2lkZWAgZ3JhbW1hci5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtzdHJpbmcgfCBUb2tlblN0cmVhbX1cblx0XHQgKiBAcHVibGljXG5cdFx0ICovXG5cdFx0dGhpcy5jb250ZW50ID0gY29udGVudDtcblx0XHQvKipcblx0XHQgKiBUaGUgYWxpYXMoZXMpIG9mIHRoZSB0b2tlbi5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtzdHJpbmd8c3RyaW5nW119XG5cdFx0ICogQHNlZSBHcmFtbWFyVG9rZW5cblx0XHQgKiBAcHVibGljXG5cdFx0ICovXG5cdFx0dGhpcy5hbGlhcyA9IGFsaWFzO1xuXHRcdC8vIENvcHkgb2YgdGhlIGZ1bGwgc3RyaW5nIHRoaXMgdG9rZW4gd2FzIGNyZWF0ZWQgZnJvbVxuXHRcdHRoaXMubGVuZ3RoID0gKG1hdGNoZWRTdHIgfHwgJycpLmxlbmd0aCB8IDA7XG5cdH1cblxuXHQvKipcblx0ICogQSB0b2tlbiBzdHJlYW0gaXMgYW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQge0BsaW5rIFRva2VuIFRva2VufSBvYmplY3RzLlxuXHQgKlxuXHQgKiBUb2tlbiBzdHJlYW1zIGhhdmUgdG8gZnVsZmlsbCBhIGZldyBwcm9wZXJ0aWVzIHRoYXQgYXJlIGFzc3VtZWQgYnkgbW9zdCBmdW5jdGlvbnMgKG1vc3RseSBpbnRlcm5hbCBvbmVzKSB0aGF0IHByb2Nlc3Ncblx0ICogdGhlbS5cblx0ICpcblx0ICogMS4gTm8gYWRqYWNlbnQgc3RyaW5ncy5cblx0ICogMi4gTm8gZW1wdHkgc3RyaW5ncy5cblx0ICpcblx0ICogICAgVGhlIG9ubHkgZXhjZXB0aW9uIGhlcmUgaXMgdGhlIHRva2VuIHN0cmVhbSB0aGF0IG9ubHkgY29udGFpbnMgdGhlIGVtcHR5IHN0cmluZyBhbmQgbm90aGluZyBlbHNlLlxuXHQgKlxuXHQgKiBAdHlwZWRlZiB7QXJyYXk8c3RyaW5nIHwgVG9rZW4+fSBUb2tlblN0cmVhbVxuXHQgKiBAZ2xvYmFsXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIHRoZSBnaXZlbiB0b2tlbiBvciB0b2tlbiBzdHJlYW0gdG8gYW4gSFRNTCByZXByZXNlbnRhdGlvbi5cblx0ICpcblx0ICogVGhlIGZvbGxvd2luZyBob29rcyB3aWxsIGJlIHJ1bjpcblx0ICogMS4gYHdyYXBgOiBPbiBlYWNoIHtAbGluayBUb2tlbn0uXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nIHwgVG9rZW4gfCBUb2tlblN0cmVhbX0gbyBUaGUgdG9rZW4gb3IgdG9rZW4gc3RyZWFtIHRvIGJlIGNvbnZlcnRlZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlIFRoZSBuYW1lIG9mIGN1cnJlbnQgbGFuZ3VhZ2UuXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBIVE1MIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0b2tlbiBvciB0b2tlbiBzdHJlYW0uXG5cdCAqIEBtZW1iZXJvZiBUb2tlblxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRUb2tlbi5zdHJpbmdpZnkgPSBmdW5jdGlvbiBzdHJpbmdpZnkobywgbGFuZ3VhZ2UpIHtcblx0XHRpZiAodHlwZW9mIG8gPT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiBvO1xuXHRcdH1cblx0XHRpZiAoQXJyYXkuaXNBcnJheShvKSkge1xuXHRcdFx0dmFyIHMgPSAnJztcblx0XHRcdG8uZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRzICs9IHN0cmluZ2lmeShlLCBsYW5ndWFnZSk7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBzO1xuXHRcdH1cblxuXHRcdHZhciBlbnYgPSB7XG5cdFx0XHR0eXBlOiBvLnR5cGUsXG5cdFx0XHRjb250ZW50OiBzdHJpbmdpZnkoby5jb250ZW50LCBsYW5ndWFnZSksXG5cdFx0XHR0YWc6ICdzcGFuJyxcblx0XHRcdGNsYXNzZXM6IFsndG9rZW4nLCBvLnR5cGVdLFxuXHRcdFx0YXR0cmlidXRlczoge30sXG5cdFx0XHRsYW5ndWFnZTogbGFuZ3VhZ2Vcblx0XHR9O1xuXG5cdFx0dmFyIGFsaWFzZXMgPSBvLmFsaWFzO1xuXHRcdGlmIChhbGlhc2VzKSB7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShhbGlhc2VzKSkge1xuXHRcdFx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShlbnYuY2xhc3NlcywgYWxpYXNlcyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbnYuY2xhc3Nlcy5wdXNoKGFsaWFzZXMpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdF8uaG9va3MucnVuKCd3cmFwJywgZW52KTtcblxuXHRcdHZhciBhdHRyaWJ1dGVzID0gJyc7XG5cdFx0Zm9yICh2YXIgbmFtZSBpbiBlbnYuYXR0cmlidXRlcykge1xuXHRcdFx0YXR0cmlidXRlcyArPSAnICcgKyBuYW1lICsgJz1cIicgKyAoZW52LmF0dHJpYnV0ZXNbbmFtZV0gfHwgJycpLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKSArICdcIic7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICc8JyArIGVudi50YWcgKyAnIGNsYXNzPVwiJyArIGVudi5jbGFzc2VzLmpvaW4oJyAnKSArICdcIicgKyBhdHRyaWJ1dGVzICsgJz4nICsgZW52LmNvbnRlbnQgKyAnPC8nICsgZW52LnRhZyArICc+Jztcblx0fTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtSZWdFeHB9IHBhdHRlcm5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHBvc1xuXHQgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGxvb2tiZWhpbmRcblx0ICogQHJldHVybnMge1JlZ0V4cEV4ZWNBcnJheSB8IG51bGx9XG5cdCAqL1xuXHRmdW5jdGlvbiBtYXRjaFBhdHRlcm4ocGF0dGVybiwgcG9zLCB0ZXh0LCBsb29rYmVoaW5kKSB7XG5cdFx0cGF0dGVybi5sYXN0SW5kZXggPSBwb3M7XG5cdFx0dmFyIG1hdGNoID0gcGF0dGVybi5leGVjKHRleHQpO1xuXHRcdGlmIChtYXRjaCAmJiBsb29rYmVoaW5kICYmIG1hdGNoWzFdKSB7XG5cdFx0XHQvLyBjaGFuZ2UgdGhlIG1hdGNoIHRvIHJlbW92ZSB0aGUgdGV4dCBtYXRjaGVkIGJ5IHRoZSBQcmlzbSBsb29rYmVoaW5kIGdyb3VwXG5cdFx0XHR2YXIgbG9va2JlaGluZExlbmd0aCA9IG1hdGNoWzFdLmxlbmd0aDtcblx0XHRcdG1hdGNoLmluZGV4ICs9IGxvb2tiZWhpbmRMZW5ndGg7XG5cdFx0XHRtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKGxvb2tiZWhpbmRMZW5ndGgpO1xuXHRcdH1cblx0XHRyZXR1cm4gbWF0Y2g7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IHRleHRcblx0ICogQHBhcmFtIHtMaW5rZWRMaXN0PHN0cmluZyB8IFRva2VuPn0gdG9rZW5MaXN0XG5cdCAqIEBwYXJhbSB7YW55fSBncmFtbWFyXG5cdCAqIEBwYXJhbSB7TGlua2VkTGlzdE5vZGU8c3RyaW5nIHwgVG9rZW4+fSBzdGFydE5vZGVcblx0ICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0UG9zXG5cdCAqIEBwYXJhbSB7UmVtYXRjaE9wdGlvbnN9IFtyZW1hdGNoXVxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICogQHByaXZhdGVcblx0ICpcblx0ICogQHR5cGVkZWYgUmVtYXRjaE9wdGlvbnNcblx0ICogQHByb3BlcnR5IHtzdHJpbmd9IGNhdXNlXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZWFjaFxuXHQgKi9cblx0ZnVuY3Rpb24gbWF0Y2hHcmFtbWFyKHRleHQsIHRva2VuTGlzdCwgZ3JhbW1hciwgc3RhcnROb2RlLCBzdGFydFBvcywgcmVtYXRjaCkge1xuXHRcdGZvciAodmFyIHRva2VuIGluIGdyYW1tYXIpIHtcblx0XHRcdGlmICghZ3JhbW1hci5oYXNPd25Qcm9wZXJ0eSh0b2tlbikgfHwgIWdyYW1tYXJbdG9rZW5dKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcGF0dGVybnMgPSBncmFtbWFyW3Rva2VuXTtcblx0XHRcdHBhdHRlcm5zID0gQXJyYXkuaXNBcnJheShwYXR0ZXJucykgPyBwYXR0ZXJucyA6IFtwYXR0ZXJuc107XG5cblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgcGF0dGVybnMubGVuZ3RoOyArK2opIHtcblx0XHRcdFx0aWYgKHJlbWF0Y2ggJiYgcmVtYXRjaC5jYXVzZSA9PSB0b2tlbiArICcsJyArIGopIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgcGF0dGVybk9iaiA9IHBhdHRlcm5zW2pdO1xuXHRcdFx0XHR2YXIgaW5zaWRlID0gcGF0dGVybk9iai5pbnNpZGU7XG5cdFx0XHRcdHZhciBsb29rYmVoaW5kID0gISFwYXR0ZXJuT2JqLmxvb2tiZWhpbmQ7XG5cdFx0XHRcdHZhciBncmVlZHkgPSAhIXBhdHRlcm5PYmouZ3JlZWR5O1xuXHRcdFx0XHR2YXIgYWxpYXMgPSBwYXR0ZXJuT2JqLmFsaWFzO1xuXG5cdFx0XHRcdGlmIChncmVlZHkgJiYgIXBhdHRlcm5PYmoucGF0dGVybi5nbG9iYWwpIHtcblx0XHRcdFx0XHQvLyBXaXRob3V0IHRoZSBnbG9iYWwgZmxhZywgbGFzdEluZGV4IHdvbid0IHdvcmtcblx0XHRcdFx0XHR2YXIgZmxhZ3MgPSBwYXR0ZXJuT2JqLnBhdHRlcm4udG9TdHJpbmcoKS5tYXRjaCgvW2ltc3V5XSokLylbMF07XG5cdFx0XHRcdFx0cGF0dGVybk9iai5wYXR0ZXJuID0gUmVnRXhwKHBhdHRlcm5PYmoucGF0dGVybi5zb3VyY2UsIGZsYWdzICsgJ2cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8qKiBAdHlwZSB7UmVnRXhwfSAqL1xuXHRcdFx0XHR2YXIgcGF0dGVybiA9IHBhdHRlcm5PYmoucGF0dGVybiB8fCBwYXR0ZXJuT2JqO1xuXG5cdFx0XHRcdGZvciAoIC8vIGl0ZXJhdGUgdGhlIHRva2VuIGxpc3QgYW5kIGtlZXAgdHJhY2sgb2YgdGhlIGN1cnJlbnQgdG9rZW4vc3RyaW5nIHBvc2l0aW9uXG5cdFx0XHRcdFx0dmFyIGN1cnJlbnROb2RlID0gc3RhcnROb2RlLm5leHQsIHBvcyA9IHN0YXJ0UG9zO1xuXHRcdFx0XHRcdGN1cnJlbnROb2RlICE9PSB0b2tlbkxpc3QudGFpbDtcblx0XHRcdFx0XHRwb3MgKz0gY3VycmVudE5vZGUudmFsdWUubGVuZ3RoLCBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLm5leHRcblx0XHRcdFx0KSB7XG5cblx0XHRcdFx0XHRpZiAocmVtYXRjaCAmJiBwb3MgPj0gcmVtYXRjaC5yZWFjaCkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIHN0ciA9IGN1cnJlbnROb2RlLnZhbHVlO1xuXG5cdFx0XHRcdFx0aWYgKHRva2VuTGlzdC5sZW5ndGggPiB0ZXh0Lmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0Ly8gU29tZXRoaW5nIHdlbnQgdGVycmlibHkgd3JvbmcsIEFCT1JULCBBQk9SVCFcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoc3RyIGluc3RhbmNlb2YgVG9rZW4pIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciByZW1vdmVDb3VudCA9IDE7IC8vIHRoaXMgaXMgdGhlIHRvIHBhcmFtZXRlciBvZiByZW1vdmVCZXR3ZWVuXG5cdFx0XHRcdFx0dmFyIG1hdGNoO1xuXG5cdFx0XHRcdFx0aWYgKGdyZWVkeSkge1xuXHRcdFx0XHRcdFx0bWF0Y2ggPSBtYXRjaFBhdHRlcm4ocGF0dGVybiwgcG9zLCB0ZXh0LCBsb29rYmVoaW5kKTtcblx0XHRcdFx0XHRcdGlmICghbWF0Y2ggfHwgbWF0Y2guaW5kZXggPj0gdGV4dC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHZhciBmcm9tID0gbWF0Y2guaW5kZXg7XG5cdFx0XHRcdFx0XHR2YXIgdG8gPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcblx0XHRcdFx0XHRcdHZhciBwID0gcG9zO1xuXG5cdFx0XHRcdFx0XHQvLyBmaW5kIHRoZSBub2RlIHRoYXQgY29udGFpbnMgdGhlIG1hdGNoXG5cdFx0XHRcdFx0XHRwICs9IGN1cnJlbnROb2RlLnZhbHVlLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlIChmcm9tID49IHApIHtcblx0XHRcdFx0XHRcdFx0Y3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5uZXh0O1xuXHRcdFx0XHRcdFx0XHRwICs9IGN1cnJlbnROb2RlLnZhbHVlLmxlbmd0aDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIGFkanVzdCBwb3MgKGFuZCBwKVxuXHRcdFx0XHRcdFx0cCAtPSBjdXJyZW50Tm9kZS52YWx1ZS5sZW5ndGg7XG5cdFx0XHRcdFx0XHRwb3MgPSBwO1xuXG5cdFx0XHRcdFx0XHQvLyB0aGUgY3VycmVudCBub2RlIGlzIGEgVG9rZW4sIHRoZW4gdGhlIG1hdGNoIHN0YXJ0cyBpbnNpZGUgYW5vdGhlciBUb2tlbiwgd2hpY2ggaXMgaW52YWxpZFxuXHRcdFx0XHRcdFx0aWYgKGN1cnJlbnROb2RlLnZhbHVlIGluc3RhbmNlb2YgVG9rZW4pIHtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIGZpbmQgdGhlIGxhc3Qgbm9kZSB3aGljaCBpcyBhZmZlY3RlZCBieSB0aGlzIG1hdGNoXG5cdFx0XHRcdFx0XHRmb3IgKFxuXHRcdFx0XHRcdFx0XHR2YXIgayA9IGN1cnJlbnROb2RlO1xuXHRcdFx0XHRcdFx0XHRrICE9PSB0b2tlbkxpc3QudGFpbCAmJiAocCA8IHRvIHx8IHR5cGVvZiBrLnZhbHVlID09PSAnc3RyaW5nJyk7XG5cdFx0XHRcdFx0XHRcdGsgPSBrLm5leHRcblx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHRyZW1vdmVDb3VudCsrO1xuXHRcdFx0XHRcdFx0XHRwICs9IGsudmFsdWUubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmVtb3ZlQ291bnQtLTtcblxuXHRcdFx0XHRcdFx0Ly8gcmVwbGFjZSB3aXRoIHRoZSBuZXcgbWF0Y2hcblx0XHRcdFx0XHRcdHN0ciA9IHRleHQuc2xpY2UocG9zLCBwKTtcblx0XHRcdFx0XHRcdG1hdGNoLmluZGV4IC09IHBvcztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bWF0Y2ggPSBtYXRjaFBhdHRlcm4ocGF0dGVybiwgMCwgc3RyLCBsb29rYmVoaW5kKTtcblx0XHRcdFx0XHRcdGlmICghbWF0Y2gpIHtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXHRcdFx0XHRcdHZhciBmcm9tID0gbWF0Y2guaW5kZXg7XG5cdFx0XHRcdFx0dmFyIG1hdGNoU3RyID0gbWF0Y2hbMF07XG5cdFx0XHRcdFx0dmFyIGJlZm9yZSA9IHN0ci5zbGljZSgwLCBmcm9tKTtcblx0XHRcdFx0XHR2YXIgYWZ0ZXIgPSBzdHIuc2xpY2UoZnJvbSArIG1hdGNoU3RyLmxlbmd0aCk7XG5cblx0XHRcdFx0XHR2YXIgcmVhY2ggPSBwb3MgKyBzdHIubGVuZ3RoO1xuXHRcdFx0XHRcdGlmIChyZW1hdGNoICYmIHJlYWNoID4gcmVtYXRjaC5yZWFjaCkge1xuXHRcdFx0XHRcdFx0cmVtYXRjaC5yZWFjaCA9IHJlYWNoO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciByZW1vdmVGcm9tID0gY3VycmVudE5vZGUucHJldjtcblxuXHRcdFx0XHRcdGlmIChiZWZvcmUpIHtcblx0XHRcdFx0XHRcdHJlbW92ZUZyb20gPSBhZGRBZnRlcih0b2tlbkxpc3QsIHJlbW92ZUZyb20sIGJlZm9yZSk7XG5cdFx0XHRcdFx0XHRwb3MgKz0gYmVmb3JlLmxlbmd0aDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZW1vdmVSYW5nZSh0b2tlbkxpc3QsIHJlbW92ZUZyb20sIHJlbW92ZUNvdW50KTtcblxuXHRcdFx0XHRcdHZhciB3cmFwcGVkID0gbmV3IFRva2VuKHRva2VuLCBpbnNpZGUgPyBfLnRva2VuaXplKG1hdGNoU3RyLCBpbnNpZGUpIDogbWF0Y2hTdHIsIGFsaWFzLCBtYXRjaFN0cik7XG5cdFx0XHRcdFx0Y3VycmVudE5vZGUgPSBhZGRBZnRlcih0b2tlbkxpc3QsIHJlbW92ZUZyb20sIHdyYXBwZWQpO1xuXG5cdFx0XHRcdFx0aWYgKGFmdGVyKSB7XG5cdFx0XHRcdFx0XHRhZGRBZnRlcih0b2tlbkxpc3QsIGN1cnJlbnROb2RlLCBhZnRlcik7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHJlbW92ZUNvdW50ID4gMSkge1xuXHRcdFx0XHRcdFx0Ly8gYXQgbGVhc3Qgb25lIFRva2VuIG9iamVjdCB3YXMgcmVtb3ZlZCwgc28gd2UgaGF2ZSB0byBkbyBzb21lIHJlbWF0Y2hpbmdcblx0XHRcdFx0XHRcdC8vIHRoaXMgY2FuIG9ubHkgaGFwcGVuIGlmIHRoZSBjdXJyZW50IHBhdHRlcm4gaXMgZ3JlZWR5XG5cblx0XHRcdFx0XHRcdC8qKiBAdHlwZSB7UmVtYXRjaE9wdGlvbnN9ICovXG5cdFx0XHRcdFx0XHR2YXIgbmVzdGVkUmVtYXRjaCA9IHtcblx0XHRcdFx0XHRcdFx0Y2F1c2U6IHRva2VuICsgJywnICsgaixcblx0XHRcdFx0XHRcdFx0cmVhY2g6IHJlYWNoXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0bWF0Y2hHcmFtbWFyKHRleHQsIHRva2VuTGlzdCwgZ3JhbW1hciwgY3VycmVudE5vZGUucHJldiwgcG9zLCBuZXN0ZWRSZW1hdGNoKTtcblxuXHRcdFx0XHRcdFx0Ly8gdGhlIHJlYWNoIG1pZ2h0IGhhdmUgYmVlbiBleHRlbmRlZCBiZWNhdXNlIG9mIHRoZSByZW1hdGNoaW5nXG5cdFx0XHRcdFx0XHRpZiAocmVtYXRjaCAmJiBuZXN0ZWRSZW1hdGNoLnJlYWNoID4gcmVtYXRjaC5yZWFjaCkge1xuXHRcdFx0XHRcdFx0XHRyZW1hdGNoLnJlYWNoID0gbmVzdGVkUmVtYXRjaC5yZWFjaDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGVkZWYgTGlua2VkTGlzdE5vZGVcblx0ICogQHByb3BlcnR5IHtUfSB2YWx1ZVxuXHQgKiBAcHJvcGVydHkge0xpbmtlZExpc3ROb2RlPFQ+IHwgbnVsbH0gcHJldiBUaGUgcHJldmlvdXMgbm9kZS5cblx0ICogQHByb3BlcnR5IHtMaW5rZWRMaXN0Tm9kZTxUPiB8IG51bGx9IG5leHQgVGhlIG5leHQgbm9kZS5cblx0ICogQHRlbXBsYXRlIFRcblx0ICogQHByaXZhdGVcblx0ICovXG5cblx0LyoqXG5cdCAqIEB0ZW1wbGF0ZSBUXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBMaW5rZWRMaXN0KCkge1xuXHRcdC8qKiBAdHlwZSB7TGlua2VkTGlzdE5vZGU8VD59ICovXG5cdFx0dmFyIGhlYWQgPSB7IHZhbHVlOiBudWxsLCBwcmV2OiBudWxsLCBuZXh0OiBudWxsIH07XG5cdFx0LyoqIEB0eXBlIHtMaW5rZWRMaXN0Tm9kZTxUPn0gKi9cblx0XHR2YXIgdGFpbCA9IHsgdmFsdWU6IG51bGwsIHByZXY6IGhlYWQsIG5leHQ6IG51bGwgfTtcblx0XHRoZWFkLm5leHQgPSB0YWlsO1xuXG5cdFx0LyoqIEB0eXBlIHtMaW5rZWRMaXN0Tm9kZTxUPn0gKi9cblx0XHR0aGlzLmhlYWQgPSBoZWFkO1xuXHRcdC8qKiBAdHlwZSB7TGlua2VkTGlzdE5vZGU8VD59ICovXG5cdFx0dGhpcy50YWlsID0gdGFpbDtcblx0XHR0aGlzLmxlbmd0aCA9IDA7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIG5ldyBub2RlIHdpdGggdGhlIGdpdmVuIHZhbHVlIHRvIHRoZSBsaXN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0xpbmtlZExpc3Q8VD59IGxpc3Rcblx0ICogQHBhcmFtIHtMaW5rZWRMaXN0Tm9kZTxUPn0gbm9kZVxuXHQgKiBAcGFyYW0ge1R9IHZhbHVlXG5cdCAqIEByZXR1cm5zIHtMaW5rZWRMaXN0Tm9kZTxUPn0gVGhlIGFkZGVkIG5vZGUuXG5cdCAqIEB0ZW1wbGF0ZSBUXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGRBZnRlcihsaXN0LCBub2RlLCB2YWx1ZSkge1xuXHRcdC8vIGFzc3VtZXMgdGhhdCBub2RlICE9IGxpc3QudGFpbCAmJiB2YWx1ZXMubGVuZ3RoID49IDBcblx0XHR2YXIgbmV4dCA9IG5vZGUubmV4dDtcblxuXHRcdHZhciBuZXdOb2RlID0geyB2YWx1ZTogdmFsdWUsIHByZXY6IG5vZGUsIG5leHQ6IG5leHQgfTtcblx0XHRub2RlLm5leHQgPSBuZXdOb2RlO1xuXHRcdG5leHQucHJldiA9IG5ld05vZGU7XG5cdFx0bGlzdC5sZW5ndGgrKztcblxuXHRcdHJldHVybiBuZXdOb2RlO1xuXHR9XG5cdC8qKlxuXHQgKiBSZW1vdmVzIGBjb3VudGAgbm9kZXMgYWZ0ZXIgdGhlIGdpdmVuIG5vZGUuIFRoZSBnaXZlbiBub2RlIHdpbGwgbm90IGJlIHJlbW92ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TGlua2VkTGlzdDxUPn0gbGlzdFxuXHQgKiBAcGFyYW0ge0xpbmtlZExpc3ROb2RlPFQ+fSBub2RlXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudFxuXHQgKiBAdGVtcGxhdGUgVFxuXHQgKi9cblx0ZnVuY3Rpb24gcmVtb3ZlUmFuZ2UobGlzdCwgbm9kZSwgY291bnQpIHtcblx0XHR2YXIgbmV4dCA9IG5vZGUubmV4dDtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50ICYmIG5leHQgIT09IGxpc3QudGFpbDsgaSsrKSB7XG5cdFx0XHRuZXh0ID0gbmV4dC5uZXh0O1xuXHRcdH1cblx0XHRub2RlLm5leHQgPSBuZXh0O1xuXHRcdG5leHQucHJldiA9IG5vZGU7XG5cdFx0bGlzdC5sZW5ndGggLT0gaTtcblx0fVxuXHQvKipcblx0ICogQHBhcmFtIHtMaW5rZWRMaXN0PFQ+fSBsaXN0XG5cdCAqIEByZXR1cm5zIHtUW119XG5cdCAqIEB0ZW1wbGF0ZSBUXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FycmF5KGxpc3QpIHtcblx0XHR2YXIgYXJyYXkgPSBbXTtcblx0XHR2YXIgbm9kZSA9IGxpc3QuaGVhZC5uZXh0O1xuXHRcdHdoaWxlIChub2RlICE9PSBsaXN0LnRhaWwpIHtcblx0XHRcdGFycmF5LnB1c2gobm9kZS52YWx1ZSk7XG5cdFx0XHRub2RlID0gbm9kZS5uZXh0O1xuXHRcdH1cblx0XHRyZXR1cm4gYXJyYXk7XG5cdH1cblxuXG5cdGlmICghX3NlbGYuZG9jdW1lbnQpIHtcblx0XHRpZiAoIV9zZWxmLmFkZEV2ZW50TGlzdGVuZXIpIHtcblx0XHRcdC8vIGluIE5vZGUuanNcblx0XHRcdHJldHVybiBfO1xuXHRcdH1cblxuXHRcdGlmICghXy5kaXNhYmxlV29ya2VyTWVzc2FnZUhhbmRsZXIpIHtcblx0XHRcdC8vIEluIHdvcmtlclxuXHRcdFx0X3NlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChldnQpIHtcblx0XHRcdFx0dmFyIG1lc3NhZ2UgPSBKU09OLnBhcnNlKGV2dC5kYXRhKTtcblx0XHRcdFx0dmFyIGxhbmcgPSBtZXNzYWdlLmxhbmd1YWdlO1xuXHRcdFx0XHR2YXIgY29kZSA9IG1lc3NhZ2UuY29kZTtcblx0XHRcdFx0dmFyIGltbWVkaWF0ZUNsb3NlID0gbWVzc2FnZS5pbW1lZGlhdGVDbG9zZTtcblxuXHRcdFx0XHRfc2VsZi5wb3N0TWVzc2FnZShfLmhpZ2hsaWdodChjb2RlLCBfLmxhbmd1YWdlc1tsYW5nXSwgbGFuZykpO1xuXHRcdFx0XHRpZiAoaW1tZWRpYXRlQ2xvc2UpIHtcblx0XHRcdFx0XHRfc2VsZi5jbG9zZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCBmYWxzZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIF87XG5cdH1cblxuXHQvLyBHZXQgY3VycmVudCBzY3JpcHQgYW5kIGhpZ2hsaWdodFxuXHR2YXIgc2NyaXB0ID0gXy51dGlsLmN1cnJlbnRTY3JpcHQoKTtcblxuXHRpZiAoc2NyaXB0KSB7XG5cdFx0Xy5maWxlbmFtZSA9IHNjcmlwdC5zcmM7XG5cblx0XHRpZiAoc2NyaXB0Lmhhc0F0dHJpYnV0ZSgnZGF0YS1tYW51YWwnKSkge1xuXHRcdFx0Xy5tYW51YWwgPSB0cnVlO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGhpZ2hsaWdodEF1dG9tYXRpY2FsbHlDYWxsYmFjaygpIHtcblx0XHRpZiAoIV8ubWFudWFsKSB7XG5cdFx0XHRfLmhpZ2hsaWdodEFsbCgpO1xuXHRcdH1cblx0fVxuXG5cdGlmICghXy5tYW51YWwpIHtcblx0XHQvLyBJZiB0aGUgZG9jdW1lbnQgc3RhdGUgaXMgXCJsb2FkaW5nXCIsIHRoZW4gd2UnbGwgdXNlIERPTUNvbnRlbnRMb2FkZWQuXG5cdFx0Ly8gSWYgdGhlIGRvY3VtZW50IHN0YXRlIGlzIFwiaW50ZXJhY3RpdmVcIiBhbmQgdGhlIHByaXNtLmpzIHNjcmlwdCBpcyBkZWZlcnJlZCwgdGhlbiB3ZSdsbCBhbHNvIHVzZSB0aGVcblx0XHQvLyBET01Db250ZW50TG9hZGVkIGV2ZW50IGJlY2F1c2UgdGhlcmUgbWlnaHQgYmUgc29tZSBwbHVnaW5zIG9yIGxhbmd1YWdlcyB3aGljaCBoYXZlIGFsc28gYmVlbiBkZWZlcnJlZCBhbmQgdGhleVxuXHRcdC8vIG1pZ2h0IHRha2UgbG9uZ2VyIG9uZSBhbmltYXRpb24gZnJhbWUgdG8gZXhlY3V0ZSB3aGljaCBjYW4gY3JlYXRlIGEgcmFjZSBjb25kaXRpb24gd2hlcmUgb25seSBzb21lIHBsdWdpbnMgaGF2ZVxuXHRcdC8vIGJlZW4gbG9hZGVkIHdoZW4gUHJpc20uaGlnaGxpZ2h0QWxsKCkgaXMgZXhlY3V0ZWQsIGRlcGVuZGluZyBvbiBob3cgZmFzdCByZXNvdXJjZXMgYXJlIGxvYWRlZC5cblx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL1ByaXNtSlMvcHJpc20vaXNzdWVzLzIxMDJcblx0XHR2YXIgcmVhZHlTdGF0ZSA9IGRvY3VtZW50LnJlYWR5U3RhdGU7XG5cdFx0aWYgKHJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJyB8fCByZWFkeVN0YXRlID09PSAnaW50ZXJhY3RpdmUnICYmIHNjcmlwdCAmJiBzY3JpcHQuZGVmZXIpIHtcblx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBoaWdobGlnaHRBdXRvbWF0aWNhbGx5Q2FsbGJhY2spO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuXHRcdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGhpZ2hsaWdodEF1dG9tYXRpY2FsbHlDYWxsYmFjayk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dChoaWdobGlnaHRBdXRvbWF0aWNhbGx5Q2FsbGJhY2ssIDE2KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gXztcblxufShfc2VsZikpO1xuXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0bW9kdWxlLmV4cG9ydHMgPSBQcmlzbTtcbn1cblxuLy8gaGFjayBmb3IgY29tcG9uZW50cyB0byB3b3JrIGNvcnJlY3RseSBpbiBub2RlLmpzXG5pZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0Z2xvYmFsLlByaXNtID0gUHJpc207XG59XG5cbi8vIHNvbWUgYWRkaXRpb25hbCBkb2N1bWVudGF0aW9uL3R5cGVzXG5cbi8qKlxuICogVGhlIGV4cGFuc2lvbiBvZiBhIHNpbXBsZSBgUmVnRXhwYCBsaXRlcmFsIHRvIHN1cHBvcnQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzLlxuICpcbiAqIEB0eXBlZGVmIEdyYW1tYXJUb2tlblxuICogQHByb3BlcnR5IHtSZWdFeHB9IHBhdHRlcm4gVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBvZiB0aGUgdG9rZW4uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtsb29rYmVoaW5kPWZhbHNlXSBJZiBgdHJ1ZWAsIHRoZW4gdGhlIGZpcnN0IGNhcHR1cmluZyBncm91cCBvZiBgcGF0dGVybmAgd2lsbCAoZWZmZWN0aXZlbHkpXG4gKiBiZWhhdmUgYXMgYSBsb29rYmVoaW5kIGdyb3VwIG1lYW5pbmcgdGhhdCB0aGUgY2FwdHVyZWQgdGV4dCB3aWxsIG5vdCBiZSBwYXJ0IG9mIHRoZSBtYXRjaGVkIHRleHQgb2YgdGhlIG5ldyB0b2tlbi5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2dyZWVkeT1mYWxzZV0gV2hldGhlciB0aGUgdG9rZW4gaXMgZ3JlZWR5LlxuICogQHByb3BlcnR5IHtzdHJpbmd8c3RyaW5nW119IFthbGlhc10gQW4gb3B0aW9uYWwgYWxpYXMgb3IgbGlzdCBvZiBhbGlhc2VzLlxuICogQHByb3BlcnR5IHtHcmFtbWFyfSBbaW5zaWRlXSBUaGUgbmVzdGVkIGdyYW1tYXIgb2YgdGhpcyB0b2tlbi5cbiAqXG4gKiBUaGUgYGluc2lkZWAgZ3JhbW1hciB3aWxsIGJlIHVzZWQgdG8gdG9rZW5pemUgdGhlIHRleHQgdmFsdWUgb2YgZWFjaCB0b2tlbiBvZiB0aGlzIGtpbmQuXG4gKlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBtYWtlIG5lc3RlZCBhbmQgZXZlbiByZWN1cnNpdmUgbGFuZ3VhZ2UgZGVmaW5pdGlvbnMuXG4gKlxuICogTm90ZTogVGhpcyBjYW4gY2F1c2UgaW5maW5pdGUgcmVjdXJzaW9uLiBCZSBjYXJlZnVsIHdoZW4geW91IGVtYmVkIGRpZmZlcmVudCBsYW5ndWFnZXMgb3IgZXZlbiB0aGUgc2FtZSBsYW5ndWFnZSBpbnRvXG4gKiBlYWNoIGFub3RoZXIuXG4gKiBAZ2xvYmFsXG4gKiBAcHVibGljXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiBHcmFtbWFyXG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgUmVnRXhwIHwgR3JhbW1hclRva2VuIHwgQXJyYXk8UmVnRXhwIHwgR3JhbW1hclRva2VuPj59XG4gKiBAcHJvcGVydHkge0dyYW1tYXJ9IFtyZXN0XSBBbiBvcHRpb25hbCBncmFtbWFyIG9iamVjdCB0aGF0IHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhpcyBncmFtbWFyLlxuICogQGdsb2JhbFxuICogQHB1YmxpY1xuICovXG5cbi8qKlxuICogQSBmdW5jdGlvbiB3aGljaCB3aWxsIGludm9rZWQgYWZ0ZXIgYW4gZWxlbWVudCB3YXMgc3VjY2Vzc2Z1bGx5IGhpZ2hsaWdodGVkLlxuICpcbiAqIEBjYWxsYmFjayBIaWdobGlnaHRDYWxsYmFja1xuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHN1Y2Nlc3NmdWxseSBoaWdobGlnaHRlZC5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQGdsb2JhbFxuICogQHB1YmxpY1xuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIEhvb2tDYWxsYmFja1xuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBlbnYgVGhlIGVudmlyb25tZW50IHZhcmlhYmxlcyBvZiB0aGUgaG9vay5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQGdsb2JhbFxuICogQHB1YmxpY1xuICovXG5cblxuLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICBCZWdpbiBwcmlzbS1tYXJrdXAuanNcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cCA9IHtcblx0J2NvbW1lbnQnOiB7XG5cdFx0cGF0dGVybjogLzwhLS0oPzooPyE8IS0tKVtcXHNcXFNdKSo/LS0+Lyxcblx0XHRncmVlZHk6IHRydWVcblx0fSxcblx0J3Byb2xvZyc6IHtcblx0XHRwYXR0ZXJuOiAvPFxcP1tcXHNcXFNdKz9cXD8+Lyxcblx0XHRncmVlZHk6IHRydWVcblx0fSxcblx0J2RvY3R5cGUnOiB7XG5cdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3htbC8jTlQtZG9jdHlwZWRlY2xcblx0XHRwYXR0ZXJuOiAvPCFET0NUWVBFKD86W14+XCInW1xcXV18XCJbXlwiXSpcInwnW14nXSonKSsoPzpcXFsoPzpbXjxcIidcXF1dfFwiW15cIl0qXCJ8J1teJ10qJ3w8KD8hIS0tKXw8IS0tKD86W14tXXwtKD8hLT4pKSotLT4pKlxcXVxccyopPz4vaSxcblx0XHRncmVlZHk6IHRydWUsXG5cdFx0aW5zaWRlOiB7XG5cdFx0XHQnaW50ZXJuYWwtc3Vic2V0Jzoge1xuXHRcdFx0XHRwYXR0ZXJuOiAvKF5bXlxcW10qXFxbKVtcXHNcXFNdKyg/PVxcXT4kKS8sXG5cdFx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRcdFx0aW5zaWRlOiBudWxsIC8vIHNlZSBiZWxvd1xuXHRcdFx0fSxcblx0XHRcdCdzdHJpbmcnOiB7XG5cdFx0XHRcdHBhdHRlcm46IC9cIlteXCJdKlwifCdbXiddKicvLFxuXHRcdFx0XHRncmVlZHk6IHRydWVcblx0XHRcdH0sXG5cdFx0XHQncHVuY3R1YXRpb24nOiAvXjwhfD4kfFtbXFxdXS8sXG5cdFx0XHQnZG9jdHlwZS10YWcnOiAvXkRPQ1RZUEUvaSxcblx0XHRcdCduYW1lJzogL1teXFxzPD4nXCJdKy9cblx0XHR9XG5cdH0sXG5cdCdjZGF0YSc6IHtcblx0XHRwYXR0ZXJuOiAvPCFcXFtDREFUQVxcW1tcXHNcXFNdKj9cXF1cXF0+L2ksXG5cdFx0Z3JlZWR5OiB0cnVlXG5cdH0sXG5cdCd0YWcnOiB7XG5cdFx0cGF0dGVybjogLzxcXC8/KD8hXFxkKVteXFxzPlxcLz0kPCVdKyg/Olxccyg/OlxccypbXlxccz5cXC89XSsoPzpcXHMqPVxccyooPzpcIlteXCJdKlwifCdbXiddKid8W15cXHMnXCI+PV0rKD89W1xccz5dKSl8KD89W1xccy8+XSkpKSspP1xccypcXC8/Pi8sXG5cdFx0Z3JlZWR5OiB0cnVlLFxuXHRcdGluc2lkZToge1xuXHRcdFx0J3RhZyc6IHtcblx0XHRcdFx0cGF0dGVybjogL148XFwvP1teXFxzPlxcL10rLyxcblx0XHRcdFx0aW5zaWRlOiB7XG5cdFx0XHRcdFx0J3B1bmN0dWF0aW9uJzogL148XFwvPy8sXG5cdFx0XHRcdFx0J25hbWVzcGFjZSc6IC9eW15cXHM+XFwvOl0rOi9cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdCdzcGVjaWFsLWF0dHInOiBbXSxcblx0XHRcdCdhdHRyLXZhbHVlJzoge1xuXHRcdFx0XHRwYXR0ZXJuOiAvPVxccyooPzpcIlteXCJdKlwifCdbXiddKid8W15cXHMnXCI+PV0rKS8sXG5cdFx0XHRcdGluc2lkZToge1xuXHRcdFx0XHRcdCdwdW5jdHVhdGlvbic6IFtcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0cGF0dGVybjogL149Lyxcblx0XHRcdFx0XHRcdFx0YWxpYXM6ICdhdHRyLWVxdWFscydcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHQvXCJ8Jy9cblx0XHRcdFx0XHRdXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQncHVuY3R1YXRpb24nOiAvXFwvPz4vLFxuXHRcdFx0J2F0dHItbmFtZSc6IHtcblx0XHRcdFx0cGF0dGVybjogL1teXFxzPlxcL10rLyxcblx0XHRcdFx0aW5zaWRlOiB7XG5cdFx0XHRcdFx0J25hbWVzcGFjZSc6IC9eW15cXHM+XFwvOl0rOi9cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fVxuXHR9LFxuXHQnZW50aXR5JzogW1xuXHRcdHtcblx0XHRcdHBhdHRlcm46IC8mW1xcZGEtel17MSw4fTsvaSxcblx0XHRcdGFsaWFzOiAnbmFtZWQtZW50aXR5J1xuXHRcdH0sXG5cdFx0LyYjeD9bXFxkYS1mXXsxLDh9Oy9pXG5cdF1cbn07XG5cblByaXNtLmxhbmd1YWdlcy5tYXJrdXBbJ3RhZyddLmluc2lkZVsnYXR0ci12YWx1ZSddLmluc2lkZVsnZW50aXR5J10gPVxuXHRQcmlzbS5sYW5ndWFnZXMubWFya3VwWydlbnRpdHknXTtcblByaXNtLmxhbmd1YWdlcy5tYXJrdXBbJ2RvY3R5cGUnXS5pbnNpZGVbJ2ludGVybmFsLXN1YnNldCddLmluc2lkZSA9IFByaXNtLmxhbmd1YWdlcy5tYXJrdXA7XG5cbi8vIFBsdWdpbiB0byBtYWtlIGVudGl0eSB0aXRsZSBzaG93IHRoZSByZWFsIGVudGl0eSwgaWRlYSBieSBSb21hbiBLb21hcm92XG5QcmlzbS5ob29rcy5hZGQoJ3dyYXAnLCBmdW5jdGlvbiAoZW52KSB7XG5cblx0aWYgKGVudi50eXBlID09PSAnZW50aXR5Jykge1xuXHRcdGVudi5hdHRyaWJ1dGVzWyd0aXRsZSddID0gZW52LmNvbnRlbnQucmVwbGFjZSgvJmFtcDsvLCAnJicpO1xuXHR9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFByaXNtLmxhbmd1YWdlcy5tYXJrdXAudGFnLCAnYWRkSW5saW5lZCcsIHtcblx0LyoqXG5cdCAqIEFkZHMgYW4gaW5saW5lZCBsYW5ndWFnZSB0byBtYXJrdXAuXG5cdCAqXG5cdCAqIEFuIGV4YW1wbGUgb2YgYW4gaW5saW5lZCBsYW5ndWFnZSBpcyBDU1Mgd2l0aCBgPHN0eWxlPmAgdGFncy5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWUgVGhlIG5hbWUgb2YgdGhlIHRhZyB0aGF0IGNvbnRhaW5zIHRoZSBpbmxpbmVkIGxhbmd1YWdlLiBUaGlzIG5hbWUgd2lsbCBiZSB0cmVhdGVkIGFzXG5cdCAqIGNhc2UgaW5zZW5zaXRpdmUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBsYW5nIFRoZSBsYW5ndWFnZSBrZXkuXG5cdCAqIEBleGFtcGxlXG5cdCAqIGFkZElubGluZWQoJ3N0eWxlJywgJ2NzcycpO1xuXHQgKi9cblx0dmFsdWU6IGZ1bmN0aW9uIGFkZElubGluZWQodGFnTmFtZSwgbGFuZykge1xuXHRcdHZhciBpbmNsdWRlZENkYXRhSW5zaWRlID0ge307XG5cdFx0aW5jbHVkZWRDZGF0YUluc2lkZVsnbGFuZ3VhZ2UtJyArIGxhbmddID0ge1xuXHRcdFx0cGF0dGVybjogLyhePCFcXFtDREFUQVxcWylbXFxzXFxTXSs/KD89XFxdXFxdPiQpL2ksXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0aW5zaWRlOiBQcmlzbS5sYW5ndWFnZXNbbGFuZ11cblx0XHR9O1xuXHRcdGluY2x1ZGVkQ2RhdGFJbnNpZGVbJ2NkYXRhJ10gPSAvXjwhXFxbQ0RBVEFcXFt8XFxdXFxdPiQvaTtcblxuXHRcdHZhciBpbnNpZGUgPSB7XG5cdFx0XHQnaW5jbHVkZWQtY2RhdGEnOiB7XG5cdFx0XHRcdHBhdHRlcm46IC88IVxcW0NEQVRBXFxbW1xcc1xcU10qP1xcXVxcXT4vaSxcblx0XHRcdFx0aW5zaWRlOiBpbmNsdWRlZENkYXRhSW5zaWRlXG5cdFx0XHR9XG5cdFx0fTtcblx0XHRpbnNpZGVbJ2xhbmd1YWdlLScgKyBsYW5nXSA9IHtcblx0XHRcdHBhdHRlcm46IC9bXFxzXFxTXSsvLFxuXHRcdFx0aW5zaWRlOiBQcmlzbS5sYW5ndWFnZXNbbGFuZ11cblx0XHR9O1xuXG5cdFx0dmFyIGRlZiA9IHt9O1xuXHRcdGRlZlt0YWdOYW1lXSA9IHtcblx0XHRcdHBhdHRlcm46IFJlZ0V4cCgvKDxfX1tePl0qPikoPzo8IVxcW0NEQVRBXFxbKD86W15cXF1dfFxcXSg/IVxcXT4pKSpcXF1cXF0+fCg/ITwhXFxbQ0RBVEFcXFspW1xcc1xcU10pKj8oPz08XFwvX18+KS8uc291cmNlLnJlcGxhY2UoL19fL2csIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRhZ05hbWU7IH0pLCAnaScpLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRcdGluc2lkZTogaW5zaWRlXG5cdFx0fTtcblxuXHRcdFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ21hcmt1cCcsICdjZGF0YScsIGRlZik7XG5cdH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFByaXNtLmxhbmd1YWdlcy5tYXJrdXAudGFnLCAnYWRkQXR0cmlidXRlJywge1xuXHQvKipcblx0ICogQWRkcyBhbiBwYXR0ZXJuIHRvIGhpZ2hsaWdodCBsYW5ndWFnZXMgZW1iZWRkZWQgaW4gSFRNTCBhdHRyaWJ1dGVzLlxuXHQgKlxuXHQgKiBBbiBleGFtcGxlIG9mIGFuIGlubGluZWQgbGFuZ3VhZ2UgaXMgQ1NTIHdpdGggYHN0eWxlYCBhdHRyaWJ1dGVzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gYXR0ck5hbWUgVGhlIG5hbWUgb2YgdGhlIHRhZyB0aGF0IGNvbnRhaW5zIHRoZSBpbmxpbmVkIGxhbmd1YWdlLiBUaGlzIG5hbWUgd2lsbCBiZSB0cmVhdGVkIGFzXG5cdCAqIGNhc2UgaW5zZW5zaXRpdmUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBsYW5nIFRoZSBsYW5ndWFnZSBrZXkuXG5cdCAqIEBleGFtcGxlXG5cdCAqIGFkZEF0dHJpYnV0ZSgnc3R5bGUnLCAnY3NzJyk7XG5cdCAqL1xuXHR2YWx1ZTogZnVuY3Rpb24gKGF0dHJOYW1lLCBsYW5nKSB7XG5cdFx0UHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcuaW5zaWRlWydzcGVjaWFsLWF0dHInXS5wdXNoKHtcblx0XHRcdHBhdHRlcm46IFJlZ0V4cChcblx0XHRcdFx0LyhefFtcIidcXHNdKS8uc291cmNlICsgJyg/OicgKyBhdHRyTmFtZSArICcpJyArIC9cXHMqPVxccyooPzpcIlteXCJdKlwifCdbXiddKid8W15cXHMnXCI+PV0rKD89W1xccz5dKSkvLnNvdXJjZSxcblx0XHRcdFx0J2knXG5cdFx0XHQpLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGluc2lkZToge1xuXHRcdFx0XHQnYXR0ci1uYW1lJzogL15bXlxccz1dKy8sXG5cdFx0XHRcdCdhdHRyLXZhbHVlJzoge1xuXHRcdFx0XHRcdHBhdHRlcm46IC89W1xcc1xcU10rLyxcblx0XHRcdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0XHRcdCd2YWx1ZSc6IHtcblx0XHRcdFx0XHRcdFx0cGF0dGVybjogLyhePVxccyooW1wiJ118KD8hW1wiJ10pKSlcXFNbXFxzXFxTXSooPz1cXDIkKS8sXG5cdFx0XHRcdFx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRcdFx0XHRcdGFsaWFzOiBbbGFuZywgJ2xhbmd1YWdlLScgKyBsYW5nXSxcblx0XHRcdFx0XHRcdFx0aW5zaWRlOiBQcmlzbS5sYW5ndWFnZXNbbGFuZ11cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHQncHVuY3R1YXRpb24nOiBbXG5cdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRwYXR0ZXJuOiAvXj0vLFxuXHRcdFx0XHRcdFx0XHRcdGFsaWFzOiAnYXR0ci1lcXVhbHMnXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdC9cInwnL1xuXHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59KTtcblxuUHJpc20ubGFuZ3VhZ2VzLmh0bWwgPSBQcmlzbS5sYW5ndWFnZXMubWFya3VwO1xuUHJpc20ubGFuZ3VhZ2VzLm1hdGhtbCA9IFByaXNtLmxhbmd1YWdlcy5tYXJrdXA7XG5QcmlzbS5sYW5ndWFnZXMuc3ZnID0gUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cDtcblxuUHJpc20ubGFuZ3VhZ2VzLnhtbCA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ21hcmt1cCcsIHt9KTtcblByaXNtLmxhbmd1YWdlcy5zc21sID0gUHJpc20ubGFuZ3VhZ2VzLnhtbDtcblByaXNtLmxhbmd1YWdlcy5hdG9tID0gUHJpc20ubGFuZ3VhZ2VzLnhtbDtcblByaXNtLmxhbmd1YWdlcy5yc3MgPSBQcmlzbS5sYW5ndWFnZXMueG1sO1xuXG5cbi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgQmVnaW4gcHJpc20tY3NzLmpzXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbihmdW5jdGlvbiAoUHJpc20pIHtcblxuXHR2YXIgc3RyaW5nID0gLyg/OlwiKD86XFxcXCg/OlxcclxcbnxbXFxzXFxTXSl8W15cIlxcXFxcXHJcXG5dKSpcInwnKD86XFxcXCg/OlxcclxcbnxbXFxzXFxTXSl8W14nXFxcXFxcclxcbl0pKicpLztcblxuXHRQcmlzbS5sYW5ndWFnZXMuY3NzID0ge1xuXHRcdCdjb21tZW50JzogL1xcL1xcKltcXHNcXFNdKj9cXCpcXC8vLFxuXHRcdCdhdHJ1bGUnOiB7XG5cdFx0XHRwYXR0ZXJuOiAvQFtcXHctXSg/OlteO3tcXHNdfFxccysoPyFbXFxze10pKSooPzo7fCg/PVxccypcXHspKS8sXG5cdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0J3J1bGUnOiAvXkBbXFx3LV0rLyxcblx0XHRcdFx0J3NlbGVjdG9yLWZ1bmN0aW9uLWFyZ3VtZW50Jzoge1xuXHRcdFx0XHRcdHBhdHRlcm46IC8oXFxic2VsZWN0b3JcXHMqXFwoXFxzKig/IVtcXHMpXSkpKD86W14oKVxcc118XFxzKyg/IVtcXHMpXSl8XFwoKD86W14oKV18XFwoW14oKV0qXFwpKSpcXCkpKyg/PVxccypcXCkpLyxcblx0XHRcdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0XHRcdGFsaWFzOiAnc2VsZWN0b3InXG5cdFx0XHRcdH0sXG5cdFx0XHRcdCdrZXl3b3JkJzoge1xuXHRcdFx0XHRcdHBhdHRlcm46IC8oXnxbXlxcdy1dKSg/OmFuZHxub3R8b25seXxvcikoPyFbXFx3LV0pLyxcblx0XHRcdFx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gU2VlIHJlc3QgYmVsb3dcblx0XHRcdH1cblx0XHR9LFxuXHRcdCd1cmwnOiB7XG5cdFx0XHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLXZhbHVlcy0zLyN1cmxzXG5cdFx0XHRwYXR0ZXJuOiBSZWdFeHAoJ1xcXFxidXJsXFxcXCgoPzonICsgc3RyaW5nLnNvdXJjZSArICd8JyArIC8oPzpbXlxcXFxcXHJcXG4oKVwiJ118XFxcXFtcXHNcXFNdKSovLnNvdXJjZSArICcpXFxcXCknLCAnaScpLFxuXHRcdFx0Z3JlZWR5OiB0cnVlLFxuXHRcdFx0aW5zaWRlOiB7XG5cdFx0XHRcdCdmdW5jdGlvbic6IC9edXJsL2ksXG5cdFx0XHRcdCdwdW5jdHVhdGlvbic6IC9eXFwofFxcKSQvLFxuXHRcdFx0XHQnc3RyaW5nJzoge1xuXHRcdFx0XHRcdHBhdHRlcm46IFJlZ0V4cCgnXicgKyBzdHJpbmcuc291cmNlICsgJyQnKSxcblx0XHRcdFx0XHRhbGlhczogJ3VybCdcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0J3NlbGVjdG9yJzoge1xuXHRcdFx0cGF0dGVybjogUmVnRXhwKCcoXnxbe31cXFxcc10pW157fVxcXFxzXSg/Oltee307XCJcXCdcXFxcc118XFxcXHMrKD8hW1xcXFxze10pfCcgKyBzdHJpbmcuc291cmNlICsgJykqKD89XFxcXHMqXFxcXHspJyksXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdFx0fSxcblx0XHQnc3RyaW5nJzoge1xuXHRcdFx0cGF0dGVybjogc3RyaW5nLFxuXHRcdFx0Z3JlZWR5OiB0cnVlXG5cdFx0fSxcblx0XHQncHJvcGVydHknOiB7XG5cdFx0XHRwYXR0ZXJuOiAvKF58W14tXFx3XFx4QTAtXFx1RkZGRl0pKD8hXFxzKVstX2EtelxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVstXFx3XFx4QTAtXFx1RkZGRl0pKig/PVxccyo6KS9pLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZVxuXHRcdH0sXG5cdFx0J2ltcG9ydGFudCc6IC8haW1wb3J0YW50XFxiL2ksXG5cdFx0J2Z1bmN0aW9uJzoge1xuXHRcdFx0cGF0dGVybjogLyhefFteLWEtejAtOV0pWy1hLXowLTldKyg/PVxcKCkvaSxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWVcblx0XHR9LFxuXHRcdCdwdW5jdHVhdGlvbic6IC9bKCl7fTs6LF0vXG5cdH07XG5cblx0UHJpc20ubGFuZ3VhZ2VzLmNzc1snYXRydWxlJ10uaW5zaWRlLnJlc3QgPSBQcmlzbS5sYW5ndWFnZXMuY3NzO1xuXG5cdHZhciBtYXJrdXAgPSBQcmlzbS5sYW5ndWFnZXMubWFya3VwO1xuXHRpZiAobWFya3VwKSB7XG5cdFx0bWFya3VwLnRhZy5hZGRJbmxpbmVkKCdzdHlsZScsICdjc3MnKTtcblx0XHRtYXJrdXAudGFnLmFkZEF0dHJpYnV0ZSgnc3R5bGUnLCAnY3NzJyk7XG5cdH1cblxufShQcmlzbSkpO1xuXG5cbi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgQmVnaW4gcHJpc20tY2xpa2UuanNcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuUHJpc20ubGFuZ3VhZ2VzLmNsaWtlID0ge1xuXHQnY29tbWVudCc6IFtcblx0XHR7XG5cdFx0XHRwYXR0ZXJuOiAvKF58W15cXFxcXSlcXC9cXCpbXFxzXFxTXSo/KD86XFwqXFwvfCQpLyxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRncmVlZHk6IHRydWVcblx0XHR9LFxuXHRcdHtcblx0XHRcdHBhdHRlcm46IC8oXnxbXlxcXFw6XSlcXC9cXC8uKi8sXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0Z3JlZWR5OiB0cnVlXG5cdFx0fVxuXHRdLFxuXHQnc3RyaW5nJzoge1xuXHRcdHBhdHRlcm46IC8oW1wiJ10pKD86XFxcXCg/OlxcclxcbnxbXFxzXFxTXSl8KD8hXFwxKVteXFxcXFxcclxcbl0pKlxcMS8sXG5cdFx0Z3JlZWR5OiB0cnVlXG5cdH0sXG5cdCdjbGFzcy1uYW1lJzoge1xuXHRcdHBhdHRlcm46IC8oXFxiKD86Y2xhc3N8ZXh0ZW5kc3xpbXBsZW1lbnRzfGluc3RhbmNlb2Z8aW50ZXJmYWNlfG5ld3x0cmFpdClcXHMrfFxcYmNhdGNoXFxzK1xcKClbXFx3LlxcXFxdKy9pLFxuXHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0aW5zaWRlOiB7XG5cdFx0XHQncHVuY3R1YXRpb24nOiAvWy5cXFxcXS9cblx0XHR9XG5cdH0sXG5cdCdrZXl3b3JkJzogL1xcYig/OmJyZWFrfGNhdGNofGNvbnRpbnVlfGRvfGVsc2V8ZmluYWxseXxmb3J8ZnVuY3Rpb258aWZ8aW58aW5zdGFuY2VvZnxuZXd8bnVsbHxyZXR1cm58dGhyb3d8dHJ5fHdoaWxlKVxcYi8sXG5cdCdib29sZWFuJzogL1xcYig/OmZhbHNlfHRydWUpXFxiLyxcblx0J2Z1bmN0aW9uJzogL1xcYlxcdysoPz1cXCgpLyxcblx0J251bWJlcic6IC9cXGIweFtcXGRhLWZdK1xcYnwoPzpcXGJcXGQrKD86XFwuXFxkKik/fFxcQlxcLlxcZCspKD86ZVsrLV0/XFxkKyk/L2ksXG5cdCdvcGVyYXRvcic6IC9bPD5dPT98WyE9XT0/PT98LS0/fFxcK1xcKz98JiY/fFxcfFxcfD98Wz8qL35eJV0vLFxuXHQncHVuY3R1YXRpb24nOiAvW3t9W1xcXTsoKSwuOl0vXG59O1xuXG5cbi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgQmVnaW4gcHJpc20tamF2YXNjcmlwdC5qc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG5QcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdCA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2NsaWtlJywge1xuXHQnY2xhc3MtbmFtZSc6IFtcblx0XHRQcmlzbS5sYW5ndWFnZXMuY2xpa2VbJ2NsYXNzLW5hbWUnXSxcblx0XHR7XG5cdFx0XHRwYXR0ZXJuOiAvKF58W14kXFx3XFx4QTAtXFx1RkZGRl0pKD8hXFxzKVtfJEEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKig/PVxcLig/OmNvbnN0cnVjdG9yfHByb3RvdHlwZSkpLyxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWVcblx0XHR9XG5cdF0sXG5cdCdrZXl3b3JkJzogW1xuXHRcdHtcblx0XHRcdHBhdHRlcm46IC8oKD86XnxcXH0pXFxzKiljYXRjaFxcYi8sXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRwYXR0ZXJuOiAvKF58W14uXXxcXC5cXC5cXC5cXHMqKVxcYig/OmFzfGFzc2VydCg/PVxccypcXHspfGFzeW5jKD89XFxzKig/OmZ1bmN0aW9uXFxifFxcKHxbJFxcd1xceEEwLVxcdUZGRkZdfCQpKXxhd2FpdHxicmVha3xjYXNlfGNsYXNzfGNvbnN0fGNvbnRpbnVlfGRlYnVnZ2VyfGRlZmF1bHR8ZGVsZXRlfGRvfGVsc2V8ZW51bXxleHBvcnR8ZXh0ZW5kc3xmaW5hbGx5KD89XFxzKig/Olxce3wkKSl8Zm9yfGZyb20oPz1cXHMqKD86WydcIl18JCkpfGZ1bmN0aW9ufCg/OmdldHxzZXQpKD89XFxzKig/OlsjXFxbJFxcd1xceEEwLVxcdUZGRkZdfCQpKXxpZnxpbXBsZW1lbnRzfGltcG9ydHxpbnxpbnN0YW5jZW9mfGludGVyZmFjZXxsZXR8bmV3fG51bGx8b2Z8cGFja2FnZXxwcml2YXRlfHByb3RlY3RlZHxwdWJsaWN8cmV0dXJufHN0YXRpY3xzdXBlcnxzd2l0Y2h8dGhpc3x0aHJvd3x0cnl8dHlwZW9mfHVuZGVmaW5lZHx2YXJ8dm9pZHx3aGlsZXx3aXRofHlpZWxkKVxcYi8sXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdFx0fSxcblx0XSxcblx0Ly8gQWxsb3cgZm9yIGFsbCBub24tQVNDSUkgY2hhcmFjdGVycyAoU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIwMDg0NDQpXG5cdCdmdW5jdGlvbic6IC8jPyg/IVxccylbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSooPz1cXHMqKD86XFwuXFxzKig/OmFwcGx5fGJpbmR8Y2FsbClcXHMqKT9cXCgpLyxcblx0J251bWJlcic6IHtcblx0XHRwYXR0ZXJuOiBSZWdFeHAoXG5cdFx0XHQvKF58W15cXHckXSkvLnNvdXJjZSArXG5cdFx0XHQnKD86JyArXG5cdFx0XHQoXG5cdFx0XHRcdC8vIGNvbnN0YW50XG5cdFx0XHRcdC9OYU58SW5maW5pdHkvLnNvdXJjZSArXG5cdFx0XHRcdCd8JyArXG5cdFx0XHRcdC8vIGJpbmFyeSBpbnRlZ2VyXG5cdFx0XHRcdC8wW2JCXVswMV0rKD86X1swMV0rKSpuPy8uc291cmNlICtcblx0XHRcdFx0J3wnICtcblx0XHRcdFx0Ly8gb2N0YWwgaW50ZWdlclxuXHRcdFx0XHQvMFtvT11bMC03XSsoPzpfWzAtN10rKSpuPy8uc291cmNlICtcblx0XHRcdFx0J3wnICtcblx0XHRcdFx0Ly8gaGV4YWRlY2ltYWwgaW50ZWdlclxuXHRcdFx0XHQvMFt4WF1bXFxkQS1GYS1mXSsoPzpfW1xcZEEtRmEtZl0rKSpuPy8uc291cmNlICtcblx0XHRcdFx0J3wnICtcblx0XHRcdFx0Ly8gZGVjaW1hbCBiaWdpbnRcblx0XHRcdFx0L1xcZCsoPzpfXFxkKykqbi8uc291cmNlICtcblx0XHRcdFx0J3wnICtcblx0XHRcdFx0Ly8gZGVjaW1hbCBudW1iZXIgKGludGVnZXIgb3IgZmxvYXQpIGJ1dCBubyBiaWdpbnRcblx0XHRcdFx0Lyg/OlxcZCsoPzpfXFxkKykqKD86XFwuKD86XFxkKyg/Ol9cXGQrKSopPyk/fFxcLlxcZCsoPzpfXFxkKykqKSg/OltFZV1bKy1dP1xcZCsoPzpfXFxkKykqKT8vLnNvdXJjZVxuXHRcdFx0KSArXG5cdFx0XHQnKScgK1xuXHRcdFx0Lyg/IVtcXHckXSkvLnNvdXJjZVxuXHRcdCksXG5cdFx0bG9va2JlaGluZDogdHJ1ZVxuXHR9LFxuXHQnb3BlcmF0b3InOiAvLS18XFwrXFwrfFxcKlxcKj0/fD0+fCYmPT98XFx8XFx8PT98WyE9XT09fDw8PT98Pj4+Pz0/fFstKyovJSZ8XiE9PD5dPT98XFwuezN9fFxcP1xcPz0/fFxcP1xcLj98W346XS9cbn0pO1xuXG5QcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFsnY2xhc3MtbmFtZSddWzBdLnBhdHRlcm4gPSAvKFxcYig/OmNsYXNzfGV4dGVuZHN8aW1wbGVtZW50c3xpbnN0YW5jZW9mfGludGVyZmFjZXxuZXcpXFxzKylbXFx3LlxcXFxdKy87XG5cblByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2phdmFzY3JpcHQnLCAna2V5d29yZCcsIHtcblx0J3JlZ2V4Jzoge1xuXHRcdHBhdHRlcm46IFJlZ0V4cChcblx0XHRcdC8vIGxvb2tiZWhpbmRcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWdleHAvbm8tZHVwZS1jaGFyYWN0ZXJzLWNoYXJhY3Rlci1jbGFzc1xuXHRcdFx0LygoPzpefFteJFxcd1xceEEwLVxcdUZGRkYuXCInXFxdKVxcc118XFxiKD86cmV0dXJufHlpZWxkKSlcXHMqKS8uc291cmNlICtcblx0XHRcdC8vIFJlZ2V4IHBhdHRlcm46XG5cdFx0XHQvLyBUaGVyZSBhcmUgMiByZWdleCBwYXR0ZXJucyBoZXJlLiBUaGUgUmVnRXhwIHNldCBub3RhdGlvbiBwcm9wb3NhbCBhZGRlZCBzdXBwb3J0IGZvciBuZXN0ZWQgY2hhcmFjdGVyXG5cdFx0XHQvLyBjbGFzc2VzIGlmIHRoZSBgdmAgZmxhZyBpcyBwcmVzZW50LiBVbmZvcnR1bmF0ZWx5LCBuZXN0ZWQgQ0NzIGFyZSBib3RoIGNvbnRleHQtZnJlZSBhbmQgaW5jb21wYXRpYmxlXG5cdFx0XHQvLyB3aXRoIHRoZSBvbmx5IHN5bnRheCwgc28gd2UgaGF2ZSB0byBkZWZpbmUgMiBkaWZmZXJlbnQgcmVnZXggcGF0dGVybnMuXG5cdFx0XHQvXFwvLy5zb3VyY2UgK1xuXHRcdFx0Jyg/OicgK1xuXHRcdFx0Lyg/OlxcWyg/OlteXFxdXFxcXFxcclxcbl18XFxcXC4pKlxcXXxcXFxcLnxbXi9cXFxcXFxbXFxyXFxuXSkrXFwvW2RnaW15dXNdezAsN30vLnNvdXJjZSArXG5cdFx0XHQnfCcgK1xuXHRcdFx0Ly8gYHZgIGZsYWcgc3ludGF4LiBUaGlzIHN1cHBvcnRzIDMgbGV2ZWxzIG9mIG5lc3RlZCBjaGFyYWN0ZXIgY2xhc3Nlcy5cblx0XHRcdC8oPzpcXFsoPzpbXltcXF1cXFxcXFxyXFxuXXxcXFxcLnxcXFsoPzpbXltcXF1cXFxcXFxyXFxuXXxcXFxcLnxcXFsoPzpbXltcXF1cXFxcXFxyXFxuXXxcXFxcLikqXFxdKSpcXF0pKlxcXXxcXFxcLnxbXi9cXFxcXFxbXFxyXFxuXSkrXFwvW2RnaW15dXNdezAsN312W2RnaW15dXNdezAsN30vLnNvdXJjZSArXG5cdFx0XHQnKScgK1xuXHRcdFx0Ly8gbG9va2FoZWFkXG5cdFx0XHQvKD89KD86XFxzfFxcL1xcKig/OlteKl18XFwqKD8hXFwvKSkqXFwqXFwvKSooPzokfFtcXHJcXG4sLjs6fSlcXF1dfFxcL1xcLykpLy5zb3VyY2Vcblx0XHQpLFxuXHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0Z3JlZWR5OiB0cnVlLFxuXHRcdGluc2lkZToge1xuXHRcdFx0J3JlZ2V4LXNvdXJjZSc6IHtcblx0XHRcdFx0cGF0dGVybjogL14oXFwvKVtcXHNcXFNdKyg/PVxcL1thLXpdKiQpLyxcblx0XHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdFx0YWxpYXM6ICdsYW5ndWFnZS1yZWdleCcsXG5cdFx0XHRcdGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLnJlZ2V4XG5cdFx0XHR9LFxuXHRcdFx0J3JlZ2V4LWRlbGltaXRlcic6IC9eXFwvfFxcLyQvLFxuXHRcdFx0J3JlZ2V4LWZsYWdzJzogL15bYS16XSskLyxcblx0XHR9XG5cdH0sXG5cdC8vIFRoaXMgbXVzdCBiZSBkZWNsYXJlZCBiZWZvcmUga2V5d29yZCBiZWNhdXNlIHdlIHVzZSBcImZ1bmN0aW9uXCIgaW5zaWRlIHRoZSBsb29rLWZvcndhcmRcblx0J2Z1bmN0aW9uLXZhcmlhYmxlJzoge1xuXHRcdHBhdHRlcm46IC8jPyg/IVxccylbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSooPz1cXHMqWz06XVxccyooPzphc3luY1xccyopPyg/OlxcYmZ1bmN0aW9uXFxifCg/OlxcKCg/OlteKCldfFxcKFteKCldKlxcKSkqXFwpfCg/IVxccylbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSopXFxzKj0+KSkvLFxuXHRcdGFsaWFzOiAnZnVuY3Rpb24nXG5cdH0sXG5cdCdwYXJhbWV0ZXInOiBbXG5cdFx0e1xuXHRcdFx0cGF0dGVybjogLyhmdW5jdGlvbig/OlxccysoPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqKT9cXHMqXFwoXFxzKikoPyFcXHMpKD86W14oKVxcc118XFxzKyg/IVtcXHMpXSl8XFwoW14oKV0qXFwpKSsoPz1cXHMqXFwpKS8sXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0aW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0cGF0dGVybjogLyhefFteJFxcd1xceEEwLVxcdUZGRkZdKSg/IVxccylbXyRhLXpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSooPz1cXHMqPT4pL2ksXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0aW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0cGF0dGVybjogLyhcXChcXHMqKSg/IVxccykoPzpbXigpXFxzXXxcXHMrKD8hW1xccyldKXxcXChbXigpXSpcXCkpKyg/PVxccypcXClcXHMqPT4pLyxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0XG5cdFx0fSxcblx0XHR7XG5cdFx0XHRwYXR0ZXJuOiAvKCg/OlxcYnxcXHN8XikoPyEoPzphc3xhc3luY3xhd2FpdHxicmVha3xjYXNlfGNhdGNofGNsYXNzfGNvbnN0fGNvbnRpbnVlfGRlYnVnZ2VyfGRlZmF1bHR8ZGVsZXRlfGRvfGVsc2V8ZW51bXxleHBvcnR8ZXh0ZW5kc3xmaW5hbGx5fGZvcnxmcm9tfGZ1bmN0aW9ufGdldHxpZnxpbXBsZW1lbnRzfGltcG9ydHxpbnxpbnN0YW5jZW9mfGludGVyZmFjZXxsZXR8bmV3fG51bGx8b2Z8cGFja2FnZXxwcml2YXRlfHByb3RlY3RlZHxwdWJsaWN8cmV0dXJufHNldHxzdGF0aWN8c3VwZXJ8c3dpdGNofHRoaXN8dGhyb3d8dHJ5fHR5cGVvZnx1bmRlZmluZWR8dmFyfHZvaWR8d2hpbGV8d2l0aHx5aWVsZCkoPyFbJFxcd1xceEEwLVxcdUZGRkZdKSkoPzooPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqXFxzKilcXChcXHMqfFxcXVxccypcXChcXHMqKSg/IVxccykoPzpbXigpXFxzXXxcXHMrKD8hW1xccyldKXxcXChbXigpXSpcXCkpKyg/PVxccypcXClcXHMqXFx7KS8sXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0aW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFxuXHRcdH1cblx0XSxcblx0J2NvbnN0YW50JzogL1xcYltBLVpdKD86W0EtWl9dfFxcZHg/KSpcXGIvXG59KTtcblxuUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnamF2YXNjcmlwdCcsICdzdHJpbmcnLCB7XG5cdCdoYXNoYmFuZyc6IHtcblx0XHRwYXR0ZXJuOiAvXiMhLiovLFxuXHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRhbGlhczogJ2NvbW1lbnQnXG5cdH0sXG5cdCd0ZW1wbGF0ZS1zdHJpbmcnOiB7XG5cdFx0cGF0dGVybjogL2AoPzpcXFxcW1xcc1xcU118XFwkXFx7KD86W157fV18XFx7KD86W157fV18XFx7W159XSpcXH0pKlxcfSkrXFx9fCg/IVxcJFxceylbXlxcXFxgXSkqYC8sXG5cdFx0Z3JlZWR5OiB0cnVlLFxuXHRcdGluc2lkZToge1xuXHRcdFx0J3RlbXBsYXRlLXB1bmN0dWF0aW9uJzoge1xuXHRcdFx0XHRwYXR0ZXJuOiAvXmB8YCQvLFxuXHRcdFx0XHRhbGlhczogJ3N0cmluZydcblx0XHRcdH0sXG5cdFx0XHQnaW50ZXJwb2xhdGlvbic6IHtcblx0XHRcdFx0cGF0dGVybjogLygoPzpefFteXFxcXF0pKD86XFxcXHsyfSkqKVxcJFxceyg/Oltee31dfFxceyg/Oltee31dfFxce1tefV0qXFx9KSpcXH0pK1xcfS8sXG5cdFx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRcdGluc2lkZToge1xuXHRcdFx0XHRcdCdpbnRlcnBvbGF0aW9uLXB1bmN0dWF0aW9uJzoge1xuXHRcdFx0XHRcdFx0cGF0dGVybjogL15cXCRcXHt8XFx9JC8sXG5cdFx0XHRcdFx0XHRhbGlhczogJ3B1bmN0dWF0aW9uJ1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0cmVzdDogUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdCdzdHJpbmcnOiAvW1xcc1xcU10rL1xuXHRcdH1cblx0fSxcblx0J3N0cmluZy1wcm9wZXJ0eSc6IHtcblx0XHRwYXR0ZXJuOiAvKCg/Ol58Wyx7XSlbIFxcdF0qKShbXCInXSkoPzpcXFxcKD86XFxyXFxufFtcXHNcXFNdKXwoPyFcXDIpW15cXFxcXFxyXFxuXSkqXFwyKD89XFxzKjopL20sXG5cdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRncmVlZHk6IHRydWUsXG5cdFx0YWxpYXM6ICdwcm9wZXJ0eSdcblx0fVxufSk7XG5cblByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2phdmFzY3JpcHQnLCAnb3BlcmF0b3InLCB7XG5cdCdsaXRlcmFsLXByb3BlcnR5Jzoge1xuXHRcdHBhdHRlcm46IC8oKD86XnxbLHtdKVsgXFx0XSopKD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKig/PVxccyo6KS9tLFxuXHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0YWxpYXM6ICdwcm9wZXJ0eSdcblx0fSxcbn0pO1xuXG5pZiAoUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cCkge1xuXHRQcmlzbS5sYW5ndWFnZXMubWFya3VwLnRhZy5hZGRJbmxpbmVkKCdzY3JpcHQnLCAnamF2YXNjcmlwdCcpO1xuXG5cdC8vIGFkZCBhdHRyaWJ1dGUgc3VwcG9ydCBmb3IgYWxsIERPTSBldmVudHMuXG5cdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0V2ZW50cyNTdGFuZGFyZF9ldmVudHNcblx0UHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcuYWRkQXR0cmlidXRlKFxuXHRcdC9vbig/OmFib3J0fGJsdXJ8Y2hhbmdlfGNsaWNrfGNvbXBvc2l0aW9uKD86ZW5kfHN0YXJ0fHVwZGF0ZSl8ZGJsY2xpY2t8ZXJyb3J8Zm9jdXMoPzppbnxvdXQpP3xrZXkoPzpkb3dufHVwKXxsb2FkfG1vdXNlKD86ZG93bnxlbnRlcnxsZWF2ZXxtb3ZlfG91dHxvdmVyfHVwKXxyZXNldHxyZXNpemV8c2Nyb2xsfHNlbGVjdHxzbG90Y2hhbmdlfHN1Ym1pdHx1bmxvYWR8d2hlZWwpLy5zb3VyY2UsXG5cdFx0J2phdmFzY3JpcHQnXG5cdCk7XG59XG5cblByaXNtLmxhbmd1YWdlcy5qcyA9IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0O1xuXG5cbi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgQmVnaW4gcHJpc20tZmlsZS1oaWdobGlnaHQuanNcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuKGZ1bmN0aW9uICgpIHtcblxuXHRpZiAodHlwZW9mIFByaXNtID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvbWF0Y2hlcyNQb2x5ZmlsbFxuXHRpZiAoIUVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMpIHtcblx0XHRFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzID0gRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yO1xuXHR9XG5cblx0dmFyIExPQURJTkdfTUVTU0FHRSA9ICdMb2FkaW5n4oCmJztcblx0dmFyIEZBSUxVUkVfTUVTU0FHRSA9IGZ1bmN0aW9uIChzdGF0dXMsIG1lc3NhZ2UpIHtcblx0XHRyZXR1cm4gJ+KcliBFcnJvciAnICsgc3RhdHVzICsgJyB3aGlsZSBmZXRjaGluZyBmaWxlOiAnICsgbWVzc2FnZTtcblx0fTtcblx0dmFyIEZBSUxVUkVfRU1QVFlfTUVTU0FHRSA9ICfinJYgRXJyb3I6IEZpbGUgZG9lcyBub3QgZXhpc3Qgb3IgaXMgZW1wdHknO1xuXG5cdHZhciBFWFRFTlNJT05TID0ge1xuXHRcdCdqcyc6ICdqYXZhc2NyaXB0Jyxcblx0XHQncHknOiAncHl0aG9uJyxcblx0XHQncmInOiAncnVieScsXG5cdFx0J3BzMSc6ICdwb3dlcnNoZWxsJyxcblx0XHQncHNtMSc6ICdwb3dlcnNoZWxsJyxcblx0XHQnc2gnOiAnYmFzaCcsXG5cdFx0J2JhdCc6ICdiYXRjaCcsXG5cdFx0J2gnOiAnYycsXG5cdFx0J3RleCc6ICdsYXRleCdcblx0fTtcblxuXHR2YXIgU1RBVFVTX0FUVFIgPSAnZGF0YS1zcmMtc3RhdHVzJztcblx0dmFyIFNUQVRVU19MT0FESU5HID0gJ2xvYWRpbmcnO1xuXHR2YXIgU1RBVFVTX0xPQURFRCA9ICdsb2FkZWQnO1xuXHR2YXIgU1RBVFVTX0ZBSUxFRCA9ICdmYWlsZWQnO1xuXG5cdHZhciBTRUxFQ1RPUiA9ICdwcmVbZGF0YS1zcmNdOm5vdChbJyArIFNUQVRVU19BVFRSICsgJz1cIicgKyBTVEFUVVNfTE9BREVEICsgJ1wiXSknXG5cdFx0KyAnOm5vdChbJyArIFNUQVRVU19BVFRSICsgJz1cIicgKyBTVEFUVVNfTE9BRElORyArICdcIl0pJztcblxuXHQvKipcblx0ICogTG9hZHMgdGhlIGdpdmVuIGZpbGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgVGhlIFVSTCBvciBwYXRoIG9mIHRoZSBzb3VyY2UgZmlsZSB0byBsb2FkLlxuXHQgKiBAcGFyYW0geyhyZXN1bHQ6IHN0cmluZykgPT4gdm9pZH0gc3VjY2Vzc1xuXHQgKiBAcGFyYW0geyhyZWFzb246IHN0cmluZykgPT4gdm9pZH0gZXJyb3Jcblx0ICovXG5cdGZ1bmN0aW9uIGxvYWRGaWxlKHNyYywgc3VjY2VzcywgZXJyb3IpIHtcblx0XHR2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdFx0eGhyLm9wZW4oJ0dFVCcsIHNyYywgdHJ1ZSk7XG5cdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh4aHIucmVhZHlTdGF0ZSA9PSA0KSB7XG5cdFx0XHRcdGlmICh4aHIuc3RhdHVzIDwgNDAwICYmIHhoci5yZXNwb25zZVRleHQpIHtcblx0XHRcdFx0XHRzdWNjZXNzKHhoci5yZXNwb25zZVRleHQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICh4aHIuc3RhdHVzID49IDQwMCkge1xuXHRcdFx0XHRcdFx0ZXJyb3IoRkFJTFVSRV9NRVNTQUdFKHhoci5zdGF0dXMsIHhoci5zdGF0dXNUZXh0KSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGVycm9yKEZBSUxVUkVfRU1QVFlfTUVTU0FHRSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHR4aHIuc2VuZChudWxsKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBQYXJzZXMgdGhlIGdpdmVuIHJhbmdlLlxuXHQgKlxuXHQgKiBUaGlzIHJldHVybnMgYSByYW5nZSB3aXRoIGluY2x1c2l2ZSBlbmRzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IHJhbmdlXG5cdCAqIEByZXR1cm5zIHtbbnVtYmVyLCBudW1iZXIgfCB1bmRlZmluZWRdIHwgdW5kZWZpbmVkfVxuXHQgKi9cblx0ZnVuY3Rpb24gcGFyc2VSYW5nZShyYW5nZSkge1xuXHRcdHZhciBtID0gL15cXHMqKFxcZCspXFxzKig/OigsKVxccyooPzooXFxkKylcXHMqKT8pPyQvLmV4ZWMocmFuZ2UgfHwgJycpO1xuXHRcdGlmIChtKSB7XG5cdFx0XHR2YXIgc3RhcnQgPSBOdW1iZXIobVsxXSk7XG5cdFx0XHR2YXIgY29tbWEgPSBtWzJdO1xuXHRcdFx0dmFyIGVuZCA9IG1bM107XG5cblx0XHRcdGlmICghY29tbWEpIHtcblx0XHRcdFx0cmV0dXJuIFtzdGFydCwgc3RhcnRdO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFlbmQpIHtcblx0XHRcdFx0cmV0dXJuIFtzdGFydCwgdW5kZWZpbmVkXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBbc3RhcnQsIE51bWJlcihlbmQpXTtcblx0XHR9XG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0fVxuXG5cdFByaXNtLmhvb2tzLmFkZCgnYmVmb3JlLWhpZ2hsaWdodGFsbCcsIGZ1bmN0aW9uIChlbnYpIHtcblx0XHRlbnYuc2VsZWN0b3IgKz0gJywgJyArIFNFTEVDVE9SO1xuXHR9KTtcblxuXHRQcmlzbS5ob29rcy5hZGQoJ2JlZm9yZS1zYW5pdHktY2hlY2snLCBmdW5jdGlvbiAoZW52KSB7XG5cdFx0dmFyIHByZSA9IC8qKiBAdHlwZSB7SFRNTFByZUVsZW1lbnR9ICovIChlbnYuZWxlbWVudCk7XG5cdFx0aWYgKHByZS5tYXRjaGVzKFNFTEVDVE9SKSkge1xuXHRcdFx0ZW52LmNvZGUgPSAnJzsgLy8gZmFzdC1wYXRoIHRoZSB3aG9sZSB0aGluZyBhbmQgZ28gdG8gY29tcGxldGVcblxuXHRcdFx0cHJlLnNldEF0dHJpYnV0ZShTVEFUVVNfQVRUUiwgU1RBVFVTX0xPQURJTkcpOyAvLyBtYXJrIGFzIGxvYWRpbmdcblxuXHRcdFx0Ly8gYWRkIGNvZGUgZWxlbWVudCB3aXRoIGxvYWRpbmcgbWVzc2FnZVxuXHRcdFx0dmFyIGNvZGUgPSBwcmUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnQ09ERScpKTtcblx0XHRcdGNvZGUudGV4dENvbnRlbnQgPSBMT0FESU5HX01FU1NBR0U7XG5cblx0XHRcdHZhciBzcmMgPSBwcmUuZ2V0QXR0cmlidXRlKCdkYXRhLXNyYycpO1xuXG5cdFx0XHR2YXIgbGFuZ3VhZ2UgPSBlbnYubGFuZ3VhZ2U7XG5cdFx0XHRpZiAobGFuZ3VhZ2UgPT09ICdub25lJykge1xuXHRcdFx0XHQvLyB0aGUgbGFuZ3VhZ2UgbWlnaHQgYmUgJ25vbmUnIGJlY2F1c2UgdGhlcmUgaXMgbm8gbGFuZ3VhZ2Ugc2V0O1xuXHRcdFx0XHQvLyBpbiB0aGlzIGNhc2UsIHdlIHdhbnQgdG8gdXNlIHRoZSBleHRlbnNpb24gYXMgdGhlIGxhbmd1YWdlXG5cdFx0XHRcdHZhciBleHRlbnNpb24gPSAoL1xcLihcXHcrKSQvLmV4ZWMoc3JjKSB8fCBbLCAnbm9uZSddKVsxXTtcblx0XHRcdFx0bGFuZ3VhZ2UgPSBFWFRFTlNJT05TW2V4dGVuc2lvbl0gfHwgZXh0ZW5zaW9uO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBzZXQgbGFuZ3VhZ2UgY2xhc3Nlc1xuXHRcdFx0UHJpc20udXRpbC5zZXRMYW5ndWFnZShjb2RlLCBsYW5ndWFnZSk7XG5cdFx0XHRQcmlzbS51dGlsLnNldExhbmd1YWdlKHByZSwgbGFuZ3VhZ2UpO1xuXG5cdFx0XHQvLyBwcmVsb2FkIHRoZSBsYW5ndWFnZVxuXHRcdFx0dmFyIGF1dG9sb2FkZXIgPSBQcmlzbS5wbHVnaW5zLmF1dG9sb2FkZXI7XG5cdFx0XHRpZiAoYXV0b2xvYWRlcikge1xuXHRcdFx0XHRhdXRvbG9hZGVyLmxvYWRMYW5ndWFnZXMobGFuZ3VhZ2UpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBsb2FkIGZpbGVcblx0XHRcdGxvYWRGaWxlKFxuXHRcdFx0XHRzcmMsXG5cdFx0XHRcdGZ1bmN0aW9uICh0ZXh0KSB7XG5cdFx0XHRcdFx0Ly8gbWFyayBhcyBsb2FkZWRcblx0XHRcdFx0XHRwcmUuc2V0QXR0cmlidXRlKFNUQVRVU19BVFRSLCBTVEFUVVNfTE9BREVEKTtcblxuXHRcdFx0XHRcdC8vIGhhbmRsZSBkYXRhLXJhbmdlXG5cdFx0XHRcdFx0dmFyIHJhbmdlID0gcGFyc2VSYW5nZShwcmUuZ2V0QXR0cmlidXRlKCdkYXRhLXJhbmdlJykpO1xuXHRcdFx0XHRcdGlmIChyYW5nZSkge1xuXHRcdFx0XHRcdFx0dmFyIGxpbmVzID0gdGV4dC5zcGxpdCgvXFxyXFxuP3xcXG4vZyk7XG5cblx0XHRcdFx0XHRcdC8vIHRoZSByYW5nZSBpcyBvbmUtYmFzZWQgYW5kIGluY2x1c2l2ZSBvbiBib3RoIGVuZHNcblx0XHRcdFx0XHRcdHZhciBzdGFydCA9IHJhbmdlWzBdO1xuXHRcdFx0XHRcdFx0dmFyIGVuZCA9IHJhbmdlWzFdID09IG51bGwgPyBsaW5lcy5sZW5ndGggOiByYW5nZVsxXTtcblxuXHRcdFx0XHRcdFx0aWYgKHN0YXJ0IDwgMCkgeyBzdGFydCArPSBsaW5lcy5sZW5ndGg7IH1cblx0XHRcdFx0XHRcdHN0YXJ0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oc3RhcnQgLSAxLCBsaW5lcy5sZW5ndGgpKTtcblx0XHRcdFx0XHRcdGlmIChlbmQgPCAwKSB7IGVuZCArPSBsaW5lcy5sZW5ndGg7IH1cblx0XHRcdFx0XHRcdGVuZCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGVuZCwgbGluZXMubGVuZ3RoKSk7XG5cblx0XHRcdFx0XHRcdHRleHQgPSBsaW5lcy5zbGljZShzdGFydCwgZW5kKS5qb2luKCdcXG4nKTtcblxuXHRcdFx0XHRcdFx0Ly8gYWRkIGRhdGEtc3RhcnQgZm9yIGxpbmUgbnVtYmVyc1xuXHRcdFx0XHRcdFx0aWYgKCFwcmUuaGFzQXR0cmlidXRlKCdkYXRhLXN0YXJ0JykpIHtcblx0XHRcdFx0XHRcdFx0cHJlLnNldEF0dHJpYnV0ZSgnZGF0YS1zdGFydCcsIFN0cmluZyhzdGFydCArIDEpKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBoaWdobGlnaHQgY29kZVxuXHRcdFx0XHRcdGNvZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xuXHRcdFx0XHRcdFByaXNtLmhpZ2hsaWdodEVsZW1lbnQoY29kZSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGZ1bmN0aW9uIChlcnJvcikge1xuXHRcdFx0XHRcdC8vIG1hcmsgYXMgZmFpbGVkXG5cdFx0XHRcdFx0cHJlLnNldEF0dHJpYnV0ZShTVEFUVVNfQVRUUiwgU1RBVFVTX0ZBSUxFRCk7XG5cblx0XHRcdFx0XHRjb2RlLnRleHRDb250ZW50ID0gZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cdFx0fVxuXHR9KTtcblxuXHRQcmlzbS5wbHVnaW5zLmZpbGVIaWdobGlnaHQgPSB7XG5cdFx0LyoqXG5cdFx0ICogRXhlY3V0ZXMgdGhlIEZpbGUgSGlnaGxpZ2h0IHBsdWdpbiBmb3IgYWxsIG1hdGNoaW5nIGBwcmVgIGVsZW1lbnRzIHVuZGVyIHRoZSBnaXZlbiBjb250YWluZXIuXG5cdFx0ICpcblx0XHQgKiBOb3RlOiBFbGVtZW50cyB3aGljaCBhcmUgYWxyZWFkeSBsb2FkZWQgb3IgY3VycmVudGx5IGxvYWRpbmcgd2lsbCBub3QgYmUgdG91Y2hlZCBieSB0aGlzIG1ldGhvZC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7UGFyZW50Tm9kZX0gW2NvbnRhaW5lcj1kb2N1bWVudF1cblx0XHQgKi9cblx0XHRoaWdobGlnaHQ6IGZ1bmN0aW9uIGhpZ2hsaWdodChjb250YWluZXIpIHtcblx0XHRcdHZhciBlbGVtZW50cyA9IChjb250YWluZXIgfHwgZG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3JBbGwoU0VMRUNUT1IpO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgZWxlbWVudDsgKGVsZW1lbnQgPSBlbGVtZW50c1tpKytdKTspIHtcblx0XHRcdFx0UHJpc20uaGlnaGxpZ2h0RWxlbWVudChlbGVtZW50KTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0dmFyIGxvZ2dlZCA9IGZhbHNlO1xuXHQvKiogQGRlcHJlY2F0ZWQgVXNlIGBQcmlzbS5wbHVnaW5zLmZpbGVIaWdobGlnaHQuaGlnaGxpZ2h0YCBpbnN0ZWFkLiAqL1xuXHRQcmlzbS5maWxlSGlnaGxpZ2h0ID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICghbG9nZ2VkKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1ByaXNtLmZpbGVIaWdobGlnaHQgaXMgZGVwcmVjYXRlZC4gVXNlIGBQcmlzbS5wbHVnaW5zLmZpbGVIaWdobGlnaHQuaGlnaGxpZ2h0YCBpbnN0ZWFkLicpO1xuXHRcdFx0bG9nZ2VkID0gdHJ1ZTtcblx0XHR9XG5cdFx0UHJpc20ucGx1Z2lucy5maWxlSGlnaGxpZ2h0LmhpZ2hsaWdodC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9O1xuXG59KCkpO1xuIiwiLyoqIVxuKiB0aXBweS5qcyB2Ni4yLjNcbiogKGMpIDIwMTctMjAyMCBhdG9taWtzXG4qIE1JVCBMaWNlbnNlXG4qL1xuaW1wb3J0IHsgY3JlYXRlUG9wcGVyIH0gZnJvbSAnQHBvcHBlcmpzL2NvcmUnO1xuXG52YXIgUk9VTkRfQVJST1cgPSAnPHN2ZyB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiNlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTAgNnMxLjc5Ni0uMDEzIDQuNjctMy42MTVDNS44NTEuOSA2LjkzLjAwNiA4IDBjMS4wNy0uMDA2IDIuMTQ4Ljg4NyAzLjM0MyAyLjM4NUMxNC4yMzMgNi4wMDUgMTYgNiAxNiA2SDB6XCI+PC9zdmc+JztcbnZhciBCT1hfQ0xBU1MgPSBcInRpcHB5LWJveFwiO1xudmFyIENPTlRFTlRfQ0xBU1MgPSBcInRpcHB5LWNvbnRlbnRcIjtcbnZhciBCQUNLRFJPUF9DTEFTUyA9IFwidGlwcHktYmFja2Ryb3BcIjtcbnZhciBBUlJPV19DTEFTUyA9IFwidGlwcHktYXJyb3dcIjtcbnZhciBTVkdfQVJST1dfQ0xBU1MgPSBcInRpcHB5LXN2Zy1hcnJvd1wiO1xudmFyIFRPVUNIX09QVElPTlMgPSB7XG4gIHBhc3NpdmU6IHRydWUsXG4gIGNhcHR1cmU6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwga2V5KSB7XG4gIHJldHVybiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn1cbmZ1bmN0aW9uIGdldFZhbHVlQXRJbmRleE9yUmV0dXJuKHZhbHVlLCBpbmRleCwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciB2ID0gdmFsdWVbaW5kZXhdO1xuICAgIHJldHVybiB2ID09IG51bGwgPyBBcnJheS5pc0FycmF5KGRlZmF1bHRWYWx1ZSkgPyBkZWZhdWx0VmFsdWVbaW5kZXhdIDogZGVmYXVsdFZhbHVlIDogdjtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGlzVHlwZSh2YWx1ZSwgdHlwZSkge1xuICB2YXIgc3RyID0ge30udG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIHJldHVybiBzdHIuaW5kZXhPZignW29iamVjdCcpID09PSAwICYmIHN0ci5pbmRleE9mKHR5cGUgKyBcIl1cIikgPiAtMTtcbn1cbmZ1bmN0aW9uIGludm9rZVdpdGhBcmdzT3JSZXR1cm4odmFsdWUsIGFyZ3MpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLmFwcGx5KHZvaWQgMCwgYXJncykgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGRlYm91bmNlKGZuLCBtcykge1xuICAvLyBBdm9pZCB3cmFwcGluZyBpbiBgc2V0VGltZW91dGAgaWYgbXMgaXMgMCBhbnl3YXlcbiAgaWYgKG1zID09PSAwKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHRpbWVvdXQ7XG4gIHJldHVybiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGZuKGFyZyk7XG4gICAgfSwgbXMpO1xuICB9O1xufVxuZnVuY3Rpb24gcmVtb3ZlUHJvcGVydGllcyhvYmosIGtleXMpIHtcbiAgdmFyIGNsb25lID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqKTtcbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBkZWxldGUgY2xvbmVba2V5XTtcbiAgfSk7XG4gIHJldHVybiBjbG9uZTtcbn1cbmZ1bmN0aW9uIHNwbGl0QnlTcGFjZXModmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnNwbGl0KC9cXHMrLykuZmlsdGVyKEJvb2xlYW4pO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplVG9BcnJheSh2YWx1ZSkge1xuICByZXR1cm4gW10uY29uY2F0KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHB1c2hJZlVuaXF1ZShhcnIsIHZhbHVlKSB7XG4gIGlmIChhcnIuaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgYXJyLnB1c2godmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiB1bmlxdWUoYXJyKSB7XG4gIHJldHVybiBhcnIuZmlsdGVyKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgIHJldHVybiBhcnIuaW5kZXhPZihpdGVtKSA9PT0gaW5kZXg7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xufVxuZnVuY3Rpb24gYXJyYXlGcm9tKHZhbHVlKSB7XG4gIHJldHVybiBbXS5zbGljZS5jYWxsKHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gZGl2KCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuIFsnRWxlbWVudCcsICdGcmFnbWVudCddLnNvbWUoZnVuY3Rpb24gKHR5cGUpIHtcbiAgICByZXR1cm4gaXNUeXBlKHZhbHVlLCB0eXBlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBpc05vZGVMaXN0KHZhbHVlKSB7XG4gIHJldHVybiBpc1R5cGUodmFsdWUsICdOb2RlTGlzdCcpO1xufVxuZnVuY3Rpb24gaXNNb3VzZUV2ZW50KHZhbHVlKSB7XG4gIHJldHVybiBpc1R5cGUodmFsdWUsICdNb3VzZUV2ZW50Jyk7XG59XG5mdW5jdGlvbiBpc1JlZmVyZW5jZUVsZW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl90aXBweSAmJiB2YWx1ZS5fdGlwcHkucmVmZXJlbmNlID09PSB2YWx1ZSk7XG59XG5mdW5jdGlvbiBnZXRBcnJheU9mRWxlbWVudHModmFsdWUpIHtcbiAgaWYgKGlzRWxlbWVudCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gW3ZhbHVlXTtcbiAgfVxuXG4gIGlmIChpc05vZGVMaXN0KHZhbHVlKSkge1xuICAgIHJldHVybiBhcnJheUZyb20odmFsdWUpO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIGFycmF5RnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHZhbHVlKSk7XG59XG5mdW5jdGlvbiBzZXRUcmFuc2l0aW9uRHVyYXRpb24oZWxzLCB2YWx1ZSkge1xuICBlbHMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAoZWwpIHtcbiAgICAgIGVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IHZhbHVlICsgXCJtc1wiO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBzZXRWaXNpYmlsaXR5U3RhdGUoZWxzLCBzdGF0ZSkge1xuICBlbHMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAoZWwpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnZGF0YS1zdGF0ZScsIHN0YXRlKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0T3duZXJEb2N1bWVudChlbGVtZW50T3JFbGVtZW50cykge1xuICB2YXIgX25vcm1hbGl6ZVRvQXJyYXkgPSBub3JtYWxpemVUb0FycmF5KGVsZW1lbnRPckVsZW1lbnRzKSxcbiAgICAgIGVsZW1lbnQgPSBfbm9ybWFsaXplVG9BcnJheVswXTtcblxuICByZXR1cm4gZWxlbWVudCA/IGVsZW1lbnQub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCA6IGRvY3VtZW50O1xufVxuZnVuY3Rpb24gaXNDdXJzb3JPdXRzaWRlSW50ZXJhY3RpdmVCb3JkZXIocG9wcGVyVHJlZURhdGEsIGV2ZW50KSB7XG4gIHZhciBjbGllbnRYID0gZXZlbnQuY2xpZW50WCxcbiAgICAgIGNsaWVudFkgPSBldmVudC5jbGllbnRZO1xuICByZXR1cm4gcG9wcGVyVHJlZURhdGEuZXZlcnkoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgcG9wcGVyUmVjdCA9IF9yZWYucG9wcGVyUmVjdCxcbiAgICAgICAgcG9wcGVyU3RhdGUgPSBfcmVmLnBvcHBlclN0YXRlLFxuICAgICAgICBwcm9wcyA9IF9yZWYucHJvcHM7XG4gICAgdmFyIGludGVyYWN0aXZlQm9yZGVyID0gcHJvcHMuaW50ZXJhY3RpdmVCb3JkZXI7XG4gICAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBvcHBlclN0YXRlLnBsYWNlbWVudCk7XG4gICAgdmFyIG9mZnNldERhdGEgPSBwb3BwZXJTdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldDtcblxuICAgIGlmICghb2Zmc2V0RGF0YSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHRvcERpc3RhbmNlID0gYmFzZVBsYWNlbWVudCA9PT0gJ2JvdHRvbScgPyBvZmZzZXREYXRhLnRvcC55IDogMDtcbiAgICB2YXIgYm90dG9tRGlzdGFuY2UgPSBiYXNlUGxhY2VtZW50ID09PSAndG9wJyA/IG9mZnNldERhdGEuYm90dG9tLnkgOiAwO1xuICAgIHZhciBsZWZ0RGlzdGFuY2UgPSBiYXNlUGxhY2VtZW50ID09PSAncmlnaHQnID8gb2Zmc2V0RGF0YS5sZWZ0LnggOiAwO1xuICAgIHZhciByaWdodERpc3RhbmNlID0gYmFzZVBsYWNlbWVudCA9PT0gJ2xlZnQnID8gb2Zmc2V0RGF0YS5yaWdodC54IDogMDtcbiAgICB2YXIgZXhjZWVkc1RvcCA9IHBvcHBlclJlY3QudG9wIC0gY2xpZW50WSArIHRvcERpc3RhbmNlID4gaW50ZXJhY3RpdmVCb3JkZXI7XG4gICAgdmFyIGV4Y2VlZHNCb3R0b20gPSBjbGllbnRZIC0gcG9wcGVyUmVjdC5ib3R0b20gLSBib3R0b21EaXN0YW5jZSA+IGludGVyYWN0aXZlQm9yZGVyO1xuICAgIHZhciBleGNlZWRzTGVmdCA9IHBvcHBlclJlY3QubGVmdCAtIGNsaWVudFggKyBsZWZ0RGlzdGFuY2UgPiBpbnRlcmFjdGl2ZUJvcmRlcjtcbiAgICB2YXIgZXhjZWVkc1JpZ2h0ID0gY2xpZW50WCAtIHBvcHBlclJlY3QucmlnaHQgLSByaWdodERpc3RhbmNlID4gaW50ZXJhY3RpdmVCb3JkZXI7XG4gICAgcmV0dXJuIGV4Y2VlZHNUb3AgfHwgZXhjZWVkc0JvdHRvbSB8fCBleGNlZWRzTGVmdCB8fCBleGNlZWRzUmlnaHQ7XG4gIH0pO1xufVxuZnVuY3Rpb24gdXBkYXRlVHJhbnNpdGlvbkVuZExpc3RlbmVyKGJveCwgYWN0aW9uLCBsaXN0ZW5lcikge1xuICB2YXIgbWV0aG9kID0gYWN0aW9uICsgXCJFdmVudExpc3RlbmVyXCI7IC8vIHNvbWUgYnJvd3NlcnMgYXBwYXJlbnRseSBzdXBwb3J0IGB0cmFuc2l0aW9uYCAodW5wcmVmaXhlZCkgYnV0IG9ubHkgZmlyZVxuICAvLyBgd2Via2l0VHJhbnNpdGlvbkVuZGAuLi5cblxuICBbJ3RyYW5zaXRpb25lbmQnLCAnd2Via2l0VHJhbnNpdGlvbkVuZCddLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgYm94W21ldGhvZF0oZXZlbnQsIGxpc3RlbmVyKTtcbiAgfSk7XG59XG5cbnZhciBjdXJyZW50SW5wdXQgPSB7XG4gIGlzVG91Y2g6IGZhbHNlXG59O1xudmFyIGxhc3RNb3VzZU1vdmVUaW1lID0gMDtcbi8qKlxuICogV2hlbiBhIGB0b3VjaHN0YXJ0YCBldmVudCBpcyBmaXJlZCwgaXQncyBhc3N1bWVkIHRoZSB1c2VyIGlzIHVzaW5nIHRvdWNoXG4gKiBpbnB1dC4gV2UnbGwgYmluZCBhIGBtb3VzZW1vdmVgIGV2ZW50IGxpc3RlbmVyIHRvIGxpc3RlbiBmb3IgbW91c2UgaW5wdXQgaW5cbiAqIHRoZSBmdXR1cmUuIFRoaXMgd2F5LCB0aGUgYGlzVG91Y2hgIHByb3BlcnR5IGlzIGZ1bGx5IGR5bmFtaWMgYW5kIHdpbGwgaGFuZGxlXG4gKiBoeWJyaWQgZGV2aWNlcyB0aGF0IHVzZSBhIG1peCBvZiB0b3VjaCArIG1vdXNlIGlucHV0LlxuICovXG5cbmZ1bmN0aW9uIG9uRG9jdW1lbnRUb3VjaFN0YXJ0KCkge1xuICBpZiAoY3VycmVudElucHV0LmlzVG91Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjdXJyZW50SW5wdXQuaXNUb3VjaCA9IHRydWU7XG5cbiAgaWYgKHdpbmRvdy5wZXJmb3JtYW5jZSkge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uRG9jdW1lbnRNb3VzZU1vdmUpO1xuICB9XG59XG4vKipcbiAqIFdoZW4gdHdvIGBtb3VzZW1vdmVgIGV2ZW50IGFyZSBmaXJlZCBjb25zZWN1dGl2ZWx5IHdpdGhpbiAyMG1zLCBpdCdzIGFzc3VtZWRcbiAqIHRoZSB1c2VyIGlzIHVzaW5nIG1vdXNlIGlucHV0IGFnYWluLiBgbW91c2Vtb3ZlYCBjYW4gZmlyZSBvbiB0b3VjaCBkZXZpY2VzIGFzXG4gKiB3ZWxsLCBidXQgdmVyeSByYXJlbHkgdGhhdCBxdWlja2x5LlxuICovXG5cbmZ1bmN0aW9uIG9uRG9jdW1lbnRNb3VzZU1vdmUoKSB7XG4gIHZhciBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICBpZiAobm93IC0gbGFzdE1vdXNlTW92ZVRpbWUgPCAyMCkge1xuICAgIGN1cnJlbnRJbnB1dC5pc1RvdWNoID0gZmFsc2U7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Eb2N1bWVudE1vdXNlTW92ZSk7XG4gIH1cblxuICBsYXN0TW91c2VNb3ZlVGltZSA9IG5vdztcbn1cbi8qKlxuICogV2hlbiBhbiBlbGVtZW50IGlzIGluIGZvY3VzIGFuZCBoYXMgYSB0aXBweSwgbGVhdmluZyB0aGUgdGFiL3dpbmRvdyBhbmRcbiAqIHJldHVybmluZyBjYXVzZXMgaXQgdG8gc2hvdyBhZ2Fpbi4gRm9yIG1vdXNlIHVzZXJzIHRoaXMgaXMgdW5leHBlY3RlZCwgYnV0XG4gKiBmb3Iga2V5Ym9hcmQgdXNlIGl0IG1ha2VzIHNlbnNlLlxuICogVE9ETzogZmluZCBhIGJldHRlciB0ZWNobmlxdWUgdG8gc29sdmUgdGhpcyBwcm9ibGVtXG4gKi9cblxuZnVuY3Rpb24gb25XaW5kb3dCbHVyKCkge1xuICB2YXIgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cbiAgaWYgKGlzUmVmZXJlbmNlRWxlbWVudChhY3RpdmVFbGVtZW50KSkge1xuICAgIHZhciBpbnN0YW5jZSA9IGFjdGl2ZUVsZW1lbnQuX3RpcHB5O1xuXG4gICAgaWYgKGFjdGl2ZUVsZW1lbnQuYmx1ciAmJiAhaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICBhY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGJpbmRHbG9iYWxFdmVudExpc3RlbmVycygpIHtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG9uRG9jdW1lbnRUb3VjaFN0YXJ0LCBUT1VDSF9PUFRJT05TKTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBvbldpbmRvd0JsdXIpO1xufVxuXG52YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbnZhciB1YSA9IGlzQnJvd3NlciA/IG5hdmlnYXRvci51c2VyQWdlbnQgOiAnJztcbnZhciBpc0lFID0gL01TSUUgfFRyaWRlbnRcXC8vLnRlc3QodWEpO1xuXG5mdW5jdGlvbiBjcmVhdGVNZW1vcnlMZWFrV2FybmluZyhtZXRob2QpIHtcbiAgdmFyIHR4dCA9IG1ldGhvZCA9PT0gJ2Rlc3Ryb3knID8gJ24gYWxyZWFkeS0nIDogJyAnO1xuICByZXR1cm4gW21ldGhvZCArIFwiKCkgd2FzIGNhbGxlZCBvbiBhXCIgKyB0eHQgKyBcImRlc3Ryb3llZCBpbnN0YW5jZS4gVGhpcyBpcyBhIG5vLW9wIGJ1dFwiLCAnaW5kaWNhdGVzIGEgcG90ZW50aWFsIG1lbW9yeSBsZWFrLiddLmpvaW4oJyAnKTtcbn1cbmZ1bmN0aW9uIGNsZWFuKHZhbHVlKSB7XG4gIHZhciBzcGFjZXNBbmRUYWJzID0gL1sgXFx0XXsyLH0vZztcbiAgdmFyIGxpbmVTdGFydFdpdGhTcGFjZXMgPSAvXlsgXFx0XSovZ207XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKHNwYWNlc0FuZFRhYnMsICcgJykucmVwbGFjZShsaW5lU3RhcnRXaXRoU3BhY2VzLCAnJykudHJpbSgpO1xufVxuXG5mdW5jdGlvbiBnZXREZXZNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIGNsZWFuKFwiXFxuICAlY3RpcHB5LmpzXFxuXFxuICAlY1wiICsgY2xlYW4obWVzc2FnZSkgKyBcIlxcblxcbiAgJWNcXHVEODNEXFx1REM3N1xcdTIwMEQgVGhpcyBpcyBhIGRldmVsb3BtZW50LW9ubHkgbWVzc2FnZS4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHByb2R1Y3Rpb24uXFxuICBcIik7XG59XG5cbmZ1bmN0aW9uIGdldEZvcm1hdHRlZE1lc3NhZ2UobWVzc2FnZSkge1xuICByZXR1cm4gW2dldERldk1lc3NhZ2UobWVzc2FnZSksIC8vIHRpdGxlXG4gICdjb2xvcjogIzAwQzU4NDsgZm9udC1zaXplOiAxLjNlbTsgZm9udC13ZWlnaHQ6IGJvbGQ7JywgLy8gbWVzc2FnZVxuICAnbGluZS1oZWlnaHQ6IDEuNScsIC8vIGZvb3RlclxuICAnY29sb3I6ICNhNmEwOTU7J107XG59IC8vIEFzc3VtZSB3YXJuaW5ncyBhbmQgZXJyb3JzIG5ldmVyIGhhdmUgdGhlIHNhbWUgbWVzc2FnZVxuXG52YXIgdmlzaXRlZE1lc3NhZ2VzO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIHJlc2V0VmlzaXRlZE1lc3NhZ2VzKCk7XG59XG5cbmZ1bmN0aW9uIHJlc2V0VmlzaXRlZE1lc3NhZ2VzKCkge1xuICB2aXNpdGVkTWVzc2FnZXMgPSBuZXcgU2V0KCk7XG59XG5mdW5jdGlvbiB3YXJuV2hlbihjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKGNvbmRpdGlvbiAmJiAhdmlzaXRlZE1lc3NhZ2VzLmhhcyhtZXNzYWdlKSkge1xuICAgIHZhciBfY29uc29sZTtcblxuICAgIHZpc2l0ZWRNZXNzYWdlcy5hZGQobWVzc2FnZSk7XG5cbiAgICAoX2NvbnNvbGUgPSBjb25zb2xlKS53YXJuLmFwcGx5KF9jb25zb2xlLCBnZXRGb3JtYXR0ZWRNZXNzYWdlKG1lc3NhZ2UpKTtcbiAgfVxufVxuZnVuY3Rpb24gZXJyb3JXaGVuKGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoY29uZGl0aW9uICYmICF2aXNpdGVkTWVzc2FnZXMuaGFzKG1lc3NhZ2UpKSB7XG4gICAgdmFyIF9jb25zb2xlMjtcblxuICAgIHZpc2l0ZWRNZXNzYWdlcy5hZGQobWVzc2FnZSk7XG5cbiAgICAoX2NvbnNvbGUyID0gY29uc29sZSkuZXJyb3IuYXBwbHkoX2NvbnNvbGUyLCBnZXRGb3JtYXR0ZWRNZXNzYWdlKG1lc3NhZ2UpKTtcbiAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVUYXJnZXRzKHRhcmdldHMpIHtcbiAgdmFyIGRpZFBhc3NGYWxzeVZhbHVlID0gIXRhcmdldHM7XG4gIHZhciBkaWRQYXNzUGxhaW5PYmplY3QgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGFyZ2V0cykgPT09ICdbb2JqZWN0IE9iamVjdF0nICYmICF0YXJnZXRzLmFkZEV2ZW50TGlzdGVuZXI7XG4gIGVycm9yV2hlbihkaWRQYXNzRmFsc3lWYWx1ZSwgWyd0aXBweSgpIHdhcyBwYXNzZWQnLCAnYCcgKyBTdHJpbmcodGFyZ2V0cykgKyAnYCcsICdhcyBpdHMgdGFyZ2V0cyAoZmlyc3QpIGFyZ3VtZW50LiBWYWxpZCB0eXBlcyBhcmU6IFN0cmluZywgRWxlbWVudCwnLCAnRWxlbWVudFtdLCBvciBOb2RlTGlzdC4nXS5qb2luKCcgJykpO1xuICBlcnJvcldoZW4oZGlkUGFzc1BsYWluT2JqZWN0LCBbJ3RpcHB5KCkgd2FzIHBhc3NlZCBhIHBsYWluIG9iamVjdCB3aGljaCBpcyBub3Qgc3VwcG9ydGVkIGFzIGFuIGFyZ3VtZW50JywgJ2ZvciB2aXJ0dWFsIHBvc2l0aW9uaW5nLiBVc2UgcHJvcHMuZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdCBpbnN0ZWFkLiddLmpvaW4oJyAnKSk7XG59XG5cbnZhciBwbHVnaW5Qcm9wcyA9IHtcbiAgYW5pbWF0ZUZpbGw6IGZhbHNlLFxuICBmb2xsb3dDdXJzb3I6IGZhbHNlLFxuICBpbmxpbmVQb3NpdGlvbmluZzogZmFsc2UsXG4gIHN0aWNreTogZmFsc2Vcbn07XG52YXIgcmVuZGVyUHJvcHMgPSB7XG4gIGFsbG93SFRNTDogZmFsc2UsXG4gIGFuaW1hdGlvbjogJ2ZhZGUnLFxuICBhcnJvdzogdHJ1ZSxcbiAgY29udGVudDogJycsXG4gIGluZXJ0aWE6IGZhbHNlLFxuICBtYXhXaWR0aDogMzUwLFxuICByb2xlOiAndG9vbHRpcCcsXG4gIHRoZW1lOiAnJyxcbiAgekluZGV4OiA5OTk5XG59O1xudmFyIGRlZmF1bHRQcm9wcyA9IE9iamVjdC5hc3NpZ24oe1xuICBhcHBlbmRUbzogZnVuY3Rpb24gYXBwZW5kVG8oKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmJvZHk7XG4gIH0sXG4gIGFyaWE6IHtcbiAgICBjb250ZW50OiAnYXV0bycsXG4gICAgZXhwYW5kZWQ6ICdhdXRvJ1xuICB9LFxuICBkZWxheTogMCxcbiAgZHVyYXRpb246IFszMDAsIDI1MF0sXG4gIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6IG51bGwsXG4gIGhpZGVPbkNsaWNrOiB0cnVlLFxuICBpZ25vcmVBdHRyaWJ1dGVzOiBmYWxzZSxcbiAgaW50ZXJhY3RpdmU6IGZhbHNlLFxuICBpbnRlcmFjdGl2ZUJvcmRlcjogMixcbiAgaW50ZXJhY3RpdmVEZWJvdW5jZTogMCxcbiAgbW92ZVRyYW5zaXRpb246ICcnLFxuICBvZmZzZXQ6IFswLCAxMF0sXG4gIG9uQWZ0ZXJVcGRhdGU6IGZ1bmN0aW9uIG9uQWZ0ZXJVcGRhdGUoKSB7fSxcbiAgb25CZWZvcmVVcGRhdGU6IGZ1bmN0aW9uIG9uQmVmb3JlVXBkYXRlKCkge30sXG4gIG9uQ3JlYXRlOiBmdW5jdGlvbiBvbkNyZWF0ZSgpIHt9LFxuICBvbkRlc3Ryb3k6IGZ1bmN0aW9uIG9uRGVzdHJveSgpIHt9LFxuICBvbkhpZGRlbjogZnVuY3Rpb24gb25IaWRkZW4oKSB7fSxcbiAgb25IaWRlOiBmdW5jdGlvbiBvbkhpZGUoKSB7fSxcbiAgb25Nb3VudDogZnVuY3Rpb24gb25Nb3VudCgpIHt9LFxuICBvblNob3c6IGZ1bmN0aW9uIG9uU2hvdygpIHt9LFxuICBvblNob3duOiBmdW5jdGlvbiBvblNob3duKCkge30sXG4gIG9uVHJpZ2dlcjogZnVuY3Rpb24gb25UcmlnZ2VyKCkge30sXG4gIG9uVW50cmlnZ2VyOiBmdW5jdGlvbiBvblVudHJpZ2dlcigpIHt9LFxuICBvbkNsaWNrT3V0c2lkZTogZnVuY3Rpb24gb25DbGlja091dHNpZGUoKSB7fSxcbiAgcGxhY2VtZW50OiAndG9wJyxcbiAgcGx1Z2luczogW10sXG4gIHBvcHBlck9wdGlvbnM6IHt9LFxuICByZW5kZXI6IG51bGwsXG4gIHNob3dPbkNyZWF0ZTogZmFsc2UsXG4gIHRvdWNoOiB0cnVlLFxuICB0cmlnZ2VyOiAnbW91c2VlbnRlciBmb2N1cycsXG4gIHRyaWdnZXJUYXJnZXQ6IG51bGxcbn0sIHBsdWdpblByb3BzLCB7fSwgcmVuZGVyUHJvcHMpO1xudmFyIGRlZmF1bHRLZXlzID0gT2JqZWN0LmtleXMoZGVmYXVsdFByb3BzKTtcbnZhciBzZXREZWZhdWx0UHJvcHMgPSBmdW5jdGlvbiBzZXREZWZhdWx0UHJvcHMocGFydGlhbFByb3BzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YWxpZGF0ZVByb3BzKHBhcnRpYWxQcm9wcywgW10pO1xuICB9XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwYXJ0aWFsUHJvcHMpO1xuICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGRlZmF1bHRQcm9wc1trZXldID0gcGFydGlhbFByb3BzW2tleV07XG4gIH0pO1xufTtcbmZ1bmN0aW9uIGdldEV4dGVuZGVkUGFzc2VkUHJvcHMocGFzc2VkUHJvcHMpIHtcbiAgdmFyIHBsdWdpbnMgPSBwYXNzZWRQcm9wcy5wbHVnaW5zIHx8IFtdO1xuICB2YXIgcGx1Z2luUHJvcHMgPSBwbHVnaW5zLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbHVnaW4pIHtcbiAgICB2YXIgbmFtZSA9IHBsdWdpbi5uYW1lLFxuICAgICAgICBkZWZhdWx0VmFsdWUgPSBwbHVnaW4uZGVmYXVsdFZhbHVlO1xuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIGFjY1tuYW1lXSA9IHBhc3NlZFByb3BzW25hbWVdICE9PSB1bmRlZmluZWQgPyBwYXNzZWRQcm9wc1tuYW1lXSA6IGRlZmF1bHRWYWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBwYXNzZWRQcm9wcywge30sIHBsdWdpblByb3BzKTtcbn1cbmZ1bmN0aW9uIGdldERhdGFBdHRyaWJ1dGVQcm9wcyhyZWZlcmVuY2UsIHBsdWdpbnMpIHtcbiAgdmFyIHByb3BLZXlzID0gcGx1Z2lucyA/IE9iamVjdC5rZXlzKGdldEV4dGVuZGVkUGFzc2VkUHJvcHMoT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFByb3BzLCB7XG4gICAgcGx1Z2luczogcGx1Z2luc1xuICB9KSkpIDogZGVmYXVsdEtleXM7XG4gIHZhciBwcm9wcyA9IHByb3BLZXlzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICB2YXIgdmFsdWVBc1N0cmluZyA9IChyZWZlcmVuY2UuZ2V0QXR0cmlidXRlKFwiZGF0YS10aXBweS1cIiArIGtleSkgfHwgJycpLnRyaW0oKTtcblxuICAgIGlmICghdmFsdWVBc1N0cmluZykge1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAnY29udGVudCcpIHtcbiAgICAgIGFjY1trZXldID0gdmFsdWVBc1N0cmluZztcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYWNjW2tleV0gPSBKU09OLnBhcnNlKHZhbHVlQXNTdHJpbmcpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBhY2Nba2V5XSA9IHZhbHVlQXNTdHJpbmc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICByZXR1cm4gcHJvcHM7XG59XG5mdW5jdGlvbiBldmFsdWF0ZVByb3BzKHJlZmVyZW5jZSwgcHJvcHMpIHtcbiAgdmFyIG91dCA9IE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgY29udGVudDogaW52b2tlV2l0aEFyZ3NPclJldHVybihwcm9wcy5jb250ZW50LCBbcmVmZXJlbmNlXSlcbiAgfSwgcHJvcHMuaWdub3JlQXR0cmlidXRlcyA/IHt9IDogZ2V0RGF0YUF0dHJpYnV0ZVByb3BzKHJlZmVyZW5jZSwgcHJvcHMucGx1Z2lucykpO1xuICBvdXQuYXJpYSA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQcm9wcy5hcmlhLCB7fSwgb3V0LmFyaWEpO1xuICBvdXQuYXJpYSA9IHtcbiAgICBleHBhbmRlZDogb3V0LmFyaWEuZXhwYW5kZWQgPT09ICdhdXRvJyA/IHByb3BzLmludGVyYWN0aXZlIDogb3V0LmFyaWEuZXhwYW5kZWQsXG4gICAgY29udGVudDogb3V0LmFyaWEuY29udGVudCA9PT0gJ2F1dG8nID8gcHJvcHMuaW50ZXJhY3RpdmUgPyBudWxsIDogJ2Rlc2NyaWJlZGJ5JyA6IG91dC5hcmlhLmNvbnRlbnRcbiAgfTtcbiAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcHMocGFydGlhbFByb3BzLCBwbHVnaW5zKSB7XG4gIGlmIChwYXJ0aWFsUHJvcHMgPT09IHZvaWQgMCkge1xuICAgIHBhcnRpYWxQcm9wcyA9IHt9O1xuICB9XG5cbiAgaWYgKHBsdWdpbnMgPT09IHZvaWQgMCkge1xuICAgIHBsdWdpbnMgPSBbXTtcbiAgfVxuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMocGFydGlhbFByb3BzKTtcbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgdmFyIG5vblBsdWdpblByb3BzID0gcmVtb3ZlUHJvcGVydGllcyhkZWZhdWx0UHJvcHMsIE9iamVjdC5rZXlzKHBsdWdpblByb3BzKSk7XG4gICAgdmFyIGRpZFBhc3NVbmtub3duUHJvcCA9ICFoYXNPd25Qcm9wZXJ0eShub25QbHVnaW5Qcm9wcywgcHJvcCk7IC8vIENoZWNrIGlmIHRoZSBwcm9wIGV4aXN0cyBpbiBgcGx1Z2luc2BcblxuICAgIGlmIChkaWRQYXNzVW5rbm93blByb3ApIHtcbiAgICAgIGRpZFBhc3NVbmtub3duUHJvcCA9IHBsdWdpbnMuZmlsdGVyKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgICAgcmV0dXJuIHBsdWdpbi5uYW1lID09PSBwcm9wO1xuICAgICAgfSkubGVuZ3RoID09PSAwO1xuICAgIH1cblxuICAgIHdhcm5XaGVuKGRpZFBhc3NVbmtub3duUHJvcCwgW1wiYFwiICsgcHJvcCArIFwiYFwiLCBcImlzIG5vdCBhIHZhbGlkIHByb3AuIFlvdSBtYXkgaGF2ZSBzcGVsbGVkIGl0IGluY29ycmVjdGx5LCBvciBpZiBpdCdzXCIsICdhIHBsdWdpbiwgZm9yZ290IHRvIHBhc3MgaXQgaW4gYW4gYXJyYXkgYXMgcHJvcHMucGx1Z2lucy4nLCAnXFxuXFxuJywgJ0FsbCBwcm9wczogaHR0cHM6Ly9hdG9taWtzLmdpdGh1Yi5pby90aXBweWpzL3Y2L2FsbC1wcm9wcy9cXG4nLCAnUGx1Z2luczogaHR0cHM6Ly9hdG9taWtzLmdpdGh1Yi5pby90aXBweWpzL3Y2L3BsdWdpbnMvJ10uam9pbignICcpKTtcbiAgfSk7XG59XG5cbnZhciBpbm5lckhUTUwgPSBmdW5jdGlvbiBpbm5lckhUTUwoKSB7XG4gIHJldHVybiAnaW5uZXJIVE1MJztcbn07XG5cbmZ1bmN0aW9uIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKGVsZW1lbnQsIGh0bWwpIHtcbiAgZWxlbWVudFtpbm5lckhUTUwoKV0gPSBodG1sO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBcnJvd0VsZW1lbnQodmFsdWUpIHtcbiAgdmFyIGFycm93ID0gZGl2KCk7XG5cbiAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgYXJyb3cuY2xhc3NOYW1lID0gQVJST1dfQ0xBU1M7XG4gIH0gZWxzZSB7XG4gICAgYXJyb3cuY2xhc3NOYW1lID0gU1ZHX0FSUk9XX0NMQVNTO1xuXG4gICAgaWYgKGlzRWxlbWVudCh2YWx1ZSkpIHtcbiAgICAgIGFycm93LmFwcGVuZENoaWxkKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwoYXJyb3csIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXJyb3c7XG59XG5cbmZ1bmN0aW9uIHNldENvbnRlbnQoY29udGVudCwgcHJvcHMpIHtcbiAgaWYgKGlzRWxlbWVudChwcm9wcy5jb250ZW50KSkge1xuICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKGNvbnRlbnQsICcnKTtcbiAgICBjb250ZW50LmFwcGVuZENoaWxkKHByb3BzLmNvbnRlbnQpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9wcy5jb250ZW50ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHByb3BzLmFsbG93SFRNTCkge1xuICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwoY29udGVudCwgcHJvcHMuY29udGVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRlbnQudGV4dENvbnRlbnQgPSBwcm9wcy5jb250ZW50O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0Q2hpbGRyZW4ocG9wcGVyKSB7XG4gIHZhciBib3ggPSBwb3BwZXIuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gIHZhciBib3hDaGlsZHJlbiA9IGFycmF5RnJvbShib3guY2hpbGRyZW4pO1xuICByZXR1cm4ge1xuICAgIGJveDogYm94LFxuICAgIGNvbnRlbnQ6IGJveENoaWxkcmVuLmZpbmQoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLmNsYXNzTGlzdC5jb250YWlucyhDT05URU5UX0NMQVNTKTtcbiAgICB9KSxcbiAgICBhcnJvdzogYm94Q2hpbGRyZW4uZmluZChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKEFSUk9XX0NMQVNTKSB8fCBub2RlLmNsYXNzTGlzdC5jb250YWlucyhTVkdfQVJST1dfQ0xBU1MpO1xuICAgIH0pLFxuICAgIGJhY2tkcm9wOiBib3hDaGlsZHJlbi5maW5kKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5jbGFzc0xpc3QuY29udGFpbnMoQkFDS0RST1BfQ0xBU1MpO1xuICAgIH0pXG4gIH07XG59XG5mdW5jdGlvbiByZW5kZXIoaW5zdGFuY2UpIHtcbiAgdmFyIHBvcHBlciA9IGRpdigpO1xuICB2YXIgYm94ID0gZGl2KCk7XG4gIGJveC5jbGFzc05hbWUgPSBCT1hfQ0xBU1M7XG4gIGJveC5zZXRBdHRyaWJ1dGUoJ2RhdGEtc3RhdGUnLCAnaGlkZGVuJyk7XG4gIGJveC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gIHZhciBjb250ZW50ID0gZGl2KCk7XG4gIGNvbnRlbnQuY2xhc3NOYW1lID0gQ09OVEVOVF9DTEFTUztcbiAgY29udGVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtc3RhdGUnLCAnaGlkZGVuJyk7XG4gIHNldENvbnRlbnQoY29udGVudCwgaW5zdGFuY2UucHJvcHMpO1xuICBwb3BwZXIuYXBwZW5kQ2hpbGQoYm94KTtcbiAgYm94LmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICBvblVwZGF0ZShpbnN0YW5jZS5wcm9wcywgaW5zdGFuY2UucHJvcHMpO1xuXG4gIGZ1bmN0aW9uIG9uVXBkYXRlKHByZXZQcm9wcywgbmV4dFByb3BzKSB7XG4gICAgdmFyIF9nZXRDaGlsZHJlbiA9IGdldENoaWxkcmVuKHBvcHBlciksXG4gICAgICAgIGJveCA9IF9nZXRDaGlsZHJlbi5ib3gsXG4gICAgICAgIGNvbnRlbnQgPSBfZ2V0Q2hpbGRyZW4uY29udGVudCxcbiAgICAgICAgYXJyb3cgPSBfZ2V0Q2hpbGRyZW4uYXJyb3c7XG5cbiAgICBpZiAobmV4dFByb3BzLnRoZW1lKSB7XG4gICAgICBib3guc2V0QXR0cmlidXRlKCdkYXRhLXRoZW1lJywgbmV4dFByb3BzLnRoZW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm94LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS10aGVtZScpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV4dFByb3BzLmFuaW1hdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJveC5zZXRBdHRyaWJ1dGUoJ2RhdGEtYW5pbWF0aW9uJywgbmV4dFByb3BzLmFuaW1hdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJveC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtYW5pbWF0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKG5leHRQcm9wcy5pbmVydGlhKSB7XG4gICAgICBib3guc2V0QXR0cmlidXRlKCdkYXRhLWluZXJ0aWEnLCAnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJveC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtaW5lcnRpYScpO1xuICAgIH1cblxuICAgIGJveC5zdHlsZS5tYXhXaWR0aCA9IHR5cGVvZiBuZXh0UHJvcHMubWF4V2lkdGggPT09ICdudW1iZXInID8gbmV4dFByb3BzLm1heFdpZHRoICsgXCJweFwiIDogbmV4dFByb3BzLm1heFdpZHRoO1xuXG4gICAgaWYgKG5leHRQcm9wcy5yb2xlKSB7XG4gICAgICBib3guc2V0QXR0cmlidXRlKCdyb2xlJywgbmV4dFByb3BzLnJvbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3gucmVtb3ZlQXR0cmlidXRlKCdyb2xlJyk7XG4gICAgfVxuXG4gICAgaWYgKHByZXZQcm9wcy5jb250ZW50ICE9PSBuZXh0UHJvcHMuY29udGVudCB8fCBwcmV2UHJvcHMuYWxsb3dIVE1MICE9PSBuZXh0UHJvcHMuYWxsb3dIVE1MKSB7XG4gICAgICBzZXRDb250ZW50KGNvbnRlbnQsIGluc3RhbmNlLnByb3BzKTtcbiAgICB9XG5cbiAgICBpZiAobmV4dFByb3BzLmFycm93KSB7XG4gICAgICBpZiAoIWFycm93KSB7XG4gICAgICAgIGJveC5hcHBlbmRDaGlsZChjcmVhdGVBcnJvd0VsZW1lbnQobmV4dFByb3BzLmFycm93KSk7XG4gICAgICB9IGVsc2UgaWYgKHByZXZQcm9wcy5hcnJvdyAhPT0gbmV4dFByb3BzLmFycm93KSB7XG4gICAgICAgIGJveC5yZW1vdmVDaGlsZChhcnJvdyk7XG4gICAgICAgIGJveC5hcHBlbmRDaGlsZChjcmVhdGVBcnJvd0VsZW1lbnQobmV4dFByb3BzLmFycm93KSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhcnJvdykge1xuICAgICAgYm94LnJlbW92ZUNoaWxkKGFycm93KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBvcHBlcjogcG9wcGVyLFxuICAgIG9uVXBkYXRlOiBvblVwZGF0ZVxuICB9O1xufSAvLyBSdW50aW1lIGNoZWNrIHRvIGlkZW50aWZ5IGlmIHRoZSByZW5kZXIgZnVuY3Rpb24gaXMgdGhlIGRlZmF1bHQgb25lOyB0aGlzXG4vLyB3YXkgd2UgY2FuIGFwcGx5IGRlZmF1bHQgQ1NTIHRyYW5zaXRpb25zIGxvZ2ljIGFuZCBpdCBjYW4gYmUgdHJlZS1zaGFrZW4gYXdheVxuXG5yZW5kZXIuJCR0aXBweSA9IHRydWU7XG5cbnZhciBpZENvdW50ZXIgPSAxO1xudmFyIG1vdXNlTW92ZUxpc3RlbmVycyA9IFtdOyAvLyBVc2VkIGJ5IGBoaWRlQWxsKClgXG5cbnZhciBtb3VudGVkSW5zdGFuY2VzID0gW107XG5mdW5jdGlvbiBjcmVhdGVUaXBweShyZWZlcmVuY2UsIHBhc3NlZFByb3BzKSB7XG4gIHZhciBwcm9wcyA9IGV2YWx1YXRlUHJvcHMocmVmZXJlbmNlLCBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UHJvcHMsIHt9LCBnZXRFeHRlbmRlZFBhc3NlZFByb3BzKHBhc3NlZFByb3BzKSkpOyAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8g8J+UkiBQcml2YXRlIG1lbWJlcnNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIHNob3dUaW1lb3V0O1xuICB2YXIgaGlkZVRpbWVvdXQ7XG4gIHZhciBzY2hlZHVsZUhpZGVBbmltYXRpb25GcmFtZTtcbiAgdmFyIGlzVmlzaWJsZUZyb21DbGljayA9IGZhbHNlO1xuICB2YXIgZGlkSGlkZUR1ZVRvRG9jdW1lbnRNb3VzZURvd24gPSBmYWxzZTtcbiAgdmFyIGRpZFRvdWNoTW92ZSA9IGZhbHNlO1xuICB2YXIgaWdub3JlT25GaXJzdFVwZGF0ZSA9IGZhbHNlO1xuICB2YXIgbGFzdFRyaWdnZXJFdmVudDtcbiAgdmFyIGN1cnJlbnRUcmFuc2l0aW9uRW5kTGlzdGVuZXI7XG4gIHZhciBvbkZpcnN0VXBkYXRlO1xuICB2YXIgbGlzdGVuZXJzID0gW107XG4gIHZhciBkZWJvdW5jZWRPbk1vdXNlTW92ZSA9IGRlYm91bmNlKG9uTW91c2VNb3ZlLCBwcm9wcy5pbnRlcmFjdGl2ZURlYm91bmNlKTtcbiAgdmFyIGN1cnJlbnRUYXJnZXQ7XG4gIHZhciBkb2MgPSBnZXRPd25lckRvY3VtZW50KHByb3BzLnRyaWdnZXJUYXJnZXQgfHwgcmVmZXJlbmNlKTsgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIPCflJEgUHVibGljIG1lbWJlcnNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIGlkID0gaWRDb3VudGVyKys7XG4gIHZhciBwb3BwZXJJbnN0YW5jZSA9IG51bGw7XG4gIHZhciBwbHVnaW5zID0gdW5pcXVlKHByb3BzLnBsdWdpbnMpO1xuICB2YXIgc3RhdGUgPSB7XG4gICAgLy8gSXMgdGhlIGluc3RhbmNlIGN1cnJlbnRseSBlbmFibGVkP1xuICAgIGlzRW5hYmxlZDogdHJ1ZSxcbiAgICAvLyBJcyB0aGUgdGlwcHkgY3VycmVudGx5IHNob3dpbmcgYW5kIG5vdCB0cmFuc2l0aW9uaW5nIG91dD9cbiAgICBpc1Zpc2libGU6IGZhbHNlLFxuICAgIC8vIEhhcyB0aGUgaW5zdGFuY2UgYmVlbiBkZXN0cm95ZWQ/XG4gICAgaXNEZXN0cm95ZWQ6IGZhbHNlLFxuICAgIC8vIElzIHRoZSB0aXBweSBjdXJyZW50bHkgbW91bnRlZCB0byB0aGUgRE9NP1xuICAgIGlzTW91bnRlZDogZmFsc2UsXG4gICAgLy8gSGFzIHRoZSB0aXBweSBmaW5pc2hlZCB0cmFuc2l0aW9uaW5nIGluP1xuICAgIGlzU2hvd246IGZhbHNlXG4gIH07XG4gIHZhciBpbnN0YW5jZSA9IHtcbiAgICAvLyBwcm9wZXJ0aWVzXG4gICAgaWQ6IGlkLFxuICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlLFxuICAgIHBvcHBlcjogZGl2KCksXG4gICAgcG9wcGVySW5zdGFuY2U6IHBvcHBlckluc3RhbmNlLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICBzdGF0ZTogc3RhdGUsXG4gICAgcGx1Z2luczogcGx1Z2lucyxcbiAgICAvLyBtZXRob2RzXG4gICAgY2xlYXJEZWxheVRpbWVvdXRzOiBjbGVhckRlbGF5VGltZW91dHMsXG4gICAgc2V0UHJvcHM6IHNldFByb3BzLFxuICAgIHNldENvbnRlbnQ6IHNldENvbnRlbnQsXG4gICAgc2hvdzogc2hvdyxcbiAgICBoaWRlOiBoaWRlLFxuICAgIGhpZGVXaXRoSW50ZXJhY3Rpdml0eTogaGlkZVdpdGhJbnRlcmFjdGl2aXR5LFxuICAgIGVuYWJsZTogZW5hYmxlLFxuICAgIGRpc2FibGU6IGRpc2FibGUsXG4gICAgdW5tb3VudDogdW5tb3VudCxcbiAgICBkZXN0cm95OiBkZXN0cm95XG4gIH07IC8vIFRPRE86IEludmVzdGlnYXRlIHdoeSB0aGlzIGVhcmx5IHJldHVybiBjYXVzZXMgYSBURFogZXJyb3IgaW4gdGhlIHRlc3RzIOKAlFxuICAvLyBpdCBkb2Vzbid0IHNlZW0gdG8gaGFwcGVuIGluIHRoZSBicm93c2VyXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cbiAgaWYgKCFwcm9wcy5yZW5kZXIpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBlcnJvcldoZW4odHJ1ZSwgJ3JlbmRlcigpIGZ1bmN0aW9uIGhhcyBub3QgYmVlbiBzdXBwbGllZC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIEluaXRpYWwgbXV0YXRpb25zXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgdmFyIF9wcm9wcyRyZW5kZXIgPSBwcm9wcy5yZW5kZXIoaW5zdGFuY2UpLFxuICAgICAgcG9wcGVyID0gX3Byb3BzJHJlbmRlci5wb3BwZXIsXG4gICAgICBvblVwZGF0ZSA9IF9wcm9wcyRyZW5kZXIub25VcGRhdGU7XG5cbiAgcG9wcGVyLnNldEF0dHJpYnV0ZSgnZGF0YS10aXBweS1yb290JywgJycpO1xuICBwb3BwZXIuaWQgPSBcInRpcHB5LVwiICsgaW5zdGFuY2UuaWQ7XG4gIGluc3RhbmNlLnBvcHBlciA9IHBvcHBlcjtcbiAgcmVmZXJlbmNlLl90aXBweSA9IGluc3RhbmNlO1xuICBwb3BwZXIuX3RpcHB5ID0gaW5zdGFuY2U7XG4gIHZhciBwbHVnaW5zSG9va3MgPSBwbHVnaW5zLm1hcChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgcmV0dXJuIHBsdWdpbi5mbihpbnN0YW5jZSk7XG4gIH0pO1xuICB2YXIgaGFzQXJpYUV4cGFuZGVkID0gcmVmZXJlbmNlLmhhc0F0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcpO1xuICBhZGRMaXN0ZW5lcnMoKTtcbiAgaGFuZGxlQXJpYUV4cGFuZGVkQXR0cmlidXRlKCk7XG4gIGhhbmRsZVN0eWxlcygpO1xuICBpbnZva2VIb29rKCdvbkNyZWF0ZScsIFtpbnN0YW5jZV0pO1xuXG4gIGlmIChwcm9wcy5zaG93T25DcmVhdGUpIHtcbiAgICBzY2hlZHVsZVNob3coKTtcbiAgfSAvLyBQcmV2ZW50IGEgdGlwcHkgd2l0aCBhIGRlbGF5IGZyb20gaGlkaW5nIGlmIHRoZSBjdXJzb3IgbGVmdCB0aGVuIHJldHVybmVkXG4gIC8vIGJlZm9yZSBpdCBzdGFydGVkIGhpZGluZ1xuXG5cbiAgcG9wcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlICYmIGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSkge1xuICAgICAgaW5zdGFuY2UuY2xlYXJEZWxheVRpbWVvdXRzKCk7XG4gICAgfVxuICB9KTtcbiAgcG9wcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUgJiYgaW5zdGFuY2UucHJvcHMudHJpZ2dlci5pbmRleE9mKCdtb3VzZWVudGVyJykgPj0gMCkge1xuICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGRlYm91bmNlZE9uTW91c2VNb3ZlKTtcbiAgICAgIGRlYm91bmNlZE9uTW91c2VNb3ZlKGV2ZW50KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gaW5zdGFuY2U7IC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyDwn5SSIFByaXZhdGUgbWV0aG9kc1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBnZXROb3JtYWxpemVkVG91Y2hTZXR0aW5ncygpIHtcbiAgICB2YXIgdG91Y2ggPSBpbnN0YW5jZS5wcm9wcy50b3VjaDtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0b3VjaCkgPyB0b3VjaCA6IFt0b3VjaCwgMF07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJc0N1c3RvbVRvdWNoQmVoYXZpb3IoKSB7XG4gICAgcmV0dXJuIGdldE5vcm1hbGl6ZWRUb3VjaFNldHRpbmdzKClbMF0gPT09ICdob2xkJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldElzRGVmYXVsdFJlbmRlckZuKCkge1xuICAgIHZhciBfaW5zdGFuY2UkcHJvcHMkcmVuZGU7XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuICEhKChfaW5zdGFuY2UkcHJvcHMkcmVuZGUgPSBpbnN0YW5jZS5wcm9wcy5yZW5kZXIpID09IG51bGwgPyB2b2lkIDAgOiBfaW5zdGFuY2UkcHJvcHMkcmVuZGUuJCR0aXBweSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDdXJyZW50VGFyZ2V0KCkge1xuICAgIHJldHVybiBjdXJyZW50VGFyZ2V0IHx8IHJlZmVyZW5jZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERlZmF1bHRUZW1wbGF0ZUNoaWxkcmVuKCkge1xuICAgIHJldHVybiBnZXRDaGlsZHJlbihwb3BwZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RGVsYXkoaXNTaG93KSB7XG4gICAgLy8gRm9yIHRvdWNoIG9yIGtleWJvYXJkIGlucHV0LCBmb3JjZSBgMGAgZGVsYXkgZm9yIFVYIHJlYXNvbnNcbiAgICAvLyBBbHNvIGlmIHRoZSBpbnN0YW5jZSBpcyBtb3VudGVkIGJ1dCBub3QgdmlzaWJsZSAodHJhbnNpdGlvbmluZyBvdXQpLFxuICAgIC8vIGlnbm9yZSBkZWxheVxuICAgIGlmIChpbnN0YW5jZS5zdGF0ZS5pc01vdW50ZWQgJiYgIWluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSB8fCBjdXJyZW50SW5wdXQuaXNUb3VjaCB8fCBsYXN0VHJpZ2dlckV2ZW50ICYmIGxhc3RUcmlnZ2VyRXZlbnQudHlwZSA9PT0gJ2ZvY3VzJykge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldFZhbHVlQXRJbmRleE9yUmV0dXJuKGluc3RhbmNlLnByb3BzLmRlbGF5LCBpc1Nob3cgPyAwIDogMSwgZGVmYXVsdFByb3BzLmRlbGF5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVN0eWxlcygpIHtcbiAgICBwb3BwZXIuc3R5bGUucG9pbnRlckV2ZW50cyA9IGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlICYmIGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSA/ICcnIDogJ25vbmUnO1xuICAgIHBvcHBlci5zdHlsZS56SW5kZXggPSBcIlwiICsgaW5zdGFuY2UucHJvcHMuekluZGV4O1xuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlSG9vayhob29rLCBhcmdzLCBzaG91bGRJbnZva2VQcm9wc0hvb2spIHtcbiAgICBpZiAoc2hvdWxkSW52b2tlUHJvcHNIb29rID09PSB2b2lkIDApIHtcbiAgICAgIHNob3VsZEludm9rZVByb3BzSG9vayA9IHRydWU7XG4gICAgfVxuXG4gICAgcGx1Z2luc0hvb2tzLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbkhvb2tzKSB7XG4gICAgICBpZiAocGx1Z2luSG9va3NbaG9va10pIHtcbiAgICAgICAgcGx1Z2luSG9va3NbaG9va10uYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChzaG91bGRJbnZva2VQcm9wc0hvb2spIHtcbiAgICAgIHZhciBfaW5zdGFuY2UkcHJvcHM7XG5cbiAgICAgIChfaW5zdGFuY2UkcHJvcHMgPSBpbnN0YW5jZS5wcm9wcylbaG9va10uYXBwbHkoX2luc3RhbmNlJHByb3BzLCBhcmdzKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVBcmlhQ29udGVudEF0dHJpYnV0ZSgpIHtcbiAgICB2YXIgYXJpYSA9IGluc3RhbmNlLnByb3BzLmFyaWE7XG5cbiAgICBpZiAoIWFyaWEuY29udGVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhdHRyID0gXCJhcmlhLVwiICsgYXJpYS5jb250ZW50O1xuICAgIHZhciBpZCA9IHBvcHBlci5pZDtcbiAgICB2YXIgbm9kZXMgPSBub3JtYWxpemVUb0FycmF5KGluc3RhbmNlLnByb3BzLnRyaWdnZXJUYXJnZXQgfHwgcmVmZXJlbmNlKTtcbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICB2YXIgY3VycmVudFZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cik7XG5cbiAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0ciwgY3VycmVudFZhbHVlID8gY3VycmVudFZhbHVlICsgXCIgXCIgKyBpZCA6IGlkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBuZXh0VmFsdWUgPSBjdXJyZW50VmFsdWUgJiYgY3VycmVudFZhbHVlLnJlcGxhY2UoaWQsICcnKS50cmltKCk7XG5cbiAgICAgICAgaWYgKG5leHRWYWx1ZSkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHIsIG5leHRWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUFyaWFFeHBhbmRlZEF0dHJpYnV0ZSgpIHtcbiAgICBpZiAoaGFzQXJpYUV4cGFuZGVkIHx8ICFpbnN0YW5jZS5wcm9wcy5hcmlhLmV4cGFuZGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5vZGVzID0gbm9ybWFsaXplVG9BcnJheShpbnN0YW5jZS5wcm9wcy50cmlnZ2VyVGFyZ2V0IHx8IHJlZmVyZW5jZSk7XG4gICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgaWYgKGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlICYmIG5vZGUgPT09IGdldEN1cnJlbnRUYXJnZXQoKSA/ICd0cnVlJyA6ICdmYWxzZScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFudXBJbnRlcmFjdGl2ZU1vdXNlTGlzdGVuZXJzKCkge1xuICAgIGRvYy5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBzY2hlZHVsZUhpZGUpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBkZWJvdW5jZWRPbk1vdXNlTW92ZSk7XG4gICAgbW91c2VNb3ZlTGlzdGVuZXJzID0gbW91c2VNb3ZlTGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBsaXN0ZW5lciAhPT0gZGVib3VuY2VkT25Nb3VzZU1vdmU7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkRvY3VtZW50UHJlc3MoZXZlbnQpIHtcbiAgICAvLyBNb3ZlZCBmaW5nZXIgdG8gc2Nyb2xsIGluc3RlYWQgb2YgYW4gaW50ZW50aW9uYWwgdGFwIG91dHNpZGVcbiAgICBpZiAoY3VycmVudElucHV0LmlzVG91Y2gpIHtcbiAgICAgIGlmIChkaWRUb3VjaE1vdmUgfHwgZXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bicpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gLy8gQ2xpY2tlZCBvbiBpbnRlcmFjdGl2ZSBwb3BwZXJcblxuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlICYmIHBvcHBlci5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBDbGlja2VkIG9uIHRoZSBldmVudCBsaXN0ZW5lcnMgdGFyZ2V0XG5cblxuICAgIGlmIChnZXRDdXJyZW50VGFyZ2V0KCkuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgaWYgKGN1cnJlbnRJbnB1dC5pc1RvdWNoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSAmJiBpbnN0YW5jZS5wcm9wcy50cmlnZ2VyLmluZGV4T2YoJ2NsaWNrJykgPj0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGludm9rZUhvb2soJ29uQ2xpY2tPdXRzaWRlJywgW2luc3RhbmNlLCBldmVudF0pO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5wcm9wcy5oaWRlT25DbGljayA9PT0gdHJ1ZSkge1xuICAgICAgaXNWaXNpYmxlRnJvbUNsaWNrID0gZmFsc2U7XG4gICAgICBpbnN0YW5jZS5jbGVhckRlbGF5VGltZW91dHMoKTtcbiAgICAgIGluc3RhbmNlLmhpZGUoKTsgLy8gYG1vdXNlZG93bmAgZXZlbnQgaXMgZmlyZWQgcmlnaHQgYmVmb3JlIGBmb2N1c2AgaWYgcHJlc3NpbmcgdGhlXG4gICAgICAvLyBjdXJyZW50VGFyZ2V0LiBUaGlzIGxldHMgYSB0aXBweSB3aXRoIGBmb2N1c2AgdHJpZ2dlciBrbm93IHRoYXQgaXRcbiAgICAgIC8vIHNob3VsZCBub3Qgc2hvd1xuXG4gICAgICBkaWRIaWRlRHVlVG9Eb2N1bWVudE1vdXNlRG93biA9IHRydWU7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGlkSGlkZUR1ZVRvRG9jdW1lbnRNb3VzZURvd24gPSBmYWxzZTtcbiAgICAgIH0pOyAvLyBUaGUgbGlzdGVuZXIgZ2V0cyBhZGRlZCBpbiBgc2NoZWR1bGVTaG93KClgLCBidXQgdGhpcyBtYXkgYmUgaGlkaW5nIGl0XG4gICAgICAvLyBiZWZvcmUgaXQgc2hvd3MsIGFuZCBoaWRlKCkncyBlYXJseSBiYWlsLW91dCBiZWhhdmlvciBjYW4gcHJldmVudCBpdFxuICAgICAgLy8gZnJvbSBiZWluZyBjbGVhbmVkIHVwXG5cbiAgICAgIGlmICghaW5zdGFuY2Uuc3RhdGUuaXNNb3VudGVkKSB7XG4gICAgICAgIHJlbW92ZURvY3VtZW50UHJlc3MoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvblRvdWNoTW92ZSgpIHtcbiAgICBkaWRUb3VjaE1vdmUgPSB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KCkge1xuICAgIGRpZFRvdWNoTW92ZSA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkRG9jdW1lbnRQcmVzcygpIHtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgb25Eb2N1bWVudFByZXNzLCB0cnVlKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvbkRvY3VtZW50UHJlc3MsIFRPVUNIX09QVElPTlMpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb25Ub3VjaFN0YXJ0LCBUT1VDSF9PUFRJT05TKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25Ub3VjaE1vdmUsIFRPVUNIX09QVElPTlMpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlRG9jdW1lbnRQcmVzcygpIHtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgb25Eb2N1bWVudFByZXNzLCB0cnVlKTtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvbkRvY3VtZW50UHJlc3MsIFRPVUNIX09QVElPTlMpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb25Ub3VjaFN0YXJ0LCBUT1VDSF9PUFRJT05TKTtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25Ub3VjaE1vdmUsIFRPVUNIX09QVElPTlMpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25UcmFuc2l0aW9uZWRPdXQoZHVyYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgb25UcmFuc2l0aW9uRW5kKGR1cmF0aW9uLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIWluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSAmJiBwb3BwZXIucGFyZW50Tm9kZSAmJiBwb3BwZXIucGFyZW50Tm9kZS5jb250YWlucyhwb3BwZXIpKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBvblRyYW5zaXRpb25lZEluKGR1cmF0aW9uLCBjYWxsYmFjaykge1xuICAgIG9uVHJhbnNpdGlvbkVuZChkdXJhdGlvbiwgY2FsbGJhY2spO1xuICB9XG5cbiAgZnVuY3Rpb24gb25UcmFuc2l0aW9uRW5kKGR1cmF0aW9uLCBjYWxsYmFjaykge1xuICAgIHZhciBib3ggPSBnZXREZWZhdWx0VGVtcGxhdGVDaGlsZHJlbigpLmJveDtcblxuICAgIGZ1bmN0aW9uIGxpc3RlbmVyKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSBib3gpIHtcbiAgICAgICAgdXBkYXRlVHJhbnNpdGlvbkVuZExpc3RlbmVyKGJveCwgJ3JlbW92ZScsIGxpc3RlbmVyKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9IC8vIE1ha2UgY2FsbGJhY2sgc3luY2hyb25vdXMgaWYgZHVyYXRpb24gaXMgMFxuICAgIC8vIGB0cmFuc2l0aW9uZW5kYCB3b24ndCBmaXJlIG90aGVyd2lzZVxuXG5cbiAgICBpZiAoZHVyYXRpb24gPT09IDApIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIHVwZGF0ZVRyYW5zaXRpb25FbmRMaXN0ZW5lcihib3gsICdyZW1vdmUnLCBjdXJyZW50VHJhbnNpdGlvbkVuZExpc3RlbmVyKTtcbiAgICB1cGRhdGVUcmFuc2l0aW9uRW5kTGlzdGVuZXIoYm94LCAnYWRkJywgbGlzdGVuZXIpO1xuICAgIGN1cnJlbnRUcmFuc2l0aW9uRW5kTGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uKGV2ZW50VHlwZSwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZXMgPSBub3JtYWxpemVUb0FycmF5KGluc3RhbmNlLnByb3BzLnRyaWdnZXJUYXJnZXQgfHwgcmVmZXJlbmNlKTtcbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgIGxpc3RlbmVycy5wdXNoKHtcbiAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgZXZlbnRUeXBlOiBldmVudFR5cGUsXG4gICAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkTGlzdGVuZXJzKCkge1xuICAgIGlmIChnZXRJc0N1c3RvbVRvdWNoQmVoYXZpb3IoKSkge1xuICAgICAgb24oJ3RvdWNoc3RhcnQnLCBvblRyaWdnZXIsIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBvbigndG91Y2hlbmQnLCBvbk1vdXNlTGVhdmUsIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3BsaXRCeVNwYWNlcyhpbnN0YW5jZS5wcm9wcy50cmlnZ2VyKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudFR5cGUpIHtcbiAgICAgIGlmIChldmVudFR5cGUgPT09ICdtYW51YWwnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgb24oZXZlbnRUeXBlLCBvblRyaWdnZXIpO1xuXG4gICAgICBzd2l0Y2ggKGV2ZW50VHlwZSkge1xuICAgICAgICBjYXNlICdtb3VzZWVudGVyJzpcbiAgICAgICAgICBvbignbW91c2VsZWF2ZScsIG9uTW91c2VMZWF2ZSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZm9jdXMnOlxuICAgICAgICAgIG9uKGlzSUUgPyAnZm9jdXNvdXQnIDogJ2JsdXInLCBvbkJsdXJPckZvY3VzT3V0KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmb2N1c2luJzpcbiAgICAgICAgICBvbignZm9jdXNvdXQnLCBvbkJsdXJPckZvY3VzT3V0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVycygpIHtcbiAgICBsaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgdmFyIG5vZGUgPSBfcmVmLm5vZGUsXG4gICAgICAgICAgZXZlbnRUeXBlID0gX3JlZi5ldmVudFR5cGUsXG4gICAgICAgICAgaGFuZGxlciA9IF9yZWYuaGFuZGxlcixcbiAgICAgICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zO1xuICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgfSk7XG4gICAgbGlzdGVuZXJzID0gW107XG4gIH1cblxuICBmdW5jdGlvbiBvblRyaWdnZXIoZXZlbnQpIHtcbiAgICB2YXIgX2xhc3RUcmlnZ2VyRXZlbnQ7XG5cbiAgICB2YXIgc2hvdWxkU2NoZWR1bGVDbGlja0hpZGUgPSBmYWxzZTtcblxuICAgIGlmICghaW5zdGFuY2Uuc3RhdGUuaXNFbmFibGVkIHx8IGlzRXZlbnRMaXN0ZW5lclN0b3BwZWQoZXZlbnQpIHx8IGRpZEhpZGVEdWVUb0RvY3VtZW50TW91c2VEb3duKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHdhc0ZvY3VzZWQgPSAoKF9sYXN0VHJpZ2dlckV2ZW50ID0gbGFzdFRyaWdnZXJFdmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9sYXN0VHJpZ2dlckV2ZW50LnR5cGUpID09PSAnZm9jdXMnO1xuICAgIGxhc3RUcmlnZ2VyRXZlbnQgPSBldmVudDtcbiAgICBjdXJyZW50VGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICBoYW5kbGVBcmlhRXhwYW5kZWRBdHRyaWJ1dGUoKTtcblxuICAgIGlmICghaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlICYmIGlzTW91c2VFdmVudChldmVudCkpIHtcbiAgICAgIC8vIElmIHNjcm9sbGluZywgYG1vdXNlZW50ZXJgIGV2ZW50cyBjYW4gYmUgZmlyZWQgaWYgdGhlIGN1cnNvciBsYW5kc1xuICAgICAgLy8gb3ZlciBhIG5ldyB0YXJnZXQsIGJ1dCBgbW91c2Vtb3ZlYCBldmVudHMgZG9uJ3QgZ2V0IGZpcmVkLiBUaGlzXG4gICAgICAvLyBjYXVzZXMgaW50ZXJhY3RpdmUgdG9vbHRpcHMgdG8gZ2V0IHN0dWNrIG9wZW4gdW50aWwgdGhlIGN1cnNvciBpc1xuICAgICAgLy8gbW92ZWRcbiAgICAgIG1vdXNlTW92ZUxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gbGlzdGVuZXIoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfSAvLyBUb2dnbGUgc2hvdy9oaWRlIHdoZW4gY2xpY2tpbmcgY2xpY2stdHJpZ2dlcmVkIHRvb2x0aXBzXG5cblxuICAgIGlmIChldmVudC50eXBlID09PSAnY2xpY2snICYmIChpbnN0YW5jZS5wcm9wcy50cmlnZ2VyLmluZGV4T2YoJ21vdXNlZW50ZXInKSA8IDAgfHwgaXNWaXNpYmxlRnJvbUNsaWNrKSAmJiBpbnN0YW5jZS5wcm9wcy5oaWRlT25DbGljayAhPT0gZmFsc2UgJiYgaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICBzaG91bGRTY2hlZHVsZUNsaWNrSGlkZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjaGVkdWxlU2hvdyhldmVudCk7XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdjbGljaycpIHtcbiAgICAgIGlzVmlzaWJsZUZyb21DbGljayA9ICFzaG91bGRTY2hlZHVsZUNsaWNrSGlkZTtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkU2NoZWR1bGVDbGlja0hpZGUgJiYgIXdhc0ZvY3VzZWQpIHtcbiAgICAgIHNjaGVkdWxlSGlkZShldmVudCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgIHZhciBpc0N1cnNvck92ZXJSZWZlcmVuY2VPclBvcHBlciA9IHJlZmVyZW5jZS5jb250YWlucyh0YXJnZXQpIHx8IHBvcHBlci5jb250YWlucyh0YXJnZXQpO1xuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdtb3VzZW1vdmUnICYmIGlzQ3Vyc29yT3ZlclJlZmVyZW5jZU9yUG9wcGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBvcHBlclRyZWVEYXRhID0gZ2V0TmVzdGVkUG9wcGVyVHJlZSgpLmNvbmNhdChwb3BwZXIpLm1hcChmdW5jdGlvbiAocG9wcGVyKSB7XG4gICAgICB2YXIgX2luc3RhbmNlJHBvcHBlckluc3RhO1xuXG4gICAgICB2YXIgaW5zdGFuY2UgPSBwb3BwZXIuX3RpcHB5O1xuICAgICAgdmFyIHN0YXRlID0gKF9pbnN0YW5jZSRwb3BwZXJJbnN0YSA9IGluc3RhbmNlLnBvcHBlckluc3RhbmNlKSA9PSBudWxsID8gdm9pZCAwIDogX2luc3RhbmNlJHBvcHBlckluc3RhLnN0YXRlO1xuXG4gICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwb3BwZXJSZWN0OiBwb3BwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgcG9wcGVyU3RhdGU6IHN0YXRlLFxuICAgICAgICAgIHByb3BzOiBwcm9wc1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KS5maWx0ZXIoQm9vbGVhbik7XG5cbiAgICBpZiAoaXNDdXJzb3JPdXRzaWRlSW50ZXJhY3RpdmVCb3JkZXIocG9wcGVyVHJlZURhdGEsIGV2ZW50KSkge1xuICAgICAgY2xlYW51cEludGVyYWN0aXZlTW91c2VMaXN0ZW5lcnMoKTtcbiAgICAgIHNjaGVkdWxlSGlkZShldmVudCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Nb3VzZUxlYXZlKGV2ZW50KSB7XG4gICAgdmFyIHNob3VsZEJhaWwgPSBpc0V2ZW50TGlzdGVuZXJTdG9wcGVkKGV2ZW50KSB8fCBpbnN0YW5jZS5wcm9wcy50cmlnZ2VyLmluZGV4T2YoJ2NsaWNrJykgPj0gMCAmJiBpc1Zpc2libGVGcm9tQ2xpY2s7XG5cbiAgICBpZiAoc2hvdWxkQmFpbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZSkge1xuICAgICAgaW5zdGFuY2UuaGlkZVdpdGhJbnRlcmFjdGl2aXR5KGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzY2hlZHVsZUhpZGUoZXZlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25CbHVyT3JGb2N1c091dChldmVudCkge1xuICAgIGlmIChpbnN0YW5jZS5wcm9wcy50cmlnZ2VyLmluZGV4T2YoJ2ZvY3VzaW4nKSA8IDAgJiYgZXZlbnQudGFyZ2V0ICE9PSBnZXRDdXJyZW50VGFyZ2V0KCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIElmIGZvY3VzIHdhcyBtb3ZlZCB0byB3aXRoaW4gdGhlIHBvcHBlclxuXG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUgJiYgZXZlbnQucmVsYXRlZFRhcmdldCAmJiBwb3BwZXIuY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzY2hlZHVsZUhpZGUoZXZlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNFdmVudExpc3RlbmVyU3RvcHBlZChldmVudCkge1xuICAgIHJldHVybiBjdXJyZW50SW5wdXQuaXNUb3VjaCA/IGdldElzQ3VzdG9tVG91Y2hCZWhhdmlvcigpICE9PSBldmVudC50eXBlLmluZGV4T2YoJ3RvdWNoJykgPj0gMCA6IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUG9wcGVySW5zdGFuY2UoKSB7XG4gICAgZGVzdHJveVBvcHBlckluc3RhbmNlKCk7XG4gICAgdmFyIF9pbnN0YW5jZSRwcm9wczIgPSBpbnN0YW5jZS5wcm9wcyxcbiAgICAgICAgcG9wcGVyT3B0aW9ucyA9IF9pbnN0YW5jZSRwcm9wczIucG9wcGVyT3B0aW9ucyxcbiAgICAgICAgcGxhY2VtZW50ID0gX2luc3RhbmNlJHByb3BzMi5wbGFjZW1lbnQsXG4gICAgICAgIG9mZnNldCA9IF9pbnN0YW5jZSRwcm9wczIub2Zmc2V0LFxuICAgICAgICBnZXRSZWZlcmVuY2VDbGllbnRSZWN0ID0gX2luc3RhbmNlJHByb3BzMi5nZXRSZWZlcmVuY2VDbGllbnRSZWN0LFxuICAgICAgICBtb3ZlVHJhbnNpdGlvbiA9IF9pbnN0YW5jZSRwcm9wczIubW92ZVRyYW5zaXRpb247XG4gICAgdmFyIGFycm93ID0gZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKSA/IGdldENoaWxkcmVuKHBvcHBlcikuYXJyb3cgOiBudWxsO1xuICAgIHZhciBjb21wdXRlZFJlZmVyZW5jZSA9IGdldFJlZmVyZW5jZUNsaWVudFJlY3QgPyB7XG4gICAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3Q6IGdldFJlZmVyZW5jZUNsaWVudFJlY3QsXG4gICAgICBjb250ZXh0RWxlbWVudDogZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdC5jb250ZXh0RWxlbWVudCB8fCBnZXRDdXJyZW50VGFyZ2V0KClcbiAgICB9IDogcmVmZXJlbmNlO1xuICAgIHZhciB0aXBweU1vZGlmaWVyID0ge1xuICAgICAgbmFtZTogJyQkdGlwcHknLFxuICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgIHBoYXNlOiAnYmVmb3JlV3JpdGUnLFxuICAgICAgcmVxdWlyZXM6IFsnY29tcHV0ZVN0eWxlcyddLFxuICAgICAgZm46IGZ1bmN0aW9uIGZuKF9yZWYyKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlO1xuXG4gICAgICAgIGlmIChnZXRJc0RlZmF1bHRSZW5kZXJGbigpKSB7XG4gICAgICAgICAgdmFyIF9nZXREZWZhdWx0VGVtcGxhdGVDaCA9IGdldERlZmF1bHRUZW1wbGF0ZUNoaWxkcmVuKCksXG4gICAgICAgICAgICAgIGJveCA9IF9nZXREZWZhdWx0VGVtcGxhdGVDaC5ib3g7XG5cbiAgICAgICAgICBbJ3BsYWNlbWVudCcsICdyZWZlcmVuY2UtaGlkZGVuJywgJ2VzY2FwZWQnXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICBpZiAoYXR0ciA9PT0gJ3BsYWNlbWVudCcpIHtcbiAgICAgICAgICAgICAgYm94LnNldEF0dHJpYnV0ZSgnZGF0YS1wbGFjZW1lbnQnLCBzdGF0ZS5wbGFjZW1lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyW1wiZGF0YS1wb3BwZXItXCIgKyBhdHRyXSkge1xuICAgICAgICAgICAgICAgIGJveC5zZXRBdHRyaWJ1dGUoXCJkYXRhLVwiICsgYXR0ciwgJycpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJveC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLVwiICsgYXR0cik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciA9IHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgbW9kaWZpZXJzID0gW3tcbiAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBvZmZzZXQ6IG9mZnNldFxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdwcmV2ZW50T3ZlcmZsb3cnLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBwYWRkaW5nOiB7XG4gICAgICAgICAgdG9wOiAyLFxuICAgICAgICAgIGJvdHRvbTogMixcbiAgICAgICAgICBsZWZ0OiA1LFxuICAgICAgICAgIHJpZ2h0OiA1XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBuYW1lOiAnZmxpcCcsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHBhZGRpbmc6IDVcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBuYW1lOiAnY29tcHV0ZVN0eWxlcycsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIGFkYXB0aXZlOiAhbW92ZVRyYW5zaXRpb25cbiAgICAgIH1cbiAgICB9LCB0aXBweU1vZGlmaWVyXTtcblxuICAgIGlmIChnZXRJc0RlZmF1bHRSZW5kZXJGbigpICYmIGFycm93KSB7XG4gICAgICBtb2RpZmllcnMucHVzaCh7XG4gICAgICAgIG5hbWU6ICdhcnJvdycsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBlbGVtZW50OiBhcnJvdyxcbiAgICAgICAgICBwYWRkaW5nOiAzXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIG1vZGlmaWVycy5wdXNoLmFwcGx5KG1vZGlmaWVycywgKHBvcHBlck9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IHBvcHBlck9wdGlvbnMubW9kaWZpZXJzKSB8fCBbXSk7XG4gICAgaW5zdGFuY2UucG9wcGVySW5zdGFuY2UgPSBjcmVhdGVQb3BwZXIoY29tcHV0ZWRSZWZlcmVuY2UsIHBvcHBlciwgT2JqZWN0LmFzc2lnbih7fSwgcG9wcGVyT3B0aW9ucywge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBvbkZpcnN0VXBkYXRlOiBvbkZpcnN0VXBkYXRlLFxuICAgICAgbW9kaWZpZXJzOiBtb2RpZmllcnNcbiAgICB9KSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95UG9wcGVySW5zdGFuY2UoKSB7XG4gICAgaWYgKGluc3RhbmNlLnBvcHBlckluc3RhbmNlKSB7XG4gICAgICBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZS5kZXN0cm95KCk7XG4gICAgICBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgdmFyIGFwcGVuZFRvID0gaW5zdGFuY2UucHJvcHMuYXBwZW5kVG87XG4gICAgdmFyIHBhcmVudE5vZGU7IC8vIEJ5IGRlZmF1bHQsIHdlJ2xsIGFwcGVuZCB0aGUgcG9wcGVyIHRvIHRoZSB0cmlnZ2VyVGFyZ2V0cydzIHBhcmVudE5vZGUgc29cbiAgICAvLyBpdCdzIGRpcmVjdGx5IGFmdGVyIHRoZSByZWZlcmVuY2UgZWxlbWVudCBzbyB0aGUgZWxlbWVudHMgaW5zaWRlIHRoZVxuICAgIC8vIHRpcHB5IGNhbiBiZSB0YWJiZWQgdG9cbiAgICAvLyBJZiB0aGVyZSBhcmUgY2xpcHBpbmcgaXNzdWVzLCB0aGUgdXNlciBjYW4gc3BlY2lmeSBhIGRpZmZlcmVudCBhcHBlbmRUb1xuICAgIC8vIGFuZCBlbnN1cmUgZm9jdXMgbWFuYWdlbWVudCBpcyBoYW5kbGVkIGNvcnJlY3RseSBtYW51YWxseVxuXG4gICAgdmFyIG5vZGUgPSBnZXRDdXJyZW50VGFyZ2V0KCk7XG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUgJiYgYXBwZW5kVG8gPT09IGRlZmF1bHRQcm9wcy5hcHBlbmRUbyB8fCBhcHBlbmRUbyA9PT0gJ3BhcmVudCcpIHtcbiAgICAgIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudE5vZGUgPSBpbnZva2VXaXRoQXJnc09yUmV0dXJuKGFwcGVuZFRvLCBbbm9kZV0pO1xuICAgIH0gLy8gVGhlIHBvcHBlciBlbGVtZW50IG5lZWRzIHRvIGV4aXN0IG9uIHRoZSBET00gYmVmb3JlIGl0cyBwb3NpdGlvbiBjYW4gYmVcbiAgICAvLyB1cGRhdGVkIGFzIFBvcHBlciBuZWVkcyB0byByZWFkIGl0cyBkaW1lbnNpb25zXG5cblxuICAgIGlmICghcGFyZW50Tm9kZS5jb250YWlucyhwb3BwZXIpKSB7XG4gICAgICBwYXJlbnROb2RlLmFwcGVuZENoaWxkKHBvcHBlcik7XG4gICAgfVxuXG4gICAgY3JlYXRlUG9wcGVySW5zdGFuY2UoKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgLy8gQWNjZXNzaWJpbGl0eSBjaGVja1xuICAgICAgd2FybldoZW4oaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUgJiYgYXBwZW5kVG8gPT09IGRlZmF1bHRQcm9wcy5hcHBlbmRUbyAmJiBub2RlLm5leHRFbGVtZW50U2libGluZyAhPT0gcG9wcGVyLCBbJ0ludGVyYWN0aXZlIHRpcHB5IGVsZW1lbnQgbWF5IG5vdCBiZSBhY2Nlc3NpYmxlIHZpYSBrZXlib2FyZCcsICduYXZpZ2F0aW9uIGJlY2F1c2UgaXQgaXMgbm90IGRpcmVjdGx5IGFmdGVyIHRoZSByZWZlcmVuY2UgZWxlbWVudCcsICdpbiB0aGUgRE9NIHNvdXJjZSBvcmRlci4nLCAnXFxuXFxuJywgJ1VzaW5nIGEgd3JhcHBlciA8ZGl2PiBvciA8c3Bhbj4gdGFnIGFyb3VuZCB0aGUgcmVmZXJlbmNlIGVsZW1lbnQnLCAnc29sdmVzIHRoaXMgYnkgY3JlYXRpbmcgYSBuZXcgcGFyZW50Tm9kZSBjb250ZXh0LicsICdcXG5cXG4nLCAnU3BlY2lmeWluZyBgYXBwZW5kVG86IGRvY3VtZW50LmJvZHlgIHNpbGVuY2VzIHRoaXMgd2FybmluZywgYnV0IGl0JywgJ2Fzc3VtZXMgeW91IGFyZSB1c2luZyBhIGZvY3VzIG1hbmFnZW1lbnQgc29sdXRpb24gdG8gaGFuZGxlJywgJ2tleWJvYXJkIG5hdmlnYXRpb24uJywgJ1xcblxcbicsICdTZWU6IGh0dHBzOi8vYXRvbWlrcy5naXRodWIuaW8vdGlwcHlqcy92Ni9hY2Nlc3NpYmlsaXR5LyNpbnRlcmFjdGl2aXR5J10uam9pbignICcpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXROZXN0ZWRQb3BwZXJUcmVlKCkge1xuICAgIHJldHVybiBhcnJheUZyb20ocG9wcGVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXRpcHB5LXJvb3RdJykpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGVTaG93KGV2ZW50KSB7XG4gICAgaW5zdGFuY2UuY2xlYXJEZWxheVRpbWVvdXRzKCk7XG5cbiAgICBpZiAoZXZlbnQpIHtcbiAgICAgIGludm9rZUhvb2soJ29uVHJpZ2dlcicsIFtpbnN0YW5jZSwgZXZlbnRdKTtcbiAgICB9XG5cbiAgICBhZGREb2N1bWVudFByZXNzKCk7XG4gICAgdmFyIGRlbGF5ID0gZ2V0RGVsYXkodHJ1ZSk7XG5cbiAgICB2YXIgX2dldE5vcm1hbGl6ZWRUb3VjaFNlID0gZ2V0Tm9ybWFsaXplZFRvdWNoU2V0dGluZ3MoKSxcbiAgICAgICAgdG91Y2hWYWx1ZSA9IF9nZXROb3JtYWxpemVkVG91Y2hTZVswXSxcbiAgICAgICAgdG91Y2hEZWxheSA9IF9nZXROb3JtYWxpemVkVG91Y2hTZVsxXTtcblxuICAgIGlmIChjdXJyZW50SW5wdXQuaXNUb3VjaCAmJiB0b3VjaFZhbHVlID09PSAnaG9sZCcgJiYgdG91Y2hEZWxheSkge1xuICAgICAgZGVsYXkgPSB0b3VjaERlbGF5O1xuICAgIH1cblxuICAgIGlmIChkZWxheSkge1xuICAgICAgc2hvd1RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2hvdygpO1xuICAgICAgfSwgZGVsYXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZS5zaG93KCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGVIaWRlKGV2ZW50KSB7XG4gICAgaW5zdGFuY2UuY2xlYXJEZWxheVRpbWVvdXRzKCk7XG4gICAgaW52b2tlSG9vaygnb25VbnRyaWdnZXInLCBbaW5zdGFuY2UsIGV2ZW50XSk7XG5cbiAgICBpZiAoIWluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSkge1xuICAgICAgcmVtb3ZlRG9jdW1lbnRQcmVzcygpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRm9yIGludGVyYWN0aXZlIHRpcHBpZXMsIHNjaGVkdWxlSGlkZSBpcyBhZGRlZCB0byBhIGRvY3VtZW50LmJvZHkgaGFuZGxlclxuICAgIC8vIGZyb20gb25Nb3VzZUxlYXZlIHNvIG11c3QgaW50ZXJjZXB0IHNjaGVkdWxlZCBoaWRlcyBmcm9tIG1vdXNlbW92ZS9sZWF2ZVxuICAgIC8vIGV2ZW50cyB3aGVuIHRyaWdnZXIgY29udGFpbnMgbW91c2VlbnRlciBhbmQgY2xpY2ssIGFuZCB0aGUgdGlwIGlzXG4gICAgLy8gY3VycmVudGx5IHNob3duIGFzIGEgcmVzdWx0IG9mIGEgY2xpY2suXG5cblxuICAgIGlmIChpbnN0YW5jZS5wcm9wcy50cmlnZ2VyLmluZGV4T2YoJ21vdXNlZW50ZXInKSA+PSAwICYmIGluc3RhbmNlLnByb3BzLnRyaWdnZXIuaW5kZXhPZignY2xpY2snKSA+PSAwICYmIFsnbW91c2VsZWF2ZScsICdtb3VzZW1vdmUnXS5pbmRleE9mKGV2ZW50LnR5cGUpID49IDAgJiYgaXNWaXNpYmxlRnJvbUNsaWNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRlbGF5ID0gZ2V0RGVsYXkoZmFsc2UpO1xuXG4gICAgaWYgKGRlbGF5KSB7XG4gICAgICBoaWRlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgaW5zdGFuY2UuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICB9LCBkZWxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZpeGVzIGEgYHRyYW5zaXRpb25lbmRgIHByb2JsZW0gd2hlbiBpdCBmaXJlcyAxIGZyYW1lIHRvb1xuICAgICAgLy8gbGF0ZSBzb21ldGltZXMsIHdlIGRvbid0IHdhbnQgaGlkZSgpIHRvIGJlIGNhbGxlZC5cbiAgICAgIHNjaGVkdWxlSGlkZUFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5zdGFuY2UuaGlkZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9IC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyDwn5SRIFB1YmxpYyBtZXRob2RzXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgIGluc3RhbmNlLnN0YXRlLmlzRW5hYmxlZCA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgIC8vIERpc2FibGluZyB0aGUgaW5zdGFuY2Ugc2hvdWxkIGFsc28gaGlkZSBpdFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hdG9taWtzL3RpcHB5LmpzLXJlYWN0L2lzc3Vlcy8xMDZcbiAgICBpbnN0YW5jZS5oaWRlKCk7XG4gICAgaW5zdGFuY2Uuc3RhdGUuaXNFbmFibGVkID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhckRlbGF5VGltZW91dHMoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHNob3dUaW1lb3V0KTtcbiAgICBjbGVhclRpbWVvdXQoaGlkZVRpbWVvdXQpO1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHNjaGVkdWxlSGlkZUFuaW1hdGlvbkZyYW1lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFByb3BzKHBhcnRpYWxQcm9wcykge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgd2FybldoZW4oaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQsIGNyZWF0ZU1lbW9yeUxlYWtXYXJuaW5nKCdzZXRQcm9wcycpKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnZva2VIb29rKCdvbkJlZm9yZVVwZGF0ZScsIFtpbnN0YW5jZSwgcGFydGlhbFByb3BzXSk7XG4gICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgdmFyIHByZXZQcm9wcyA9IGluc3RhbmNlLnByb3BzO1xuICAgIHZhciBuZXh0UHJvcHMgPSBldmFsdWF0ZVByb3BzKHJlZmVyZW5jZSwgT2JqZWN0LmFzc2lnbih7fSwgaW5zdGFuY2UucHJvcHMsIHt9LCBwYXJ0aWFsUHJvcHMsIHtcbiAgICAgIGlnbm9yZUF0dHJpYnV0ZXM6IHRydWVcbiAgICB9KSk7XG4gICAgaW5zdGFuY2UucHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgYWRkTGlzdGVuZXJzKCk7XG5cbiAgICBpZiAocHJldlByb3BzLmludGVyYWN0aXZlRGVib3VuY2UgIT09IG5leHRQcm9wcy5pbnRlcmFjdGl2ZURlYm91bmNlKSB7XG4gICAgICBjbGVhbnVwSW50ZXJhY3RpdmVNb3VzZUxpc3RlbmVycygpO1xuICAgICAgZGVib3VuY2VkT25Nb3VzZU1vdmUgPSBkZWJvdW5jZShvbk1vdXNlTW92ZSwgbmV4dFByb3BzLmludGVyYWN0aXZlRGVib3VuY2UpO1xuICAgIH0gLy8gRW5zdXJlIHN0YWxlIGFyaWEtZXhwYW5kZWQgYXR0cmlidXRlcyBhcmUgcmVtb3ZlZFxuXG5cbiAgICBpZiAocHJldlByb3BzLnRyaWdnZXJUYXJnZXQgJiYgIW5leHRQcm9wcy50cmlnZ2VyVGFyZ2V0KSB7XG4gICAgICBub3JtYWxpemVUb0FycmF5KHByZXZQcm9wcy50cmlnZ2VyVGFyZ2V0KS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG5leHRQcm9wcy50cmlnZ2VyVGFyZ2V0KSB7XG4gICAgICByZWZlcmVuY2UucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJyk7XG4gICAgfVxuXG4gICAgaGFuZGxlQXJpYUV4cGFuZGVkQXR0cmlidXRlKCk7XG4gICAgaGFuZGxlU3R5bGVzKCk7XG5cbiAgICBpZiAob25VcGRhdGUpIHtcbiAgICAgIG9uVXBkYXRlKHByZXZQcm9wcywgbmV4dFByb3BzKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UucG9wcGVySW5zdGFuY2UpIHtcbiAgICAgIGNyZWF0ZVBvcHBlckluc3RhbmNlKCk7IC8vIEZpeGVzIGFuIGlzc3VlIHdpdGggbmVzdGVkIHRpcHBpZXMgaWYgdGhleSBhcmUgYWxsIGdldHRpbmcgcmUtcmVuZGVyZWQsXG4gICAgICAvLyBhbmQgdGhlIG5lc3RlZCBvbmVzIGdldCByZS1yZW5kZXJlZCBmaXJzdC5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hdG9taWtzL3RpcHB5anMtcmVhY3QvaXNzdWVzLzE3N1xuICAgICAgLy8gVE9ETzogZmluZCBhIGNsZWFuZXIgLyBtb3JlIGVmZmljaWVudCBzb2x1dGlvbighKVxuXG4gICAgICBnZXROZXN0ZWRQb3BwZXJUcmVlKCkuZm9yRWFjaChmdW5jdGlvbiAobmVzdGVkUG9wcGVyKSB7XG4gICAgICAgIC8vIFJlYWN0IChhbmQgb3RoZXIgVUkgbGlicyBsaWtlbHkpIHJlcXVpcmVzIGEgckFGIHdyYXBwZXIgYXMgaXQgZmx1c2hlc1xuICAgICAgICAvLyBpdHMgd29yayBpbiBvbmVcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKG5lc3RlZFBvcHBlci5fdGlwcHkucG9wcGVySW5zdGFuY2UuZm9yY2VVcGRhdGUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaW52b2tlSG9vaygnb25BZnRlclVwZGF0ZScsIFtpbnN0YW5jZSwgcGFydGlhbFByb3BzXSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRDb250ZW50KGNvbnRlbnQpIHtcbiAgICBpbnN0YW5jZS5zZXRQcm9wcyh7XG4gICAgICBjb250ZW50OiBjb250ZW50XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBzaG93KCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgd2FybldoZW4oaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQsIGNyZWF0ZU1lbW9yeUxlYWtXYXJuaW5nKCdzaG93JykpO1xuICAgIH0gLy8gRWFybHkgYmFpbC1vdXRcblxuXG4gICAgdmFyIGlzQWxyZWFkeVZpc2libGUgPSBpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGU7XG4gICAgdmFyIGlzRGVzdHJveWVkID0gaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQ7XG4gICAgdmFyIGlzRGlzYWJsZWQgPSAhaW5zdGFuY2Uuc3RhdGUuaXNFbmFibGVkO1xuICAgIHZhciBpc1RvdWNoQW5kVG91Y2hEaXNhYmxlZCA9IGN1cnJlbnRJbnB1dC5pc1RvdWNoICYmICFpbnN0YW5jZS5wcm9wcy50b3VjaDtcbiAgICB2YXIgZHVyYXRpb24gPSBnZXRWYWx1ZUF0SW5kZXhPclJldHVybihpbnN0YW5jZS5wcm9wcy5kdXJhdGlvbiwgMCwgZGVmYXVsdFByb3BzLmR1cmF0aW9uKTtcblxuICAgIGlmIChpc0FscmVhZHlWaXNpYmxlIHx8IGlzRGVzdHJveWVkIHx8IGlzRGlzYWJsZWQgfHwgaXNUb3VjaEFuZFRvdWNoRGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIE5vcm1hbGl6ZSBgZGlzYWJsZWRgIGJlaGF2aW9yIGFjcm9zcyBicm93c2Vycy5cbiAgICAvLyBGaXJlZm94IGFsbG93cyBldmVudHMgb24gZGlzYWJsZWQgZWxlbWVudHMsIGJ1dCBDaHJvbWUgZG9lc24ndC5cbiAgICAvLyBVc2luZyBhIHdyYXBwZXIgZWxlbWVudCAoaS5lLiA8c3Bhbj4pIGlzIHJlY29tbWVuZGVkLlxuXG5cbiAgICBpZiAoZ2V0Q3VycmVudFRhcmdldCgpLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludm9rZUhvb2soJ29uU2hvdycsIFtpbnN0YW5jZV0sIGZhbHNlKTtcblxuICAgIGlmIChpbnN0YW5jZS5wcm9wcy5vblNob3coaW5zdGFuY2UpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSA9IHRydWU7XG5cbiAgICBpZiAoZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKSkge1xuICAgICAgcG9wcGVyLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgfVxuXG4gICAgaGFuZGxlU3R5bGVzKCk7XG4gICAgYWRkRG9jdW1lbnRQcmVzcygpO1xuXG4gICAgaWYgKCFpbnN0YW5jZS5zdGF0ZS5pc01vdW50ZWQpIHtcbiAgICAgIHBvcHBlci5zdHlsZS50cmFuc2l0aW9uID0gJ25vbmUnO1xuICAgIH0gLy8gSWYgZmxpcHBpbmcgdG8gdGhlIG9wcG9zaXRlIHNpZGUgYWZ0ZXIgaGlkaW5nIGF0IGxlYXN0IG9uY2UsIHRoZVxuICAgIC8vIGFuaW1hdGlvbiB3aWxsIHVzZSB0aGUgd3JvbmcgcGxhY2VtZW50IHdpdGhvdXQgcmVzZXR0aW5nIHRoZSBkdXJhdGlvblxuXG5cbiAgICBpZiAoZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKSkge1xuICAgICAgdmFyIF9nZXREZWZhdWx0VGVtcGxhdGVDaDIgPSBnZXREZWZhdWx0VGVtcGxhdGVDaGlsZHJlbigpLFxuICAgICAgICAgIGJveCA9IF9nZXREZWZhdWx0VGVtcGxhdGVDaDIuYm94LFxuICAgICAgICAgIGNvbnRlbnQgPSBfZ2V0RGVmYXVsdFRlbXBsYXRlQ2gyLmNvbnRlbnQ7XG5cbiAgICAgIHNldFRyYW5zaXRpb25EdXJhdGlvbihbYm94LCBjb250ZW50XSwgMCk7XG4gICAgfVxuXG4gICAgb25GaXJzdFVwZGF0ZSA9IGZ1bmN0aW9uIG9uRmlyc3RVcGRhdGUoKSB7XG4gICAgICBpZiAoIWluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSB8fCBpZ25vcmVPbkZpcnN0VXBkYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWdub3JlT25GaXJzdFVwZGF0ZSA9IHRydWU7IC8vIHJlZmxvd1xuXG4gICAgICB2b2lkIHBvcHBlci5vZmZzZXRIZWlnaHQ7XG4gICAgICBwb3BwZXIuc3R5bGUudHJhbnNpdGlvbiA9IGluc3RhbmNlLnByb3BzLm1vdmVUcmFuc2l0aW9uO1xuXG4gICAgICBpZiAoZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKSAmJiBpbnN0YW5jZS5wcm9wcy5hbmltYXRpb24pIHtcbiAgICAgICAgdmFyIF9nZXREZWZhdWx0VGVtcGxhdGVDaDMgPSBnZXREZWZhdWx0VGVtcGxhdGVDaGlsZHJlbigpLFxuICAgICAgICAgICAgX2JveCA9IF9nZXREZWZhdWx0VGVtcGxhdGVDaDMuYm94LFxuICAgICAgICAgICAgX2NvbnRlbnQgPSBfZ2V0RGVmYXVsdFRlbXBsYXRlQ2gzLmNvbnRlbnQ7XG5cbiAgICAgICAgc2V0VHJhbnNpdGlvbkR1cmF0aW9uKFtfYm94LCBfY29udGVudF0sIGR1cmF0aW9uKTtcbiAgICAgICAgc2V0VmlzaWJpbGl0eVN0YXRlKFtfYm94LCBfY29udGVudF0sICd2aXNpYmxlJyk7XG4gICAgICB9XG5cbiAgICAgIGhhbmRsZUFyaWFDb250ZW50QXR0cmlidXRlKCk7XG4gICAgICBoYW5kbGVBcmlhRXhwYW5kZWRBdHRyaWJ1dGUoKTtcbiAgICAgIHB1c2hJZlVuaXF1ZShtb3VudGVkSW5zdGFuY2VzLCBpbnN0YW5jZSk7XG4gICAgICBpbnN0YW5jZS5zdGF0ZS5pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgaW52b2tlSG9vaygnb25Nb3VudCcsIFtpbnN0YW5jZV0pO1xuXG4gICAgICBpZiAoaW5zdGFuY2UucHJvcHMuYW5pbWF0aW9uICYmIGdldElzRGVmYXVsdFJlbmRlckZuKCkpIHtcbiAgICAgICAgb25UcmFuc2l0aW9uZWRJbihkdXJhdGlvbiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGluc3RhbmNlLnN0YXRlLmlzU2hvd24gPSB0cnVlO1xuICAgICAgICAgIGludm9rZUhvb2soJ29uU2hvd24nLCBbaW5zdGFuY2VdKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIG1vdW50KCk7XG4gIH1cblxuICBmdW5jdGlvbiBoaWRlKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgd2FybldoZW4oaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQsIGNyZWF0ZU1lbW9yeUxlYWtXYXJuaW5nKCdoaWRlJykpO1xuICAgIH0gLy8gRWFybHkgYmFpbC1vdXRcblxuXG4gICAgdmFyIGlzQWxyZWFkeUhpZGRlbiA9ICFpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGU7XG4gICAgdmFyIGlzRGVzdHJveWVkID0gaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQ7XG4gICAgdmFyIGlzRGlzYWJsZWQgPSAhaW5zdGFuY2Uuc3RhdGUuaXNFbmFibGVkO1xuICAgIHZhciBkdXJhdGlvbiA9IGdldFZhbHVlQXRJbmRleE9yUmV0dXJuKGluc3RhbmNlLnByb3BzLmR1cmF0aW9uLCAxLCBkZWZhdWx0UHJvcHMuZHVyYXRpb24pO1xuXG4gICAgaWYgKGlzQWxyZWFkeUhpZGRlbiB8fCBpc0Rlc3Ryb3llZCB8fCBpc0Rpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW52b2tlSG9vaygnb25IaWRlJywgW2luc3RhbmNlXSwgZmFsc2UpO1xuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzLm9uSGlkZShpbnN0YW5jZSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlID0gZmFsc2U7XG4gICAgaW5zdGFuY2Uuc3RhdGUuaXNTaG93biA9IGZhbHNlO1xuICAgIGlnbm9yZU9uRmlyc3RVcGRhdGUgPSBmYWxzZTtcblxuICAgIGlmIChnZXRJc0RlZmF1bHRSZW5kZXJGbigpKSB7XG4gICAgICBwb3BwZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgIH1cblxuICAgIGNsZWFudXBJbnRlcmFjdGl2ZU1vdXNlTGlzdGVuZXJzKCk7XG4gICAgcmVtb3ZlRG9jdW1lbnRQcmVzcygpO1xuICAgIGhhbmRsZVN0eWxlcygpO1xuXG4gICAgaWYgKGdldElzRGVmYXVsdFJlbmRlckZuKCkpIHtcbiAgICAgIHZhciBfZ2V0RGVmYXVsdFRlbXBsYXRlQ2g0ID0gZ2V0RGVmYXVsdFRlbXBsYXRlQ2hpbGRyZW4oKSxcbiAgICAgICAgICBib3ggPSBfZ2V0RGVmYXVsdFRlbXBsYXRlQ2g0LmJveCxcbiAgICAgICAgICBjb250ZW50ID0gX2dldERlZmF1bHRUZW1wbGF0ZUNoNC5jb250ZW50O1xuXG4gICAgICBpZiAoaW5zdGFuY2UucHJvcHMuYW5pbWF0aW9uKSB7XG4gICAgICAgIHNldFRyYW5zaXRpb25EdXJhdGlvbihbYm94LCBjb250ZW50XSwgZHVyYXRpb24pO1xuICAgICAgICBzZXRWaXNpYmlsaXR5U3RhdGUoW2JveCwgY29udGVudF0sICdoaWRkZW4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVBcmlhQ29udGVudEF0dHJpYnV0ZSgpO1xuICAgIGhhbmRsZUFyaWFFeHBhbmRlZEF0dHJpYnV0ZSgpO1xuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzLmFuaW1hdGlvbikge1xuICAgICAgaWYgKGdldElzRGVmYXVsdFJlbmRlckZuKCkpIHtcbiAgICAgICAgb25UcmFuc2l0aW9uZWRPdXQoZHVyYXRpb24sIGluc3RhbmNlLnVubW91bnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZS51bm1vdW50KCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGlkZVdpdGhJbnRlcmFjdGl2aXR5KGV2ZW50KSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICB3YXJuV2hlbihpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZCwgY3JlYXRlTWVtb3J5TGVha1dhcm5pbmcoJ2hpZGVXaXRoSW50ZXJhY3Rpdml0eScpKTtcbiAgICB9XG5cbiAgICBkb2MuYm9keS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgc2NoZWR1bGVIaWRlKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZGVib3VuY2VkT25Nb3VzZU1vdmUpO1xuICAgIHB1c2hJZlVuaXF1ZShtb3VzZU1vdmVMaXN0ZW5lcnMsIGRlYm91bmNlZE9uTW91c2VNb3ZlKTtcbiAgICBkZWJvdW5jZWRPbk1vdXNlTW92ZShldmVudCk7XG4gIH1cblxuICBmdW5jdGlvbiB1bm1vdW50KCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgd2FybldoZW4oaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQsIGNyZWF0ZU1lbW9yeUxlYWtXYXJuaW5nKCd1bm1vdW50JykpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUpIHtcbiAgICAgIGluc3RhbmNlLmhpZGUoKTtcbiAgICB9XG5cbiAgICBpZiAoIWluc3RhbmNlLnN0YXRlLmlzTW91bnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRlc3Ryb3lQb3BwZXJJbnN0YW5jZSgpOyAvLyBJZiBhIHBvcHBlciBpcyBub3QgaW50ZXJhY3RpdmUsIGl0IHdpbGwgYmUgYXBwZW5kZWQgb3V0c2lkZSB0aGUgcG9wcGVyXG4gICAgLy8gdHJlZSBieSBkZWZhdWx0LiBUaGlzIHNlZW1zIG1haW5seSBmb3IgaW50ZXJhY3RpdmUgdGlwcGllcywgYnV0IHdlIHNob3VsZFxuICAgIC8vIGZpbmQgYSB3b3JrYXJvdW5kIGlmIHBvc3NpYmxlXG5cbiAgICBnZXROZXN0ZWRQb3BwZXJUcmVlKCkuZm9yRWFjaChmdW5jdGlvbiAobmVzdGVkUG9wcGVyKSB7XG4gICAgICBuZXN0ZWRQb3BwZXIuX3RpcHB5LnVubW91bnQoKTtcbiAgICB9KTtcblxuICAgIGlmIChwb3BwZXIucGFyZW50Tm9kZSkge1xuICAgICAgcG9wcGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocG9wcGVyKTtcbiAgICB9XG5cbiAgICBtb3VudGVkSW5zdGFuY2VzID0gbW91bnRlZEluc3RhbmNlcy5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBpICE9PSBpbnN0YW5jZTtcbiAgICB9KTtcbiAgICBpbnN0YW5jZS5zdGF0ZS5pc01vdW50ZWQgPSBmYWxzZTtcbiAgICBpbnZva2VIb29rKCdvbkhpZGRlbicsIFtpbnN0YW5jZV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHdhcm5XaGVuKGluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkLCBjcmVhdGVNZW1vcnlMZWFrV2FybmluZygnZGVzdHJveScpKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnN0YW5jZS5jbGVhckRlbGF5VGltZW91dHMoKTtcbiAgICBpbnN0YW5jZS51bm1vdW50KCk7XG4gICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgZGVsZXRlIHJlZmVyZW5jZS5fdGlwcHk7XG4gICAgaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgIGludm9rZUhvb2soJ29uRGVzdHJveScsIFtpbnN0YW5jZV0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRpcHB5KHRhcmdldHMsIG9wdGlvbmFsUHJvcHMpIHtcbiAgaWYgKG9wdGlvbmFsUHJvcHMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbmFsUHJvcHMgPSB7fTtcbiAgfVxuXG4gIHZhciBwbHVnaW5zID0gZGVmYXVsdFByb3BzLnBsdWdpbnMuY29uY2F0KG9wdGlvbmFsUHJvcHMucGx1Z2lucyB8fCBbXSk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhbGlkYXRlVGFyZ2V0cyh0YXJnZXRzKTtcbiAgICB2YWxpZGF0ZVByb3BzKG9wdGlvbmFsUHJvcHMsIHBsdWdpbnMpO1xuICB9XG5cbiAgYmluZEdsb2JhbEV2ZW50TGlzdGVuZXJzKCk7XG4gIHZhciBwYXNzZWRQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbmFsUHJvcHMsIHtcbiAgICBwbHVnaW5zOiBwbHVnaW5zXG4gIH0pO1xuICB2YXIgZWxlbWVudHMgPSBnZXRBcnJheU9mRWxlbWVudHModGFyZ2V0cyk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhciBpc1NpbmdsZUNvbnRlbnRFbGVtZW50ID0gaXNFbGVtZW50KHBhc3NlZFByb3BzLmNvbnRlbnQpO1xuICAgIHZhciBpc01vcmVUaGFuT25lUmVmZXJlbmNlRWxlbWVudCA9IGVsZW1lbnRzLmxlbmd0aCA+IDE7XG4gICAgd2FybldoZW4oaXNTaW5nbGVDb250ZW50RWxlbWVudCAmJiBpc01vcmVUaGFuT25lUmVmZXJlbmNlRWxlbWVudCwgWyd0aXBweSgpIHdhcyBwYXNzZWQgYW4gRWxlbWVudCBhcyB0aGUgYGNvbnRlbnRgIHByb3AsIGJ1dCBtb3JlIHRoYW4nLCAnb25lIHRpcHB5IGluc3RhbmNlIHdhcyBjcmVhdGVkIGJ5IHRoaXMgaW52b2NhdGlvbi4gVGhpcyBtZWFucyB0aGUnLCAnY29udGVudCBlbGVtZW50IHdpbGwgb25seSBiZSBhcHBlbmRlZCB0byB0aGUgbGFzdCB0aXBweSBpbnN0YW5jZS4nLCAnXFxuXFxuJywgJ0luc3RlYWQsIHBhc3MgdGhlIC5pbm5lckhUTUwgb2YgdGhlIGVsZW1lbnQsIG9yIHVzZSBhIGZ1bmN0aW9uIHRoYXQnLCAncmV0dXJucyBhIGNsb25lZCB2ZXJzaW9uIG9mIHRoZSBlbGVtZW50IGluc3RlYWQuJywgJ1xcblxcbicsICcxKSBjb250ZW50OiBlbGVtZW50LmlubmVySFRNTFxcbicsICcyKSBjb250ZW50OiAoKSA9PiBlbGVtZW50LmNsb25lTm9kZSh0cnVlKSddLmpvaW4oJyAnKSk7XG4gIH1cblxuICB2YXIgaW5zdGFuY2VzID0gZWxlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHJlZmVyZW5jZSkge1xuICAgIHZhciBpbnN0YW5jZSA9IHJlZmVyZW5jZSAmJiBjcmVhdGVUaXBweShyZWZlcmVuY2UsIHBhc3NlZFByb3BzKTtcblxuICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgYWNjLnB1c2goaW5zdGFuY2UpO1xuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIGlzRWxlbWVudCh0YXJnZXRzKSA/IGluc3RhbmNlc1swXSA6IGluc3RhbmNlcztcbn1cblxudGlwcHkuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xudGlwcHkuc2V0RGVmYXVsdFByb3BzID0gc2V0RGVmYXVsdFByb3BzO1xudGlwcHkuY3VycmVudElucHV0ID0gY3VycmVudElucHV0O1xudmFyIGhpZGVBbGwgPSBmdW5jdGlvbiBoaWRlQWxsKF90ZW1wKSB7XG4gIHZhciBfcmVmID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAsXG4gICAgICBleGNsdWRlZFJlZmVyZW5jZU9ySW5zdGFuY2UgPSBfcmVmLmV4Y2x1ZGUsXG4gICAgICBkdXJhdGlvbiA9IF9yZWYuZHVyYXRpb247XG5cbiAgbW91bnRlZEluc3RhbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIHZhciBpc0V4Y2x1ZGVkID0gZmFsc2U7XG5cbiAgICBpZiAoZXhjbHVkZWRSZWZlcmVuY2VPckluc3RhbmNlKSB7XG4gICAgICBpc0V4Y2x1ZGVkID0gaXNSZWZlcmVuY2VFbGVtZW50KGV4Y2x1ZGVkUmVmZXJlbmNlT3JJbnN0YW5jZSkgPyBpbnN0YW5jZS5yZWZlcmVuY2UgPT09IGV4Y2x1ZGVkUmVmZXJlbmNlT3JJbnN0YW5jZSA6IGluc3RhbmNlLnBvcHBlciA9PT0gZXhjbHVkZWRSZWZlcmVuY2VPckluc3RhbmNlLnBvcHBlcjtcbiAgICB9XG5cbiAgICBpZiAoIWlzRXhjbHVkZWQpIHtcbiAgICAgIHZhciBvcmlnaW5hbER1cmF0aW9uID0gaW5zdGFuY2UucHJvcHMuZHVyYXRpb247XG4gICAgICBpbnN0YW5jZS5zZXRQcm9wcyh7XG4gICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvblxuICAgICAgfSk7XG4gICAgICBpbnN0YW5jZS5oaWRlKCk7XG5cbiAgICAgIGlmICghaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0UHJvcHMoe1xuICAgICAgICAgIGR1cmF0aW9uOiBvcmlnaW5hbER1cmF0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgY3JlYXRlU2luZ2xldG9uID0gZnVuY3Rpb24gY3JlYXRlU2luZ2xldG9uKHRpcHB5SW5zdGFuY2VzLCBvcHRpb25hbFByb3BzKSB7XG4gIGlmIChvcHRpb25hbFByb3BzID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25hbFByb3BzID0ge307XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgZXJyb3JXaGVuKCFBcnJheS5pc0FycmF5KHRpcHB5SW5zdGFuY2VzKSwgWydUaGUgZmlyc3QgYXJndW1lbnQgcGFzc2VkIHRvIGNyZWF0ZVNpbmdsZXRvbigpIG11c3QgYmUgYW4gYXJyYXkgb2YnLCAndGlwcHkgaW5zdGFuY2VzLiBUaGUgcGFzc2VkIHZhbHVlIHdhcycsIFN0cmluZyh0aXBweUluc3RhbmNlcyldLmpvaW4oJyAnKSk7XG4gIH1cblxuICB2YXIgbXV0VGlwcHlJbnN0YW5jZXMgPSB0aXBweUluc3RhbmNlcztcbiAgdmFyIHJlZmVyZW5jZXMgPSBbXTtcbiAgdmFyIGN1cnJlbnRUYXJnZXQ7XG4gIHZhciBvdmVycmlkZXMgPSBvcHRpb25hbFByb3BzLm92ZXJyaWRlcztcblxuICBmdW5jdGlvbiBzZXRSZWZlcmVuY2VzKCkge1xuICAgIHJlZmVyZW5jZXMgPSBtdXRUaXBweUluc3RhbmNlcy5tYXAoZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2UucmVmZXJlbmNlO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5hYmxlSW5zdGFuY2VzKGlzRW5hYmxlZCkge1xuICAgIG11dFRpcHB5SW5zdGFuY2VzLmZvckVhY2goZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICBpZiAoaXNFbmFibGVkKSB7XG4gICAgICAgIGluc3RhbmNlLmVuYWJsZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5zdGFuY2UuZGlzYWJsZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZW5hYmxlSW5zdGFuY2VzKGZhbHNlKTtcbiAgc2V0UmVmZXJlbmNlcygpO1xuICB2YXIgc2luZ2xldG9uID0ge1xuICAgIGZuOiBmdW5jdGlvbiBmbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9uRGVzdHJveTogZnVuY3Rpb24gb25EZXN0cm95KCkge1xuICAgICAgICAgIGVuYWJsZUluc3RhbmNlcyh0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25UcmlnZ2VyOiBmdW5jdGlvbiBvblRyaWdnZXIoaW5zdGFuY2UsIGV2ZW50KSB7XG4gICAgICAgICAgdmFyIHRhcmdldCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgdmFyIGluZGV4ID0gcmVmZXJlbmNlcy5pbmRleE9mKHRhcmdldCk7IC8vIGJhaWwtb3V0XG5cbiAgICAgICAgICBpZiAodGFyZ2V0ID09PSBjdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VycmVudFRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgICB2YXIgb3ZlcnJpZGVQcm9wcyA9IChvdmVycmlkZXMgfHwgW10pLmNvbmNhdCgnY29udGVudCcpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwcm9wKSB7XG4gICAgICAgICAgICBhY2NbcHJvcF0gPSBtdXRUaXBweUluc3RhbmNlc1tpbmRleF0ucHJvcHNbcHJvcF07XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICBpbnN0YW5jZS5zZXRQcm9wcyhPYmplY3QuYXNzaWduKHt9LCBvdmVycmlkZVByb3BzLCB7XG4gICAgICAgICAgICBnZXRSZWZlcmVuY2VDbGllbnRSZWN0OiBmdW5jdGlvbiBnZXRSZWZlcmVuY2VDbGllbnRSZWN0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIHZhciBpbnN0YW5jZSA9IHRpcHB5KGRpdigpLCBPYmplY3QuYXNzaWduKHt9LCByZW1vdmVQcm9wZXJ0aWVzKG9wdGlvbmFsUHJvcHMsIFsnb3ZlcnJpZGVzJ10pLCB7XG4gICAgcGx1Z2luczogW3NpbmdsZXRvbl0uY29uY2F0KG9wdGlvbmFsUHJvcHMucGx1Z2lucyB8fCBbXSksXG4gICAgdHJpZ2dlclRhcmdldDogcmVmZXJlbmNlc1xuICB9KSk7XG4gIHZhciBvcmlnaW5hbFNldFByb3BzID0gaW5zdGFuY2Uuc2V0UHJvcHM7XG5cbiAgaW5zdGFuY2Uuc2V0UHJvcHMgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICBvdmVycmlkZXMgPSBwcm9wcy5vdmVycmlkZXMgfHwgb3ZlcnJpZGVzO1xuICAgIG9yaWdpbmFsU2V0UHJvcHMocHJvcHMpO1xuICB9O1xuXG4gIGluc3RhbmNlLnNldEluc3RhbmNlcyA9IGZ1bmN0aW9uIChuZXh0SW5zdGFuY2VzKSB7XG4gICAgZW5hYmxlSW5zdGFuY2VzKHRydWUpO1xuICAgIG11dFRpcHB5SW5zdGFuY2VzID0gbmV4dEluc3RhbmNlcztcbiAgICBlbmFibGVJbnN0YW5jZXMoZmFsc2UpO1xuICAgIHNldFJlZmVyZW5jZXMoKTtcbiAgICBpbnN0YW5jZS5zZXRQcm9wcyh7XG4gICAgICB0cmlnZ2VyVGFyZ2V0OiByZWZlcmVuY2VzXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufTtcblxudmFyIEJVQkJMSU5HX0VWRU5UU19NQVAgPSB7XG4gIG1vdXNlb3ZlcjogJ21vdXNlZW50ZXInLFxuICBmb2N1c2luOiAnZm9jdXMnLFxuICBjbGljazogJ2NsaWNrJ1xufTtcbi8qKlxuICogQ3JlYXRlcyBhIGRlbGVnYXRlIGluc3RhbmNlIHRoYXQgY29udHJvbHMgdGhlIGNyZWF0aW9uIG9mIHRpcHB5IGluc3RhbmNlc1xuICogZm9yIGNoaWxkIGVsZW1lbnRzIChgdGFyZ2V0YCBDU1Mgc2VsZWN0b3IpLlxuICovXG5cbmZ1bmN0aW9uIGRlbGVnYXRlKHRhcmdldHMsIHByb3BzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBlcnJvcldoZW4oIShwcm9wcyAmJiBwcm9wcy50YXJnZXQpLCBbJ1lvdSBtdXN0IHNwZWNpdHkgYSBgdGFyZ2V0YCBwcm9wIGluZGljYXRpbmcgYSBDU1Mgc2VsZWN0b3Igc3RyaW5nIG1hdGNoaW5nJywgJ3RoZSB0YXJnZXQgZWxlbWVudHMgdGhhdCBzaG91bGQgcmVjZWl2ZSBhIHRpcHB5LiddLmpvaW4oJyAnKSk7XG4gIH1cblxuICB2YXIgbGlzdGVuZXJzID0gW107XG4gIHZhciBjaGlsZFRpcHB5SW5zdGFuY2VzID0gW107XG4gIHZhciB0YXJnZXQgPSBwcm9wcy50YXJnZXQ7XG4gIHZhciBuYXRpdmVQcm9wcyA9IHJlbW92ZVByb3BlcnRpZXMocHJvcHMsIFsndGFyZ2V0J10pO1xuICB2YXIgcGFyZW50UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBuYXRpdmVQcm9wcywge1xuICAgIHRyaWdnZXI6ICdtYW51YWwnLFxuICAgIHRvdWNoOiBmYWxzZVxuICB9KTtcbiAgdmFyIGNoaWxkUHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBuYXRpdmVQcm9wcywge1xuICAgIHNob3dPbkNyZWF0ZTogdHJ1ZVxuICB9KTtcbiAgdmFyIHJldHVyblZhbHVlID0gdGlwcHkodGFyZ2V0cywgcGFyZW50UHJvcHMpO1xuICB2YXIgbm9ybWFsaXplZFJldHVyblZhbHVlID0gbm9ybWFsaXplVG9BcnJheShyZXR1cm5WYWx1ZSk7XG5cbiAgZnVuY3Rpb24gb25UcmlnZ2VyKGV2ZW50KSB7XG4gICAgaWYgKCFldmVudC50YXJnZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0Tm9kZSA9IGV2ZW50LnRhcmdldC5jbG9zZXN0KHRhcmdldCk7XG5cbiAgICBpZiAoIXRhcmdldE5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEdldCByZWxldmFudCB0cmlnZ2VyIHdpdGggZmFsbGJhY2tzOlxuICAgIC8vIDEuIENoZWNrIGBkYXRhLXRpcHB5LXRyaWdnZXJgIGF0dHJpYnV0ZSBvbiB0YXJnZXQgbm9kZVxuICAgIC8vIDIuIEZhbGxiYWNrIHRvIGB0cmlnZ2VyYCBwYXNzZWQgdG8gYGRlbGVnYXRlKClgXG4gICAgLy8gMy4gRmFsbGJhY2sgdG8gYGRlZmF1bHRQcm9wcy50cmlnZ2VyYFxuXG5cbiAgICB2YXIgdHJpZ2dlciA9IHRhcmdldE5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLXRpcHB5LXRyaWdnZXInKSB8fCBwcm9wcy50cmlnZ2VyIHx8IGRlZmF1bHRQcm9wcy50cmlnZ2VyOyAvLyBAdHMtaWdub3JlXG5cbiAgICBpZiAodGFyZ2V0Tm9kZS5fdGlwcHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ3RvdWNoc3RhcnQnICYmIHR5cGVvZiBjaGlsZFByb3BzLnRvdWNoID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQudHlwZSAhPT0gJ3RvdWNoc3RhcnQnICYmIHRyaWdnZXIuaW5kZXhPZihCVUJCTElOR19FVkVOVFNfTUFQW2V2ZW50LnR5cGVdKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpbnN0YW5jZSA9IHRpcHB5KHRhcmdldE5vZGUsIGNoaWxkUHJvcHMpO1xuXG4gICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICBjaGlsZFRpcHB5SW5zdGFuY2VzID0gY2hpbGRUaXBweUluc3RhbmNlcy5jb25jYXQoaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uKG5vZGUsIGV2ZW50VHlwZSwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICBsaXN0ZW5lcnMucHVzaCh7XG4gICAgICBub2RlOiBub2RlLFxuICAgICAgZXZlbnRUeXBlOiBldmVudFR5cGUsXG4gICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcnMoaW5zdGFuY2UpIHtcbiAgICB2YXIgcmVmZXJlbmNlID0gaW5zdGFuY2UucmVmZXJlbmNlO1xuICAgIG9uKHJlZmVyZW5jZSwgJ3RvdWNoc3RhcnQnLCBvblRyaWdnZXIpO1xuICAgIG9uKHJlZmVyZW5jZSwgJ21vdXNlb3ZlcicsIG9uVHJpZ2dlcik7XG4gICAgb24ocmVmZXJlbmNlLCAnZm9jdXNpbicsIG9uVHJpZ2dlcik7XG4gICAgb24ocmVmZXJlbmNlLCAnY2xpY2snLCBvblRyaWdnZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBub2RlID0gX3JlZi5ub2RlLFxuICAgICAgICAgIGV2ZW50VHlwZSA9IF9yZWYuZXZlbnRUeXBlLFxuICAgICAgICAgIGhhbmRsZXIgPSBfcmVmLmhhbmRsZXIsXG4gICAgICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIH0pO1xuICAgIGxpc3RlbmVycyA9IFtdO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlNdXRhdGlvbnMoaW5zdGFuY2UpIHtcbiAgICB2YXIgb3JpZ2luYWxEZXN0cm95ID0gaW5zdGFuY2UuZGVzdHJveTtcblxuICAgIGluc3RhbmNlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoc2hvdWxkRGVzdHJveUNoaWxkSW5zdGFuY2VzKSB7XG4gICAgICBpZiAoc2hvdWxkRGVzdHJveUNoaWxkSW5zdGFuY2VzID09PSB2b2lkIDApIHtcbiAgICAgICAgc2hvdWxkRGVzdHJveUNoaWxkSW5zdGFuY2VzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNob3VsZERlc3Ryb3lDaGlsZEluc3RhbmNlcykge1xuICAgICAgICBjaGlsZFRpcHB5SW5zdGFuY2VzLmZvckVhY2goZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgICAgaW5zdGFuY2UuZGVzdHJveSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY2hpbGRUaXBweUluc3RhbmNlcyA9IFtdO1xuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgIG9yaWdpbmFsRGVzdHJveSgpO1xuICAgIH07XG5cbiAgICBhZGRFdmVudExpc3RlbmVycyhpbnN0YW5jZSk7XG4gIH1cblxuICBub3JtYWxpemVkUmV0dXJuVmFsdWUuZm9yRWFjaChhcHBseU11dGF0aW9ucyk7XG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cblxudmFyIGFuaW1hdGVGaWxsID0ge1xuICBuYW1lOiAnYW5pbWF0ZUZpbGwnLFxuICBkZWZhdWx0VmFsdWU6IGZhbHNlLFxuICBmbjogZnVuY3Rpb24gZm4oaW5zdGFuY2UpIHtcbiAgICB2YXIgX2luc3RhbmNlJHByb3BzJHJlbmRlO1xuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmICghKChfaW5zdGFuY2UkcHJvcHMkcmVuZGUgPSBpbnN0YW5jZS5wcm9wcy5yZW5kZXIpID09IG51bGwgPyB2b2lkIDAgOiBfaW5zdGFuY2UkcHJvcHMkcmVuZGUuJCR0aXBweSkpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgZXJyb3JXaGVuKGluc3RhbmNlLnByb3BzLmFuaW1hdGVGaWxsLCAnVGhlIGBhbmltYXRlRmlsbGAgcGx1Z2luIHJlcXVpcmVzIHRoZSBkZWZhdWx0IHJlbmRlciBmdW5jdGlvbi4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIHZhciBfZ2V0Q2hpbGRyZW4gPSBnZXRDaGlsZHJlbihpbnN0YW5jZS5wb3BwZXIpLFxuICAgICAgICBib3ggPSBfZ2V0Q2hpbGRyZW4uYm94LFxuICAgICAgICBjb250ZW50ID0gX2dldENoaWxkcmVuLmNvbnRlbnQ7XG5cbiAgICB2YXIgYmFja2Ryb3AgPSBpbnN0YW5jZS5wcm9wcy5hbmltYXRlRmlsbCA/IGNyZWF0ZUJhY2tkcm9wRWxlbWVudCgpIDogbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgb25DcmVhdGU6IGZ1bmN0aW9uIG9uQ3JlYXRlKCkge1xuICAgICAgICBpZiAoYmFja2Ryb3ApIHtcbiAgICAgICAgICBib3guaW5zZXJ0QmVmb3JlKGJhY2tkcm9wLCBib3guZmlyc3RFbGVtZW50Q2hpbGQpO1xuICAgICAgICAgIGJveC5zZXRBdHRyaWJ1dGUoJ2RhdGEtYW5pbWF0ZWZpbGwnLCAnJyk7XG4gICAgICAgICAgYm94LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICAgICAgaW5zdGFuY2Uuc2V0UHJvcHMoe1xuICAgICAgICAgICAgYXJyb3c6IGZhbHNlLFxuICAgICAgICAgICAgYW5pbWF0aW9uOiAnc2hpZnQtYXdheSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uTW91bnQ6IGZ1bmN0aW9uIG9uTW91bnQoKSB7XG4gICAgICAgIGlmIChiYWNrZHJvcCkge1xuICAgICAgICAgIHZhciB0cmFuc2l0aW9uRHVyYXRpb24gPSBib3guc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uO1xuICAgICAgICAgIHZhciBkdXJhdGlvbiA9IE51bWJlcih0cmFuc2l0aW9uRHVyYXRpb24ucmVwbGFjZSgnbXMnLCAnJykpOyAvLyBUaGUgY29udGVudCBzaG91bGQgZmFkZSBpbiBhZnRlciB0aGUgYmFja2Ryb3AgaGFzIG1vc3RseSBmaWxsZWQgdGhlXG4gICAgICAgICAgLy8gdG9vbHRpcCBlbGVtZW50LiBgY2xpcC1wYXRoYCBpcyB0aGUgb3RoZXIgYWx0ZXJuYXRpdmUgYnV0IGlzIG5vdFxuICAgICAgICAgIC8vIHdlbGwtc3VwcG9ydGVkIGFuZCBpcyBidWdneSBvbiBzb21lIGRldmljZXMuXG5cbiAgICAgICAgICBjb250ZW50LnN0eWxlLnRyYW5zaXRpb25EZWxheSA9IE1hdGgucm91bmQoZHVyYXRpb24gLyAxMCkgKyBcIm1zXCI7XG4gICAgICAgICAgYmFja2Ryb3Auc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gdHJhbnNpdGlvbkR1cmF0aW9uO1xuICAgICAgICAgIHNldFZpc2liaWxpdHlTdGF0ZShbYmFja2Ryb3BdLCAndmlzaWJsZScpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25TaG93OiBmdW5jdGlvbiBvblNob3coKSB7XG4gICAgICAgIGlmIChiYWNrZHJvcCkge1xuICAgICAgICAgIGJhY2tkcm9wLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwbXMnO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25IaWRlOiBmdW5jdGlvbiBvbkhpZGUoKSB7XG4gICAgICAgIGlmIChiYWNrZHJvcCkge1xuICAgICAgICAgIHNldFZpc2liaWxpdHlTdGF0ZShbYmFja2Ryb3BdLCAnaGlkZGVuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVCYWNrZHJvcEVsZW1lbnQoKSB7XG4gIHZhciBiYWNrZHJvcCA9IGRpdigpO1xuICBiYWNrZHJvcC5jbGFzc05hbWUgPSBCQUNLRFJPUF9DTEFTUztcbiAgc2V0VmlzaWJpbGl0eVN0YXRlKFtiYWNrZHJvcF0sICdoaWRkZW4nKTtcbiAgcmV0dXJuIGJhY2tkcm9wO1xufVxuXG52YXIgZm9sbG93Q3Vyc29yID0ge1xuICBuYW1lOiAnZm9sbG93Q3Vyc29yJyxcbiAgZGVmYXVsdFZhbHVlOiBmYWxzZSxcbiAgZm46IGZ1bmN0aW9uIGZuKGluc3RhbmNlKSB7XG4gICAgdmFyIHJlZmVyZW5jZSA9IGluc3RhbmNlLnJlZmVyZW5jZTtcbiAgICB2YXIgZG9jID0gZ2V0T3duZXJEb2N1bWVudChpbnN0YW5jZS5wcm9wcy50cmlnZ2VyVGFyZ2V0IHx8IHJlZmVyZW5jZSk7XG4gICAgdmFyIGluaXRpYWxNb3VzZUNvb3JkcyA9IG51bGw7XG5cbiAgICBmdW5jdGlvbiBnZXRJc01hbnVhbCgpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZS5wcm9wcy50cmlnZ2VyLnRyaW0oKSA9PT0gJ21hbnVhbCc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SXNFbmFibGVkKCkge1xuICAgICAgLy8gIzU5N1xuICAgICAgdmFyIGlzVmFsaWRNb3VzZUV2ZW50ID0gZ2V0SXNNYW51YWwoKSA/IHRydWUgOiAvLyBDaGVjayBpZiBhIGtleWJvYXJkIFwiY2xpY2tcIlxuICAgICAgaW5pdGlhbE1vdXNlQ29vcmRzICE9PSBudWxsICYmICEoaW5pdGlhbE1vdXNlQ29vcmRzLmNsaWVudFggPT09IDAgJiYgaW5pdGlhbE1vdXNlQ29vcmRzLmNsaWVudFkgPT09IDApO1xuICAgICAgcmV0dXJuIGluc3RhbmNlLnByb3BzLmZvbGxvd0N1cnNvciAmJiBpc1ZhbGlkTW91c2VFdmVudDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJc0luaXRpYWxCZWhhdmlvcigpIHtcbiAgICAgIHJldHVybiBjdXJyZW50SW5wdXQuaXNUb3VjaCB8fCBpbnN0YW5jZS5wcm9wcy5mb2xsb3dDdXJzb3IgPT09ICdpbml0aWFsJyAmJiBpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5zZXRSZWZlcmVuY2VDbGllbnRSZWN0KHNob3VsZFVuc2V0KSB7XG4gICAgICBpZiAoc2hvdWxkVW5zZXQpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0UHJvcHMoe1xuICAgICAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlTGlzdGVuZXIoKSB7XG4gICAgICBpZiAoZ2V0SXNFbmFibGVkKCkpIHtcbiAgICAgICAgYWRkTGlzdGVuZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVuc2V0UmVmZXJlbmNlQ2xpZW50UmVjdChpbnN0YW5jZS5wcm9wcy5mb2xsb3dDdXJzb3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyaWdnZXJMYXN0TW91c2VNb3ZlKCkge1xuICAgICAgaWYgKGdldElzRW5hYmxlZCgpKSB7XG4gICAgICAgIG9uTW91c2VNb3ZlKGluaXRpYWxNb3VzZUNvb3Jkcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkTGlzdGVuZXIoKSB7XG4gICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKCkge1xuICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbk1vdXNlTW92ZShldmVudCkge1xuICAgICAgaW5pdGlhbE1vdXNlQ29vcmRzID0ge1xuICAgICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxuICAgICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZXG4gICAgICB9OyAvLyBJZiB0aGUgaW5zdGFuY2UgaXMgaW50ZXJhY3RpdmUsIGF2b2lkIHVwZGF0aW5nIHRoZSBwb3NpdGlvbiB1bmxlc3MgaXQnc1xuICAgICAgLy8gb3ZlciB0aGUgcmVmZXJlbmNlIGVsZW1lbnRcblxuICAgICAgdmFyIGlzQ3Vyc29yT3ZlclJlZmVyZW5jZSA9IGV2ZW50LnRhcmdldCA/IHJlZmVyZW5jZS5jb250YWlucyhldmVudC50YXJnZXQpIDogdHJ1ZTtcbiAgICAgIHZhciBmb2xsb3dDdXJzb3IgPSBpbnN0YW5jZS5wcm9wcy5mb2xsb3dDdXJzb3I7XG4gICAgICB2YXIgY2xpZW50WCA9IGV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgY2xpZW50WSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICB2YXIgcmVjdCA9IHJlZmVyZW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciByZWxhdGl2ZVggPSBjbGllbnRYIC0gcmVjdC5sZWZ0O1xuICAgICAgdmFyIHJlbGF0aXZlWSA9IGNsaWVudFkgLSByZWN0LnRvcDtcblxuICAgICAgaWYgKGlzQ3Vyc29yT3ZlclJlZmVyZW5jZSB8fCAhaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0UHJvcHMoe1xuICAgICAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6IGZ1bmN0aW9uIGdldFJlZmVyZW5jZUNsaWVudFJlY3QoKSB7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IHJlZmVyZW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHZhciB4ID0gY2xpZW50WDtcbiAgICAgICAgICAgIHZhciB5ID0gY2xpZW50WTtcblxuICAgICAgICAgICAgaWYgKGZvbGxvd0N1cnNvciA9PT0gJ2luaXRpYWwnKSB7XG4gICAgICAgICAgICAgIHggPSByZWN0LmxlZnQgKyByZWxhdGl2ZVg7XG4gICAgICAgICAgICAgIHkgPSByZWN0LnRvcCArIHJlbGF0aXZlWTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRvcCA9IGZvbGxvd0N1cnNvciA9PT0gJ2hvcml6b250YWwnID8gcmVjdC50b3AgOiB5O1xuICAgICAgICAgICAgdmFyIHJpZ2h0ID0gZm9sbG93Q3Vyc29yID09PSAndmVydGljYWwnID8gcmVjdC5yaWdodCA6IHg7XG4gICAgICAgICAgICB2YXIgYm90dG9tID0gZm9sbG93Q3Vyc29yID09PSAnaG9yaXpvbnRhbCcgPyByZWN0LmJvdHRvbSA6IHk7XG4gICAgICAgICAgICB2YXIgbGVmdCA9IGZvbGxvd0N1cnNvciA9PT0gJ3ZlcnRpY2FsJyA/IHJlY3QubGVmdCA6IHg7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB3aWR0aDogcmlnaHQgLSBsZWZ0LFxuICAgICAgICAgICAgICBoZWlnaHQ6IGJvdHRvbSAtIHRvcCxcbiAgICAgICAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgICAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgICAgICAgICAgYm90dG9tOiBib3R0b20sXG4gICAgICAgICAgICAgIGxlZnQ6IGxlZnRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGdldElzSW5pdGlhbEJlaGF2aW9yKCkpIHtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgb25BZnRlclVwZGF0ZTogZnVuY3Rpb24gb25BZnRlclVwZGF0ZShfLCBfcmVmKSB7XG4gICAgICAgIHZhciBmb2xsb3dDdXJzb3IgPSBfcmVmLmZvbGxvd0N1cnNvcjtcblxuICAgICAgICBpZiAoZm9sbG93Q3Vyc29yICE9PSB1bmRlZmluZWQgJiYgIWZvbGxvd0N1cnNvcikge1xuICAgICAgICAgIHVuc2V0UmVmZXJlbmNlQ2xpZW50UmVjdCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uTW91bnQ6IGZ1bmN0aW9uIG9uTW91bnQoKSB7XG4gICAgICAgIHRyaWdnZXJMYXN0TW91c2VNb3ZlKCk7XG4gICAgICB9LFxuICAgICAgb25TaG93OiBmdW5jdGlvbiBvblNob3coKSB7XG4gICAgICAgIGlmIChnZXRJc01hbnVhbCgpKSB7XG4gICAgICAgICAgLy8gU2luY2UgdGhlcmUncyBubyB0cmlnZ2VyIGV2ZW50IHRvIHVzZSwgd2UgaGF2ZSB0byB1c2UgdGhlc2UgYXNcbiAgICAgICAgICAvLyBiYXNlbGluZSBjb29yZHNcbiAgICAgICAgICBpbml0aWFsTW91c2VDb29yZHMgPSB7XG4gICAgICAgICAgICBjbGllbnRYOiAwLFxuICAgICAgICAgICAgY2xpZW50WTogMFxuICAgICAgICAgIH07XG4gICAgICAgICAgaGFuZGxlTW91c2VNb3ZlTGlzdGVuZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uVHJpZ2dlcjogZnVuY3Rpb24gb25UcmlnZ2VyKF8sIGV2ZW50KSB7XG4gICAgICAgIC8vIFRhcHBpbmcgb24gdG91Y2ggZGV2aWNlcyBjYW4gdHJpZ2dlciBgbW91c2VlbnRlcmAgdGhlbiBgZm9jdXNgXG4gICAgICAgIGlmIChpbml0aWFsTW91c2VDb29yZHMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNNb3VzZUV2ZW50KGV2ZW50KSkge1xuICAgICAgICAgIGluaXRpYWxNb3VzZUNvb3JkcyA9IHtcbiAgICAgICAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhbmRsZU1vdXNlTW92ZUxpc3RlbmVyKCk7XG4gICAgICB9LFxuICAgICAgb25VbnRyaWdnZXI6IGZ1bmN0aW9uIG9uVW50cmlnZ2VyKCkge1xuICAgICAgICAvLyBJZiB1bnRyaWdnZXJlZCBiZWZvcmUgc2hvd2luZyAoYG9uSGlkZGVuYCB3aWxsIG5ldmVyIGJlIGludm9rZWQpXG4gICAgICAgIGlmICghaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoKTtcbiAgICAgICAgICBpbml0aWFsTW91c2VDb29yZHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25IaWRkZW46IGZ1bmN0aW9uIG9uSGlkZGVuKCkge1xuICAgICAgICByZW1vdmVMaXN0ZW5lcigpO1xuICAgICAgICBpbml0aWFsTW91c2VDb29yZHMgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldFByb3BzKHByb3BzLCBtb2RpZmllcikge1xuICB2YXIgX3Byb3BzJHBvcHBlck9wdGlvbnM7XG5cbiAgcmV0dXJuIHtcbiAgICBwb3BwZXJPcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBwcm9wcy5wb3BwZXJPcHRpb25zLCB7XG4gICAgICBtb2RpZmllcnM6IFtdLmNvbmNhdCgoKChfcHJvcHMkcG9wcGVyT3B0aW9ucyA9IHByb3BzLnBvcHBlck9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfcHJvcHMkcG9wcGVyT3B0aW9ucy5tb2RpZmllcnMpIHx8IFtdKS5maWx0ZXIoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBfcmVmLm5hbWU7XG4gICAgICAgIHJldHVybiBuYW1lICE9PSBtb2RpZmllci5uYW1lO1xuICAgICAgfSksIFttb2RpZmllcl0pXG4gICAgfSlcbiAgfTtcbn1cblxudmFyIGlubGluZVBvc2l0aW9uaW5nID0ge1xuICBuYW1lOiAnaW5saW5lUG9zaXRpb25pbmcnLFxuICBkZWZhdWx0VmFsdWU6IGZhbHNlLFxuICBmbjogZnVuY3Rpb24gZm4oaW5zdGFuY2UpIHtcbiAgICB2YXIgcmVmZXJlbmNlID0gaW5zdGFuY2UucmVmZXJlbmNlO1xuXG4gICAgZnVuY3Rpb24gaXNFbmFibGVkKCkge1xuICAgICAgcmV0dXJuICEhaW5zdGFuY2UucHJvcHMuaW5saW5lUG9zaXRpb25pbmc7XG4gICAgfVxuXG4gICAgdmFyIHBsYWNlbWVudDtcbiAgICB2YXIgY3Vyc29yUmVjdEluZGV4ID0gLTE7XG4gICAgdmFyIGlzSW50ZXJuYWxVcGRhdGUgPSBmYWxzZTtcbiAgICB2YXIgbW9kaWZpZXIgPSB7XG4gICAgICBuYW1lOiAndGlwcHlJbmxpbmVQb3NpdGlvbmluZycsXG4gICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgcGhhc2U6ICdhZnRlcldyaXRlJyxcbiAgICAgIGZuOiBmdW5jdGlvbiBmbihfcmVmMikge1xuICAgICAgICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZTtcblxuICAgICAgICBpZiAoaXNFbmFibGVkKCkpIHtcbiAgICAgICAgICBpZiAocGxhY2VtZW50ICE9PSBzdGF0ZS5wbGFjZW1lbnQpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnNldFByb3BzKHtcbiAgICAgICAgICAgICAgZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdDogZnVuY3Rpb24gZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldFJlZmVyZW5jZUNsaWVudFJlY3Qoc3RhdGUucGxhY2VtZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGxhY2VtZW50ID0gc3RhdGUucGxhY2VtZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9nZXRSZWZlcmVuY2VDbGllbnRSZWN0KHBsYWNlbWVudCkge1xuICAgICAgcmV0dXJuIGdldElubGluZUJvdW5kaW5nQ2xpZW50UmVjdChnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCksIHJlZmVyZW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgYXJyYXlGcm9tKHJlZmVyZW5jZS5nZXRDbGllbnRSZWN0cygpKSwgY3Vyc29yUmVjdEluZGV4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRJbnRlcm5hbFByb3BzKHBhcnRpYWxQcm9wcykge1xuICAgICAgaXNJbnRlcm5hbFVwZGF0ZSA9IHRydWU7XG4gICAgICBpbnN0YW5jZS5zZXRQcm9wcyhwYXJ0aWFsUHJvcHMpO1xuICAgICAgaXNJbnRlcm5hbFVwZGF0ZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZE1vZGlmaWVyKCkge1xuICAgICAgaWYgKCFpc0ludGVybmFsVXBkYXRlKSB7XG4gICAgICAgIHNldEludGVybmFsUHJvcHMoZ2V0UHJvcHMoaW5zdGFuY2UucHJvcHMsIG1vZGlmaWVyKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9uQ3JlYXRlOiBhZGRNb2RpZmllcixcbiAgICAgIG9uQWZ0ZXJVcGRhdGU6IGFkZE1vZGlmaWVyLFxuICAgICAgb25UcmlnZ2VyOiBmdW5jdGlvbiBvblRyaWdnZXIoXywgZXZlbnQpIHtcbiAgICAgICAgaWYgKGlzTW91c2VFdmVudChldmVudCkpIHtcbiAgICAgICAgICB2YXIgcmVjdHMgPSBhcnJheUZyb20oaW5zdGFuY2UucmVmZXJlbmNlLmdldENsaWVudFJlY3RzKCkpO1xuICAgICAgICAgIHZhciBjdXJzb3JSZWN0ID0gcmVjdHMuZmluZChmdW5jdGlvbiAocmVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlY3QubGVmdCAtIDIgPD0gZXZlbnQuY2xpZW50WCAmJiByZWN0LnJpZ2h0ICsgMiA+PSBldmVudC5jbGllbnRYICYmIHJlY3QudG9wIC0gMiA8PSBldmVudC5jbGllbnRZICYmIHJlY3QuYm90dG9tICsgMiA+PSBldmVudC5jbGllbnRZO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGN1cnNvclJlY3RJbmRleCA9IHJlY3RzLmluZGV4T2YoY3Vyc29yUmVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvblVudHJpZ2dlcjogZnVuY3Rpb24gb25VbnRyaWdnZXIoKSB7XG4gICAgICAgIGN1cnNvclJlY3RJbmRleCA9IC0xO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBnZXRJbmxpbmVCb3VuZGluZ0NsaWVudFJlY3QoY3VycmVudEJhc2VQbGFjZW1lbnQsIGJvdW5kaW5nUmVjdCwgY2xpZW50UmVjdHMsIGN1cnNvclJlY3RJbmRleCkge1xuICAvLyBOb3QgYW4gaW5saW5lIGVsZW1lbnQsIG9yIHBsYWNlbWVudCBpcyBub3QgeWV0IGtub3duXG4gIGlmIChjbGllbnRSZWN0cy5sZW5ndGggPCAyIHx8IGN1cnJlbnRCYXNlUGxhY2VtZW50ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGJvdW5kaW5nUmVjdDtcbiAgfSAvLyBUaGVyZSBhcmUgdHdvIHJlY3RzIGFuZCB0aGV5IGFyZSBkaXNqb2luZWRcblxuXG4gIGlmIChjbGllbnRSZWN0cy5sZW5ndGggPT09IDIgJiYgY3Vyc29yUmVjdEluZGV4ID49IDAgJiYgY2xpZW50UmVjdHNbMF0ubGVmdCA+IGNsaWVudFJlY3RzWzFdLnJpZ2h0KSB7XG4gICAgcmV0dXJuIGNsaWVudFJlY3RzW2N1cnNvclJlY3RJbmRleF0gfHwgYm91bmRpbmdSZWN0O1xuICB9XG5cbiAgc3dpdGNoIChjdXJyZW50QmFzZVBsYWNlbWVudCkge1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIGZpcnN0UmVjdCA9IGNsaWVudFJlY3RzWzBdO1xuICAgICAgICB2YXIgbGFzdFJlY3QgPSBjbGllbnRSZWN0c1tjbGllbnRSZWN0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIGlzVG9wID0gY3VycmVudEJhc2VQbGFjZW1lbnQgPT09ICd0b3AnO1xuICAgICAgICB2YXIgdG9wID0gZmlyc3RSZWN0LnRvcDtcbiAgICAgICAgdmFyIGJvdHRvbSA9IGxhc3RSZWN0LmJvdHRvbTtcbiAgICAgICAgdmFyIGxlZnQgPSBpc1RvcCA/IGZpcnN0UmVjdC5sZWZ0IDogbGFzdFJlY3QubGVmdDtcbiAgICAgICAgdmFyIHJpZ2h0ID0gaXNUb3AgPyBmaXJzdFJlY3QucmlnaHQgOiBsYXN0UmVjdC5yaWdodDtcbiAgICAgICAgdmFyIHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICAgICAgICB2YXIgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRvcDogdG9wLFxuICAgICAgICAgIGJvdHRvbTogYm90dG9tLFxuICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgY2FzZSAnbGVmdCc6XG4gICAgY2FzZSAncmlnaHQnOlxuICAgICAge1xuICAgICAgICB2YXIgbWluTGVmdCA9IE1hdGgubWluLmFwcGx5KE1hdGgsIGNsaWVudFJlY3RzLm1hcChmdW5jdGlvbiAocmVjdHMpIHtcbiAgICAgICAgICByZXR1cm4gcmVjdHMubGVmdDtcbiAgICAgICAgfSkpO1xuICAgICAgICB2YXIgbWF4UmlnaHQgPSBNYXRoLm1heC5hcHBseShNYXRoLCBjbGllbnRSZWN0cy5tYXAoZnVuY3Rpb24gKHJlY3RzKSB7XG4gICAgICAgICAgcmV0dXJuIHJlY3RzLnJpZ2h0O1xuICAgICAgICB9KSk7XG4gICAgICAgIHZhciBtZWFzdXJlUmVjdHMgPSBjbGllbnRSZWN0cy5maWx0ZXIoZnVuY3Rpb24gKHJlY3QpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudEJhc2VQbGFjZW1lbnQgPT09ICdsZWZ0JyA/IHJlY3QubGVmdCA9PT0gbWluTGVmdCA6IHJlY3QucmlnaHQgPT09IG1heFJpZ2h0O1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIF90b3AgPSBtZWFzdXJlUmVjdHNbMF0udG9wO1xuICAgICAgICB2YXIgX2JvdHRvbSA9IG1lYXN1cmVSZWN0c1ttZWFzdXJlUmVjdHMubGVuZ3RoIC0gMV0uYm90dG9tO1xuICAgICAgICB2YXIgX2xlZnQgPSBtaW5MZWZ0O1xuICAgICAgICB2YXIgX3JpZ2h0ID0gbWF4UmlnaHQ7XG5cbiAgICAgICAgdmFyIF93aWR0aCA9IF9yaWdodCAtIF9sZWZ0O1xuXG4gICAgICAgIHZhciBfaGVpZ2h0ID0gX2JvdHRvbSAtIF90b3A7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0b3A6IF90b3AsXG4gICAgICAgICAgYm90dG9tOiBfYm90dG9tLFxuICAgICAgICAgIGxlZnQ6IF9sZWZ0LFxuICAgICAgICAgIHJpZ2h0OiBfcmlnaHQsXG4gICAgICAgICAgd2lkdGg6IF93aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IF9oZWlnaHRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBib3VuZGluZ1JlY3Q7XG4gICAgICB9XG4gIH1cbn1cblxudmFyIHN0aWNreSA9IHtcbiAgbmFtZTogJ3N0aWNreScsXG4gIGRlZmF1bHRWYWx1ZTogZmFsc2UsXG4gIGZuOiBmdW5jdGlvbiBmbihpbnN0YW5jZSkge1xuICAgIHZhciByZWZlcmVuY2UgPSBpbnN0YW5jZS5yZWZlcmVuY2UsXG4gICAgICAgIHBvcHBlciA9IGluc3RhbmNlLnBvcHBlcjtcblxuICAgIGZ1bmN0aW9uIGdldFJlZmVyZW5jZSgpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZSA/IGluc3RhbmNlLnBvcHBlckluc3RhbmNlLnN0YXRlLmVsZW1lbnRzLnJlZmVyZW5jZSA6IHJlZmVyZW5jZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaG91bGRDaGVjayh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlLnByb3BzLnN0aWNreSA9PT0gdHJ1ZSB8fCBpbnN0YW5jZS5wcm9wcy5zdGlja3kgPT09IHZhbHVlO1xuICAgIH1cblxuICAgIHZhciBwcmV2UmVmUmVjdCA9IG51bGw7XG4gICAgdmFyIHByZXZQb3BSZWN0ID0gbnVsbDtcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVBvc2l0aW9uKCkge1xuICAgICAgdmFyIGN1cnJlbnRSZWZSZWN0ID0gc2hvdWxkQ2hlY2soJ3JlZmVyZW5jZScpID8gZ2V0UmVmZXJlbmNlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiBudWxsO1xuICAgICAgdmFyIGN1cnJlbnRQb3BSZWN0ID0gc2hvdWxkQ2hlY2soJ3BvcHBlcicpID8gcG9wcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogbnVsbDtcblxuICAgICAgaWYgKGN1cnJlbnRSZWZSZWN0ICYmIGFyZVJlY3RzRGlmZmVyZW50KHByZXZSZWZSZWN0LCBjdXJyZW50UmVmUmVjdCkgfHwgY3VycmVudFBvcFJlY3QgJiYgYXJlUmVjdHNEaWZmZXJlbnQocHJldlBvcFJlY3QsIGN1cnJlbnRQb3BSZWN0KSkge1xuICAgICAgICBpZiAoaW5zdGFuY2UucG9wcGVySW5zdGFuY2UpIHtcbiAgICAgICAgICBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwcmV2UmVmUmVjdCA9IGN1cnJlbnRSZWZSZWN0O1xuICAgICAgcHJldlBvcFJlY3QgPSBjdXJyZW50UG9wUmVjdDtcblxuICAgICAgaWYgKGluc3RhbmNlLnN0YXRlLmlzTW91bnRlZCkge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodXBkYXRlUG9zaXRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBvbk1vdW50OiBmdW5jdGlvbiBvbk1vdW50KCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UucHJvcHMuc3RpY2t5KSB7XG4gICAgICAgICAgdXBkYXRlUG9zaXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGFyZVJlY3RzRGlmZmVyZW50KHJlY3RBLCByZWN0Qikge1xuICBpZiAocmVjdEEgJiYgcmVjdEIpIHtcbiAgICByZXR1cm4gcmVjdEEudG9wICE9PSByZWN0Qi50b3AgfHwgcmVjdEEucmlnaHQgIT09IHJlY3RCLnJpZ2h0IHx8IHJlY3RBLmJvdHRvbSAhPT0gcmVjdEIuYm90dG9tIHx8IHJlY3RBLmxlZnQgIT09IHJlY3RCLmxlZnQ7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxudGlwcHkuc2V0RGVmYXVsdFByb3BzKHtcbiAgcmVuZGVyOiByZW5kZXJcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCB0aXBweTtcbmV4cG9ydCB7IGFuaW1hdGVGaWxsLCBjcmVhdGVTaW5nbGV0b24sIGRlbGVnYXRlLCBmb2xsb3dDdXJzb3IsIGhpZGVBbGwsIGlubGluZVBvc2l0aW9uaW5nLCBST1VORF9BUlJPVyBhcyByb3VuZEFycm93LCBzdGlja3kgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpcHB5LmVzbS5qcy5tYXBcbiIsIi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xudmFyIGJ5dGVUb0hleCA9IFtdO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXhbaV0gPSAoaSArIDB4MTAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpO1xufVxuXG5mdW5jdGlvbiBieXRlc1RvVXVpZChidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IG9mZnNldCB8fCAwO1xuICB2YXIgYnRoID0gYnl0ZVRvSGV4O1xuICAvLyBqb2luIHVzZWQgdG8gZml4IG1lbW9yeSBpc3N1ZSBjYXVzZWQgYnkgY29uY2F0ZW5hdGlvbjogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzE3NSNjNFxuICByZXR1cm4gKFtidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCBcblx0YnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcblx0YnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dXSkuam9pbignJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnl0ZXNUb1V1aWQ7XG4iLCIvLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiAgSW4gdGhlXG4vLyBicm93c2VyIHRoaXMgaXMgYSBsaXR0bGUgY29tcGxpY2F0ZWQgZHVlIHRvIHVua25vd24gcXVhbGl0eSBvZiBNYXRoLnJhbmRvbSgpXG4vLyBhbmQgaW5jb25zaXN0ZW50IHN1cHBvcnQgZm9yIHRoZSBgY3J5cHRvYCBBUEkuICBXZSBkbyB0aGUgYmVzdCB3ZSBjYW4gdmlhXG4vLyBmZWF0dXJlLWRldGVjdGlvblxuXG4vLyBnZXRSYW5kb21WYWx1ZXMgbmVlZHMgdG8gYmUgaW52b2tlZCBpbiBhIGNvbnRleHQgd2hlcmUgXCJ0aGlzXCIgaXMgYSBDcnlwdG9cbi8vIGltcGxlbWVudGF0aW9uLiBBbHNvLCBmaW5kIHRoZSBjb21wbGV0ZSBpbXBsZW1lbnRhdGlvbiBvZiBjcnlwdG8gb24gSUUxMS5cbnZhciBnZXRSYW5kb21WYWx1ZXMgPSAodHlwZW9mKGNyeXB0bykgIT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQoY3J5cHRvKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mKG1zQ3J5cHRvKSAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93Lm1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PSAnZnVuY3Rpb24nICYmIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKG1zQ3J5cHRvKSk7XG5cbmlmIChnZXRSYW5kb21WYWx1ZXMpIHtcbiAgLy8gV0hBVFdHIGNyeXB0byBSTkcgLSBodHRwOi8vd2lraS53aGF0d2cub3JnL3dpa2kvQ3J5cHRvXG4gIHZhciBybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2hhdHdnUk5HKCkge1xuICAgIGdldFJhbmRvbVZhbHVlcyhybmRzOCk7XG4gICAgcmV0dXJuIHJuZHM4O1xuICB9O1xufSBlbHNlIHtcbiAgLy8gTWF0aC5yYW5kb20oKS1iYXNlZCAoUk5HKVxuICAvL1xuICAvLyBJZiBhbGwgZWxzZSBmYWlscywgdXNlIE1hdGgucmFuZG9tKCkuICBJdCdzIGZhc3QsIGJ1dCBpcyBvZiB1bnNwZWNpZmllZFxuICAvLyBxdWFsaXR5LlxuICB2YXIgcm5kcyA9IG5ldyBBcnJheSgxNik7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtYXRoUk5HKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCByOyBpIDwgMTY7IGkrKykge1xuICAgICAgaWYgKChpICYgMHgwMykgPT09IDApIHIgPSBNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDA7XG4gICAgICBybmRzW2ldID0gciA+Pj4gKChpICYgMHgwMykgPDwgMykgJiAweGZmO1xuICAgIH1cblxuICAgIHJldHVybiBybmRzO1xuICB9O1xufVxuIiwidmFyIHJuZyA9IHJlcXVpcmUoJy4vbGliL3JuZycpO1xudmFyIGJ5dGVzVG9VdWlkID0gcmVxdWlyZSgnLi9saWIvYnl0ZXNUb1V1aWQnKTtcblxuLy8gKipgdjEoKWAgLSBHZW5lcmF0ZSB0aW1lLWJhc2VkIFVVSUQqKlxuLy9cbi8vIEluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9MaW9zSy9VVUlELmpzXG4vLyBhbmQgaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L3V1aWQuaHRtbFxuXG52YXIgX25vZGVJZDtcbnZhciBfY2xvY2tzZXE7XG5cbi8vIFByZXZpb3VzIHV1aWQgY3JlYXRpb24gdGltZVxudmFyIF9sYXN0TVNlY3MgPSAwO1xudmFyIF9sYXN0TlNlY3MgPSAwO1xuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2Jyb29mYS9ub2RlLXV1aWQgZm9yIEFQSSBkZXRhaWxzXG5mdW5jdGlvbiB2MShvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcbiAgdmFyIGIgPSBidWYgfHwgW107XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBub2RlID0gb3B0aW9ucy5ub2RlIHx8IF9ub2RlSWQ7XG4gIHZhciBjbG9ja3NlcSA9IG9wdGlvbnMuY2xvY2tzZXEgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2xvY2tzZXEgOiBfY2xvY2tzZXE7XG5cbiAgLy8gbm9kZSBhbmQgY2xvY2tzZXEgbmVlZCB0byBiZSBpbml0aWFsaXplZCB0byByYW5kb20gdmFsdWVzIGlmIHRoZXkncmUgbm90XG4gIC8vIHNwZWNpZmllZC4gIFdlIGRvIHRoaXMgbGF6aWx5IHRvIG1pbmltaXplIGlzc3VlcyByZWxhdGVkIHRvIGluc3VmZmljaWVudFxuICAvLyBzeXN0ZW0gZW50cm9weS4gIFNlZSAjMTg5XG4gIGlmIChub2RlID09IG51bGwgfHwgY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgIHZhciBzZWVkQnl0ZXMgPSBybmcoKTtcbiAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAvLyBQZXIgNC41LCBjcmVhdGUgYW5kIDQ4LWJpdCBub2RlIGlkLCAoNDcgcmFuZG9tIGJpdHMgKyBtdWx0aWNhc3QgYml0ID0gMSlcbiAgICAgIG5vZGUgPSBfbm9kZUlkID0gW1xuICAgICAgICBzZWVkQnl0ZXNbMF0gfCAweDAxLFxuICAgICAgICBzZWVkQnl0ZXNbMV0sIHNlZWRCeXRlc1syXSwgc2VlZEJ5dGVzWzNdLCBzZWVkQnl0ZXNbNF0sIHNlZWRCeXRlc1s1XVxuICAgICAgXTtcbiAgICB9XG4gICAgaWYgKGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjIuMiwgcmFuZG9taXplICgxNCBiaXQpIGNsb2Nrc2VxXG4gICAgICBjbG9ja3NlcSA9IF9jbG9ja3NlcSA9IChzZWVkQnl0ZXNbNl0gPDwgOCB8IHNlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG4gICAgfVxuICB9XG5cbiAgLy8gVVVJRCB0aW1lc3RhbXBzIGFyZSAxMDAgbmFuby1zZWNvbmQgdW5pdHMgc2luY2UgdGhlIEdyZWdvcmlhbiBlcG9jaCxcbiAgLy8gKDE1ODItMTAtMTUgMDA6MDApLiAgSlNOdW1iZXJzIGFyZW4ndCBwcmVjaXNlIGVub3VnaCBmb3IgdGhpcywgc29cbiAgLy8gdGltZSBpcyBoYW5kbGVkIGludGVybmFsbHkgYXMgJ21zZWNzJyAoaW50ZWdlciBtaWxsaXNlY29uZHMpIGFuZCAnbnNlY3MnXG4gIC8vICgxMDAtbmFub3NlY29uZHMgb2Zmc2V0IGZyb20gbXNlY3MpIHNpbmNlIHVuaXggZXBvY2gsIDE5NzAtMDEtMDEgMDA6MDAuXG4gIHZhciBtc2VjcyA9IG9wdGlvbnMubXNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubXNlY3MgOiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAvLyBQZXIgNC4yLjEuMiwgdXNlIGNvdW50IG9mIHV1aWQncyBnZW5lcmF0ZWQgZHVyaW5nIHRoZSBjdXJyZW50IGNsb2NrXG4gIC8vIGN5Y2xlIHRvIHNpbXVsYXRlIGhpZ2hlciByZXNvbHV0aW9uIGNsb2NrXG4gIHZhciBuc2VjcyA9IG9wdGlvbnMubnNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubnNlY3MgOiBfbGFzdE5TZWNzICsgMTtcblxuICAvLyBUaW1lIHNpbmNlIGxhc3QgdXVpZCBjcmVhdGlvbiAoaW4gbXNlY3MpXG4gIHZhciBkdCA9IChtc2VjcyAtIF9sYXN0TVNlY3MpICsgKG5zZWNzIC0gX2xhc3ROU2VjcykvMTAwMDA7XG5cbiAgLy8gUGVyIDQuMi4xLjIsIEJ1bXAgY2xvY2tzZXEgb24gY2xvY2sgcmVncmVzc2lvblxuICBpZiAoZHQgPCAwICYmIG9wdGlvbnMuY2xvY2tzZXEgPT09IHVuZGVmaW5lZCkge1xuICAgIGNsb2Nrc2VxID0gY2xvY2tzZXEgKyAxICYgMHgzZmZmO1xuICB9XG5cbiAgLy8gUmVzZXQgbnNlY3MgaWYgY2xvY2sgcmVncmVzc2VzIChuZXcgY2xvY2tzZXEpIG9yIHdlJ3ZlIG1vdmVkIG9udG8gYSBuZXdcbiAgLy8gdGltZSBpbnRlcnZhbFxuICBpZiAoKGR0IDwgMCB8fCBtc2VjcyA+IF9sYXN0TVNlY3MpICYmIG9wdGlvbnMubnNlY3MgPT09IHVuZGVmaW5lZCkge1xuICAgIG5zZWNzID0gMDtcbiAgfVxuXG4gIC8vIFBlciA0LjIuMS4yIFRocm93IGVycm9yIGlmIHRvbyBtYW55IHV1aWRzIGFyZSByZXF1ZXN0ZWRcbiAgaWYgKG5zZWNzID49IDEwMDAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1dWlkLnYxKCk6IENhblxcJ3QgY3JlYXRlIG1vcmUgdGhhbiAxME0gdXVpZHMvc2VjJyk7XG4gIH1cblxuICBfbGFzdE1TZWNzID0gbXNlY3M7XG4gIF9sYXN0TlNlY3MgPSBuc2VjcztcbiAgX2Nsb2Nrc2VxID0gY2xvY2tzZXE7XG5cbiAgLy8gUGVyIDQuMS40IC0gQ29udmVydCBmcm9tIHVuaXggZXBvY2ggdG8gR3JlZ29yaWFuIGVwb2NoXG4gIG1zZWNzICs9IDEyMjE5MjkyODAwMDAwO1xuXG4gIC8vIGB0aW1lX2xvd2BcbiAgdmFyIHRsID0gKChtc2VjcyAmIDB4ZmZmZmZmZikgKiAxMDAwMCArIG5zZWNzKSAlIDB4MTAwMDAwMDAwO1xuICBiW2krK10gPSB0bCA+Pj4gMjQgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gMTYgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsICYgMHhmZjtcblxuICAvLyBgdGltZV9taWRgXG4gIHZhciB0bWggPSAobXNlY3MgLyAweDEwMDAwMDAwMCAqIDEwMDAwKSAmIDB4ZmZmZmZmZjtcbiAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdG1oICYgMHhmZjtcblxuICAvLyBgdGltZV9oaWdoX2FuZF92ZXJzaW9uYFxuICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMTYgJiAweGZmO1xuXG4gIC8vIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYCAoUGVyIDQuMi4yIC0gaW5jbHVkZSB2YXJpYW50KVxuICBiW2krK10gPSBjbG9ja3NlcSA+Pj4gOCB8IDB4ODA7XG5cbiAgLy8gYGNsb2NrX3NlcV9sb3dgXG4gIGJbaSsrXSA9IGNsb2Nrc2VxICYgMHhmZjtcblxuICAvLyBgbm9kZWBcbiAgZm9yICh2YXIgbiA9IDA7IG4gPCA2OyArK24pIHtcbiAgICBiW2kgKyBuXSA9IG5vZGVbbl07XG4gIH1cblxuICByZXR1cm4gYnVmID8gYnVmIDogYnl0ZXNUb1V1aWQoYik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdjE7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL2xpYi9waXhlbHNjaHVic2VyL3V0aWxzJyk7XG5cbnZhciBDYXJldCA9IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICB0aGlzLnNlbGVjdGlvbmNoYW5nZVN1YnNjcmliZXJzID0gW107XG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgICAgaWYoc2VsZi5faXNTZWxlY3Rpb25Qcm9jZXNzZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgc2VsZi5fbWFya1NlbGVjdGlvbkFzUHJvY2Vzc2VkKHNlbGVjdGlvbilcbiAgICAgICAgICAgIGZvcihsZXQgaT0wOyBpPHNlbGYuc2VsZWN0aW9uY2hhbmdlU3Vic2NyaWJlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGlvbmNoYW5nZVN1YnNjcmliZXJzW2ldKHNlbGVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuQ2FyZXQucHJvdG90eXBlID0ge1xuXG4gICAgc3Vic2NyaWJlU2VsZWN0aW9uQ2hhbmdlOiBmdW5jdGlvbihmKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uY2hhbmdlU3Vic2NyaWJlcnMucHVzaChmKTtcbiAgICB9LFxuXG4gICAgX21hcmtTZWxlY3Rpb25Bc1Byb2Nlc3NlZDogZnVuY3Rpb24oc2VsZWN0aW9uKSB7XG4gICAgICAgIHRoaXMubGFzdFByb2Nlc3NlZFNlbGVjdGlvbkNoYW5nZSA9IHtcbiAgICAgICAgICAgIGFuY2hvck5vZGU6IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgICAgICAgYW5jaG9yT2Zmc2V0OiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgICAgICAgZm9jdXNOb2RlOiBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgICAgICAgZm9jdXNPZmZzZXQ6IHNlbGVjdGlvbi5mb2N1c09mZnNldFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBfaXNTZWxlY3Rpb25Qcm9jZXNzZWQ6IGZ1bmN0aW9uKHNlbGVjdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMubGFzdFByb2Nlc3NlZFNlbGVjdGlvbkNoYW5nZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgdGhpcy5sYXN0UHJvY2Vzc2VkU2VsZWN0aW9uQ2hhbmdlLmFuY2hvck5vZGUgIT09ICBzZWxlY3Rpb24uYW5jaG9yTm9kZSB8fFxuICAgICAgICAgICAgIHRoaXMubGFzdFByb2Nlc3NlZFNlbGVjdGlvbkNoYW5nZS5hbmNob3JPZmZzZXQgIT09ICBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0IHx8XG4gICAgICAgICAgICAgdGhpcy5sYXN0UHJvY2Vzc2VkU2VsZWN0aW9uQ2hhbmdlLmZvY3VzTm9kZSAhPT0gIHNlbGVjdGlvbi5mb2N1c05vZGUgfHxcbiAgICAgICAgICAgICB0aGlzLmxhc3RQcm9jZXNzZWRTZWxlY3Rpb25DaGFuZ2UuZm9jdXNPZmZzZXQgIT09ICBzZWxlY3Rpb24uZm9jdXNPZmZzZXRcbiAgICB9LFxuXG4gICAgX2dldEVsZW1lbnRzQ29udGVudExlbmd0aEluY3JlbWVudDogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICBpZihbJ0JSJywgJ0lNRyddLmluY2x1ZGVzKGVsZW1lbnQudGFnTmFtZSkpIHJldHVybiAxO1xuXG4gICAgICAgIGlmKGVsZW1lbnQgJiYgZWxlbWVudC5jbGFzc0xpc3QgJiYgZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ3RvYy1jb250ZW50JykpIHJldHVybiAwO1xuICAgICAgICBpZihlbGVtZW50ICYmIGVsZW1lbnQuY2xhc3NMaXN0ICYmIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdtaXNzaW5nTGV2ZWxIaW50JykpIHJldHVybiAwO1xuXG4gICAgICAgIGlmKGVsZW1lbnQudGFnTmFtZSA9PT0gJ0xJJyAmJiBlbGVtZW50LmlubmVyVGV4dCA9PT0gJycpIHJldHVybiAxO1xuICAgICAgICBpZihlbGVtZW50LmdldEF0dHJpYnV0ZSAmJiBlbGVtZW50LmdldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykgPT09ICdmYWxzZScpIHJldHVybiAxO1xuICAgICAgICBpZih0aGlzLndpdGhpblVuZWRpZGFibGVSZWZlcmVuY2VFbChlbGVtZW50KSkgcmV0dXJuIDA7XG5cbiAgICAgICAgaWYoWydDQVBUSU9OJywgJ0ZJR0NBUFRJT04nLCAnQ0lURVNSQyddLmluY2x1ZGVzKGVsZW1lbnQudGFnTmFtZSkgJiYgKGVsZW1lbnQuY2hpbGRyZW4gJiYgZWxlbWVudC5jaGlsZHJlbi5sZW5ndGgpID09PSAwKSB7IC8vRml4bWU6IFNob3VsZCBpdCBub3QgYmUgY2hpbGROb2RlcyBpbnN0ZWFkIG9mIGNoaWxkcmVuXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFlbGVtZW50Lmxlbmd0aCkgcmV0dXJuIDA7XG4gICAgICAgIHJldHVybiBlbGVtZW50Lmxlbmd0aDtcbiAgICB9LFxuXG4gICAgLy8gZXhhbXBsZSBJbnB1dDogIFwidGVzdDxzcGFuIGNsYXNzPVwiZm9vdG5vdGVcIiBkYXRhLW5vdGU9XCJub3RlIG51bWJlciAxMVwiIGNvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCI+MTE8L3NwYW4+IHRoZSBlZGl0b3IgaW50ZXJmYWNlIHRvIHJlc3RvcmVYIHNlbGVjdGlvblwiXG4gICAgLy8gZXhhbXBsZSBPdXRwdXQ6IFwidGVzdF8gdGhlIGVkaXRvciBpbnRlcmZhY2UgdG8gcmVzdG9yZVggc2VsZWN0aW9uXCJcbiAgICAvLyAtPiBiZWNhdXNlIHdlIGNhbm5vdCBwbGFjZSB0aGUgY2FyZXQgd2l0aGluIHRoZSBmb290bm90ZSAob3IgcmVmZXJlbmNlLCBpbmxpbmUgZXF1YXRpb24sIHRvYyBzZWN0aW9uKVxuICAgIC8vIHdlIHJlcGxhY2UgdGhlIGZvb3Rlbm90ZSB3aXRoIG9uZSBwbGFjZWhvbGRlciBjaGFyLlxuICAgIF9nZXRDb250ZW50TGVuZ3RoSW5jcmVtZW50TWFza2VkVGV4dDogZnVuY3Rpb24ocm9vdEVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuXG5cbiAgICAgICAgaWYocm9vdEVsZW1lbnQubGVuZ3RoICYmIHJvb3RFbGVtZW50LnRleHRDb250ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gcm9vdEVsZW1lbnQudGV4dENvbnRlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICByb290RWxlbWVudC5jaGlsZE5vZGVzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgICAgICBpZihbJ0JSJywgJ0lNRyddLmluY2x1ZGVzKGVsZW1lbnQudGFnTmFtZSkpIHsgcmVzdWx0ICs9ICdfJzsgfVxuICAgICAgICAgICAgZWxzZSBpZihlbGVtZW50ICYmIGVsZW1lbnQuY2xhc3NMaXN0ICYmIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCd0b2MtY29udGVudCcpKSB7IHJlc3VsdCArPSAnJzsgfVxuICAgICAgICAgICAgZWxzZSBpZihlbGVtZW50ICYmIGVsZW1lbnQuY2xhc3NMaXN0ICYmIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdtaXNzaW5nTGV2ZWxIaW50JykpIHsgcmVzdWx0ICs9ICcnOyB9XG4gICAgICAgICAgICBlbHNlIGlmKGVsZW1lbnQudGFnTmFtZSA9PT0gJ0xJJyAmJiBlbGVtZW50LmlubmVyVGV4dCA9PT0gJycpIHsgcmVzdWx0ICs9ICdfJzsgfVxuICAgICAgICAgICAgZWxzZSBpZihlbGVtZW50LmdldEF0dHJpYnV0ZSAmJiBlbGVtZW50LmdldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykgPT09ICdmYWxzZScpIHsgcmVzdWx0ICs9ICdfJzsgfVxuICAgICAgICAgICAgZWxzZSBpZih0aGlzLndpdGhpblVuZWRpZGFibGVSZWZlcmVuY2VFbChlbGVtZW50KSkgeyByZXN1bHQgKz0gJyc7IH1cblxuICAgICAgICAgICAgZWxzZSBpZihbJ0NBUFRJT04nLCAnRklHQ0FQVElPTicsICdDSVRFU1JDJ10uaW5jbHVkZXMoZWxlbWVudC50YWdOYW1lKSAmJiAoZWxlbWVudC5jaGlsZE5vZGVzICYmIGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdfJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLl9nZXRDb250ZW50TGVuZ3RoSW5jcmVtZW50TWFza2VkVGV4dChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBfZ2V0Q29udGVudExlbmd0aE9mRE9NRWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCwgZW5kQ2hpbGQpIHtcbiAgICAgICAgaWYoIWVuZENoaWxkICYmIGVsZW1lbnQuc3VtbWFyaXplZENvbnRlbnRMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50LnN1bW1hcml6ZWRDb250ZW50TGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVuZFNlY3Rpb24gPSBlbmRDaGlsZCAmJiB1dGlscy5nZXRTdWJ0cmVlQnlDaGlsZE5vZGUoZWxlbWVudCwgZW5kQ2hpbGQpLFxuICAgICAgICAgICAgZW5kU2VjdGlvbkluZGV4ID0gZW5kU2VjdGlvbiAmJiBlbGVtZW50LmNoaWxkcmVuLmluZGV4T2YoZW5kU2VjdGlvbiksXG4gICAgICAgICAgICB0cmVlV2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihlbmRTZWN0aW9uIHx8IGVsZW1lbnQpLFxuICAgICAgICAgICAgbGVuZ3RoID0gMCxcbiAgICAgICAgICAgIGN1cnJlbnRFbDtcblxuICAgICAgICBpZihlbmRTZWN0aW9uKSB7XG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaTxlbmRTZWN0aW9uSW5kZXg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxlbmd0aCArPSB0aGlzLl9nZXRDb250ZW50TGVuZ3RoT2ZET01FbGVtZW50KGVsZW1lbnQuY2hpbGRyZW5baV0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSgoY3VycmVudEVsID0gdHJlZVdhbGtlci5jdXJyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgIGlmKGN1cnJlbnRFbCA9PT0gZW5kQ2hpbGQpIHJldHVybiBsZW5ndGg7XG4gICAgICAgICAgICBsZW5ndGggKz0gdGhpcy5fZ2V0RWxlbWVudHNDb250ZW50TGVuZ3RoSW5jcmVtZW50KGN1cnJlbnRFbCk7XG5cbiAgICAgICAgICAgIGlmKCF0cmVlV2Fsa2VyLm5leHROb2RlKCkpIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIWVuZENoaWxkKSB7XG4gICAgICAgICAgICBlbGVtZW50LnN1bW1hcml6ZWRDb250ZW50TGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9LFxuXG4gICAgX3dhbGtUb05leHRFZGl0YWJsZU5vZGU6IGZ1bmN0aW9uKHRyZWVXYWxrZXIpIHtcbiAgICAgICAgdmFyIGNhbmRpZHRlID0gdHJlZVdhbGtlci5uZXh0Tm9kZSgpO1xuICAgICAgICBpZighY2FuZGlkdGUpIHsgcmV0dXJuIGNhbmRpZHRlIH1cblxuICAgICAgICB3aGlsZSh0aGlzLndpdGhpblVuZWRpZGFibGVSZWZlcmVuY2VFbChjYW5kaWR0ZSkpIHtcbiAgICAgICAgICAgIGNhbmRpZHRlID0gdHJlZVdhbGtlci5uZXh0Tm9kZSgpO1xuICAgICAgICAgICAgaWYoIWNhbmRpZHRlKSB7IHJldHVybiBjYW5kaWR0ZSB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FuZGlkdGU7XG4gICAgfSxcblxuICAgIC8vIHJpZ2h0TWF0Y2g6IHdoZW4gcm9vdCBlbGVtZW50IGNvbnRhaW5zOiAnPHA+SGVsbG88L3A+PHA+V29ybGQ8L3A+JyBhbmQgY29udGVudExlbmd0aCBpcyAnNSdcbiAgICAvLyAgICAgICAgICAgICBpdCBpcyBub3QgY2xlYXIgd2hpY2ggZWxlbWVudCB0byByZXR1cm4sIGlmIHJpZ2h0TWF0Y2ggaXMgdHJ1ZSB0aGVuICc8cD5Xb3JsZDwvcD4nIHdpbGxcbiAgICAvLyAgICAgICAgICAgICBiZSByZXR1cm5lZCwgJzxwPkhlbGxvPC9wPicgb3RoZXJ3aXNlXG4gICAgX2dldEVsZW1lbnRCeUNvbnRlbnRMZW5ndGg6IGZ1bmN0aW9uKHJvb3RFbCwgY29udGVudExlbmd0aCwgcmlnaHRNYXRjaCkge1xuICAgICAgICB2YXIgdHJlZVdhbGtlciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIocm9vdEVsKSxcbiAgICAgICAgICAgIGN1cnJlbnRFbCxcbiAgICAgICAgICAgIGxlbmd0aCA9IDAsXG4gICAgICAgICAgICBjdXJyZW50RWxMZW5ndGg7XG5cbiAgICAgICAgd2hpbGUoY3VycmVudEVsID0gdHJlZVdhbGtlci5jdXJyZW50Tm9kZSkge1xuICAgICAgICAgICAgY3VycmVudEVsTGVuZ3RoID0gdGhpcy5fZ2V0RWxlbWVudHNDb250ZW50TGVuZ3RoSW5jcmVtZW50KGN1cnJlbnRFbCk7XG5cbiAgICAgICAgICAgIGlmKChsZW5ndGggKyBjdXJyZW50RWxMZW5ndGgpIDwgY29udGVudExlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxlbmd0aCArPSBjdXJyZW50RWxMZW5ndGg7XG4gICAgICAgICAgICB9IGVsc2UgaWYoKGxlbmd0aCArIGN1cnJlbnRFbExlbmd0aCkgPT09IGNvbnRlbnRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmlnaHRNYXRjaCA/ICh0aGlzLl93YWxrVG9OZXh0RWRpdGFibGVOb2RlKHRyZWVXYWxrZXIpIHx8IGN1cnJlbnRFbCkgOiBjdXJyZW50RWw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50RWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCF0cmVlV2Fsa2VyLm5leHROb2RlKCkpIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIF9nZXRGaXJzdFBhcmVudFdoaWNoTWF0Y2hDb250ZXh0OiBmdW5jdGlvbihub2RlLCBjb250ZXh0KSB7XG4gICAgICAgIGlmKCFub2RlKSByZXR1cm47XG5cbiAgICAgICAgdmFyIHRtcE5vZGUgPSBub2RlLFxuICAgICAgICAgICAgY29udGV4dFR5cGUsXG4gICAgICAgICAgICBtYXRjaEZucztcblxuICAgICAgICBpZighQXJyYXkuaXNBcnJheShjb250ZXh0KSkge1xuICAgICAgICAgICAgY29udGV4dCA9IFtjb250ZXh0XVxuICAgICAgICB9XG5cbiAgICAgICAgbWF0Y2hGbnMgPSBjb250ZXh0Lm1hcChmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgIGlmKGN0eC5zdGFydHNXaXRoKCcuJykpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0VHlwZSA9ICdjbGFzcyc7XG4gICAgICAgICAgICAgICAgY3R4ID0gY3R4LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGV4dFR5cGUgPSAndGFnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoKGNvbnRleHRUeXBlID09PSAndGFnJyB8fCAhY29udGV4dFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtyZXR1cm4gbm9kZS50YWdOYW1lICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBjdHh9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihub2RlKSB7cmV0dXJuIG5vZGUuY2xhc3NMaXN0ICYmIG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKGN0eCl9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgd2hpbGUodG1wTm9kZSkge1xuICAgICAgICAgICAgaWYobWF0Y2hGbnMuc29tZShmdW5jdGlvbihtYXRjaEZuKSB7cmV0dXJuIG1hdGNoRm4odG1wTm9kZSl9KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0bXBOb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0bXBOb2RlID0gdG1wTm9kZS5wYXJlbnRFbGVtZW50O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGlzV2l0aGluRWxlbWVudDogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgdmFyIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblxuICAgICAgICByZXR1cm4gc2VsLmZvY3VzTm9kZSAmJlxuICAgICAgICAgICAgICAgc2VsLmFuY2hvck5vZGUgJiZcbiAgICAgICAgICAgICAgIGVsLmNvbnRhaW5zKHNlbC5mb2N1c05vZGUpICYmXG4gICAgICAgICAgICAgICBlbC5jb250YWlucyhzZWwuYW5jaG9yTm9kZSlcbiAgICB9LFxuXG4gICAgZ2V0UHJlY2VkaW5nQ2hhcmFjdGVyOiBmdW5jdGlvbihjb250ZXh0RWxlbWVudCkge1xuICAgICAgICB2YXIgcHJlY2VkaW5nQ2hhciA9ICcnLCBzZWwsIHJhbmdlO1xuICAgICAgICB2YXIgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgICBpZiAoc2VsLnJhbmdlQ291bnQgPiAwKSB7XG4gICAgICAgICAgICByYW5nZSA9IHNlbC5nZXRSYW5nZUF0KDApLmNsb25lUmFuZ2UoKTtcbiAgICAgICAgICAgIHJhbmdlLmNvbGxhcHNlKHRydWUpO1xuICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoY29udGV4dEVsZW1lbnQsIDApO1xuICAgICAgICAgICAgcHJlY2VkaW5nQ2hhciA9IHJhbmdlLnRvU3RyaW5nKCkuc2xpY2UoLTEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmVjZWRpbmdDaGFyO1xuICAgIH0sXG5cbiAgICBpc1ByZWNlZGluZ0NoYXJhY3RlcldoaXRlc3BhY2U6IGZ1bmN0aW9uKGNvbnRleHRFbGVtZW50KSB7XG4gICAgICAgIHZhciBwcmVjZWRpbmdDaGFyYWN0ZXIgPSBDYXJldC5wcm90b3R5cGUuZ2V0UHJlY2VkaW5nQ2hhcmFjdGVyKGNvbnRleHRFbGVtZW50KSxcbiAgICAgICAgICAgIHByZWNlZGluZ0NoYXJhY3RlckNvZGU7XG5cbiAgICAgICAgaWYoIXByZWNlZGluZ0NoYXJhY3RlcikgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgICBwcmVjZWRpbmdDaGFyYWN0ZXJDb2RlID0gcHJlY2VkaW5nQ2hhcmFjdGVyLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIHJldHVybiAocHJlY2VkaW5nQ2hhcmFjdGVyQ29kZSA9PT0gMzIgfHwgcHJlY2VkaW5nQ2hhcmFjdGVyQ29kZSA9PT0gMTYwKTtcbiAgICB9LFxuXG4gICAgaXNDb2xsYXBzZWRBbmRQb3NpdGlvbmVkQXRUaGVGaXJzdExpbmVPZjogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBpZighbm9kZS5vZmZzZXRUb3ApIHsgcmV0dXJuIH1cblxuICAgICAgICBpZihub2RlLmlubmVyVGV4dCA9PT0gJycgJiYgKG5vZGUudGFnTmFtZSA9PT0gJ09MJyB8fCBub2RlLnRhZ05hbWUgPT09ICdVTCcpKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0RWwgPSB0aGlzLmdldENvbnRleHRFbGVtZW50KCdsaScpO1xuICAgICAgICAgICAgaWYodGFyZ2V0RWwgJiYgdGFyZ2V0RWwgIT09IG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKG5vZGUuaW5uZXJUZXh0ID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpLFxuICAgICAgICAgICAgY2FyZXRQb3MgPSB0aGlzLmdldFBvc2l0aW9uKCksXG4gICAgICAgICAgICBjYXJldFBvc1kgPSBjYXJldFBvcyAmJiBjYXJldFBvcy55LFxuICAgICAgICAgICAgcGFkZGluZ1RvcCA9IHBhcnNlSW50KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3BhZGRpbmctdG9wJykpLFxuICAgICAgICAgICAgbGluZUhlaWdodCA9IHBhcnNlSW50KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ2xpbmUtaGVpZ2h0JykpLFxuICAgICAgICAgICAgZmlyc3RMaW5lU3RhcnRZUG9zID0gbm9kZS5vZmZzZXRUb3AgKyBwYWRkaW5nVG9wLFxuICAgICAgICAgICAgZmlyc3RMaW5lRW5kWVBvcyA9IGZpcnN0TGluZVN0YXJ0WVBvcyArIGxpbmVIZWlnaHQ7XG5cbiAgICAgICAgcmV0dXJuIGZpcnN0TGluZVN0YXJ0WVBvcyA8IGNhcmV0UG9zWSAmJiBmaXJzdExpbmVFbmRZUG9zID4gY2FyZXRQb3NZO1xuICAgIH0sXG5cbiAgICBpc0NvbGxhcHNlZEFuZFBvc2l0aW9uZWRBdFRoZUxhc3RMaW5lT2Y6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgaWYoIW5vZGUub2Zmc2V0VG9wKSB7IHJldHVybiB9XG4gICAgICAgIGlmKG5vZGUuaW5uZXJUZXh0ID09PSAnJykgeyByZXR1cm4gdHJ1ZSB9XG5cbiAgICAgICAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSksXG4gICAgICAgICAgICBjYXJldFBvcyA9IHRoaXMuZ2V0UG9zaXRpb24oKSxcbiAgICAgICAgICAgIGNhcmV0UG9zWSA9IGNhcmV0UG9zICYmIGNhcmV0UG9zLnksXG4gICAgICAgICAgICBwYWRkaW5nQm90dG9tID0gcGFyc2VJbnQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgncGFkZGluZy1ib3R0b20nKSksXG4gICAgICAgICAgICBsaW5lSGVpZ2h0ID0gcGFyc2VJbnQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnbGluZS1oZWlnaHQnKSksXG4gICAgICAgICAgICBib3JkZXJCb3R0b20gPSAxLFxuICAgICAgICAgICAgbGFzdExpbmVFbmRZUG9zID0gKG5vZGUub2Zmc2V0VG9wICsgbm9kZS5vZmZzZXRIZWlnaHQpIC0gcGFkZGluZ0JvdHRvbSAtIGJvcmRlckJvdHRvbSxcbiAgICAgICAgICAgIGxhc3RMaW5lU3RhcnRZUG9zID0gbGFzdExpbmVFbmRZUG9zIC0gbGluZUhlaWdodCAtIDEwO1xuXG4gICAgICAgIHJldHVybiBsYXN0TGluZUVuZFlQb3MgPiBjYXJldFBvc1kgJiYgbGFzdExpbmVTdGFydFlQb3MgPCBjYXJldFBvc1k7XG4gICAgfSxcblxuICAgIGlzQ29sbGFwc2VkQW5kUG9zaXRpb25lZEF0VGhlQmVnaW5uaW5nT2Y6IGZ1bmN0aW9uKG5vZGUsIGlnbm9yZUZpcnN0Q2hhcklmV2hpdGVzcGFjZSkge1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpLFxuICAgICAgICAgICAgcG9zO1xuXG4gICAgICAgIGlnbm9yZUZpcnN0Q2hhcklmV2hpdGVzcGFjZSA9IGlnbm9yZUZpcnN0Q2hhcklmV2hpdGVzcGFjZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGlnbm9yZUZpcnN0Q2hhcklmV2hpdGVzcGFjZTtcblxuICAgICAgICBpZighc2VsZWN0aW9uLmlzQ29sbGFwc2VkIHx8ICFub2RlKSB7IHJldHVybiBmYWxzZSB9XG5cbiAgICAgICAgcG9zID0gdGhpcy5fZ2V0Q29udGVudExlbmd0aE9mRE9NRWxlbWVudChub2RlLCBzZWxlY3Rpb24uYW5jaG9yTm9kZSkgKyBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0O1xuICAgICAgICBpZihpZ25vcmVGaXJzdENoYXJJZldoaXRlc3BhY2UgJiZcbiAgICAgICAgICAgcG9zID09PSAxICYmXG4gICAgICAgICAgIG5vZGUuY2hpbGROb2RlcyAmJiBub2RlLmNoaWxkTm9kZXNbMF0gPT09IHNlbGVjdGlvbi5hbmNob3JOb2RlICYmXG4gICAgICAgICAgIChzZWxlY3Rpb24uZm9jdXNOb2RlLm5vZGVWYWx1ZSAmJiAoc2VsZWN0aW9uLmZvY3VzTm9kZS5ub2RlVmFsdWVbMF0gPT09ICdcXHUwMEEwJyB8fCBzZWxlY3Rpb24uZm9jdXNOb2RlLm5vZGVWYWx1ZVswXSA9PT0gJyAnKSkpIHtcblxuICAgICAgICAgICAgLy8gd2hlbiB0aGUgZmlyc3Qgbm9kZSBvZiB0aGUgc2VjdGlvbiBpcyBmb2N1c2VkIGFuZCBpdCBzdGFydHMgd2l0aFxuICAgICAgICAgICAgLy8gYSB3aGl0ZSBzcGFjZSB3ZSBkbyBub3QgbWluZCB3aGV0aGVyIHRoZSBjYXJldCBpcyBwbGFjZWQgcmlnaHQgb3JcbiAgICAgICAgICAgIC8vIGxlZnQgZnJvbSB0aGF0IHdoaXRlc3BhY2UuIFRoaXMgaXMgYmVjYXVzZSBmb3Igc29tZSByZWFzb24gdGhlIGJyb3dzZXJcbiAgICAgICAgICAgIC8vIGp1c3QgZG9lcyBub3QgZGlzcGxheSB0aGlzIHdoaXRlc3BhY2UgPyE/IT8gQmxhbWUgdGhpcyBsaW5lIGluIGdpdFxuICAgICAgICAgICAgLy8gYW5kIHNlZSB0aGUgc3BlYyBpbiB0aGUgc2FtZSBjb21taXQgdG8gZ2V0IG1vcmUgZGV0YWlscyBhYm91dCB0aGlzXG4gICAgICAgICAgICAvLyBzcGVjaWZjIHNjZW5hcmlvLlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9zID09PSAwO1xuICAgIH0sXG5cbiAgICBpc0NvbGxhcHNlZEFuZFBvc2l0aW9uZWRBdFRoZUVuZE9mOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCksXG4gICAgICAgICAgICBwb3MsIG5vZGVMZW5ndGgsIGxhc3RFbDtcblxuICAgICAgICBpZighc2VsZWN0aW9uLmlzQ29sbGFwc2VkIHx8ICFub2RlKSB7IHJldHVybiBmYWxzZSB9XG5cbiAgICAgICAgaWYoc2VsZWN0aW9uLmFuY2hvck5vZGUgPT09IG5vZGUgJiYgc2VsZWN0aW9uLmFuY2hvck9mZnNldCA9PT0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBwb3MgPSB0aGlzLl9nZXRDb250ZW50TGVuZ3RoT2ZET01FbGVtZW50KG5vZGUsIHNlbGVjdGlvbi5hbmNob3JOb2RlKSArIHNlbGVjdGlvbi5hbmNob3JPZmZzZXQ7XG4gICAgICAgIG5vZGVMZW5ndGggPSB0aGlzLl9nZXRDb250ZW50TGVuZ3RoT2ZET01FbGVtZW50KG5vZGUpO1xuXG4gICAgICAgIGlmKHBvcyA9PT0gbm9kZUxlbmd0aC0xICYmIG5vZGUuaW5uZXJUZXh0W25vZGUuaW5uZXJUZXh0Lmxlbmd0aC0xXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvcyA9PT0gbm9kZUxlbmd0aDtcbiAgICB9LFxuXG4gICAgcG9zaXRpb25BdFRoZUJlZ2lubmluZ09mOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCksXG4gICAgICAgICAgICBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgICAgcmFuZ2Uuc2V0RW5kKG5vZGUsIDApO1xuICAgICAgICByYW5nZS5zZXRTdGFydChub2RlLCAwKTtcbiAgICAgICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgIH0sXG5cbiAgICBwb3NpdGlvbkFmdGVyOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciBub2RlSW5kZXgsXG4gICAgICAgICAgICByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCksXG4gICAgICAgICAgICBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCksXG4gICAgICAgICAgICB1bmVkaXRhYmxlUGFyZW50ID0gdGhpcy53aXRoaW5VbmVkaWRhYmxlUmVmZXJlbmNlRWwobm9kZSk7XG5cbiAgICAgICAgaWYodW5lZGl0YWJsZVBhcmVudCkge1xuICAgICAgICAgICAgbm9kZSA9IHVuZWRpdGFibGVQYXJlbnRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgbm9kZUluZGV4ID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChub2RlLnBhcmVudE5vZGUuY2hpbGROb2Rlcywgbm9kZSk7XG4gICAgICAgICAgICByYW5nZS5zZXRFbmQobm9kZS5wYXJlbnROb2RlLCBub2RlSW5kZXgrMSk7XG4gICAgICAgICAgICByYW5nZS5zZXRTdGFydChub2RlLnBhcmVudE5vZGUsIG5vZGVJbmRleCsxKTtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcG9zaXRpb25JbjogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpLFxuICAgICAgICAgICAgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuXG4gICAgICAgIHJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhub2RlKTtcbiAgICAgICAgcmFuZ2UuY29sbGFwc2UoKTtcbiAgICAgICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgIH0sXG5cbiAgICBtb2RpZnlSYW5nZVRvQmVWYWxpZEluc2VydFBvc2l0aW9uOiBmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICB2YXIgbm9kZSA9IHJhbmdlICYmIHJhbmdlLmNvbGxhcHNlZCAmJiByYW5nZS5zdGFydENvbnRhaW5lcixcbiAgICAgICAgICAgIGZpcnN0TEk7XG5cbiAgICAgICAgaWYobm9kZSAmJiBbJ1VMJywgJ09MJ10uaW5jbHVkZXMobm9kZS50YWdOYW1lKSAmJiByYW5nZS5zdGFydE9mZnNldCA9PT0gMCkge1xuICAgICAgICAgICAgaWYoZmlyc3RMSSA9IG5vZGUucXVlcnlTZWxlY3RvcignbGknKSkge1xuICAgICAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KGZpcnN0TEksIDApO1xuICAgICAgICAgICAgICAgIHJhbmdlLnNldEVuZChmaXJzdExJLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICB9LFxuXG4gICAgaW5zZXJ0Tm9kZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSxcbiAgICAgICAgICAgIHJhbmdlID0gc2VsLmdldFJhbmdlQXQoMCk7XG5cbiAgICAgICAgdGhpcy5tb2RpZnlSYW5nZVRvQmVWYWxpZEluc2VydFBvc2l0aW9uKHJhbmdlKTtcbiAgICAgICAgcmFuZ2UuaW5zZXJ0Tm9kZShub2RlKTtcbiAgICAgICAgcmFuZ2UuY29sbGFwc2UoKTtcbiAgICAgICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICBzZWwuYWRkUmFuZ2UocmFuZ2UpO1xuXG4gICAgICAgIGlmKG5vZGUubmV4dFNpYmxpbmcgJiYgbm9kZS5uZXh0U2libGluZy5ub2RlVmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICBub2RlLm5leHRTaWJsaW5nLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGluc2VydExpbmVCcmVhazogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnInKSxcbiAgICAgICAgICAgIGZvY3VzZWRTZWN0aW9uID0gdGhpcy5lZGl0b3IuZm9jdXNlZFNlY3Rpb24oKSxcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5lZGl0b3IuaW5kZXhPZkZvY3VzZWRTZWN0aW9uKCksXG4gICAgICAgICAgICBuZXh0U2VjdGlvbiA9IDE7XG5cbiAgICAgICAgaWYodGhpcy5pc1Bvc2l0aW9uZWRBdFRoZUJlZ2lubmluZ09mRm9jdXNOb2RlKHdpbmRvdy5nZXRTZWxlY3Rpb24oKSkpIHtcbiAgICAgICAgICAgIG5leHRTZWN0aW9uID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZWRpdG9yLmNhcmV0Lmluc2VydE5vZGUobm9kZSk7XG4gICAgICAgIHRoaXMuZWRpdG9yLnJlcGxhY2VTZWN0aW9uV2l0aEhUTUwoZm9jdXNlZFNlY3Rpb24sIGZvY3VzZWRTZWN0aW9uLm91dGVySFRNTCwge1xuICAgICAgICAgICAgcG9zaXRpb25DYXJldEF0VGhlRW5kT2ZTZWN0aW9uV2l0aEluZGV4OiBpbmRleCtuZXh0U2VjdGlvblxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgd2l0aGluVW5lZGlkYWJsZVJlZmVyZW5jZUVsOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIGlmKG5vZGUgJiYgbm9kZS5pc0NvbnRlbnRFZGl0YWJsZSkgeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgICAgIHZhciBzZWwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCksXG4gICAgICAgICAgICB0bXBOb2RlID0gbm9kZSB8fCBzZWwuZm9jdXNOb2RlO1xuXG4gICAgICAgIGlmKCF0bXBOb2RlKSB7IHJldHVybiBmYWxzZSB9XG5cbiAgICAgICAgd2hpbGUodG1wTm9kZSkge1xuICAgICAgICAgICAgaWYodG1wTm9kZS5pc0NvbnRlbnRFZGl0YWJsZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYodG1wTm9kZS5nZXRBdHRyaWJ1dGUgJiYgdG1wTm9kZS5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpID09PSAnZmFsc2UnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRtcE5vZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRtcE5vZGUgPSB0bXBOb2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIGlzUG9zaXRpb25lZEF0VGhlRW5kT2ZGb2N1c05vZGU6IGZ1bmN0aW9uKHNlbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gc2VsZWN0aW9uLmlzQ29sbGFwc2VkICYmXG4gICAgICAgICAgICAgICBzZWxlY3Rpb24uZm9jdXNOb2RlICYmXG4gICAgICAgICAgICAgICBzZWxlY3Rpb24uZm9jdXNPZmZzZXQgPT09IHNlbGVjdGlvbi5mb2N1c05vZGUubGVuZ3RoO1xuICAgIH0sXG5cbiAgICBpc1Bvc2l0aW9uZWRBdFRoZUJlZ2lubmluZ09mRm9jdXNOb2RlOiBmdW5jdGlvbihzZWxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvbi5pc0NvbGxhcHNlZCAmJlxuICAgICAgICAgICAgICAgc2VsZWN0aW9uLmZvY3VzTm9kZSAmJlxuICAgICAgICAgICAgICAgc2VsZWN0aW9uLmZvY3VzT2Zmc2V0ID09PSAwO1xuICAgIH0sXG5cbiAgICBnZXRUYW5nZXROb2RlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSxcbiAgICAgICAgICAgIHRhbmdlbnROb2RlcyA9IHtsZWZ0OiBudWxsLCByaWdodDogbnVsbH0sXG4gICAgICAgICAgICBub2RlSXRlcmF0b3IsXG4gICAgICAgICAgICBlbnN1cmVTYW1lU2VjdGlvbiA9IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gfTtcblxuICAgICAgICBpZih0aGlzLmVkaXRvciAmJiBzZWxmLmVkaXRvci5mb2N1c2VkU2VjdGlvbikge1xuICAgICAgICAgICAgZW5zdXJlU2FtZVNlY3Rpb24gPSBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgICAgICAgaWYobiAmJiBzZWxmLmVkaXRvci5mb2N1c2VkU2VjdGlvbigpID09PSBzZWxmLmVkaXRvci5zZWN0aW9uQnlDaGlsZE5vZGUobikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoc2VsZWN0aW9uICYmIHNlbGVjdGlvbi5mb2N1c05vZGUgJiYgc2VsZWN0aW9uLmZvY3VzTm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbGVmdDogc2VsZWN0aW9uLmZvY3VzTm9kZS5jaGlsZE5vZGVzW3NlbGVjdGlvbi5mb2N1c09mZnNldC0xXSxcbiAgICAgICAgICAgICAgICByaWdodDogc2VsZWN0aW9uLmZvY3VzTm9kZS5jaGlsZE5vZGVzW3NlbGVjdGlvbi5mb2N1c09mZnNldF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGVJdGVyYXRvciA9IHV0aWxzLmdldE5vZGVJdGVyYXRvclBvaW50aW5nVG8oc2VsZWN0aW9uLmZvY3VzTm9kZSk7XG5cbiAgICAgICAgaWYoIW5vZGVJdGVyYXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRhbmdlbnROb2RlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuaXNQb3NpdGlvbmVkQXRUaGVCZWdpbm5pbmdPZkZvY3VzTm9kZShzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICB0YW5nZW50Tm9kZXMubGVmdCA9IGVuc3VyZVNhbWVTZWN0aW9uKG5vZGVJdGVyYXRvci5wcmV2aW91c05vZGUoKSk7XG4gICAgICAgICAgICBub2RlSXRlcmF0b3IubmV4dE5vZGUoKTsgLy9tb3ZlIHRoZSBpdGVyYXRvciBiYWNrIHRvIHRoZSBmb2N1cyBub2RlXG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLmlzUG9zaXRpb25lZEF0VGhlRW5kT2ZGb2N1c05vZGUoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgdGFuZ2VudE5vZGVzLnJpZ2h0ID0gZW5zdXJlU2FtZVNlY3Rpb24obm9kZUl0ZXJhdG9yLm5leHROb2RlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhbmdlbnROb2RlcztcbiAgICB9LFxuXG4gICAgLy8gVGhpcyBtZXRob2QgZmluZHMgYSBET00gZWxlbWVudCB3aGljaCB3cmFwcyB0aGUgcGFzc2VkIHNlbGVjdGlvbiBhbmQgbWF0Y2hlcyB0aGUgY29udGV4dC5cbiAgICAvLyAgIC0gd3JhcHMgbWVhbnMsIGZvY3VzTm9kZSBhbmQgYW5jaG9yTm9kZSBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGUgZWxlbWVudFxuICAgIC8vICAgLSBtYXRjaGVzIHRoZSBjb250ZXh0IG1lYW5zLCB0aGUgcmV0dXJuZWQgZWxlbWVudCBoYXMgZWl0aGVyIChkZXBlbmRpbmcgb24gY29udGV4dFR5cGUsIHNlZSBiZWxvdylcbiAgICAvLyAgICAgdGhlIHNhbWUgdGFnTmFtZSBhcyBzcGVjaWZpZWQgaW4gY29udGV4dCwgb3IgYSBjbGFzcyBuYW1lIHNwZWNpZmllZCBpbiBjb250ZXh0XG4gICAgLy8gICAtIHRoZSBjb250ZXh0VHlwZSBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBjaGFyIG9mIHRoZSBjb250ZXh0IGFyZ3VtZW50LiBJZiBpdCBpcyAnLicgdGhlIHR5cGUgaXNcbiAgICAvLyAgICAgXCJjbGFzc1wiIHdpbGwgbWF0Y2ggYSBlbGVtZW50IHdoaWNoIGhhcyB0aGUgYWNjb3JkaW5nIGNsYXNzIGFzc2lnbmVkIGluIGl0cyBjbGFzcyBhdHRyaWJ1dGUuXG4gICAgLy8gICAgIElmIHRoZSBjb250ZXh0IGRvZXMgbm90IHN0YXJ0IHdpdGggYSAnLicgYSBlbGVtZW50IHdpdGggdGhlIGFjY29yZGluZyB0YWcgbmFtZSB3aWxsIG1hdGNoLlxuICAgIGdldENvbnRleHRFbGVtZW50OiBmdW5jdGlvbihjb250ZXh0LCBzZWxlY3Rpb24sIHRhbmdlbnROb2Rlcykge1xuICAgICAgICBzZWxlY3Rpb24gPSBzZWxlY3Rpb24gfHwgd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgICB0YW5nZW50Tm9kZXMgPSB0YW5nZW50Tm9kZXMgfHwgdGhpcy5nZXRUYW5nZXROb2RlcygpO1xuXG4gICAgICAgIGlmKHNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAwKSByZXR1cm4gbnVsbDtcblxuICAgICAgICB2YXIgY29tbW9uQW5jZXN0b3IgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKS5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtcblxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Rmlyc3RQYXJlbnRXaGljaE1hdGNoQ29udGV4dChjb21tb25BbmNlc3RvciwgY29udGV4dCkgfHxcbiAgICAgICAgICAgICAgIHRoaXMuX2dldEZpcnN0UGFyZW50V2hpY2hNYXRjaENvbnRleHQodGFuZ2VudE5vZGVzLnJpZ2h0LCBjb250ZXh0KSB8fFxuICAgICAgICAgICAgICAgdGhpcy5fZ2V0Rmlyc3RQYXJlbnRXaGljaE1hdGNoQ29udGV4dCh0YW5nZW50Tm9kZXMubGVmdCwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIGdldFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSxcbiAgICAgICAgICAgIHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCksXG4gICAgICAgICAgICByZWN0ID0gcmFuZ2UuZ2V0Q2xpZW50UmVjdHMoKVswXSxcbiAgICAgICAgICAgIHRuO1xuXG4gICAgICAgIGlmKHJlY3QpIHtcbiAgICAgICAgICByZXR1cm4ge3g6IHJlY3QubGVmdCwgeTogcmVjdC50b3AgKyB3aW5kb3cuc2Nyb2xsWSwgd2lkdGg6IHJlY3Qud2lkdGgsIGhlaWdodDogcmVjdC5oZWlnaHR9O1xuICAgICAgICB9XG5cbiAgICAgICAgdG4gPSB0aGlzLmdldFRhbmdldE5vZGVzKCk7XG5cbiAgICAgICAgaWYodG4ubGVmdCAmJiB0bi5sZWZ0Lm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICAgICAgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKHRuLmxlZnQpO1xuICAgICAgICAgICAgcmFuZ2UuY29sbGFwc2UoZmFsc2UpO1xuICAgICAgICAgICAgcmVjdCA9IHJhbmdlLmdldENsaWVudFJlY3RzKClbMF07XG4gICAgICAgICAgICByZXR1cm4ge3g6IHJlY3QubGVmdCtyZWN0LndpZHRoLCB5OiByZWN0LnRvcCArIHdpbmRvdy5zY3JvbGxZLCB3aWR0aDogMCwgaGVpZ2h0OiByZWN0LmhlaWdodH07XG4gICAgICAgIH0gZWxzZSBpZih0bi5sZWZ0KSB7XG4gICAgICAgICAgICByZWN0ID0gdG4ubGVmdC5nZXRDbGllbnRSZWN0cygpWzBdO1xuICAgICAgICAgICAgcmV0dXJuIHt4OiByZWN0LmxlZnQrcmVjdC53aWR0aCwgeTogcmVjdC50b3AgKyB3aW5kb3cuc2Nyb2xsWSwgd2lkdGg6IDAsIGhlaWdodDogcmVjdC5oZWlnaHR9O1xuICAgICAgICB9IGVsc2UgaWYoIXJlY3QgJiYgcmFuZ2Uuc3RhcnRDb250YWluZXIgPT09IHJhbmdlLmVuZENvbnRhaW5lcikgIHtcbiAgICAgICAgICAgIHJlY3QgPSByYW5nZS5zdGFydENvbnRhaW5lci5nZXRDbGllbnRSZWN0cygpWzBdO1xuICAgICAgICAgICAgcmV0dXJuIHt4OiByZWN0LmxlZnQsIHk6IHJlY3QudG9wICsgd2luZG93LnNjcm9sbFksIHdpZHRoOiByZWN0LndpZHRoLCBoZWlnaHQ6IHJlY3QuaGVpZ2h0fTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGl0IHNlZWVtcyB0aGVyZSBpcyBubyBrbm93biBzaXR1YXRpb24gaW4gd2hpY2ggd2UgaGF2ZSB0byBjb25zaWRlciB0bi5yaWdodFxuICAgIH0sXG5cbiAgICByZXN0b3JlU2VsZWN0aW9uOiBmdW5jdGlvbihtb3ZlVG9MZWZ0LCBzdHJhdGVneSkge1xuICAgICAgICBzdHJhdGVneSA9IHN0cmF0ZWd5IHx8ICdPZmZzZXRTdHJhdGVneSc7XG4gICAgICAgIGlmKHN0cmF0ZWd5ID09PSAnT2Zmc2V0U3RyYXRlZ3knKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN0b3JlU2VsZWN0aW9uVmlhT2Zmc2V0U3RyYXRlZ3kobW92ZVRvTGVmdCk7XG4gICAgICAgIH0gZWxzZSBpZihzdHJhdGVneSA9PT0gJ1RyeURPTVN0cmF0ZWd5Rmlyc3QnKSB7XG4gICAgICAgICAgICBpZighdGhpcy5yZXN0b3JlU2VsZWN0aW9uVmlhRE9NU3RyYXRlZ3koKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3RvcmVTZWxlY3Rpb25WaWFPZmZzZXRTdHJhdGVneShtb3ZlVG9MZWZ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdG9yZVNlbGVjdGlvblZpYURPTVN0cmF0ZWd5KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gcGFyYW0gJ21vdmVUb0xlZnQnOiB3aWxsIGNvcnJlY3QgdGhlIHBvaXN0aW9uIGJ5IHRoZSBnaXZlbiBhbW91bnQgb2YgY2hhclxuICAgIHJlc3RvcmVTZWxlY3Rpb25WaWFPZmZzZXRTdHJhdGVneTogZnVuY3Rpb24obW92ZVRvTGVmdCwgc2F2ZWRTZWxlY3Rpb24pIHtcbiAgICAgICAgbW92ZVRvTGVmdCA9IG1vdmVUb0xlZnQgfHwgMDtcblxuICAgICAgICBpZihzYXZlZFNlbGVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5yb290RWwgPSBzYXZlZFNlbGVjdGlvbi5yb290RWw7XG4gICAgICAgICAgICB0aGlzLnJhbmdlU3RhcnQgPSBzYXZlZFNlbGVjdGlvbi5yYW5nZVN0YXJ0O1xuICAgICAgICAgICAgdGhpcy5yYW5nZUVuZCA9IHNhdmVkU2VsZWN0aW9uLnJhbmdlRW5kO1xuICAgICAgICAgICAgdGhpcy5pc0FuY2hvckxlZnQgPSBzYXZlZFNlbGVjdGlvbi5pc0FuY2hvckxlZnQ7XG4gICAgICAgICAgICB0aGlzLnJhbmdlU3RhcnRBdFplcm9PZmZzZXQgPSBzYXZlZFNlbGVjdGlvbi5yYW5nZVN0YXJ0QXRaZXJvT2Zmc2V0O1xuICAgICAgICAgICAgdGhpcy5yYW5nZUVuZEF0WmVyb09mZnNldCA9ICBzYXZlZFNlbGVjdGlvbi5yYW5nZUVuZEF0WmVyb09mZnNldDtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uRm9jdXNOb2RlID0gc2F2ZWRTZWxlY3Rpb24uc2VsZWN0aW9uRm9jdXNOb2RlO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25BbmNob3JOb2RlID0gc2F2ZWRTZWxlY3Rpb24uc2VsZWN0aW9uQW5jaG9yTm9kZTtcbiAgICAgICAgICAgIHRoaXMucmFuZ2VTdGFydEF0WmVyb09mZnNldCA9IHNhdmVkU2VsZWN0aW9uLnJhbmdlU3RhcnRBdFplcm9PZmZzZXQ7XG4gICAgICAgICAgICB0aGlzLnJhbmdlRW5kQXRaZXJvT2Zmc2V0ID0gc2F2ZWRTZWxlY3Rpb24ucmFuZ2VFbmRBdFplcm9PZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLnNlbGVjdGlvbklzVW5lZGlkYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLmNhcnJldFBsYWNlbWVudENvcnJlY3Rpb24pIHtcbiAgICAgICAgICAgIG1vdmVUb0xlZnQgKz0gdGhpcy5jYXJyZXRQbGFjZW1lbnRDb3JyZWN0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yYW5nZVN0YXJ0QXRaZXJvT2Zmc2V0ID0gKHRoaXMuc2VsZWN0aW9uQW5jaG9yT2Zmc2V0LW1vdmVUb0xlZnQpID09PSAwO1xuICAgICAgICB0aGlzLnJhbmdlRW5kQXRaZXJvT2Zmc2V0ID0gKHRoaXMuc2VsZWN0aW9uRm9jdXNPZmZzZXQtbW92ZVRvTGVmdCkgPT09IDA7XG5cbiAgICAgICAgaWYodHlwZW9mIHRoaXMucmFuZ2VTdGFydCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHRoaXMucmFuZ2VFbmQgPT09ICdudW1iZXInKSB7XG5cbiAgICAgICAgICAgIHZhciByYW5nZSxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCksXG4gICAgICAgICAgICAgICAgc3RhcnROb2RlID0gdGhpcy5fZ2V0RWxlbWVudEJ5Q29udGVudExlbmd0aCh0aGlzLnJvb3RFbCwgdGhpcy5yYW5nZVN0YXJ0IC0gbW92ZVRvTGVmdCwgdGhpcy5yYW5nZVN0YXJ0QXRaZXJvT2Zmc2V0KSxcbiAgICAgICAgICAgICAgICBzdGFydE9mZnNldCA9IHRoaXMucmFuZ2VTdGFydCAtIG1vdmVUb0xlZnQgLSB0aGlzLl9nZXRDb250ZW50TGVuZ3RoT2ZET01FbGVtZW50KHRoaXMucm9vdEVsLCBzdGFydE5vZGUpLFxuICAgICAgICAgICAgICAgIGVuZE5vZGUsXG4gICAgICAgICAgICAgICAgZW5kT2Zmc2V0LFxuICAgICAgICAgICAgICAgIHVuZWRpYWJsZUNvbnRleEVsO1xuXG4gICAgICAgICAgICBpZih0aGlzLnNlbGVjdGlvbklzQ29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgICAgZW5kTm9kZSA9IHN0YXJ0Tm9kZTtcbiAgICAgICAgICAgICAgICBlbmRPZmZzZXQgPSBzdGFydE9mZnNldDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5kTm9kZSA9IHRoaXMuX2dldEVsZW1lbnRCeUNvbnRlbnRMZW5ndGgodGhpcy5yb290RWwsIHRoaXMucmFuZ2VFbmQgLSBtb3ZlVG9MZWZ0LCB0aGlzLnJhbmdlRW5kQXRaZXJvT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBlbmRPZmZzZXQgPSB0aGlzLnJhbmdlRW5kIC0gbW92ZVRvTGVmdCAtIHRoaXMuX2dldENvbnRlbnRMZW5ndGhPZkRPTUVsZW1lbnQodGhpcy5yb290RWwsIGVuZE5vZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1bmVkaWFibGVDb250ZXhFbCA9IHN0YXJ0Tm9kZSA9PSBlbmROb2RlICYmICh1bmVkaWFibGVDb250ZXhFbCA9IHRoaXMud2l0aGluVW5lZGlkYWJsZVJlZmVyZW5jZUVsKHN0YXJ0Tm9kZSkpO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmKHVuZWRpYWJsZUNvbnRleEVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0T2Zmc2V0ID0gZW5kT2Zmc2V0ID0gdW5lZGlhYmxlQ29udGV4RWwucGFyZW50RWxlbWVudC5jaGlsZE5vZGVzLmluZGV4T2YodW5lZGlhYmxlQ29udGV4RWwpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnROb2RlID0gZW5kTm9kZSA9IHVuZWRpYWJsZUNvbnRleEVsLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuaXNBbmNob3JMZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KHN0YXJ0Tm9kZSwgc3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRFbmQoZW5kTm9kZSwgZW5kT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRFbmQoc3RhcnROb2RlLCBzdGFydE9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KGVuZE5vZGUsIGVuZE9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGNhdGNoKGV4KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2ZhaWxlZCB0byBzZXQgY2FyZXQgcG9zaXRpb24gdmlhIG9mZnNldCBzdHJhdGVneScsIGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVzdG9yZVNlbGVjdGlvblZpYURPTVN0cmF0ZWd5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJhbmdlLCBzZWxlY3Rpb247XG5cbiAgICAgICAgaWYoIXRoaXMucm9vdEVsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLnNlbGVjdGlvbklzVW5lZGlkYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLnJvb3RFbC5jb250YWlucyh0aGlzLnNlbGVjdGlvbkFuY2hvck5vZGUpICYmIHRoaXMucm9vdEVsLmNvbnRhaW5zKHRoaXMuc2VsZWN0aW9uRm9jdXNOb2RlKSkge1xuICAgICAgICAgICAgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgaWYodGhpcy5pc0FuY2hvckxlZnQpIHtcbiAgICAgICAgICAgICAgICByYW5nZS5zZXRFbmQodGhpcy5zZWxlY3Rpb25BbmNob3JOb2RlLCB0aGlzLnNlbGVjdGlvbkFuY2hvck9mZnNldCk7XG4gICAgICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQodGhpcy5zZWxlY3Rpb25Gb2N1c05vZGUsIHRoaXMuc2VsZWN0aW9uRm9jdXNPZmZzZXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydCh0aGlzLnNlbGVjdGlvbkFuY2hvck5vZGUsIHRoaXMuc2VsZWN0aW9uQW5jaG9yT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICByYW5nZS5zZXRFbmQodGhpcy5zZWxlY3Rpb25Gb2N1c05vZGUsIHRoaXMuc2VsZWN0aW9uRm9jdXNPZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBzYXZlU2VsZWN0aW9uOiBmdW5jdGlvbihyb290RWwsIGluc2VydGVkQ29udGVudCkge1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuXG4gICAgICAgIGlmKHRoaXMud2l0aGluVW5lZGlkYWJsZVJlZmVyZW5jZUVsKHNlbGVjdGlvbi5hbmNob3JOb2RlKSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25Jc1VuZWRpZGFibGUgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYoIXNlbGVjdGlvbi5pc0NvbGxhcHNlZCAmJiB0aGlzLndpdGhpblVuZWRpZGFibGVSZWZlcmVuY2VFbChzZWxlY3Rpb24uZm9jdXNOb2RlKSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25Jc1VuZWRpZGFibGUgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25Jc1VuZWRpZGFibGUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuc2VsZWN0aW9uSXNVbmVkaWRhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzZWxlY3Rpb25Jc1VuZWRpZGFibGU6IHRydWUgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHNlbGVjdGlvbi5hbmNob3JOb2RlICYmIHNlbGVjdGlvbi5mb2N1c05vZGUpIHtcbiAgICAgICAgICAgIGlmKHNlbGVjdGlvbi5hbmNob3JOb2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmFuZ2VTdGFydCA9IHRoaXMuX2dldENvbnRlbnRMZW5ndGhPZkRPTUVsZW1lbnQocm9vdEVsLCBzZWxlY3Rpb24uYW5jaG9yTm9kZSkgKyBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJhbmdlU3RhcnQgPSB0aGlzLl9nZXRDb250ZW50TGVuZ3RoT2ZET01FbGVtZW50KHJvb3RFbCwgc2VsZWN0aW9uLmFuY2hvck5vZGUpO1xuICAgICAgICAgICAgICAgIGZvcihsZXQgaT0wOyBpPHNlbGVjdGlvbi5hbmNob3JPZmZzZXQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJhbmdlU3RhcnQgKz0gdGhpcy5fZ2V0Q29udGVudExlbmd0aE9mRE9NRWxlbWVudChzZWxlY3Rpb24uYW5jaG9yTm9kZS5jaGlsZE5vZGVzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHNlbGVjdGlvbi5pc0NvbGxhcHNlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmFuZ2VFbmQgPSB0aGlzLnJhbmdlU3RhcnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmKHNlbGVjdGlvbi5mb2N1c05vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmFuZ2VFbmQgPSB0aGlzLl9nZXRDb250ZW50TGVuZ3RoT2ZET01FbGVtZW50KHJvb3RFbCwgc2VsZWN0aW9uLmZvY3VzTm9kZSkgKyBzZWxlY3Rpb24uZm9jdXNPZmZzZXQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yYW5nZUVuZCA9IHRoaXMuX2dldENvbnRlbnRMZW5ndGhPZkRPTUVsZW1lbnQocm9vdEVsLCBzZWxlY3Rpb24uZm9jdXNOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpPTA7IGk8c2VsZWN0aW9uLmZvY3VzT2Zmc2V0OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmFuZ2VFbmQgKz0gdGhpcy5fZ2V0Q29udGVudExlbmd0aE9mRE9NRWxlbWVudChzZWxlY3Rpb24uZm9jdXNOb2RlLmNoaWxkTm9kZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnJvb3RFbCA9IHJvb3RFbDtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uSXNVbmVkaWRhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmlzQW5jaG9yTGVmdCA9IHRoaXMucmFuZ2VTdGFydCA8PSB0aGlzLnJhbmdlRW5kO1xuICAgICAgICAgICAgdGhpcy5yYW5nZVN0YXJ0QXRaZXJvT2Zmc2V0ID0gc2VsZWN0aW9uLmFuY2hvck9mZnNldCA9PT0gMDtcbiAgICAgICAgICAgIHRoaXMucmFuZ2VFbmRBdFplcm9PZmZzZXQgPSBzZWxlY3Rpb24uZm9jdXNPZmZzZXQgPT09IDA7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yTm9kZTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uRm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzTm9kZTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uQW5jaG9yT2Zmc2V0ID0gc2VsZWN0aW9uLmFuY2hvck9mZnNldDtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uRm9jdXNPZmZzZXQgPSBzZWxlY3Rpb24uZm9jdXNPZmZzZXQ7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbklzQ29sbGFwc2VkID0gc2VsZWN0aW9uLmlzQ29sbGFwc2VkO1xuXG4gICAgICAgICAgICB0aGlzLmZvbGxvd2luZ1NwYWNlVGVybWluYXRlc1RleHROb2RlID0gc2VsZWN0aW9uLmFuY2hvck5vZGUgPT09IHNlbGVjdGlvbi5mb2N1c05vZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24uZm9jdXNOb2RlLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5hbmNob3JPZmZzZXQgPT09IChzZWxlY3Rpb24uZm9jdXNOb2RlLmxlbmd0aC0xKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzZWxlY3Rpb24uZm9jdXNOb2RlLm5vZGVWYWx1ZVtzZWxlY3Rpb24uZm9jdXNOb2RlLmxlbmd0aC0xXSA9PT0gJ1xcdTAwQTAnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5mb2N1c05vZGUubm9kZVZhbHVlW3NlbGVjdGlvbi5mb2N1c05vZGUubGVuZ3RoLTFdID09PSAnICcpO1xuXG4gICAgICAgICAgICAgaWYoaW5zZXJ0ZWRDb250ZW50ID09PSAnICcgJiYgdGhpcy5mb2xsb3dpbmdTcGFjZVRlcm1pbmF0ZXNUZXh0Tm9kZSkge1xuICAgICAgICAgICAgICAgdGhpcy5jYXJyZXRQbGFjZW1lbnRDb3JyZWN0aW9uID0gLTE7XG4gICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgIHRoaXMuY2FycmV0UGxhY2VtZW50Q29ycmVjdGlvbiA9IDA7XG4gICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByb290RWw6IHRoaXMucm9vdEVsLFxuICAgICAgICAgICAgICAgIHJhbmdlU3RhcnQ6IHRoaXMucmFuZ2VTdGFydCxcbiAgICAgICAgICAgICAgICByYW5nZUVuZDogdGhpcy5yYW5nZUVuZCxcbiAgICAgICAgICAgICAgICBpc0FuY2hvckxlZnQ6IHRoaXMuaXNBbmNob3JMZWZ0LFxuICAgICAgICAgICAgICAgIHJhbmdlU3RhcnRBdFplcm9PZmZzZXQ6IHRoaXMucmFuZ2VTdGFydEF0WmVyb09mZnNldCxcbiAgICAgICAgICAgICAgICByYW5nZUVuZEF0WmVyb09mZnNldDogdGhpcy5yYW5nZUVuZEF0WmVyb09mZnNldCxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Gb2N1c05vZGU6IHRoaXMuc2VsZWN0aW9uRm9jdXNOb2RlLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbkFuY2hvck5vZGU6IHRoaXMuc2VsZWN0aW9uQW5jaG9yTm9kZSxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Jc0NvbGxhcHNlZDogdGhpcy5zZWxlY3Rpb25Jc0NvbGxhcHNlZCxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Jc1VuZWRpZGFibGU6IHRoaXMuc2VsZWN0aW9uSXNVbmVkaWRhYmxlXG4gICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNsZWFyU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgd2luZG93LmdldFNlbGVjdGlvbigpLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIH0sXG5cbiAgICB0YXJnZXRFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5mb2N1c05vZGU7XG4gICAgfSxcblxuICAgIGlzQ29sbGFwc2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSxcbiAgICAgICAgICAgIHJhbmdlO1xuXG4gICAgICAgIGlmKHNlbC5yYW5nZUNvdW50ID09PSAwKSByZXR1cm47XG5cbiAgICAgICAgcmFuZ2UgPSBzZWwuZ2V0UmFuZ2VBdCgwKTtcbiAgICAgICAgaWYoIXJhbmdlKSByZXR1cm47XG4gICAgICAgIHJldHVybiByYW5nZS5jb2xsYXBzZWQ7XG4gICAgfSxcblxuICAgIC8vIElmIHRoZSBzZWxlY3Rpb24gaXMgbm90IGNvbGxhcHNlZCBhbmQgdGhlIHN0YXJ0IG9yIGVuZFxuICAgIC8vIGlzIG91dHNpdGUgdGhlIGdpdmVuIGVsZW1lbnQsIHRoaXMgZnVuY3Rpb24gd2lsbCBtb3ZlIHRoZVxuICAgIC8vIGNvcnJlc3BvbmRpbmcgc2VsZWN0aW9uIGVuZCBpbnNpZGUgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgLy9cbiAgICAvLyBJbiB0aGUgZm9sbG93aW5nIEV4YW1wbGUgdGhlIHBhc3NlZCBlbGVtZW50IGlzIHRoZSBwIHNlY3Rpb25cbiAgICAvLyBpbiB0aGUgbWlkZGxlOlxuICAgIC8vIDxwPnRleHQ8L3A+PHA+d3xpdGg8L3A+PHA+cGFyYWdyfGFwaHM8L3A+XG4gICAgLy8gPT5cbiAgICAvLyA8cD50ZXh0PC9wPjxwPnd8aXRofDwvcD48cD5wYXJhZ3JhcGhzPC9wPlxuICAgIC8vXG4gICAgLy8gVGhpcyBpcyBhY3R1YWxseSBub3QgdXNlZCBvbiBzZWN0aW9uIGxldmVsIGJ1dCB0byBlbnN1cmVcbiAgICAvLyB0aGF0IHRoZSBzZWxlY3Rpb24gaXMgd2l0aGluIHRoZSBlZGl0b3IgaXRlc2VsZi5cbiAgICBlbnN1cmVFeHBhbmRlZFNlbGVjdGlvbklzV2l0aGluRWxlbWVudDogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgdmFyIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSxcbiAgICAgICAgICAgIG4xID0gc2VsLmZvY3VzTm9kZSxcbiAgICAgICAgICAgIG8xID0gc2VsLmZvY3VzT2Zmc2V0LFxuICAgICAgICAgICAgbjIgPSBzZWwuYW5jaG9yTm9kZSxcbiAgICAgICAgICAgIG8yID0gc2VsLmFuY2hvck9mZnNldCxcbiAgICAgICAgICAgIHRtcCwgbjFJbmNsdWRlZEluRWwsIG4ySW5jbHVkZWRJbkVsLCBuMVBvcywgbjJQb3MsXG4gICAgICAgICAgICBuMUFuZE4yQXJlRm9sbG93aW5nRWwsIG4xQW5kTjJBcmVQcmVjZWRpbmdFbCwgY2hpbGRFbCxcbiAgICAgICAgICAgIGVsV2Fsa2VyLCBuZXdSYW5nZTtcblxuICAgICAgICBpZighbjEgfHwgIW4yIHx8IHNlbC5pc0NvbGxhcHNlZCkgeyByZXR1cm4gfVxuXG4gICAgICAgIG4xUG9zID0gbjEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZWwpO1xuICAgICAgICBuMlBvcyA9IG4yLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGVsKTtcblxuICAgICAgICBuMUluY2x1ZGVkSW5FbCA9IG4xUG9zICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9DT05UQUlOUztcbiAgICAgICAgbjJJbmNsdWRlZEluRWwgPSBuMlBvcyAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTlM7XG5cbiAgICAgICAgaWYobjFJbmNsdWRlZEluRWwgJiYgbjJJbmNsdWRlZEluRWwpIHsgcmV0dXJuIH1cblxuICAgICAgICBuMUFuZE4yQXJlRm9sbG93aW5nRWwgPSAhISgobjFQb3MgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORykgJiYgKG4yUG9zICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkcpICYmICFuMUluY2x1ZGVkSW5FbCAmJiAhbjJJbmNsdWRlZEluRWwpO1xuICAgICAgICBuMUFuZE4yQXJlUHJlY2VkaW5nRWwgPSAhISgobjFQb3MgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORykgJiYgKG4yUG9zICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkcpICYmICFuMUluY2x1ZGVkSW5FbCAmJiAhbjJJbmNsdWRlZEluRWwpO1xuXG4gICAgICAgIGlmKG4xQW5kTjJBcmVGb2xsb3dpbmdFbCB8fCBuMUFuZE4yQXJlUHJlY2VkaW5nRWwpIHsgcmV0dXJuIH1cblxuICAgICAgICBpZihuMS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihuMikgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORykge1xuICAgICAgICAgICAgdG1wID0gbjI7IG4yID0gbjE7IG4xID0gdG1wO1xuICAgICAgICAgICAgdG1wID0gbzI7IG8yID0gbzE7IG8xID0gdG1wO1xuICAgICAgICAgICAgdG1wID0gbjJJbmNsdWRlZEluRWw7IG4ySW5jbHVkZWRJbkVsID0gbjFJbmNsdWRlZEluRWw7IG4xSW5jbHVkZWRJbkVsID0gdG1wO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3UmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuXG4gICAgICAgIGlmKCFuMUluY2x1ZGVkSW5FbCkge1xuICAgICAgICAgICAgZWxXYWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGVsLCBOb2RlRmlsdGVyLlNIT1dfVEVYVCwgbnVsbCwgZmFsc2UpO1xuICAgICAgICAgICAgbmV3UmFuZ2Uuc2V0U3RhcnQoZWxXYWxrZXIuZmlyc3RDaGlsZCgpLCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld1JhbmdlLnNldFN0YXJ0KG4xLCBvMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZighbjJJbmNsdWRlZEluRWwpIHtcbiAgICAgICAgICAgIGVsV2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihlbCwgTm9kZUZpbHRlci5TSE9XX1RFWFQsIG51bGwsIGZhbHNlKTtcbiAgICAgICAgICAgIGNoaWxkRWwgPSBlbFdhbGtlci5sYXN0Q2hpbGQoKTtcbiAgICAgICAgICAgIG5ld1JhbmdlLnNldEVuZChjaGlsZEVsLCBjaGlsZEVsLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdSYW5nZS5zZXRFbmQobjIsIG8yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgc2VsLmFkZFJhbmdlKG5ld1JhbmdlKTtcbiAgICB9LFxuXG4gICAgZ2V0Q29udGVudExlbmd0aFRpbGxTZWN0aW9uOiBmdW5jdGlvbihzZWN0aW9uKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAwO1xuICAgICAgICBzZWN0aW9uID0gc2VjdGlvbi5wcmV2aW91c1NpYmxpbmc7XG5cbiAgICAgICAgd2hpbGUoc2VjdGlvbikge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuX2dldENvbnRlbnRMZW5ndGhPZkRPTUVsZW1lbnQoc2VjdGlvbik7XG4gICAgICAgICAgICBzZWN0aW9uID0gc2VjdGlvbi5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FyZXQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBIVE1MUmF6b3IgPSByZXF1aXJlKCcuLi9saWIvaHRtbF9yYXpvci9odG1sX3Jhem9yJyksXG4gICAgVGFnVHJhbnNmb3JtYXRpb25zID0gcmVxdWlyZSgnLi4vbGliL2h0bWxfcmF6b3IvdGFnX3RyYW5zZm9ybWF0aW9uJyksXG4gICAgQ2FyZXQgPSByZXF1aXJlKCcuL2NhcmV0JyksXG4gICAgU2VjdGlvblR5cGVTZWxlY3RvckNvbnRyb2wgPSByZXF1aXJlKCcuL3NlY3Rpb25fdHlwZV9zZWxlY3Rvcl9jb250cm9sJyksXG4gICAgS2V5UHJlc3NIYW5kbGVyID0gcmVxdWlyZSgnLi9rZXlfcHJlc3NfaGFuZGxlcicpLFxuICAgIFRleHRFbnJpY2htZW50Q29udHJvbCA9IHJlcXVpcmUoJy4vdGV4dF9lbnJpY2htZW50X2NvbnRyb2wnKSxcbiAgICBEb2N1bWVudHVwZGF0ZXIgPSByZXF1aXJlKCcuLi9saWIvZG9jdW1lbnR1cGRhdGVyL2RvY3VtZW50dXBkYXRlcicpLFxuICAgIE1vZGlmaWNhdGlvbkxvZ0VudHJ5ID0gcmVxdWlyZSgnLi4vbGliL2RvY3VtZW50dXBkYXRlci9tb2RpZmljYXRpb25fbG9nJyksXG4gICAgUmVmZXJlbmNlU3RvcmUgPSByZXF1aXJlKCcuL3JlZmVyZW5jZXMvcmVmZXJlbmNlX3N0b3JlJyksXG4gICAgUmVmZXJlbmNlQ29udHJvbGxlciA9IHJlcXVpcmUoJy4vcmVmZXJlbmNlcy9yZWZlcmVuY2VfY29udHJvbGxlcicpLFxuICAgIERlY2xhcmF0aXZGb3JtID0gcmVxdWlyZSgnLi4vbGliL2RlY2xhcmF0aXZfZm9ybXMvc3JjL2RlY2xhcmF0aXZfZm9ybScpLFxuICAgIENoYW5nZXNldCA9IHJlcXVpcmUoJ2NoYW5nZXNldHMnKS5DaGFuZ2VzZXQsXG4gICAgcGFyYWdyYXBoU2VjdGlvblR5cGUgPSByZXF1aXJlKCcuL3NlY3Rpb25fdHlwZXMvcGFyYWdyYXBoL3BhcmFncmFwaF9zZWN0aW9uX3R5cGUnKSxcbiAgICB0YWJsZVNlY3Rpb25UeXBlID0gcmVxdWlyZSgnLi9zZWN0aW9uX3R5cGVzL3RhYmxlL3RhYmxlX3NlY3Rpb25fdHlwZScpLFxuICAgIHVub3JkZXJlZExpc3RTZWN0aW9uVHlwZSA9IHJlcXVpcmUoJy4vc2VjdGlvbl90eXBlcy9saXN0L3Vub3JkZXJlZF9saXN0X3NlY3Rpb25fdHlwZScpLFxuICAgIG9yZGVyZWRMaXN0U2VjdGlvblR5cGUgPSByZXF1aXJlKCcuL3NlY3Rpb25fdHlwZXMvbGlzdC9vcmRlcmVkX2xpc3Rfc2VjdGlvbl90eXBlJyksXG4gICAgaW1hZ2VTZWN0aW9uVHlwZSA9IHJlcXVpcmUoJy4vc2VjdGlvbl90eXBlcy9pbWFnZS9pbWFnZV9zZWN0aW9uX3R5cGUnKSxcbiAgICBjb2RlU2VjdGlvblR5cGUgPSByZXF1aXJlKCcuL3NlY3Rpb25fdHlwZXMvY29kZS9jb2RlX3NlY3Rpb25fdHlwZScpLFxuICAgIHRvY1NlY3Rpb25UeXBlID0gcmVxdWlyZSgnLi9zZWN0aW9uX3R5cGVzL3RvYy90b2Nfc2VjdGlvbl90eXBlJyksXG4gICAgYmlibGlvZ3JhcGhpZVNlY3Rpb25UeXBlID0gcmVxdWlyZSgnLi9zZWN0aW9uX3R5cGVzL2JpYmxpb2dyYXBoaWUvYmlibGlvZ3JhcGhpZV9zZWN0aW9uX3R5cGUnKSxcbiAgICBmb290bm90ZXNTZWN0aW9uVHlwZSA9IHJlcXVpcmUoJy4vc2VjdGlvbl90eXBlcy9mb290bm90ZXMvZm9vdG5vdGVzX3NlY3Rpb25fdHlwZScpLFxuICAgIGZvcm11bGFTZWN0aW9uVHlwZSA9IHJlcXVpcmUoJy4vc2VjdGlvbl90eXBlcy9mb3JtdWxhL2Zvcm11bGFfc2VjdGlvbl90eXBlJyksXG4gICAgbWVybWFpZFNlY3Rpb25UeXBlID0gcmVxdWlyZSgnLi9zZWN0aW9uX3R5cGVzL21lcm1haWQvbWVybWFpZF9zZWN0aW9uX3R5cGUnKSxcbiAgICBibG9ja3F1b3RlU2VjdGlvblR5cGUgPSByZXF1aXJlKCcuL3NlY3Rpb25fdHlwZXMvYmxvY2txdW90ZS9ibG9ja3F1b3RlX3NlY3Rpb25fdHlwZScpLFxuICAgIGhlYWRpbmcxU2VjdGlvblR5cGUgPSByZXF1aXJlKCcuL3NlY3Rpb25fdHlwZXMvaGVhZGluZy9oZWFkaW5nMScpLFxuICAgIGhlYWRpbmcyU2VjdGlvblR5cGUgPSByZXF1aXJlKCcuL3NlY3Rpb25fdHlwZXMvaGVhZGluZy9oZWFkaW5nMicpLFxuICAgIGhlYWRpbmczU2VjdGlvblR5cGUgPSByZXF1aXJlKCcuL3NlY3Rpb25fdHlwZXMvaGVhZGluZy9oZWFkaW5nMycpLFxuICAgIGhlYWRpbmc0U2VjdGlvblR5cGUgPSByZXF1aXJlKCcuL3NlY3Rpb25fdHlwZXMvaGVhZGluZy9oZWFkaW5nNCcpLFxuICAgIGhlYWRpbmc1U2VjdGlvblR5cGUgPSByZXF1aXJlKCcuL3NlY3Rpb25fdHlwZXMvaGVhZGluZy9oZWFkaW5nNScpLFxuICAgIHV0aWxzID0gcmVxdWlyZSgnLi4vbGliL3BpeGVsc2NodWJzZXIvdXRpbHMnKSxcbiAgICAvLyBrYXRleCA9IHJlcXVpcmUoJ2thdGV4JyksIC8vIG1ha2Ugc3VyZSB0byBsb2FkIDxzY3JpcHQgc3JjPVwiLi9rYXRleC5qc1wiIGRlZmVyPjwvc2NyaXB0PiBpbiB5b3VyIGh0bWxcbiAgICB1dWlkID0gcmVxdWlyZSgndXVpZC92MScpLFxuICAgIGlzTWFjID0gbmF2aWdhdG9yLnBsYXRmb3JtLmluZGV4T2YoXCJNYWNcIikgPT09IDA7XG5cbndpbmRvdy5DaGFuZ2VzZXQgPSBDaGFuZ2VzZXQ7XG5cbkRPTVRva2VuTGlzdC5wcm90b3R5cGUuZmluZCA9IEFycmF5LnByb3RvdHlwZS5maW5kO1xuTm9kZUxpc3QucHJvdG90eXBlLmluZGV4T2YgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZjtcbk5vZGVMaXN0LnByb3RvdHlwZS5maWx0ZXIgPSBBcnJheS5wcm90b3R5cGUuZmlsdGVyO1xuTm9kZUxpc3QucHJvdG90eXBlLmZvckVhY2ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaDtcbk5vZGVMaXN0LnByb3RvdHlwZS5tYXAgPSBBcnJheS5wcm90b3R5cGUubWFwO1xuSFRNTENvbGxlY3Rpb24ucHJvdG90eXBlLmluZGV4T2YgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZjtcbkhUTUxDb2xsZWN0aW9uLnByb3RvdHlwZS5maWx0ZXIgPSBBcnJheS5wcm90b3R5cGUuZmlsdGVyO1xuSFRNTENvbGxlY3Rpb24ucHJvdG90eXBlLmZvckVhY2ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaDtcbkhUTUxDb2xsZWN0aW9uLnByb3RvdHlwZS5tYXAgPSBBcnJheS5wcm90b3R5cGUubWFwO1xuQXJyYXkucHJvdG90eXBlLmNvbnRhaW5zID0gQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzO1xuQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzQWxsID0gZnVuY3Rpb24oKSB7IHZhciBzZWxmID0gdGhpcywgYXJncyA9IEFycmF5LmZyb20oYXJndW1lbnRzKTsgcmV0dXJuIGFyZ3MuZXZlcnkoZnVuY3Rpb24ocikge3JldHVybiBzZWxmLmluY2x1ZGVzKHIpIH0pfVxuQXJyYXkucHJvdG90eXBlLnVuaXF1ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgc2VsZikgeyByZXR1cm4gc2VsZi5pbmRleE9mKHZhbHVlKSA9PT0gaW5kZXggfSkgfVxuXG52YXIgRWRpdG9yID0gZnVuY3Rpb24oZG9tSWQsIG9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICAgIHRoaXMuX2luaXREb25lID0gZmFsc2U7XG4gICAgdGhpcy5faXNDb250ZW50RWRpdGFibGUgPSB0cnVlO1xuICAgIHRoaXMucmVmZXJlbmNlID0gbmV3IFJlZmVyZW5jZUNvbnRyb2xsZXIobmV3IFJlZmVyZW5jZVN0b3JlKG9wdGlvbnMuY29udGVudElELCBvcHRpb25zLlJlZmVyZW5jZVBlcnNpdGVuY3lEcml2ZXIpLCB0aGlzKTtcbiAgICB0aGlzLnRhZ1RyYW5zZm9ybWF0aW9ucyA9IG5ldyBUYWdUcmFuc2Zvcm1hdGlvbnMoKTtcbiAgICB0aGlzLmRvbUlkID0gZG9tSWQ7XG4gICAgdGhpcy5oaW50RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdGUtaW5wdXQtaGludCcpXG4gICAgdGhpcy5jb250YWluZXJFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZG9tSWQpO1xuICAgIHRoaXMuY29udGFpbmVyRWxlbWVudC5pbm5lckhUTUwgPSAnJztcbiAgICB0aGlzLmNvbnRlbnRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5jYXJldCA9IG5ldyBDYXJldCh0aGlzKTtcbiAgICB0aGlzLnN1YnNjcmliZXJzID0gW107XG4gICAgdGhpcy5yZWZlcmVuY2VJbnNlcnRlZFN1YnNjcmliZXJzID0gW107XG4gICAgdGhpcy5zZWN0aW9uRm9jdXNDaGFuZ2VTdWJzY3JpYmVycyA9IFtdO1xuICAgIHRoaXMuc2VjdGlvblR5cGVTZWxlY3RvciA9IG5ldyBTZWN0aW9uVHlwZVNlbGVjdG9yQ29udHJvbCh0aGlzLmNoYW5nZUZvY3VzZWRTZWN0aW9uVHlwZSwgdGhpcywgdGhpcyk7XG4gICAgdGhpcy50ZXh0RW5yaWNobWVudENvbnRyb2wgPSBuZXcgVGV4dEVucmljaG1lbnRDb250cm9sKHRoaXMpO1xuICAgIHRoaXMua2V5UHJlc3NIYW5kbGVyID0gbmV3IEtleVByZXNzSGFuZGxlcih0aGlzKTtcblxuICAgIHRoaXMuY29udGVudEVsZW1lbnQuc2V0QXR0cmlidXRlKCdzcGVsbGNoZWNrJywgb3B0aW9ucy5zcGVsbGNoZWNrKTtcbiAgICB0aGlzLmNvbnRlbnRFbGVtZW50LmNsYXNzTmFtZSA9ICdzdHJ1Y3R1cmVkLXRleHQtZWRpdG9yJztcblxuICAgIHRoaXMuaGludEVsLmlubmVySFRNTCA9IGBXcml0ZSBIZXJlLi4uIFByZXNzIDxjb2RlPiR7aXNNYWMgPyAn4oyYJyA6ICdDdHJsJ308L2NvZGU+ICsgPGNvZGU+aTwvY29kZT4gdG8gaW5zZXJ0IGEgcmVmZXJlbmNlLCBmb290bm90ZSBvciBlcXVhdGlvbi5gO1xuXG4gICAgdGhpcy5jb250YWluZXJFbGVtZW50LmNsYXNzTmFtZSA9ICdzdHJ1Y3R1cmVkLXRleHQtZWRpdG9yLWNvbnRhaW5lcic7XG4gICAgdGhpcy5jb250YWluZXJFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuYnVpbGRBZGRTZWN0aW9uQnV0dG9uKCd0b3AnKSk7XG4gICAgdGhpcy5jb250YWluZXJFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuY29udGVudEVsZW1lbnQpO1xuICAgIHRoaXMuY29udGFpbmVyRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmJ1aWxkQWRkU2VjdGlvbkJ1dHRvbignYm90dG9tJykpO1xuXG4gICAgdGhpcy5zdXBwb3J0ZWRTZWN0aW9uVHlwZXMgPSB7fTtcblxuICAgIHRoaXMuaGlzdG9yeSA9IFtdO1xuICAgIHRoaXMudW5kb25lTW9kaWZpY2F0aW9ucyA9IFtdO1xuICAgIHRoaXMuY2FyZXRQb3NpdGlvbnMgPSBbXTtcblxuICAgIHRoaXMubWFya3VwVHJhbnNmb3JtYXRpb25zID0gW1xuICAgICAgICB7IHRvOiAndGFibGUnLCAgICAgcHJhZWZpeDogJyN0YWJsZScgIH0sXG4gICAgICAgIHsgdG86ICdwcmUnLCAgICAgICBwcmFlZml4OiAnI2NvZGUnICAgfSxcbiAgICAgICAgeyB0bzogJ2gxJywgICAgICAgIHByYWVmaXg6ICcjdGl0bGUnICB9LFxuICAgICAgICB7IHRvOiAnaDInLCAgICAgICAgcHJhZWZpeDogJyMnICAgICAgIH0sXG4gICAgICAgIHsgdG86ICdoMicsICAgICAgICBwcmFlZml4OiAnI2gxJyAgICAgfSxcbiAgICAgICAgeyB0bzogJ2gzJywgICAgICAgIHByYWVmaXg6ICcjIycgICAgICB9LFxuICAgICAgICB7IHRvOiAnaDMnLCAgICAgICAgcHJhZWZpeDogJyNoMicgICAgIH0sXG4gICAgICAgIHsgdG86ICdoNCcsICAgICAgICBwcmFlZml4OiAnIyMjJyAgICAgfSxcbiAgICAgICAgeyB0bzogJ2g0JywgICAgICAgIHByYWVmaXg6ICcjaDMnICAgICB9LFxuICAgICAgICB7IHRvOiAnaDUnLCAgICAgICAgcHJhZWZpeDogJyMjIyMnICAgIH0sXG4gICAgICAgIHsgdG86ICdoNScsICAgICAgICBwcmFlZml4OiAnI2g0JyAgICAgfSxcbiAgICAgICAgeyB0bzogJ3AnLCAgICAgICAgIHByYWVmaXg6ICcjcCcgICAgICB9LFxuICAgICAgICB7IHRvOiAndWwnLCAgICAgICAgcHJhZWZpeDogJyN1bCcgICAgIH0sXG4gICAgICAgIHsgdG86ICd1bCcsICAgICAgICBwcmFlZml4OiAnXFxcXConICAgICB9LFxuICAgICAgICB7IHRvOiAnb2wnLCAgICAgICAgcHJhZWZpeDogJyNvbCcgICAgIH0sXG4gICAgICAgIHsgdG86ICdvbCcsICAgICAgICBwcmFlZml4OiAnMVxcXFwpJyAgICB9LFxuICAgICAgICB7IHRvOiAnZmlndXJlJywgICAgcHJhZWZpeDogJyNpbWcnICAgIH0sXG4gICAgICAgIHsgdG86ICdmaWd1cmUnLCAgICBwcmFlZml4OiAnI2ltYWdlJyAgfSxcbiAgICAgICAgeyB0bzogJ25hdicsICAgICAgIHByYWVmaXg6ICcjdG9jJyAgICB9LFxuICAgICAgICB7IHRvOiAnaDIoQWJzdHJhY3QpJywgICBwcmFlZml4OiAnI2Fic3RyYWN0JyAgfSxcbiAgICAgICAgeyB0bzogJ2gyKEFic3RyYWN0KScsICAgcHJhZWZpeDogJyNBYnN0cmFjdCcgIH0sXG4gICAgICAgIHsgdG86ICdiaWJsaW9ncmFwaGllJywgIHByYWVmaXg6ICcjYmliJyAgICAgICB9LFxuICAgICAgICB7IHRvOiAnZm9vdG5vdGVzJywgICAgICBwcmFlZml4OiAnI2Zvb3Rub3RlcycgfSxcbiAgICAgICAgeyB0bzogJ2Zvcm11bGEnLCAgICAgICAgcHJhZWZpeDogJyNmb3JtdWxhJyAgIH0sXG4gICAgICAgIHsgdG86ICdmb3JtdWxhJywgICAgICAgIHByYWVmaXg6ICcjZXEnICAgICAgICB9LFxuICAgICAgICB7IHRvOiAnbWVybWFpZCcsICAgICAgICBwcmFlZml4OiAnI2RpYScgICAgICAgfSxcbiAgICAgICAgeyB0bzogJ2JxdW90ZScsICAgICAgICAgcHJhZWZpeDogJyNxdW90ZScgICAgIH0sXG4gICAgICAgIHsgdG86ICdicXVvdGUnLCAgICAgICAgIHByYWVmaXg6ICcjXCInICAgICAgICAgfSxcbiAgICAgICAgeyB0bzogJ2JxdW90ZScsICAgICAgICAgcHJhZWZpeDogXCIjJ1wiICAgICAgICAgfSxcbiAgICAgICAgeyB0bzogJ2JxdW90ZScsICAgICAgICAgcHJhZWZpeDogJyNibG9ja3F1b3RlJ30sXG4gICAgXTtcblxuICAgIE9iamVjdC5hc3NpZ24odGhpcy50YWdUcmFuc2Zvcm1hdGlvbnMsIHtcbiAgICAgICAgJy9wJzogdGhpcy5tYXJrdXBUcmFuc2Zvcm1hdGlvbnMsXG4gICAgICAgICcvaDEnOiB0aGlzLm1hcmt1cFRyYW5zZm9ybWF0aW9ucyxcbiAgICAgICAgJy9oMic6IHRoaXMubWFya3VwVHJhbnNmb3JtYXRpb25zLFxuICAgICAgICAnL2gzJzogdGhpcy5tYXJrdXBUcmFuc2Zvcm1hdGlvbnMsXG4gICAgICAgICcvaDQnOiB0aGlzLm1hcmt1cFRyYW5zZm9ybWF0aW9ucyxcbiAgICAgICAgJy9oNSc6IHRoaXMubWFya3VwVHJhbnNmb3JtYXRpb25zLFxuICAgICAgICAnL2Rpdic6ICdwJyxcbiAgICAgICAgJy9iJzogJ3AnLFxuICAgICAgICAnL2knOiAncCcsXG4gICAgICAgICcvaW5saW5lY29kZSc6ICdwJyxcbiAgICAgICAgJy9wL2JyJzogJz0nLFxuICAgICAgICAnL2gxL2JyJzogJz1wJyxcbiAgICAgICAgJy9oMi9icic6ICc9cCcsXG4gICAgICAgICcvaDMvYnInOiAnPXAnLFxuICAgICAgICAnL2g0L2JyJzogJz1wJyxcbiAgICAgICAgJy9oNS9icic6ICc9cCcsXG5cbiAgICAgICAgJy9wL2IvYnInOiAnPScsXG4gICAgICAgICcvcC9iL2kvYnInOiAnPScsXG4gICAgICAgICcvcC9iL3UvYnInOiAnPScsXG4gICAgICAgICcvcC9iL2EvYnInOiAnPScsXG5cbiAgICAgICAgJy9wL3UvYnInOiAnPScsXG4gICAgICAgICcvcC91L2kvYnInOiAnPScsXG4gICAgICAgICcvcC91L2IvYnInOiAnPScsXG4gICAgICAgICcvcC91L2EvYnInOiAnPScsXG5cbiAgICAgICAgJy9wL2kvYnInOiAnPScsXG4gICAgICAgICcvcC9pL3UvYnInOiAnPScsXG4gICAgICAgICcvcC9pL2IvYnInOiAnPScsXG4gICAgICAgICcvcC9pL2EvYnInOiAnPScsXG5cbiAgICAgICAgJy9wL2NvZGUnOiAnaW5saW5lY29kZScsXG4gICAgICAgICcvcC9pbmxpbmVjb2RlL2JyJzogJz0nLFxuICAgICAgICAnL3AvaW5saW5lY29kZS9pbmxpbmVjb2RlJzogJyNjb250ZW50JyxcbiAgICAgICAgJy9wL2lubGluZWNvZGUvYic6ICcjY29udGVudCcsXG4gICAgICAgICcvcC9pbmxpbmVjb2RlL3UnOiAnI2NvbnRlbnQnLFxuICAgICAgICAnL3AvaW5saW5lY29kZS9pJzogJyNjb250ZW50JyxcbiAgICAgICAgJy9wL2lubGluZWNvZGUvYSc6ICcjY29udGVudCcsXG4gICAgICAgICcvcC9pL2NvZGUnOiAnLScsXG4gICAgICAgICcvcC9iL2NvZGUnOiAnLScsXG4gICAgICAgICcvcC91L2NvZGUnOiAnLScsXG4gICAgICAgICcvcC9hL2NvZGUnOiAnaW5saW5lY29kZScsXG4gICAgICAgICcvcC9pL2lubGluZWNvZGUnOiAnLScsXG4gICAgICAgICcvcC9iL2lubGluZWNvZGUnOiAnLScsXG4gICAgICAgICcvcC91L2lubGluZWNvZGUnOiAnLScsXG5cbiAgICAgICAgJy9wL2EvYnInOiAnPScsXG4gICAgICAgICcvcC9hL2kvYnInOiAnPScsXG4gICAgICAgICcvcC9hL3UvYnInOiAnPScsXG4gICAgICAgICcvcC9hL2IvYnInOiAnPScsXG5cbiAgICAgICAgJy9wL2Rpdic6ICctJyxcbiAgICAgICAgJy9oMS9kaXYnOiAnLScsXG4gICAgICAgICcvaDIvZGl2JzogJy0nLFxuICAgICAgICAnL2gzL2Rpdic6ICctJyxcbiAgICAgICAgJy9oNC9kaXYnOiAnLScsXG4gICAgICAgICcvaDUvZGl2JzogJy0nLFxuICAgICAgICAnL3AvcCc6ICcjY29udGVudCcsXG4gICAgICAgICcvcC9mb250JzogJyNjb250ZW50JyxcbiAgICAgICAgJy9wL3Zhcic6ICcjY29udGVudCcsXG4gICAgICAgICcvcC9hL3NwYW4nOiAnI2NvbnRlbnQnLFxuICAgICAgICAnL2ZpZ3VyZS9kaXYnOiAnI2NvbnRlbnQnLFxuICAgIH0pO1xuXG4gICAgIHRoaXMudGFnVHJhbnNmb3JtYXRpb25zLmFsbG93T25seVRleHRJbignL3RhYmxlL2NhcHRpb24nKTtcbiAgICAgdGhpcy50YWdUcmFuc2Zvcm1hdGlvbnMuYWxsb3dPbmx5VGV4dEluKCcvZmlndXJlL2ZpZ2NhcHRpb24nKTtcbiAgICAgdGhpcy50YWdUcmFuc2Zvcm1hdGlvbnMuYWxsb3dPbmx5VGV4dEluKCcvdGFibGUvdGJvZHkvdHIvdGQnLCB7IGFsbG93RXF1YXRpb25zOiB0cnVlLCBhbGxvd1JlZnM6IHRydWUsIGFsbG93TGlua3M6IHRydWUsIGFsbG93Qm9sZEl0YWxpY1VuZGVybGluZTogdHJ1ZSB9KTtcbiAgICAgdGhpcy50YWdUcmFuc2Zvcm1hdGlvbnMuYWxsb3dPbmx5VGV4dEluKCcvdWwvbGknLCB7IGFsbG93RXF1YXRpb25zOiB0cnVlLCBhbGxvd1JlZnM6IHRydWUsIGFsbG93TGlua3M6IHRydWUsIGFsbG93Qm9sZEl0YWxpY1VuZGVybGluZTogdHJ1ZSB9KTtcbiAgICAgdGhpcy50YWdUcmFuc2Zvcm1hdGlvbnMuYWxsb3dPbmx5VGV4dEluKCcvb2wvbGknLCB7IGFsbG93RXF1YXRpb25zOiB0cnVlLCBhbGxvd1JlZnM6IHRydWUsIGFsbG93TGlua3M6IHRydWUsIGFsbG93Qm9sZEl0YWxpY1VuZGVybGluZTogdHJ1ZSB9KTtcblxuICAgICB0aGlzLnRhZ1RyYW5zZm9ybWF0aW9ucy5hbGxvd09ubHlUZXh0SW4oJy9vbC9vbC9saScsIHsgYWxsb3dFcXVhdGlvbnM6IHRydWUsIGFsbG93UmVmczogdHJ1ZSwgYWxsb3dMaW5rczogdHJ1ZSwgYWxsb3dCb2xkSXRhbGljVW5kZXJsaW5lOiB0cnVlIH0pO1xuICAgICB0aGlzLnRhZ1RyYW5zZm9ybWF0aW9ucy5hbGxvd09ubHlUZXh0SW4oJy9vbC9vbC9vbC9saScsIHsgYWxsb3dFcXVhdGlvbnM6IHRydWUsIGFsbG93UmVmczogdHJ1ZSwgYWxsb3dMaW5rczogdHJ1ZSwgYWxsb3dCb2xkSXRhbGljVW5kZXJsaW5lOiB0cnVlIH0pO1xuXG4gICAgIHRoaXMudGFnVHJhbnNmb3JtYXRpb25zLmFsbG93T25seVRleHRJbignL3VsL3VsL2xpJywgeyBhbGxvd0VxdWF0aW9uczogdHJ1ZSwgYWxsb3dSZWZzOiB0cnVlLCBhbGxvd0xpbmtzOiB0cnVlLCBhbGxvd0JvbGRJdGFsaWNVbmRlcmxpbmU6IHRydWUgfSk7XG4gICAgIHRoaXMudGFnVHJhbnNmb3JtYXRpb25zLmFsbG93T25seVRleHRJbignL3VsL3VsL3VsL2xpJywgeyBhbGxvd0VxdWF0aW9uczogdHJ1ZSwgYWxsb3dSZWZzOiB0cnVlLCBhbGxvd0xpbmtzOiB0cnVlLCBhbGxvd0JvbGRJdGFsaWNVbmRlcmxpbmU6IHRydWUgfSk7XG5cbiAgICAgdGhpcy50YWdUcmFuc2Zvcm1hdGlvbnMuYWxsb3dPbmx5VGV4dEluKCcvaDEnLCB7IGFsbG93RXF1YXRpb25zOiB0cnVlIH0pO1xuICAgICB0aGlzLnRhZ1RyYW5zZm9ybWF0aW9ucy5hbGxvd09ubHlUZXh0SW4oJy9oMicsIHsgYWxsb3dFcXVhdGlvbnM6IHRydWUgfSk7XG4gICAgIHRoaXMudGFnVHJhbnNmb3JtYXRpb25zLmFsbG93T25seVRleHRJbignL2gzJywgeyBhbGxvd0VxdWF0aW9uczogdHJ1ZSB9KTtcbiAgICAgdGhpcy50YWdUcmFuc2Zvcm1hdGlvbnMuYWxsb3dPbmx5VGV4dEluKCcvaDQnLCB7IGFsbG93RXF1YXRpb25zOiB0cnVlIH0pO1xuICAgICB0aGlzLnRhZ1RyYW5zZm9ybWF0aW9ucy5hbGxvd09ubHlUZXh0SW4oJy9oNScsIHsgYWxsb3dFcXVhdGlvbnM6IHRydWUgfSk7XG5cbiAgICAgdGhpcy50YWdUcmFuc2Zvcm1hdGlvbnMuYWxsb3dSZWZzSW4oJy9wJyk7XG4gICAgIHRoaXMudGFnVHJhbnNmb3JtYXRpb25zLmFsbG93UmVmc0luKCcvcC9iJyk7XG4gICAgIHRoaXMudGFnVHJhbnNmb3JtYXRpb25zLmFsbG93UmVmc0luKCcvcC9pJyk7XG4gICAgIHRoaXMudGFnVHJhbnNmb3JtYXRpb25zLmFsbG93UmVmc0luKCcvcC91Jyk7XG4gICAgIHRoaXMudGFnVHJhbnNmb3JtYXRpb25zLmFsbG93UmVmc0luKCcvcHJlL2NhcHRpb24nKTtcbiAgICAgdGhpcy50YWdUcmFuc2Zvcm1hdGlvbnMuYWxsb3dSZWZzSW4oJy90YWJsZS9jYXB0aW9uJyk7XG4gICAgIHRoaXMudGFnVHJhbnNmb3JtYXRpb25zLmFsbG93UmVmc0luKCcvZm9ybXVsYS9jYXB0aW9uJyk7XG4gICAgIHRoaXMudGFnVHJhbnNmb3JtYXRpb25zLmFsbG93UmVmc0luKCcvbWVybWFpZC9jYXB0aW9uJyk7XG4gICAgIHRoaXMudGFnVHJhbnNmb3JtYXRpb25zLmFsbG93UmVmc0luKCcvZmlndXJlL2ZpZ2NhcHRpb24nKTtcbiAgICAgLy8gdGhpcy50YWdUcmFuc2Zvcm1hdGlvbnMuYWxsb3dSZWZzSW4oJy9icXVvdGUvY2l0ZXNyYycpOyAvLyB0aGlzIGlzIHNwZWNpZmllZCBpbiB0aGUgc2VjdGlvbiB0eXBlIGNvZGUgZmlsZSBpdHNlbGZcblxuICAgICB0aGlzLnRhZ1RyYW5zZm9ybWF0aW9ucy5hbGxvd0lubGluZWVxdWF0aW9uc0luKCcvcCcpO1xuICAgICB0aGlzLnRhZ1RyYW5zZm9ybWF0aW9ucy5hbGxvd0lubGluZWVxdWF0aW9uc0luKCcvcHJlL2NhcHRpb24nKTtcbiAgICAgdGhpcy50YWdUcmFuc2Zvcm1hdGlvbnMuYWxsb3dJbmxpbmVlcXVhdGlvbnNJbignL3RhYmxlL2NhcHRpb24nKTtcbiAgICAgdGhpcy50YWdUcmFuc2Zvcm1hdGlvbnMuYWxsb3dJbmxpbmVlcXVhdGlvbnNJbignL2Zvcm11bGEvY2FwdGlvbicpO1xuICAgICB0aGlzLnRhZ1RyYW5zZm9ybWF0aW9ucy5hbGxvd0lubGluZWVxdWF0aW9uc0luKCcvbWVybWFpZC9jYXB0aW9uJyk7XG4gICAgIHRoaXMudGFnVHJhbnNmb3JtYXRpb25zLmFsbG93SW5saW5lZXF1YXRpb25zSW4oJy9maWd1cmUvZmlnY2FwdGlvbicpO1xuICAgICB0aGlzLnRhZ1RyYW5zZm9ybWF0aW9ucy5hbGxvd0lubGluZWVxdWF0aW9uc0luKCcvYnF1b3RlL2NpdGVzcmMnKTtcblxuICAgIHRoaXMuY29udGVudFJ1bGVzID0ge1xuICAgICAgICAnaSc6IHtcbiAgICAgICAgICAgIHRhZ05hbWU6ICdpJyxcbiAgICAgICAgICAgIGFsbG93ZWRDaGlsZHJlbjogWycjdGV4dCcsICdsaW5rJywgJ2InLCAndScsICdmb290bm90ZScsICdyZWZlcmVuY2UnXSxcbiAgICAgICAgICAgIHBydW5lU3BhY2VzOiB0cnVlLFxuICAgICAgICAgICAgZGVsZXRlSWZFbXB0eTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICAnYic6IHtcbiAgICAgICAgICAgIHRhZ05hbWU6ICdiJyxcbiAgICAgICAgICAgIGFsbG93ZWRDaGlsZHJlbjogWycjdGV4dCcsICdsaW5rJywgJ2knLCAndScsICdmb290bm90ZScsICdyZWZlcmVuY2UnXSxcbiAgICAgICAgICAgIHBydW5lU3BhY2VzOiB0cnVlLFxuICAgICAgICAgICAgZGVsZXRlSWZFbXB0eTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICAndSc6IHtcbiAgICAgICAgICAgIHRhZ05hbWU6ICd1JyxcbiAgICAgICAgICAgIGFsbG93ZWRDaGlsZHJlbjogWycjdGV4dCcsICdsaW5rJywgJ2InLCAnaScsICdmb290bm90ZScsICdyZWZlcmVuY2UnXSxcbiAgICAgICAgICAgIHBydW5lU3BhY2VzOiB0cnVlLFxuICAgICAgICAgICAgZGVsZXRlSWZFbXB0eTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICAnaW5saW5lY29kZSc6IHtcbiAgICAgICAgICAgIHRhZ05hbWU6ICdpbmxpbmVjb2RlJyxcbiAgICAgICAgICAgIGFsbG93ZWRDaGlsZHJlbjogWycjdGV4dCddLFxuICAgICAgICAgICAgcHJ1bmVTcGFjZXM6IHRydWUsXG4gICAgICAgICAgICBkZWxldGVJZkVtcHR5OiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICAnbGluayc6IHtcbiAgICAgICAgICAgIHRhZ05hbWU6ICdhJyxcbiAgICAgICAgICAgIGFsbG93ZWRDaGlsZHJlbjogWycjdGV4dCcsICdiJywgJ2knLCAndScsICdpbmxpbmVjb2RlJ10sXG4gICAgICAgICAgICBhbGxvd2VkQXR0cmlidXRlczogWydocmVmJ10sXG4gICAgICAgICAgICBwcnVuZVNwYWNlczogdHJ1ZSxcbiAgICAgICAgICAgIGRlbGV0ZUlmRW1wdHk6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgJ2Zvb3Rub3RlJzoge1xuICAgICAgICAgICAgdGFnTmFtZTogJ3NwYW4nLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAnZm9vdG5vdGUnLFxuICAgICAgICAgICAgYWxsb3dlZEF0dHJpYnV0ZXM6IFsnY2xhc3MnLCAnY29udGVudGVkaXRhYmxlJywgJ2RhdGEtbm90ZSddLFxuICAgICAgICAgICAgYWxsb3dlZENsYXNzTmFtZXM6IFsnZm9vdG5vdGUnXSxcbiAgICAgICAgICAgIGFsbG93ZWRDaGlsZHJlbjogW10sXG4gICAgICAgICAgICBidWlsZEF0dHJpYnV0ZXM6IFt7bmFtZTogJ2NvbnRlbnRlZGl0YWJsZScsIGJ1aWxkOiBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlIH19XVxuICAgICAgICB9LFxuICAgICAgICAnaW5saW5lZXF1YXRpb24nOiB7XG4gICAgICAgICAgICB0YWdOYW1lOiAnaW5saW5lZXF1YXRpb24nLFxuICAgICAgICAgICAgYWxsb3dlZEF0dHJpYnV0ZXM6IFsnY29udGVudGVkaXRhYmxlJywgJ2RhdGEtbGF0ZXhlcXVhdGlvbicsICdpZCddLFxuICAgICAgICAgICAgYWxsb3dlZENoaWxkcmVuOiBbXSxcbiAgICAgICAgICAgIGJ1aWxkQXR0cmlidXRlczogW1xuICAgICAgICAgICAgICAgIHtuYW1lOiAnY29udGVudGVkaXRhYmxlJywgYnVpbGQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2UgfX0sXG4gICAgICAgICAgICAgICAge25hbWU6ICdpZCcsIGJ1aWxkOiBmdW5jdGlvbigpIHsgcmV0dXJuIHV1aWQoKSB9fVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICAncmVmZXJlbmNlJzoge1xuICAgICAgICAgICAgdGFnTmFtZTogJ3NwYW4nLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAncmVmZXJlbmNlJyxcbiAgICAgICAgICAgIGFsbG93ZWRBdHRyaWJ1dGVzOiBbJ2NsYXNzJywgJ2NvbnRlbnRlZGl0YWJsZScsICdkYXRhLXJlZicsICdkYXRhLWV4dGVybmFsJ10sXG4gICAgICAgICAgICBhbGxvd2VkQ2xhc3NOYW1lczogWydyZWZlcmVuY2UnXSxcbiAgICAgICAgICAgIGFsbG93ZWRDaGlsZHJlbjogW10sXG4gICAgICAgICAgICBidWlsZEF0dHJpYnV0ZXM6IFt7bmFtZTogJ2NvbnRlbnRlZGl0YWJsZScsIGJ1aWxkOiBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlIH19XVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIEFjY29yZGluZyB0byB0aGlzIGNvbmZpZzpcbiAgICAvLyAgIHdoZW4gdGhlIGVkaXRvciB1cGRhdGVkIGEgc2VjdGlvbiB3aGljaFxuICAgIC8vICAgICAtIGNvbnRhaW5zIGEgXCJoMlwiIGVsZW1lbnQgb3JcbiAgICAvLyAgICAgLSBjb250YWluZWQgYSBcImgyXCIgZWxlbWVudCBvclxuICAgIC8vICAgICAtIGlzIGEgXCJoMlwiIGVsZW1lbnQgb3JcbiAgICAvLyAgICAgLSB3YXMgYSBcImgyXCIgZWxlbWVudFxuICAgIC8vIHRoZSBtb2RpZmljYXRpb25Mb2dFbnRyeSB3aWxsIGhhdmUgYSBmaWVsZCBcIm1pZ2h0SW5jbHVkZUhlYWRpbmdVcGRhdGVzXCIgc2V0IHRvIHRydWVcbiAgICB0aGlzLm1vZExvZ0ZsYWdzID0ge1xuICAgICAgICBIZWFkaW5nOiBbJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1J10sXG4gICAgICAgIFRhYmxlT2ZDb250ZW50OiBbJ25hdiddLFxuICAgICAgICBCaWJsaW9ncmFwaGllOiBbJ2JpYmxpb2dyYXBoaWUnXSxcbiAgICAgICAgUmVmZXJlbmNlOiBbJy5yZWZlcmVuY2VbZGF0YS1leHRlcm5hbD1cInRydWVcIl0nXSxcbiAgICAgICAgRm9vdG5vdGU6IFsnLmZvb3Rub3RlJ10sXG4gICAgICAgIElubGluZXF1YXRpb246IFsnLmlubGluZWVxdWF0aW9uJ10sXG4gICAgICAgIEZvb3Rub3Rlc1NlY3Rpb246IFsnZm9vdG5vdGVzJ10sXG4gICAgfTtcblxuICAgIHRoaXMuYWRkU2VjdGlvblR5cGUocGFyYWdyYXBoU2VjdGlvblR5cGUpO1xuICAgIHRoaXMuYWRkU2VjdGlvblR5cGUodGFibGVTZWN0aW9uVHlwZSk7XG4gICAgdGhpcy5hZGRTZWN0aW9uVHlwZSh1bm9yZGVyZWRMaXN0U2VjdGlvblR5cGUpO1xuICAgIHRoaXMuYWRkU2VjdGlvblR5cGUob3JkZXJlZExpc3RTZWN0aW9uVHlwZSk7XG4gICAgdGhpcy5hZGRTZWN0aW9uVHlwZShjb2RlU2VjdGlvblR5cGUpO1xuICAgIHRoaXMuYWRkU2VjdGlvblR5cGUodG9jU2VjdGlvblR5cGUpO1xuICAgIHRoaXMuYWRkU2VjdGlvblR5cGUoYmlibGlvZ3JhcGhpZVNlY3Rpb25UeXBlLnNldEVkaXRvcih0aGlzKSk7XG4gICAgdGhpcy5hZGRTZWN0aW9uVHlwZShmb290bm90ZXNTZWN0aW9uVHlwZS5zZXRFZGl0b3IodGhpcykpO1xuICAgIHRoaXMuYWRkU2VjdGlvblR5cGUoaGVhZGluZzFTZWN0aW9uVHlwZSk7XG4gICAgdGhpcy5hZGRTZWN0aW9uVHlwZShoZWFkaW5nMlNlY3Rpb25UeXBlKTtcbiAgICB0aGlzLmFkZFNlY3Rpb25UeXBlKGhlYWRpbmczU2VjdGlvblR5cGUpO1xuICAgIHRoaXMuYWRkU2VjdGlvblR5cGUoaGVhZGluZzRTZWN0aW9uVHlwZSk7XG4gICAgdGhpcy5hZGRTZWN0aW9uVHlwZShoZWFkaW5nNVNlY3Rpb25UeXBlKTtcbiAgICB0aGlzLmFkZFNlY3Rpb25UeXBlKGltYWdlU2VjdGlvblR5cGUuc2V0RWRpdG9yKHRoaXMpKTtcbiAgICB0aGlzLmFkZFNlY3Rpb25UeXBlKGZvcm11bGFTZWN0aW9uVHlwZSk7XG4gICAgdGhpcy5hZGRTZWN0aW9uVHlwZShtZXJtYWlkU2VjdGlvblR5cGUpO1xuICAgIHRoaXMuYWRkU2VjdGlvblR5cGUoYmxvY2txdW90ZVNlY3Rpb25UeXBlKTtcblxuICAgIHRoaXMuaHRtbFJhem9yID0gbmV3IEhUTUxSYXpvcih0aGlzLnRhZ1RyYW5zZm9ybWF0aW9ucywgdGhpcy5jb250ZW50UnVsZXMpO1xuICAgIHRoaXMuZG9jdW1lbnR1cGRhdGVyID0gbmV3IERvY3VtZW50dXBkYXRlcih0aGlzLmNvbnRlbnRFbGVtZW50LCB0aGlzLmh0bWxSYXpvcik7XG4gICAgdGhpcy5hY3RpdmF0ZUlucHV0RXZlbnRQcm9jZXNzaW5nKCk7XG5cbiAgICB0aGlzLnN1YnNjcmliZShmdW5jdGlvbihtb2RMb2dFbnRyeSkge1xuICAgICAgICBpZihtb2RMb2dFbnRyeS50YWdzICE9PSAndW5kbycpIHtcbiAgICAgICAgICAgIHNlbGYuaGlzdG9yeS5wdXNoKG1vZExvZ0VudHJ5KTtcbiAgICAgICAgICAgIGlmKHNlbGYuaGlzdG9yeS5sZW5ndGggPiAzMCkge1xuICAgICAgICAgICAgICAgIHNlbGYuaGlzdG9yeS5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYobW9kTG9nRW50cnkudGFncyAhPT0gJ3JlZG8nICYmIG1vZExvZ0VudHJ5LnRhZ3MgIT09ICd1bmRvJykge1xuICAgICAgICAgICAgc2VsZi51bmRvbmVNb2RpZmljYXRpb25zID0gW107XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlY3Rpb24gPSBzZWxmLmZvY3VzZWRTZWN0aW9uKCk7XG5cbiAgICAgICAgaWYoc2VjdGlvbiAmJiBzZWN0aW9uLm9uV2luZG93UmVzaXplKSB7XG4gICAgICAgICAgICBzZWN0aW9uLm9uV2luZG93UmVzaXplKHNlbGYpO1xuICAgICAgICB9XG4gICAgfSlcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYoc2VsZi5pc0NvbnRlbnRFZGl0YWJsZSgpICYmIHNlbGYuX21vdXNlRG93biAmJiAhc2VsZi5jYXJldC5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICAgICAgICBzZWxmLnNldENvbnRlbnRFZGl0YWJsZShmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2VjdGlvbiA9IHNlbGYuZm9jdXNlZFNlY3Rpb24oKTtcblxuICAgICAgICBpZihzZWN0aW9uICYmIHNlY3Rpb24ub25TZWxlY3Rpb25DaGFuZ2UpIHtcbiAgICAgICAgICAgIHNlY3Rpb24ub25TZWxlY3Rpb25DaGFuZ2Uoc2VsZik7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2VsZi5fbW91c2VEb3duID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5zZXRDb250ZW50RWRpdGFibGUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLl9tb3VzZURvd24gPSBmYWxzZTtcbiAgICAgICAgaWYoIXNlbGYuYXJlTXVsdGlwbGVTZWN0aW9uc1NlbGVjdGVkKCkpIHtcbiAgICAgICAgICAgIHNlbGYuc2V0Q29udGVudEVkaXRhYmxlKHRydWUpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLnNlY3Rpb25UeXBlU2VsZWN0b3IuZGlzcGxheU5leHRUbyhzZWxmLmZvY3VzZWRTZWN0aW9uKCkpO1xuICAgIH0pO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2VsZi5zZWN0aW9uVHlwZVNlbGVjdG9yLmRpc3BsYXlOZXh0VG8oc2VsZi5mb2N1c2VkU2VjdGlvbigpKTtcbiAgICAgICAgc2VsZi50ZXh0RW5yaWNobWVudENvbnRyb2wudXBkYXRlUG9zaXRpb25JZlZpc2libGUoKTtcbiAgICB9KTtcblxuICAgIHRoaXMuY2FyZXQuc3Vic2NyaWJlU2VsZWN0aW9uQ2hhbmdlKGZ1bmN0aW9uKHNlbGVjdGlvbikge1xuICAgICAgICB2YXIgc2VjdGlvbiA9IHNlbGYuc2VjdGlvbkF0Q2FyZXRQb3N0aW9uKCksXG4gICAgICAgICAgICBwcmV2aW91c0ZvY3VzZWRTZWN0aW9uID0gc2VsZi5mb2N1c2VkU2VjdGlvbigpO1xuXG4gICAgICAgIGlmKHNlY3Rpb24gJiYgIXNlbGYuaXNGb2N1c2VkKHNlY3Rpb24pKSB7XG4gICAgICAgICAgICBzZWxmLmZvY3VzU2VjdGlvbihzZWN0aW9uKTtcblxuICAgICAgICAgICAgaWYocHJldmlvdXNGb2N1c2VkU2VjdGlvbiAmJiBzZWxmLnNob3VsZFNlY3Rpb25CZVJlbW92ZWRJZlVuZm9jdXNlZChwcmV2aW91c0ZvY3VzZWRTZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBkZWxldGUgdGhlIHByZXZpb3VzIGZvY3VzZWQgU2VjdGlvbiBpbiBjYXNlIGl0IGlzIGVtcHR5XG4gICAgICAgICAgICAgICAgc2VsZi5yZXBsYWNlU2VjdGlvbldpdGhIVE1MKHByZXZpb3VzRm9jdXNlZFNlY3Rpb24sIHByZXZpb3VzRm9jdXNlZFNlY3Rpb24ub3V0ZXJIVE1MKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuc2Nyb2xsVG9Gb2N1c2VkU2VjdGlvbklmTm90SW5WaWV3cG9ydCgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5jb250ZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYoc2VsZi5pc0lucHV0RXZlbnRQcm9jZXNzaW5nQWN0aXZhdGVkKCkgJiYgZS50YXJnZXQudGFnTmFtZSAhPT0gJ0lOUFVUJykge1xuICAgICAgICAgICAgc2VsZi5yZXBsYWNlU2VjdGlvbldpdGhIVE1MKGUudGFyZ2V0LCBlLnRhcmdldC5vdXRlckhUTUwsIHtpbnB1dEV2ZW50OiBlfSlcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5faW5pdERvbmUgPSB0cnVlO1xufVxuXG5FZGl0b3IucHJvdG90eXBlID0ge1xuXG4gICAgZGlzcGxheU1vZGFsOiBmdW5jdGlvbihmaWVsZHMsIGhhbmRsZXIsIG5vdEZvY3VzRmlyc3RJbnB1dCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIGZvcm07XG5cbiAgICAgICAgdGhpcy5mcmVlemVTZWxlY3Rpb24oe1xuICAgICAgICAgICAgJ3VuZnJlZXplQ2FsbGJhY2snOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnRleHRFbnJpY2htZW50Q29udHJvbC5wcmV2ZW50RW5yaWNobWVudENvbnRyb2xsVG9CZUhpZGRlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHNlbGYudGV4dEVucmljaG1lbnRDb250cm9sLmhpZGUoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3JtID0gbmV3IERlY2xhcmF0aXZGb3JtKHtmaWVsZHM6IGZpZWxkc30sIGhhbmRsZXIsICgpID0+IHtcbiAgICAgICAgICAgICAgICBzZWxmLnVuZnJlZXplU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgc2VsZi51bmZvY3VzU2VjdGlvbigpO1xuICAgICAgICAgICAgICAgIHNlbGYuY2FyZXQuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9ybS5vcGVuSW5Nb2RhbCgpO1xuXG4gICAgICAgICAgICBpZighbm90Rm9jdXNGaXJzdElucHV0ICYmIGZpZWxkc1swXSAmJiBmaWVsZHNbMF0uZG9tRWxlbWVudCAmJiBmaWVsZHNbMF0uZG9tRWxlbWVudC50YWdOYW1lID09PSAnREwtU0VMRUNUJykge1xuICAgICAgICAgICAgICAgIGZvcm0uZm9ybUVsZW1lbnQucXVlcnlTZWxlY3RvcignaW5wdXQnKS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZighbm90Rm9jdXNGaXJzdElucHV0ICYmIGZpZWxkc1swXSAmJiBmaWVsZHNbMF0uZG9tRWxlbWVudCAmJiBmaWVsZHNbMF0uZG9tRWxlbWVudC50YWdOYW1lID09PSAnVEVYVEFSRUEnKSB7XG4gICAgICAgICAgICAgICAgZm9ybS5mb3JtRWxlbWVudC5xdWVyeVNlbGVjdG9yKCd0ZXh0YXJlYScpLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCFub3RGb2N1c0ZpcnN0SW5wdXQgJiYgZmllbGRzWzBdICYmIGZpZWxkc1swXS5kb21FbGVtZW50ICYmIGZpZWxkc1swXS5kb21FbGVtZW50LnRhZ05hbWUgPT09ICdJTlBVVCcpIHtcbiAgICAgICAgICAgICAgICBmb3JtLmZvcm1FbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0JykuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICBzZWxmLnVuZnJlZXplU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHVuZG86IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbG9nRW50cnkgPSB0aGlzLmhpc3RvcnkucG9wKCk7XG5cbiAgICAgICAgaWYobG9nRW50cnkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q29udGVudChsb2dFbnRyeS5iZWZvcmVTdGF0ZSgpLCB7IGNhcmV0UG9zaXRpb246IGxvZ0VudHJ5LmJlZm9yZVN0YXRlQ2FyZXRQb3NpdGlvbiwgbW9kaWZpY2F0aW9uTG9nVGFnczogJ3VuZG8nIH0pO1xuICAgICAgICAgICAgdGhpcy5mb2N1c1NlY3Rpb24odGhpcy5zZWN0aW9uQXRDYXJldFBvc3Rpb24oKSwgeyBmb3JjZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIHRoaXMudW5kb25lTW9kaWZpY2F0aW9ucy5wdXNoKGxvZ0VudHJ5KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZWRvOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxvZ0VudHJ5ID0gdGhpcy51bmRvbmVNb2RpZmljYXRpb25zLnBvcCgpO1xuXG4gICAgICAgIGlmKGxvZ0VudHJ5KSB7XG4gICAgICAgICAgICB0aGlzLnNldENvbnRlbnQobG9nRW50cnkuYWZ0ZXJTdGF0ZSgpLCB7IGNhcmV0UG9zaXRpb246IGxvZ0VudHJ5LmFmdGVyU3RhdGVDYXJldFBvc2l0aW9uLCBtb2RpZmljYXRpb25Mb2dUYWdzOiAncmVkbycgfSk7XG4gICAgICAgICAgICB0aGlzLmZvY3VzU2VjdGlvbih0aGlzLnNlY3Rpb25BdENhcmV0UG9zdGlvbigpLCB7IGZvcmNlOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGVtcHR5SGlzdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuaGlzdG9yeSA9IFtdO1xuICAgICAgICB0aGlzLnVuZG9uZU1vZGlmaWNhdGlvbnMgPSBbXTtcbiAgICB9LFxuXG4gICAgc2VsZWN0RXZlcnl0aGluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsYXN0U2VjdGlvbiA9IHRoaXMuY29udGVudEVsZW1lbnQuY2hpbGRyZW5bdGhpcy5jb250ZW50RWxlbWVudC5jaGlsZHJlbi5sZW5ndGgtMV0sXG4gICAgICAgICAgICBmaXJzdFNlY3Rpb24gPSB0aGlzLmNvbnRlbnRFbGVtZW50LmNoaWxkcmVuWzBdLFxuICAgICAgICAgICAgbGFzdE5vbkVtcHR5U2VjdGlvbkluZGV4ID0gbGFzdFNlY3Rpb24uaW5uZXJUZXh0ICE9PSAnJyA/IHRoaXMuY29udGVudEVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoLTEgOiB0aGlzLmNvbnRlbnRFbGVtZW50LmNoaWxkcmVuLmxlbmd0aC0yLFxuICAgICAgICAgICAgZmlyc3ROb25FbXB0eVNlY3Rpb25JbmRleCA9IGZpcnN0U2VjdGlvbi5pbm5lclRleHQgIT09ICcnID8gMCA6IDEsXG4gICAgICAgICAgICByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCksXG4gICAgICAgICAgICBzZWwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCksXG4gICAgICAgICAgICBhbGxUZXh0Tm9kZXNPZkZpcnN0U2VjdGlvbiA9IHRoaXMuYWxsVGV4dE5vZGVzT2ZTZWN0aW9uKGZpcnN0Tm9uRW1wdHlTZWN0aW9uSW5kZXgpLFxuICAgICAgICAgICAgYWxsVGV4dE5vZGVzT2ZMYXN0U2VjdGlvbiA9IHRoaXMuYWxsVGV4dE5vZGVzT2ZTZWN0aW9uKGxhc3ROb25FbXB0eVNlY3Rpb25JbmRleCksXG4gICAgICAgICAgICBsYXN0VGV4dE5vZGVPZkxhc3RTZWN0aW9uID0gYWxsVGV4dE5vZGVzT2ZMYXN0U2VjdGlvblthbGxUZXh0Tm9kZXNPZkxhc3RTZWN0aW9uLmxlbmd0aC0xXTtcblxuICAgICAgICByYW5nZS5zZXRTdGFydChhbGxUZXh0Tm9kZXNPZkZpcnN0U2VjdGlvblswXSwgMCk7XG4gICAgICAgIHJhbmdlLnNldEVuZChsYXN0VGV4dE5vZGVPZkxhc3RTZWN0aW9uLCBsYXN0VGV4dE5vZGVPZkxhc3RTZWN0aW9uLmxlbmd0aCk7XG4gICAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgc2VsLmFkZFJhbmdlKHJhbmdlKTtcblxuICAgICAgICBpZihmaXJzdE5vbkVtcHR5U2VjdGlvbkluZGV4ICE9PSBsYXN0Tm9uRW1wdHlTZWN0aW9uSW5kZXgpIHtcbiAgICAgICAgICAgIGZvcihsZXQgaT0wOyBpPHRoaXMuY29udGVudEVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRFbGVtZW50LmNoaWxkcmVuW2ldLmJsdXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0Q29udGVudEVkaXRhYmxlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBhbGxUZXh0Tm9kZXNPZlNlY3Rpb246IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB1dGlscy5nZXRBbGxUZXh0Tm9kZXNPZkVsZW1lbnQodGhpcy5zZWN0aW9uQXQoaW5kZXgpKVxuICAgIH0sXG5cbiAgICBpc1NwZWxsY2hlY2tFbmFibGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzcGVsbGNoZWNrJykgPT09ICd0cnVlJztcbiAgICB9LFxuXG4gICAgYnVpbGRBZGRTZWN0aW9uQnV0dG9uOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIGJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICAgIGlmKHR5cGUgIT09ICdib3R0b20nICYmIHR5cGUgIT09ICd0b3AnKSByZXR1cm4gZmFsc2VcblxuICAgICAgICBidG4uY2xhc3NOYW1lID0gdHlwZSArICdTZWN0aW9uSW5zZXJ0QnV0dG9uJ1xuICAgICAgICBidG4uaW5uZXJIVE1MID0gJzxzcGFuPkFkZCBTZWN0aW9uPC9zcGFuPic7XG4gICAgICAgIGJ0bi5vbmNsaWNrID0gZnVuY3Rpb24oKSB7IHNlbGYuYWRkU2VjdGlvbih0eXBlKTsgYnRuLm9ubW91c2VvdmVyKCl9XG4gICAgICAgIGJ0bi5vbm1vdXNlb3ZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlY3Rpb24gPSBzZWxmLmNvbnRlbnRFbGVtZW50W3R5cGUgPT0gJ2JvdHRvbScgPyAnbGFzdENoaWxkJyA6ICdmaXJzdENoaWxkJ107XG4gICAgICAgICAgICBpZihzZWxmLnNob3VsZFNlY3Rpb25CZVJlbW92ZWRJZlVuZm9jdXNlZChzZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgYnRuLmNsYXNzTGlzdC5hZGQoJ2RlYWN0aXZhdGVkU2VjdGlvbkluc2VydEJ1dHRvbicpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgIGJ0bi5jbGFzc0xpc3QucmVtb3ZlKCdkZWFjdGl2YXRlZFNlY3Rpb25JbnNlcnRCdXR0b24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGJ0bjtcbiAgICB9LFxuXG4gICAgaXNDb250ZW50RWRpdGFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNDb250ZW50RWRpdGFibGU7XG4gICAgfSxcblxuICAgIHNldENvbnRlbnRFZGl0YWJsZTogZnVuY3Rpb24oc2hvdWxkQmVFZGl0YWJsZSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBpbmRleE9mRm9jdXNlZFNlY3Rpb24gPSB0aGlzLmluZGV4T2ZGb2N1c2VkU2VjdGlvbigpO1xuXG4gICAgICAgIGlmKHRoaXMuX2lzQ29udGVudEVkaXRhYmxlID09PSBzaG91bGRCZUVkaXRhYmxlKSByZXR1cm47XG5cbiAgICAgICAgdmFyIHVwZGF0ZURvbSA9IGZ1bmN0aW9uKGVsLCBzaG91bGRCZUVkaXRhYmxlKSB7XG4gICAgICAgICAgICBpZihlbC5zZXRDb250ZW50ZWRpdGFibGUpIHtcbiAgICAgICAgICAgICAgICBlbC5zZXRDb250ZW50ZWRpdGFibGUoc2hvdWxkQmVFZGl0YWJsZSwgZWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZihzaG91bGRCZUVkaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9pc0NvbnRlbnRFZGl0YWJsZSA9IHNob3VsZEJlRWRpdGFibGU7XG4gICAgICAgIGZvcihsZXQgaT0wOyBpPHRoaXMuY29udGVudEVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAgICAgaWYoTWF0aC5hYnMoaW5kZXhPZkZvY3VzZWRTZWN0aW9uIC0gaSkgPD0gMykge1xuICAgICAgICAgICAgICAgIHVwZGF0ZURvbShzZWxmLmNvbnRlbnRFbGVtZW50LmNoaWxkcmVuW2ldLCBzaG91bGRCZUVkaXRhYmxlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgKGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlRG9tKGVsLCBzaG91bGRCZUVkaXRhYmxlKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgfSkoc2VsZi5jb250ZW50RWxlbWVudC5jaGlsZHJlbltpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZihzaG91bGRCZUVkaXRhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hGb2N1cygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlZnJlc2hGb2N1czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByYW5nZSwgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgICBpZihzZWwucmFuZ2VDb3VudCA+IDAgJiYgIXRoaXMuaXNTZWxlY3Rpb25GcmVlemVkKSB7XG4gICAgICAgICAgICByYW5nZSA9IHNlbC5nZXRSYW5nZUF0KDApO1xuICAgICAgICAgICAgaWYocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBzZWwucmVtb3ZlUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgICAgIHNlbC5hZGRSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2VjdGlvbkF0OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50RWxlbWVudC5jaGlsZHJlbltpbmRleF07XG4gICAgfSxcblxuICAgIGluZGV4T2Y6IGZ1bmN0aW9uKHNlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudEVsZW1lbnQuY2hpbGRyZW4uaW5kZXhPZihzZWN0aW9uKTtcbiAgICB9LFxuXG4gICAgaW5kZXhPZkZvY3VzZWRTZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhPZih0aGlzLmZvY3VzZWRTZWN0aW9uKCkpO1xuICAgIH0sXG5cbiAgICBzY3JvbGxUb0ZvY3VzZWRTZWN0aW9uSWZOb3RJblZpZXdwb3J0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlY3Rpb247XG4gICAgICAgIGlmKHRoaXMuaXNGb2N1c2VkU2VjdGlvbkluVmlld3BvcnQoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHNlY3Rpb24gPSB0aGlzLmZvY3VzZWRTZWN0aW9uKCk7XG4gICAgICAgICAgICBpZihzZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIHNlY3Rpb24ub2Zmc2V0VG9wLSh3aW5kb3cuaW5uZXJIZWlnaHQvMikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGlzRm9jdXNlZFNlY3Rpb25JblZpZXdwb3J0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlY3Rpb24gPSB0aGlzLmZvY3VzZWRTZWN0aW9uKCk7XG4gICAgICAgIGlmKCFzZWN0aW9uKSByZXR1cm47XG4gICAgICAgIHJldHVybiB3aW5kb3cuaW5uZXJIZWlnaHQtMjAgPiBzZWN0aW9uLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnk7XG4gICAgfSxcblxuICAgIGFkZFNlY3Rpb246IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gfHwgJ2JvdHRvbSc7XG5cbiAgICAgICAgaWYocG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGROZXdTZWN0aW9uTmV4dFRvKHRoaXMuY29udGVudEVsZW1lbnQubGFzdENoaWxkKTtcbiAgICAgICAgfSBlbHNlIGlmKHBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkTmV3U2VjdGlvbk5leHRUbyh0aGlzLmNvbnRlbnRFbGVtZW50LmZpcnN0Q2hpbGQsICdiZWZvcmUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBhZGROZXdTZWN0aW9uTmV4dFRvOiBmdW5jdGlvbihzZWN0aW9uLCBwb3NpdGlvbikge1xuICAgICAgICBpZih0aGlzLnNob3VsZFNlY3Rpb25CZVJlbW92ZWRJZlVuZm9jdXNlZChzZWN0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVtcHR5U2VjdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcblxuICAgICAgICB0aGlzLm1vZGlmaWNhdGlvbkxvZ0VudHJ5ID0gbmV3IE1vZGlmaWNhdGlvbkxvZ0VudHJ5KCk7XG4gICAgICAgIGVtcHR5U2VjdGlvbi5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgZW1wdHlTZWN0aW9uLm9yaWdpbmFsSFRNTCA9IGVtcHR5U2VjdGlvbi5vdXRlckhUTUw7XG4gICAgICAgIGVtcHR5U2VjdGlvbi5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScsIHRydWUpO1xuXG4gICAgICAgIHRoaXMuY29udGVudEVsZW1lbnQuaW5zZXJ0QmVmb3JlKGVtcHR5U2VjdGlvbiwgKHBvc2l0aW9uID09PSAnYmVmb3JlJyA/IHNlY3Rpb24gOiBzZWN0aW9uLm5leHRTaWJsaW5nKSk7XG4gICAgICAgIHRoaXMubW9kaWZpY2F0aW9uTG9nRW50cnkucmV0YWluQWxsU2VjdGlvbnNCZWZvcmUoZW1wdHlTZWN0aW9uKTtcbiAgICAgICAgdGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeS5pbnNlcnRTZWN0aW9uKGVtcHR5U2VjdGlvbik7XG4gICAgICAgIHRoaXMubW9kaWZpY2F0aW9uTG9nRW50cnkucmV0YWluQWxsU2VjdGlvbnNBZnRlcihlbXB0eVNlY3Rpb24pO1xuXG4gICAgICAgIHRoaXMuZm9jdXNTZWN0aW9uKGVtcHR5U2VjdGlvbik7XG4gICAgICAgIHRoaXMuY2FyZXQucG9zaXRpb25BdFRoZUJlZ2lubmluZ09mKGVtcHR5U2VjdGlvbik7XG4gICAgICAgIHRoaXMubm90aWZ5U3Vic2NyaWJlcnModGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICByZW1vdmVTZWN0aW9uOiBmdW5jdGlvbihzZWN0aW9uKSB7XG4gICAgICAgIGlmKCF0aGlzLmlzU2VjdGlvbihzZWN0aW9uKSkgcmV0dXJuO1xuXG4gICAgICAgIGlmKHRoaXMuY29udGVudEVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLnJlcGxhY2VTZWN0aW9uV2l0aEhUTUwoc2VjdGlvbiwgJzxwPjwvcD4nKTtcbiAgICAgICAgICAgIHRoaXMuY2FyZXQucG9zaXRpb25BdFRoZUJlZ2lubmluZ09mKHRoaXMuY29udGVudEVsZW1lbnQuY2hpbGRyZW5bMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeSA9IG5ldyBNb2RpZmljYXRpb25Mb2dFbnRyeSgpO1xuICAgICAgICAgICAgdGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeS5tb2RMb2dGbGFncyA9IHRoaXMubW9kTG9nRmxhZ3M7XG4gICAgICAgICAgICB0aGlzLm1vZGlmaWNhdGlvbkxvZ0VudHJ5LnJldGFpbkFsbFNlY3Rpb25zQmVmb3JlKHNlY3Rpb24pO1xuICAgICAgICAgICAgdGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeS5kZWxldGVTZWN0aW9uKHNlY3Rpb24pO1xuICAgICAgICAgICAgdGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeS5yZXRhaW5BbGxTZWN0aW9uc0FmdGVyKHNlY3Rpb24pO1xuXG4gICAgICAgICAgICB0aGlzLmNhcmV0LnNhdmVTZWxlY3Rpb24odGhpcy5jb250ZW50RWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHNlY3Rpb24pO1xuICAgICAgICAgICAgdGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeS53b3JkQ291bnQgPSB0aGlzLmdldFdvcmRDb3VudCgpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGb290bm90ZXNOdW1iZXJpbmcoKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUmVmZXJlbmNlTnVtYmVyaW5nKCk7XG4gICAgICAgICAgICB0aGlzLmNhcmV0LnJlc3RvcmVTZWxlY3Rpb24oMCk7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeVN1YnNjcmliZXJzKHRoaXMubW9kaWZpY2F0aW9uTG9nRW50cnkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGFkZFNlY3Rpb25UeXBlOiBmdW5jdGlvbihzZWN0aW9uVHlwZSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMudGFnVHJhbnNmb3JtYXRpb25zLCBzZWN0aW9uVHlwZS50YWdUcmFuc2Zvcm1hdGlvbnMgfHwge30pO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuY29udGVudFJ1bGVzLCBzZWN0aW9uVHlwZS5jb250ZW50UnVsZXMgfHwge30pO1xuICAgICAgICB0aGlzLnRleHRFbnJpY2htZW50Q29udHJvbC5hZGRFbnJpY2htZW50cyhzZWN0aW9uVHlwZS5lbnJpY2htZW50cyB8fCBbXSk7XG4gICAgICAgIHRoaXMuc3VwcG9ydGVkU2VjdGlvblR5cGVzW3NlY3Rpb25UeXBlLm5hbWVdID0gc2VjdGlvblR5cGU7XG5cbiAgICAgICAgaWYoc2VjdGlvblR5cGUub25FZGl0b3JDb250ZW50Q2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmUoc2VjdGlvblR5cGUub25FZGl0b3JDb250ZW50Q2hhbmdlZCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc3Vic2NyaWJlOiBmdW5jdGlvbihjYWxsYmFjaywgbm90aWZ5T25NZXRhZGF0YUNoYW5nZSkge1xuXG4gICAgICAgIGlmKG5vdGlmeU9uTWV0YWRhdGFDaGFuZ2UpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLm5vdGlmeU9uTWV0YWRhdGFDaGFuZ2UgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdWJzY3JpYmVycy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgc3Vic2NyaWJlUmVmZXJlbmNlSW5zZXJ0aW9uOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICB0aGlzLnJlZmVyZW5jZUluc2VydGVkU3Vic2NyaWJlcnMucHVzaChjYWxsYmFjayk7XG4gICAgfSxcblxuICAgIHN1YnNjcmliZVNlY3Rpb25Gb2N1c0NoYW5nZTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5zZWN0aW9uRm9jdXNDaGFuZ2VTdWJzY3JpYmVycy5wdXNoKGNhbGxiYWNrKVxuICAgIH0sXG5cbiAgICBpc0lucHV0RXZlbnRQcm9jZXNzaW5nQWN0aXZhdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xlYW51cENvbnRlbnRPbklucHV0RXZlbnQ7XG4gICAgfSxcblxuICAgIGRlYWN0aXZhdGVJbnB1dEV2ZW50UHJvY2Vzc2luZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvcihsZXQgaT0wOyBpPHRoaXMuY29udGVudEVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudEVsZW1lbnQuY2hpbGRyZW5baV0uSFRNTGJldm9yZUlucHV0UHJvY2Vzc2luZ0RlYWN0aXZhdGlvbiA9IHRoaXMuY29udGVudEVsZW1lbnQuY2hpbGRyZW5baV0ub3V0ZXJIVE1MO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZWN0aW9uQ291bnRCZWZvcmVJbnB1dFByb2Nlc3NpbmcgPSB0aGlzLmNvbnRlbnRFbGVtZW50LmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgdGhpcy5jbGVhbnVwQ29udGVudE9uSW5wdXRFdmVudCA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICBhY3RpdmF0ZUlucHV0RXZlbnRQcm9jZXNzaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jbGVhbnVwQ29udGVudE9uSW5wdXRFdmVudCA9IHRydWU7XG4gICAgICAgIHZhciBjaGFuZ2VzTWFkZSA9IGZhbHNlO1xuXG4gICAgICAgIGlmKHRoaXMuc2VjdGlvbkNvdW50QmVmb3JlSW5wdXRQcm9jZXNzaW5nID09PSB0aGlzLmNvbnRlbnRFbGVtZW50LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yKGxldCBpPTA7IGk8dGhpcy5jb250ZW50RWxlbWVudC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuY29udGVudEVsZW1lbnQuY2hpbGRyZW5baV0uZm9yY2VVcGRhdGVPbklucHV0UHJvY2Vzc3NpbmdFbmFibGVtZW50IHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGVudEVsZW1lbnQuY2hpbGRyZW5baV0uSFRNTGJldm9yZUlucHV0UHJvY2Vzc2luZ0RlYWN0aXZhdGlvbiAhPT0gdGhpcy5jb250ZW50RWxlbWVudC5jaGlsZHJlbltpXS5vdXRlckhUTUwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlU2VjdGlvbldpdGhIVE1MKHRoaXMuY29udGVudEVsZW1lbnQuY2hpbGRyZW5baV0sIHRoaXMuY29udGVudEVsZW1lbnQuY2hpbGRyZW5baV0ub3V0ZXJIVE1MKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlc01hZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNvbnRlbnRFbGVtZW50LmNoaWxkcmVuW2ldLkhUTUxiZXZvcmVJbnB1dFByb2Nlc3NpbmdEZWFjdGl2YXRpb247XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuY29udGVudEVsZW1lbnQuY2hpbGRyZW5baV0uZm9yY2VVcGRhdGVPbklucHV0UHJvY2Vzc3NpbmdFbmFibGVtZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihjaGFuZ2VzTWFkZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRm9vdG5vdGVzTnVtYmVyaW5nKCk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVSZWZlcmVuY2VOdW1iZXJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudCh0aGlzLmNvbnRlbnRFbGVtZW50LmlubmVySFRNTCk7XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgdGhpcy5zZWN0aW9uQ291bnRCZWZvcmVJbnB1dFByb2Nlc3Npbmc7XG4gICAgfSxcblxuICAgIGZyZWV6ZVNlbGVjdGlvbjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3MgfHwge30sXG4gICAgICAgICAgICBjbGlja2FibGVFbGVtZW50ID0gYXJnc1sndW5mcmVlemVPbkNsaWNrc091dHNpdGVPZiddLFxuICAgICAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBmO1xuXG4gICAgICAgIHRoaXMudW5mcmVlemVDYWxsYmFjayA9IGFyZ3NbJ3VuZnJlZXplQ2FsbGJhY2snXTtcblxuICAgICAgICBpZihjbGlja2FibGVFbGVtZW50KSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gZS50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHBhdGggPSBbXTtcblxuICAgICAgICAgICAgICAgIHdoaWxlKHRtcC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGgucHVzaCh0bXAucGFyZW50RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIHRtcCA9IHRtcC5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKHBhdGguaW5kZXhPZihjbGlja2FibGVFbGVtZW50KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi51bmZyZWV6ZVNlbGVjdGlvbihmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCF0aGlzLmlzU2VsZWN0aW9uRnJlZXplZCkge1xuICAgICAgICAgICAgdGhpcy5kZWFjdGl2YXRlSW5wdXRFdmVudFByb2Nlc3NpbmcoKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKCdiYWNrQ29sb3InLCBmYWxzZSwgJyNiMmQ3ZmQnKTtcbiAgICAgICAgICAgIHRoaXMuY2FyZXQuc2F2ZVNlbGVjdGlvbih0aGlzLmNvbnRlbnRFbGVtZW50KTtcbiAgICAgICAgICAgIHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgIHRoaXMuaXNTZWxlY3Rpb25GcmVlemVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB1bmZyZWV6ZVNlbGVjdGlvbjogZnVuY3Rpb24ocmVzdG9yZVNlbGVjdGlvbikge1xuICAgICAgICBpZih0aGlzLmlzU2VsZWN0aW9uRnJlZXplZCkge1xuICAgICAgICAgICAgcmVzdG9yZVNlbGVjdGlvbiA9IHJlc3RvcmVTZWxlY3Rpb24gPT09IHVuZGVmaW5lZCA/IHRydWUgOiByZXN0b3JlU2VsZWN0aW9uO1xuXG4gICAgICAgICAgICBpZihyZXN0b3JlU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5jYXJldC5zZWxlY3Rpb25Jc0NvbGxhcHNlZCAmJiB0aGlzLmNhcmV0LnNlbGVjdGlvbkZvY3VzTm9kZS50YWdOYW1lID09PSAnVEQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FyZXQucmVzdG9yZVNlbGVjdGlvbihmYWxzZSwgJ1RyeURPTVN0cmF0ZWd5Rmlyc3QnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhcmV0LnJlc3RvcmVTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVJbnB1dEV2ZW50UHJvY2Vzc2luZygpO1xuXG4gICAgICAgICAgICBpZih0aGlzLnVuZnJlZXplQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuZnJlZXplQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVuZnJlZXplQ2FsbGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pc1NlbGVjdGlvbkZyZWV6ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBub3RpZnlTdWJzY3JpYmVyczogZnVuY3Rpb24obW9kaWZpY2F0aW9uTG9nRW50cnkpIHtcbiAgICAgICAgdGhpcy5fY2xlYW51cE1vZGlmaWNhdGlvbkxvZ0Zyb21FZGl0b3JTcGVjaWZpY01hcmt1cChtb2RpZmljYXRpb25Mb2dFbnRyeSk7XG5cbiAgICAgICAgY29uc3Qgbm9Ob09wID0gbW9kaWZpY2F0aW9uTG9nRW50cnkubG9nLmZpbmQobCA9PiB7XG4gICAgICAgICAgICBpZihsLnR5cGUgPT09ICdyZXRhaW4nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihsLnR5cGUgPT09ICdyZXBsYWNlJyAmJiBsLm5ld1NlY3Rpb25IVE1MID09PSBsLm9sZFNlY3Rpb25IVE1MKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSlcblxuICAgICAgICBpZighbm9Ob09wKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZXJzLmZpbHRlcihjYiA9PiBjYi5ub3RpZnlPbk1ldGFkYXRhQ2hhbmdlKS5mb3JFYWNoKGZ1bmN0aW9uKGYpIHtmKG1vZGlmaWNhdGlvbkxvZ0VudHJ5KX0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uKGYpIHtmKG1vZGlmaWNhdGlvbkxvZ0VudHJ5KX0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNlY3Rpb25CeUNoaWxkTm9kZTogZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgd2hpbGUoY2hpbGQpIHtcbiAgICAgICAgICAgIGlmKHRoaXMuaXNTZWN0aW9uKGNoaWxkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkID0gY2hpbGQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZWN0aW9uQXRDYXJldFBvc3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWN0aW9uQnlDaGlsZE5vZGUodGhpcy5jYXJldC50YXJnZXRFbGVtZW50KCkpO1xuICAgIH0sXG5cbiAgICBhcmVNdWx0aXBsZVNlY3Rpb25zU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpLCBzMSwgczI7XG5cbiAgICAgICAgaWYoIXNlbCB8fCBzZWwuaXNDb2xsYXBzZWQpIHsgcmV0dXJuIGZhbHNlIH1cblxuICAgICAgICBzMSA9IHRoaXMuc2VjdGlvbkJ5Q2hpbGROb2RlKHNlbC5hbmNob3JOb2RlKTtcbiAgICAgICAgczIgPSB0aGlzLnNlY3Rpb25CeUNoaWxkTm9kZShzZWwuZm9jdXNOb2RlKTtcblxuICAgICAgICByZXR1cm4gczEgJiYgczIgJiYgczEgIT09IHMyO1xuICAgIH0sXG5cbiAgICBwbGFjZUNhcmV0SW50b1NlY3Rpb246IGZ1bmN0aW9uKHNlY3Rpb24sIHBvc2l0aW9uLCBkb05vdEZvY3VzU2VjdGlvbikge1xuICAgICAgICBpZighc2VjdGlvbikgcmV0dXJuO1xuICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uIHx8ICdlbmQnO1xuXG4gICAgICAgIGlmKHBvc2l0aW9uID09PSAncHJlZmVycmVkT3JCZWdpbm5pbmcnKSB7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IHNlY3Rpb24uc2VjdGlvblR5cGUgJiYgc2VjdGlvbi5zZWN0aW9uVHlwZS5wcmVmZXJyZWRDYXJldFBvc2l0aW9uaW5nIHx8ICdiZWdpbm5pbmcnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRhcmdldEVsID0gc2VjdGlvbixcbiAgICAgICAgICAgIHRtcFRhcmdldEVsO1xuXG4gICAgICAgIGlmKHNlY3Rpb24uc2VjdGlvblR5cGUgJiYgc2VjdGlvbi5zZWN0aW9uVHlwZS5lZGl0YWJsZUVsZW1lbnRTZWxlY3Rvcikge1xuICAgICAgICAgICAgdG1wVGFyZ2V0RWwgPSBzZWN0aW9uLnF1ZXJ5U2VsZWN0b3Ioc2VjdGlvbi5zZWN0aW9uVHlwZS5lZGl0YWJsZUVsZW1lbnRTZWxlY3Rvcik7XG4gICAgICAgICAgICB0YXJnZXRFbCA9IHRtcFRhcmdldEVsIHx8IHNlY3Rpb247XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpLFxuICAgICAgICAgICAgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpLFxuICAgICAgICAgICAgdGV4dE5vZGVzID0gdXRpbHMuZ2V0QWxsVGV4dE5vZGVzT2ZFbGVtZW50KHRhcmdldEVsKSxcbiAgICAgICAgICAgIHRleHROb2RlID0gcG9zaXRpb24gPT09ICdlbmQnID8gdGV4dE5vZGVzW3RleHROb2Rlcy5sZW5ndGgtMV0gOiB0ZXh0Tm9kZXNbMF07XG5cbiAgICAgICAgLy8gVGhlIGZvY3VzL2FuY2hvciBub2RlIHNob3VsZCBiZSB0aGUgZGVlcGVzdCBub2RlIHBvc3NpYmxlLlxuICAgICAgICAvLyBPdGhlcndpc2UgdGhlIHRleHQgZW5yaWNobWVudCBjb250cm9sbHMgd2lsbCBiZSBwbGFjZWQgYXQgdGhlIHdyb25nXG4gICAgICAgIC8vIHBvc2l0aW9uLlxuXG4gICAgICAgIGlmKHBvc2l0aW9uID09PSAnZW5kJyAmJiB0ZXh0Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5jYXJldC5wb3NpdGlvbkFmdGVyKHRleHROb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyh0ZXh0Tm9kZSB8fCB0YXJnZXRFbCk7XG4gICAgICAgICAgICByYW5nZS5jb2xsYXBzZShwb3NpdGlvbiAhPT0gJ2VuZCcpO1xuICAgICAgICAgICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgc2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFkb05vdEZvY3VzU2VjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5mb2N1c1NlY3Rpb24odGFyZ2V0RWwsIHthY3Rpb246ICdwbGFjZUNhcmV0SW50b1NlY3Rpb24nfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaXNTZWN0aW9uOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50ICYmXG4gICAgICAgICAgICAgICBlbGVtZW50LnBhcmVudEVsZW1lbnQgPT09IHRoaXMuY29udGVudEVsZW1lbnQgJiZcbiAgICAgICAgICAgICAgIGVsZW1lbnQubm9kZVR5cGUgIT09IE5vZGUuVEVYVF9OT0RFO1xuICAgIH0sXG5cbiAgICBmb2N1c1NlY3Rpb246IGZ1bmN0aW9uKGVsZW1lbnQsIGFyZ3MpIHtcbiAgICAgICAgYXJncyA9IGFyZ3MgfHwge307XG4gICAgICAgIGlmKCFlbGVtZW50IHx8ICF0aGlzLmlzU2VjdGlvbihlbGVtZW50KSkgcmV0dXJuO1xuICAgICAgICBpZih0aGlzLmZvY3VzZWRFbGVtZW50ID09PSBlbGVtZW50ICYmICFhcmdzLmZvcmNlKSByZXR1cm47XG4gICAgICAgIHZhciBpc0FscmVhZHlIaWdobGlnaHRlZCA9IGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdmb2N1c2VkJyk7XG5cbiAgICAgICAgdGhpcy51bmZvY3VzU2VjdGlvbigpO1xuICAgICAgICB0aGlzLmZvY3VzZWRFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5mb2N1c2VkRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdmb2N1c2VkJyk7XG5cbiAgICAgICAgdGhpcy5zZWN0aW9uRm9jdXNDaGFuZ2VTdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uKGNiKSB7Y2IoKX0pO1xuICAgICAgICB0aGlzLnNlY3Rpb25UeXBlU2VsZWN0b3IuZGlzcGxheU5leHRUbyh0aGlzLmZvY3VzZWRFbGVtZW50KTtcblxuICAgICAgICBpZighaXNBbHJlYWR5SGlnaGxpZ2h0ZWQpIHtcbiAgICAgICAgICAgIGlmKGVsZW1lbnQgJiYgZWxlbWVudC5zZWN0aW9uVHlwZSAmJiBlbGVtZW50LnNlY3Rpb25UeXBlLm9uRm9jdXMpIHtcbiAgICAgICAgICAgICAgICBpZighdGhpcy5hcmVNdWx0aXBsZVNlY3Rpb25zU2VsZWN0ZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnNlY3Rpb25UeXBlLm9uRm9jdXMoZWxlbWVudCwgdGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIHVuZm9jdXNTZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgZm9jdXNlZFNlY3Rpb25zID0gdGhpcy5jb250ZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZm9jdXNlZCcpO1xuXG4gICAgICAgIGZvY3VzZWRTZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHNlYykge1xuICAgICAgICAgICAgaWYoc2VjLmNsYXNzTGlzdC5jb250YWlucygnZm9jdXNlZCcpKSB7XG4gICAgICAgICAgICAgICAgc2VjLmNsYXNzTGlzdC5yZW1vdmUoJ2ZvY3VzZWQnKTtcblxuICAgICAgICAgICAgICAgIGlmKHNlYy5vblVuZm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VjLm9uVW5mb2N1cyhzZWxmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNlbGYuc2VjdGlvblR5cGVTZWxlY3Rvci5oaWRlKCk7XG4gICAgICAgIHRoaXMuZm9jdXNlZEVsZW1lbnQgPSBudWxsO1xuICAgIH0sXG5cbiAgICBmb2N1c2VkU2VjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvY3VzZWRFbGVtZW50O1xuICAgIH0sXG5cbiAgICBpc0ZvY3VzZWQ6IGZ1bmN0aW9uKHNlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHNlY3Rpb24gPT09IHRoaXMuZm9jdXNlZEVsZW1lbnQ7XG4gICAgfSxcblxuICAgIG1vdmVDYXJldE9uZVNlY3Rpb25VcDogZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiB8fCAnZW5kJztcbiAgICAgICAgdmFyIHMgPSB0aGlzLmZvY3VzZWRTZWN0aW9uKCk7XG4gICAgICAgIHRoaXMucGxhY2VDYXJldEludG9TZWN0aW9uKHMgJiYgcy5wcmV2aW91c1NpYmxpbmcsIHBvc2l0aW9uLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgbW92ZUNhcmV0T25lU2VjdGlvbkRvd246IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gfHwgJ2VuZCc7XG4gICAgICAgIHZhciBzID0gdGhpcy5mb2N1c2VkU2VjdGlvbigpO1xuICAgICAgICB0aGlzLnBsYWNlQ2FyZXRJbnRvU2VjdGlvbihzICYmIHMubmV4dFNpYmxpbmcsIHBvc2l0aW9uLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgbW92ZUZvY3VzZWRTZWN0aW9uVXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZm9jdXNlZFNlY3Rpb24gPSB0aGlzLmZvY3VzZWRTZWN0aW9uKCk7XG4gICAgICAgIGlmKGZvY3VzZWRTZWN0aW9uICYmIGZvY3VzZWRTZWN0aW9uLnByZXZpb3VzU2libGluZykge1xuICAgICAgICAgICAgdGhpcy5jYXJldC5zYXZlU2VsZWN0aW9uKHRoaXMuY29udGVudEVsZW1lbnQpO1xuXG4gICAgICAgICAgICB0aGlzLm1vZGlmaWNhdGlvbkxvZ0VudHJ5ID0gbmV3IE1vZGlmaWNhdGlvbkxvZ0VudHJ5KCk7XG4gICAgICAgICAgICB0aGlzLm1vZGlmaWNhdGlvbkxvZ0VudHJ5Lm1vZExvZ0ZsYWdzID0gdGhpcy5tb2RMb2dGbGFncztcbiAgICAgICAgICAgIHRoaXMubW9kaWZpY2F0aW9uTG9nRW50cnkucmV0YWluQWxsU2VjdGlvbnNCZWZvcmUoZm9jdXNlZFNlY3Rpb24ucHJldmlvdXNTaWJsaW5nKTtcbiAgICAgICAgICAgIHRoaXMubW9kaWZpY2F0aW9uTG9nRW50cnkucmVwbGFjZVNlY3Rpb24oZm9jdXNlZFNlY3Rpb24ucHJldmlvdXNTaWJsaW5nLCBmb2N1c2VkU2VjdGlvbik7XG4gICAgICAgICAgICB0aGlzLm1vZGlmaWNhdGlvbkxvZ0VudHJ5LnJlcGxhY2VTZWN0aW9uKGZvY3VzZWRTZWN0aW9uLCBmb2N1c2VkU2VjdGlvbi5wcmV2aW91c1NpYmxpbmcpO1xuICAgICAgICAgICAgdGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeS5yZXRhaW5BbGxTZWN0aW9uc0FmdGVyKGZvY3VzZWRTZWN0aW9uKTtcblxuICAgICAgICAgICAgdGhpcy5jb250ZW50RWxlbWVudC5pbnNlcnRCZWZvcmUoZm9jdXNlZFNlY3Rpb24sIGZvY3VzZWRTZWN0aW9uLnByZXZpb3VzU2libGluZyk7XG4gICAgICAgICAgICB0aGlzLmNhcmV0LnJlc3RvcmVTZWxlY3Rpb24oMCwgJ0RPTVN0cmF0ZWd5Jyk7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeVN1YnNjcmliZXJzKHRoaXMubW9kaWZpY2F0aW9uTG9nRW50cnkpO1xuICAgICAgICAgICAgdGhpcy5zZWN0aW9uVHlwZVNlbGVjdG9yLmRpc3BsYXlOZXh0VG8odGhpcy5mb2N1c2VkU2VjdGlvbigpKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRm9vdG5vdGVzTnVtYmVyaW5nKCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVJlZmVyZW5jZU51bWJlcmluZygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1vdmVGb2N1c2VkU2VjdGlvbkRvd246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZm9jdXNlZFNlY3Rpb24gPSB0aGlzLmZvY3VzZWRTZWN0aW9uKCk7XG4gICAgICAgIGlmKGZvY3VzZWRTZWN0aW9uICYmIGZvY3VzZWRTZWN0aW9uLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmNhcmV0LnNhdmVTZWxlY3Rpb24odGhpcy5jb250ZW50RWxlbWVudCk7XG5cbiAgICAgICAgICAgIHRoaXMubW9kaWZpY2F0aW9uTG9nRW50cnkgPSBuZXcgTW9kaWZpY2F0aW9uTG9nRW50cnkoKTtcbiAgICAgICAgICAgIHRoaXMubW9kaWZpY2F0aW9uTG9nRW50cnkubW9kTG9nRmxhZ3MgPSB0aGlzLm1vZExvZ0ZsYWdzO1xuICAgICAgICAgICAgdGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeS5yZXRhaW5BbGxTZWN0aW9uc0JlZm9yZShmb2N1c2VkU2VjdGlvbik7XG4gICAgICAgICAgICB0aGlzLm1vZGlmaWNhdGlvbkxvZ0VudHJ5LnJlcGxhY2VTZWN0aW9uKGZvY3VzZWRTZWN0aW9uLCBmb2N1c2VkU2VjdGlvbi5uZXh0U2libGluZyk7XG4gICAgICAgICAgICB0aGlzLm1vZGlmaWNhdGlvbkxvZ0VudHJ5LnJlcGxhY2VTZWN0aW9uKGZvY3VzZWRTZWN0aW9uLm5leHRTaWJsaW5nLCBmb2N1c2VkU2VjdGlvbik7XG4gICAgICAgICAgICB0aGlzLm1vZGlmaWNhdGlvbkxvZ0VudHJ5LnJldGFpbkFsbFNlY3Rpb25zQWZ0ZXIoZm9jdXNlZFNlY3Rpb24ubmV4dFNpYmxpbmcpO1xuXG4gICAgICAgICAgICBpZihmb2N1c2VkU2VjdGlvbi5uZXh0U2libGluZy5uZXh0U2libGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudEVsZW1lbnQuaW5zZXJ0QmVmb3JlKGZvY3VzZWRTZWN0aW9uLCBmb2N1c2VkU2VjdGlvbi5uZXh0U2libGluZy5uZXh0U2libGluZyk7XG4gICAgICAgICAgICB9IGVsc2UgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRFbGVtZW50LmFwcGVuZENoaWxkKGZvY3VzZWRTZWN0aW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jYXJldC5yZXN0b3JlU2VsZWN0aW9uKDAsICdET01TdHJhdGVneScpO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlTdWJzY3JpYmVycyh0aGlzLm1vZGlmaWNhdGlvbkxvZ0VudHJ5KTtcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvblR5cGVTZWxlY3Rvci5kaXNwbGF5TmV4dFRvKHRoaXMuZm9jdXNlZFNlY3Rpb24oKSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZvb3Rub3Rlc051bWJlcmluZygpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVSZWZlcmVuY2VOdW1iZXJpbmcoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjaGFuZ2VGb2N1c2VkU2VjdGlvblR5cGU6IGZ1bmN0aW9uKHNlY3Rpb25UeXBlTmFtZSwgYW5ub3RhdGlvbikge1xuICAgICAgICB2YXIgZm9jdXNlZFNlY3Rpb24gPSB0aGlzLmZvY3VzZWRTZWN0aW9uKCksXG4gICAgICAgICAgICBzdCA9IHRoaXMuc3VwcG9ydGVkU2VjdGlvblR5cGVzW3NlY3Rpb25UeXBlTmFtZV0sXG4gICAgICAgICAgICBuZXdFbCwgc2VjdGlvbkNyZWF0b3IsIHNlY3Rpb25JbmRleCwgY2hhbmdlZFNlY3Rpb24sXG4gICAgICAgICAgICBzZWxmID0gdGhpcywgbmV3Q29udGVudCwgb2xkQ29udGVudCwgcnVsZTtcblxuICAgICAgICBpZihhbm5vdGF0aW9uKSB7XG4gICAgICAgICAgICBhbm5vdGF0aW9uID0gW2Fubm90YXRpb25dXG4gICAgICAgIH1cblxuICAgICAgICBzZWN0aW9uQ3JlYXRvciA9IChzdCAmJiBzdC5nZXRTZWN0aW9uRWxlbWVudCkgfHwgZnVuY3Rpb24oZXhpc3RpbmdTZWN0aW9uQ29udGVudCkge1xuICAgICAgICAgICAgbmV3Q29udGVudCA9IHNlbGYuaHRtbFJhem9yLmNsZWFudXBIVE1MKCc8JyArIHNlY3Rpb25UeXBlTmFtZSArICc+JyArICBleGlzdGluZ1NlY3Rpb25Db250ZW50ICsgICc8JyArIHNlY3Rpb25UeXBlTmFtZSArICc+Jyk7XG4gICAgICAgICAgICBuZXdDb250ZW50ID0gbmV3Q29udGVudC5uZXh0KCkgfHwgJyc7XG4gICAgICAgICAgICBuZXdDb250ZW50ID0gbmV3Q29udGVudC52YWx1ZSB8fCAnJztcbiAgICAgICAgICAgIHJldHVybiBuZXdDb250ZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoZm9jdXNlZFNlY3Rpb24pIHtcbiAgICAgICAgICAgIHJ1bGUgPSBzdCAmJiBPYmplY3QudmFsdWVzKHN0LmNvbnRlbnRSdWxlcykuZmluZChmdW5jdGlvbihyKSB7IHJldHVybiByLmFsbG93ZWRUb0JlUm9vdCB9KTtcbiAgICAgICAgICAgIG9sZENvbnRlbnQgPSBmb2N1c2VkU2VjdGlvbi5pbm5lckhUTUxcblxuICAgICAgICAgICAgaWYoZm9jdXNlZFNlY3Rpb24udGFnTmFtZSA9PT0gJ1BSRScgJiYgZm9jdXNlZFNlY3Rpb24ucXVlcnlTZWxlY3RvcignY29kZScpKSB7XG4gICAgICAgICAgICAgICAgb2xkQ29udGVudCA9IGZvY3VzZWRTZWN0aW9uLnF1ZXJ5U2VsZWN0b3IoJ2NvZGUnKS5pbm5lclRleHRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbmV3RWwgPSBzZWN0aW9uQ3JlYXRvcihvbGRDb250ZW50LCBhbm5vdGF0aW9uLCBydWxlKSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHNlY3Rpb25UeXBlTmFtZSk7XG4gICAgICAgICAgICBzZWN0aW9uSW5kZXggPSB0aGlzLmluZGV4T2YoZm9jdXNlZFNlY3Rpb24pO1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlU2VjdGlvbldpdGhIVE1MKGZvY3VzZWRTZWN0aW9uLCBuZXdFbC5vdXRlckhUTUwsIHthY3Rpb246ICdjaGFuZ2VGb2N1c2VkU2VjdGlvblR5cGUnfSk7XG4gICAgICAgICAgICB1dGlscy5jb3B5RXZlbnRMaXN0ZW5lcnNSZWN1cnNpdmVseShuZXdFbCwgdGhpcy5jb250ZW50RWxlbWVudC5jaGlsZHJlbltzZWN0aW9uSW5kZXhdKTtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNTZWN0aW9uKG5ld0VsLCB7YWN0aW9uOiAnY2hhbmdlRm9jdXNlZFNlY3Rpb25UeXBlJ30pO1xuICAgICAgICAgICAgY2hhbmdlZFNlY3Rpb24gPSB0aGlzLmNvbnRlbnRFbGVtZW50LmNoaWxkcmVuW3NlY3Rpb25JbmRleF07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWVyZ2VQYXJhZ3JhcGhJbnRvTGlzdElmU2VjdGlvblR5cGVNYXRjaDogZnVuY3Rpb24oczEsIHMyKSB7XG4gICAgICAgIHZhciBsaUl0ZW0sIG5ld0VsZW1lbnQ7XG5cbiAgICAgICAgaWYoczEudGFnTmFtZSAhPT0gJ1VMJyAmJiBzMS50YWdOYW1lICE9PSAnT0wnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZihzMi50YWdOYW1lICE9PSAnUCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld0VsZW1lbnQgPSBzMS5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAgICBuZXdFbGVtZW50LmlubmVySFRNTCA9IHMxLmlubmVySFRNTCArICc8bGk+JyArICBzMi5pbm5lckhUTUwgKyAnPC9saT4nXG4gICAgICAgIHJldHVybiBuZXdFbGVtZW50O1xuICAgIH0sXG5cbiAgICBtZXJnZVNpbXBsZVRleHRTZWN0aW9uc0lmU2VjdGlvblR5cGVNYXRjaDogZnVuY3Rpb24oczEsIHMyKSB7XG4gICAgICAgIGlmKCFzMSB8fCAhczIpIHsgcmV0dXJuIGZhbHNlIH1cblxuICAgICAgICB2YXIgczJJc0VtcHR5ID0gczIuaW5uZXJIVE1MLnRyaW0oKSA9PT0gJycsXG4gICAgICAgICAgICBtZXJnZWFibGUgPSBbJ1AnLCAnSDEnLCAnSDInLCAnSDMnLCAnSDQnLCAnSDUnXSxcbiAgICAgICAgICAgIG5ld0VsZW1lbnQ7XG5cbiAgICAgICAgaWYoczJJc0VtcHR5KSB7XG4gICAgICAgICAgICByZXR1cm4gczE7XG4gICAgICAgIH1cblxuICAgICAgICBpZihtZXJnZWFibGUuaW5jbHVkZXNBbGwoczEudGFnTmFtZSwgczIudGFnTmFtZSkpIHtcbiAgICAgICAgICAgIG5ld0VsZW1lbnQgPSBzMS5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAgICAgICAgbmV3RWxlbWVudC5pbm5lckhUTUwgPSBzMS5pbm5lckhUTUwgKyBzMi5pbm5lckhUTUw7XG4gICAgICAgICAgICByZXR1cm4gbmV3RWxlbWVudDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXJnZVNlY3Rpb25zOiBmdW5jdGlvbihzMSwgczIpIHtcbiAgICAgICAgdmFyIHNlY3Rpb25JbmRleCA9IHRoaXMuaW5kZXhPZihzMSksXG4gICAgICAgICAgICBzMklzRW1wdHkgPSBzMi5pbm5lclRleHQudHJpbSgpID09PSAnJyxcbiAgICAgICAgICAgIG5ld0VsZW1lbnQ7XG5cbiAgICAgICAgbmV3RWxlbWVudCA9IHRoaXMubWVyZ2VQYXJhZ3JhcGhJbnRvTGlzdElmU2VjdGlvblR5cGVNYXRjaChzMSwgczIpO1xuXG4gICAgICAgIGlmKCFuZXdFbGVtZW50KSB7XG4gICAgICAgICAgICBuZXdFbGVtZW50ID0gdGhpcy5tZXJnZVNpbXBsZVRleHRTZWN0aW9uc0lmU2VjdGlvblR5cGVNYXRjaChzMSwgczIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYobmV3RWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5zZXRDb250ZW50KG5ld0VsZW1lbnQub3V0ZXJIVE1MLCB7IHN0YXJ0U2VjdGlvbjogczEsIGVuZFNlY3Rpb246IHMyIH0pO1xuXG4gICAgICAgICAgICBpZihzMklzRW1wdHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBsYWNlQ2FyZXRJbnRvU2VjdGlvbih0aGlzLmNvbnRlbnRFbGVtZW50LmNoaWxkcmVuW3NlY3Rpb25JbmRleF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlcGxhY2VTZWN0aW9uV2l0aEhUTUw6IGZ1bmN0aW9uKG9sZFNlY3Rpb24sIG91dGVySFRNTCwgYXJncykge1xuICAgICAgICBhcmdzID0gYXJncyB8fCB7fTtcbiAgICAgICAgYXJncy5zZWN0aW9uID0gb2xkU2VjdGlvbjtcbiAgICAgICAgdGhpcy5zZXRDb250ZW50KG91dGVySFRNTCwgYXJncyk7XG4gICAgfSxcblxuICAgIGNvbnRlbnQ6IGZ1bmN0aW9uKGNvbnRlbnQsIGFyZ3MpIHtcbiAgICAgICAgaWYodHlwZW9mIGNvbnRlbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb250ZW50KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRDb250ZW50KGNvbnRlbnQsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldENvbnRlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZW5kZXJlZENvbnRlbnQoKTtcbiAgICB9LFxuXG4gICAgZ2V0UmVuZGVyZWRDb250ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnLFxuICAgICAgICBzZWN0aW9uID0gdGhpcy5jb250ZW50RWxlbWVudC5jaGlsZHJlblswXTtcblxuICAgICAgICB3aGlsZShzZWN0aW9uKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5fY2xlYW51cEhUTUxGcm9tRWRpdG9yU3BlY2lmaWNNYXJrdXBGb3JTZWN0aW9uSFRNTChzZWN0aW9uLm91dGVySFRNTCk7XG4gICAgICAgICAgICBzZWN0aW9uID0gc2VjdGlvbi5uZXh0U2libGluZztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGdldE9yaWdpbmFsQ29udGVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAnJyxcbiAgICAgICAgICAgIHNlY3Rpb24gPSB0aGlzLmNvbnRlbnRFbGVtZW50LmNoaWxkcmVuWzBdO1xuXG4gICAgICAgIHdoaWxlKHNlY3Rpb24pIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLl9jbGVhbnVwSFRNTEZyb21FZGl0b3JTcGVjaWZpY01hcmt1cEZvclNlY3Rpb25IVE1MKHNlY3Rpb24ub3JpZ2luYWxIVE1MKTtcbiAgICAgICAgICAgIHNlY3Rpb24gPSBzZWN0aW9uLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXBwbHlDaGFuZ2VzZXQ6IGZ1bmN0aW9uKGNoYW5nZXNldCwgYXR0cikge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciB0b3RhbE9sZENvbnRlbnRMZW5ndGggPSAwO1xuICAgICAgICB2YXIgY2hhbmdlc2V0Q3Vyc29yT2xkVmVyc2lvbiA9IDA7XG4gICAgICAgIHZhciBjaGFuZ2VzZXRDdXJzb3JOZXdWZXJzaW9uID0gMDtcbiAgICAgICAgdmFyIGxlbmd0aE9mVW5jaGFuZ2VkU2VjdGlvbiA9IDA7XG4gICAgICAgIHZhciBsZW5ndGhPZlJlbWFpbmluZ0NvbnRlbnQgPSAwO1xuICAgICAgICB2YXIgY2hhbmdlc1N0YXJ0QWZ0ZXIgPSAwO1xuICAgICAgICB2YXIgY2hhbmdlc0VuZEFmdGVySW5PbGRWZXJzaW9uID0gMDtcbiAgICAgICAgdmFyIHVwZGF0ZVN0YXJ0U2VjdGlvbiA9IHRoaXMuY29udGVudEVsZW1lbnQuY2hpbGRyZW5bMF07XG5cbiAgICAgICAgZm9yKDsgaTxjaGFuZ2VzZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmKGNoYW5nZXNldFtpXS5jb25zdHJ1Y3Rvci5uYW1lICE9PSAnUmV0YWluJykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGFuZ2VzU3RhcnRBZnRlciArPSBjaGFuZ2VzZXRbaV0ubGVuZ3RoO1xuICAgICAgICAgICAgY2hhbmdlc2V0Q3Vyc29yT2xkVmVyc2lvbiArPSBjaGFuZ2VzZXRbaV0ubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUoKGxlbmd0aE9mVW5jaGFuZ2VkU2VjdGlvbiArIHRoaXMuX2NsZWFudXBIVE1MRnJvbUVkaXRvclNwZWNpZmljTWFya3VwRm9yU2VjdGlvbkhUTUwodXBkYXRlU3RhcnRTZWN0aW9uLm9yaWdpbmFsSFRNTCkubGVuZ3RoKSA8PSBjaGFuZ2VzU3RhcnRBZnRlcikge1xuICAgICAgICAgICAgaWYoIXVwZGF0ZVN0YXJ0U2VjdGlvbi5uZXh0U2libGluZykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZW5ndGhPZlVuY2hhbmdlZFNlY3Rpb24gKz0gdGhpcy5fY2xlYW51cEhUTUxGcm9tRWRpdG9yU3BlY2lmaWNNYXJrdXBGb3JTZWN0aW9uSFRNTCh1cGRhdGVTdGFydFNlY3Rpb24ub3JpZ2luYWxIVE1MKS5sZW5ndGg7XG5cbiAgICAgICAgICAgIHVwZGF0ZVN0YXJ0U2VjdGlvbiA9IHVwZGF0ZVN0YXJ0U2VjdGlvbi5uZXh0U2libGluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGNoYW5nZXNldEN1cnNvck5ld1ZlcnNpb24gPSBjaGFuZ2VzZXRDdXJzb3JPbGRWZXJzaW9uO1xuXG4gICAgICAgIGZvcig7IGk8Y2hhbmdlc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjaGFuZ2VzZXRDdXJzb3JPbGRWZXJzaW9uICs9IGNoYW5nZXNldFtpXS5pbnB1dDtcbiAgICAgICAgICAgIGNoYW5nZXNldEN1cnNvck5ld1ZlcnNpb24gKz0gY2hhbmdlc2V0W2ldLm91dHB1dDtcblxuICAgICAgICAgICAgaWYoY2hhbmdlc2V0W2ldLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdTa2lwJykge1xuICAgICAgICAgICAgICAgIGNoYW5nZXNFbmRBZnRlckluT2xkVmVyc2lvbiA9IGNoYW5nZXNldEN1cnNvck9sZFZlcnNpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdXBkYXRlRW5kU2VjdGlvbiA9IHVwZGF0ZVN0YXJ0U2VjdGlvbjtcbiAgICAgICAgdmFyIHRtcENoYW5nZXNFbmRQb3NpdGlvbiA9IGxlbmd0aE9mVW5jaGFuZ2VkU2VjdGlvbjtcblxuICAgICAgICB3aGlsZSgodG1wQ2hhbmdlc0VuZFBvc2l0aW9uICsgdGhpcy5fY2xlYW51cEhUTUxGcm9tRWRpdG9yU3BlY2lmaWNNYXJrdXBGb3JTZWN0aW9uSFRNTCh1cGRhdGVFbmRTZWN0aW9uLm9yaWdpbmFsSFRNTCkubGVuZ3RoKSA8IGNoYW5nZXNFbmRBZnRlckluT2xkVmVyc2lvbikge1xuICAgICAgICAgICAgdG1wQ2hhbmdlc0VuZFBvc2l0aW9uICs9IHRoaXMuX2NsZWFudXBIVE1MRnJvbUVkaXRvclNwZWNpZmljTWFya3VwRm9yU2VjdGlvbkhUTUwodXBkYXRlRW5kU2VjdGlvbi5vcmlnaW5hbEhUTUwpLmxlbmd0aDtcbiAgICAgICAgICAgIHVwZGF0ZUVuZFNlY3Rpb24gPSB1cGRhdGVFbmRTZWN0aW9uLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9sZENvbnRlbnQgPSAnJztcbiAgICAgICAgdmFyIHRtcFNlY3Rpb24gPSB1cGRhdGVTdGFydFNlY3Rpb247XG5cbiAgICAgICAgd2hpbGUodG1wU2VjdGlvbiAhPT0gdXBkYXRlRW5kU2VjdGlvbikge1xuICAgICAgICAgICAgb2xkQ29udGVudCArPSB0aGlzLl9jbGVhbnVwSFRNTEZyb21FZGl0b3JTcGVjaWZpY01hcmt1cEZvclNlY3Rpb25IVE1MKHRtcFNlY3Rpb24ub3JpZ2luYWxIVE1MKTtcbiAgICAgICAgICAgIHRtcFNlY3Rpb24gPSB0bXBTZWN0aW9uLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgb2xkQ29udGVudCArPSB0aGlzLl9jbGVhbnVwSFRNTEZyb21FZGl0b3JTcGVjaWZpY01hcmt1cEZvclNlY3Rpb25IVE1MKHVwZGF0ZUVuZFNlY3Rpb24ub3JpZ2luYWxIVE1MKTtcblxuICAgICAgICB0bXBTZWN0aW9uID0gdG1wU2VjdGlvbi5uZXh0U2libGluZztcblxuICAgICAgICB3aGlsZSh0bXBTZWN0aW9uKSB7XG4gICAgICAgICAgICBsZW5ndGhPZlJlbWFpbmluZ0NvbnRlbnQgKz0gdGhpcy5fY2xlYW51cEhUTUxGcm9tRWRpdG9yU3BlY2lmaWNNYXJrdXBGb3JTZWN0aW9uSFRNTCh0bXBTZWN0aW9uLm9yaWdpbmFsSFRNTCkubGVuZ3RoO1xuICAgICAgICAgICAgdG1wU2VjdGlvbiA9IHRtcFNlY3Rpb24ubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cblxuICAgICAgICB0b3RhbE9sZENvbnRlbnRMZW5ndGggPSBsZW5ndGhPZlVuY2hhbmdlZFNlY3Rpb24gKyBvbGRDb250ZW50Lmxlbmd0aCArIGxlbmd0aE9mUmVtYWluaW5nQ29udGVudDtcblxuICAgICAgICBpZih0b3RhbE9sZENvbnRlbnRMZW5ndGggIT09IGNoYW5nZXNldC5pbnB1dExlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgJ2FwcGx5Q2hhbmdlc2V0OiB0aGUgZ2l2ZW4gY2hhbmdlc2V0IGRvZXMgbm90IG1hdGNoIHRoZSBjb250ZW50IGxlbmd0aCEhJztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNsaWNlID0gKGNhbmdlc2V0LCBzdGFydCwgZW5kKSA9PiB7XG4gICAgICAgICAgICBsZXQgcHJvY2Vzc2VkID0gMDtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBDaGFuZ2VzZXQuY3JlYXRlKCk7XG5cbiAgICAgICAgICAgIGZvcihsZXQgb3Agb2YgY2hhbmdlc2V0KSB7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRPcFN0YXJ0ID0gcHJvY2Vzc2VkO1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50T3BFbmQgPSBwcm9jZXNzZWQgKyBvcC5pbnB1dDtcblxuICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRPcFN0YXJ0IDwgc3RhcnQgJiYgY3VycmVudE9wRW5kID4gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYob3AuY29uc3RydWN0b3IubmFtZSAhPT0gJ1JldGFpbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICdSZXRhaW4gb3BlcmF0aW9uIGV4cGVjdGVkIHdoZW4gZXh0cmFjdGluZyB0aGUgY2hhbmdlcyBsb2NhbCB0byBhIHNlY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucmV0YWluKG9wLmlucHV0IC0gKHN0YXJ0IC0gY3VycmVudE9wU3RhcnQpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoY3VycmVudE9wU3RhcnQgPj0gc3RhcnQgJiYgY3VycmVudE9wRW5kIDw9IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQub3BzLnB1c2gob3ApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZihjdXJyZW50T3BTdGFydCA+PSBzdGFydCAmJiBjdXJyZW50T3BTdGFydCA8IGVuZCAmJiBlbmQgPCBjdXJyZW50T3BFbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYob3AuY29uc3RydWN0b3IubmFtZSAhPT0gJ1JldGFpbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICdSZXRhaW4gb3BlcmF0aW9uIGV4cGVjdGVkIHdoZW4gZXh0cmFjdGluZyB0aGUgY2hhbmdlcyBsb2NhbCB0byBhIHNlY3Rpb24nO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnJldGFpbihvcC5pbnB1dCAtIChjdXJyZW50T3BFbmQtZW5kKSk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoY3VycmVudE9wU3RhcnQgPiBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwcm9jZXNzZWQgKz0gb3AuaW5wdXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuZW5kKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9jYWxDaGFuZ2VzZXQgPSBzbGljZShjaGFuZ2VzZXQsIGxlbmd0aE9mVW5jaGFuZ2VkU2VjdGlvbiwgbGVuZ3RoT2ZVbmNoYW5nZWRTZWN0aW9uK29sZENvbnRlbnQubGVuZ3RoKTtcbiAgICAgICAgbG9jYWxDaGFuZ2VzZXQuYWRkZW5kdW0gPSBjaGFuZ2VzZXQuYWRkZW5kdW07XG4gICAgICAgIGxvY2FsQ2hhbmdlc2V0LnJlbW92ZW5kdW0gPSBjaGFuZ2VzZXQucmVtb3ZlbmR1bTtcblxuICAgICAgICB2YXIgbmV3Q29udGVudCA9IGxvY2FsQ2hhbmdlc2V0LmFwcGx5KG9sZENvbnRlbnQpO1xuXG4gICAgICAgIHRoaXMuc2V0Q29udGVudChuZXdDb250ZW50LCB7XG4gICAgICAgICAgICAuLi5hdHRyLFxuICAgICAgICAgICAgc3RhcnRTZWN0aW9uOiB1cGRhdGVTdGFydFNlY3Rpb24sXG4gICAgICAgICAgICBlbmRTZWN0aW9uOiB1cGRhdGVFbmRTZWN0aW9uXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBzZXRDb250ZW50OiBmdW5jdGlvbihjb250ZW50LCBhcmdzKSB7XG4gICAgICAgIGFyZ3MgPSBhcmdzIHx8IHt9O1xuXG4gICAgICAgIHZhciBpbnNlcnRlZENvbnRlbnQgPSBhcmdzLmlucHV0RXZlbnQgJiYgYXJncy5pbnB1dEV2ZW50LmRhdGEsXG4gICAgICAgICAgICBtb2RpZmljYXRpb25Mb2dFbnRyeSxcbiAgICAgICAgICAgIGN1cnJlbnRDYXJldFBvc2l0aW9uLFxuICAgICAgICAgICAgYmVmb3JlU3RhdGVDYXJldFBvc2l0aW9uLFxuICAgICAgICAgICAgc2Nyb2xsUG9zaXRpb24gPSB0aGlzLnNhdmVTY3JvbGxQb3NpdGlvbihhcmdzLnNlY3Rpb24pO1xuXG4gICAgICAgIGlmKHRoaXMuY2FyZXQuaXNXaXRoaW5FbGVtZW50KHRoaXMuY29udGVudEVsZW1lbnQpICYmIGFyZ3MucG9zaXRpb25DYXJldEF0VGhlRW5kT2ZTZWN0aW9uV2l0aEluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGN1cnJlbnRDYXJldFBvc2l0aW9uID0gdGhpcy5jYXJldC5zYXZlU2VsZWN0aW9uKHRoaXMuY29udGVudEVsZW1lbnQsIGluc2VydGVkQ29udGVudCksXG4gICAgICAgICAgICBiZWZvcmVTdGF0ZUNhcmV0UG9zaXRpb24gPSB0aGlzLmNhcmV0UG9zaXRpb25zW3RoaXMuY2FyZXRQb3NpdGlvbnMubGVuZ3RoLTFdO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJncy5tb2RpZmljYXRpb25Mb2dFbnRyeSA9IGFyZ3MubW9kaWZpY2F0aW9uTG9nRW50cnkgfHwgbmV3IE1vZGlmaWNhdGlvbkxvZ0VudHJ5KCk7XG4gICAgICAgIGFyZ3MubW9kaWZpY2F0aW9uTG9nRW50cnkubW9kTG9nRmxhZ3MgPSB0aGlzLm1vZExvZ0ZsYWdzO1xuXG4gICAgICAgIGFyZ3MubW9kaWZpY2F0aW9uTG9nRW50cnkuYWN0b3IgPSBhcmdzLmFjdG9yXG5cbiAgICAgICAgdGhpcy5jYXJldFBvc2l0aW9ucy5wdXNoKGFyZ3MuY2FyZXRQb3NpdGlvbiB8fCBjdXJyZW50Q2FyZXRQb3NpdGlvbik7XG5cbiAgICAgICAgbW9kaWZpY2F0aW9uTG9nRW50cnkgPSB0aGlzLmRvY3VtZW50dXBkYXRlci51cGRhdGVIVE1MKGNvbnRlbnQsIHRoaXMuZm9jdXNlZFNlY3Rpb24oKSwgeyAuLi5hcmdzLCBjYXJldDogdGhpcy5jYXJldCB9KTtcblxuICAgICAgICBpZihtb2RpZmljYXRpb25Mb2dFbnRyeS5mb2N1c2VkU2VjdGlvbkhhc0JlZW5Nb2RpZmllZCAmJiBhcmdzLnBvc2l0aW9uQ2FyZXRBdFRoZUVuZE9mU2VjdGlvbldpdGhJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZihtb2RpZmljYXRpb25Mb2dFbnRyeS5jaGFuZ2VTZWN0aW9uVHlwZSkge1xuICAgICAgICAgICAgICAgIGFyZ3MuYWN0aW9uID0gJ2NoYW5nZUZvY3VzZWRTZWN0aW9uVHlwZSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCFhcmdzLmNhcmV0UG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZighbW9kaWZpY2F0aW9uTG9nRW50cnkuZm9jdXNlZFNlY3Rpb25ET01XYXNOb3RNb2RpZmllZCB8fCAhKGN1cnJlbnRDYXJldFBvc2l0aW9uICYmICBjdXJyZW50Q2FyZXRQb3NpdGlvbi5zZWxlY3Rpb25Jc0NvbGxhcHNlZCkpIHtcblxuICAgICAgICAgICAgICAgICAgICBpZihtb2RpZmljYXRpb25Mb2dFbnRyeS5pbnNlcnRlZEJlZm9yZVNlbGVjdGlvblJhbmdlU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FyZXQucmFuZ2VTdGFydCArPSBtb2RpZmljYXRpb25Mb2dFbnRyeS5pbnNlcnRlZEJlZm9yZVNlbGVjdGlvblJhbmdlU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZihtb2RpZmljYXRpb25Mb2dFbnRyeS5pbnNlcnRlZEJlZm9yZVNlbGVjdGlvblJhbmdlRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhcmV0LnJhbmdlRW5kICs9IG1vZGlmaWNhdGlvbkxvZ0VudHJ5Lmluc2VydGVkQmVmb3JlU2VsZWN0aW9uUmFuZ2VFbmQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhcmV0LnJlc3RvcmVTZWxlY3Rpb24obW9kaWZpY2F0aW9uTG9nRW50cnkuZGVsZXRlZENoYXJzQnlNYXJrdXBUcmFuc2Zvcm1hdGlvbnMsICdUcnlET01TdHJhdGVneUZpcnN0Jyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYobW9kaWZpY2F0aW9uTG9nRW50cnkuZm9jdXNlZFNlY3Rpb25SZXBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvY3VzU2VjdGlvbihtb2RpZmljYXRpb25Mb2dFbnRyeS5mb2N1c2VkU2VjdGlvblJlcGxhY2VtZW50LCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZihhcmdzLnBvc2l0aW9uQ2FyZXRBdFRoZUVuZE9mU2VjdGlvbldpdGhJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNhcmV0LnBvc2l0aW9uQXRUaGVCZWdpbm5pbmdPZih0aGlzLnNlY3Rpb25BdChhcmdzLnBvc2l0aW9uQ2FyZXRBdFRoZUVuZE9mU2VjdGlvbldpdGhJbmRleCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoYXJncy5jYXJldFBvc2l0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmNhcmV0LnJlc3RvcmVTZWxlY3Rpb25WaWFPZmZzZXRTdHJhdGVneSgwLCBhcmdzLmNhcmV0UG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZXN0b3JlU2Nyb2xsUG9zdGlvbihtb2RpZmljYXRpb25Mb2dFbnRyeS5mb2N1c2VkU2VjdGlvblJlcGxhY2VtZW50LCBzY3JvbGxQb3NpdGlvbik7XG5cbiAgICAgICAgdGhpcy51cGRhdGVGb290bm90ZXNOdW1iZXJpbmcoKTtcbiAgICAgICAgdGhpcy51cGRhdGVSZWZlcmVuY2VOdW1iZXJpbmcoKTtcbiAgICAgICAgdGhpcy51cGRhdGVJbmxpbmVFcXVhdGlvbk51bWJlcmluZyhtb2RpZmljYXRpb25Mb2dFbnRyeSk7XG5cbiAgICAgICAgbW9kaWZpY2F0aW9uTG9nRW50cnkuYmVmb3JlU3RhdGVDYXJldFBvc2l0aW9uID0gYmVmb3JlU3RhdGVDYXJldFBvc2l0aW9uO1xuICAgICAgICBtb2RpZmljYXRpb25Mb2dFbnRyeS5hZnRlclN0YXRlQ2FyZXRQb3NpdGlvbiA9IGFyZ3MuY2FyZXRQb3NpdGlvbiB8fCBjdXJyZW50Q2FyZXRQb3NpdGlvbjtcbiAgICAgICAgbW9kaWZpY2F0aW9uTG9nRW50cnkudGFncyA9IGFyZ3MubW9kaWZpY2F0aW9uTG9nVGFncztcblxuICAgICAgICBtb2RpZmljYXRpb25Mb2dFbnRyeS53b3JkQ291bnQgPSB0aGlzLmdldFdvcmRDb3VudCgpO1xuXG4gICAgICAgIHRoaXMuc2hvd0lucHV0VG9vbHRpcElmQ29udGVudElzRW1wdHkoKTtcblxuICAgICAgICB0aGlzLmZvY3VzU2VjdGlvbih0aGlzLnNlY3Rpb25BdENhcmV0UG9zdGlvbigpLCBhcmdzKTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRW1wdHlTZWN0aW9uc0V4Y2VwdE9mRm9jdXNlZFNlY3Rpb24obW9kaWZpY2F0aW9uTG9nRW50cnkpO1xuICAgICAgICB0aGlzLm5vdGlmeVN1YnNjcmliZXJzKG1vZGlmaWNhdGlvbkxvZ0VudHJ5KTtcblxuICAgICAgICByZXR1cm4gbW9kaWZpY2F0aW9uTG9nRW50cnk7XG4gICAgfSxcblxuICAgIHNob3dJbnB1dFRvb2x0aXBJZkNvbnRlbnRJc0VtcHR5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYodGhpcy5faW5pdERvbmUgJiYgdGhpcy5jb250ZW50RWxlbWVudC5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgdGhpcy5jb250ZW50RWxlbWVudC5pbm5lclRleHQudHJpbSgpID09PSAnJyAmJiB0aGlzLmNvbnRlbnRFbGVtZW50LmNoaWxkcmVuWzBdLnRhZ05hbWUgPT09ICdQJykge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXJFbGVtZW50Lmluc2VydEJlZm9yZSh0aGlzLmhpbnRFbCwgdGhpcy5jb250ZW50RWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhpbnRFbC5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRXb3JkQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gMDtcblxuICAgICAgICBmb3IobGV0IGk9MDsgaTx0aGlzLmNvbnRlbnRFbGVtZW50LmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5jb250ZW50RWxlbWVudC5jaGlsZHJlbltpXS53b3JkQ291bnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBzYXZlU2Nyb2xsUG9zaXRpb246IGZ1bmN0aW9uKHNlY3Rpb24pIHtcbiAgICAgICAgdmFyIG5lc3RlZENvZGVFbCxcbiAgICAgICAgICAgIGlzRGlhU2VjdGlvbiA9IHNlY3Rpb24gJiYgc2VjdGlvbi5jbGFzc0xpc3QgJiYgc2VjdGlvbi5jbGFzc0xpc3QuY29udGFpbnMoJ20yZGlhJyksXG4gICAgICAgICAgICBpc0NvZGVTZWN0aW9uID0gc2VjdGlvbiAmJiBzZWN0aW9uLnRhZ05hbWUgPT09ICdQUkUnO1xuXG4gICAgICAgIGlmKGlzRGlhU2VjdGlvbiB8fCBpc0NvZGVTZWN0aW9uKSB7XG4gICAgICAgICAgICBuZXN0ZWRDb2RlRWwgPSBzZWN0aW9uLnF1ZXJ5U2VsZWN0b3IoJ2NvZGUnKTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiB3aW5kb3cuc2Nyb2xsWCxcbiAgICAgICAgICAgICAgICB5OiB3aW5kb3cuc2Nyb2xsWSxcbiAgICAgICAgICAgICAgICBjb2RlU2Nyb2xsWDogbmVzdGVkQ29kZUVsICYmIG5lc3RlZENvZGVFbC5zY3JvbGxMZWZ0XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVzdG9yZVNjcm9sbFBvc3Rpb246IGZ1bmN0aW9uKHNlY3Rpb24sIHNjcm9sbFBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBuZXN0ZWRDb2RlRWw7XG4gICAgICAgIGlmKHNjcm9sbFBvc2l0aW9uKSB7XG4gICAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oc2Nyb2xsUG9zaXRpb24ueCwgc2Nyb2xsUG9zaXRpb24ueSk7XG4gICAgICAgICAgICBpZihzY3JvbGxQb3NpdGlvbi5jb2RlU2Nyb2xsWCAmJiBzZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgbmVzdGVkQ29kZUVsID0gc2VjdGlvbi5xdWVyeVNlbGVjdG9yKCdjb2RlJylcbiAgICAgICAgICAgICAgICBuZXN0ZWRDb2RlRWwuc2Nyb2xsVG8oc2Nyb2xsUG9zaXRpb24uY29kZVNjcm9sbFgsIG5lc3RlZENvZGVFbC5zY3JvbGxZKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIHVwZGF0ZUZvb3Rub3Rlc051bWJlcmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhbGxGb290bm90ZXMgPSB0aGlzLmNvbnRlbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5mb290bm90ZScpO1xuICAgICAgICBmb3IodmFyIGk9MDsgaTxhbGxGb290bm90ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmKGFsbEZvb3Rub3Rlc1tpXS5pbm5lclRleHQgIT09IChpKzEpLnRvU3RyaW5nKCkpIHtcbiAgICAgICAgICAgICAgICBhbGxGb290bm90ZXNbaV0uaW5uZXJUZXh0ID0gKGkrMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdXBkYXRlUmVmZXJlbmNlTnVtYmVyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlZnMgPSB0aGlzLmNvbnRlbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5yZWZlcmVuY2UnKTtcblxuICAgICAgICBmb3IodmFyIGk9MDsgaTxyZWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnJlZmVyZW5jZS51cGRhdGVSZWZFbGVtZW50KHJlZnNbaV0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHVwZGF0ZUlubGluZUVxdWF0aW9uTnVtYmVyaW5nOiBmdW5jdGlvbihtb2RpZmljYXRpb25Mb2dFbnRyeSkge1xuICAgICAgICB2YXIgZXFzID0gdGhpcy5jb250ZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbmxpbmVlcXVhdGlvbicpLFxuICAgICAgICAgICAgbGF0ZXgsIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPGVxcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGVxID0gZXFzW2ldXG4gICAgICAgICAgICBlcS5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgICAgIGxhdGV4ID0gdXRpbHMuYXR0cmlidXRlU2F2ZVN0cmluZ1RvU3RyaW5nKGVxLmRhdGFzZXQubGF0ZXhlcXVhdGlvbilcblxuICAgICAgICAgICAgZXEub25jbGljayA9IGVxLm9uY2xpY2sgfHwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIHNlbGYuY2FyZXQucG9zaXRpb25BZnRlcih1dGlscy5nZXRGaXJzdFBhcmVudFdpdGhUYWdOYW1lKGUudGFyZ2V0KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAga2F0ZXgucmVuZGVyKGxhdGV4LCBlcSwge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd09uRXJyb3I6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlNb2RlOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICBlcS5pbm5lckhUTUwgPSAnPHNwYW4gY2xhc3M9XCJlcnJvclwiPmludmFsaWQgTGFUZVggZXF1YXRpb248L3NwYW4+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzaG91bGRTZWN0aW9uQmVSZW1vdmVkSWZVbmZvY3VzZWQ6IGZ1bmN0aW9uKHNlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHNlY3Rpb24uaW5uZXJUZXh0LnRyaW0oKSA9PT0gJycgJiZcbiAgICAgICAgICAgICAgICFzZWN0aW9uLmNsYXNzTGlzdC5maW5kKGMgPT4gYy5zdGFydHNXaXRoKCdmb2N1c2VkLWJ5LWFwaS1hY3RvcicpKSAmJlxuICAgICAgICAgICAgICAgISh0aGlzLmh0bWxSYXpvci5nZXRSdWxlQnlFbGVtZW50KHNlY3Rpb24pLmRlbGV0ZUlmRW1wdHkgPT09IGZhbHNlKTtcbiAgICB9LFxuXG4gICAgZGVsZXRlTm9uQ29sbGFwc2VkU2VsZWN0aW9uQ29udGVudDogZnVuY3Rpb24oc2VsKSB7XG4gICAgICAgIHNlbCA9IHNlbCB8fCB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgICAgaWYoIXNlbCkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBzMSA9IHRoaXMuc2VjdGlvbkJ5Q2hpbGROb2RlKHNlbC5hbmNob3JOb2RlKSxcbiAgICAgICAgICAgIHMyID0gdGhpcy5zZWN0aW9uQnlDaGlsZE5vZGUoc2VsLmZvY3VzTm9kZSksXG4gICAgICAgICAgICBpMSA9IHRoaXMuaW5kZXhPZihzMSksXG4gICAgICAgICAgICBpMiA9IHRoaXMuaW5kZXhPZihzMiksXG4gICAgICAgICAgICB0bXAsIG5ld0VsZW1lbnQ7XG5cbiAgICAgICAgaWYoaTEgPT09IHVuZGVmaW5lZCB8fCBpMiA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICAgICAgaWYoaTEgPiBpMikge1xuICAgICAgICAgICAgdG1wID0gczE7IHMxID0gczI7IHMyID0gdG1wO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2UgaGF2ZSB0byBrZWVwIHRoZSBzZWN0aW9ucyBpbiBiZXR3ZWVuIHRoZSBzZWxlY3Rpb24gaW4gb3JkZXJcbiAgICAgICAgLy8gdG8gY2FjbHVsYXRlIHRoZSBtb2RpZmljYXRpb25Mb2dFbnRyeS4gVGhleSB3aWxsIGJlIHJlbW92ZWQgYnlcbiAgICAgICAgLy8gdGhlIHNldENvbnRlbnQgZnVuY3Rpb24gd2hpY2ggYWxzbyBjYWxjdWxhdGVzIHRoZSBMb2dFbnRyeS5cbiAgICAgICAgdGhpcy5fZGVsZXRlU2VsZWN0ZWRUZXh0QnV0S2VlcEFsbFNlbGVjdGVkU2VjdGlvbnMoczEsIHMyLCBzZWwpO1xuXG4gICAgICAgIG5ld0VsZW1lbnQgPSBzMS5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAgICBuZXdFbGVtZW50LmlubmVySFRNTCA9IHMxLmlubmVySFRNTCArIHMyLmlubmVySFRNTDtcblxuICAgICAgICB0aGlzLnNldENvbnRlbnQobmV3RWxlbWVudC5vdXRlckhUTUwsIHtzdGFydFNlY3Rpb246IHMxLCBlbmRTZWN0aW9uOiBzMn0pO1xuXG4gICAgICAgIGlmKCF0aGlzLnNlY3Rpb25BdENhcmV0UG9zdGlvbigpKSB7XG4gICAgICAgICAgICB0aGlzLnBsYWNlQ2FyZXRJbnRvU2VjdGlvbih0aGlzLmNvbnRlbnRFbGVtZW50Lmxhc3RDaGlsZCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldENvbnRlbnRFZGl0YWJsZSh0cnVlKTtcbiAgICB9LFxuXG4gICAgc2V0RmlsZVBlcnNpc3RIYW5kbGVyOiBmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgICAgIE9iamVjdC52YWx1ZXModGhpcy5zdXBwb3J0ZWRTZWN0aW9uVHlwZXMpXG4gICAgICAgICAgICAuZmlsdGVyKHNlY3Rpb24gPT4gc2VjdGlvbi5wZXJzaXN0RmlsZSlcbiAgICAgICAgICAgIC5mb3JFYWNoKHNlY3Rpb24gPT4ge1xuICAgICAgICAgICAgICAgIHNlY3Rpb24ucGVyc2lzdEZpbGUgPSBoYW5kbGVyO1xuICAgICAgICB9KVxuICAgIH0sXG5cbiAgICBhZGRSZWZlcmVuY2VEYXRhOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlLmFkZFJlZmVyZW5jZURhdGEoZGF0YSk7XG4gICAgICAgIHRoaXMudXBkYXRlUmVmZXJlbmNlTnVtYmVyaW5nKCk7XG5cbiAgICAgICAgaWYodGhpcy5jb250ZW50RWxlbWVudC5jaGlsZHJlblswXSkge1xuICAgICAgICAgICAgdGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeSA9IG5ldyBNb2RpZmljYXRpb25Mb2dFbnRyeSgpO1xuICAgICAgICAgICAgdGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeS5yZXRhaW5TZWN0aW9uKHRoaXMuY29udGVudEVsZW1lbnQuY2hpbGRyZW5bMF0pO1xuICAgICAgICAgICAgdGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeS5yZXRhaW5BbGxTZWN0aW9uc0FmdGVyKHRoaXMuY29udGVudEVsZW1lbnQuY2hpbGRyZW5bMF0pO1xuICAgICAgICAgICAgdGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeS5taWdodEluY2x1ZGVSZWZlcmVuY2VVcGRhdGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5U3Vic2NyaWJlcnModGhpcy5tb2RpZmljYXRpb25Mb2dFbnRyeSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3JlbW92ZUVtcHR5U2VjdGlvbnNFeGNlcHRPZkZvY3VzZWRTZWN0aW9uOiBmdW5jdGlvbihmaW5hbGl6ZWRNb2RpZmljYXRpb25Mb2dFbnRyeSkge1xuICAgICAgICB2YXIgc2VjdGlvbnMgPSB0aGlzLmNvbnRlbnRFbGVtZW50LmNoaWxkcmVuLFxuICAgICAgICAgICAgdG9CZURlbGV0ZWQgPSBbXSwgaW5kZXhDb3JyZWN0aW9uID0gMCwgb2xkTW9kTG9nLCBkZWxldGVkU2VjdGlvbjtcblxuICAgICAgICBpZihzZWN0aW9ucy5sZW5ndGggPT09IDEpIHJldHVybjtcblxuICAgICAgICBmb3IobGV0IGk9MDsgaTxzZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYodGhpcy5zaG91bGRTZWN0aW9uQmVSZW1vdmVkSWZVbmZvY3VzZWQoc2VjdGlvbnNbaV0pICYmXG4gICAgICAgICAgICAgICBzZWN0aW9uc1tpXSAhPT0gdGhpcy5mb2N1c2VkU2VjdGlvbigpKSB7XG4gICAgICAgICAgICAgICAgIHRvQmVEZWxldGVkLnB1c2goe3NlY3Rpb246IHNlY3Rpb25zW2ldLCBpbmRleDogaX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yKGxldCBpPTA7IGk8dG9CZURlbGV0ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGRlbGV0ZWRTZWN0aW9uID0gdGhpcy5jb250ZW50RWxlbWVudC5yZW1vdmVDaGlsZCh0b0JlRGVsZXRlZFtpXS5zZWN0aW9uKTtcbiAgICAgICAgICAgIG9sZE1vZExvZyA9IGZpbmFsaXplZE1vZGlmaWNhdGlvbkxvZ0VudHJ5LmRlbGV0ZVNlY3Rpb25BdCh0b0JlRGVsZXRlZFtpK2luZGV4Q29ycmVjdGlvbl0uaW5kZXgsIGRlbGV0ZWRTZWN0aW9uKTtcbiAgICAgICAgICAgIGlmKG9sZE1vZExvZy50eXBlID09PSAnaW5zZXJ0Jykge1xuICAgICAgICAgICAgICAgIGluZGV4Q29ycmVjdGlvbi0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZWN0aW9uVHlwZVNlbGVjdG9yLmRpc3BsYXlOZXh0VG8odGhpcy5mb2N1c2VkU2VjdGlvbigpKTtcbiAgICB9LFxuXG4gICAgLy8gRXhhbXBsZTogdGhlIHBpcGVzIChcInxcIikgc2hvdyB3aGVyZSB0aGUgc2VsZWN0aW9uIHN0YXJ0cy9lbmRzXG4gICAgLy8gY29udGVudCBiZWZvcmUgZXhlY3V0aW9uOiA8cD5zZWN0aW9uIHxvbmU8L3A+PHA+c2VjdGlvbiB0d288L3A+PHA+c2VjdGlvbiB0aHJlZTwvcD48cD5zZWN0aW9uIHxmb3VyPC9wPlxuICAgIC8vIGNvbnRlbnQgYWZ0ZXIgZXhlY3V0aW9uOiA8cD5zZWN0aW9uIHx8PC9wPjxwPjwvcD48cD48L3A+PHA+Zm91cjwvcD5cbiAgICBfZGVsZXRlU2VsZWN0ZWRUZXh0QnV0S2VlcEFsbFNlbGVjdGVkU2VjdGlvbnM6IGZ1bmN0aW9uKHMxLCBzMiwgc2VsKSB7XG4gICAgICAgIHZhciBpbkJldHdlZW5TZWN0aW9ucyA9IFtdLFxuICAgICAgICAgICAgaTEgPSB0aGlzLmluZGV4T2YoczEpLFxuICAgICAgICAgICAgaTIgPSB0aGlzLmluZGV4T2YoczIpLFxuICAgICAgICAgICAgY2VjID0gdGhpcy5jb250ZW50RWxlbWVudC5jaGlsZHJlbixcbiAgICAgICAgICAgIHRtcCwgaSwgcmFuZ2UsIHNlbGVjdGlvbiwgbGFzdEluc2VydGVkRHVtbXlTZWN0aW9uLCBjbG9uZWRSYW5nZTtcblxuICAgICAgICBpZihpMSA+IGkyKSB7XG4gICAgICAgICAgICB0bXAgPSBzMTsgczEgPSBzMjsgczIgPSB0bXA7XG4gICAgICAgICAgICB0bXAgPSBpMTsgaTEgPSBpMjsgaTIgPSB0bXA7XG4gICAgICAgIH1cblxuICAgICAgICBzMS5zdW1tYXJpemVkQ29udGVudExlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgczIuc3VtbWFyaXplZENvbnRlbnRMZW5ndGggPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgZm9yKGk9aTErMSA7IGk8aTI7IGkrKykge1xuICAgICAgICAgICAgdG1wID0gY2VjW2ldLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICAgICAgICB0bXAub3JpZ2luYWxIVE1MID0gY2VjW2ldLm9yaWdpbmFsSFRNTDtcbiAgICAgICAgICAgIHRtcC5zdW1tYXJpemVkQ29udGVudExlbmd0aCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5tb2RMb2dGbGFncykuZm9yRWFjaChmdW5jdGlvbihmbGFnKSB7XG4gICAgICAgICAgICAgICAgdG1wWydvcmlnaW5hbEhUTUxDb250YWlucycgKyBmbGFnXSA9IGNlY1tpXVsnb3JpZ2luYWxIVE1MQ29udGFpbnMnICsgZmxhZ107XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaW5CZXR3ZWVuU2VjdGlvbnMucHVzaCh0bXApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmFuZ2UgPSBzZWwuZ2V0UmFuZ2VBdCgwKTtcbiAgICAgICAgY2xvbmVkUmFuZ2UgPSByYW5nZS5jbG9uZVJhbmdlKCk7XG4gICAgICAgIHJhbmdlLmRlbGV0ZUNvbnRlbnRzKCk7XG4gICAgICAgIC8vIGNsb25lZFJhbmdlLmNvbGxhcHNlOyA/PyB3aHkgbm90IGNsb25lZFJhbmdlLmNvbGxhcHNlKClcbiAgICAgICAgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShjbG9uZWRSYW5nZSk7XG5cbiAgICAgICAgbGFzdEluc2VydGVkRHVtbXlTZWN0aW9uID0gczI7XG4gICAgICAgIHdoaWxlKGluQmV0d2VlblNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRtcCA9IGluQmV0d2VlblNlY3Rpb25zLnBvcCgpO1xuICAgICAgICAgICAgdGhpcy5jb250ZW50RWxlbWVudC5pbnNlcnRCZWZvcmUodG1wLCBsYXN0SW5zZXJ0ZWREdW1teVNlY3Rpb24pO1xuICAgICAgICAgICAgbGFzdEluc2VydGVkRHVtbXlTZWN0aW9uID0gdG1wO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9jbGVhbnVwSFRNTEZyb21FZGl0b3JTcGVjaWZpY01hcmt1cEZvclNlY3Rpb25IVE1MOiBmdW5jdGlvbihIVE1MKSB7XG4gICAgICAgIHJldHVybiBIVE1MLnJlcGxhY2UoL148KFthLXpBLVowLTlcXC1dKz8pXFxzKC4qPyk+LywgKG1hdGNoLCB0YWdOYW1lLCBhdHRyaWJ1dGVzKSA9PiB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgIC5tYXRjaCgvKFthLXpBLVowLTlcXC1dKz1cIi4qP1wiKXxbYS16QS1aMC05XFwtXSovZylcbiAgICAgICAgICAgICAgICAubWFwKHggPT4geC50cmltKCkpXG4gICAgICAgICAgICAgICAgLmZpbHRlcih4ID0+IHggIT09ICcnKVxuICAgICAgICAgICAgICAgIC5tYXAoYXR0ciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHIgPSBhdHRyLnNwbGl0KCc9JylcblxuICAgICAgICAgICAgICAgICAgICBpZihhdHRyWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyWzFdID0gYXR0clsxXS5yZXBsYWNlKC9eKFwifCcpL2csICcnKS5yZXBsYWNlKC8oXCJ8JykkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoYXR0clswXSA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0clsxXSA9IGF0dHJbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3BsaXQoJyAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoYyA9PiBjLnRyaW0oKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGMgPT4gYyAhPT0gJ2ZvY3VzZWQnICYmICFjLnN0YXJ0c1dpdGgoJ2ZvY3VzZWQtYnktYXBpLWFjdG9yJykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJyAnKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoYXR0clsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0clsxXSA9IGBcIiR7YXR0clsxXS50cmltKCl9XCJgXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXR0ci5qb2luKCc9JylcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoYXR0ciA9PiAhYXR0ci5tYXRjaCgvY29udGVudGVkaXRhYmxlPVwidHJ1ZVwiLykpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihhdHRyID0+IGF0dHIgIT09ICdjbGFzcz0nKVxuICAgICAgICAgICAgICAgIC5qb2luKCcgJylcblxuXG4gICAgICAgICAgICByZXR1cm4gYXR0cmlidXRlcyAhPT0gJycgP1xuICAgICAgICAgICAgICAgIGA8JHt0YWdOYW1lfSAke2F0dHJpYnV0ZXN9PmAgOlxuICAgICAgICAgICAgICAgIGA8JHt0YWdOYW1lfT5gXG4gICAgICAgIH0pLnJlcGxhY2VBbGwoJyZuYnNwOycsICcgJyk7XG4gICAgfSxcblxuICAgIF9jbGVhbnVwTW9kaWZpY2F0aW9uTG9nRnJvbUVkaXRvclNwZWNpZmljTWFya3VwOiBmdW5jdGlvbihtb2RpZmljYXRpb25Mb2dFbnRyeSkge1xuICAgICAgICBtb2RpZmljYXRpb25Mb2dFbnRyeS5sb2cuZm9yRWFjaChsb2cgPT4ge1xuICAgICAgICAgICAgaWYobG9nLm9sZFNlY3Rpb25IVE1MKSB7XG4gICAgICAgICAgICAgICAgbG9nLm9sZFNlY3Rpb25IVE1MID0gdGhpcy5fY2xlYW51cEhUTUxGcm9tRWRpdG9yU3BlY2lmaWNNYXJrdXBGb3JTZWN0aW9uSFRNTChsb2cub2xkU2VjdGlvbkhUTUwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYobG9nLm5ld1NlY3Rpb25IVE1MKSB7XG4gICAgICAgICAgICAgICAgbG9nLm5ld1NlY3Rpb25IVE1MID0gdGhpcy5fY2xlYW51cEhUTUxGcm9tRWRpdG9yU3BlY2lmaWNNYXJrdXBGb3JTZWN0aW9uSFRNTChsb2cubmV3U2VjdGlvbkhUTUwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYobG9nLnNlY3Rpb25IVE1MKSB7XG4gICAgICAgICAgICAgICAgbG9nLnNlY3Rpb25IVE1MID0gdGhpcy5fY2xlYW51cEhUTUxGcm9tRWRpdG9yU3BlY2lmaWNNYXJrdXBGb3JTZWN0aW9uSFRNTChsb2cuc2VjdGlvbkhUTUwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRWRpdG9yO1xuIiwiZnVuY3Rpb24gS2V5UHJlc3NIYW5kbGVyKGVkaXRvcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwYXN0ZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgcGFzdGVEYXRhO1xuICAgICAgICBlZGl0b3IuY2FyZXQuZW5zdXJlRXhwYW5kZWRTZWxlY3Rpb25Jc1dpdGhpbkVsZW1lbnQoZWRpdG9yLmNvbnRlbnRFbGVtZW50KTtcblxuICAgICAgICBpZihzZWxmLmVkaXRvci5hcmVNdWx0aXBsZVNlY3Rpb25zU2VsZWN0ZWQoKSkge1xuICAgICAgICAgICAgc2VsZi5lZGl0b3IuZGVsZXRlTm9uQ29sbGFwc2VkU2VsZWN0aW9uQ29udGVudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoKGVkaXRvci5jYXJldC5nZXRDb250ZXh0RWxlbWVudCgnY29kZScpICYmIGVkaXRvci5jYXJldC5nZXRDb250ZXh0RWxlbWVudCgncHJlJykpXG4gICAgICAgICAgIHx8IGVkaXRvci5jYXJldC5nZXRDb250ZXh0RWxlbWVudCgnY2FwdGlvbicpXG4gICAgICAgICAgIHx8IGVkaXRvci5jYXJldC5nZXRDb250ZXh0RWxlbWVudCgnY2l0ZXNyYycpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgcGFzdGVEYXRhID0gZS5jbGlwYm9hcmREYXRhLmdldERhdGEoJ3RleHQvcGxhaW4nKS5yZXBsYWNlKC88L2csICcmbHQ7JykucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ2luc2VydGh0bWwnLCBmYWxzZSwgcGFzdGVEYXRhKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHNlY3Rpb24sIGhhbmRsZUVudGVyS2V5O1xuXG4gICAgICAgIGlmKCFlLm1ldGFLZXkgJiYgIWUuY3RybEtleSkge1xuICAgICAgICAgICAgaWYoZS5rZXkgPT09ICcgJykgICAgICAgICAgICAgIHsgIWVkaXRvci5pc0NvbnRlbnRFZGl0YWJsZSgpICYmIGUucHJldmVudERlZmF1bHQoKTsgfVxuXG4gICAgICAgICAgICBpZihlLmtleSA9PT0gJ0JhY2tzcGFjZScpIHtcbiAgICAgICAgICAgICAgICBzZWN0aW9uID0gZWRpdG9yLnNlY3Rpb25CeUNoaWxkTm9kZShlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgZWRpdG9yLmNhcmV0LmVuc3VyZUV4cGFuZGVkU2VsZWN0aW9uSXNXaXRoaW5FbGVtZW50KGVkaXRvci5jb250ZW50RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgaWYoc2VjdGlvbiAmJiBzZWN0aW9uLm9uS2V5QmFja3NwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlY3Rpb24ub25LZXlCYWNrc3BhY2UoZSwgZWRpdG9yKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmhhbmRsZUJhY2tzcGFjZShlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGUua2V5ID09PSAnQXJyb3dVcCcpIHtcbiAgICAgICAgICAgICAgICBzZWN0aW9uID0gZWRpdG9yLnNlY3Rpb25CeUNoaWxkTm9kZShlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgaWYoc2VjdGlvbiAmJiBzZWN0aW9uLm9uS2V5VXApIHtcbiAgICAgICAgICAgICAgICAgICAgc2VjdGlvbi5vbktleVVwKGUsIGVkaXRvcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLm1vdmVDYXJldE9uZVNlY3Rpb25VcCgpO1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihlLmtleSA9PT0gJ0Fycm93RG93bicpIHtcbiAgICAgICAgICAgICAgICBzZWN0aW9uID0gZWRpdG9yLnNlY3Rpb25CeUNoaWxkTm9kZShlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgaWYoc2VjdGlvbiAmJiBzZWN0aW9uLm9uS2V5RG93bikge1xuICAgICAgICAgICAgICAgICAgICBzZWN0aW9uLm9uS2V5RG93bihlLCBlZGl0b3IpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5tb3ZlQ2FyZXRPbmVTZWN0aW9uRG93bigpO1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihlLmtleSA9PT0gJ0VudGVyJykge1xuICAgICAgICAgICAgICAgIHNlY3Rpb24gPSBlZGl0b3Iuc2VjdGlvbkJ5Q2hpbGROb2RlKGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBoYW5kbGVFbnRlcktleSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZihlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmhhbmRsZVNoaWZ0RW50ZXIoZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihzZWN0aW9uICYmIHNlY3Rpb24ub25LZXlFbnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VjdGlvbi5vbktleUVudGVyKGUsIGVkaXRvcik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihzZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuY2FyZXQuaW5zZXJ0TGluZUJyZWFrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZihlLmlzQ29tcG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGUudGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IENvbXBvc2l0aW9uRXZlbnQoJ2NvbXBvc2l0aW9uZW5kJykpO1xuICAgICAgICAgICAgICAgICAgICAvLyB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHsgaGFuZGxlRW50ZXJLZXkoKSB9LCAxMDApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUVudGVyS2V5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihlLmtleSA9PT0gJ1RhYicpIHtcbiAgICAgICAgICAgICAgICBzZWN0aW9uID0gZWRpdG9yLnNlY3Rpb25CeUNoaWxkTm9kZShlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgaWYoc2VjdGlvbiAmJiBzZWN0aW9uLm9uS2V5VGFiKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlY3Rpb24ub25LZXlUYWIoZSwgZWRpdG9yKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoc2VjdGlvbiAmJiBzZWN0aW9uLm5leHRTaWJsaW5nICYmICFlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5wbGFjZUNhcmV0SW50b1NlY3Rpb24oc2VjdGlvbi5uZXh0U2libGluZylcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZihzZWN0aW9uICYmIHNlY3Rpb24ucHJldmlvdXNTaWJsaW5nICYmIGUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnBsYWNlQ2FyZXRJbnRvU2VjdGlvbihzZWN0aW9uLnByZXZpb3VzU2libGluZylcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoZS5rZXkgPT09ICcgJyAmJiAhKGUuaXNDb21wb3NpbmcgfHwgZS5rZXlDb2RlID09PSAyMjkpKSB7XG4gICAgICAgICAgICAgICAgc2VjdGlvbiA9IGVkaXRvci5zZWN0aW9uQnlDaGlsZE5vZGUoZS50YXJnZXQpO1xuICAgICAgICAgICAgICAgIGlmKHNlY3Rpb24gJiYgIXNlbGYuZWRpdG9yLmNhcmV0LmlzUHJlY2VkaW5nQ2hhcmFjdGVyV2hpdGVzcGFjZShzZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5leGVjQ29tbWFuZCgnaW5zZXJ0VGV4dCcsIGZhbHNlLCBzZWxmLmVkaXRvci5odG1sUmF6b3IudGVtcHJvYXJ5UHJ1bmVQcm90ZWN0ZWRXaGl0ZXNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9kbyBub3QgaGFuZGxlIHRoZSBrZXlzIGJlbG93IGlmIENNRCBvciBDb250cm9sXG4gICAgICAgICAgICAvL2lzIG5vdCBwcmVzc2VkIGF0IHRoZSBzYW1lIHRpbWVcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGUua2V5ID09PSAnRW50ZXInKSAgICAgICAgICAgICB7IHNlbGYuaGFuZGxlU2hpZnRFbnRlcihlKTsgfVxuICAgICAgICBlbHNlIGlmKGUua2V5ID09PSAnQXJyb3dVcCcpICAgICAgeyBlZGl0b3IubW92ZUZvY3VzZWRTZWN0aW9uVXAoKTsgZS5wcmV2ZW50RGVmYXVsdCgpOyB9XG4gICAgICAgIGVsc2UgaWYoZS5rZXkgPT09ICdBcnJvd0Rvd24nKSAgICB7IGVkaXRvci5tb3ZlRm9jdXNlZFNlY3Rpb25Eb3duKCk7IGUucHJldmVudERlZmF1bHQoKTsgfVxuICAgICAgICBlbHNlIGlmKGUua2V5ID09PSAnaScpICAgICAgICAgICAgeyBlZGl0b3IudGV4dEVucmljaG1lbnRDb250cm9sLnNob3codHJ1ZSk7IGUucHJldmVudERlZmF1bHQoKTsgfVxuICAgICAgICBlbHNlIGlmKGUua2V5ID09PSAnYScpICAgICAgICAgICAgeyBzZWxmLmhhbmRsZUNtZEEoZSk7IH1cbiAgICAgICAgZWxzZSBpZihlLmtleSA9PT0gJ3onKSAgICAgICAgICAgIHsgZWRpdG9yLnVuZG8oKTsgZS5wcmV2ZW50RGVmYXVsdCgpOyB9XG4gICAgICAgIGVsc2UgaWYoZS5rZXkgPT09ICd5JykgICAgICAgICAgICB7IGVkaXRvci5yZWRvKCk7IGUucHJldmVudERlZmF1bHQoKTsgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlY3Rpb24gPSBlZGl0b3Iuc2VjdGlvbkJ5Q2hpbGROb2RlKGUudGFyZ2V0KTtcbiAgICAgICAgICAgIGlmKHNlY3Rpb24gJiYgc2VjdGlvbi5vbktleUNvbWJpbmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgc2VjdGlvbi5vbktleUNvbWJpbmF0aW9uKGUsIGVkaXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbn1cblxuS2V5UHJlc3NIYW5kbGVyLnByb3RvdHlwZSA9IHtcblxuICAgIGhhbmRsZVNoaWZ0RW50ZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5lZGl0b3Iuc2VjdGlvbkJ5Q2hpbGROb2RlKGV2ZW50LnRhcmdldCk7XG4gICAgICAgIHRoaXMuZWRpdG9yLmFkZE5ld1NlY3Rpb25OZXh0VG8oc2VjdGlvbik7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSxcblxuICAgIGhhbmRsZUJhY2tzcGFjZTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSwgczEsIHMyO1xuXG4gICAgICAgIGlmKCFzZWwpIHJldHVybjsgLy9ubyBjYXJldCBwb3NpdGlvbmVkLCBubyBkZWxldGlvbiByZXF1aXJlZFxuXG4gICAgICAgIGlmKHRoaXMuZWRpdG9yLmNhcmV0LmlzQ29sbGFwc2VkQW5kUG9zaXRpb25lZEF0VGhlQmVnaW5uaW5nT2YodGhpcy5lZGl0b3IuZm9jdXNlZFNlY3Rpb24oKSkpIHtcbiAgICAgICAgICAgIHMyID0gdGhpcy5lZGl0b3Iuc2VjdGlvbkJ5Q2hpbGROb2RlKHNlbC5hbmNob3JOb2RlKTtcbiAgICAgICAgICAgIHMxID0gczIucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3IubWVyZ2VTZWN0aW9ucyhzMSwgczIpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuZWRpdG9yLmFyZU11bHRpcGxlU2VjdGlvbnNTZWxlY3RlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRvci5kZWxldGVOb25Db2xsYXBzZWRTZWxlY3Rpb25Db250ZW50KHNlbCk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZm9yIHNvbWUgcmVhc29uIHRoZXJlIGlzIGEgZWRnZSBjYXNlIGluIHdoaWNoIHRoZSBiYWNrc3BhY2UgZG9lc24ndFxuICAgICAgICAvLyB0cmlnZ2VyIGEgc2VsZWN0aW9uIGNoYW5nZSBhbmQgc28gdGhlIGNvbnRyb2xscyB3aWxsIG5vdCBiZWVuIGhpZGRlblxuICAgICAgICAvLyBieSB0aGUgaGFuZGxlciBpbnRlZGVkIHRvIGRvIHRoaXMuXG4gICAgICAgIHRoaXMuZWRpdG9yLnRleHRFbnJpY2htZW50Q29udHJvbC5oaWRlKCk7XG4gICAgfSxcblxuICAgIGhhbmRsZUNtZEE6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciBlbFRhZyA9IGV2ZW50LnRhcmdldCAmJiBldmVudC50YXJnZXQudGFnTmFtZTtcbiAgICAgICAgdmFyIG5hdGl2ZUV2ZW50SGFuZGxpbmdUYWcgPSBbJ1RFWFRBUkVBJywgJ0lOUFVUJ11cblxuICAgICAgICBpZighbmF0aXZlRXZlbnRIYW5kbGluZ1RhZy5pbmNsdWRlcyhlbFRhZykpIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLnNlbGVjdEV2ZXJ5dGhpbmcoKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gS2V5UHJlc3NIYW5kbGVyO1xuIiwidmFyIHV1aWQgPSByZXF1aXJlKCd1dWlkL3YxJyk7XG52YXIgbG9va3VwUmVmcyA9IHJlcXVpcmUoJy4uLy4uL2xpYi9sb29rdXBfcmVmcycpO1xudmFyIGxvb2t1cFVSTCA9IHJlcXVpcmUoJy4uLy4uL2xpYi9sb29rdXBfcmVmcy9sb29rdXBfYnlfdXJsJyk7XG52YXIgdGhyb3R0bGUgPSByZXF1aXJlKCcuLi8uLi9saWIvdGhyb3R0bGUvdGhyb3R0bGUnKTtcblxudmFyIFJlZmVyZW5jZSA9IGZ1bmN0aW9uKHN0b3JlLCBlZGl0b3IpIHtcbiAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG4gICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG59XG5cblJlZmVyZW5jZS5wcm90b3R5cGUgPSB7XG5cbiAgICBhZGRSZWZlcmVuY2VEYXRhOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHRoaXMuc3RvcmUuYWRkUmVmZXJlbmNlRGF0YShkYXRhKTtcbiAgICB9LFxuXG4gICAgc3RvcmVFeHRlcm5hbFJlZkRhdGE6IGZ1bmN0aW9uKGlkLCBhdHRyKSB7XG4gICAgICAgIHRoaXMuc3RvcmUuc2V0KGlkLCBhdHRyKTtcbiAgICAgICAgdGhpcy5lZGl0b3IucmVmZXJlbmNlSW5zZXJ0ZWRTdWJzY3JpYmVycy5mb3JFYWNoKChjYikgPT4ge1xuICAgICAgICAgICAgY2IoaWQsIGF0dHIpO1xuICAgICAgICB9KVxuICAgIH0sXG5cbiAgICBnZXRFeHRlcm5hbFJlZkRhdGE6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JlLmdldChpZCk7XG4gICAgfSxcblxuICAgIGdldEFsbEV4dGVybmFsUmVmczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JlLmFsbCh0cnVlKTtcbiAgICB9LFxuXG4gICAgdXBkYXRlUmVmRWxlbWVudDogZnVuY3Rpb24ocmVmKSB7XG4gICAgICAgIGlmKHJlZi5nZXRBdHRyaWJ1dGUoJ2RhdGEtZXh0ZXJuYWwnKSAhPT0gJ3RydWUnKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUludGVybmFsUmVmRWxlbWVudChyZWYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVFeHRlcm5hbFJlZkVsZW1lbnQocmVmKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBBcmd1bWVudDogQSBET00gRWxlbWVudCB3aGljaCBpcyBhIGNsaWxkIGVsZW1lbnQgb2YgdGhlIGVkaXRvcidzIGNvbnRlbnRcbiAgICAvLyBlbGVtZW50LiBUaGUgZWxlbWVudCBzaG91bGQgaGF2ZSB0aGUgXCJkYXRhLXJlZlwiIGF0dHJpYnV0ZSByZXByZXNlbnRpbmcgdGhlIGlkXG4gICAgLy8gb2YgYW4gZXh0ZXJuYWwgcmVmZXJlbmNlIChleHRlcm5hbCByZWZlcmVuY2VzIGFyZSBib29rcywgcGFwZXJzKS5cbiAgICAvLyBUaGUgZnVuY3Rpb24gd2lsbCB1cGRhdGUgdGhlIGlubmVySFRNTCBvZiB0aGUgcGFzc2VkIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgIHVwZGF0ZUV4dGVybmFsUmVmRWxlbWVudDogZnVuY3Rpb24ocmVmKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcywgdG1wQ29udGVudCwgcmVma2V5LCByZWZlcmVuY2VlID0gdGhpcy5nZXRFeHRlcm5hbFJlZkRhdGEocmVmLmdldEF0dHJpYnV0ZSgnZGF0YS1yZWYnKSk7XG5cbiAgICAgICAgaWYoIXJlZmVyZW5jZWUpIHtcbiAgICAgICAgICAgIHJlZi5jbGFzc0xpc3QuYWRkKCd3YXJuaW5nJyk7XG4gICAgICAgICAgICByZWYuaW5uZXJIVE1MID0gJ1s8aT5ub3QgZm91bmQ8L2k+XSc7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZWZrZXkgPSByZWZlcmVuY2VlLmF1dGhvci5zcGxpdCgnICcpLnJlZHVjZShmdW5jdGlvbihhLCBlKSB7cmV0dXJuIGEgKyAoZVswXSB8fCAnJyl9LCAnJyk7XG4gICAgICAgIHJlZmtleSArPSAnLSc7XG4gICAgICAgIHJlZmtleSArPSByZWZlcmVuY2VlLnRpdGxlLnNwbGl0KCcgJykucmVkdWNlKGZ1bmN0aW9uKGEsIGUpIHtyZXR1cm4gYSArIChlWzBdIHx8ICcnKX0sICcnKTtcbiAgICAgICAgcmVma2V5ICs9ICctJztcbiAgICAgICAgcmVma2V5ICs9IHJlZmVyZW5jZWUueWVhcjtcblxuICAgICAgICB0bXBDb250ZW50ID0gJ1s8aT4nICsgcmVma2V5ICsgJzwvaT5dJztcblxuICAgICAgICByZWYub25jbGljayA9IGZ1bmN0aW9uKCkge3NlbGYuc2hvd0VkaXRFeHRlcm5hbFJlZkRpYWxvZyh0aGlzKX07XG5cbiAgICAgICAgaWYocmVmZXJlbmNlZS5hdXRob3IudHJpbSgpID09PSAnJyB8fFxuICAgICAgICAgICByZWZlcmVuY2VlLnRpdGxlLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJlZi5jbGFzc0xpc3QuYWRkKCd3YXJuaW5nJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihyZWYuaW5uZXJIVE1MICE9PSB0bXBDb250ZW50KSB7XG4gICAgICAgICAgICByZWYuaW5uZXJIVE1MID0gdG1wQ29udGVudDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBBY2NvcmRpbmcgdG8gdXBkYXRlRXh0ZXJuYWxSZWZFbGVtZW50IGJ1dCBmb3IgaW50ZXJuYWwgcmVmcywgbGlrZSB0YWJsZXMsXG4gICAgLy8gZmlndXJlcywgc2VjdGlvbnNcbiAgICB1cGRhdGVJbnRlcm5hbFJlZkVsZW1lbnQ6IGZ1bmN0aW9uKHJlZikge1xuICAgICAgICB2YXIgcmVmZXJlbmNlZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHJlZi5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmVmJykpLFxuICAgICAgICAgICAgdG1wQ29udGVudCwgaW5kZXhQcmVmaXggPSAnJywgYWxsU2VsZWN0b3I7XG5cbiAgICAgICAgaWYocmVmZXJlbmNlZSkge1xuICAgICAgICAgICAgYWxsU2VsZWN0b3IgPSByZWZlcmVuY2VlLnRhZ05hbWU7XG5cbiAgICAgICAgICAgIGlmKHJlZmVyZW5jZWUudGFnTmFtZSA9PT0gJ0ZJR1VSRScgfHwgcmVmZXJlbmNlZS50YWdOYW1lID09PSAnTUVSTUFJRCcpIHtcbiAgICAgICAgICAgICAgICBhbGxTZWxlY3RvciA9ICdGSUdVUkUsIE1FUk1BSUQnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihyZWZlcmVuY2VlLnRhZ05hbWUgPT0gJ1BSRScpIHtcbiAgICAgICAgICAgICAgICBhbGxTZWxlY3RvciA9ICdwcmUuY29kZSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlZmVyZW5jZWVJbmRleCA9IHRoaXMuZWRpdG9yLmNvbnRlbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYWxsU2VsZWN0b3IpLmluZGV4T2YocmVmZXJlbmNlZSk7XG5cbiAgICAgICAgICAgIGlmKHJlZmVyZW5jZWUudGFnTmFtZSA9PT0gJ0ZJR1VSRScpIHtcbiAgICAgICAgICAgICAgICBpbmRleFByZWZpeCA9ICdmaWctJyArIChyZWZlcmVuY2VlSW5kZXgrMSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYocmVmZXJlbmNlZS50YWdOYW1lID09PSAnVEFCTEUnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXhQcmVmaXggPSAndGFibGUtJyArIChyZWZlcmVuY2VlSW5kZXgrMSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYocmVmZXJlbmNlZS50YWdOYW1lID09PSAnUFJFJykge1xuICAgICAgICAgICAgICAgIGluZGV4UHJlZml4ID0gJ2xpc3RpbmctJyArIChyZWZlcmVuY2VlSW5kZXgrMSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYocmVmZXJlbmNlZS5jbGFzc0xpc3QuY29udGFpbnMoJ2Zvcm11bGEnKSkge1xuICAgICAgICAgICAgICAgIGluZGV4UHJlZml4ID0gJ2VxLScgKyAocmVmZXJlbmNlZUluZGV4KzEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmKHJlZmVyZW5jZWUuY2xhc3NMaXN0LmNvbnRhaW5zKCdtZXJtYWlkJykpIHtcbiAgICAgICAgICAgICAgICBpbmRleFByZWZpeCA9ICdmaWctJyArIChyZWZlcmVuY2VlSW5kZXgrMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKHJlZmVyZW5jZWUudGFnTmFtZSA9PT0gJ0gyJyB8fCByZWZlcmVuY2VlLnRhZ05hbWUgPT09ICdIMycgfHwgcmVmZXJlbmNlZS50YWdOYW1lID09PSAnSDQnIHx8IHJlZmVyZW5jZWUudGFnTmFtZSA9PT0gJ0g1Jykge1xuICAgICAgICAgICAgICAgIGluZGV4UHJlZml4ID0gJ3NlY3Rpb246ICcgKyByZWZlcmVuY2VlLmlubmVySFRNTDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG1wQ29udGVudCA9ICdbPGk+PGEgaHJlZj1cIiMnICsgcmVmZXJlbmNlZS5pZCArICdcIj4nICsgaW5kZXhQcmVmaXggKyAnPC9hPjwvaT5dJztcblxuICAgICAgICAgICAgaWYocmVmLmlubmVySFRNTCAhPT0gdG1wQ29udGVudCkge1xuICAgICAgICAgICAgICAgIHJlZi5pbm5lckhUTUwgPSB0bXBDb250ZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZWYuY2xhc3NMaXN0LnJlbW92ZSgnd2FybmluZycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVmLmlubmVySFRNTCA9ICdbcmVmIG5vdCBmb3VuZF0nO1xuICAgICAgICAgICAgcmVmLmNsYXNzTGlzdC5hZGQoJ3dhcm5pbmcnKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRSZWZDYXB0aW9uSFRNTDogZnVuY3Rpb24ocmVmZXJlbmNlRWwpIHtcbiAgICAgICAgdmFyIHJlZklkID0gcmVmZXJlbmNlRWwuZ2V0QXR0cmlidXRlKCdkYXRhLXJlZicpO1xuICAgICAgICBpZihyZWZlcmVuY2VFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZXh0ZXJuYWwnKSA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRFeHRlcm5hbFJlZkNhcHRpb25IVE1MKHJlZklkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEludGVybmFsUmVmQ2FwdGlvbkhUTUwoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocmVmSWQpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRWYWx1ZXNGb3JDcm9zc1JlZmVyZW5jZVNlbGVjdEJveDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICAgIGludGVybmFscyA9IHRoaXMuZWRpdG9yLmNvbnRlbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2ZpZ3VyZSwgdGFibGUsIGgyLCBoMywgaDQsIGg1LCBwcmUuY29kZSwgLmZvcm11bGEsIC5tZXJtYWlkJyk7XG5cbiAgICAgICAgaW50ZXJuYWxzID0gaW50ZXJuYWxzLmZpbHRlcihmdW5jdGlvbihpbnQpIHtcbiAgICAgICAgICAgIGlmKGludC50YWdOYW1lID09PSAnRklHVVJFJyAmJiAhaW50LnF1ZXJ5U2VsZWN0b3IoJ2ZpZ2NhcHRpb24nKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoaW50LnRhZ05hbWUgPT09ICdUQUJMRScgJiYgIWludC5xdWVyeVNlbGVjdG9yKCdjYXB0aW9uJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGludC50YWdOYW1lID09PSAnUFJFJyAmJiAhaW50LnF1ZXJ5U2VsZWN0b3IoJ2NhcHRpb24nKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoaW50LmNsYXNzTGlzdC5jb250YWlucygnZm9ybXVsYScpICYmICFpbnQucXVlcnlTZWxlY3RvcignY2FwdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihpbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdtZXJtYWlkJykgJiYgIWludC5xdWVyeVNlbGVjdG9yKCdjYXB0aW9uJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBmb3IodmFyIGk9MDsgaTxpbnRlcm5hbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFtpbnRlcm5hbHNbaV0uaWQsIHRoaXMuZ2V0SW50ZXJuYWxSZWZDYXB0aW9uSFRNTChpbnRlcm5hbHNbaV0pXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBnZXRWYWx1ZXNGb3JFeGlzdGluZ1JlZmVyZW5jZVNlbGVjdEJveDogYXN5bmMgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICAgIGFsbFJlZnMgPSBhd2FpdCB0aGlzLnN0b3JlLmFsbEFzeW5jKHRydWUpLFxuICAgICAgICAgICAgZXh0ZXJuYWxzID0gT2JqZWN0LmtleXMoYWxsUmVmcyk7XG5cbiAgICAgICAgZm9yKHZhciBqPTA7IGo8ZXh0ZXJuYWxzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChbZXh0ZXJuYWxzW2pdLCB0aGlzLmdldEV4dGVybmFsUmVmQ2FwdGlvbkhUTUwoZXh0ZXJuYWxzW2pdLCBhbGxSZWZzKV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXJlRXhpc3RpbmdSZWZlcmVuY2VzQXZhaWxhYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFsbFJlZnMgPSB0aGlzLmdldEFsbEV4dGVybmFsUmVmcygpO1xuXG4gICAgICAgIHJldHVybiBhbGxSZWZzICYmIE9iamVjdC5rZXlzKGFsbFJlZnMpLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgLy8gcmV0dXJucyB0aGUgY2FwdGlvbiB0byBkaXNwbGF5IGluIHRoZSByZWZlcmVuY2Ugc2VsZWN0IGJveC5cbiAgICBnZXRJbnRlcm5hbFJlZkNhcHRpb25IVE1MOiBmdW5jdGlvbihyZWZlcmVlRWwpIHtcbiAgICAgICAgaWYoIXJlZmVyZWVFbCkge1xuICAgICAgICAgICAgcmV0dXJuICdbcmVmIG5vdCBmb3VuZF0nO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRtcENhcHRpb24sXG4gICAgICAgICAgICBhbGxTZWxlY3RvciA9IHJlZmVyZWVFbC50YWdOYW1lO1xuXG4gICAgICAgIGlmKHJlZmVyZWVFbC50YWdOYW1lID09PSAnRklHVVJFJyB8fCByZWZlcmVlRWwudGFnTmFtZSA9PT0gICdNRVJNQUlEJykge1xuICAgICAgICAgICAgYWxsU2VsZWN0b3IgPSAnRklHVVJFLCBNRVJNQUlEJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHJlZmVyZWVFbC50YWdOYW1lID09PSAnUFJFJykge1xuICAgICAgICAgICAgYWxsU2VsZWN0b3IgPSAncHJlLmNvZGUnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVmZXJlbmNlZUluZGV4ID0gdGhpcy5lZGl0b3IuY29udGVudEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChhbGxTZWxlY3RvcikuaW5kZXhPZihyZWZlcmVlRWwpO1xuXG4gICAgICAgIGlmKHJlZmVyZWVFbC50YWdOYW1lID09PSAnRklHVVJFJykge1xuICAgICAgICAgICAgdG1wQ2FwdGlvbiA9IHJlZmVyZWVFbC5xdWVyeVNlbGVjdG9yKCdmaWdjYXB0aW9uJykuaW5uZXJIVE1MO1xuICAgICAgICAgICAgcmV0dXJuICc8Yj5JbWFnZTwvYj4gJyArIChyZWZlcmVuY2VlSW5kZXgrMSkgKyAnOiAnICsgdG1wQ2FwdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmKHJlZmVyZWVFbC50YWdOYW1lID09PSAnVEFCTEUnKSB7XG4gICAgICAgICAgICB0bXBDYXB0aW9uID0gcmVmZXJlZUVsLnF1ZXJ5U2VsZWN0b3IoJ2NhcHRpb24nKS5pbm5lckhUTUw7XG4gICAgICAgICAgICByZXR1cm4gJzxiPlRhYmxlPC9iPiAnICsgKHJlZmVyZW5jZWVJbmRleCsxKSArICc6ICcgKyB0bXBDYXB0aW9uO1xuICAgICAgICB9IGVsc2UgaWYocmVmZXJlZUVsLnRhZ05hbWUgPT09ICdIMicgfHwgcmVmZXJlZUVsLnRhZ05hbWUgPT09ICdIMycgfHwgcmVmZXJlZUVsLnRhZ05hbWUgPT09ICdINCcgfHwgcmVmZXJlZUVsLnRhZ05hbWUgPT09ICdINScpIHtcbiAgICAgICAgICAgIHJldHVybiAnPGI+U2VjdGlvbjwvYj46ICcgKyByZWZlcmVlRWwuaW5uZXJIVE1MO1xuICAgICAgICB9IGVsc2UgaWYocmVmZXJlZUVsLnRhZ05hbWUgPT09ICdQUkUnKSB7XG4gICAgICAgICAgICB0bXBDYXB0aW9uID0gcmVmZXJlZUVsLnF1ZXJ5U2VsZWN0b3IoJ2NhcHRpb24nKS5pbm5lckhUTUw7XG4gICAgICAgICAgICByZXR1cm4gJzxiPkxpc3Rpbmc8L2I+ICcgKyAocmVmZXJlbmNlZUluZGV4KzEpICsgJzogJyArIHRtcENhcHRpb247XG4gICAgICAgIH0gZWxzZSBpZihyZWZlcmVlRWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdmb3JtdWxhJykpIHtcbiAgICAgICAgICAgIHRtcENhcHRpb24gPSByZWZlcmVlRWwucXVlcnlTZWxlY3RvcignY2FwdGlvbicpLmlubmVySFRNTDtcbiAgICAgICAgICAgIHJldHVybiAnPGI+RXF1YXRpb248L2I+ICcgKyAocmVmZXJlbmNlZUluZGV4KzEpICsgJzogJyArIHRtcENhcHRpb247XG4gICAgICAgIH0gZWxzZSBpZihyZWZlcmVlRWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdtZXJtYWlkJykpIHtcbiAgICAgICAgICAgIHRtcENhcHRpb24gPSByZWZlcmVlRWwucXVlcnlTZWxlY3RvcignY2FwdGlvbicpLmlubmVySFRNTDtcbiAgICAgICAgICAgIHJldHVybiAnPGI+SW1hZ2U8L2I+ICcgKyAocmVmZXJlbmNlZUluZGV4KzEpICsgJzogJyArIHRtcENhcHRpb247XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gcmV0dXJucyB0aGUgY2FwdGlvbiB0byBkaXNwbGF5IGluIHRoZSByZWZlcmVuY2Ugc2VsZWN0IGJveC5cbiAgICBnZXRFeHRlcm5hbFJlZkNhcHRpb25IVE1MOiBmdW5jdGlvbihyZWZlcmVlSWQsIGFsbFJlZnMpIHtcbiAgICAgICAgdmFyIHJlZiA9IChhbGxSZWZzIHx8IHRoaXMuZ2V0QWxsRXh0ZXJuYWxSZWZzKCkpW3JlZmVyZWVJZF07XG4gICAgICAgIGlmKCFyZWYpIHsgcmV0dXJuICcnIH1cbiAgICAgICAgcmV0dXJuIFtyZWYuYXV0aG9yLCByZWYudGl0bGUsIChyZWYucHVibGlzaGVyIHx8IHJlZi5qb3VybmFsKSwgcmVmLnllYXJdLmZpbHRlcihmdW5jdGlvbiAoZikgeyByZXR1cm4gZiAhPT0gJycgJiYgZiB9KS5qb2luKCcgLSAnKTtcbiAgICB9LFxuXG4gICAgaW5zZXJ0SW50ZXJuYWxSZWZlcmVuY2U6IGZ1bmN0aW9uKGZvcm1EYXRhKSB7XG4gICAgICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICBub2RlLmNsYXNzTGlzdC5hZGQoJ3JlZmVyZW5jZScpO1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnZGF0YS1yZWYnLCBmb3JtRGF0YS5yZWYpO1xuXG4gICAgICAgIGlmKHRoaXMuZ2V0RXh0ZXJuYWxSZWZEYXRhKGZvcm1EYXRhLnJlZikpIHtcbiAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdkYXRhLWV4dGVybmFsJywgJ3RydWUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuZWRpdG9yLmNhcmV0Lmluc2VydE5vZGUobm9kZSk7XG4gICAgfSxcblxuICAgIGluc2VydEV4dGVybmFsUmVmZXJlbmNlOiBmdW5jdGlvbihmb3JtRGF0YSkge1xuICAgICAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKSxcbiAgICAgICAgICAgIHJlZklkID0gdXVpZCgpLFxuICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgbm9kZS5jbGFzc0xpc3QuYWRkKCdyZWZlcmVuY2UnKTtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScsIGZhbHNlKTtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtZXh0ZXJuYWwnLCAndHJ1ZScpO1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnZGF0YS1yZWYnLCByZWZJZCk7XG4gICAgICAgIG5vZGUub25jbGljayA9IGZ1bmN0aW9uKCkge3NlbGYuc2hvd0VkaXRFeHRlcm5hbFJlZkRpYWxvZyh0aGlzKX07XG4gICAgICAgIHRoaXMuc3RvcmVFeHRlcm5hbFJlZkRhdGEocmVmSWQsIGZvcm1EYXRhKTtcbiAgICAgICAgdGhpcy5lZGl0b3IuY2FyZXQuaW5zZXJ0Tm9kZShub2RlKTtcbiAgICB9LFxuXG4gICAgc2hvd0VkaXRFeHRlcm5hbFJlZkRpYWxvZzogZnVuY3Rpb24ocmVmTm9kZSkge1xuICAgICAgICB2YXIgcmVmSWQgPSByZWZOb2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1yZWYnKSxcbiAgICAgICAgICAgIHJlZiA9IHRoaXMuZ2V0RXh0ZXJuYWxSZWZEYXRhKHJlZklkKSxcbiAgICAgICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGlmKCFyZWYpIHsgcmV0dXJuIH1cblxuICAgICAgICBzZWxmLmVkaXRvci51bmZvY3VzU2VjdGlvbigpO1xuXG4gICAgICAgIHNlbGYuZWRpdG9yLmRpc3BsYXlNb2RhbChzZWxmLmdldEV4dGVybmFsUmVmRGlhbG9nQXR0cmlidXRlcyhyZWYsIHJlZklkKSwgZnVuY3Rpb24oZm9ybURhdGEpIHtcbiAgICAgICAgICAgIHZhciBzZWN0aW9uID0gc2VsZi5lZGl0b3Iuc2VjdGlvbkJ5Q2hpbGROb2RlKHJlZk5vZGUpO1xuICAgICAgICAgICAgaWYoc2VjdGlvbikge1xuICAgICAgICAgICAgICAgIHNlY3Rpb24uZm9yY2VVcGRhdGVPbklucHV0UHJvY2Vzc3NpbmdFbmFibGVtZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5zdG9yZUV4dGVybmFsUmVmRGF0YShyZWZJZCwgZm9ybURhdGEpO1xuICAgICAgICAgICAgc2VsZi5lZGl0b3IudW5mcmVlemVTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHNlbGYuZWRpdG9yLnRleHRFbnJpY2htZW50Q29udHJvbC5oaWRlKCk7XG5cbiAgICAgICAgICAgIHNlbGYuZWRpdG9yLnJlZmVyZW5jZS51cGRhdGVSZWZFbGVtZW50KHJlZk5vZGUpO1xuICAgICAgICAgICAgc2VsZi5lZGl0b3IudW5mb2N1c1NlY3Rpb24oKTtcbiAgICAgICAgICAgIHNlbGYuZWRpdG9yLmNhcmV0LmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmVkaXRvci5zZWN0aW9uVHlwZVNlbGVjdG9yLmhpZGUoKTtcbiAgICAgICAgICAgIH0sIDUwKVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgZ2V0RXh0ZXJuYWxSZWZEaWFsb2dBdHRyaWJ1dGVzOiBmdW5jdGlvbihkYXRhUmVjb3JkLCByZWZJZCkge1xuICAgICAgICBkYXRhUmVjb3JkID0gZGF0YVJlY29yZCB8fCB7fTtcblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHJlZmVyZW5jZVR5cGVzID0ge1xuICAgICAgICAgICAgJ0FydGljbGUnOiB7XG4gICAgICAgICAgICAgICAgcmVxdWlyZWQ6IFsnYXV0aG9yJywgJ3RpdGxlJywgJ2pvdXJuYWwnLCAneWVhciddLFxuICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBbJ3ZvbHVtZScsICdudW1iZXInLCAncGFnZXMnLCAnbW9udGgnLCAnc3VidGl0bGUnXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdCb29rJzoge1xuICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBbJ2F1dGhvcicsICd0aXRsZScsICdwdWJsaXNoZXInLCAneWVhciddLFxuICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBbJ2VkaXRvcicsICd2b2x1bWUnLCAnbnVtYmVyJywgJ3NlcmllcycsICdlZGl0aW9uJywgJ21vbnRoJywgJ3N1YnRpdGxlJ11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnQ29uZmVyZW5jZS9JbnByb2NlZWRpbmdzJzoge1xuICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBbJ2F1dGhvcicsICd0aXRsZScsICdib29rdGl0bGUnLCAneWVhciddLFxuICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBbJ2VkaXRvcicsICd2b2x1bWUnLCAnbnVtYmVyJywgJ3NlcmllcycsICdwYWdlcycsICdtb250aCcsICdvcmdhbml6YXRpb24nXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdJbmJvb2snOiB7XG4gICAgICAgICAgICAgICAgcmVxdWlyZWQ6IFsndGl0bGUnLCAncHVibGlzaGVyJywgJ3llYXInXSxcbiAgICAgICAgICAgICAgICBvcHRpb25hbDogWydhdXRob3InLCAnZWRpdG9yJywgJ2NoYXB0ZXInLCAncGFnZXMnLCAnc3VidGl0bGUnXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdNYW51YWwnOiB7XG4gICAgICAgICAgICAgICAgcmVxdWlyZWQ6IFsndGl0bGUnXSxcbiAgICAgICAgICAgICAgICBvcHRpb25hbDogWydhdXRob3InLCAnb3JnYW5pemF0aW9uJywgJ2VkaXRpb24nLCAnbW9udGgnLCAneWVhcicsICdzdWJ0aXRsZSddXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ01hc3RlcnN0aGVzaXMnOiB7XG4gICAgICAgICAgICAgICAgcmVxdWlyZWQ6IFsnYXV0aG9yJywgJ3RpdGxlJywgJ3NjaG9vbCcsICd5ZWFyJ10sXG4gICAgICAgICAgICAgICAgb3B0aW9uYWw6IFsnbW9udGgnLCAnc3VidGl0bGUnXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdQaGR0aGVzaXMnOiB7XG4gICAgICAgICAgICAgICAgcmVxdWlyZWQ6IFsnYXV0aG9yJywgJ3RpdGxlJywgJ3NjaG9vbCcsICd5ZWFyJ10sXG4gICAgICAgICAgICAgICAgb3B0aW9uYWw6IFsnbW9udGgnLCAnc3VidGl0bGUnXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdQcm9jZWVkaW5ncyc6IHtcbiAgICAgICAgICAgICAgICByZXF1aXJlZDogWyd0aXRsZScsICd5ZWFyJ10sXG4gICAgICAgICAgICAgICAgb3B0aW9uYWw6IFsnZWRpdG9yJywgJ3ZvbHVtZScsICdudW1iZXInLCAnc2VyaWVzJywgJ21vbnRoJywgJ29yZ2FuaXphdGlvbicsICdzdWJ0aXRsZSddXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ1RlY2hyZXBvcnQnOiB7XG4gICAgICAgICAgICAgICAgcmVxdWlyZWQ6IFsnYXV0aG9yJywgJ3RpdGxlJywgJ2luc3RpdHV0aW9uJywgJ3llYXInXSxcbiAgICAgICAgICAgICAgICBvcHRpb25hbDogWyd0eXBlJywgJ251bWJlcicsICdtb250aCcsICdzdWJ0aXRsZSddXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ1dlYnNpdGUnOiB7XG4gICAgICAgICAgICAgICAgcmVxdWlyZWQ6IFsndXJsJ10sXG4gICAgICAgICAgICAgICAgb3B0aW9uYWw6IFsnYXV0aG9yJywgJ2RhdGUnLCAnbW9udGgnLCAneWVhcicsICd0aXRsZSddXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYWxsb3dlZFR5cGVWYWx1ZXMgPSBPYmplY3Qua2V5cyhyZWZlcmVuY2VUeXBlcylcbiAgICAgICAgICAgIC5tYXAocnQgPT4gW1xuICAgICAgICAgICAgICAgIHJ0LFxuICAgICAgICAgICAgICAgIHJ0LFxuICAgICAgICAgICAgICAgICdUeXBlOiAnICsgcnRcbiAgICAgICAgICAgIF0pXG5cbiAgICAgICAgdmFyIGhhbmRsZVVybEZpZWxkQ2hhbmdlID0gYXN5bmMgZnVuY3Rpb24gKGZvcm1EYXRhLCBkRnJvbSwgdHJpZ2dlckVsZW1lbnQsIGFsbEV4aXN0aW5nUmVmcywgdXJsKSB7XG5cbiAgICAgICAgICAgIHZhciB1cmwgPSB1cmwgfHwgZm9ybURhdGEudXJsO1xuICAgICAgICAgICAgdmFyIGZpZWxkcyA9IFsndXJsJywgJ2F1dGhvcicsICd0aXRsZScsICd5ZWFyJywgJ21vbnRoJ11cblxuICAgICAgICAgICAgaWYobG9va3VwVVJMLmlzVmFsaWRJRCh1cmwpKSB7XG4gICAgICAgICAgICAgICAgZmllbGRzLmZvckVhY2goZmllbGQgPT4gZEZyb20uc2V0VG9vbHRpcChmaWVsZCwgJ1dhaXQgZm9yIGl0IC4uLicsICcnLCAndG9vbHRpcC1sb2FkaW5nJykpXG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdXJsTWV0YSA9IGF3YWl0IGxvb2t1cFVSTC5mZXRjaEpTT04odXJsKTtcblxuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh1cmxNZXRhKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmllbGQgPSBkRnJvbS5maWVsZHMuZmluZChmID0+IGYubmFtZSA9PSBrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZmllbGQgJiYgZmllbGQuZG9tRWxlbWVudCAmJiBmaWVsZC5kb21FbGVtZW50LnNldFZhbHVlICYmIGZvcm1EYXRhW2ZpZWxkLm5hbWVdICE9PSB1cmxNZXRhW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZC5kb21FbGVtZW50LnNldFZhbHVlKHVybE1ldGFba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRzLmZvckVhY2goZmllbGQgPT4gZEZyb20ucmVzZXRUb29sdGlwKGZpZWxkKSk7XG4gICAgICAgICAgICAgICAgICAgIGRGcm9tLnJlc2V0VG9vbHRpcCgnbG9va3VwSWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGFuZGxlTG9va3VwSWRGaWVsZENoYW5nZSA9IGZ1bmN0aW9uKGZvcm1EYXRhLCBkRnJvbSwgdHJpZ2dlckVsZW1lbnQsIGFsbEV4aXN0aW5nUmVmcykge1xuICAgICAgICAgICAgZEZyb20uc2V0VG9vbHRpcCgnbG9va3VwSWQnLCAnV2FpdCBmb3IgaXQgLi4uJywgJycsICd0b29sdGlwLWxvYWRpbmcnKVxuXG4gICAgICAgICAgICBjb25zdCBzaW1pbGFyUmVmID0gYWxsRXhpc3RpbmdSZWZzLmZpbmQocmVmID0+IChyZWYubG9va3VwSWQgJiYgcmVmLmxvb2t1cElkLnRyaW0oKS50b0xvd2VyQ2FzZSgpID09PSBmb3JtRGF0YS5sb29rdXBJZC50cmltKCkudG9Mb3dlckNhc2UoKSkpXG5cbiAgICAgICAgICAgIGlmKGZvcm1EYXRhLmxvb2t1cElkXG4gICAgICAgICAgICAgICAgJiYgc2ltaWxhclJlZlxuICAgICAgICAgICAgICAgICYmICghcmVmSWQgfHwgcmVmSWQgIT09IHNpbWlsYXJSZWYuaWQpKSB7XG4gICAgICAgICAgICAgICAgZEZyb20uc2V0VG9vbHRpcEVycm9yKCdsb29rdXBJZCcsICdZb3UgYWxyZWFkeSByZWZlcmVuY2VkIHRoaXMgZG9jdW1lbnQgYmVmb3JlLiBZb3UgY2FuIGZpbmQgaXQgaW4gdGhlIFwiRmluZCBSZWZlcmVuY2VcIiB0YWIgb2YgdGhpcyBkaWFsb2cuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZXJyb3JUZXh0ID0gJ1NvbWV0aGluZyB3ZW50IHdyb25nLiBNYXliZSB0aGUgcHJvdmlkZWQgRE9JIC8gSVNCTiAvIFdlYnNpdGUgVVJMIC8gYXJYaXYgSUQgZG9lcyBub3QgZXhpc3RzPyc7XG5cbiAgICAgICAgICAgIGxvb2t1cFJlZnMuZmV0Y2hKU09OKGZvcm1EYXRhLmxvb2t1cElkKVxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnZXJyb3Igd2hlbiBmZXRjaGluZyByZWYgZGF0YScsIGVycilcbiAgICAgICAgICAgICAgICAgICAgaWYoZXJyIGluc3RhbmNlb2YgbG9va3VwUmVmcy5lcnJvcnMuSW52YWxpZElEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkRnJvbS5zZXRUb29sdGlwV2FybmluZygnbG9va3VwSWQnLCAnSXQgbmVlZHMgdG8gYmUgYSB2YWxpZCBET0kgb3IgSVNCTicpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYoZXJyIGluc3RhbmNlb2YgbG9va3VwUmVmcy5lcnJvcnMuRW1wdHlJRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZEZyb20ucmVzZXRUb29sdGlwKCdsb29rdXBJZCcpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYoZXJyIGluc3RhbmNlb2YgbG9va3VwUmVmcy5lcnJvcnMuTm90Rm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRGcm9tLnNldFRvb2x0aXBFcnJvcignbG9va3VwSWQnLCAnTm8gZGF0YSBmb3VuZCBmb3IgdGhlIGdpdmVuIERPSSAvIElTQk4nKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRGcm9tLnNldFRvb2x0aXBFcnJvcignbG9va3VwSWQnLCBlcnJvclRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZEZyb20uc2V0VG9vbHRpcCgnbG9va3VwSWQnLCAnTW9uc3RlcldyaXRlciBmaWxsZWQgb3V0IGFsbCB0aGUgaW5mb3JtYXRpb24gaXQgY291bGQgZmluZC4gWW91IGNhbiBzdGlsbCBjb21wbGV0ZSBvciBjaGFuZ2UgdGhlIGRhdGEgYmVsb3cuJywgJyYjMTAwMDM7JywgJ3Rvb2x0aXAtc3VjY2VzcycpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhkYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZmllbGROYW1lID0+IGRGcm9tLmZpZWxkcy5maW5kKGYgPT4gZi5uYW1lID09IGZpZWxkTmFtZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmaWVsZCA9PiBmaWVsZCAmJiBmaWVsZC5kb21FbGVtZW50ICYmIGZpZWxkLmRvbUVsZW1lbnQuc2V0VmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihmb3JtRGF0YVtmaWVsZC5uYW1lXSAhPT0gZGF0YVtmaWVsZC5uYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQuZG9tRWxlbWVudC5zZXRWYWx1ZShkYXRhW2ZpZWxkLm5hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KS5jYXRjaChleCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRGcm9tLnNldFRvb2x0aXBFcnJvcignbG9va3VwSWQnLCBlcnJvclRleHQpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGFuZGxlVGl0bGVGaWVsZENoYW5nZSA9IGZ1bmN0aW9uIChmb3JtRGF0YSwgZEZyb20sIHRyaWdnZXJFbGVtZW50LCBhbGxFeGlzdGluZ1JlZnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpbWlsYXJSZWYgPSBhbGxFeGlzdGluZ1JlZnMuZmluZChyZWYgPT4gKHJlZi50aXRsZSAmJiByZWYudGl0bGUudHJpbSgpLnRvTG93ZXJDYXNlKCkgPT09IGZvcm1EYXRhLnRpdGxlLnRyaW0oKS50b0xvd2VyQ2FzZSgpKSlcblxuICAgICAgICAgICAgaWYoZm9ybURhdGEudGl0bGVcbiAgICAgICAgICAgICAgICAmJiBzaW1pbGFyUmVmXG4gICAgICAgICAgICAgICAgJiYgKCFyZWZJZCB8fCByZWZJZCAhPT0gc2ltaWxhclJlZi5pZCkpIHtcbiAgICAgICAgICAgICAgICBkRnJvbS5zZXRUb29sdGlwV2FybmluZygndGl0bGUnLCAnWW91IGFscmVhZHkgcmVmZXJlbmNlZCBhIGRvY3VtZW50IHdpdGggdGhlIHNhbWUgdGl0bGUuIENvbnNpZGVyIHRvIGNob29zZSBpdCBpbiB0aGUgXCJGaW5kIFJlZmVyZW5jZVwiIHRhYiBvZiB0aGlzIGRpYWxvZy4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRGcm9tLnJlc2V0VG9vbHRpcCgndGl0bGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvbkZvcm1DaGFuZ2UgPSB0aHJvdHRsZSgxMDAsIGZ1bmN0aW9uIChmb3JtRGF0YSwgZEZyb20sIHRyaWdnZXJFbGVtZW50KSB7XG4gICAgICAgICAgICBpZighdHJpZ2dlckVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBhbGxFeGlzdGluZ1JlZnMgPSBPYmplY3QudmFsdWVzKHNlbGYuZ2V0QWxsRXh0ZXJuYWxSZWZzKCkpO1xuXG4gICAgICAgICAgICBpZih0cmlnZ2VyRWxlbWVudC5uYW1lID09PSAnbG9va3VwSWQnKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlTG9va3VwSWRGaWVsZENoYW5nZShmb3JtRGF0YSwgZEZyb20sIHRyaWdnZXJFbGVtZW50LCBhbGxFeGlzdGluZ1JlZnMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmKHRyaWdnZXJFbGVtZW50Lm5hbWUgPT09ICd0aXRsZScpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVUaXRsZUZpZWxkQ2hhbmdlKGZvcm1EYXRhLCBkRnJvbSwgdHJpZ2dlckVsZW1lbnQsIGFsbEV4aXN0aW5nUmVmcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYodHJpZ2dlckVsZW1lbnQubmFtZSA9PT0gJ3VybCcpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVVcmxGaWVsZENoYW5nZShmb3JtRGF0YSwgZEZyb20sIHRyaWdnZXJFbGVtZW50LCBhbGxFeGlzdGluZ1JlZnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge25hbWU6ICdsb29rdXBJZCcsIGRpc3BsYXlOYW1lOiAnQXV0b21hdGljYWxseSBGZXRjaCBhbmQgRmlsbCBPdXQgSW5mb3JtYXRpb24gQnk6JywgdG9vbHRpcDogeyB0ZXh0OiAnSW5zZXJ0IGEgdmFsaWQgRE9JLCBJU0JOLCBhclhpdiBJRCBvciB0aGUgVVJMIG9mIGEgd2Vic2l0ZSB5b3Ugd2FudCB0byBjaXRlLiBNb25zdGVyV3JpdGVyIHdpbGwgdHJ5IHRvIGZpbmQgYWxsIHRoZSBpbmZvcm1hdGlvbiBvbiB0aGUgaW50ZXJuZXQgZm9yIHlvdS4nLCBpbklucHV0OiB0cnVlIH0sIGF1dG9jb21wbGV0ZTogJ29mZicsIHBsYWNlaG9sZGVyOiAnSVNCTiAvIERPSSAvIGFyWGl2IElEIC8gV2Vic2l0ZSBVUkwnLCBvbkZvcm1DaGFuZ2U6IG9uRm9ybUNoYW5nZSB9LFxuICAgICAgICAgICAge25hbWU6ICd0eXBlJywgZGlzcGxheU5hbWU6ICdNYW51YWxseSBTcGVjaWZ5IEluZm9ybWF0aW9uOicsIGRlZmF1bHRWYWx1ZTogJ0FydGljbGUnLCBhbGxvd2VkVmFsdWVzOiBhbGxvd2VkVHlwZVZhbHVlcyB9LFxuICAgICAgICAgICAge25hbWU6ICd1cmwnLCBwbGFjZWhvbGRlcjogJ1dlYnNpdGUgVVJMJywgdG9vbHRpcDogJ1RoZSBhZGRyZXNzIG9mIHRoZSB3ZWJzaXRlLid9LFxuICAgICAgICAgICAge25hbWU6ICdkYXRlJywgcGxhY2Vob2xkZXI6ICdMb29rdXAgRGF0ZScsIHRvb2x0aXA6ICdUaGUgZGF0ZSB3aGVuIHlvdSBhY2Nlc3NlZCB0aGUgd2Vic2l0ZS4gVGhpcyBpcyB1c2FsbHkgdG9kYXlzIGRhdGUuJywgZGVmYXVsdFZhbHVlOiAoKSA9PiAobmV3IERhdGUoKSkuZ2V0RnVsbFllYXIoKSArICctJyArICgobmV3IERhdGUoKSkuZ2V0TW9udGgoKSArIDEpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKSArICctJyArICgobmV3IERhdGUoKSkuZ2V0RGF0ZSgpKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJykgfSxcbiAgICAgICAgICAgIHtuYW1lOiAnYXV0aG9yJywgcGxhY2Vob2xkZXI6ICdBdXRob3IocyknLCB0b29sdGlwOiAnQWxsIGF1dGhvcnMgc2VwYXJhdGVkIGJ5IHRoZSB3b3JkIFwiYW5kXCIuIENvbW1hIGlzIHVzZWQgdG8gZGlzdGluZ3Vpc2ggZmlyc3QgYW5kIGxhc3QgbmFtZS4gZS5nIFwiV29sZiwgT2xpdmVyIGFuZCBCYXJuZXR0LCBQaGlsbGlwXCIuJ30sXG4gICAgICAgICAgICB7bmFtZTogJ3RpdGxlJywgcGxhY2Vob2xkZXI6ICdUaXRsZScsIHRvb2x0aXA6ICdUaGUgdGl0bGUgb2YgdGhlIHJlZmVyZW5jZS4nfSxcbiAgICAgICAgICAgIHtuYW1lOiAnc3VidGl0bGUnLCBwbGFjZWhvbGRlcjogJ1N1YnRpdGxlJywgdG9vbHRpcDogJ1RoZSBzdWIgdGl0bGUgb2YgdGhlIHJlZmVyZW5jZS4nfSxcbiAgICAgICAgICAgIHtuYW1lOiAnYm9va3RpdGxlJywgcGxhY2Vob2xkZXI6ICdCb29rIFRpdGxlJywgdG9vbHRpcDogJ1RoZSB0aXRsZSBvZiB0aGUgYm9vay4nfSxcbiAgICAgICAgICAgIHtuYW1lOiAnb3JnYW5pemF0aW9uJywgcGxhY2Vob2xkZXI6ICdPcmdhbml6YXRpb24nLCB0b29sdGlwOiAnVGhlIG9yZ2FuaXphdGlvbiB0aGF0IG9yZ2FuaXplcyB0aGUgY29uZmVyZW5jZSBvciBwdWJsaXNoZXMgdGhlIHdvcmsuJ30sXG4gICAgICAgICAgICB7bmFtZTogJ2pvdXJuYWwnLCBwbGFjZWhvbGRlcjogJ0pvdXJuYWwnLCB0b29sdGlwOiAnVGhlIGpvdXJuYWwgdGhhdCBwdWJsaXNoZWQgdGhlIGFydGljbGUuJ30sXG4gICAgICAgICAgICB7bmFtZTogJ3B1Ymxpc2hlcicsIHBsYWNlaG9sZGVyOiAnUHVibGlzaGVyJywgdG9vbHRpcDogJ1RoZSBwdWJsaXNoZXIgb2YgdGhlIHdvcmsuJ30sXG4gICAgICAgICAgICB7bmFtZTogJ3NjaG9vbCcsIHBsYWNlaG9sZGVyOiAnU2Nob29sJywgdG9vbHRpcDogJ1RoZSBpbnN0aXR1dGlvbiBpbiB3aGljaCB0aGUgYXV0aG9yIGlzIGVucm9sbGVkLid9LFxuICAgICAgICAgICAge25hbWU6ICdpbnN0aXR1dGlvbicsIHBsYWNlaG9sZGVyOiAnSW5zdGl0dXRpb24nLCB0b29sdGlwOiAnVGhlIGluc3RpdHV0aW9uIHRoYXQgc3BvbnNvcnMgdGhlIHJlc2VhcmNoIHdvcmsuJ30sXG4gICAgICAgICAgICB7bmFtZTogJ2VkaXRvcicsIHBsYWNlaG9sZGVyOiAnRWRpdG9yKHMpJywgdG9vbHRpcDogJ0FsbCBlZGl0b3JzIHNlcGFyYXRlZCBieSB0aGUgd29yZCBcImFuZFwiLiBDb21tYSBpcyB1c2VkIHRvIGRpc3Rpbmd1aXNoIGZpcnN0IGFuZCBsYXN0IG5hbWUuIGUuZyBcIldvbGYsIE9saXZlciBhbmQgQmFybmV0dCwgUGhpbGxpcCd9LFxuICAgICAgICAgICAge25hbWU6ICdzZXJpZXMnLCBwbGFjZWhvbGRlcjogJ1NlcmllcycsIHRvb2x0aXA6ICdUaGUgc2VyaWVzIG5hbWUgb2YgdGhlIGJvb2svd29yayd9LFxuICAgICAgICAgICAge25hbWU6ICd5ZWFyJywgcGxhY2Vob2xkZXI6ICdZZWFyJywgdG9vbHRpcDogJ1RoZSB5ZWFyIG9mIHRoZSBwdWJsaWNhdGlvbiBjb25zaXN0aW5nIG9mIGZvdXIgZGlnaXRzIChlLmcuIFwiMjAyMFwiKS4nfSxcbiAgICAgICAgICAgIHtuYW1lOiAnbW9udGgnLCBwbGFjZWhvbGRlcjogJ01vbnRoJywgdG9vbHRpcDogJ1RoZSBtb250aCBvZiB0aGUgcHVibGljYXRpb24uIFVzZSB0aGUgdGhyZWUgbGV0dGVyIGFiYnJldmlhdGlvbjogSmFuLiBGZWIuIE1hci4gQXByLiBNYXkuIEp1bi4gSnVsLiBBdWcuIFNlcC4gT2N0LiBOb3YuIERlYy4nfSxcbiAgICAgICAgICAgIHtuYW1lOiAnZWRpdGlvbicsIHBsYWNlaG9sZGVyOiAnRWRpdGlvbicsIHRvb2x0aXA6ICdUaGUgZWRpdGlvbiBvZiB0aGUgcHVibGljYXRpb24gKGUuZy4gXCJTZWNvbmRcIikuIFRoZSBmaXJzdCBsZXR0ZXIgc2hvdWxkIGJlIGNhcGl0YWxpemVkLid9LFxuICAgICAgICAgICAge25hbWU6ICd2b2x1bWUnLCBwbGFjZWhvbGRlcjogJ1ZvbHVtZScsIHRvb2x0aXA6ICdUaGUgdm9sdW1lIG9mIHRoZSBwdWJsaWNhdGlvbi4nfSxcbiAgICAgICAgICAgIHtuYW1lOiAnbnVtYmVyJywgcGxhY2Vob2xkZXI6ICdOdW1iZXInLCB0b29sdGlwOiAnVGhlIHdvcmtcXCdzIG51bWJlciB3aXRoaW4gYSBzZXJpZXMuJ30sXG4gICAgICAgICAgICB7bmFtZTogJ2NoYXB0ZXInLCBwbGFjZWhvbGRlcjogJ0NoYXB0ZXInLCB0b29sdGlwOiAnQSBjaGFwdGVyIGlmIHlvdSByZWZlcmVuY2UgdG8gYSBwYXJ0aWN1bGFyIHBhcnQgb2YgdGhlIHdvcmsuJ30sXG4gICAgICAgICAgICB7bmFtZTogJ3BhZ2VzJywgcGxhY2Vob2xkZXI6ICdQYWdlcycsIHRvb2x0aXA6ICdUaGUgcGFnZSBudW1iZXIocykgaWYgeW91IHJlZmVyZW5jZSB0byBhIHBhcnRpY3VsYXIgcGFydCBvZiB0aGUgd29yayAoZS5nLiBcIjIzLTUwXCIgb3IgXCI0MTcsNDIzLDU5MC02MDFcIiBvciA1MCspLid9LFxuICAgICAgICBdLm1hcChmaWVsZCA9PlxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihmaWVsZCwge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogKGRhdGFSZWNvcmRbZmllbGQubmFtZV0gfHwgZmllbGQuZGVmYXVsdFZhbHVlIHx8ICcnKSxcbiAgICAgICAgICAgICAgICBpc0FjdGl2ZTogZnVuY3Rpb24oZm9ybURhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoZmllbGQubmFtZSA9PT0gJ3R5cGUnIHx8IGZpZWxkLm5hbWUgPT09ICdsb29rdXBJZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoIXJlZmVyZW5jZVR5cGVzW2Zvcm1EYXRhLnR5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZihyZWZlcmVuY2VUeXBlc1tmb3JtRGF0YS50eXBlXS5yZXF1aXJlZC5pbmNsdWRlcyhmaWVsZC5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZihyZWZlcmVuY2VUeXBlc1tmb3JtRGF0YS50eXBlXS5vcHRpb25hbC5pbmNsdWRlcyhmaWVsZC5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICB9LFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlZmVyZW5jZTtcbiIsImNvbnN0IHJlZmVyZW5jZVNvdXJjZXNDb25maWcgPSBbXG4gICAgeyBpZCwgZGlzcGxheU5hbWUsIGlzVmFsaWRSZWNvcmQsIHJlbmRlckVudHJ5LCBmaWVsZHMsIHN5bmMgfSA9IHJlcXVpcmUoJy4vem90ZXJvX29ubGluZScpLFxuICAgIHsgaWQsIGRpc3BsYXlOYW1lLCBpc1ZhbGlkUmVjb3JkLCByZW5kZXJFbnRyeSwgZmllbGRzLCBzeW5jIH0gPSByZXF1aXJlKCcuL3pvdGVyb19kZXNrdG9wJylcbl1cblxuYXN5bmMgZnVuY3Rpb24gc2F2ZVJlZmVyZW5jZVNvdXJjZXMoZm9ybURhdGEsIFJlZmVyZW5jZVN0b3JlKSB7XG4gICAgYXdhaXQgUmVmZXJlbmNlU3RvcmUuZGVsZXRlQWxsU291cmNlcygpXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoZm9ybURhdGFbJ3JlZmVyZW5jZS1zb3VyY2VzJ10ubWFwKGFzeW5jIHJzID0+IHtcbiAgICAgICAgYXdhaXQgUmVmZXJlbmNlU3RvcmUuYWRkU291cmNlKHJzKVxuICAgIH0pKVxuXG4gICAgYXdhaXQgUmVmZXJlbmNlU3RvcmUuY2xlYW51cFJlZmVyZW5jZXNGcm9tU291cmNlcygpXG59XG5cbmNvbnN0IHN5bmNBbGxTb3VyY2VzID0gYXN5bmMgZnVuY3Rpb24oUmVmZXJlbmNlU3RvcmUpIHtcbiAgICBjb25zdCByZWZlcmVuY2VTb3VyY2VzID0gYXdhaXQgUmVmZXJlbmNlU3RvcmUuZ2V0QWxsU291cmNlcygpXG5cbiAgICByZWZlcmVuY2VTb3VyY2VzLmZvckVhY2gocmNGb3JtRGF0YSA9PiB7XG4gICAgICAgIGNvbnN0IHJzYyA9IHJlZmVyZW5jZVNvdXJjZXNDb25maWcuZmluZChycyA9PiBycy5pZCA9PT0gcmNGb3JtRGF0YS50eXBlKVxuXG4gICAgICAgIGlmKHJzYyAmJiByc2Muc3luYykge1xuICAgICAgICAgICAgcnNjLnN5bmMocmNGb3JtRGF0YSwgUmVmZXJlbmNlU3RvcmUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnTm8gcmVmZXJlbmNlIHNvdXJjZSBpbXBsZW1lbnRhdGlvbiBmb3IgJyArIHJjRm9ybURhdGEudHlwZSArICcgZm91bmQnKVxuICAgICAgICB9XG4gICAgfSlcbn1cblxuY29uc3QgZ2V0UmVmZXJlbmNlU291cmNlc0ZpZWxkcyA9IGFzeW5jIGZ1bmN0aW9uKFJlZmVyZW5jZVN0b3JlKSB7XG4gICAgY29uc3QgcmVmZXJlbmNlU291cmNlcyA9IGF3YWl0IFJlZmVyZW5jZVN0b3JlLmdldEFsbFNvdXJjZXMoKVxuXG4gICAgcmV0dXJuIFtcbiAgICAgICAge1xuICAgICAgICAgICAgdGFiOiAnUmVmZXJlbmNlIFNvdXJjZXMnLFxuICAgICAgICAgICAgaXNBY3RpdmU6IGZvcm1EYXRhID0+ICFmb3JtRGF0YVsncmVmZXJlbmNlLXNvdXJjZXMnXSB8fCAhZm9ybURhdGFbJ3JlZmVyZW5jZS1zb3VyY2VzJ10ubGVuZ3RoLFxuICAgICAgICAgICAgcmVuZGVyOiAoZWwsIGZvcm1EYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgnaW50ZWdyYXRpb24taW5mbycpO1xuICAgICAgICAgICAgICAgIGVsLmlubmVySFRNTCA9ICdObyBpbnRlZ3JhdGlvbihzKSBjb25maWd1cmVkLiBDbGljayB0aGUgXCJDb25maWd1cmUgTmV3IEludGVncmF0aW9uXCIgYnV0dG9uIGJlbG93IHRvIGRvIHNvLidcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ3JlZmVyZW5jZS1zb3VyY2VzJyxcbiAgICAgICAgICAgIG5ld0J1dHRvbkxhYmVsOiAnQ29uZmlndXJlIE5ldyBSZWZlcmVuY2UgU291cmNlJyxcbiAgICAgICAgICAgIHRhYjogJ1JlZmVyZW5jZSBTb3VyY2VzJyxcbiAgICAgICAgICAgIGlzVmFsaWRSZWNvcmQ6IChmb3JtRGF0YSwgZEZvcm0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByc2MgPSByZWZlcmVuY2VTb3VyY2VzQ29uZmlnLmZpbmQocnMgPT4gcnMuaWQgPT09IGZvcm1EYXRhLnR5cGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJzYyAmJiByc2MuaXNWYWxpZFJlY29yZChmb3JtRGF0YSwgZEZvcm0sIFJlZmVyZW5jZVN0b3JlKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbmRlckVudHJ5OiAoZm9ybURhdGEsIGRGb3JtKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcnNjID0gcmVmZXJlbmNlU291cmNlc0NvbmZpZy5maW5kKHJzID0+IHJzLmlkID09PSBmb3JtRGF0YS50eXBlKVxuICAgICAgICAgICAgICAgIHJldHVybiByc2MgJiYgcnNjLnJlbmRlckVudHJ5KGZvcm1EYXRhLCBkRm9ybSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IHJlZmVyZW5jZVNvdXJjZXMsXG4gICAgICAgICAgICBvbkNoYW5nZTogZm9ybURhdGEgPT4gc2F2ZVJlZmVyZW5jZVNvdXJjZXMoZm9ybURhdGEsIFJlZmVyZW5jZVN0b3JlKSxcbiAgICAgICAgICAgIGFycmF5T2Y6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd0eXBlJyxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheU5hbWU6ICdTb3VyY2U6JyxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dlZFZhbHVlczogcmVmZXJlbmNlU291cmNlc0NvbmZpZy5tYXAoaSA9PiBbaS5pZCwgaS5kaXNwbGF5TmFtZV0pLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLi4ucmVmZXJlbmNlU291cmNlc0NvbmZpZy5mbGF0TWFwKGkgPT4gaS5maWVsZHMpXG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICBdXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGdldFJlZmVyZW5jZVNvdXJjZXNGaWVsZHMsXG4gICAgc3luY0FsbFNvdXJjZXNcbn0iLCJjb25zdCB0aHJvdHRsZSA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi90aHJvdHRsZS90aHJvdHRsZScpXG5cbmNvbnN0IHRyYW5zZm9ybVJlc3BvbnNlSXRlbSA9IGZ1bmN0aW9uKGl0ZW0sIGxpYnJhcnlJRCwgQ29sbGVjdGlvbklEKSB7XG4gICAgY29uc3QgdHlwZU1hcCA9IHtcbiAgICAgICAgJ2FydGljbGUtam91cm5hbCc6ICdBcnRpY2xlJyxcbiAgICAgICAgJ2FydGljbGUnOiAnQXJ0aWNsZScsXG4gICAgICAgICdhcnRpY2xlLW1hZ2F6aW5lJzogJ0FydGljbGUnLFxuICAgICAgICAnYXJ0aWNsZS1uZXdzcGFwZXInOiAnQXJ0aWNsZScsXG4gICAgICAgICdiaWxsJzogJ0FydGljbGUnLFxuICAgICAgICAnYm9vayc6ICdCb29rJyxcbiAgICAgICAgJ2Jyb2FkY2FzdCc6ICdBcnRpY2xlJyxcbiAgICAgICAgJ2NoYXB0ZXInOiAnSW5ib29rJyxcbiAgICAgICAgJ2NsYXNzaWMnOiAnQXJ0aWNsZScsXG4gICAgICAgICdjb2xsZWN0aW9uJzogJ0FydGljbGUnLFxuICAgICAgICAnZGF0YXNldCc6ICdBcnRpY2xlJyxcbiAgICAgICAgJ2RvY3VtZW50JzogJ0FydGljbGUnLFxuICAgICAgICAnZW50cnknOiAnQXJ0aWNsZScsXG4gICAgICAgICdlbnRyeS1kaWN0aW9uYXJ5JzogJ0FydGljbGUnLFxuICAgICAgICAnZW50cnktZW5jeWNsb3BlZGlhJzogJ1dlYnNpdGUnLFxuICAgICAgICAnZXZlbnQnOiAnQXJ0aWNsZScsXG4gICAgICAgICdmaWd1cmUnOiAnQXJ0aWNsZScsXG4gICAgICAgICdncmFwaGljJzogJ0FydGljbGUnLFxuICAgICAgICAnaGVhcmluZyc6ICdBcnRpY2xlJyxcbiAgICAgICAgJ2ludGVydmlldyc6ICdBcnRpY2xlJyxcbiAgICAgICAgJ2xlZ2FsX2Nhc2UnOiAnQXJ0aWNsZScsXG4gICAgICAgICdsZWdpc2xhdGlvbic6ICdBcnRpY2xlJyxcbiAgICAgICAgJ21hbnVzY3JpcHQnOiAnQXJ0aWNsZScsXG4gICAgICAgICdtYXAnOiAnQXJ0aWNsZScsXG4gICAgICAgICdtb3Rpb25fcGljdHVyZSc6ICdBcnRpY2xlJyxcbiAgICAgICAgJ211c2ljYWxfc2NvcmUnOiAnQXJ0aWNsZScsXG4gICAgICAgICdwYW1waGxldCc6ICdBcnRpY2xlJyxcbiAgICAgICAgJ3BhcGVyLWNvbmZlcmVuY2UnOiAnQ29uZmVyZW5jZS9JbnByb2NlZWRpbmdzJyxcbiAgICAgICAgJ3BhdGVudCc6ICdBcnRpY2xlJyxcbiAgICAgICAgJ3BlcmZvcm1hbmNlJzogJ0FydGljbGUnLFxuICAgICAgICAncGVyaW9kaWNhbCc6ICdBcnRpY2xlJyxcbiAgICAgICAgJ3BlcnNvbmFsX2NvbW11bmljYXRpb24nOiAnQXJ0aWNsZScsXG4gICAgICAgICdwb3N0JzogJ1dlYnNpdGUnLFxuICAgICAgICAncG9zdC13ZWJsb2cnOiAnV2Vic2l0ZScsXG4gICAgICAgICdyZWd1bGF0aW9uJzogJ0FydGljbGUnLFxuICAgICAgICAncmVwb3J0JzogJ0FydGljbGUnLFxuICAgICAgICAncmV2aWV3JzogJ0FydGljbGUnLFxuICAgICAgICAncmV2aWV3LWJvb2snOiAnQXJ0aWNsZScsXG4gICAgICAgICdzb2Z0d2FyZSc6ICdBcnRpY2xlJyxcbiAgICAgICAgJ3NvbmcnOiAnQXJ0aWNsZScsXG4gICAgICAgICdzcGVlY2gnOiAnQXJ0aWNsZScsXG4gICAgICAgICdzdGFuZGFyZCc6ICdBcnRpY2xlJyxcbiAgICAgICAgJ3RoZXNpcyc6ICdNYXN0ZXJzdGhlc2lzJyxcbiAgICAgICAgJ3RyZWF0eSc6ICdBcnRpY2xlJyxcbiAgICAgICAgJ3dlYnBhZ2UnOiAnV2Vic2l0ZSdcbiAgICB9XG5cbiAgICBjb25zdCBjb252ZXJ0TmFtZVZhbHVlID0gbmFtZUVudHJ5ID0+IHtcbiAgICAgICAgcmV0dXJuIFtuYW1lRW50cnkuZmFtaWx5LCBuYW1lRW50cnkuZ2l2ZW5dXG4gICAgICAgICAgICAuZmlsdGVyKGYgPT4gZiAmJiBmLnRyaW0pXG4gICAgICAgICAgICAubWFwKGYgPT4gZi50cmltKCkpXG4gICAgICAgICAgICAuZmlsdGVyKGYgPT4gZiAhPT0gJycpXG4gICAgICAgICAgICAuam9pbignLCAnKVxuICAgIH1cblxuICAgIGNvbnN0IHRyeVRvUGFyc2VEYXRlID0gZGF0ZVBhcnRzID0+IHtcbiAgICAgICAgaWYoZGF0ZVBhcnRzICYmIGRhdGVQYXJ0c1snZGF0ZS1wYXJ0cyddICYmIGRhdGVQYXJ0c1snZGF0ZS1wYXJ0cyddWzBdKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0ZVBhcnRzWydkYXRlLXBhcnRzJ11bMF0uam9pbignLScpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB0cnlUb1BhcnNlWWVhciA9IGRhdGVQYXJ0cyA9PiB7XG4gICAgICAgIGlmKGRhdGVQYXJ0cyAmJiBkYXRlUGFydHNbJ2RhdGUtcGFydHMnXSAmJiBkYXRlUGFydHNbJ2RhdGUtcGFydHMnXVswXSAmJiBkYXRlUGFydHNbJ2RhdGUtcGFydHMnXVswXVswXSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGVQYXJ0c1snZGF0ZS1wYXJ0cyddWzBdWzBdLnRvU3RyaW5nKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHRyeVRvUGFyc2VNb250aCA9IGRhdGVQYXJ0cyA9PiB7XG4gICAgICAgIGlmKGRhdGVQYXJ0cyAmJiBkYXRlUGFydHNbJ2RhdGUtcGFydHMnXSAmJiBkYXRlUGFydHNbJ2RhdGUtcGFydHMnXVswXSAmJiBkYXRlUGFydHNbJ2RhdGUtcGFydHMnXVswXVsxXSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGVQYXJ0c1snZGF0ZS1wYXJ0cyddWzBdWzFdLnRvU3RyaW5nKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGxvb2t1cElkOiBpdGVtLklTQk4gfHwgaXRlbS5ET0ksXG4gICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICB0eXBlOiB0eXBlTWFwW2l0ZW0udHlwZV0gfHwgJ0FydGljbGUnLFxuICAgICAgICByZWZlcmVuY2VTb3VyY2U6IGB6b3Rlcm8tZGVza3RvcC0ke2xpYnJhcnlJRH0tJHtDb2xsZWN0aW9uSUR9YCxcbiAgICAgICAgdGl0bGU6IGl0ZW0udGl0bGUsXG4gICAgICAgIGF1dGhvcjogaXRlbS5hdXRob3IgJiYgaXRlbS5hdXRob3IubWFwKGNvbnZlcnROYW1lVmFsdWUpLmpvaW4oJyBhbmQgJyksXG4gICAgICAgIHBhZ2VzOiBpdGVtWydudW1iZXItb2YtcGFnZXMnXSxcbiAgICAgICAgdm9sdW1lOiBpdGVtLnZhbHVtZSxcbiAgICAgICAgdXJsOiBpdGVtLlVSTCxcbiAgICAgICAgcHVibGlzaGVyOiBpdGVtLnB1Ymxpc2hlcixcbiAgICAgICAgZWRpdGlvbjogaXRlbS5lZGl0aW9uLFxuICAgICAgICBkYXRlOiB0cnlUb1BhcnNlRGF0ZShpdGVtLmFjY2Vzc2VkKSxcbiAgICAgICAgeWVhcjogdHJ5VG9QYXJzZVllYXIoaXRlbS5pc3N1ZWQpLFxuICAgICAgICBtb250aDogdHJ5VG9QYXJzZU1vbnRoKGl0ZW0uaXNzdWVkKSxcbiAgICAgICAgZWRpdG9yOiBpdGVtLmVkaXRvciAmJiBpdGVtLmVkaXRvci5tYXAoY29udmVydE5hbWVWYWx1ZSkuam9pbignIGFuZCAnKSxcbiAgICB9XG59XG5cbmNvbnN0IHJlbmRlckVudHJ5ID0gZnVuY3Rpb24oZW50cnkpIHtcbiAgICBpZihlbnRyeS50eXBlID09PSAnem90ZXJvLWRlc2t0b3AnKSB7XG4gICAgICAgIHJldHVybiBgWm90ZXJvIERlc3Rrb3BgXG4gICAgfVxufVxuXG5jb25zdCBpc1ZhbGlkUmVjb3JkID0gdGhyb3R0bGUoMTAwLCBhc3luYyBmdW5jdGlvbihmb3JtRGF0YSwgZEZyb20sIFJlZmVyZW5jZVN0b3JlKSB7XG4gICAgd2luZG93LnN0b3JlID0gUmVmZXJlbmNlU3RvcmVcbiAgICBpZihmb3JtRGF0YS50eXBlID09PSAnem90ZXJvLWRlc2t0b3AnICYmIGZvcm1EYXRhWyd6b3Rlcm8tZGVza3RvcC1saWJyYXJ5SUQnXSkge1xuICAgICAgICB2YXIgaXRlbVJlc3BvbnNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZEZyb20uc2V0VG9vbHRpcCgnem90ZXJvLWRlc2t0b3AtbGlicmFyeUlEJywgJ1dhaXQgZm9yIGl0IC4uLicsICcnLCAndG9vbHRpcC1sb2FkaW5nJylcbiAgICAgICAgICAgIGRGcm9tLnNldFRvb2x0aXAoJ3pvdGVyby1kZXNrdG9wLWNvbGxlY3Rpb25JRCcsICdXYWl0IGZvciBpdCAuLi4nLCAnJywgJ3Rvb2x0aXAtbG9hZGluZycpXG5cbiAgICAgICAgICAgIGlmKGZvcm1EYXRhWyd6b3Rlcm8tZGVza3RvcC1jb2xsZWN0aW9uSUQnXSA9PT0gJ25vLWNvbGxlY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaXRlbVJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYGh0dHA6Ly8xMjcuMC4wLjE6MjMxMTkvYmV0dGVyLWJpYnRleC9leHBvcnQvbGlicmFyeT8vJHtmb3JtRGF0YVsnem90ZXJvLWRlc2t0b3AtbGlicmFyeUlEJ119L2xpYnJhcnkuY3NsanNvbmApXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZW1SZXNwb25zZSA9IGF3YWl0IGZldGNoKGBodHRwOi8vMTI3LjAuMC4xOjIzMTE5L2JldHRlci1iaWJ0ZXgvY29sbGVjdGlvbj8vJHtmb3JtRGF0YVsnem90ZXJvLWRlc2t0b3AtbGlicmFyeUlEJ119LyR7Zm9ybURhdGFbJ3pvdGVyby1kZXNrdG9wLWNvbGxlY3Rpb25JRCddfS5jc2xqc29uYClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBhd2FpdCBpdGVtUmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAgICAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIFJlZmVyZW5jZVN0b3JlLnNldChgem90ZXJvLWRlc2t0b3AtaXRlbS0ke2Zvcm1EYXRhWyd6b3Rlcm8tZGVza3RvcC1saWJyYXJ5SUQnXX0tJHtmb3JtRGF0YVsnem90ZXJvLWRlc2t0b3AtY29sbGVjdGlvbklEJ119LSR7aXRlbS5pZH1gLCB0cmFuc2Zvcm1SZXNwb25zZUl0ZW0oaXRlbSwgZm9ybURhdGFbJ3pvdGVyby1kZXNrdG9wLWxpYnJhcnlJRCddLCBmb3JtRGF0YVsnem90ZXJvLWRlc2t0b3AtY29sbGVjdGlvbklEJ10pKVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgZEZyb20ucmVzZXRUb29sdGlwcyhbJ3pvdGVyby1kZXNrdG9wLWxpYnJhcnlJRCcsICd6b3Rlcm8tZGVza3RvcC1jb2xsZWN0aW9uSUQnXSlcblxuICAgICAgICAgICAgY29uc3QgaGludEZpZWxkID0gZm9ybURhdGFbJ3pvdGVyby1kZXNrdG9wLWNvbGxlY3Rpb25JRCddID09PSAnbm8tY29sbGVjdGlvbicgPyAnem90ZXJvLWRlc2t0b3AtbGlicmFyeUlEJyA6ICd6b3Rlcm8tZGVza3RvcC1jb2xsZWN0aW9uSUQnXG4gICAgICAgICAgICBjb25zdCBoaW50RmllbGRUeXBlID0gZm9ybURhdGFbJ3pvdGVyby1kZXNrdG9wLWNvbGxlY3Rpb25JRCddID09PSAnbm8tY29sbGVjdGlvbicgPyAnbGlicmFyeScgOiAnY29sbGVjdGlvbidcblxuICAgICAgICAgICAgaWYoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRGcm9tLnNldFRvb2x0aXBXYXJuaW5nKGhpbnRGaWVsZCwgYE5vIGl0ZW1zIGZvdW5kIGluIHRoaXMgJHtoaW50RmllbGRUeXBlfSFgKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkRnJvbS5zZXRUb29sdGlwU3VjY2VzcyhoaW50RmllbGQsIGAke2l0ZW1zLmxlbmd0aH0gaXRlbXMgZm91bmQuYClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgICAgICAgIGRGcm9tLnNldFRvb2x0aXBFcnJvcignem90ZXJvLWRlc2t0b3AtbGlicmFyeUlEJywgYFNvbWV0aGluZyB3ZW50IHdyb25nIGZldGNoaW5nIGl0ZW1zIGZyb20gWm90ZXJvLmApXG4gICAgICAgICAgICBkRnJvbS5zZXRUb29sdGlwRXJyb3IoJ3pvdGVyby1kZXNrdG9wLWNvbGxlY3Rpb25JRCcsIGBTb21ldGhpbmcgd2VudCB3cm9uZyBmZXRjaGluZyBpdGVtcyBmcm9tIFpvdGVyby5gKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG59KVxuXG5jb25zdCBzeW5jID0gYXN5bmMgZnVuY3Rpb24oZm9ybURhdGEsIFJlZmVyZW5jZVN0b3JlKSB7XG4gICAgaWYoZm9ybURhdGEudHlwZSA9PT0gJ3pvdGVyby1kZXNrdG9wJyAmJiBmb3JtRGF0YVsnem90ZXJvLWRlc2t0b3AtbGlicmFyeUlEJ10pIHtcbiAgICAgICAgdmFyIGl0ZW1SZXNwb25zZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmKGZvcm1EYXRhWyd6b3Rlcm8tZGVza3RvcC1jb2xsZWN0aW9uSUQnXSA9PT0gJ25vLWNvbGxlY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaXRlbVJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYGh0dHA6Ly8xMjcuMC4wLjE6MjMxMTkvYmV0dGVyLWJpYnRleC9leHBvcnQvbGlicmFyeT8vJHtmb3JtRGF0YVsnem90ZXJvLWRlc2t0b3AtbGlicmFyeUlEJ119L2xpYnJhcnkuY3NsanNvbmApXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZW1SZXNwb25zZSA9IGF3YWl0IGZldGNoKGBodHRwOi8vMTI3LjAuMC4xOjIzMTE5L2JldHRlci1iaWJ0ZXgvY29sbGVjdGlvbj8vJHtmb3JtRGF0YVsnem90ZXJvLWRlc2t0b3AtbGlicmFyeUlEJ119LyR7Zm9ybURhdGFbJ3pvdGVyby1kZXNrdG9wLWNvbGxlY3Rpb25JRCddfS5jc2xqc29uYClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBhd2FpdCBpdGVtUmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAgICAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIFJlZmVyZW5jZVN0b3JlLnNldChgem90ZXJvLWRlc2t0b3AtaXRlbS0ke2Zvcm1EYXRhWyd6b3Rlcm8tZGVza3RvcC1saWJyYXJ5SUQnXX0tJHtmb3JtRGF0YVsnem90ZXJvLWRlc2t0b3AtY29sbGVjdGlvbklEJ119LSR7aXRlbS5pZH1gLCB0cmFuc2Zvcm1SZXNwb25zZUl0ZW0oaXRlbSwgZm9ybURhdGFbJ3pvdGVyby1kZXNrdG9wLWxpYnJhcnlJRCddLCBmb3JtRGF0YVsnem90ZXJvLWRlc2t0b3AtY29sbGVjdGlvbklEJ10pKVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBmZXRjaExpYnJhcmllcyA9IHRocm90dGxlKDEwMCwgYXN5bmMgZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3BvbnNlO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgaHR0cDovL2xvY2FsaG9zdDoyMzExOS9iZXR0ZXItYmlidGV4L2pzb24tcnBjYCwge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGpzb25ycGM6IFwiMi4wXCIsIG1ldGhvZDogXCJ1c2VyLmdyb3Vwc1wiLCBwYXJhbXM6IFt0cnVlXSB9KSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgICAgdGhyb3cgeyBtZXNzYWdlOiAnTWFrZSBzdXJlIHlvdSBoYXZlIHN0YXJ0ZXQgdGhlIFpvdGVybyBkZXNrdG9wIGFwcCcgfVxuICAgIH1cblxuICAgIGlmKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgIHRocm93IHsgbWVzc2FnZTogJ01ha2Ugc3VyZSB5b3UgaGF2ZSB0aGUgXCJCZXR0ZXIgQmliVGVYIGZvciBab3Rlcm9cIiBhZGQtb24gaW5zdGFsbGVkIGluIFpvdGVyby4gWW91IGNhbiBkb3dubG9hZCBpdCBoZXJlOiBodHRwczovL3JldG9ycXVlLnJlL3pvdGVyby1iZXR0ZXItYmlidGV4L2luc3RhbGxhdGlvbi8nIH1cbiAgICB9IGVsc2UgaWYocmVzcG9uc2Uuc3RhdHVzID09PSA1MDApIHtcbiAgICAgICAgdGhyb3cgeyBtZXNzYWdlOiAnTWFrZSBzdXJlIHlvdSBoYXZlIGF0IGxlYXN0IHZlcnNpb24gPGI+Ni43LjE8L2I+IG9mIFwiQmV0dGVyIEJpYlRlWCBmb3IgWm90ZXJvXCIgaW5zdGFsbGVkLiBZb3UgY2FuIGRvd25sb2FkIGl0IGhlcmU6IGh0dHBzOi8vcmV0b3JxdWUucmUvem90ZXJvLWJldHRlci1iaWJ0ZXgvaW5zdGFsbGF0aW9uLycgfVxuICAgIH1cblxuICAgIGlmKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgIHRocm93IHsgbWVzc2FnZTogJ1NvbWV0aGluZyB3ZW50IHdyb25nIGZldGNoaW5nIGl0ZW1zIGZyb20gWm90ZXJvJyB9XG4gICAgfVxuXG4gICAgdmFyIGpzb25SZXNwb25zZSA9IChhd2FpdCByZXNwb25zZS5qc29uKCkpXG5cbiAgICBpZighanNvblJlc3BvbnNlLnJlc3VsdCkge1xuICAgICAgICB0aHJvdyB7IG1lc3NhZ2U6ICdTb21ldGhpbmcgd2VudCB3cm9uZyBmZXRjaGluZyBpdGVtcyBmcm9tIFpvdGVyby4gUGxlYXNlIHNlbmQgdGhlIGZvbGxvd2luZyBlcnJvciB0ZXN0IHRvIGluZm9AbW9uc3RlcndyaXRlci5hcHA6ICcgKyBKU09OLnN0cmluZ2lmeShqc29uUmVzcG9uc2UuZXJyb3IpIH1cbiAgICB9XG5cbiAgICBpZihqc29uUmVzcG9uc2UucmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyB7IG1lc3NhZ2U6ICdObyBsaWJyYXJpZXMgYXZhaWxhYmxlIScgfVxuICAgIH1cblxuICAgIHJldHVybiBqc29uUmVzcG9uc2UucmVzdWx0XG59KVxuXG5jb25zdCBvblZhbHVlc0NhbGN1bGF0aW9uRmFpbGVkTWVzc2FnZSA9IGZ1bmN0aW9uKGZyb21EYXRhLCBlcnIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZXZlbDogZXJyLmxldmVsIHx8ICdlcnJvcicsXG4gICAgICAgIHRleHQ6IGVyci5tZXNzYWdlIHx8ICdTb21ldGhpbmcgd2VudCB3cm9uZyBmZXRjaGluZyBpdGVtcyBmcm9tIFpvdGVyby4nXG4gICAgfVxufVxuXG5jb25zdCBmaWVsZHMgPSBbXG4gICAge1xuICAgICAgICBuYW1lOiAnem90ZXJvLWRlc2t0b3AtbGlicmFyeUlEJyxcbiAgICAgICAgZGlzcGxheU5hbWU6ICdMaWJyYXJ5JyxcbiAgICAgICAgdG9vbHRpcDogJ0Nob29zZSBhIGxpYnJhcnkgZnJvbSB5b3VyIGxvY2FsIFpvdGVybyBpbnN0YWxsYXRpb24nLFxuICAgICAgICBpc0FjdGl2ZTogZm9ybURhdGEgPT4gZm9ybURhdGFbJ3R5cGUnXSA9PT0gJ3pvdGVyby1kZXNrdG9wJyxcbiAgICAgICAgb25WYWx1ZXNDYWxjdWxhdGlvbkZhaWxlZE1lc3NhZ2UsXG4gICAgICAgIGFsbG93ZWRWYWx1ZXM6IGFzeW5jICgpID0+IChhd2FpdCBmZXRjaExpYnJhcmllcygpKS5tYXAobGliID0+IFtsaWIuaWQsIGxpYi5uYW1lXSksXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICd6b3Rlcm8tZGVza3RvcC1jb2xsZWN0aW9uSUQnLFxuICAgICAgICBkaXNwbGF5TmFtZTogJ0NvbGxlY3Rpb24nLFxuICAgICAgICByZWxvYWRPbkNoYW5nZU9mOiBbJ3pvdGVyby1kZXNrdG9wLWxpYnJhcnlJRCddLFxuICAgICAgICB0b29sdGlwOiAnQ2hvb3NlIGEgY29sbGVjdGlvbiBmcm9tIHlvdXIgbG9jYWwgWm90ZXJvIGluc3RhbGxhdGlvbicsXG4gICAgICAgIGlzQWN0aXZlOiBmb3JtRGF0YSA9PiBmb3JtRGF0YVsndHlwZSddID09PSAnem90ZXJvLWRlc2t0b3AnLFxuICAgICAgICBkZWZhdWx0VmFsdWU6ICduby1jb2xsZWN0aW9uJyxcbiAgICAgICAgb25WYWx1ZXNDYWxjdWxhdGlvbkZhaWxlZE1lc3NhZ2UsXG4gICAgICAgIGFsbG93ZWRWYWx1ZXM6IGFzeW5jIGZvcm1EYXRhID0+IHtcbiAgICAgICAgICAgIGlmKCFmb3JtRGF0YVsnem90ZXJvLWRlc2t0b3AtbGlicmFyeUlEJ10pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB7IG1lc3NhZ2U6ICdDaG9vc2UgYSBsaWJyYXJ5IGZpcnN0IScgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbGlicmFyaWVzID0gYXdhaXQgZmV0Y2hMaWJyYXJpZXMoKVxuICAgICAgICAgICAgdmFyIGxpYnJhcnkgPSBsaWJyYXJpZXMuZmluZChsaWIgPT4gbGliLmlkLnRvU3RyaW5nKCkgPT09IGZvcm1EYXRhWyd6b3Rlcm8tZGVza3RvcC1saWJyYXJ5SUQnXSlcblxuICAgICAgICAgICAgaWYoIWxpYnJhcnkuY29sbGVjdGlvbnMgfHwgIWxpYnJhcnkuY29sbGVjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgeyBtZXNzYWdlOiAnTm8gY29sbGVjdGlvbnMgYXZhaWxhYmxlIGluIHRoZSBjaG9vc2VuIGxpYnJhcnkhJyB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgWyduby1jb2xsZWN0aW9uJywgJ0VudGlyZSBMaWJyYXJ5J10sXG4gICAgICAgICAgICAgICAgLi4ubGlicmFyeS5jb2xsZWN0aW9ucy5tYXAoY29sID0+IFsgY29sLmtleSwgY29sLm5hbWUgXSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICB9XG5dXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGlkOiAnem90ZXJvLWRlc2t0b3AnLFxuICAgIGRpc3BsYXlOYW1lOiAnWm90ZXJvIChEZXNrdG9wIHZpYSBCZXR0ZXIgQmliVGVYIEFkZC1PbiknLFxuICAgIGlzVmFsaWRSZWNvcmQsXG4gICAgcmVuZGVyRW50cnksXG4gICAgZmllbGRzLFxuICAgIHN5bmNcbn0iLCJjb25zdCB0aHJvdHRsZSA9IHJlcXVpcmUoJy4vLi4vLi4vLi4vbGliL3Rocm90dGxlL3Rocm90dGxlJylcbmNvbnN0IHsgWm90ZXJvT25saW5lIH0gPSByZXF1aXJlKCcuLy4uLy4uLy4uL2xpYi96b3Rlcm8tY2xpZW50JylcbnZhciBsYXRlc3RMb2FkZWRHcm91cHMgPSBbXSwgY2xpZW50c1dpdGhvdXRTdG9yZSA9IHt9XG5cbmNvbnN0IGlzVmFsaWRSZWNvcmQgPSB0aHJvdHRsZSgxMDAsIGFzeW5jIGZ1bmN0aW9uKGZvcm1EYXRhLCBkRnJvbSwgUmVmZXJlbmNlU3RvcmUpIHtcbiAgICBpZihmb3JtRGF0YS50eXBlID09PSAnem90ZXJvLW9ubGluZScpIHtcbiAgICAgICAgY29uc3QgaXNHcm91cCA9IGZvcm1EYXRhWyd6b3Rlcm8tb25saW5lLXVzZXJPckdyb3VwJ10gPT09ICdncm91cCdcblxuICAgICAgICBpZihmb3JtRGF0YVsnem90ZXJvLW9ubGluZS1hcGlLZXknXS50cmltKCkgPT09ICcnKSB7XG4gICAgICAgICAgICBkRnJvbS5zZXRUb29sdGlwV2FybmluZygnem90ZXJvLW9ubGluZS1hcGlLZXknLCAnQW4gWm90ZXJvIEFQSSBrZXkgaXMgbmVlZGVkLiBZb3UgY2FuIGNyZWF0ZSBhbiBBUEkga2V5IGhlcmU6IGh0dHBzOi8vd3d3LnpvdGVyby5vcmcvc2V0dGluZ3Mva2V5cycpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGlzR3JvdXAgJiYgZm9ybURhdGFbJ3pvdGVyby1vbmxpbmUtZ3JvdXBJRCddID09PSAnJykge1xuICAgICAgICAgICAgZEZyb20uc2V0VG9vbHRpcFdhcm5pbmcoJ3pvdGVyby1vbmxpbmUtZ3JvdXBJRCcsICdDaG9vc2UgYSBncm91cCBmcm9tIHdoaWNoIHlvdSB3YW50IHRvIHJldHJpZXZlIHJlZmVyZW5jZXMgZnJvbS4gSWYgeW91IGRvIG5vdCB3YW50IHRvIHJldHJpZXZlIHJlZmVyZW5jZXMgZnJvbSBhIFpvdGVybyBncm91cCBjaG9vc2UgXCJVc2VyXCIgaW4gXCJVc2VyIG9yIEdyb3VwIFNjb3BlZCBJbnRlZ3JhdGlvblwiJylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRGcm9tLnNldFRvb2x0aXAoJ3pvdGVyby1vbmxpbmUtYXBpS2V5JywgJ1dhaXQgZm9yIGl0IC4uLicsICcnLCAndG9vbHRpcC1sb2FkaW5nJylcblxuICAgICAgICAgICAgY29uc3Qgem90ZXJvT25saW5lQ2xpZW50ID0gbmV3IFpvdGVyb09ubGluZShmb3JtRGF0YVsnem90ZXJvLW9ubGluZS1hcGlLZXknXSwgUmVmZXJlbmNlU3RvcmUpXG4gICAgICAgICAgICBhd2FpdCB6b3Rlcm9PbmxpbmVDbGllbnQubG9hZFVzZXJJbmZvKClcblxuICAgICAgICAgICAgY29uc3QgaXRlbUNvdW50ID0gKGlzR3JvdXAgP1xuICAgICAgICAgICAgICAgIGF3YWl0IHpvdGVyb09ubGluZUNsaWVudC5pdGVtc0J5R3JvdXBJRChmb3JtRGF0YVsnem90ZXJvLW9ubGluZS1ncm91cElEJ10pIDpcbiAgICAgICAgICAgICAgICBhd2FpdCB6b3Rlcm9PbmxpbmVDbGllbnQuaXRlbXMoKSkubGVuZ3RoXG5cbiAgICAgICAgICAgIGRGcm9tLnJlc2V0VG9vbHRpcHMoWyd6b3Rlcm8tb25saW5lLWdyb3VwSUQnLCAnem90ZXJvLW9ubGluZS1hcGlLZXknXSlcblxuICAgICAgICAgICAgaWYoaXRlbUNvdW50KSB7XG4gICAgICAgICAgICAgICAgZEZyb20uc2V0VG9vbHRpcFN1Y2Nlc3MoJ3pvdGVyby1vbmxpbmUtYXBpS2V5JywgYCR7aXRlbUNvdW50fSBpdGVtcyBoYXZlIGJlZW4gZmV0Y2hlZCBmcm9tIFpvdGVyb2ApXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRGcm9tLnNldFRvb2x0aXBXYXJuaW5nKCd6b3Rlcm8tb25saW5lLWFwaUtleScsICdJdCBzZWVtcyBsaWtlIHRoaXMgdXNlciBvciBncm91cCBkb2VzIG5vdCBoYXMgYW55IGl0ZW1zIHNhdmVkJylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycilcbiAgICAgICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGBUaGVyZSB3YXMgYW4gZXJyb3IgY29ubmVjdGluZyB0byBab3Rlcm8uIE1ha2Ugc3VyZSAke2lzR3JvdXAgPyAnR3JvdXAnIDogJ1VzZXInfSBJRCBhbmQgQVBJIEtleSBhcmUgY29ycmVjdCFgXG4gICAgICAgICAgICBkRnJvbS5zZXRUb29sdGlwRXJyb3IoJ3pvdGVyby1vbmxpbmUtYXBpS2V5JywgZXJyb3JUZXh0KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG59KVxuXG5jb25zdCBzeW5jID0gYXN5bmMgZnVuY3Rpb24oZm9ybURhdGEsIFJlZmVyZW5jZVN0b3JlKSB7XG4gICAgaWYoZm9ybURhdGEudHlwZSA9PT0gJ3pvdGVyby1vbmxpbmUnKSB7XG4gICAgICAgIGNvbnN0IGlzR3JvdXAgPSBmb3JtRGF0YVsnem90ZXJvLW9ubGluZS11c2VyT3JHcm91cCddID09PSAnZ3JvdXAnXG5cbiAgICAgICAgaWYoZm9ybURhdGFbJ3pvdGVyby1vbmxpbmUtYXBpS2V5J10udHJpbSgpID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBpZihpc0dyb3VwICYmIGZvcm1EYXRhWyd6b3Rlcm8tb25saW5lLWdyb3VwSUQnXSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHpvdGVyb09ubGluZUNsaWVudCA9IG5ldyBab3Rlcm9PbmxpbmUoZm9ybURhdGFbJ3pvdGVyby1vbmxpbmUtYXBpS2V5J10sIFJlZmVyZW5jZVN0b3JlKVxuICAgICAgICAgICAgYXdhaXQgem90ZXJvT25saW5lQ2xpZW50LmxvYWRVc2VySW5mbygpXG5cbiAgICAgICAgICAgIGlmKGlzR3JvdXApIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB6b3Rlcm9PbmxpbmVDbGllbnQuaXRlbXNCeUdyb3VwSUQoZm9ybURhdGFbJ3pvdGVyby1vbmxpbmUtZ3JvdXBJRCddKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB6b3Rlcm9PbmxpbmVDbGllbnQuaXRlbXMoKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZXJyKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IGdldENsaWVudFdpdGhvdXRTdG9yZSA9IGFzeW5jIGZ1bmN0aW9uKGFwaUtleSkge1xuICAgIGlmKCFjbGllbnRzV2l0aG91dFN0b3JlW2FwaUtleV0pIHtcbiAgICAgICAgY2xpZW50c1dpdGhvdXRTdG9yZVthcGlLZXldID0gW11cbiAgICAgICAgY2xpZW50c1dpdGhvdXRTdG9yZVthcGlLZXldWzBdID0gbmV3IFpvdGVyb09ubGluZShhcGlLZXkpXG4gICAgICAgIGNsaWVudHNXaXRob3V0U3RvcmVbYXBpS2V5XVsxXSA9IGNsaWVudHNXaXRob3V0U3RvcmVbYXBpS2V5XVswXS5sb2FkVXNlckluZm8oKVxuICAgIH1cblxuICAgIGF3YWl0IGNsaWVudHNXaXRob3V0U3RvcmVbYXBpS2V5XVsxXVxuXG4gICAgcmV0dXJuIGNsaWVudHNXaXRob3V0U3RvcmVbYXBpS2V5XVswXVxufVxuXG5jb25zdCByZW5kZXJFbnRyeSA9IGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgaWYoZW50cnkudHlwZSA9PT0gJ3pvdGVyby1vbmxpbmUnKSB7XG4gICAgICAgIGNvbnN0IGlzR3JvdXAgPSBlbnRyeVsnem90ZXJvLW9ubGluZS11c2VyT3JHcm91cCddID09PSAnZ3JvdXAnXG4gICAgICAgIGNvbnN0IHVzZXJPckdyb3VwID0gZW50cnlbJ3pvdGVyby1vbmxpbmUtdXNlck9yR3JvdXAnXS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGVudHJ5Wyd6b3Rlcm8tb25saW5lLXVzZXJPckdyb3VwJ10uc2xpY2UoMSlcbiAgICAgICAgdmFyIGRpc3BsYXlOYW1lID0gJydcblxuICAgICAgICBpZighaXNHcm91cCkge1xuICAgICAgICAgICAgZGlzcGxheU5hbWUgPSBlbnRyeVsnem90ZXJvLW9ubGluZS11c2VyTmFtZSddXG4gICAgICAgIH0gZWxzZSBpZihpc0dyb3VwKSB7XG4gICAgICAgICAgICBkaXNwbGF5TmFtZSA9IGVudHJ5Wyd6b3Rlcm8tb25saW5lLWdyb3VwTmFtZSddXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYFpvdGVyby5vcmcgKE9ubGluZSkgLSAke3VzZXJPckdyb3VwfTogJHtkaXNwbGF5TmFtZX1gXG4gICAgfVxufVxuXG5jb25zdCBmaWVsZHMgPSBbXG4gICAge1xuICAgICAgICBuYW1lOiAnem90ZXJvLW9ubGluZS11c2VyT3JHcm91cCcsXG4gICAgICAgIGRpc3BsYXlOYW1lOiAnWm90ZXJvIExpYnJhcnkgVHlwZTonLFxuICAgICAgICBpc0FjdGl2ZTogZm9ybURhdGEgPT4gZm9ybURhdGFbJ3R5cGUnXSA9PT0gJ3pvdGVyby1vbmxpbmUnLFxuICAgICAgICBhbGxvd2VkVmFsdWVzOiBbWyd1c2VyJywgJ1VzZXInXSwgWydncm91cCcsICdHcm91cCddXSxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiAndXNlcicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICd6b3Rlcm8tb25saW5lLWFwaUtleScsXG4gICAgICAgIGlzQWN0aXZlOiBmb3JtRGF0YSA9PiBmb3JtRGF0YVsndHlwZSddID09PSAnem90ZXJvLW9ubGluZScsXG4gICAgICAgIGRpc3BsYXlOYW1lOiAnQVBJIEtleTonLFxuICAgICAgICBpbnB1dFR5cGU6ICdwYXNzd29yZCcsXG4gICAgICAgIHRvb2x0aXA6ICdZb3UgY2FuIGNyZWF0ZSBhbiBBUEkga2V5IGhlcmU6IGh0dHBzOi8vd3d3LnpvdGVyby5vcmcvc2V0dGluZ3Mva2V5cycsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICd6b3Rlcm8tb25saW5lLXVzZXJJRCcsXG4gICAgICAgIHJlbG9hZE9uQ2hhbmdlT2Y6IFsnem90ZXJvLW9ubGluZS1hcGlLZXknXSxcbiAgICAgICAgY2FsY3VsYXRlOiBhc3luYyBmb3JtRGF0YSA9PiB7XG4gICAgICAgICAgICBpZighZm9ybURhdGEgfHwgIWZvcm1EYXRhWyd6b3Rlcm8tb25saW5lLWFwaUtleSddIHx8IGZvcm1EYXRhWyd6b3Rlcm8tb25saW5lLWFwaUtleSddID09PSAnJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgZ2V0Q2xpZW50V2l0aG91dFN0b3JlKGZvcm1EYXRhWyd6b3Rlcm8tb25saW5lLWFwaUtleSddKVxuICAgICAgICAgICAgcmV0dXJuIGNsaWVudC51c2VySURcbiAgICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnem90ZXJvLW9ubGluZS11c2VyTmFtZScsXG4gICAgICAgIHJlbG9hZE9uQ2hhbmdlT2Y6IFsnem90ZXJvLW9ubGluZS1hcGlLZXknXSxcbiAgICAgICAgY2FsY3VsYXRlOiBhc3luYyBmb3JtRGF0YSA9PiB7XG4gICAgICAgICAgICBpZighZm9ybURhdGEgfHwgIWZvcm1EYXRhWyd6b3Rlcm8tb25saW5lLWFwaUtleSddIHx8IGZvcm1EYXRhWyd6b3Rlcm8tb25saW5lLWFwaUtleSddID09PSAnJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgZ2V0Q2xpZW50V2l0aG91dFN0b3JlKGZvcm1EYXRhWyd6b3Rlcm8tb25saW5lLWFwaUtleSddKVxuICAgICAgICAgICAgcmV0dXJuIGNsaWVudC51c2VyTmFtZVxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICd6b3Rlcm8tb25saW5lLWdyb3VwTmFtZScsXG4gICAgICAgIHJlbG9hZE9uQ2hhbmdlT2Y6IFsnem90ZXJvLW9ubGluZS1hcGlLZXknLCAnem90ZXJvLW9ubGluZS11c2VyT3JHcm91cCcsICd6b3Rlcm8tb25saW5lLWdyb3VwSUQnXSxcbiAgICAgICAgY2FsY3VsYXRlOiBmb3JtRGF0YSA9PiB7XG4gICAgICAgICAgICBpZighbGF0ZXN0TG9hZGVkR3JvdXBzXG4gICAgICAgICAgICAgICAgfHwgIWxhdGVzdExvYWRlZEdyb3Vwcy5maW5kXG4gICAgICAgICAgICAgICAgfHwgIWZvcm1EYXRhXG4gICAgICAgICAgICAgICAgfHwgIWZvcm1EYXRhWyd6b3Rlcm8tb25saW5lLWdyb3VwSUQnXVxuICAgICAgICAgICAgICAgIHx8IGZvcm1EYXRhWyd6b3Rlcm8tb25saW5lLXVzZXJPckdyb3VwJ10gPT09ICd1c2VyJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZ3JvdXAgPSBsYXRlc3RMb2FkZWRHcm91cHMuZmluZChnciA9PiBnci5pZC50b1N0cmluZygpID09PSBmb3JtRGF0YVsnem90ZXJvLW9ubGluZS1ncm91cElEJ10udG9TdHJpbmcoKSlcblxuICAgICAgICAgICAgaWYoZ3JvdXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ3JvdXAubmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICd6b3Rlcm8tb25saW5lLWdyb3VwSUQnLFxuICAgICAgICBkaXNwbGF5TmFtZTogJ0dyb3VwJyxcbiAgICAgICAgdG9vbHRpcDogJ0lmIHlvdSB3YW50IHRvIGNpdGUgcmVmZXJlbmNlcyB3aGljaCBhcmUgbWFuYWdlZCBpbiBhIFpvdGVybyBncm91cCwgc2VsZWN0IHRoZSBncm91cCBoZXJlLiBJZiBub3QsIHNlbGVjdCBcIlVzZXJcIiBpbiBcIlVzZXIgb3IgR3JvdXAgU2NvcGVkIEludGVncmF0aW9uXCInLFxuICAgICAgICBpc0FjdGl2ZTogZm9ybURhdGEgPT4gZm9ybURhdGFbJ3R5cGUnXSA9PT0gJ3pvdGVyby1vbmxpbmUnICYmIGZvcm1EYXRhWyd6b3Rlcm8tb25saW5lLXVzZXJPckdyb3VwJ10gPT09ICdncm91cCcsXG4gICAgICAgIHJlbG9hZE9uQ2hhbmdlT2Y6IFsnem90ZXJvLW9ubGluZS1hcGlLZXknLCAnem90ZXJvLW9ubGluZS11c2VyT3JHcm91cCddLFxuICAgICAgICBhbGxvd2VkVmFsdWVzOiBhc3luYyBmb3JtRGF0YSA9PiB7XG4gICAgICAgICAgICBpZighZm9ybURhdGFcbiAgICAgICAgICAgICAgICB8fCAhZm9ybURhdGFbJ3pvdGVyby1vbmxpbmUtYXBpS2V5J11cbiAgICAgICAgICAgICAgICB8fCBmb3JtRGF0YVsnem90ZXJvLW9ubGluZS1hcGlLZXknXS50cmltKCkgPT09ICcnXG4gICAgICAgICAgICAgICAgfHwgZm9ybURhdGFbJ3pvdGVyby1vbmxpbmUtdXNlck9yR3JvdXAnXSAhPT0gJ2dyb3VwJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBnZXRDbGllbnRXaXRob3V0U3RvcmUoZm9ybURhdGFbJ3pvdGVyby1vbmxpbmUtYXBpS2V5J10pXG4gICAgICAgICAgICBsYXRlc3RMb2FkZWRHcm91cHMgPSBhd2FpdCBjbGllbnQuZ3JvdXBzKClcblxuICAgICAgICAgICAgcmV0dXJuIGxhdGVzdExvYWRlZEdyb3Vwcy5tYXAociA9PiBbci5pZCwgci5uYW1lXSlcbiAgICAgICAgfSxcbiAgICB9XG5dXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGlkOiAnem90ZXJvLW9ubGluZScsXG4gICAgZGlzcGxheU5hbWU6ICdab3Rlcm8ub3JnIChDbG91ZCBWZXJzaW9uKScsXG4gICAgaXNWYWxpZFJlY29yZCxcbiAgICByZW5kZXJFbnRyeSxcbiAgICBmaWVsZHMsXG4gICAgc3luY1xufSIsImNvbnN0IHRocm90dGxlID0gcmVxdWlyZSgnLi4vLi4vbGliL3Rocm90dGxlL3Rocm90dGxlJyk7XG5jb25zdCBlc2NhcGVJRCA9IGlkID0+IGlkLnJlcGxhY2UoL1teYS16QS1aMC05XFwtXS9nLCBcInhcIik7XG5cbmNsYXNzIFNpbXBsZVBlcnNpdGVuY3lEcml2ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmRhdGEgPSB7fVxuICAgIH1cblxuICAgIGFzeW5jIHNldChpZCwgYXR0cikge1xuICAgICAgICB0aGlzLmRhdGFbaWRdID0geyBpZCwgLi4uYXR0ciB9XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbaWRdXG4gICAgfVxuXG4gICAgYXN5bmMgYWxsKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLmRhdGEpXG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0KGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbaWRdXG4gICAgfVxuXG4gICAgYXN5bmMgZGVsZXRlQWxsKCkge1xuICAgICAgICB0aGlzLmRhdGEgPSB7fVxuICAgIH1cbn1cblxuY2xhc3MgUmVmZXJlbmNlU3RvcmUge1xuXG4gICAgc3RhdGljIGNpdGVkSW5DdXJyZW50RG9jdW1lbnQoKSB7XG4gICAgICAgIGlmKGRvY3VtZW50ICYmIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwpIHtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudFxuICAgICAgICAgICAgICAgIC5xdWVyeVNlbGVjdG9yQWxsKCcucmVmZXJlbmNlW2RhdGEtZXh0ZXJuYWw9XCJ0cnVlXCJdJylcbiAgICAgICAgICAgICAgICAubWFwKGVsID0+IGVsLmRhdGFzZXQucmVmKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtdXG4gICAgfVxuXG4gICAgc3RhdGljIGlzQ2l0ZWRJbkN1cnJlbnREb2N1bWVudChpZCkge1xuICAgICAgICByZXR1cm4gUmVmZXJlbmNlU3RvcmUuY2l0ZWRJbkN1cnJlbnREb2N1bWVudCgpLmluY2x1ZGVzKGlkKVxuICAgIH1cblxuICAgIC8vRklYTUU6IG1ha2UgdGhpcyBjYWxjdWxhdGVkIGF0dHJpYnV0ZSBvZiBmb3JtRGF0YVxuICAgIHN0YXRpYyBnZXRTb3VyY2VJRChmb3JtRGF0YSkge1xuICAgICAgICBpZihmb3JtRGF0YVsndHlwZSddID09PSAnem90ZXJvLW9ubGluZScpIHtcbiAgICAgICAgICAgIGlmKGZvcm1EYXRhWyd6b3Rlcm8tb25saW5lLXVzZXJPckdyb3VwJ10gPT09ICd1c2VyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBgem90ZXJvLW9ubGluZS11c2VyLSR7Zm9ybURhdGFbJ3pvdGVyby1vbmxpbmUtdXNlcklEJ119YFxuICAgICAgICAgICAgfSBlbHNlIGlmKGZvcm1EYXRhWyd6b3Rlcm8tb25saW5lLXVzZXJPckdyb3VwJ10gPT09ICdncm91cCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYHpvdGVyby1vbmxpbmUtZ3JvdXAtJHtmb3JtRGF0YVsnem90ZXJvLW9ubGluZS1ncm91cElEJ119YFxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYoZm9ybURhdGFbJ3R5cGUnXSA9PT0gJ3pvdGVyby1kZXNrdG9wJykge1xuICAgICAgICAgICAgcmV0dXJuIGB6b3Rlcm8tZGVza3RvcC0ke2Zvcm1EYXRhWyd6b3Rlcm8tZGVza3RvcC1saWJyYXJ5SUQnXX0tJHtmb3JtRGF0YVsnem90ZXJvLWRlc2t0b3AtY29sbGVjdGlvbklEJ119YFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoY29udGVudElkLCBQZXJzaXRlbmN5RHJpdmVyID0gU2ltcGxlUGVyc2l0ZW5jeURyaXZlcikge1xuICAgICAgICB0aGlzLmNvbnRlbnRJZCA9IGNvbnRlbnRJZFxuICAgICAgICB0aGlzLmRhdGEgPSB7fVxuICAgICAgICB0aGlzLnBlcnNpc3RlbnRSZWZlcmVuY2VTdG9yZSA9IG5ldyBQZXJzaXRlbmN5RHJpdmVyKCdyZWZlcmVuY2UnKVxuICAgICAgICB0aGlzLnBlcnNpc3RlbnRSZWZlcmVuY2VTb3VyY2VTdG9yZSA9IG5ldyBQZXJzaXRlbmN5RHJpdmVyKCdyZWZlcmVuY2Vfc291cmNlcycpXG4gICAgfVxuXG4gICAgaW5pdENhY2hlID0gdGhyb3R0bGUoMTAwLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGFsbFJlZnNGcm9tU3RvcmUgPSBhd2FpdCB0aGlzLnBlcnNpc3RlbnRSZWZlcmVuY2VTdG9yZS5hbGwoeyB1cGRhdGVkU2luY2U6IHRoaXMubGFzdENhY2hlVXBkYXRlIH0pXG4gICAgICAgIHRoaXMubGFzdENhY2hlVXBkYXRlID0gRGF0ZS5ub3coKVxuXG4gICAgICAgIGFsbFJlZnNGcm9tU3RvcmVcbiAgICAgICAgICAgIC5maWx0ZXIociA9PiAoci5jb250ZW50SWQgPT09IHRoaXMuY29udGVudElkIHx8IHIucmVmZXJlbmNlU291cmNlICE9PSAnaW50ZXJuJykpXG4gICAgICAgICAgICAuZm9yRWFjaChyID0+IHsgdGhpcy5kYXRhW3IuaWRdID0gciB9KVxuICAgIH0pXG5cbiAgICBzZXQoaWQsIGF0dHIpIHtcbiAgICAgICAgaWQgPSBlc2NhcGVJRChpZClcblxuICAgICAgICB2YXIgZmlsdGVyZWRBdHRyID0ge1xuICAgICAgICAgICAgLi4uYXR0cixcbiAgICAgICAgICAgIGNvbnRlbnRJZDogdGhpcy5jb250ZW50SWQsXG4gICAgICAgICAgICBsb29rdXBJZDogKGF0dHIubG9va3VwSWQgfHwgJycpLnRyaW0oKSxcbiAgICAgICAgICAgIHVybDogKGF0dHIudXJsIHx8ICcnKS50cmltKCksXG4gICAgICAgICAgICBkYXRlOiAoYXR0ci5kYXRlIHx8ICcnKS50cmltKCksXG4gICAgICAgICAgICB0eXBlOiAoYXR0ci50eXBlIHx8ICcnKS50cmltKCksXG4gICAgICAgICAgICBhdXRob3I6IChhdHRyLmF1dGhvciB8fCAnJykudHJpbSgpLFxuICAgICAgICAgICAgdGl0bGU6IChhdHRyLnRpdGxlIHx8ICcnKS50cmltKCksXG4gICAgICAgICAgICBzdWJ0aXRsZTogKGF0dHIuc3VidGl0bGUgfHwgJycpLnRyaW0oKSxcbiAgICAgICAgICAgIGJvb2t0aXRsZTogKGF0dHIuYm9va3RpdGxlIHx8ICcnKS50cmltKCksXG4gICAgICAgICAgICBvcmdhbml6YXRpb246IChhdHRyLm9yZ2FuaXphdGlvbiB8fCAnJykudHJpbSgpLFxuICAgICAgICAgICAgam91cm5hbDogKGF0dHIuam91cm5hbCB8fCAnJykudHJpbSgpLFxuICAgICAgICAgICAgcHVibGlzaGVyOiAoYXR0ci5wdWJsaXNoZXIgfHwgJycpLnRyaW0oKSxcbiAgICAgICAgICAgIHNjaG9vbDogKGF0dHIuc2Nob29sIHx8ICcnKS50cmltKCksXG4gICAgICAgICAgICBpbnN0aXR1dGlvbjogKGF0dHIuaW5zdGl0dXRpb24gfHwgJycpLnRyaW0oKSxcbiAgICAgICAgICAgIGVkaXRvcjogKGF0dHIuZWRpdG9yIHx8ICcnKS50cmltKCksXG4gICAgICAgICAgICBzZXJpZXM6IChhdHRyLnNlcmllcyB8fCAnJykudHJpbSgpLFxuICAgICAgICAgICAgeWVhcjogKGF0dHIueWVhciB8fCAnJykudHJpbSgpLFxuICAgICAgICAgICAgbW9udGg6IChhdHRyLm1vbnRoIHx8ICcnKS50cmltKCksXG4gICAgICAgICAgICBlZGl0aW9uOiAoYXR0ci5lZGl0aW9uIHx8ICcnKS50cmltKCksXG4gICAgICAgICAgICB2b2x1bWU6IChhdHRyLnZvbHVtZSB8fCAnJykudHJpbSgpLFxuICAgICAgICAgICAgbnVtYmVyOiAoYXR0ci5udW1iZXIgfHwgJycpLnRyaW0oKSxcbiAgICAgICAgICAgIGNoYXB0ZXI6IChhdHRyLmNoYXB0ZXIgfHwgJycpLnRyaW0oKSxcbiAgICAgICAgICAgIHBhZ2VzOiAoYXR0ci5wYWdlcyB8fCAnJykudHJpbSgpLFxuICAgICAgICAgICAgX2RlbGV0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgaWQ6IGlkXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRhdGFbaWRdID0gZmlsdGVyZWRBdHRyXG5cbiAgICAgICAgcmV0dXJuIHRoaXMucGVyc2lzdGVudFJlZmVyZW5jZVN0b3JlLnNldChpZCwgZmlsdGVyZWRBdHRyKVxuICAgIH1cblxuICAgIGdldChpZCkge1xuICAgICAgICBpZCA9IGVzY2FwZUlEKGlkKVxuXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbaWRdXG4gICAgfVxuXG4gICAgZGVsZXRlKGlkKSB7XG4gICAgICAgIGlkID0gZXNjYXBlSUQoaWQpXG5cbiAgICAgICAgdGhpcy5kYXRhW2lkXS5fZGVsZXRlZCA9IHRydWVcblxuICAgICAgICB0aGlzLnBlcnNpc3RlbnRSZWZlcmVuY2VTdG9yZS5nZXQoaWQpLnRoZW4oaXRlbSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBlcnNpc3RlbnRSZWZlcmVuY2VTdG9yZS5zZXQoaWQsIHtcbiAgICAgICAgICAgICAgICAuLi5pdGVtLFxuICAgICAgICAgICAgICAgIF9kZWxldGVkOiB0cnVlXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIGFsbCh3aXRoSUQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9XG5cbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5kYXRhKS5mb3JFYWNoKHJlZklkID0+IHtcbiAgICAgICAgICAgIGlmKCF0aGlzLmlzUmVmRW1wdHkocmVmSWQpICYmICghdGhpcy5kYXRhW3JlZklkXS5fZGVsZXRlZCB8fCBSZWZlcmVuY2VTdG9yZS5pc0NpdGVkSW5DdXJyZW50RG9jdW1lbnQocmVmSWQpKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtyZWZJZF0gPSB0aGlzLmRhdGFbcmVmSWRdXG5cbiAgICAgICAgICAgICAgICBpZih3aXRoSUQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3JlZklkXS5pZCA9IHJlZklkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFkZFJlZmVyZW5jZURhdGEoZGF0YSkge1xuICAgICAgICBPYmplY3QuZW50cmllcyhkYXRhKS5mb3JFYWNoKHJlZlJlY29yZCA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldChyZWZSZWNvcmRbMF0sIHJlZlJlY29yZFsxXSk7XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgYXN5bmMgYWxsQXN5bmMod2l0aElEKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fVxuXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuZGF0YSkuZm9yRWFjaChyZWZJZCA9PiB7XG4gICAgICAgICAgICBpZighdGhpcy5pc1JlZkVtcHR5KHJlZklkKSAmJiAoIXRoaXMuZGF0YVtyZWZJZF0uX2RlbGV0ZWQgfHwgUmVmZXJlbmNlU3RvcmUuaXNDaXRlZEluQ3VycmVudERvY3VtZW50KHJlZklkKSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbcmVmSWRdID0gdGhpcy5kYXRhW3JlZklkXVxuXG4gICAgICAgICAgICAgICAgaWYod2l0aElEKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtyZWZJZF0uaWQgPSByZWZJZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBpc1JlZkVtcHR5KGlkKSB7XG4gICAgICAgIGlkID0gZXNjYXBlSUQoaWQpXG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRoaXMuZGF0YVtpZF07XG5cbiAgICAgICAgcmV0dXJuIHJlY29yZC5hdXRob3IgPT09ICcnXG4gICAgICAgICAgICAmJiByZWNvcmQudGl0bGUgPT09ICcnXG4gICAgICAgICAgICAmJiByZWNvcmQudXJsID09PSAnJztcbiAgICB9XG5cbiAgICBhc3luYyBkZWxldGVBbGxTb3VyY2VzKCkge1xuICAgICAgICBhd2FpdCB0aGlzLnBlcnNpc3RlbnRSZWZlcmVuY2VTb3VyY2VTdG9yZS5kZWxldGVBbGwoKVxuICAgIH1cblxuICAgIGFzeW5jIGFkZFNvdXJjZShhdHRyKSB7XG4gICAgICAgIGNvbnN0IGlkID0gUmVmZXJlbmNlU3RvcmUuZ2V0U291cmNlSUQoYXR0cilcblxuICAgICAgICBpZighaWQpIHtcbiAgICAgICAgICAgIHRocm93IFwidW5hYmxlIHRvIHNhdmUgcmVmZXJlbmNlIHNvdXJjZVwiXG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCB0aGlzLnBlcnNpc3RlbnRSZWZlcmVuY2VTb3VyY2VTdG9yZS5zZXQoaWQsIGF0dHIpXG5cbiAgICAgICAgY29uc3QgYWxscmVmcyA9IChhd2FpdCB0aGlzLnBlcnNpc3RlbnRSZWZlcmVuY2VTdG9yZS5hbGwoKSlcbiAgICAgICAgICAgIC5maWx0ZXIociA9PiByLmlkICYmIHIuaWQuc3RhcnRzV2l0aChgem90ZXJvLW9ubGluZS1pdGVtLSR7aWQuc3BsaXQoJy0nKVszXX1gKSAmJiByLl9kZWxldGVkKVxuXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGFsbHJlZnMubWFwKGl0ZW0gPT4gdGhpcy5zZXQoaXRlbS5pZCwgaXRlbSkpKVxuICAgIH1cblxuICAgIGFzeW5jIGNsZWFudXBSZWZlcmVuY2VzRnJvbVNvdXJjZXMoKSB7XG4gICAgICAgIGNvbnN0IGFsbFNvdXJjZUlkcyA9IChhd2FpdCB0aGlzLmdldEFsbFNvdXJjZXMoKSkubWFwKHNyYyA9PiBzcmMuaWQpXG4gICAgICAgIGNvbnN0IGFsbFJlZnMgPSB0aGlzLmFsbCh0cnVlKVxuXG4gICAgICAgIGNvbnN0IHJlZnNUb0JlRGVsZXRlZCA9IE9iamVjdC52YWx1ZXMoYWxsUmVmcylcbiAgICAgICAgICAgIC5maWx0ZXIocmVmID0+IHtcbiAgICAgICAgICAgICAgICBpZighcmVmLnJlZmVyZW5jZVNvdXJjZSB8fCByZWYucmVmZXJlbmNlU291cmNlID09PSAnaW50ZXJuJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gIWFsbFNvdXJjZUlkcy5maW5kKHNyY0lkID0+IHNyY0lkID09PSByZWYucmVmZXJlbmNlU291cmNlKVxuICAgICAgICAgICAgfSlcblxuICAgICAgICByZWZzVG9CZURlbGV0ZWQuZm9yRWFjaChyZWYgPT4ge1xuICAgICAgICAgICAgdGhpcy5kZWxldGUocmVmLmlkKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIGFzeW5jIGdldEFsbFNvdXJjZXMoKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBlcnNpc3RlbnRSZWZlcmVuY2VTb3VyY2VTdG9yZS5hbGwoKVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWZlcmVuY2VTdG9yZTsiLCJ2YXIgdXRpbHMgPSByZXF1aXJlKCcuLi9saWIvcGl4ZWxzY2h1YnNlci91dGlscycpLFxuICAgIERlY2xhcmF0aXZGb3JtID0gcmVxdWlyZSgnLi4vbGliL2RlY2xhcmF0aXZfZm9ybXMvc3JjL2RlY2xhcmF0aXZfZm9ybScpO1xuXG5mdW5jdGlvbiBTZWN0aW9uVHlwZVNlbGVjdG9yQ29udHJvbChvbkNoYW5nZUNhbGxiYWNrLCBvbkNoYW5nZUNhbGxiYWNrQ29udGV4dCwgZWRpdG9yKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgdGhpcy5zZWN0aW9uVHlwZVNlbGVjdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5zZWN0aW9uVHlwZVNlbGVjdG9yLmlkID0gJ3NlY3Rpb25UeXBlU2VsZWN0b3InO1xuXG4gICAgdGhpcy5zZWN0aW9uVHlwZVNlbGVjdG9yLmlubmVySFRNTCA9ICc8c3BhbiBjbGFzcz1cIm9wdGlvbi1idG4gZGVsZXRlLW9wdGlvbi1idG5cIiBkYXRhLW9wdGlvbi1mb3I9XCJpbWdcIj48aSBjbGFzcz1cImZhcyBmYS10cmFzaFwiPjwvaT48L3NwYW4+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cIm9wdGlvbi1idG4gZGVsZXRlLW9wdGlvbi1idG5cIiBkYXRhLW9wdGlvbi1mb3I9XCJ0YWJsZVwiPjxpIGNsYXNzPVwiZmFzIGZhLXRyYXNoXCI+PC9pPjwvc3Bhbj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwib3B0aW9uLWJ0biBkZWxldGUtb3B0aW9uLWJ0blwiIGRhdGEtb3B0aW9uLWZvcj1cImNvZGVcIj48aSBjbGFzcz1cImZhcyBmYS10cmFzaFwiPjwvaT48L3NwYW4+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cIm9wdGlvbi1idG4gZGVsZXRlLW9wdGlvbi1idG5cIiBkYXRhLW9wdGlvbi1mb3I9XCJ0b2NcIj48aSBjbGFzcz1cImZhcyBmYS10cmFzaFwiPjwvaT48L3NwYW4+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cIm9wdGlvbi1idG4gZGVsZXRlLW9wdGlvbi1idG5cIiBkYXRhLW9wdGlvbi1mb3I9XCJicXVvdGVcIj48aSBjbGFzcz1cImZhcyBmYS10cmFzaFwiPjwvaT48L3NwYW4+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cIm9wdGlvbi1idG4gZGVsZXRlLW9wdGlvbi1idG5cIiBkYXRhLW9wdGlvbi1mb3I9XCJiaWJsaW9ncmFwaGllXCI+PGkgY2xhc3M9XCJmYXMgZmEtdHJhc2hcIj48L2k+PC9zcGFuPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJvcHRpb24tYnRuIGRlbGV0ZS1vcHRpb24tYnRuXCIgZGF0YS1vcHRpb24tZm9yPVwiZm9vdG5vdGVzXCI+PGkgY2xhc3M9XCJmYXMgZmEtdHJhc2hcIj48L2k+PC9zcGFuPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJvcHRpb24tYnRuIGRlbGV0ZS1vcHRpb24tYnRuXCIgZGF0YS1vcHRpb24tZm9yPVwiZm9ybXVsYVwiPjxpIGNsYXNzPVwiZmFzIGZhLXRyYXNoXCI+PC9pPjwvc3Bhbj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwib3B0aW9uLWJ0biBkZWxldGUtb3B0aW9uLWJ0blwiIGRhdGEtb3B0aW9uLWZvcj1cIm1lcm1haWRcIj48aSBjbGFzcz1cImZhcyBmYS10cmFzaFwiPjwvaT48L3NwYW4+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cIm9wdGlvbi1idG4gY29uZmlnLW9wdGlvbi1idG5cIiBkYXRhLW9wdGlvbi1mb3I9XCJjb2RlXCI+PGkgY2xhc3M9XCJmYXMgZmEtY29nXCI+PC9pPjwvc3Bhbj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwib3B0aW9uLWJ0biBjb25maWctb3B0aW9uLWJ0blwiIGRhdGEtb3B0aW9uLWZvcj1cInRhYmxlXCI+PGkgY2xhc3M9XCJmYXMgZmEtY29nXCI+PC9pPjwvc3Bhbj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwib3B0aW9uLWJ0biBjb25maWctb3B0aW9uLWJ0blwiIGRhdGEtb3B0aW9uLWZvcj1cImltZ1wiPjxpIGNsYXNzPVwiZmFzIGZhLWNvZ1wiPjwvaT48L3NwYW4+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cIm9wdGlvbi1idG4gY29uZmlnLW9wdGlvbi1idG5cIiBkYXRhLW9wdGlvbi1mb3I9XCJicXVvdGVcIj48aSBjbGFzcz1cImZhcyBmYS1jb2dcIj48L2k+PC9zcGFuPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJvcHRpb24tYnRuIGNvbmZpZy1vcHRpb24tYnRuXCIgZGF0YS1vcHRpb24tZm9yPVwiYmlibGlvZ3JhcGhpZVwiPjxpIGNsYXNzPVwiZmFzIGZhLWNvZ1wiPjwvaT48L3NwYW4+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cIm9wdGlvbi1idG4gY29uZmlnLW9wdGlvbi1idG5cIiBkYXRhLW9wdGlvbi1mb3I9XCJmb290bm90ZXNcIj48aSBjbGFzcz1cImZhcyBmYS1jb2dcIj48L2k+PC9zcGFuPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJvcHRpb24tYnRuIGNvbmZpZy1vcHRpb24tYnRuXCIgZGF0YS1vcHRpb24tZm9yPVwiZm9ybXVsYVwiPjxpIGNsYXNzPVwiZmFzIGZhLWNvZ1wiPjwvaT48L3NwYW4+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cIm9wdGlvbi1idG4gY29uZmlnLW9wdGlvbi1idG5cIiBkYXRhLW9wdGlvbi1mb3I9XCJtZXJtYWlkXCI+PGkgY2xhc3M9XCJmYXMgZmEtY29nXCI+PC9pPjwvc3Bhbj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwib3B0aW9uLWJ0biBjb25maWctb3B0aW9uLWJ0blwiIGRhdGEtb3B0aW9uLWZvcj1cImgyXCI+PGkgY2xhc3M9XCJmYXMgZmEtY29nXCI+PC9pPjwvc3Bhbj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwic2VjdGlvblR5cGVCdG5cIiBkYXRhLXR5cGU9XCJoMVwiPnRpdGxlPC9zcGFuPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJzZWN0aW9uVHlwZUJ0blwiIGRhdGEtdHlwZT1cImgyXCIgdW5hbm5vdGF0ZWQtY2FwdGlvbj1cImgxXCIgdW5hY3RpdmUtY2FwdGlvbj1cImhlYWRpbmctMVwiPmhlYWRpbmctMTwvc3Bhbj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwic2VjdGlvblR5cGVCdG5cIiBkYXRhLXR5cGU9XCJoM1wiIHVuYW5ub3RhdGVkLWNhcHRpb249XCJoMlwiIHVuYWN0aXZlLWNhcHRpb249XCJoZWFkaW5nLTJcIj5oZWFkaW5nLTI8L3NwYW4+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cInNlY3Rpb25UeXBlQnRuXCIgZGF0YS10eXBlPVwiaDRcIiB1bmFubm90YXRlZC1jYXB0aW9uPVwiaDNcIiB1bmFjdGl2ZS1jYXB0aW9uPVwiaGVhZGluZy0zXCI+aGVhZGluZy0zPC9zcGFuPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJzZWN0aW9uVHlwZUJ0blwiIGRhdGEtdHlwZT1cImg1XCIgdW5hbm5vdGF0ZWQtY2FwdGlvbj1cImg0XCIgdW5hY3RpdmUtY2FwdGlvbj1cImhlYWRpbmctNFwiPmhlYWRpbmctNDwvc3Bhbj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwic2VjdGlvblR5cGVCdG5cIiBkYXRhLXR5cGU9XCJwXCI+cGFyYWdyYXBoPC9zcGFuPicrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cInNlY3Rpb25UeXBlQnRuIG5vdENoYW5nZWFibGVcIiBkYXRhLXR5cGU9XCJicXVvdGVcIiB1bmFubm90YXRlZC1jYXB0aW9uPVwicXVvdGVcIiB1bmFjdGl2ZS1jYXB0aW9uPVwiYmxvY2txdW90ZVwiPmJsb2NrcXVvdGU8L3NwYW4+JytcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwic2VjdGlvblR5cGVCdG4gbm90Q2hhbmdlYWJsZVwiIGRhdGEtdHlwZT1cInRhYmxlXCI+dGFibGU8L3NwYW4+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cInNlY3Rpb25UeXBlQnRuXCIgZGF0YS10eXBlPVwiY29kZVwiIGRhdGEtc2VjdGlvbi10YWc9XCJwcmVcIiB1bmFubm90YXRlZC1jYXB0aW9uPVwiY29kZVwiPmNvZGU8L3NwYW4+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cInNlY3Rpb25UeXBlQnRuIG5vdENoYW5nZWFibGVcIiBkYXRhLXR5cGU9XCJ1bFwiIHVuYW5ub3RhdGVkLWNhcHRpb249XCJsaXN0XCIgdW5hY3RpdmUtY2FwdGlvbj1cInVub3JkZXJlZC1saXN0XCI+dW5vcmRlcmVkLWxpc3Q8L3NwYW4+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cInNlY3Rpb25UeXBlQnRuIG5vdENoYW5nZWFibGVcIiBkYXRhLXR5cGU9XCJvbFwiIHVuYW5ub3RhdGVkLWNhcHRpb249XCJsaXN0XCIgdW5hY3RpdmUtY2FwdGlvbj1cIm9yZGVyZWQtbGlzdFwiPm9yZGVyZWQtbGlzdDwvc3Bhbj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwic2VjdGlvblR5cGVCdG4gbm90Q2hhbmdlYWJsZVwiIGRhdGEtdHlwZT1cImltZ1wiIGRhdGEtc2VjdGlvbi10YWc9XCJmaWd1cmVcIj5pbWFnZTwvc3Bhbj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwic2VjdGlvblR5cGVCdG4gbm90Q2hhbmdlYWJsZVwiIGRhdGEtdHlwZT1cImZvcm11bGFcIj5mb3JtdWxhPC9zcGFuPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJzZWN0aW9uVHlwZUJ0biBub3RDaGFuZ2VhYmxlXCIgZGF0YS10eXBlPVwibWVybWFpZFwiPm1lcm1haWQ8L3NwYW4+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cInNlY3Rpb25UeXBlQnRuIG5vdENoYW5nZWFibGVcIiBkYXRhLXR5cGU9XCJ0b2NcIiBkYXRhLXNlY3Rpb24tdGFnPVwibmF2XCI+dG9jPC9zcGFuPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJzZWN0aW9uVHlwZUJ0biBub3RDaGFuZ2VhYmxlXCIgZGF0YS10eXBlPVwiYmlibGlvZ3JhcGhpZVwiIHVuYW5ub3RhdGVkLWNhcHRpb249XCJiaWJcIiB1bmFjdGl2ZS1jYXB0aW9uPVwiYmlibGlvZ3JhcGhpZVwiPmJpYmxpb2dyYXBoaWU8L3NwYW4+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cInNlY3Rpb25UeXBlQnRuXCIgZGF0YS10eXBlPVwiaDIoYWJzdHJhY3QpXCI+YWJzdHJhY3Q8L3NwYW4+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cInNlY3Rpb25UeXBlQnRuXCIgZGF0YS10eXBlPVwiaDIoZGVjbGFyYXRpb24pXCI+ZGVjbGFyYXRpb248L3NwYW4+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cInNlY3Rpb25UeXBlQnRuXCIgZGF0YS10eXBlPVwiaDIoYXBwZW5kaXgpXCI+YXBwZW5kaXg8L3NwYW4+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cInNlY3Rpb25UeXBlQnRuXCIgZGF0YS10eXBlPVwiaDIoYWNrbm93bGVkZ2VtZW50KVwiPmFja25vd2xlZGdlbWVudDwvc3Bhbj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwic2VjdGlvblR5cGVCdG4gbm90Q2hhbmdlYWJsZVwiIGRhdGEtdHlwZT1cImZvb3Rub3Rlc1wiPmZvb3Rub3Rlczwvc3Bhbj4nO1xuXG4gICAgdGhpcy5idXR0b25zID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5zZWN0aW9uVHlwZVNlbGVjdG9yLmNoaWxkcmVuKTtcblxuICAgIHRoaXMuc2VjdGlvblR5cGVTZWxlY3Rvci5vbm1vdXNlb3ZlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIGlzVHlwZUJ0biA9IGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnc2VjdGlvblR5cGVCdG4nKTtcblxuICAgICAgICBpZihlLnRhcmdldC5pZCA9PT0gJ3NlY3Rpb25UeXBlU2VsZWN0b3InKSB7IHJldHVybiB9XG5cbiAgICAgICAgc2VsZi5idXR0b25zLmZvckVhY2goZnVuY3Rpb24oYikge1xuICAgICAgICAgICAgaXNUeXBlQnRuID8gYi5jbGFzc0xpc3QuYWRkKCdob3ZlcicpIDogYi5jbGFzc0xpc3QucmVtb3ZlKCdob3ZlcicpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLnNlY3Rpb25UeXBlU2VsZWN0b3Iub25tb3VzZWxlYXZlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmJ1dHRvbnMuZm9yRWFjaChmdW5jdGlvbihiKSB7IGIuY2xhc3NMaXN0LnJlbW92ZSgnaG92ZXInKSB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmJ1dHRvbnMuZmlsdGVyKGZ1bmN0aW9uKGJ0bikge1xuICAgICAgICByZXR1cm4gYnRuLmNsYXNzTGlzdC5jb250YWlucygnZGVsZXRlLW9wdGlvbi1idG4nKTtcbiAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uKGJ0bikge1xuICAgICAgICBidG4ub25jbGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYoc2VsZi5lZGl0b3IpIHtcbiAgICAgICAgICAgICAgICBpZihzZWxmLnNlY3Rpb25FbGVtZW50Lm9uVW5mb2N1cykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNlY3Rpb25FbGVtZW50Lm9uVW5mb2N1cyhzZWxmLmVkaXRvcilcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZWxmLmVkaXRvci5yZW1vdmVTZWN0aW9uKHNlbGYuc2VjdGlvbkVsZW1lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNlY3Rpb25FbGVtZW50LnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoc2VsZi5zZWN0aW9uRWxlbWVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuaGlkZSgpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmJ1dHRvbnMuZmlsdGVyKGZ1bmN0aW9uKGJ0bikge1xuICAgICAgICByZXR1cm4gYnRuLmNsYXNzTGlzdC5jb250YWlucygnY29uZmlnLW9wdGlvbi1idG4nKTtcbiAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uKGJ0bikge1xuICAgICAgICBidG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpZihzZWxmLnNlY3Rpb25FbGVtZW50LnNlY3Rpb25UeXBlICYmIHNlbGYuc2VjdGlvbkVsZW1lbnQuc2VjdGlvblR5cGUuZ2V0T3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHZhciBmb3JtID0gbmV3IERlY2xhcmF0aXZGb3JtKHtmaWVsZHM6IHNlbGYuc2VjdGlvbkVsZW1lbnQuc2VjdGlvblR5cGUuZ2V0T3B0aW9ucyhzZWxmLnNlY3Rpb25FbGVtZW50KX0sIGZ1bmN0aW9uKGZvcm1EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2VjdGlvbkVsZW1lbnQuc2VjdGlvblR5cGUub25PcHRpb25zQ2hhbmdlKGZvcm1EYXRhLCBzZWxmLmVkaXRvcilcbiAgICAgICAgICAgICAgICAgICAgc2VsZi51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGZvcm0ub3BlbkluTW9kYWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnNlY3Rpb25UeXBlU2VsZWN0b3IuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBjbGlja2VkQnV0dG9uID0gZS50YXJnZXQsXG4gICAgICAgICAgICBjdXJyZW50U2VjdGlvbkJ0biA9IGNsaWNrZWRCdXR0b24ucGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yKCcuc2VjdGlvblR5cGVCdG4uYWN0aXZlJyksXG4gICAgICAgICAgICBjdXJyZW50U2VjdGlvbklzQ2hhbmdlYWJsZSA9IGN1cnJlbnRTZWN0aW9uQnRuICYmICFjdXJyZW50U2VjdGlvbkJ0bi5jbGFzc0xpc3QuY29udGFpbnMoJ25vdENoYW5nZWFibGUnKSxcbiAgICAgICAgICAgIGFubm90YXRpb24sIHNlY3Rpb25UeXBlTmFtZTtcblxuICAgICAgICBpZihjbGlja2VkQnV0dG9uLmRhdGFzZXQudHlwZSAmJiBjdXJyZW50U2VjdGlvbklzQ2hhbmdlYWJsZSkge1xuICAgICAgICAgICAgc2VjdGlvblR5cGVOYW1lID0gY2xpY2tlZEJ1dHRvbi5kYXRhc2V0LnR5cGUuc3BsaXQoL1xcKHxcXCkvKVswXTtcbiAgICAgICAgICAgIGFubm90YXRpb24gPSBjbGlja2VkQnV0dG9uLmRhdGFzZXQudHlwZS5zcGxpdCgvXFwofFxcKS8pWzFdO1xuICAgICAgICAgICAgb25DaGFuZ2VDYWxsYmFjay5hcHBseShvbkNoYW5nZUNhbGxiYWNrQ29udGV4dCwgW3NlY3Rpb25UeXBlTmFtZSwgYW5ub3RhdGlvbl0pO1xuICAgICAgICAgICAgc2VsZi5zZXRBY3RpdmVTZWxlY3Rpb24oY2xpY2tlZEJ1dHRvbi5kYXRhc2V0LnNlY3Rpb25UYWcgfHwgY2xpY2tlZEJ1dHRvbi5kYXRhc2V0LnR5cGUpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuc2VjdGlvblR5cGVTZWxlY3Rvcik7XG59XG5cblNlY3Rpb25UeXBlU2VsZWN0b3JDb250cm9sLnByb3RvdHlwZSA9IHtcbiAgICBnZXRTZWN0aW9uVHlwZUJ5U2VjdGlvblRhZzogZnVuY3Rpb24oc2VjdGlvblRhZykge1xuICAgICAgICB2YXIgYnRuID0gdGhpcy5idXR0b25zLmZpbmQoZnVuY3Rpb24gKGJ0bikge1xuICAgICAgICAgICAgcmV0dXJuIGJ0bi5kYXRhc2V0LnNlY3Rpb25UYWcgPT09IHNlY3Rpb25UYWcgfHwgYnRuLmRhdGFzZXQudHlwZSA9PT0gc2VjdGlvblRhZztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGJ0biAmJiBidG4uZGF0YXNldCAmJiBidG4uZGF0YXNldC50eXBlO1xuICAgIH0sXG5cbiAgICBzZXRBY3RpdmVTZWxlY3Rpb246IGZ1bmN0aW9uKHNlY3Rpb25UYWcpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgdW5hbm5vdGF0ZWRDYXB0aW9uLFxuICAgICAgICAgICAgdW5hY3RpdmVDYXB0aW9uLFxuICAgICAgICAgICAgY2FwdGlvbkFubm90YXRpb24sXG4gICAgICAgICAgICBhY3RpdmVCdG47XG5cbiAgICAgICAgdGhpcy5idXR0b25zLmZvckVhY2goZnVuY3Rpb24oYnRuKSB7XG4gICAgICAgICAgICBidG4uY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICAgICAgICBidG4uY2xhc3NMaXN0LnJlbW92ZSgndW51c2FibGUnKTtcbiAgICAgICAgICAgIHZhciB0YWdOYW1lID0gYnRuLmRhdGFzZXQuc2VjdGlvblRhZyB8fCBidG4uZGF0YXNldC50eXBlO1xuXG4gICAgICAgICAgICB1bmFubm90YXRlZENhcHRpb24gPSBidG4uZ2V0QXR0cmlidXRlKCd1bmFubm90YXRlZC1jYXB0aW9uJyk7XG4gICAgICAgICAgICB1bmFjdGl2ZUNhcHRpb24gPSBidG4uZ2V0QXR0cmlidXRlKCd1bmFjdGl2ZS1jYXB0aW9uJyk7XG5cbiAgICAgICAgICAgIGlmKHVuYW5ub3RhdGVkQ2FwdGlvbikge1xuICAgICAgICAgICAgICAgIGJ0bi5pbm5lckhUTUwgPSB1bmFubm90YXRlZENhcHRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHRhZ05hbWUgPT09IHNlY3Rpb25UYWcgfHwgYnRuLmRhdGFzZXQub3B0aW9uRm9yID09PSBzZWxmLmdldFNlY3Rpb25UeXBlQnlTZWN0aW9uVGFnKHNlY3Rpb25UYWcpKSB7XG4gICAgICAgICAgICAgICAgYnRuLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgICAgIGFjdGl2ZUJ0biA9IGJ0bjtcbiAgICAgICAgICAgICAgICBpZih1bmFubm90YXRlZENhcHRpb24gJiZcbiAgICAgICAgICAgICAgICAgICBzZWxmLnNlY3Rpb25FbGVtZW50ICYmXG4gICAgICAgICAgICAgICAgICAgc2VsZi5zZWN0aW9uRWxlbWVudC5zZWN0aW9uVHlwZSAmJlxuICAgICAgICAgICAgICAgICAgIHNlbGYuc2VjdGlvbkVsZW1lbnQuc2VjdGlvblR5cGUuZ2V0U2VjdGlvblR5cGVDYXB0aW9uQW5ub3RhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjYXB0aW9uQW5ub3RhdGlvbiA9IHNlbGYuc2VjdGlvbkVsZW1lbnQuc2VjdGlvblR5cGUuZ2V0U2VjdGlvblR5cGVDYXB0aW9uQW5ub3RhdGlvbihzZWxmLnNlY3Rpb25FbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHVuYWN0aXZlQ2FwdGlvbikge1xuICAgICAgICAgICAgICAgIGJ0bi5pbm5lckhUTUwgPSB1bmFjdGl2ZUNhcHRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGNhcHRpb25Bbm5vdGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYnRuLmlubmVySFRNTCA9IHVuYW5ub3RhdGVkQ2FwdGlvbiArICc8c3BhbiBjbGFzcz1cImFubm90YXRpb25cIj4oJyArIGNhcHRpb25Bbm5vdGF0aW9uICsgJyk8c3Bhbj4nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXB0aW9uQW5ub3RhdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHVuYWN0aXZlQ2FwdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYoYWN0aXZlQnRuLmNsYXNzTGlzdC5jb250YWlucygnbm90Q2hhbmdlYWJsZScpKSB7XG4gICAgICAgICAgICB0aGlzLmJ1dHRvbnMuZm9yRWFjaChmdW5jdGlvbihidG4pIHtcbiAgICAgICAgICAgICAgICBpZihidG4gIT09IGFjdGl2ZUJ0bikge1xuICAgICAgICAgICAgICAgICAgICBidG4uY2xhc3NMaXN0LmFkZCgndW51c2FibGUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBoaWRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlY3Rpb25UeXBlU2VsZWN0b3JFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NlY3Rpb25UeXBlU2VsZWN0b3InKTtcbiAgICAgICAgc2VjdGlvblR5cGVTZWxlY3RvckVsZW1lbnQuc3R5bGUubGVmdCA9IC0xMDAwICsgJ3B4JztcbiAgICAgICAgc2VjdGlvblR5cGVTZWxlY3RvckVsZW1lbnQuc3R5bGUudG9wID0gLTEwMDAgKyAncHgnO1xuICAgIH0sXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VjdGlvbkVsZW1lbnQgPSBzZWxmLmVkaXRvci5mb2N1c2VkU2VjdGlvbigpO1xuICAgICAgICBpZihzZWN0aW9uRWxlbWVudCAmJiBzZWN0aW9uRWxlbWVudC50YWdOYW1lKSB7XG4gICAgICAgICAgICB0aGlzLnNldEFjdGl2ZVNlbGVjdGlvbihzZWN0aW9uRWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGRpc3BsYXlOZXh0VG86IGZ1bmN0aW9uKHNlY3Rpb25FbGVtZW50LCBza2lwQW5pbWF0aW9uKSB7XG4gICAgICAgIGlmKCFzZWN0aW9uRWxlbWVudCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIHNlY3Rpb25Qb3NpdGlvbiA9IHV0aWxzLmdldEVsZW1lbnRQb3NpdGlvbihzZWN0aW9uRWxlbWVudCksXG4gICAgICAgICAgICBzZWN0aW9uVHlwZVNlbGVjdG9yRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZWN0aW9uVHlwZVNlbGVjdG9yJyksXG4gICAgICAgICAgICBzZWN0aW9uRWxlbWVudFRvcE1hcmdpbiA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHNlY3Rpb25FbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKCdtYXJnaW4tdG9wJykucmVwbGFjZSgncHgnLCAnJykpLFxuICAgICAgICAgICAgcG9zWCA9IHNlY3Rpb25Qb3NpdGlvbi54LFxuICAgICAgICAgICAgcG9zWSA9IHNlY3Rpb25Qb3NpdGlvbi55LFxuICAgICAgICAgICAgbWluWSA9IHdpbmRvdy5zY3JvbGxZICsgc2VjdGlvbkVsZW1lbnRUb3BNYXJnaW4gKyA1LCAvL2FkZCA1cHggc28gdGhhdCB0aGVyZSBpcyBhIHNtYWxsIHJvb20gYmV0d2VlbiB0aGUgZW5kIG9mIHRoZSBicm93c2VyIHNjcmVlbiBhbmQgdGhlIHNlbGVjdG9yIGJ1dHRvblxuICAgICAgICAgICAgbWF4WSA9IHNlY3Rpb25FbGVtZW50Lm9mZnNldEhlaWdodCArIHNlY3Rpb25FbGVtZW50Lm9mZnNldFRvcCAtIHNlY3Rpb25UeXBlU2VsZWN0b3JFbGVtZW50LmNoaWxkcmVuWzBdLm9mZnNldEhlaWdodCAtIDMwLFxuICAgICAgICAgICAgZXhlY3V0ZVVwZGF0ZTtcblxuICAgICAgICBwb3NZID0gcG9zWSA8IG1pblkgPyBtaW5ZIDogcG9zWTtcbiAgICAgICAgcG9zWSA9IHBvc1kgPiBtYXhZID8gbWF4WSA6IHBvc1k7XG5cbiAgICAgICAgdGhpcy5zZWN0aW9uRWxlbWVudCA9IHNlY3Rpb25FbGVtZW50O1xuICAgICAgICB0aGlzLnNldEFjdGl2ZVNlbGVjdGlvbihzZWN0aW9uRWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpO1xuXG4gICAgICAgIGlmKHRoaXMuZGlzcGxheVNlY3Rpb25UeXBlU2VsZWN0b3JUaW1lb3V0KVxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGlzcGxheVNlY3Rpb25UeXBlU2VsZWN0b3JUaW1lb3V0KTtcblxuICAgICAgICBleGVjdXRlVXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWN0aW9uVHlwZVNlbGVjdG9yRWxlbWVudC5zdHlsZS5sZWZ0ID0gcG9zWCArICdweCc7XG4gICAgICAgICAgICBzZWN0aW9uVHlwZVNlbGVjdG9yRWxlbWVudC5zdHlsZS50b3AgPSBwb3NZICsgJ3B4JztcbiAgICAgICAgICAgIGlmKHV0aWxzLmdldERpc3RhbmNlVG9SaWdodFdpbmRvd0JvcmRlcihzZWxmLmVkaXRvci5jb250YWluZXJFbGVtZW50KSA8IDE1MCkge1xuICAgICAgICAgICAgICAgIHNlY3Rpb25UeXBlU2VsZWN0b3JFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2xlc3NTcGFjZScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWN0aW9uVHlwZVNlbGVjdG9yRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdsZXNzU3BhY2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHNraXBBbmltYXRpb24pIHtcbiAgICAgICAgICAgIGV4ZWN1dGVVcGRhdGUoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5U2VjdGlvblR5cGVTZWxlY3RvclRpbWVvdXQgPSBzZXRUaW1lb3V0KGV4ZWN1dGVVcGRhdGUsIDEwKTtcbiAgICAgICAgfVxuXG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNlY3Rpb25UeXBlU2VsZWN0b3JDb250cm9sO1xuIiwidmFyIHV1aWQgPSByZXF1aXJlKCd1dWlkL3YxJyk7XG5cbmZ1bmN0aW9uIGdldFNlY3Rpb25FbGVtZW50KCkge1xuICAgIHZhciAgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdiaWJsaW9ncmFwaGllJyksXG4gICAgICAgICBoZWFkaW5nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDInKSxcbiAgICAgICAgIGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlbC5jbGFzc0xpc3QuYWRkKCdiaWJsaW9ncmFwaGllJyk7XG4gICAgaGVhZGluZy5jbGFzc0xpc3QuYWRkKCdiaWJsaW9ncmFwaGllLWhlYWRpbmcnKTtcbiAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoJ2JpYmxpb2dyYXBoaWUtY29udGVudCcpO1xuXG4gICAgZWwuc2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnLCAnZmFsc2UnKTtcbiAgICBoZWFkaW5nLnNldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJywgJ3RydWUnKTtcbiAgICBjb250ZW50LnNldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJywgJ2ZhbHNlJyk7XG5cbiAgICBoZWFkaW5nLmlubmVySFRNTCA9ICdCaWJsaW9ncmFwaHknO1xuXG4gICAgZWwuc2VjdGlvblR5cGUgPSBtb2R1bGUuZXhwb3J0cztcbiAgICBlbC5vbkZvY3VzID0gbW9kdWxlLmV4cG9ydHMub25Gb2N1cztcbiAgICBlbC5vbktleUJhY2tzcGFjZSA9IG1vZHVsZS5leHBvcnRzLm9uS2V5QmFja3NwYWNlO1xuXG4gICAgZWwuYXBwZW5kQ2hpbGQoaGVhZGluZyk7XG4gICAgZWwuYXBwZW5kQ2hpbGQoY29udGVudCk7XG5cbiAgICByZXR1cm4gZWw7XG59XG5cbk9iamVjdC5hc3NpZ24obW9kdWxlLmV4cG9ydHMsIHtcblxuICAgIG5hbWU6ICdiaWJsaW9ncmFwaGllJyxcblxuICAgIHByZWZlcnJlZENhcmV0UG9zaXRpb25pbmc6ICdlbmQnLFxuXG4gICAgZWRpdGFibGVFbGVtZW50U2VsZWN0b3I6ICdoMicsXG5cbiAgICBjb250ZW50UnVsZXM6IHtcbiAgICAgICAgJ2JpYmxpb2dyYXBoaWUnOiB7XG4gICAgICAgICAgICB0YWdOYW1lOiAnYmlibGlvZ3JhcGhpZScsXG4gICAgICAgICAgICBhbGxvd2VkQXR0cmlidXRlczogWydjbGFzcycsICdjb250ZW50ZWRpdGFibGUnXSxcbiAgICAgICAgICAgIGFsbG93ZWRDbGFzc05hbWVzOiBbJ2ZvY3VzZWQnXSxcbiAgICAgICAgICAgIGFsbG93ZWRDaGlsZHJlbjogWydiaWJsaW9ncmFwaGllLWhlYWRpbmcnLCAnYmlibGlvZ3JhcGhpZS1jb250ZW50J10sXG4gICAgICAgICAgICBhbGxvd2VkVG9CZVJvb3Q6IHRydWUsXG4gICAgICAgICAgICBkZWxldGVJZkVtcHR5OiBmYWxzZSxcbiAgICAgICAgICAgIGRvTm90QnJlYWtPdXRSb290RWxlbWVudHM6IHRydWUsXG4gICAgICAgICAgICBidWlsZEVtcHR5RWxlbWVudDogZ2V0U2VjdGlvbkVsZW1lbnRcbiAgICAgICAgfSxcblxuICAgICAgICAnYmlibGlvZ3JhcGhpZS1oZWFkaW5nJzoge1xuICAgICAgICAgICAgdGFnTmFtZTogJ2gyJyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2JpYmxpb2dyYXBoaWUtaGVhZGluZycsXG4gICAgICAgICAgICBhbGxvd2VkQXR0cmlidXRlczogWydpZCcsICdjbGFzcycsICdjb250ZW50ZWRpdGFibGUnLCAndW5udW1iZXJlZC1oZWFkaW5nJ10sXG4gICAgICAgICAgICBhbGxvd2VkQ2xhc3NOYW1lczogWydiaWJsaW9ncmFwaGllLWhlYWRpbmcnXSxcbiAgICAgICAgICAgIGFsbG93ZWRDaGlsZHJlbjogWycjdGV4dCddLFxuICAgICAgICAgICAgcHJ1bmVTcGFjZXM6IHRydWUsXG4gICAgICAgICAgICBidWlsZEF0dHJpYnV0ZXM6IFtcbiAgICAgICAgICAgICAgICB7bmFtZTogJ2lkJywgYnVpbGQ6IGZ1bmN0aW9uKCkge3JldHVybiB1dWlkKCl9fSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ3VubnVtYmVyZWQtaGVhZGluZycsIGJ1aWxkOiBmdW5jdGlvbigpIHtyZXR1cm4gJ1llcyd9fVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuXG4gICAgICAgICdiaWJsaW9ncmFwaGllLWNvbnRlbnQnOiB7XG4gICAgICAgICAgICB0YWdOYW1lOiAnZGl2JyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2JpYmxpb2dyYXBoaWUtY29udGVudCcsXG4gICAgICAgICAgICBhbGxvd2VkQXR0cmlidXRlczogWydjbGFzcycsICdjb250ZW50ZWRpdGFibGUnXSxcbiAgICAgICAgICAgIGFsbG93ZWRDbGFzc05hbWVzOiBbJ2JpYmxpb2dyYXBoaWUtY29udGVudCddLFxuICAgICAgICAgICAgYWxsb3dlZENoaWxkcmVuOiBbJ2JpYmxpb2dyYXBoaWUtZW50cnknXSxcbiAgICAgICAgfSxcblxuICAgICAgICAnYmlibGlvZ3JhcGhpZS1lbnRyeSc6IHtcbiAgICAgICAgICAgIHRhZ05hbWU6ICdkaXYnLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAnZW50cnknLFxuICAgICAgICAgICAgYWxsb3dlZEF0dHJpYnV0ZXM6IFsnY2xhc3MnXSxcbiAgICAgICAgICAgIGFsbG93ZWRDbGFzc05hbWVzOiBbJ2VudHJ5JywgJ25vdGUnXSxcbiAgICAgICAgICAgIGFsbG93ZWRDaGlsZHJlbjogWycjdGV4dCddLFxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGVucmljaG1lbnRzOiBbXSxcblxuICAgIGdldFNlY3Rpb25FbGVtZW50OiBnZXRTZWN0aW9uRWxlbWVudCxcblxuICAgIGdldE9wdGlvbnM6IGZ1bmN0aW9uKHNlY3Rpb25FbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ251bWJlcmVkSGVhZGluZycsXG4gICAgICAgICAgICAgICAgZGlzcGxheU5hbWU6ICdTaG91bGQgdGhlIGhlYWRpbmcgYmUgbnVtYmVyZWQnLFxuICAgICAgICAgICAgICAgIGFsbG93ZWRWYWx1ZXM6IFsnWWVzJywgJ05vJ10sXG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBzZWN0aW9uRWxlbWVudC5xdWVyeVNlbGVjdG9yKCdoMicpLmdldEF0dHJpYnV0ZSgndW5udW1iZXJlZC1oZWFkaW5nJykgPT09ICdZZXMnID8gJ05vJyA6ICdZZXMnXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuXG4gICAgb25PcHRpb25zQ2hhbmdlOiBmdW5jdGlvbihvcHQsIGVkaXRvcikge1xuICAgICAgICB2YXIgc2VjdGlvbiA9IGVkaXRvci5mb2N1c2VkU2VjdGlvbigpO1xuICAgICAgICBpZihvcHQubnVtYmVyZWRIZWFkaW5nID09PSAnWWVzJyB8fCBvcHQubnVtYmVyZWRIZWFkaW5nID09PSAnTm8nKSB7XG4gICAgICAgICAgICBzZWN0aW9uLnF1ZXJ5U2VsZWN0b3IoJ2gyJykuc2V0QXR0cmlidXRlKCd1bm51bWJlcmVkLWhlYWRpbmcnLCBvcHQubnVtYmVyZWRIZWFkaW5nID09PSAnWWVzJyA/ICdObycgOiAnWWVzJyk7XG4gICAgICAgICAgICBzZWxmLmVkaXRvci5yZXBsYWNlU2VjdGlvbldpdGhIVE1MKHNlY3Rpb24sIHNlY3Rpb24ub3V0ZXJIVE1MKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvbkVkaXRvckNvbnRlbnRDaGFuZ2VkOiBmdW5jdGlvbihtb2RpZmljYXRpb25Mb2cpIHtcbiAgICAgICAgaWYoIW1vZGlmaWNhdGlvbkxvZy5taWdodEluY2x1ZGVSZWZlcmVuY2VVcGRhdGVzICYmICFtb2RpZmljYXRpb25Mb2cubWlnaHRJbmNsdWRlQmlibGlvZ3JhcGhpZVVwZGF0ZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBiaWJzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnYmlibGlvZ3JhcGhpZSAuYmlibGlvZ3JhcGhpZS1jb250ZW50JyksXG4gICAgICAgICAgICByZWZzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnJlZmVyZW5jZVtkYXRhLWV4dGVybmFsXScpLm1hcChmdW5jdGlvbihyKSB7IHJldHVybiByLmdldEF0dHJpYnV0ZSgnZGF0YS1yZWYnKX0pLnVuaXF1ZSgpLFxuICAgICAgICAgICAgYWxsUmVmcyA9IG1vZHVsZS5leHBvcnRzLmVkaXRvci5yZWZlcmVuY2UuZ2V0QWxsRXh0ZXJuYWxSZWZzKCksIHJlZkRhdGE7XG5cbiAgICAgICAgYmlicy5mb3JFYWNoKGZ1bmN0aW9uKGJpYikge1xuICAgICAgICAgICAgYmliLmlubmVySFRNTCA9ICcnO1xuICAgICAgICAgICAgaWYocmVmcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBiaWIuaW5uZXJIVE1MICs9ICc8ZGl2IGNsYXNzPVwiZW50cnkgbm90ZVwiPkluc2VydCByZWZlcmVuY2VzIHRvIHNlZSB0aGVtIGhlcmUuPC9kaXY+JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVmcy5mb3JFYWNoKGZ1bmN0aW9uKHJlZklkKSB7XG4gICAgICAgICAgICAgICAgcmVmRGF0YSA9IGFsbFJlZnNbcmVmSWRdO1xuXG4gICAgICAgICAgICAgICAgaWYocmVmRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdG1wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgICAgIHRtcC5jbGFzc0xpc3QuYWRkKCdlbnRyeScpXG4gICAgICAgICAgICAgICAgICAgIHRtcC5zZXRBdHRyaWJ1dGUoJ2RhdGEtcmVmJywgcmVmSWQpO1xuICAgICAgICAgICAgICAgICAgICB0bXAuaW5uZXJIVE1MID0gW3JlZkRhdGEudXJsLCByZWZEYXRhLmF1dGhvciwgcmVmRGF0YS50aXRsZSwgcmVmRGF0YS55ZWFyLCAocmVmRGF0YS5wdWJsaXNoZXIgfHwgcmVmRGF0YS5qb3VybmFsKV0uZmlsdGVyKGZ1bmN0aW9uKHgpIHtyZXR1cm4geH0pLmpvaW4oJyAtICcpO1xuICAgICAgICAgICAgICAgICAgICB0bXAub25jbGljayA9IGZ1bmN0aW9uKCkgeyBtb2R1bGUuZXhwb3J0cy5lZGl0b3IucmVmZXJlbmNlLnNob3dFZGl0RXh0ZXJuYWxSZWZEaWFsb2codG1wKSB9O1xuICAgICAgICAgICAgICAgICAgICBiaWIuYXBwZW5kQ2hpbGQodG1wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIG9uS2V5QmFja3NwYWNlOiBmdW5jdGlvbihlLCBlZGl0b3IpIHtcbiAgICAgICAgdmFyIGhlYWRpbmcgPSBlZGl0b3IuY2FyZXQuZ2V0Q29udGV4dEVsZW1lbnQoJ2gyJywgd2luZG93LmdldFNlbGVjdGlvbigpLCBbXSksXG4gICAgICAgICAgICBzZWN0aW9uSW5kZXggPSBlZGl0b3IuaW5kZXhPZihlZGl0b3IuZm9jdXNlZFNlY3Rpb24oKSk7XG5cbiAgICAgICAgaWYoIWhlYWRpbmcgfHwgZWRpdG9yLmNhcmV0LmlzQ29sbGFwc2VkQW5kUG9zaXRpb25lZEF0VGhlQmVnaW5uaW5nT2YoaGVhZGluZywgZmFsc2UpKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0gZWxzZSBpZihoZWFkaW5nLmlubmVyVGV4dC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKCdkZWxldGUnKTtcbiAgICAgICAgICAgIGVkaXRvci5jYXJldC5wb3NpdGlvbkluKGVkaXRvci5zZWN0aW9uQXQoc2VjdGlvbkluZGV4KS5xdWVyeVNlbGVjdG9yKCdoMicpKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSBlbHNlIGlmKGhlYWRpbmcuaW5uZXJUZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG9uRm9jdXM6IGZ1bmN0aW9uKGVsLCBlZGl0b3IsIGFyZ3MpIHtcbiAgICAgICAgdmFyIGhlYWRpbmcgPSBlbC5xdWVyeVNlbGVjdG9yKCdoMicpLFxuICAgICAgICAgICAgaXNDYXJldEluc2lkZVNlY3Rpb24gPSAoZWRpdG9yLnNlY3Rpb25BdENhcmV0UG9zdGlvbigpID09PSBlbCAmJiBlZGl0b3IuY2FyZXQuZ2V0Q29udGV4dEVsZW1lbnQoJ2gyJykpLFxuICAgICAgICAgICAgaGFzQmVlbkZvY3VzZWRBZnRlclNlY3Rpb25UeXBlQ2hhbmdlID0gYXJncy5hY3Rpb24gPT09ICdjaGFuZ2VGb2N1c2VkU2VjdGlvblR5cGUnO1xuXG4gICAgICAgIGlmKGhhc0JlZW5Gb2N1c2VkQWZ0ZXJTZWN0aW9uVHlwZUNoYW5nZSB8fCAhaXNDYXJldEluc2lkZVNlY3Rpb24pIHtcbiAgICAgICAgICAgIGhlYWRpbmcgJiYgZWRpdG9yLmNhcmV0LnBvc2l0aW9uSW4oaGVhZGluZyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0RWRpdG9yOiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn0pO1xuIiwidmFyIHV1aWQgPSByZXF1aXJlKCd1dWlkL3YxJyk7XG5cbnZhciBnZXRTZWN0aW9uRWxlbWVudCA9IGZ1bmN0aW9uKGV4aXN0aW5nU2VjdGlvbkNvbnRlbnQpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdicXVvdGUnKSxcbiAgICAgICAgYmxvY2txdW90ZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYmxvY2txdW90ZScpLFxuICAgICAgICBjYXB0aW9uRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjaXRlc3JjJyk7XG5cbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScsICdmYWxzZScpXG4gICAgZWwuc2V0QXR0cmlidXRlKCdkaXNwbGF5LWNpdGVzcmMnLCAnWWVzJyk7XG4gICAgZWwuaWQgPSB1dWlkKCk7XG4gICAgZWwuc2V0Q29udGVudGVkaXRhYmxlID0gbW9kdWxlLmV4cG9ydHMuc2V0Q29udGVudGVkaXRhYmxlO1xuICAgIGVsLnNlY3Rpb25UeXBlID0gbW9kdWxlLmV4cG9ydHM7XG5cbiAgICBibG9ja3F1b3RlRWwuaW5uZXJIVE1MID0gZXhpc3RpbmdTZWN0aW9uQ29udGVudDtcbiAgICBibG9ja3F1b3RlRWwuc2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnLCAndHJ1ZScpO1xuXG4gICAgY2FwdGlvbkVsLmlubmVySFRNTCA9ICdjaXRhdGlvbiBzb3VyY2UnO1xuXG4gICAgZWwuYXBwZW5kQ2hpbGQoYmxvY2txdW90ZUVsKTtcbiAgICBlbC5hcHBlbmRDaGlsZChjYXB0aW9uRWwpO1xuXG4gICAgcmV0dXJuIGVsO1xufVxuXG5PYmplY3QuYXNzaWduKG1vZHVsZS5leHBvcnRzLCB7XG5cbiAgICBuYW1lOiAnYnF1b3RlJyxcblxuICAgIHRhZ1RyYW5zZm9ybWF0aW9uczoge1xuICAgICAgJy9icXVvdGUvYmxvY2txdW90ZS9kaXYnOiAnI2NvbnRlbnQnLFxuICAgICAgJy9icXVvdGUvYmxvY2txdW90ZS9zcGFuJzogJyNjb250ZW50JyxcbiAgICAgICcvYnF1b3RlL2Jsb2NrcXVvdGUnOiAnI3RleHQtY29udGVudCcsXG4gICAgfSxcblxuICAgIGNvbnRlbnRSdWxlczoge1xuICAgICAgICAnYnF1b3RlJzoge1xuICAgICAgICAgICAgdGFnTmFtZTogJ2JxdW90ZScsXG4gICAgICAgICAgICBhbGxvd2VkQXR0cmlidXRlczogWydjbGFzcycsICdjb250ZW50ZWRpdGFibGUnLCAnZGlzcGxheS1jYXB0aW9uJywgJ2lkJywgJ3JlZmVyZW5jZSddLFxuICAgICAgICAgICAgYWxsb3dlZENsYXNzTmFtZXM6IFsnZm9jdXNlZCddLFxuICAgICAgICAgICAgYWxsb3dlZENoaWxkcmVuOiBbJ2Jsb2NrcXVvdGUnLCAnY2l0ZXNyYyddLFxuICAgICAgICAgICAgYWxsb3dlZFRvQmVSb290OiB0cnVlLFxuICAgICAgICAgICAgYnVpbGRFbXB0eUVsZW1lbnQ6IGdldFNlY3Rpb25FbGVtZW50LFxuICAgICAgICAgICAgZGVsZXRlSWZFbXB0eTogZmFsc2UsXG4gICAgICAgICAgICBidWlsZEF0dHJpYnV0ZXM6IFtcbiAgICAgICAgICAgICAge25hbWU6ICdpZCcsIGJ1aWxkOiBmdW5jdGlvbigpIHtyZXR1cm4gdXVpZCgpfX0sXG4gICAgICAgICAgICAgIHtuYW1lOiAnZGlzcGxheS1jYXB0aW9uJywgYnVpbGQ6IGZ1bmN0aW9uKCkge3JldHVybiAnWWVzJ319XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgICdibG9ja3F1b3RlJzoge1xuICAgICAgICAgICAgdGFnTmFtZTogJ2Jsb2NrcXVvdGUnLFxuICAgICAgICAgICAgYWxsb3dlZFN1Y2Nlc3NvcnM6IFsnY2l0ZXNyYyddLFxuICAgICAgICAgICAgYWxsb3dlZEF0dHJpYnV0ZXM6IFsnY29udGVudGVkaXRhYmxlJ10sXG4gICAgICAgICAgICBhbGxvd2VkQ2hpbGRyZW46IFsnI3RleHQnXSxcbiAgICAgICAgfSxcbiAgICAgICAgJ2NpdGVzcmMnOiB7XG4gICAgICAgICAgICB0YWdOYW1lOiAnY2l0ZXNyYycsXG4gICAgICAgICAgICBhbGxvd2VkQ2hpbGRyZW46IFsnI3RleHQnLCAncmVmZXJlbmNlJywgICdpbmxpbmVlcXVhdGlvbiddLFxuICAgICAgICAgICAgZGVsZXRlSWZFbXB0eTogZmFsc2UsXG4gICAgICAgICAgICBwcnVuZVNwYWNlczogdHJ1ZSxcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBlbnJpY2htZW50czogW10sXG5cbiAgICBnZXRPcHRpb25zOiBmdW5jdGlvbihzZWN0aW9uRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBuYW1lOiAnZGlzcGxheUNhcHRpb24nLFxuICAgICAgICAgICAgICBkaXNwbGF5TmFtZTogJ0Rpc3BsYXkgU291cmNlJyxcbiAgICAgICAgICAgICAgYWxsb3dlZFZhbHVlczogWydZZXMnLCAnTm8nXSxcbiAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBzZWN0aW9uRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2Rpc3BsYXktY2FwdGlvbicpIHx8ICdZZXMnXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuXG4gICAgb25PcHRpb25zQ2hhbmdlOiBmdW5jdGlvbihvcHQsIGVkaXRvcikge1xuICAgICAgICB2YXIgc2VjdGlvbiA9IGVkaXRvci5mb2N1c2VkU2VjdGlvbigpO1xuXG4gICAgICAgIGlmKHNlY3Rpb24pIHtcbiAgICAgICAgICAgIGlmKG9wdC5kaXNwbGF5Q2FwdGlvbiA9PT0gJ1llcycgfHwgb3B0LmRpc3BsYXlDYXB0aW9uID09PSAnTm8nKSB7XG4gICAgICAgICAgICAgICAgc2VjdGlvbi5zZXRBdHRyaWJ1dGUoJ2Rpc3BsYXktY2FwdGlvbicsIG9wdC5kaXNwbGF5Q2FwdGlvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVkaXRvci5yZXBsYWNlU2VjdGlvbldpdGhIVE1MKHNlY3Rpb24sIHNlY3Rpb24ub3V0ZXJIVE1MKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRTZWN0aW9uRWxlbWVudDogZ2V0U2VjdGlvbkVsZW1lbnQsXG59KVxuIiwidmFyIEhUTUxSYXpvciA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi9odG1sX3Jhem9yL2h0bWxfcmF6b3InKSxcbiAgICB1dGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi9waXhlbHNjaHVic2VyL3V0aWxzJyksXG4gICAgc2hhcmVkID0gcmVxdWlyZSgnLi4vc2hhcmVkL3NoYXJlZCcpLFxuICAgIHByaW1zanMgPSByZXF1aXJlKCdwcmlzbWpzJyksXG4gICAgcHJvZ0xhbmd1YWdlcyA9IFtcIlhNTFwiLCBcIkhUTUxcIiwgXCJNYXRoTUxcIiwgXCJTVkdcIiwgXCJDU1NcIiwgXCJjbGlrZVwiLCBcIkphdmFTY3JpcHRcIl0sXG4gICAgcHJvZ0xhbmd1YWdlc1Nob3J0ID0geydKYXZhU2NyaXB0JzogJ0pTJ30sXG4gICAgZGVmYXVsdExhbmd1YWdlID0gJ0phdmFTY3JpcHQnLFxuICAgIHV1aWQgPSByZXF1aXJlKCd1dWlkL3YxJyk7XG5cbnZhciBnZXRTZWN0aW9uRWxlbWVudCA9IGZ1bmN0aW9uKGV4aXN0aW5nU2VjdGlvbkNvbnRlbnQsIHBhcmFtcykge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ByZScpLFxuICAgICAgICBjb2RlRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjb2RlJyksXG4gICAgICAgIGNhcHRpb25FbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhcHRpb24nKSxcbiAgICAgICAgY2FwaXRhbGl6ZWRMYW5nYXVnZTtcblxuICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2NvZGUnKTtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScsICdmYWxzZScpXG4gICAgZWwuc2V0QXR0cmlidXRlKCdkaXNwbGF5LWNhcHRpb24nLCAnWWVzJyk7XG4gICAgZWwuaWQgPSB1dWlkKCk7XG4gICAgZWwub25LZXlVcCA9IG1vZHVsZS5leHBvcnRzLm9uS2V5VXA7XG4gICAgZWwub25LZXlEb3duID0gbW9kdWxlLmV4cG9ydHMub25LZXlEb3duO1xuICAgIGVsLm9uS2V5RW50ZXIgPSBtb2R1bGUuZXhwb3J0cy5vbktleUVudGVyO1xuICAgIGVsLm9uS2V5VGFiID0gbW9kdWxlLmV4cG9ydHMub25LZXlUYWI7XG4gICAgZWwub25LZXlCYWNrc3BhY2UgPSBtb2R1bGUuZXhwb3J0cy5vbktleUJhY2tzcGFjZTtcbiAgICBlbC5vbk1hcmt1cENsZWFuaW5nRmluc2hlZCA9IG1vZHVsZS5leHBvcnRzLm9uTWFya3VwQ2xlYW5pbmdGaW5zaGVkO1xuICAgIGVsLnNldENvbnRlbnRlZGl0YWJsZSA9IG1vZHVsZS5leHBvcnRzLnNldENvbnRlbnRlZGl0YWJsZTtcbiAgICBlbC5zZWN0aW9uVHlwZSA9IG1vZHVsZS5leHBvcnRzO1xuXG4gICAgY29kZUVsLmlubmVySFRNTCA9IGV4aXN0aW5nU2VjdGlvbkNvbnRlbnQ7XG4gICAgY29kZUVsLnNldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJywgJ3RydWUnKTtcblxuICAgIGNhcHRpb25FbC5pbm5lckhUTUwgPSAnbGlzdGluZyB0aXRsZSc7XG5cbiAgICBlbC5hcHBlbmRDaGlsZChjb2RlRWwpO1xuICAgIGVsLmFwcGVuZENoaWxkKGNhcHRpb25FbCk7XG5cbiAgICBpZihwYXJhbXMgJiYgcGFyYW1zWzBdKSB7XG4gICAgICAgIHBhcmFtc1swXSA9IHBhcmFtc1swXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjYXBpdGFsaXplZExhbmdhdWdlID0gcHJvZ0xhbmd1YWdlcy5maW5kKGZ1bmN0aW9uKGxhbikge1xuICAgICAgICAgICAgcmV0dXJuIGxhbi50b0xvd2VyQ2FzZSgpID09PSBwYXJhbXNbMF07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNhcGl0YWxpemVkTGFuZ2F1Z2UgPSBjYXBpdGFsaXplZExhbmdhdWdlIHx8IGRlZmF1bHRMYW5ndWFnZTtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2xhbmd1YWdlJywgY2FwaXRhbGl6ZWRMYW5nYXVnZSk7XG5cbiAgICByZXR1cm4gZWw7XG59XG5cbk9iamVjdC5hc3NpZ24obW9kdWxlLmV4cG9ydHMsIHtcblxuICAgIG5hbWU6ICdjb2RlJyxcblxuICAgIHRhZ1RyYW5zZm9ybWF0aW9uczoge1xuICAgICAgJy9wcmUvY29kZS9kaXYnOiAnI2NvbnRlbnQnLFxuICAgICAgJy9wcmUvY29kZS9zcGFuJzogJyNjb250ZW50JyxcbiAgICAgICcvcHJlL2NvZGUnOiAnI3RleHQtY29udGVudCcsXG4gICAgfSxcblxuICAgIGNvbnRlbnRSdWxlczoge1xuICAgICAgICAncHJlJzoge1xuICAgICAgICAgICAgdGFnTmFtZTogJ3ByZScsXG4gICAgICAgICAgICBhbGxvd2VkQXR0cmlidXRlczogWydjbGFzcycsICdsYW5ndWFnZScsICdjb250ZW50ZWRpdGFibGUnLCAnZGlzcGxheS1jYXB0aW9uJywgJ2lkJ10sXG4gICAgICAgICAgICBhbGxvd2VkQ2xhc3NOYW1lczogWydmb2N1c2VkJywgJ2NvZGUnXSxcbiAgICAgICAgICAgIGFsbG93ZWRDaGlsZHJlbjogWydjb2RlJywgJ2NhcHRpb24nXSxcbiAgICAgICAgICAgIGFsbG93ZWRUb0JlUm9vdDogdHJ1ZSxcbiAgICAgICAgICAgIGJ1aWxkRW1wdHlFbGVtZW50OiBnZXRTZWN0aW9uRWxlbWVudCxcbiAgICAgICAgICAgIGRlbGV0ZUlmRW1wdHk6IGZhbHNlLFxuICAgICAgICAgICAgYnVpbGRBdHRyaWJ1dGVzOiBbXG4gICAgICAgICAgICAgIHtuYW1lOiAnaWQnLCBidWlsZDogZnVuY3Rpb24oKSB7cmV0dXJuIHV1aWQoKX19LFxuICAgICAgICAgICAgICB7bmFtZTogJ2xhbmd1YWdlJywgYnVpbGQ6IGZ1bmN0aW9uKCkge3JldHVybiBkZWZhdWx0TGFuZ3VhZ2V9fSxcbiAgICAgICAgICAgICAge25hbWU6ICdkaXNwbGF5LWNhcHRpb24nLCBidWlsZDogZnVuY3Rpb24oKSB7cmV0dXJuICdZZXMnfX1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgJ2NvZGUnOiB7XG4gICAgICAgICAgICB0YWdOYW1lOiAnY29kZScsXG4gICAgICAgICAgICBhbGxvd2VkU3VjY2Vzc29yczogWydjYXB0aW9uJ10sXG4gICAgICAgICAgICBhbGxvd2VkQXR0cmlidXRlczogWydjb250ZW50ZWRpdGFibGUnXSxcbiAgICAgICAgICAgIGFsbG93ZWRDaGlsZHJlbjogWycjdGV4dCddLFxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGVucmljaG1lbnRzOiBbXSxcblxuICAgIGdldE9wdGlvbnM6IGZ1bmN0aW9uKHNlY3Rpb25FbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5hbWU6ICdsYW5ndWFnZScsXG4gICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiAnU3ludGF4IEhpZ2hsaWdodGluZyBmb3InLFxuICAgICAgICAgICAgICBhbGxvd2VkVmFsdWVzOiBwcm9nTGFuZ3VhZ2VzLFxuICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IHNlY3Rpb25FbGVtZW50LmdldEF0dHJpYnV0ZSgnbGFuZ3VhZ2UnKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbmFtZTogJ2Rpc3BsYXlDYXB0aW9uJyxcbiAgICAgICAgICAgICAgZGlzcGxheU5hbWU6ICdEaXNwbGF5IExpc3RpbmcgQ2FwdGlvbicsXG4gICAgICAgICAgICAgIGFsbG93ZWRWYWx1ZXM6IFsnWWVzJywgJ05vJ10sXG4gICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogc2VjdGlvbkVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkaXNwbGF5LWNhcHRpb24nKSB8fCAnWWVzJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcblxuICAgIG9uT3B0aW9uc0NoYW5nZTogZnVuY3Rpb24ob3B0LCBlZGl0b3IpIHtcbiAgICAgICAgdmFyIHNlY3Rpb24gPSBlZGl0b3IuZm9jdXNlZFNlY3Rpb24oKTtcblxuICAgICAgICBpZihzZWN0aW9uKSB7XG4gICAgICAgICAgICBpZihvcHRbJ2xhbmd1YWdlJ10pIHtcbiAgICAgICAgICAgICAgICBzZWN0aW9uLnNldEF0dHJpYnV0ZSgnbGFuZ3VhZ2UnLCBvcHRbJ2xhbmd1YWdlJ10pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihvcHQuZGlzcGxheUNhcHRpb24gPT09ICdZZXMnIHx8IG9wdC5kaXNwbGF5Q2FwdGlvbiA9PT0gJ05vJykge1xuICAgICAgICAgICAgICAgIHNlY3Rpb24uc2V0QXR0cmlidXRlKCdkaXNwbGF5LWNhcHRpb24nLCBvcHQuZGlzcGxheUNhcHRpb24pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlZGl0b3IucmVwbGFjZVNlY3Rpb25XaXRoSFRNTChzZWN0aW9uLCBzZWN0aW9uLm91dGVySFRNTCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0U2VjdGlvbkVsZW1lbnQ6IGdldFNlY3Rpb25FbGVtZW50LFxuXG4gICAgb25NYXJrdXBDbGVhbmluZ0ZpbnNoZWQ6IGZ1bmN0aW9uKHNlY3Rpb25FbGVtZW50KSB7XG4gICAgICAgIHZhciBjb2RlRWwgPSBzZWN0aW9uRWxlbWVudC5xdWVyeVNlbGVjdG9yKCdjb2RlJyksIGNvbnRlbnQsIGxhbjtcblxuICAgICAgICBpZighY29kZUVsKSB7IHJldHVybiB9XG5cbiAgICAgICAgY29udGVudCA9IGNvZGVFbC5pbm5lckhUTUw7XG4gICAgICAgIGxhbiA9IHNlY3Rpb25FbGVtZW50LmdldEF0dHJpYnV0ZSgnbGFuZ3VhZ2UnKTtcblxuICAgICAgICBpZighbGFuIHx8IGxhbiA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgICBsYW4gPSBkZWZhdWx0TGFuZ3VhZ2U7XG4gICAgICAgIH1cblxuICAgICAgICBsYW4gPSBsYW4udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29udGVudCA9IEhUTUxSYXpvci5wcm90b3R5cGUuc3RyaXAoY29udGVudCk7XG4gICAgICAgIGNvbnRlbnQgPSBwcmltc2pzLmhpZ2hsaWdodChjb250ZW50LCBwcmltc2pzLmxhbmd1YWdlc1tsYW5dLCBsYW4pO1xuICAgICAgICBzZWN0aW9uRWxlbWVudC5xdWVyeVNlbGVjdG9yKCdjb2RlJykuaW5uZXJIVE1MID0gY29udGVudDtcbiAgICB9LFxuXG4gICAgZ2V0U2VjdGlvblR5cGVDYXB0aW9uQW5ub3RhdGlvbjogZnVuY3Rpb24oc2VjdGlvbkVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGxhbiA9IHNlY3Rpb25FbGVtZW50LmdldEF0dHJpYnV0ZSgnbGFuZ3VhZ2UnKTtcblxuICAgICAgICBpZihwcm9nTGFuZ3VhZ2VzU2hvcnRbbGFuXSkge1xuICAgICAgICAgICAgcmV0dXJuIHByb2dMYW5ndWFnZXNTaG9ydFtsYW5dO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxhbjtcbiAgICB9LFxuXG4gICAgb25LZXlUYWI6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ2luc2VydFRleHQnLCBmYWxzZSwgJyAgJyk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuXG4gICAgc2V0Q29udGVudGVkaXRhYmxlOiBmdW5jdGlvbihzaG91bGRCZUVkaXRhYmxlLCBzZWN0aW9uKSB7XG4gICAgICAgIHZhciBlbCA9IHNlY3Rpb24ucXVlcnlTZWxlY3RvcignY29kZScpXG4gICAgICAgIGlmKGVsKSB7XG4gICAgICAgICAgICBpZihzaG91bGRCZUVkaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvbktleVVwOiBzaGFyZWQub25LZXlVcEZvckZyZWVzdHlsZVNlY3Rpb25zLFxuICAgIG9uS2V5RG93bjogc2hhcmVkLm9uS2V5RG93bkZvckZyZWVzdHlsZVNlY3Rpb25zLFxuICAgIG9uS2V5QmFja3NwYWNlOiBmdW5jdGlvbihlLCBlZGl0b3IpIHtcbiAgICAgICAgdmFyIGNhcHRpb24gPSBlZGl0b3IuY2FyZXQuZ2V0Q29udGV4dEVsZW1lbnQoJ2NhcHRpb24nLCB3aW5kb3cuZ2V0U2VsZWN0aW9uKCksIFtdKSxcbiAgICAgICAgICAgIHNlY3Rpb25FbCwgc2VjdGlvbkluZGV4O1xuXG4gICAgICAgIGlmKGNhcHRpb24pIHtcbiAgICAgICAgICAgIGlmKGNhcHRpb24uaW5uZXJUZXh0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHNlY3Rpb25FbCA9IGNhcHRpb24ucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgICAgICBzZWN0aW9uSW5kZXggPSBlZGl0b3IuaW5kZXhPZihzZWN0aW9uRWwpO1xuXG4gICAgICAgICAgICAgICAgaWYoc2VjdGlvbkluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKCdkZWxldGUnKTtcblxuICAgICAgICAgICAgICAgICAgICBzZWN0aW9uRWwgPSBlZGl0b3Iuc2VjdGlvbkF0KHNlY3Rpb25JbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGNhcHRpb24gPSBzZWN0aW9uRWwgJiYgc2VjdGlvbkVsLnF1ZXJ5U2VsZWN0b3IoJ2NhcHRpb24nKTtcblxuICAgICAgICAgICAgICAgICAgICBpZihjYXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuY2FyZXQucG9zaXRpb25JbihjYXB0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYoIWNhcHRpb24uaW5uZXJUZXh0IHx8IGNhcHRpb24uaW5uZXJUZXh0Lmxlbmd0aCA9PT0gMCB8fCBlZGl0b3IuY2FyZXQuaXNDb2xsYXBzZWRBbmRQb3NpdGlvbmVkQXRUaGVCZWdpbm5pbmdPZihjYXB0aW9uLCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaGFyZWQub25LZXlCYWNrc3BhY2VGb3JCYWNrc3BhY2VEZWxldGFibGVTZWN0aW9ucyhlLCBlZGl0b3IpXG4gICAgICAgIH1cbiAgICB9LFxuICAgIG9uS2V5RW50ZXI6IHNoYXJlZC5vbktleUVudGVyRm9yRnJlZXN0eWxlU2VjdGlvbnNcbn0pXG4iLCJ2YXIgdXVpZCA9IHJlcXVpcmUoJ3V1aWQvdjEnKSxcbnV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL3BpeGVsc2NodWJzZXIvdXRpbHMnKTtcblxuZnVuY3Rpb24gZ2V0U2VjdGlvbkVsZW1lbnQoKSB7XG4gICAgdmFyICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvb3Rub3RlcycpLFxuICAgICAgICAgaGVhZGluZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2gyJyksXG4gICAgICAgICBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWwuY2xhc3NMaXN0LmFkZCgnZm9vdG5vdGVzJyk7XG5cbiAgICBoZWFkaW5nLmNsYXNzTGlzdC5hZGQoJ2Zvb3Rub3Rlcy1oZWFkaW5nJyk7XG4gICAgY29udGVudC5jbGFzc0xpc3QuYWRkKCdmb290bm90ZXMtY29udGVudCcpO1xuXG4gICAgZWwuc2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnLCAnZmFsc2UnKTtcbiAgICBoZWFkaW5nLnNldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJywgJ3RydWUnKTtcbiAgICBjb250ZW50LnNldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJywgJ2ZhbHNlJyk7XG5cbiAgICBoZWFkaW5nLmlubmVySFRNTCA9ICdGb290bm90ZXMnO1xuXG4gICAgZWwub25LZXlCYWNrc3BhY2UgPSBtb2R1bGUuZXhwb3J0cy5vbktleUJhY2tzcGFjZTtcbiAgICBlbC5zZWN0aW9uVHlwZSA9IG1vZHVsZS5leHBvcnRzO1xuXG4gICAgZWwuYXBwZW5kQ2hpbGQoaGVhZGluZyk7XG4gICAgZWwuYXBwZW5kQ2hpbGQoY29udGVudCk7XG5cbiAgICByZXR1cm4gZWw7XG59XG5cbk9iamVjdC5hc3NpZ24obW9kdWxlLmV4cG9ydHMsIHtcblxuICAgIG5hbWU6ICdmb290bm90ZXMnLFxuXG4gICAgZWRpdGFibGVFbGVtZW50U2VsZWN0b3I6ICdoMicsXG5cbiAgICBwcmVmZXJyZWRDYXJldFBvc2l0aW9uaW5nOiAnZW5kJyxcblxuICAgIGNvbnRlbnRSdWxlczoge1xuICAgICAgICAnZm9vdG5vdGVzJzoge1xuICAgICAgICAgICAgdGFnTmFtZTogJ2Zvb3Rub3RlcycsXG4gICAgICAgICAgICBhbGxvd2VkQXR0cmlidXRlczogWydjbGFzcycsICdjb250ZW50ZWRpdGFibGUnXSxcbiAgICAgICAgICAgIGFsbG93ZWRDbGFzc05hbWVzOiBbJ2ZvY3VzZWQnXSxcbiAgICAgICAgICAgIGFsbG93ZWRDaGlsZHJlbjogWydmb290bm90ZXMtaGVhZGluZycsICdmb290bm90ZXMtY29udGVudCddLFxuICAgICAgICAgICAgYWxsb3dlZFRvQmVSb290OiB0cnVlLFxuICAgICAgICAgICAgZGVsZXRlSWZFbXB0eTogZmFsc2UsXG4gICAgICAgICAgICBkb05vdEJyZWFrT3V0Um9vdEVsZW1lbnRzOiB0cnVlLFxuICAgICAgICAgICAgYnVpbGRFbXB0eUVsZW1lbnQ6IGdldFNlY3Rpb25FbGVtZW50XG4gICAgICAgIH0sXG5cbiAgICAgICAgJ2Zvb3Rub3Rlcy1oZWFkaW5nJzoge1xuICAgICAgICAgICAgdGFnTmFtZTogJ2gyJyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2Zvb3Rub3Rlcy1oZWFkaW5nJyxcbiAgICAgICAgICAgIGFsbG93ZWRBdHRyaWJ1dGVzOiBbJ2lkJywgJ2NsYXNzJywgJ2NvbnRlbnRlZGl0YWJsZScsICd1bm51bWJlcmVkLWhlYWRpbmcnXSxcbiAgICAgICAgICAgIGFsbG93ZWRDbGFzc05hbWVzOiBbJ2Zvb3Rub3Rlcy1oZWFkaW5nJ10sXG4gICAgICAgICAgICBhbGxvd2VkQ2hpbGRyZW46IFsnI3RleHQnXSxcbiAgICAgICAgICAgIHBydW5lU3BhY2VzOiB0cnVlLFxuICAgICAgICAgICAgYnVpbGRBdHRyaWJ1dGVzOiBbXG4gICAgICAgICAgICAgICAge25hbWU6ICdpZCcsIGJ1aWxkOiBmdW5jdGlvbigpIHtyZXR1cm4gdXVpZCgpfX0sXG4gICAgICAgICAgICAgICAge25hbWU6ICd1bm51bWJlcmVkLWhlYWRpbmcnLCBidWlsZDogZnVuY3Rpb24oKSB7cmV0dXJuICdZZXMnfX1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcblxuICAgICAgICAnZm9vdG5vdGVzLWNvbnRlbnQnOiB7XG4gICAgICAgICAgICB0YWdOYW1lOiAnZGl2JyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2Zvb3Rub3Rlcy1jb250ZW50JyxcbiAgICAgICAgICAgIGFsbG93ZWRBdHRyaWJ1dGVzOiBbJ2NsYXNzJywgJ2NvbnRlbnRlZGl0YWJsZSddLFxuICAgICAgICAgICAgYWxsb3dlZENsYXNzTmFtZXM6IFsnZm9vdG5vdGVzLWNvbnRlbnQnXSxcbiAgICAgICAgICAgIGFsbG93ZWRDaGlsZHJlbjogWydmb290bm90ZXMtZW50cnknXSxcbiAgICAgICAgfSxcblxuICAgICAgICAnZm9vdG5vdGVzLWVudHJ5Jzoge1xuICAgICAgICAgICAgdGFnTmFtZTogJ2RpdicsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdlbnRyeScsXG4gICAgICAgICAgICBhbGxvd2VkQXR0cmlidXRlczogWydjbGFzcyddLFxuICAgICAgICAgICAgYWxsb3dlZENsYXNzTmFtZXM6IFsnZW50cnknLCAnbm90ZSddLFxuICAgICAgICAgICAgYWxsb3dlZENoaWxkcmVuOiBbJyN0ZXh0J10sXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZW5yaWNobWVudHM6IFtdLFxuXG4gICAgZ2V0U2VjdGlvbkVsZW1lbnQ6IGdldFNlY3Rpb25FbGVtZW50LFxuXG4gICAgZ2V0T3B0aW9uczogZnVuY3Rpb24oc2VjdGlvbkVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnbnVtYmVyZWRIZWFkaW5nJyxcbiAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZTogJ1Nob3VsZCB0aGUgaGVhZGluZyBiZSBudW1iZXJlZCcsXG4gICAgICAgICAgICAgICAgYWxsb3dlZFZhbHVlczogWydZZXMnLCAnTm8nXSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IHNlY3Rpb25FbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2gyJykuZ2V0QXR0cmlidXRlKCd1bm51bWJlcmVkLWhlYWRpbmcnKSA9PT0gJ1llcycgPyAnTm8nIDogJ1llcydcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG5cbiAgICBvbk9wdGlvbnNDaGFuZ2U6IGZ1bmN0aW9uKG9wdCwgZWRpdG9yKSB7XG4gICAgICAgIHZhciBzZWN0aW9uID0gZWRpdG9yLmZvY3VzZWRTZWN0aW9uKCk7XG4gICAgICAgIGlmKG9wdC5udW1iZXJlZEhlYWRpbmcgPT09ICdZZXMnIHx8IG9wdC5udW1iZXJlZEhlYWRpbmcgPT09ICdObycpIHtcbiAgICAgICAgICAgIHNlY3Rpb24ucXVlcnlTZWxlY3RvcignaDInKS5zZXRBdHRyaWJ1dGUoJ3VubnVtYmVyZWQtaGVhZGluZycsIG9wdC5udW1iZXJlZEhlYWRpbmcgPT09ICdZZXMnID8gJ05vJyA6ICdZZXMnKTtcbiAgICAgICAgICAgIHNlbGYuZWRpdG9yLnJlcGxhY2VTZWN0aW9uV2l0aEhUTUwoc2VjdGlvbiwgc2VjdGlvbi5vdXRlckhUTUwpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG9uRWRpdG9yQ29udGVudENoYW5nZWQ6IGZ1bmN0aW9uKG1vZGlmaWNhdGlvbkxvZykge1xuICAgICAgICBpZighbW9kaWZpY2F0aW9uTG9nLm1pZ2h0SW5jbHVkZUZvb3Rub3RlVXBkYXRlcyAmJiAhbW9kaWZpY2F0aW9uTG9nLm1pZ2h0SW5jbHVkZUZvb3Rub3Rlc1NlY3Rpb25VcGRhdGVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbm90ZXNTZWN0aW9ucyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2Zvb3Rub3RlcyAuZm9vdG5vdGVzLWNvbnRlbnQnKSxcbiAgICAgICAgICAgIG5vdGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmZvb3Rub3RlJyksXG4gICAgICAgICAgICBub3RlSW5kZXgsIHRtcDtcblxuICAgICAgICBub3Rlc1NlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24obm90ZXNTZWN0aW9uKSB7XG4gICAgICAgICAgICBub3Rlc1NlY3Rpb24uaW5uZXJIVE1MID0gJyc7XG5cbiAgICAgICAgICAgIGlmKG5vdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG5vdGVzU2VjdGlvbi5pbm5lckhUTUwgKz0gJzxkaXYgY2xhc3M9XCJlbnRyeSBub3RlXCI+SW5zZXJ0IGZvb3Rub3RlcyB0byBzZWUgdGhlbSBoZXJlLjwvZGl2Pic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vdGVJbmRleCA9IDA7XG5cbiAgICAgICAgICAgIG5vdGVzLmZvckVhY2goZnVuY3Rpb24obm90ZSkge1xuICAgICAgICAgICAgICAgIG5vdGVJbmRleCsrO1xuICAgICAgICAgICAgICAgIHRtcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgIHRtcC5jbGFzc0xpc3QuYWRkKCdlbnRyeScpXG4gICAgICAgICAgICAgICAgdG1wLmlubmVySFRNTCA9IG5vdGVJbmRleCArICcpICcgKyB1dGlscy5hdHRyaWJ1dGVTYXZlU3RyaW5nVG9IVE1MRW5jb2RlZChub3RlLmdldEF0dHJpYnV0ZSgnZGF0YS1ub3RlJykpO1xuICAgICAgICAgICAgICAgIHRtcC5vbmNsaWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzLnNob3dGb290bm90ZUVkaXREaWFsb2cobm90ZSk7XG5cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG5vdGVzU2VjdGlvbi5hcHBlbmRDaGlsZCh0bXApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBzaG93Rm9vdG5vdGVFZGl0RGlhbG9nOiBmdW5jdGlvbihub3RlKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIHNlY3Rpb24gPSBzZWxmLmVkaXRvci5zZWN0aW9uQnlDaGlsZE5vZGUobm90ZSksXG4gICAgICAgICAgICBub3RlSW5kZXgsXG4gICAgICAgICAgICBhcmdzID0gW3tcbiAgICAgICAgICAgIG5hbWU6ICdub3RlJyxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiAnZm9vdG5vdGUnLFxuICAgICAgICAgICAgZGlzcGxheU5hbWU6ICdGb290bm90ZScsXG4gICAgICAgICAgICBsYXJnZXRleHQ6IHRydWUsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IHV0aWxzLmF0dHJpYnV0ZVNhdmVTdHJpbmdUb1N0cmluZyhub3RlLmRhdGFzZXQubm90ZSlcbiAgICAgICAgfV07XG5cbiAgICAgICAgaWYoIXNlY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuZWRpdG9yLmRpc3BsYXlNb2RhbChhcmdzLCBmdW5jdGlvbihmb3JtRGF0YSkge1xuICAgICAgICAgICAgbm90ZUluZGV4ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmZvb3Rub3RlJykuaW5kZXhPZihub3RlKSxcbiAgICAgICAgICAgIHNlbGYuZWRpdG9yLnVuZnJlZXplU2VsZWN0aW9uKGZhbHNlKTtcbiAgICAgICAgICAgIG5vdGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZm9vdG5vdGUnKVtub3RlSW5kZXhdO1xuICAgICAgICAgICAgc2VjdGlvbiA9IHNlbGYuZWRpdG9yLnNlY3Rpb25CeUNoaWxkTm9kZShub3RlKTtcblxuICAgICAgICAgICAgaWYoIWZvcm1EYXRhLm5vdGUpIHJldHVybjtcbiAgICAgICAgICAgIGlmKHR5cGVvZiBmb3JtRGF0YS5ub3RlICE9PSAnc3RyaW5nJykgcmV0dXJuO1xuICAgICAgICAgICAgaWYoZm9ybURhdGEubm90ZS50cmltKCkgPT09ICcnKSByZXR1cm47XG4gICAgICAgICAgICBub3RlLnNldEF0dHJpYnV0ZSgnZGF0YS1ub3RlJywgdXRpbHMuc3RyaW5nVG9BdHRyaWJ1dGVTYXZlU3RyaW5nKGZvcm1EYXRhLm5vdGUpKTtcblxuICAgICAgICAgICAgc2VsZi5lZGl0b3IucmVwbGFjZVNlY3Rpb25XaXRoSFRNTChzZWN0aW9uLCBzZWN0aW9uLm91dGVySFRNTCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBvbktleUJhY2tzcGFjZTogZnVuY3Rpb24oZSwgZWRpdG9yKSB7XG4gICAgICAgIHZhciBoZWFkaW5nID0gZWRpdG9yLmNhcmV0LmdldENvbnRleHRFbGVtZW50KCdoMicsIHdpbmRvdy5nZXRTZWxlY3Rpb24oKSwgW10pLFxuICAgICAgICAgICAgc2VjdGlvbkluZGV4ID0gZWRpdG9yLmluZGV4T2YoZWRpdG9yLmZvY3VzZWRTZWN0aW9uKCkpO1xuXG4gICAgICAgIGlmKCFoZWFkaW5nIHx8IGVkaXRvci5jYXJldC5pc0NvbGxhcHNlZEFuZFBvc2l0aW9uZWRBdFRoZUJlZ2lubmluZ09mKGhlYWRpbmcsIGZhbHNlKSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9IGVsc2UgaWYoaGVhZGluZy5pbm5lclRleHQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5leGVjQ29tbWFuZCgnZGVsZXRlJyk7XG4gICAgICAgICAgICBlZGl0b3IuY2FyZXQucG9zaXRpb25JbihlZGl0b3Iuc2VjdGlvbkF0KHNlY3Rpb25JbmRleCkucXVlcnlTZWxlY3RvcignaDInKSk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0gZWxzZSBpZihoZWFkaW5nLmlubmVyVGV4dC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvbkZvY3VzOiBmdW5jdGlvbihlbCwgZWRpdG9yLCBhcmdzKSB7XG4gICAgICAgIHZhciB0b0NIZWFkaW5nID0gZWwucXVlcnlTZWxlY3RvcignaDInKSxcbiAgICAgICAgICAgIGlzQ2FyZXRJbnNpZGVTZWN0aW9uID0gKGVkaXRvci5zZWN0aW9uQXRDYXJldFBvc3Rpb24oKSA9PT0gZWwgJiYgZWRpdG9yLmNhcmV0LmdldENvbnRleHRFbGVtZW50KCdoMicpKSxcbiAgICAgICAgICAgIGhhc0JlZW5Gb2N1c2VkQWZ0ZXJTZWN0aW9uVHlwZUNoYW5nZSA9IGFyZ3MuYWN0aW9uID09PSAnY2hhbmdlRm9jdXNlZFNlY3Rpb25UeXBlJztcblxuICAgICAgICBpZihoYXNCZWVuRm9jdXNlZEFmdGVyU2VjdGlvblR5cGVDaGFuZ2UgfHwgIWlzQ2FyZXRJbnNpZGVTZWN0aW9uKSB7XG4gICAgICAgICAgICB0b0NIZWFkaW5nICYmIGVkaXRvci5jYXJldC5wb3NpdGlvbkluKHRvQ0hlYWRpbmcpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNldEVkaXRvcjogZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59KTtcbiIsInZhciBjb2RlMmRpYSA9IHJlcXVpcmUoJy4uL3NoYXJlZC9jb2RlMmRpYV9zZWN0aW9uX3R5cGUnKSxcbiAgICAvLyBrYXRleCA9IHJlcXVpcmUoJ2thdGV4JyksIC8vIG1ha2Ugc3VyZSB0byBsb2FkIDxzY3JpcHQgc3JjPVwiLi9rYXRleC5qc1wiIGRlZmVyPjwvc2NyaXB0PiBpbiB5b3VyIGh0bWxcbiAgICBsYXRleCA9IHJlcXVpcmUoJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1sYXRleCcpLFxuICAgIHJlbmRlcjtcblxucmVuZGVyID0gZnVuY3Rpb24ocmVuZGVyRWwsIGNvbnRlbnQpIHtcbiAgICBpZihjb250ZW50LnRyaW0oKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmVuZGVyRWwuaW5uZXJIVE1MID0gJ1dyaXRlIGEgTGFUZVggZm9ybXVsYSBpbnRvIHRoZSBpbnB1dCBmaWVsZCBhYm92ZSA8c3BhbiBjbGFzcz1cImFycm93XCI+JiMxMDU0ODs8L3NwYW4+JztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZW5kZXJFbC5pbm5lckhUTUwgPSAnJztcbiAgICAgICAga2F0ZXgucmVuZGVyKGNvbnRlbnQsIHJlbmRlckVsLCB7XG4gICAgICAgICAgICB0aHJvd09uRXJyb3I6IGZhbHNlLFxuICAgICAgICAgICAgZGlzcGxheU1vZGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvZGUyZGlhKHJlbmRlciwgJ2Zvcm11bGEnLCAnbGF0ZXgnLCAnZXF1YXRpb24gY2FwdGlvbicpXG4iLCJ2YXIgdXVpZCA9IHJlcXVpcmUoJ3V1aWQvdjEnKSxcbiAgICBwYXJhZ3JhcGhTZWN0aW9uVHlwZSA9IHJlcXVpcmUoJy4uL3BhcmFncmFwaC9wYXJhZ3JhcGhfc2VjdGlvbl90eXBlJyk7XG5cbnZhciBnZXRTZWN0aW9uRWxlbWVudCA9IGZ1bmN0aW9uKGV4aXN0aW5nU2VjdGlvbkNvbnRlbnQpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoMScpO1xuICAgIGVsLmlubmVySFRNTCA9IGV4aXN0aW5nU2VjdGlvbkNvbnRlbnQgfHwgJyc7XG4gICAgZWwuaWQgPSB1dWlkKCk7XG4gICAgZWwub25LZXlVcCA9IG1vZHVsZS5leHBvcnRzLm9uS2V5VXA7XG4gICAgZWwub25LZXlEb3duID0gbW9kdWxlLmV4cG9ydHMub25LZXlEb3duO1xuICAgIGVsLm9uS2V5RW50ZXIgPSBtb2R1bGUuZXhwb3J0cy5vbktleUVudGVyO1xuICAgIHJldHVybiBlbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICBuYW1lOiAnaDEnLFxuXG4gICAgY29udGVudFJ1bGVzOiB7XG4gICAgICAgICdoMSc6IHtcbiAgICAgICAgICAgIHRhZ05hbWU6ICdoMScsXG4gICAgICAgICAgICBhbGxvd2VkQXR0cmlidXRlczogWydjbGFzcycsICdpZCddLFxuICAgICAgICAgICAgYWxsb3dlZENoaWxkcmVuOiBbJyN0ZXh0JywgJ2lubGluZWVxdWF0aW9uJ10sXG4gICAgICAgICAgICBhbGxvd2VkQ2xhc3NOYW1lczogWydmb2N1c2VkJ10sXG4gICAgICAgICAgICBwcnVuZVNwYWNlczogdHJ1ZSxcbiAgICAgICAgICAgIGFsbG93ZWRUb0JlUm9vdDogdHJ1ZSxcbiAgICAgICAgICAgIGJ1aWxkRW1wdHlFbGVtZW50OiBnZXRTZWN0aW9uRWxlbWVudCxcbiAgICAgICAgICAgIGJ1aWxkQXR0cmlidXRlczogW3tuYW1lOiAnaWQnLCBidWlsZDogZnVuY3Rpb24oKSB7cmV0dXJuIHV1aWQoKX19XVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGVucmljaG1lbnRzOiBbXSxcblxuICAgIG9uS2V5VXA6IHBhcmFncmFwaFNlY3Rpb25UeXBlLm9uS2V5VXAsXG4gICAgb25LZXlEb3duOiBwYXJhZ3JhcGhTZWN0aW9uVHlwZS5vbktleURvd24sXG4gICAgb25LZXlFbnRlcjogZnVuY3Rpb24oZSwgZWRpdG9yKSB7XG4gICAgICAgIGlmKGVkaXRvci5jYXJldC5pc0NvbGxhcHNlZEFuZFBvc2l0aW9uZWRBdFRoZUJlZ2lubmluZ09mKGVkaXRvci5mb2N1c2VkU2VjdGlvbigpKSkge1xuICAgICAgICAgICAgaWYoZWRpdG9yLmZvY3VzZWRTZWN0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICBlZGl0b3IuYWRkTmV3U2VjdGlvbk5leHRUbyhlZGl0b3IuZm9jdXNlZFNlY3Rpb24oKSwgJ2JlZm9yZScpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlZGl0b3IuY2FyZXQuaW5zZXJ0TGluZUJyZWFrKCk7XG4gICAgICAgIH1cblxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSxcblxuICAgIGdldFNlY3Rpb25FbGVtZW50OiBnZXRTZWN0aW9uRWxlbWVudCxcbn1cbiIsInZhciB1dWlkID0gcmVxdWlyZSgndXVpZC92MScpLFxuICAgIHBhcmFncmFwaFNlY3Rpb25UeXBlID0gcmVxdWlyZSgnLi4vcGFyYWdyYXBoL3BhcmFncmFwaF9zZWN0aW9uX3R5cGUnKSxcbiAgICBoMVNlY3Rpb25UeXBlID0gcmVxdWlyZSgnLi9oZWFkaW5nMS5qcycpO1xuXG52YXIgZ2V0U2VjdGlvbkVsZW1lbnQgPSBmdW5jdGlvbihleGlzdGluZ1NlY3Rpb25Db250ZW50LCBwYXJhbXMpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoMicpO1xuXG4gICAgaWYocGFyYW1zICYmIChwYXJhbXMuaW5jbHVkZXMoJ2Fic3RyYWN0JykgfHwgcGFyYW1zLmluY2x1ZGVzKCdBYnN0cmFjdCcpKSkge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnQWJzdHJhY3QnKVxuICAgIH0gZWxzZSBpZihwYXJhbXMgJiYgKHBhcmFtcy5pbmNsdWRlcygnZGVjbGFyYXRpb24nKSB8fCBwYXJhbXMuaW5jbHVkZXMoJ0RlY2xhcmF0aW9uJykpKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgncm9sZScsICdEZWNsYXJhdGlvbicpXG4gICAgfSBlbHNlIGlmKHBhcmFtcyAmJiAocGFyYW1zLmluY2x1ZGVzKCdhcHBlbmRpeCcpIHx8IHBhcmFtcy5pbmNsdWRlcygnQXBwZW5kaXgnKSkpIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdyb2xlJywgJ0FwcGVuZGl4JylcbiAgICB9IGVsc2UgaWYocGFyYW1zICYmIChwYXJhbXMuaW5jbHVkZXMoJ2Fja25vd2xlZGdlbWVudCcpIHx8IHBhcmFtcy5pbmNsdWRlcygnQWNrbm93bGVkZ2VtZW50JykpKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgncm9sZScsICdBY2tub3dsZWRnZW1lbnQnKVxuICAgIH1cblxuICAgIGVsLmlubmVySFRNTCA9IGV4aXN0aW5nU2VjdGlvbkNvbnRlbnQgfHwgJyc7XG4gICAgZWwub25LZXlVcCA9IG1vZHVsZS5leHBvcnRzLm9uS2V5VXA7XG4gICAgZWwub25LZXlEb3duID0gbW9kdWxlLmV4cG9ydHMub25LZXlEb3duO1xuICAgIGVsLm9uS2V5RW50ZXIgPSBtb2R1bGUuZXhwb3J0cy5vbktleUVudGVyO1xuICAgIGVsLmlkID0gdXVpZCgpO1xuICAgIGVsLnNlY3Rpb25UeXBlID0gbW9kdWxlLmV4cG9ydHM7XG4gICAgcmV0dXJuIGVsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIG5hbWU6ICdoMicsXG5cbiAgICBjb250ZW50UnVsZXM6IHtcbiAgICAgICAgJ2gyJzoge1xuICAgICAgICAgICAgdGFnTmFtZTogJ2gyJyxcbiAgICAgICAgICAgIGFsbG93ZWRBdHRyaWJ1dGVzOiBbJ2NsYXNzJywgJ2lkJywgJ3JvbGUnXSxcbiAgICAgICAgICAgIGFsbG93ZWRDaGlsZHJlbjogWycjdGV4dCcsICdpbmxpbmVlcXVhdGlvbiddLFxuICAgICAgICAgICAgYWxsb3dlZENsYXNzTmFtZXM6IFsnZm9jdXNlZCddLFxuICAgICAgICAgICAgcHJ1bmVTcGFjZXM6IHRydWUsXG4gICAgICAgICAgICBhbGxvd2VkVG9CZVJvb3Q6IHRydWUsXG4gICAgICAgICAgICBidWlsZEVtcHR5RWxlbWVudDogZ2V0U2VjdGlvbkVsZW1lbnQsXG4gICAgICAgICAgICBidWlsZEF0dHJpYnV0ZXM6IFt7bmFtZTogJ2lkJywgYnVpbGQ6IGZ1bmN0aW9uKCkge3JldHVybiB1dWlkKCl9fV1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBlbnJpY2htZW50czogW10sXG5cbiAgICBnZXRPcHRpb25zOiBmdW5jdGlvbihzZWN0aW9uRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBuYW1lOiAncm9sZScsXG4gICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiAnQXNzaWduIGEgc3BlY2lhbCByb2xlIHRvIHRoZSBoZWFkaW5nJyxcbiAgICAgICAgICAgICAgYWxsb3dlZFZhbHVlczogWydOb25lJywgJ0Fic3RyYWN0JywgJ0RlY2xhcmF0aW9uJywgJ0FwcGVuZGl4JywgJ0Fja25vd2xlZGdlbWVudCddLFxuICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IHNlY3Rpb25FbGVtZW50LmdldEF0dHJpYnV0ZSgncm9sZScpIHx8ICdOb25lJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcblxuICAgIG9uT3B0aW9uc0NoYW5nZTogZnVuY3Rpb24ob3B0LCBlZGl0b3IpIHtcbiAgICAgICAgdmFyIHNlY3Rpb24gPSBlZGl0b3IuZm9jdXNlZFNlY3Rpb24oKTtcblxuICAgICAgICBpZihzZWN0aW9uKSB7XG4gICAgICAgICAgICBpZihvcHRbJ3JvbGUnXSkge1xuICAgICAgICAgICAgICAgIHNlY3Rpb24uc2V0QXR0cmlidXRlKCdyb2xlJywgb3B0Wydyb2xlJ10pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlZGl0b3IucmVwbGFjZVNlY3Rpb25XaXRoSFRNTChzZWN0aW9uLCBzZWN0aW9uLm91dGVySFRNTCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0U2VjdGlvblR5cGVDYXB0aW9uQW5ub3RhdGlvbjogZnVuY3Rpb24oc2VjdGlvbkVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHJvbGUgPSBzZWN0aW9uRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JvbGUnKTtcbiAgICAgICAgaWYocm9sZSA9PT0gJ05vbmUnKSB7XG4gICAgICAgICAgICByb2xlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHJvbGUgPT09ICdBY2tub3dsZWRnZW1lbnQnKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0Fjay4nXG4gICAgICAgIH1cblxuICAgICAgICBpZihyb2xlID09PSAnRGVjbGFyYXRpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0RlY2wuJ1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJvbGU7XG4gICAgfSxcblxuICAgIG9uS2V5VXA6IHBhcmFncmFwaFNlY3Rpb25UeXBlLm9uS2V5VXAsXG4gICAgb25LZXlEb3duOiBwYXJhZ3JhcGhTZWN0aW9uVHlwZS5vbktleURvd24sXG4gICAgb25LZXlFbnRlcjogaDFTZWN0aW9uVHlwZS5vbktleUVudGVyLFxuXG4gICAgZ2V0U2VjdGlvbkVsZW1lbnQ6IGdldFNlY3Rpb25FbGVtZW50LFxufVxuIiwidmFyIHV1aWQgPSByZXF1aXJlKCd1dWlkL3YxJyksXG4gICAgcGFyYWdyYXBoU2VjdGlvblR5cGUgPSByZXF1aXJlKCcuLi9wYXJhZ3JhcGgvcGFyYWdyYXBoX3NlY3Rpb25fdHlwZScpLFxuICAgIGgxU2VjdGlvblR5cGUgPSByZXF1aXJlKCcuL2hlYWRpbmcxLmpzJyk7XG5cbnZhciBnZXRTZWN0aW9uRWxlbWVudCA9IGZ1bmN0aW9uKGV4aXN0aW5nU2VjdGlvbkNvbnRlbnQpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoMycpO1xuICAgIGVsLmlubmVySFRNTCA9IGV4aXN0aW5nU2VjdGlvbkNvbnRlbnQgfHwgJyc7XG4gICAgZWwub25LZXlVcCA9IG1vZHVsZS5leHBvcnRzLm9uS2V5VXA7XG4gICAgZWwub25LZXlEb3duID0gbW9kdWxlLmV4cG9ydHMub25LZXlEb3duO1xuICAgIGVsLm9uS2V5RW50ZXIgPSBtb2R1bGUuZXhwb3J0cy5vbktleUVudGVyO1xuICAgIGVsLmlkID0gdXVpZCgpO1xuICAgIHJldHVybiBlbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICBuYW1lOiAnaDMnLFxuXG4gICAgY29udGVudFJ1bGVzOiB7XG4gICAgICAgICdoMyc6IHtcbiAgICAgICAgICAgIHRhZ05hbWU6ICdoMycsXG4gICAgICAgICAgICBhbGxvd2VkQXR0cmlidXRlczogWydjbGFzcycsICdpZCddLFxuICAgICAgICAgICAgYWxsb3dlZENoaWxkcmVuOiBbJyN0ZXh0JywgJ2lubGluZWVxdWF0aW9uJ10sXG4gICAgICAgICAgICBhbGxvd2VkQ2xhc3NOYW1lczogWydmb2N1c2VkJ10sXG4gICAgICAgICAgICBwcnVuZVNwYWNlczogdHJ1ZSxcbiAgICAgICAgICAgIGFsbG93ZWRUb0JlUm9vdDogdHJ1ZSxcbiAgICAgICAgICAgIGJ1aWxkRW1wdHlFbGVtZW50OiBnZXRTZWN0aW9uRWxlbWVudCxcbiAgICAgICAgICAgIGJ1aWxkQXR0cmlidXRlczogW3tuYW1lOiAnaWQnLCBidWlsZDogZnVuY3Rpb24oKSB7cmV0dXJuIHV1aWQoKX19XVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGVucmljaG1lbnRzOiBbXSxcblxuICAgIG9uS2V5VXA6IHBhcmFncmFwaFNlY3Rpb25UeXBlLm9uS2V5VXAsXG4gICAgb25LZXlEb3duOiBwYXJhZ3JhcGhTZWN0aW9uVHlwZS5vbktleURvd24sXG4gICAgb25LZXlFbnRlcjogaDFTZWN0aW9uVHlwZS5vbktleUVudGVyLFxuXG4gICAgZ2V0U2VjdGlvbkVsZW1lbnQ6IGdldFNlY3Rpb25FbGVtZW50LFxufVxuIiwidmFyIHV1aWQgPSByZXF1aXJlKCd1dWlkL3YxJyksXG4gICAgcGFyYWdyYXBoU2VjdGlvblR5cGUgPSByZXF1aXJlKCcuLi9wYXJhZ3JhcGgvcGFyYWdyYXBoX3NlY3Rpb25fdHlwZScpLFxuICAgIGgxU2VjdGlvblR5cGUgPSByZXF1aXJlKCcuL2hlYWRpbmcxLmpzJyk7XG5cbnZhciBnZXRTZWN0aW9uRWxlbWVudCA9IGZ1bmN0aW9uKGV4aXN0aW5nU2VjdGlvbkNvbnRlbnQpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoNCcpO1xuICAgIGVsLmlubmVySFRNTCA9IGV4aXN0aW5nU2VjdGlvbkNvbnRlbnQgfHwgJyc7XG4gICAgZWwub25LZXlVcCA9IG1vZHVsZS5leHBvcnRzLm9uS2V5VXA7XG4gICAgZWwub25LZXlEb3duID0gbW9kdWxlLmV4cG9ydHMub25LZXlEb3duO1xuICAgIGVsLm9uS2V5RW50ZXIgPSBtb2R1bGUuZXhwb3J0cy5vbktleUVudGVyO1xuICAgIGVsLmlkID0gdXVpZCgpO1xuICAgIHJldHVybiBlbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICBuYW1lOiAnaDQnLFxuXG4gICAgY29udGVudFJ1bGVzOiB7XG4gICAgICAgICdoNCc6IHtcbiAgICAgICAgICAgIHRhZ05hbWU6ICdoNCcsXG4gICAgICAgICAgICBhbGxvd2VkQXR0cmlidXRlczogWydjbGFzcycsICdpZCddLFxuICAgICAgICAgICAgYWxsb3dlZENoaWxkcmVuOiBbJyN0ZXh0JywgJ2lubGluZWVxdWF0aW9uJ10sXG4gICAgICAgICAgICBhbGxvd2VkQ2xhc3NOYW1lczogWydmb2N1c2VkJ10sXG4gICAgICAgICAgICBwcnVuZVNwYWNlczogdHJ1ZSxcbiAgICAgICAgICAgIGFsbG93ZWRUb0JlUm9vdDogdHJ1ZSxcbiAgICAgICAgICAgIGJ1aWxkRW1wdHlFbGVtZW50OiBnZXRTZWN0aW9uRWxlbWVudCxcbiAgICAgICAgICAgIGJ1aWxkQXR0cmlidXRlczogW3tuYW1lOiAnaWQnLCBidWlsZDogZnVuY3Rpb24oKSB7cmV0dXJuIHV1aWQoKX19XVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGVucmljaG1lbnRzOiBbXSxcblxuICAgIG9uS2V5VXA6IHBhcmFncmFwaFNlY3Rpb25UeXBlLm9uS2V5VXAsXG4gICAgb25LZXlEb3duOiBwYXJhZ3JhcGhTZWN0aW9uVHlwZS5vbktleURvd24sXG4gICAgb25LZXlFbnRlcjogaDFTZWN0aW9uVHlwZS5vbktleUVudGVyLFxuXG4gICAgZ2V0U2VjdGlvbkVsZW1lbnQ6IGdldFNlY3Rpb25FbGVtZW50LFxufVxuIiwidmFyIHV1aWQgPSByZXF1aXJlKCd1dWlkL3YxJyksXG4gICAgcGFyYWdyYXBoU2VjdGlvblR5cGUgPSByZXF1aXJlKCcuLi9wYXJhZ3JhcGgvcGFyYWdyYXBoX3NlY3Rpb25fdHlwZScpLFxuICAgIGgxU2VjdGlvblR5cGUgPSByZXF1aXJlKCcuL2hlYWRpbmcxLmpzJyk7XG5cbnZhciBnZXRTZWN0aW9uRWxlbWVudCA9IGZ1bmN0aW9uKGV4aXN0aW5nU2VjdGlvbkNvbnRlbnQpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoNScpO1xuICAgIGVsLmlubmVySFRNTCA9IGV4aXN0aW5nU2VjdGlvbkNvbnRlbnQgfHwgJyc7XG4gICAgZWwub25LZXlVcCA9IG1vZHVsZS5leHBvcnRzLm9uS2V5VXA7XG4gICAgZWwub25LZXlEb3duID0gbW9kdWxlLmV4cG9ydHMub25LZXlEb3duO1xuICAgIGVsLm9uS2V5RW50ZXIgPSBtb2R1bGUuZXhwb3J0cy5vbktleUVudGVyO1xuICAgIGVsLmlkID0gdXVpZCgpO1xuICAgIHJldHVybiBlbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICBuYW1lOiAnaDUnLFxuXG4gICAgY29udGVudFJ1bGVzOiB7XG4gICAgICAgICdoNSc6IHtcbiAgICAgICAgICAgIHRhZ05hbWU6ICdoNScsXG4gICAgICAgICAgICBhbGxvd2VkQXR0cmlidXRlczogWydjbGFzcycsICdpZCddLFxuICAgICAgICAgICAgYWxsb3dlZENoaWxkcmVuOiBbJyN0ZXh0JywgJ2lubGluZWVxdWF0aW9uJ10sXG4gICAgICAgICAgICBhbGxvd2VkQ2xhc3NOYW1lczogWydmb2N1c2VkJ10sXG4gICAgICAgICAgICBwcnVuZVNwYWNlczogdHJ1ZSxcbiAgICAgICAgICAgIGFsbG93ZWRUb0JlUm9vdDogdHJ1ZSxcbiAgICAgICAgICAgIGJ1aWxkRW1wdHlFbGVtZW50OiBnZXRTZWN0aW9uRWxlbWVudCxcbiAgICAgICAgICAgIGJ1aWxkQXR0cmlidXRlczogW3tuYW1lOiAnaWQnLCBidWlsZDogZnVuY3Rpb24oKSB7cmV0dXJuIHV1aWQoKX19XVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGVucmljaG1lbnRzOiBbXSxcblxuICAgIG9uS2V5VXA6IHBhcmFncmFwaFNlY3Rpb25UeXBlLm9uS2V5VXAsXG4gICAgb25LZXlEb3duOiBwYXJhZ3JhcGhTZWN0aW9uVHlwZS5vbktleURvd24sXG4gICAgb25LZXlFbnRlcjogaDFTZWN0aW9uVHlwZS5vbktleUVudGVyLFxuXG4gICAgZ2V0U2VjdGlvbkVsZW1lbnQ6IGdldFNlY3Rpb25FbGVtZW50LFxufVxuIiwidmFyIGNob29zZUZpbGVCdG5Db3VudGVyID0gMCxcbiAgICBpbWFnZVNlY3Rpb25UeXBlLFxuICAgIHV1aWQgPSByZXF1aXJlKCd1dWlkL3YxJyk7XG5cbnZhciBidWlsZEVtcHR5SW1nUGxhY2Vob2RlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpbWdQbGFjZWhvbGRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKSxcbiAgICAgICAgZW1wdHlJbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2knKSxcbiAgICAgICAgY2hvb3NlRmlsZUxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKSxcbiAgICAgICAgY2hvb3NlRmlsZUJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JyksXG4gICAgICAgIGNob29zZUZpbGVCdG5JZCA9ICdjaG9vc2VGaWxlQnRuJyArIGNob29zZUZpbGVCdG5Db3VudGVyKys7XG5cbiAgICBlbXB0eUltYWdlLmNsYXNzTGlzdC5hZGQoJ2VtcHR5LWltYWdlJyk7XG4gICAgY2hvb3NlRmlsZUJ0bi5jbGFzc0xpc3QuYWRkKCdjaG9vc2UtaW1nLWJ0bicpO1xuICAgIGNob29zZUZpbGVCdG4uc2V0QXR0cmlidXRlKCd0eXBlJywgJ2ZpbGUnKTtcbiAgICBjaG9vc2VGaWxlQnRuLnNldEF0dHJpYnV0ZSgnaWQnLCBjaG9vc2VGaWxlQnRuSWQpO1xuXG4gICAgY2hvb3NlRmlsZUxhYmVsLmNsYXNzTGlzdC5hZGQoJ2Nob29zZS1pbWctYnRuLWxhYmVsJyk7XG4gICAgY2hvb3NlRmlsZUxhYmVsLmlubmVySFRNTCA9ICdDbGljayB0byBJbXBvcnQgSW1hZ2UgKG9yIGRyYWcgYW5kIGRyb3AgaXQpJztcblxuICAgIGltZ1BsYWNlaG9sZGVyLnNldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJywgZmFsc2UpO1xuICAgIGltZ1BsYWNlaG9sZGVyLmNsYXNzTGlzdC5hZGQoJ2ltYWdlLWltZy1wbGFjZWhvbGRlcicpO1xuICAgIGltZ1BsYWNlaG9sZGVyLmFwcGVuZENoaWxkKGNob29zZUZpbGVMYWJlbCk7XG4gICAgaW1nUGxhY2Vob2xkZXIuYXBwZW5kQ2hpbGQoY2hvb3NlRmlsZUJ0bik7XG4gICAgaW1nUGxhY2Vob2xkZXIuYXBwZW5kQ2hpbGQoZW1wdHlJbWFnZSk7XG5cbiAgICB2YXIgZ2V0SW1hZ2VPclBsYWNlaG9sZGVyQnlBQ2hpbGQgPSBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICBpZighY2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGNoaWxkLmNsYXNzTGlzdC5jb250YWlucygnaW1hZ2UtaW1nLXBsYWNlaG9sZGVyJykgfHwgY2hpbGQudGFnTmFtZSA9PT0gJ0lNRycpIHtcbiAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldEltYWdlT3JQbGFjZWhvbGRlckJ5QUNoaWxkKGNoaWxkLnBhcmVudEVsZW1lbnQpO1xuICAgIH1cblxuICAgIGltZ1BsYWNlaG9sZGVyLm9uY2xpY2sgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmKGltYWdlU2VjdGlvblR5cGUpIHtcbiAgICAgICAgICAgIGltYWdlU2VjdGlvblR5cGUuZWRpdG9yLmZvY3VzU2VjdGlvbihlLnRhcmdldC5wYXJlbnRFbGVtZW50KVxuICAgICAgICB9XG5cbiAgICAgICAgY2hvb3NlRmlsZUJ0bi5jbGljaygpXG4gICAgfVxuXG4gICAgaW1nUGxhY2Vob2xkZXIub25kcm9wID0gY2hvb3NlRmlsZUJ0bi5vbmNoYW5nZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIHZhciBjdXJyZW50SW1nID0gZ2V0SW1hZ2VPclBsYWNlaG9sZGVyQnlBQ2hpbGQoZS50YXJnZXQpLFxuICAgICAgICAgICAgc2VjdGlvbkVsZW1lbnQgPSBjdXJyZW50SW1nLnBhcmVudE5vZGU7XG5cbiAgICAgICAgaWYoIXNlY3Rpb25FbGVtZW50IHx8ICFkb2N1bWVudC5ib2R5LmNvbnRhaW5zKHNlY3Rpb25FbGVtZW50KSkge1xuICAgICAgICAgICAgc2VjdGlvbkVsZW1lbnQgPSBpbWFnZVNlY3Rpb25UeXBlLmVkaXRvci5mb2N1c2VkU2VjdGlvbigpO1xuICAgICAgICAgICAgY3VycmVudEltZyA9IHNlY3Rpb25FbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2ltZycpIHx8IHNlY3Rpb25FbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5pbWFnZS1pbWctcGxhY2Vob2xkZXInKVxuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudEltZy5jbGFzc0xpc3QucmVtb3ZlKCdkcmFnb3ZlcicpO1xuXG4gICAgICAgIHZhciBmaWxlcyA9IGUudGFyZ2V0LmZpbGVzIHx8IGUuZGF0YVRyYW5zZmVyLmZpbGVzO1xuXG4gICAgICAgIHZhciBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgdmFyIHBlcnNpc3RSZXN1bHQgPSBpbWFnZVNlY3Rpb25UeXBlLnBlcnNpc3RGaWxlKGZpbGVzWzBdKTtcblxuICAgICAgICBpZihwZXJzaXN0UmVzdWx0LnRoZW4pIHtcbiAgICAgICAgICAgIHBlcnNpc3RSZXN1bHQudGhlbih1cmwgPT4gaW1nLnNyYyA9IHVybCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbWcuc3JjID0gcGVyc2lzdFJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRJbWcucGFyZW50RWxlbWVudC5yZXBsYWNlQ2hpbGQoaW1nLCBjdXJyZW50SW1nKTtcbiAgICAgICAgaW1nLm9uZHJvcCA9IGN1cnJlbnRJbWcub25kcm9wO1xuICAgICAgICBpbWcub25kcmFnb3ZlciA9IGN1cnJlbnRJbWcub25kcmFnb3ZlcjtcbiAgICAgICAgaW1nLm9uZHJhZ2xlYXZlID0gY3VycmVudEltZy5vbmRyYWdsZWF2ZTtcbiAgICAgICAgaW1nLm9uY2xpY2sgPSBpbWdQbGFjZWhvbGRlci5vbmNsaWNrXG5cbiAgICAgICAgc2VjdGlvbkVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2ltYWdlLXVwbG9hZCcsIHtidWJibGVzOiB0cnVlLCBkZXRhaWw6IHt1cmw6IGltZy5zcmN9fSkpO1xuICAgICAgICBzZWN0aW9uRWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnaW5wdXQnLCB7YnViYmxlczogdHJ1ZX0pKTtcbiAgICB9XG5cbiAgICBpbWdQbGFjZWhvbGRlci5vbmRyYWdvdmVyID0gZnVuY3Rpb24oZSkgeyBnZXRJbWFnZU9yUGxhY2Vob2xkZXJCeUFDaGlsZChlLnRhcmdldCkuY2xhc3NMaXN0LmFkZCgnZHJhZ292ZXInKTsgZS5wcmV2ZW50RGVmYXVsdCgpOyB9XG4gICAgaW1nUGxhY2Vob2xkZXIub25kcmFnbGVhdmUgPSBmdW5jdGlvbihlKSB7IGdldEltYWdlT3JQbGFjZWhvbGRlckJ5QUNoaWxkKGUudGFyZ2V0KS5jbGFzc0xpc3QucmVtb3ZlKCdkcmFnb3ZlcicpOyBlLnByZXZlbnREZWZhdWx0KCk7IH1cblxuICAgIHJldHVybiBpbWdQbGFjZWhvbGRlcjtcbn1cblxudmFyIGdldFNlY3Rpb25FbGVtZW50ID0gZnVuY3Rpb24oZXhpc3RpbmdTZWN0aW9uQ29udGVudCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ZpZ3VyZScpLFxuICAgICAgICBjYXB0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZmlnY2FwdGlvbicpO1xuXG4gICAgZWwuaWQgPSB1dWlkKCk7XG4gICAgZWwuc2VjdGlvblR5cGUgPSBpbWFnZVNlY3Rpb25UeXBlO1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnZGlzcGxheS1jYXB0aW9uJywgJ1llcycpO1xuICAgIGNhcHRpb24uaW5uZXJIVE1MID0gJ2ltYWdlIHRpdGxlJztcbiAgICBlbC5hcHBlbmRDaGlsZChidWlsZEVtcHR5SW1nUGxhY2Vob2RlcigpKTtcbiAgICBlbC5hcHBlbmRDaGlsZChjYXB0aW9uKTtcbiAgICBlbC5vbktleUJhY2tzcGFjZSA9IGltYWdlU2VjdGlvblR5cGUub25LZXlCYWNrc3BhY2U7XG4gICAgZWwub25LZXlFbnRlciA9IGltYWdlU2VjdGlvblR5cGUub25LZXlFbnRlcjtcblxuICAgIHJldHVybiBlbDtcbn1cblxuaW1hZ2VTZWN0aW9uVHlwZSA9IHtcblxuICAgIG5hbWU6ICdpbWcnLFxuXG4gICAgY29udGVudFJ1bGVzOiB7XG4gICAgICAgICdpbWFnZSc6IHtcbiAgICAgICAgICAgIHRhZ05hbWU6ICdmaWd1cmUnLFxuICAgICAgICAgICAgYWxsb3dlZEF0dHJpYnV0ZXM6IFsnY2xhc3MnLCAnZGlzcGxheS1jYXB0aW9uJywgJ2lkJ10sXG4gICAgICAgICAgICBhbGxvd2VkQ2xhc3NOYW1lczogWydmb2N1c2VkJ10sXG4gICAgICAgICAgICBhbGxvd2VkQ2hpbGRyZW46IFsnaW1hZ2UtaW1nJywgJ2ltYWdlLWNhcHRpb24nLCAnaW1hZ2UtaW1nLXBsYWNlaG9sZGVyJ10sXG4gICAgICAgICAgICBjaGlsZHJlbkNhcmRpbmFsaXR5OiB7J2ltYWdlLWNhcHRpb24nOiB7bWF4OiAxfSwgJ2ltYWdlLWltZy1wbGFjZWhvbGRlcic6IHttYXg6IDF9fSxcbiAgICAgICAgICAgIGFsbG93ZWRUb0JlUm9vdDogdHJ1ZSxcbiAgICAgICAgICAgIGRlbGV0ZUlmRW1wdHk6IGZhbHNlLFxuICAgICAgICAgICAgYnVpbGRFbXB0eUVsZW1lbnQ6IGdldFNlY3Rpb25FbGVtZW50LFxuICAgICAgICAgICAgYnVpbGRBdHRyaWJ1dGVzOiBbXG4gICAgICAgICAgICAgICAge25hbWU6ICdpZCcsIGJ1aWxkOiBmdW5jdGlvbigpIHtyZXR1cm4gdXVpZCgpfX0sXG4gICAgICAgICAgICAgICAge25hbWU6ICdkaXNwbGF5LWNhcHRpb24nLCBidWlsZDogZnVuY3Rpb24oKSB7cmV0dXJuICdZZXMnfX1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgJ2ltYWdlLWltZyc6IHtcbiAgICAgICAgICAgIHRhZ05hbWU6ICdpbWcnLFxuICAgICAgICAgICAgYWxsb3dlZEF0dHJpYnV0ZXM6IFsnc3JjJ10sXG4gICAgICAgICAgICBhbGxvd2VkU3VjY2Vzc29yczogWydpbWFnZS1jYXB0aW9uJ10sXG4gICAgICAgICAgICBhbGxvd2VkQ2hpbGRyZW46IFtdXG4gICAgICAgIH0sXG4gICAgICAgICdpbWFnZS1pbWctcGxhY2Vob2xkZXInOiB7XG4gICAgICAgICAgICB0YWdOYW1lOiAnc3BhbicsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdpbWFnZS1pbWctcGxhY2Vob2xkZXInLFxuICAgICAgICAgICAgYWxsb3dlZEF0dHJpYnV0ZXM6IFsnY2xhc3MnLCAnY29udGVudGVkaXRhYmxlJ10sXG4gICAgICAgICAgICBhbGxvd2VkQ2xhc3NOYW1lczogWydpbWFnZS1pbWctcGxhY2Vob2xkZXInXSxcbiAgICAgICAgICAgIGFsbG93ZWRTdWNjZXNzb3JzOiBbJ2ltYWdlLWNhcHRpb24nXSxcbiAgICAgICAgICAgIGFsbG93ZWRDaGlsZHJlbjogWydlbXB0eS1pbWFnZScsICdjaG9vc2UtaW1nLWJ0bicsICdjaG9vc2UtaW1nLWJ0bi1sYWJlbCddLFxuICAgICAgICAgICAgZGVsZXRlSWZFbXB0eTogZmFsc2UsXG4gICAgICAgICAgICBidWlsZEVtcHR5RWxlbWVudDogYnVpbGRFbXB0eUltZ1BsYWNlaG9kZXJcbiAgICAgICAgfSxcbiAgICAgICAgJ2VtcHR5LWltYWdlJzoge1xuICAgICAgICAgICAgdGFnTmFtZTogJ2knLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAnZW1wdHktaW1hZ2UnLFxuICAgICAgICAgICAgYWxsb3dlZEF0dHJpYnV0ZXM6IFsnY2xhc3MnXSxcbiAgICAgICAgICAgIGFsbG93ZWRDbGFzc05hbWVzOiBbJ2VtcHR5LWltYWdlJ10sXG4gICAgICAgICAgICBhbGxvd2VkQ2hpbGRyZW46IFtdLFxuICAgICAgICAgICAgZGVsZXRlSWZFbXB0eTogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICAgICdjaG9vc2UtaW1nLWJ0bic6IHtcbiAgICAgICAgICAgIHRhZ05hbWU6ICdpbnB1dCcsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdjaG9vc2UtaW1nLWJ0bicsXG4gICAgICAgICAgICBhbGxvd2VkQXR0cmlidXRlczogWydjbGFzcycsICd0eXBlJywgJ2lkJ10sXG4gICAgICAgICAgICBhbGxvd2VkQ2xhc3NOYW1lczogWydjaG9vc2UtaW1nLWJ0biddLFxuICAgICAgICAgICAgZGVsZXRlSWZFbXB0eTogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgJ2Nob29zZS1pbWctYnRuLWxhYmVsJzoge1xuICAgICAgICAgICAgdGFnTmFtZTogJ2xhYmVsJyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2Nob29zZS1pbWctYnRuLWxhYmVsJyxcbiAgICAgICAgICAgIGFsbG93ZWRDbGFzc05hbWVzOiBbJ2Nob29zZS1pbWctYnRuLWxhYmVsJ10sXG4gICAgICAgICAgICBhbGxvd2VkQXR0cmlidXRlczogWydjbGFzcyddLFxuICAgICAgICAgICAgYWxsb3dlZENoaWxkcmVuOiBbJyN0ZXh0J11cbiAgICAgICAgfSxcbiAgICAgICAgJ2ltYWdlLWNhcHRpb24nOiB7XG4gICAgICAgICAgICB0YWdOYW1lOiAnZmlnY2FwdGlvbicsXG4gICAgICAgICAgICBhbGxvd2VkQ2hpbGRyZW46IFsnI3RleHQnLCAncmVmZXJlbmNlJywgJ2lubGluZWVxdWF0aW9uJ10sXG4gICAgICAgICAgICBhbGxvd2VkUHJlZGVjZXNzb3JzOiBbJ2ltYWdlLWltZy1wbGFjZWhvbGRlcicsICdpbWFnZS1pbWcnXSxcbiAgICAgICAgICAgIGRlbGV0ZUlmRW1wdHk6IGZhbHNlLFxuICAgICAgICAgICAgcHJ1bmVTcGFjZXM6IHRydWVcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBlbnJpY2htZW50czogW10sXG5cbiAgICBnZXRPcHRpb25zOiBmdW5jdGlvbihzZWN0aW9uRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBuYW1lOiAnZGlzcGxheUNhcHRpb24nLFxuICAgICAgICAgICAgICBkaXNwbGF5TmFtZTogJ0Rpc3BsYXkgSW1hZ2UgQ2FwdGlvbicsXG4gICAgICAgICAgICAgIGFsbG93ZWRWYWx1ZXM6IFsnWWVzJywgJ05vJ10sXG4gICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogc2VjdGlvbkVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkaXNwbGF5LWNhcHRpb24nKVxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcblxuICAgIG9uT3B0aW9uc0NoYW5nZTogZnVuY3Rpb24ob3B0LCBlZGl0b3IpIHtcbiAgICAgICAgdmFyIHNlY3Rpb24gPSBlZGl0b3IuZm9jdXNlZFNlY3Rpb24oKTtcbiAgICAgICAgaWYob3B0LmRpc3BsYXlDYXB0aW9uID09PSAnWWVzJyB8fCBvcHQuZGlzcGxheUNhcHRpb24gPT09ICdObycpIHtcbiAgICAgICAgICAgIHNlY3Rpb24uc2V0QXR0cmlidXRlKCdkaXNwbGF5LWNhcHRpb24nLCBvcHQuZGlzcGxheUNhcHRpb24pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNldEVkaXRvcjogZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcGVyc2lzdEZpbGU6IGZ1bmN0aW9uKGJsb2IpIHtcbiAgICAgICAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgfSxcblxuICAgIG9uS2V5QmFja3NwYWNlOiBmdW5jdGlvbihlLCBlZGl0b3IpIHtcbiAgICAgICAgdmFyIGNhcHRpb24gPSBlZGl0b3IuY2FyZXQuZ2V0Q29udGV4dEVsZW1lbnQoJ2ZpZ2NhcHRpb24nKTtcbiAgICAgICAgaWYoY2FwdGlvbi5pbm5lclRleHQgPT09ICcnKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgb25LZXlFbnRlcjogZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSxcblxuICAgIG9uRm9jdXM6IGZ1bmN0aW9uKGVsLCBlZGl0b3IsIGFyZ3MpIHtcbiAgICAgICAgdmFyIGNhcHRpb24gPSBlbC5xdWVyeVNlbGVjdG9yKCdmaWdjYXB0aW9uJyksXG4gICAgICAgICAgICBpc0NhcmV0SW5zaWRlU2VjdGlvbiA9IChlZGl0b3Iuc2VjdGlvbkF0Q2FyZXRQb3N0aW9uKCkgPT09IGVsICYmIGVkaXRvci5jYXJldC5nZXRDb250ZXh0RWxlbWVudCgnZmlnY2FwdGlvbicpKSxcbiAgICAgICAgICAgIGhhc0JlZW5Gb2N1c2VkQWZ0ZXJTZWN0aW9uVHlwZUNoYW5nZSA9IGFyZ3MuYWN0aW9uID09PSAnY2hhbmdlRm9jdXNlZFNlY3Rpb25UeXBlJztcblxuICAgICAgICBpZihoYXNCZWVuRm9jdXNlZEFmdGVyU2VjdGlvblR5cGVDaGFuZ2UgfHwgIWlzQ2FyZXRJbnNpZGVTZWN0aW9uKSB7XG4gICAgICAgICAgICBjYXB0aW9uICYmIGVkaXRvci5jYXJldC5wb3NpdGlvbkluKGNhcHRpb24pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldFNlY3Rpb25FbGVtZW50OiBnZXRTZWN0aW9uRWxlbWVudFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGltYWdlU2VjdGlvblR5cGU7XG4iLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi4vc2hhcmVkL3NoYXJlZCcpO1xudmFyIHVub3JkZXJlZExpc3RTZWN0aW9uVHlwZSA9IHJlcXVpcmUoJy4vdW5vcmRlcmVkX2xpc3Rfc2VjdGlvbl90eXBlJyk7XG5cbnZhciBnZXRTZWN0aW9uRWxlbWVudCA9IGZ1bmN0aW9uKGV4aXN0aW5nU2VjdGlvbkNvbnRlbnQpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvbCcpO1xuICAgIGVsLm9uS2V5VXAgPSBtb2R1bGUuZXhwb3J0cy5vbktleVVwO1xuICAgIGVsLm9uS2V5RG93biA9IG1vZHVsZS5leHBvcnRzLm9uS2V5RG93bjtcbiAgICBlbC5vbktleUVudGVyID0gbW9kdWxlLmV4cG9ydHMub25LZXlFbnRlcjtcbiAgICBlbC5vbktleVRhYiA9IG1vZHVsZS5leHBvcnRzLm9uS2V5VGFiO1xuICAgIGVsLm9uS2V5QmFja3NwYWNlID0gbW9kdWxlLmV4cG9ydHMub25LZXlCYWNrc3BhY2U7XG4gICAgZWwuaW5uZXJIVE1MID0gJzxsaT4nICsgZXhpc3RpbmdTZWN0aW9uQ29udGVudCArICc8L2xpPic7XG4gICAgcmV0dXJuIGVsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIG5hbWU6ICdvbCcsXG5cbiAgICBjb250ZW50UnVsZXM6IHtcbiAgICAgICAgJ29sJzoge1xuICAgICAgICAgICAgdGFnTmFtZTogJ29sJyxcbiAgICAgICAgICAgIGFsbG93ZWRBdHRyaWJ1dGVzOiBbJ2NsYXNzJ10sXG4gICAgICAgICAgICBhbGxvd2VkQ2xhc3NOYW1lczogWydmb2N1c2VkJ10sXG4gICAgICAgICAgICBhbGxvd2VkQ2hpbGRyZW46IFsnbGknLCAnb2wnXSxcbiAgICAgICAgICAgIGFsbG93ZWRUb0JlUm9vdDogdHJ1ZSxcbiAgICAgICAgICAgIGJ1aWxkRW1wdHlFbGVtZW50OiBnZXRTZWN0aW9uRWxlbWVudFxuICAgICAgICB9LFxuICAgICAgICAnbGknOiB7XG4gICAgICAgICAgICB0YWdOYW1lOiAnbGknLFxuICAgICAgICAgICAgcHJ1bmVTcGFjZXM6IHRydWUsXG4gICAgICAgICAgICBkb05vdEJyZWFrT3V0Um9vdEVsZW1lbnRzOiB0cnVlLFxuICAgICAgICAgICAgYWxsb3dlZENoaWxkcmVuOiBbJyN0ZXh0JywgJ2xpbmsnLCAnYicsICdpJywgJ3UnLCAncmVmZXJlbmNlJywgJ2Zvb3Rub3RlJywgJ2lubGluZWNvZGUnLCAnaW5saW5lZXF1YXRpb24nXSxcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBlbnJpY2htZW50czogW10sXG5cbiAgICBnZXRTZWN0aW9uRWxlbWVudDogZ2V0U2VjdGlvbkVsZW1lbnQsXG4gICAgaW5kZW50Rm9jdXNlZExpc3RJdGVtOiB1bm9yZGVyZWRMaXN0U2VjdGlvblR5cGUuaW5kZW50Rm9jdXNlZExpc3RJdGVtLFxuICAgIG9uS2V5VXA6IHVub3JkZXJlZExpc3RTZWN0aW9uVHlwZS5vbktleVVwLFxuICAgIG9uS2V5RG93bjogdW5vcmRlcmVkTGlzdFNlY3Rpb25UeXBlLm9uS2V5RG93bixcbiAgICBvbktleUJhY2tzcGFjZTogdW5vcmRlcmVkTGlzdFNlY3Rpb25UeXBlLm9uS2V5QmFja3NwYWNlLFxuICAgIG9uS2V5RW50ZXI6IGZ1bmN0aW9uKGUpIHt9LFxuICAgIG9uS2V5VGFiOiB1bm9yZGVyZWRMaXN0U2VjdGlvblR5cGUub25LZXlUYWJcbn1cbiIsInZhciBzaGFyZWQgPSByZXF1aXJlKCcuLi9zaGFyZWQvc2hhcmVkJyksXG4gICAgcGFyYWdyYXBoU2VjdGlvblR5cGUgPSByZXF1aXJlKCcuLi9wYXJhZ3JhcGgvcGFyYWdyYXBoX3NlY3Rpb25fdHlwZScpO1xuXG52YXIgZ2V0U2VjdGlvbkVsZW1lbnQgPSBmdW5jdGlvbihleGlzdGluZ1NlY3Rpb25Db250ZW50KSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcbiAgICBlbC5vbktleVVwID0gbW9kdWxlLmV4cG9ydHMub25LZXlVcDtcbiAgICBlbC5vbktleURvd24gPSBtb2R1bGUuZXhwb3J0cy5vbktleURvd247XG4gICAgZWwub25LZXlFbnRlciA9IG1vZHVsZS5leHBvcnRzLm9uS2V5RW50ZXI7XG4gICAgZWwub25LZXlUYWIgPSBtb2R1bGUuZXhwb3J0cy5vbktleVRhYjtcbiAgICBlbC5vbktleUJhY2tzcGFjZSA9IG1vZHVsZS5leHBvcnRzLm9uS2V5QmFja3NwYWNlO1xuICAgIGVsLmlubmVySFRNTCA9ICc8bGk+JyArIGV4aXN0aW5nU2VjdGlvbkNvbnRlbnQgKyAnPC9saT4nO1xuICAgIHJldHVybiBlbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICBuYW1lOiAndWwnLFxuXG4gICAgY29udGVudFJ1bGVzOiB7XG4gICAgICAgICd1bCc6IHtcbiAgICAgICAgICAgIHRhZ05hbWU6ICd1bCcsXG4gICAgICAgICAgICBhbGxvd2VkQXR0cmlidXRlczogWydjbGFzcyddLFxuICAgICAgICAgICAgYWxsb3dlZENsYXNzTmFtZXM6IFsnZm9jdXNlZCddLFxuICAgICAgICAgICAgYWxsb3dlZENoaWxkcmVuOiBbJ2xpJywgJ3VsJ10sXG4gICAgICAgICAgICBhbGxvd2VkVG9CZVJvb3Q6IHRydWUsXG4gICAgICAgICAgICBidWlsZEVtcHR5RWxlbWVudDogZ2V0U2VjdGlvbkVsZW1lbnRcbiAgICAgICAgfSxcbiAgICAgICAgLy8gVGhlIGxpIGNvbnRlbnQgcnVsZXMgYXJlIGRlZmluZWQgaW4gdGhlIG9yZGVyZWQgbGlzdCBzZWN0aW9uIHR5cGVcbiAgICAgICAgLy8gJ2xpJzoge31cbiAgICB9LFxuXG4gICAgZW5yaWNobWVudHM6IFtdLFxuXG4gICAgZ2V0U2VjdGlvbkVsZW1lbnQ6IGdldFNlY3Rpb25FbGVtZW50LFxuXG4gICAgb25LZXlVcDogcGFyYWdyYXBoU2VjdGlvblR5cGUub25LZXlVcCxcbiAgICBvbktleURvd246IHBhcmFncmFwaFNlY3Rpb25UeXBlLm9uS2V5RG93bixcblxuICAgIG9uS2V5QmFja3NwYWNlOiBmdW5jdGlvbihlLCBlZGl0b3IpIHtcbiAgICAgICAgdmFyIGZvY3VzZWRTZWN0aW9uID0gZWRpdG9yLmZvY3VzZWRTZWN0aW9uKCksXG4gICAgICAgICAgICB1cHBlclNlY3Rpb24sXG4gICAgICAgICAgICBhbGxMaXN0SXRlbXMsXG4gICAgICAgICAgICB0YXJnZXRMaXN0SXRlbSA9IGVkaXRvci5jYXJldC5nZXRDb250ZXh0RWxlbWVudCgnbGknKSxcbiAgICAgICAgICAgIHRhcmdldExpc3RJdGVtSW5kZXgsXG4gICAgICAgICAgICB1cHBlckxpc3RJdGVtO1xuXG4gICAgICAgIGlmKHRhcmdldExpc3RJdGVtICYmIHRhcmdldExpc3RJdGVtLmlubmVyVGV4dC50cmltKCkgPT09ICcnKSB7XG4gICAgICAgICAgICB1cHBlclNlY3Rpb24gPSBmb2N1c2VkU2VjdGlvbi5wcmV2aW91c1NpYmxpbmcsXG4gICAgICAgICAgICBhbGxMaXN0SXRlbXMgPSBmb2N1c2VkU2VjdGlvbi5xdWVyeVNlbGVjdG9yQWxsKCdsaScpLFxuICAgICAgICAgICAgdGFyZ2V0TGlzdEl0ZW1JbmRleCA9IGFsbExpc3RJdGVtcy5pbmRleE9mKHRhcmdldExpc3RJdGVtKSxcbiAgICAgICAgICAgIHVwcGVyTGlzdEl0ZW0gPSBhbGxMaXN0SXRlbXNbdGFyZ2V0TGlzdEl0ZW1JbmRleC0xXTtcblxuICAgICAgICAgICAgaWYodXBwZXJMaXN0SXRlbSkge1xuICAgICAgICAgICAgICAgIGVkaXRvci5jYXJldC5wb3NpdGlvbkluKHVwcGVyTGlzdEl0ZW0pO1xuICAgICAgICAgICAgICAgIHRhcmdldExpc3RJdGVtLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIGVkaXRvci5yZXBsYWNlU2VjdGlvbldpdGhIVE1MKGZvY3VzZWRTZWN0aW9uLCBmb2N1c2VkU2VjdGlvbi5vdXRlckhUTUwpO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZih1cHBlclNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRMaXN0SXRlbS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBlZGl0b3IucmVwbGFjZVNlY3Rpb25XaXRoSFRNTChmb2N1c2VkU2VjdGlvbiwgZm9jdXNlZFNlY3Rpb24ub3V0ZXJIVE1MKTtcbiAgICAgICAgICAgICAgICBlZGl0b3IuY2FyZXQucG9zaXRpb25Jbih1cHBlclNlY3Rpb24pO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG9uS2V5RW50ZXI6IGZ1bmN0aW9uKGUpIHt9LFxuICAgIG9uS2V5VGFiOiBmdW5jdGlvbihlLCBlZGl0b3IpICB7XG4gICAgICAgIGlmKCFlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cy5pbmRlbnRGb2N1c2VkTGlzdEl0ZW0oZWRpdG9yKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ291dGRlbnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuXG4gICAgaW5kZW50Rm9jdXNlZExpc3RJdGVtOiBmdW5jdGlvbiAoZWRpdG9yKSB7XG4gICAgICAgIHZhciB0YXJnZXRMaXN0SXRlbSA9IGVkaXRvci5jYXJldC5nZXRDb250ZXh0RWxlbWVudCgnbGknKSxcbiAgICAgICAgICAgIHByZXZpb3VzTGlzdEl0ZW0sIG5leHRMaXN0SXRlbSwgcGFyZW50RWxlbWVudCxcbiAgICAgICAgICAgIGlzVGFyZ2V0TGlzdEl0ZW1FbXB0eSA9IHRhcmdldExpc3RJdGVtLmlubmVyVGV4dCA9PT0gJyc7XG5cbiAgICAgICAgaWYodGFyZ2V0TGlzdEl0ZW0pIHtcbiAgICAgICAgICAgIHByZXZpb3VzTGlzdEl0ZW0gPSB0YXJnZXRMaXN0SXRlbS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICBuZXh0TGlzdEl0ZW0gPSB0YXJnZXRMaXN0SXRlbS5uZXh0U2libGluZztcbiAgICAgICAgICAgIHBhcmVudEVsZW1lbnQgPSB0YXJnZXRMaXN0SXRlbS5wYXJlbnRFbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ2luZGVudCcpO1xuXG4gICAgICAgIGlmKGlzVGFyZ2V0TGlzdEl0ZW1FbXB0eSkge1xuICAgICAgICAgICAgaWYocHJldmlvdXNMaXN0SXRlbSAmJiBwcmV2aW91c0xpc3RJdGVtLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgZWRpdG9yLmNhcmV0LnBvc2l0aW9uSW4ocHJldmlvdXNMaXN0SXRlbS5uZXh0U2libGluZyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYobmV4dExpc3RJdGVtICYmIG5leHRMaXN0SXRlbS5wcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICBlZGl0b3IuY2FyZXQucG9zaXRpb25JbihuZXh0TGlzdEl0ZW0ucHJldmlvdXNTaWJsaW5nKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZighcHJldmlvdXNMaXN0SXRlbSAmJiAhbmV4dExpc3RJdGVtICYmIHBhcmVudEVsZW1lbnQgJiYgcGFyZW50RWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgZWRpdG9yLmNhcmV0LnBvc2l0aW9uSW4ocGFyZW50RWxlbWVudC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbiIsInZhciBjb2RlMmRpYSA9IHJlcXVpcmUoJy4uL3NoYXJlZC9jb2RlMmRpYV9zZWN0aW9uX3R5cGUnKSxcbiAgICAvLyBtZXJtYWlkID0gcmVxdWlyZSgnbWVybWFpZCcpLCAvLyBtYWtlIHN1cmUgdG8gbG9hZCA8c2NyaXB0IHNyYz1cIi4vbWVybWFpZC5qc1wiIGRlZmVyPjwvc2NyaXB0PiBpbiB5b3VyIGh0bWxcbiAgICByZW5kZXI7XG5cbmZ1bmN0aW9uIGRvY1JlYWR5KGZuKSB7XG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiB8fCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImludGVyYWN0aXZlXCIpIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgZm4pO1xuICAgIH1cbn1cblxuZG9jUmVhZHkoZnVuY3Rpb24oKSB7XG4gICAgbWVybWFpZC5pbml0aWFsaXplKHsgc3RhcnRPbkxvYWQ6IGZhbHNlLCAnZm9udC1zaXplJzogJzEwcHgnIH0pXG59KVxuXG5yZW5kZXIgPSBmdW5jdGlvbihyZW5kZXJFbCwgY29udGVudCkge1xuICAgIHZhciB0bXBDb250YWluZXIsIGlkO1xuXG4gICAgaWYoY29udGVudC50cmltKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJlbmRlckVsLmlubmVySFRNTCA9ICdXcml0ZSBzb21lIG1lcm1haWQgaGVyZSA8c3BhbiBjbGFzcz1cImFycm93XCI+JiMxMDU0ODs8L3NwYW4+JztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZW5kZXJFbC5pZCA9IHJlbmRlckVsLmlkIHx8ICd0ZXN0Mic7XG4gICAgICAgIGlkID0gJ3InICsgcmVuZGVyRWwucGFyZW50RWxlbWVudC5pZDtcbiAgICAgICAgcmVuZGVyRWwuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIHJlbmRlckVsLmNsYXNzTGlzdC5hZGQoJ21lcm1haWQnKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbWVybWFpZC5yZW5kZXIoaWQsIGNvbnRlbnQsIChyZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJlbmRlckVsLmlubmVySFRNTCA9IHJlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICByZW5kZXJFbC5pbm5lckhUTUwgPSBleC5tZXNzYWdlLnJlcGxhY2UoL1xcbi9nLCAnPGJyLz4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRtcENvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkJyArIGlkKTtcbiAgICAgICAgaWYodG1wQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB0bXBDb250YWluZXIucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29kZTJkaWEocmVuZGVyLCAnbWVybWFpZCcsICdsYXRleCcsICdpbWFnZSB0aXRsZScpXG4iLCJ2YXIgZ2V0U2VjdGlvbkVsZW1lbnQgPSBmdW5jdGlvbihleGlzdGluZ1NlY3Rpb25Db250ZW50KSB7XG4gICAgZXhpc3RpbmdTZWN0aW9uQ29udGVudCA9IGV4aXN0aW5nU2VjdGlvbkNvbnRlbnQgfHwgJyc7XG4gICAgZXhpc3RpbmdTZWN0aW9uQ29udGVudCA9IGV4aXN0aW5nU2VjdGlvbkNvbnRlbnQucmVwbGFjZSgvPGNhcHRpb24+Lio/PFxcL2NhcHRpb24+LywgJycpO1xuXG4gICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuICAgIGVsLmlubmVySFRNTCA9IGV4aXN0aW5nU2VjdGlvbkNvbnRlbnQ7XG4gICAgZWwub25LZXlVcCA9IG1vZHVsZS5leHBvcnRzLm9uS2V5VXA7XG4gICAgZWwub25LZXlEb3duID0gbW9kdWxlLmV4cG9ydHMub25LZXlEb3duO1xuICAgIHJldHVybiBlbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICBuYW1lOiAncCcsXG5cbiAgICBjb250ZW50UnVsZXM6IHtcbiAgICAgICAgJ3AnOiB7XG4gICAgICAgICAgICB0YWdOYW1lOiAncCcsXG4gICAgICAgICAgICBhbGxvd2VkQXR0cmlidXRlczogWydjbGFzcyddLFxuICAgICAgICAgICAgYWxsb3dlZENsYXNzTmFtZXM6IFsnZm9jdXNlZCddLFxuICAgICAgICAgICAgYWxsb3dlZENoaWxkcmVuOiBbJyN0ZXh0JywgJ2InLCAnaScsICd1JywgJ2xpbmsnLCAnZm9vdG5vdGUnLCAncmVmZXJlbmNlJywgJ2lubGluZWNvZGUnLCAnaW5saW5lZXF1YXRpb24nXSxcbiAgICAgICAgICAgIHBydW5lU3BhY2VzOiB0cnVlLFxuICAgICAgICAgICAgYWxsb3dlZFRvQmVSb290OiB0cnVlLFxuICAgICAgICAgICAgYnVpbGRFbXB0eUVsZW1lbnQ6IGdldFNlY3Rpb25FbGVtZW50XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZW5yaWNobWVudHM6IFtdLFxuXG4gICAgb25LZXlVcDogZnVuY3Rpb24oZSwgZWRpdG9yKSB7XG4gICAgICAgIGlmKGVkaXRvci5jYXJldC5pc0NvbGxhcHNlZEFuZFBvc2l0aW9uZWRBdFRoZUZpcnN0TGluZU9mKGVkaXRvci5mb2N1c2VkU2VjdGlvbigpKSkge1xuICAgICAgICAgICAgZWRpdG9yLm1vdmVDYXJldE9uZVNlY3Rpb25VcCgnZW5kJyk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgb25LZXlEb3duOiBmdW5jdGlvbihlLCBlZGl0b3IpIHtcbiAgICAgICAgaWYoZWRpdG9yLmNhcmV0LmlzQ29sbGFwc2VkQW5kUG9zaXRpb25lZEF0VGhlTGFzdExpbmVPZihlZGl0b3IuZm9jdXNlZFNlY3Rpb24oKSkpIHtcbiAgICAgICAgICAgIGVkaXRvci5tb3ZlQ2FyZXRPbmVTZWN0aW9uRG93bigncHJlZmVycmVkT3JCZWdpbm5pbmcnKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRTZWN0aW9uRWxlbWVudDogZ2V0U2VjdGlvbkVsZW1lbnQsXG59XG4iLCJ2YXIgSFRNTFJhem9yID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL2h0bWxfcmF6b3IvaHRtbF9yYXpvcicpLFxuICAgIHRocm90dGxlID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL3Rocm90dGxlL3Rocm90dGxlJyksXG4gICAgY29kZVNlY3Rpb25UeXBlID0gcmVxdWlyZSgnLi4vY29kZS9jb2RlX3NlY3Rpb25fdHlwZScpLFxuICAgIHByaW1zanMgPSByZXF1aXJlKCdwcmlzbWpzJyksXG4gICAgdXVpZCA9IHJlcXVpcmUoJ3V1aWQvdjEnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihyZW5kZXIsIHRhZ05hbWUsIHN5bnRheEhpZ2hsaWdodGluZywgZGVmYXVsdENhcHRpb24pIHtcbiAgICB2YXIgc2VjdGlvblR5cGUgPSB7fTtcblxuICAgIHZhciBnZXRTZWN0aW9uRWxlbWVudCA9IGZ1bmN0aW9uKGV4aXN0aW5nU2VjdGlvbkNvbnRlbnQsIGRpcmVjdGl2ZXMsIHJ1bGUpIHtcbiAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChydWxlLnRhZ05hbWUpLFxuICAgICAgICAgICAgcHJlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncHJlJylcbiAgICAgICAgICAgIGNhcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYXB0aW9uJyksXG4gICAgICAgICAgICBpbnB1dEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY29kZScpO1xuXG4gICAgICAgIGNhcHRpb24uY2xhc3NMaXN0LmFkZCgnbTJkaWEtY2FwdGlvbicpO1xuICAgICAgICBpbnB1dEVsLmNsYXNzTGlzdC5hZGQoJ20yZGlhLWNvZGUnKTtcbiAgICAgICAgcHJlLmNsYXNzTGlzdC5hZGQoJ20yZGlhLXByZScpO1xuXG4gICAgICAgIGNhcHRpb24uaW5uZXJIVE1MID0gcnVsZS5kZWZhdWx0Q2FwdGlvbiB8fCAnY2FwdGlvbic7XG5cbiAgICAgICAgcHJlLmFwcGVuZENoaWxkKGlucHV0RWwpO1xuICAgICAgICBlbC5hcHBlbmRDaGlsZChwcmUpO1xuICAgICAgICBlbC5hcHBlbmRDaGlsZChjYXB0aW9uKTtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdkaXNwbGF5LWNhcHRpb24nLCAnWWVzJyk7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQocnVsZS50YWdOYW1lKTtcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgnbTJkaWEnKTtcbiAgICAgICAgZWwuaWQgPSB1dWlkKCk7XG5cbiAgICAgICAgZWwub25Gb2N1cyA9IHNlY3Rpb25UeXBlLm9uRm9jdXM7XG4gICAgICAgIGVsLm9uS2V5VXAgPSBzZWN0aW9uVHlwZS5vbktleVVwO1xuICAgICAgICBlbC5vbktleURvd24gPSBzZWN0aW9uVHlwZS5vbktleURvd247XG4gICAgICAgIGVsLm9uS2V5RW50ZXIgPSBzZWN0aW9uVHlwZS5vbktleUVudGVyO1xuICAgICAgICBlbC5vbktleVRhYiA9IHNlY3Rpb25UeXBlLm9uS2V5VGFiO1xuICAgICAgICBlbC5vbktleUJhY2tzcGFjZSA9IHNlY3Rpb25UeXBlLm9uS2V5QmFja3NwYWNlO1xuICAgICAgICBlbC5vbk1hcmt1cENsZWFuaW5nRmluc2hlZCA9IHNlY3Rpb25UeXBlLm9uTWFya3VwQ2xlYW5pbmdGaW5zaGVkO1xuICAgICAgICBlbC5zZXRDb250ZW50ZWRpdGFibGUgPSBzZWN0aW9uVHlwZS5zZXRDb250ZW50ZWRpdGFibGU7XG4gICAgICAgIGVsLnNlY3Rpb25UeXBlID0gc2VjdGlvblR5cGU7XG5cbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH07XG5cbiAgICBPYmplY3QuYXNzaWduKHNlY3Rpb25UeXBlLCB7XG4gICAgICAgIG5hbWU6IHRhZ05hbWUsXG5cbiAgICAgICAgY29udGVudFJ1bGVzOiB7XG4gICAgICAgICAgICAnbTJkaWEtcHJlJzoge1xuICAgICAgICAgICAgICAgIHRhZ05hbWU6ICdwcmUnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ20yZGlhLXByZScsXG4gICAgICAgICAgICAgICAgYWxsb3dlZEF0dHJpYnV0ZXM6IFsnY2xhc3MnXSxcbiAgICAgICAgICAgICAgICBhbGxvd2VkQ2xhc3NOYW1lczogWydtMmRpYS1wcmUnXSxcbiAgICAgICAgICAgICAgICBhbGxvd2VkQ2hpbGRyZW46IFsnbTJkaWEtY29kZSddLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdtMmRpYS1jb2RlJzoge1xuICAgICAgICAgICAgICAgIHRhZ05hbWU6ICdjb2RlJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdtMmRpYS1jb2RlJyxcbiAgICAgICAgICAgICAgICBhbGxvd2VkQ2xhc3NOYW1lczogWydtMmRpYS1jb2RlJ10sXG4gICAgICAgICAgICAgICAgYWxsb3dlZEF0dHJpYnV0ZXM6IFsnY2xhc3MnXSxcbiAgICAgICAgICAgICAgICBhbGxvd2VkQ2hpbGRyZW46IFsnI3RleHQnXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbTJkaWEtY2FwdGlvbic6IHtcbiAgICAgICAgICAgICAgICB0YWdOYW1lOiAnY2FwdGlvbicsXG4gICAgICAgICAgICAgICAgYWxsb3dlZEF0dHJpYnV0ZXM6IFsnY2xhc3MnXSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdtMmRpYS1jYXB0aW9uJyxcbiAgICAgICAgICAgICAgICBhbGxvd2VkQ2xhc3NOYW1lczogWydtMmRpYS1jYXB0aW9uJ10sXG4gICAgICAgICAgICAgICAgYWxsb3dlZENoaWxkcmVuOiBbJyN0ZXh0JywgJ3JlZmVyZW5jZScsICdpbmxpbmVlcXVhdGlvbiddLFxuICAgICAgICAgICAgICAgIGRlbGV0ZUlmRW1wdHk6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHBydW5lU3BhY2VzOiB0cnVlLFxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGVucmljaG1lbnRzOiBbXSxcblxuICAgICAgICBvbk1hcmt1cENsZWFuaW5nRmluc2hlZDogZnVuY3Rpb24oc2VjdGlvbkVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBjb2RlRWwgPSBzZWN0aW9uRWxlbWVudC5xdWVyeVNlbGVjdG9yKCdjb2RlJyksXG4gICAgICAgICAgICAgICAgcHJlRWwgPSBzZWN0aW9uRWxlbWVudC5xdWVyeVNlbGVjdG9yKCdwcmUnKSxcbiAgICAgICAgICAgICAgICByZW5kZXJFbCA9IHNlY3Rpb25FbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5yZW5kZXInKSxcbiAgICAgICAgICAgICAgICBsYW4gPSBzeW50YXhIaWdobGlnaHRpbmcsXG4gICAgICAgICAgICAgICAgY29udGVudDtcblxuICAgICAgICAgICAgaWYoIWNvZGVFbCkgeyByZXR1cm4gfVxuXG4gICAgICAgICAgICBpZighcmVuZGVyRWwpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgIHJlbmRlckVsLmNsYXNzTGlzdC5hZGQoJ3JlbmRlcicpO1xuICAgICAgICAgICAgICAgIHJlbmRlckVsLnNldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHNlY3Rpb25FbGVtZW50Lmluc2VydEJlZm9yZShyZW5kZXJFbCwgcHJlRWwubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250ZW50ID0gY29kZUVsLmlubmVySFRNTDtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBIVE1MUmF6b3IucHJvdG90eXBlLnN0cmlwKGNvbnRlbnQpO1xuXG4gICAgICAgICAgICB0aHJvdHRsZSg3MDAsIF8gPT4gcmVuZGVyKHJlbmRlckVsLCBjb250ZW50KSkoKVxuXG4gICAgICAgICAgICBpZihsYW4gJiYgcHJpbXNqcy5sYW5ndWFnZXNbbGFuXSkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBwcmltc2pzLmhpZ2hsaWdodChjb250ZW50LCBwcmltc2pzLmxhbmd1YWdlc1tsYW5dLCBsYW4pO1xuICAgICAgICAgICAgICAgIHNlY3Rpb25FbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2NvZGUnKS5pbm5lckhUTUwgPSBjb250ZW50OyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBvbkZvY3VzOiBmdW5jdGlvbihlbCwgZWRpdG9yLCBhcmdzKSB7XG4gICAgICAgICAgICB2YXIgaXNDYXJldEluc2lkZUNhcHRpb24gPSAoZWRpdG9yLnNlY3Rpb25BdENhcmV0UG9zdGlvbigpID09PSBlbCAmJiBlZGl0b3IuY2FyZXQuZ2V0Q29udGV4dEVsZW1lbnQoWydjYXB0aW9uJ10pKSxcbiAgICAgICAgICAgICAgICBjb2RlID0gZWwucXVlcnlTZWxlY3RvcignY29kZScpO1xuXG4gICAgICAgICAgICBpZighaXNDYXJldEluc2lkZUNhcHRpb24gJiYgY29kZSkge1xuICAgICAgICAgICAgICAgIGVkaXRvci5jYXJldC5wb3NpdGlvbkluKGNvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldE9wdGlvbnM6IGZ1bmN0aW9uKHNlY3Rpb25FbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIG5hbWU6ICdkaXNwbGF5Q2FwdGlvbicsXG4gICAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZTogJ0Rpc3BsYXkgQ2FwdGlvbicsXG4gICAgICAgICAgICAgICAgICBhbGxvd2VkVmFsdWVzOiBbJ1llcycsICdObyddLFxuICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBzZWN0aW9uRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2Rpc3BsYXktY2FwdGlvbicpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uT3B0aW9uc0NoYW5nZTogZnVuY3Rpb24ob3B0LCBlZGl0b3IpIHtcbiAgICAgICAgICAgIHZhciBzZWN0aW9uID0gZWRpdG9yLmZvY3VzZWRTZWN0aW9uKCk7XG4gICAgICAgICAgICBpZihvcHQuZGlzcGxheUNhcHRpb24gPT09ICdZZXMnIHx8IG9wdC5kaXNwbGF5Q2FwdGlvbiA9PT0gJ05vJykge1xuICAgICAgICAgICAgICAgIHNlY3Rpb24uc2V0QXR0cmlidXRlKCdkaXNwbGF5LWNhcHRpb24nLCBvcHQuZGlzcGxheUNhcHRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uS2V5VGFiOiBjb2RlU2VjdGlvblR5cGUub25LZXlUYWIsXG4gICAgICAgIG9uS2V5VXA6IGNvZGVTZWN0aW9uVHlwZS5vbktleVVwLFxuICAgICAgICBvbktleURvd246IGNvZGVTZWN0aW9uVHlwZS5vbktleURvd24sXG4gICAgICAgIG9uS2V5QmFja3NwYWNlOiBjb2RlU2VjdGlvblR5cGUub25LZXlCYWNrc3BhY2UsXG4gICAgICAgIG9uS2V5RW50ZXI6IGNvZGVTZWN0aW9uVHlwZS5vbktleUVudGVyLFxuICAgICAgICBnZXRTZWN0aW9uRWxlbWVudDogZ2V0U2VjdGlvbkVsZW1lbnQsXG4gICAgfSk7XG5cbiAgICBzZWN0aW9uVHlwZS5jb250ZW50UnVsZXNbdGFnTmFtZV0gPSB7XG4gICAgICAgIHRhZ05hbWU6IHRhZ05hbWUsXG4gICAgICAgIGNsYXNzTmFtZTogdGFnTmFtZSxcbiAgICAgICAgYWxsb3dlZEF0dHJpYnV0ZXM6IFsnY2xhc3MnLCAnZGlzcGxheS1jYXB0aW9uJywgJ2lkJ10sXG4gICAgICAgIGFsbG93ZWRDbGFzc05hbWVzOiBbJ2ZvY3VzZWQnLCB0YWdOYW1lLCAnbTJkaWEnXSxcbiAgICAgICAgYWxsb3dlZENoaWxkcmVuOiBbJ20yZGlhLWNhcHRpb24nLCAnbTJkaWEtcHJlJ10sXG4gICAgICAgIHBydW5lU3BhY2VzOiB0cnVlLFxuICAgICAgICBhbGxvd2VkVG9CZVJvb3Q6IHRydWUsXG4gICAgICAgIGRlbGV0ZUlmRW1wdHk6IGZhbHNlLFxuICAgICAgICBidWlsZEVtcHR5RWxlbWVudDogc2VjdGlvblR5cGUuZ2V0U2VjdGlvbkVsZW1lbnQsXG4gICAgICAgIGRlZmF1bHRDYXB0aW9uOiBkZWZhdWx0Q2FwdGlvbixcbiAgICAgICAgYnVpbGRBdHRyaWJ1dGVzOiBbXG4gICAgICAgICAgICB7bmFtZTogJ2Rpc3BsYXktY2FwdGlvbicsIGJ1aWxkOiBmdW5jdGlvbigpIHtyZXR1cm4gJ1llcyd9fSxcbiAgICAgICAgICAgIHtuYW1lOiAnaWQnLCBidWlsZDogZnVuY3Rpb24oKSB7cmV0dXJuIHV1aWQoKX19XG4gICAgICAgIF1cbiAgICB9O1xuXG4gICAgc2VjdGlvblR5cGUudGFnVHJhbnNmb3JtYXRpb25zID0ge307XG4gICAgc2VjdGlvblR5cGUudGFnVHJhbnNmb3JtYXRpb25zWycvJyt0YWdOYW1lKycvZGl2LnJlbmRlciddID0gJyNuby1jb250ZW50JztcbiAgICBzZWN0aW9uVHlwZS50YWdUcmFuc2Zvcm1hdGlvbnNbJy8nK3RhZ05hbWUrJy9wcmUvY29kZSddID0gJyN0ZXh0LWNvbnRlbnQnO1xuXG4gICAgcmV0dXJuIHNlY3Rpb25UeXBlO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgb25LZXlVcEZvckZyZWVzdHlsZVNlY3Rpb25zOiBmdW5jdGlvbihlLCBlZGl0b3IpIHtcbiAgICAgICAgdmFyIGZvY3VzZWRTZWN0aW9uID0gZWRpdG9yLmZvY3VzZWRTZWN0aW9uKCksXG4gICAgICAgICAgICB1cHBlclNlY3Rpb24gPSBmb2N1c2VkU2VjdGlvbi5wcmV2aW91c1NpYmxpbmc7XG5cbiAgICAgICAgaWYoIXVwcGVyU2VjdGlvbikgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gICAgICAgIGlmKGVkaXRvci5jYXJldC5pc0NvbGxhcHNlZEFuZFBvc2l0aW9uZWRBdFRoZUJlZ2lubmluZ09mKGZvY3VzZWRTZWN0aW9uKSkge1xuICAgICAgICAgICAgZWRpdG9yLnBsYWNlQ2FyZXRJbnRvU2VjdGlvbih1cHBlclNlY3Rpb24pO1xuXG4gICAgICAgICAgICAvLyB0cmlnZ2VyIHRoZSByZW1vdmFsIG9mIGVtcHR5IHNlY3Rpb25zXG4gICAgICAgICAgICBlZGl0b3IucmVwbGFjZVNlY3Rpb25XaXRoSFRNTChmb2N1c2VkU2VjdGlvbiwgZm9jdXNlZFNlY3Rpb24ub3V0ZXJIVE1MKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvbktleURvd25Gb3JGcmVlc3R5bGVTZWN0aW9uczogZnVuY3Rpb24oZSwgZWRpdG9yKSB7XG4gICAgICAgIHZhciBmb2N1c2VkU2VjdGlvbiA9IGVkaXRvci5mb2N1c2VkU2VjdGlvbigpLFxuICAgICAgICAgICAgbG93ZXJTZWN0aW9uID0gZm9jdXNlZFNlY3Rpb24ubmV4dFNpYmxpbmc7XG5cbiAgICAgICAgaWYoIWxvd2VyU2VjdGlvbikgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gICAgICAgIGlmKGVkaXRvci5jYXJldC5pc0NvbGxhcHNlZEFuZFBvc2l0aW9uZWRBdFRoZUVuZE9mKGZvY3VzZWRTZWN0aW9uKSkge1xuICAgICAgICAgICAgZWRpdG9yLnBsYWNlQ2FyZXRJbnRvU2VjdGlvbihsb3dlclNlY3Rpb24pO1xuXG4gICAgICAgICAgICAvLyB0cmlnZ2VyIHRoZSByZW1vdmFsIG9mIGVtcHR5IHNlY3Rpb25zXG4gICAgICAgICAgICBlZGl0b3IucmVwbGFjZVNlY3Rpb25XaXRoSFRNTChmb2N1c2VkU2VjdGlvbiwgZm9jdXNlZFNlY3Rpb24ub3V0ZXJIVE1MKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvbktleUVudGVyRm9yRnJlZXN0eWxlU2VjdGlvbnM6IGZ1bmN0aW9uKGUsIGVkaXRvcikge1xuICAgICAgICBkb2N1bWVudC5leGVjQ29tbWFuZCgnaW5zZXJ0SFRNTCcsIGZhbHNlLCAnJk5ld0xpbmU7Jyk7XG5cbiAgICAgICAgdmFyIGNoYXIgPSBlZGl0b3IuY2FyZXQuZ2V0UHJlY2VkaW5nQ2hhcmFjdGVyKGVkaXRvci5mb2N1c2VkU2VjdGlvbigpKTtcbiAgICAgICAgaWYoY2hhciAhPT0gJ1xcbicpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKCdpbnNlcnRIVE1MJywgZmFsc2UsICcmTmV3TGluZTsnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAvLyBXZSBkbyBub3QgaGF2ZSB0byBzZXQgdGhlIGNvbnRlbnQgb2YgdGhlIGVkaXRvciBiZWNhdXNlIGV4ZWNjb21tYW5kIHRyaWdnZXJzXG4gICAgICAgIC8vIGFuIGlucHV0IGV2ZW50IHdoaWNoIHdpbGwgaGFuZGxlIHRoZSBjb250ZW50IGNoYW5nZSBvbiB0aGUgZWRpdG9yIHNpdGUuXG4gICAgfSxcblxuICAgIG9uS2V5QmFja3NwYWNlRm9yQmFja3NwYWNlRGVsZXRhYmxlU2VjdGlvbnM6IGZ1bmN0aW9uKGUsIGVkaXRvcikge1xuICAgICAgICB2YXIgZm9jdXNlZFNlY3Rpb24gPSBlZGl0b3IuZm9jdXNlZFNlY3Rpb24oKSxcbiAgICAgICAgICAgIHVwcGVyU2VjdGlvbiA9IGZvY3VzZWRTZWN0aW9uLnByZXZpb3VzU2libGluZztcblxuICAgICAgICBpZighdXBwZXJTZWN0aW9uKSB7IHJldHVybiB0cnVlOyB9XG5cbiAgICAgICAgaWYoZm9jdXNlZFNlY3Rpb24uaW5uZXJUZXh0LnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgICAgIGVkaXRvci5wbGFjZUNhcmV0SW50b1NlY3Rpb24odXBwZXJTZWN0aW9uKTtcblxuICAgICAgICAgICAgLy8gdHJpZ2dlciB0aGUgcmVtb3ZhbCBvZiBlbXB0eSBzZWN0aW9uc1xuICAgICAgICAgICAgZWRpdG9yLnJlcGxhY2VTZWN0aW9uV2l0aEhUTUwoZm9jdXNlZFNlY3Rpb24sIGZvY3VzZWRTZWN0aW9uLm91dGVySFRNTCk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJ2YXIgdXVpZCA9IHJlcXVpcmUoJ3V1aWQvdjEnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi9waXhlbHNjaHVic2VyL3V0aWxzJyk7XG52YXIgbGFzdEZvY3VzZWRDZWxsLCBmb2N1c2VkQ2VsbCwgb25VbmZvY3VzVGltZW91dDtcblxudmFyIGdldFNlY3Rpb25FbGVtZW50ID0gZnVuY3Rpb24oZXhpc3RpbmdTZWN0aW9uQ29udGVudCkge1xuICAgIHZhciB0YWJsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0YWJsZScpO1xuICAgIHRhYmxlRWxlbWVudC5pZCA9IHV1aWQoKTtcbiAgICB0YWJsZUVsZW1lbnQuc2VjdGlvblR5cGUgPSBtb2R1bGUuZXhwb3J0cztcbiAgICB0YWJsZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdkaXNwbGF5LWhlYWRpbmcnLCAnWWVzJyk7XG4gICAgdGFibGVFbGVtZW50LnNldEF0dHJpYnV0ZSgnZGlzcGxheS1jYXB0aW9uJywgJ1llcycpO1xuXG4gICAgdGFibGVFbGVtZW50Lm9uS2V5VXAgPSBtb2R1bGUuZXhwb3J0cy5vbktleVVwO1xuICAgIHRhYmxlRWxlbWVudC5vbktleURvd24gPSBtb2R1bGUuZXhwb3J0cy5vbktleURvd247XG4gICAgdGFibGVFbGVtZW50Lm9uS2V5VGFiID0gbW9kdWxlLmV4cG9ydHMub25LZXlUYWI7XG4gICAgdGFibGVFbGVtZW50Lm9uS2V5Q29tYmluYXRpb24gPSBtb2R1bGUuZXhwb3J0cy5vbktleUNvbWJpbmF0aW9uO1xuICAgIHRhYmxlRWxlbWVudC5vbktleUJhY2tzcGFjZSA9IG1vZHVsZS5leHBvcnRzLm9uS2V5QmFja3NwYWNlO1xuICAgIHRhYmxlRWxlbWVudC5vbktleUVudGVyID0gbW9kdWxlLmV4cG9ydHMub25LZXlFbnRlcjtcbiAgICB0YWJsZUVsZW1lbnQub25TZWxlY3Rpb25DaGFuZ2UgPSBtb2R1bGUuZXhwb3J0cy5vblNlbGVjdGlvbkNoYW5nZTtcbiAgICB0YWJsZUVsZW1lbnQub25VbmZvY3VzID0gbW9kdWxlLmV4cG9ydHMub25VbmZvY3VzO1xuICAgIHRhYmxlRWxlbWVudC5vbldpbmRvd1Jlc2l6ZSA9IG1vZHVsZS5leHBvcnRzLm9uV2luZG93UmVzaXplO1xuXG4gICAgdGFibGVFbGVtZW50LmlubmVySFRNTCA9ICc8dGJvZHk+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgIDx0cj48dGQ+PC90ZD48dGQ+PC90ZD48L3RyPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnICA8dHI+PHRkPjwvdGQ+PHRkPjwvdGQ+PC90cj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyAgPHRyPjx0ZD48L3RkPjx0ZD48L3RkPjwvdHI+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8L3Rib2R5PicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPGNhcHRpb24+dGFibGUgdGl0bGU8L2NhcHRpb24+JztcblxuICAgIHJldHVybiB0YWJsZUVsZW1lbnQ7XG59XG5cbnZhciBnZXRBZGRSb3dCZWxvd0J1dHRvbiA9IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIHZhciBidG4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdGFibGVBZGRSb3dCZWxvd0J0bicpO1xuXG4gICAgaWYoYnRuKSB7XG4gICAgICAgIHJldHVybiBidG47XG4gICAgfVxuXG4gICAgdmFyIGJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICBidG4uaWQgPSAndGFibGVBZGRSb3dCZWxvd0J0bic7XG4gICAgYnRuLmlubmVySFRNTCA9ICc8c3ZnIGlkPVwiTGF5ZXJfMVwiIGRhdGEtbmFtZT1cIkxheWVyIDFcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIxMi42N1wiIGhlaWdodD1cIjE5LjY5XCIgdmlld0JveD1cIjAgMCAxMi42NyAxOS42OVwiPjxkZWZzPjxzdHlsZT4uY2xzLTEsLmNscy0ze2ZpbGw6bm9uZTt9LmNscy0xe3N0cm9rZTojMjMxZjIwO30uY2xzLTEsLmNscy0yLC5jbHMtM3tzdHJva2UtbWl0ZXJsaW1pdDoxMDt9LmNscy0ye2ZpbGw6Izk4Y2Y4ZDt9LmNscy0yLC5jbHMtM3tzdHJva2U6IzI5NzAyNzt9PC9zdHlsZT48L2RlZnM+PHBvbHlsaW5lIGNsYXNzPVwiY2xzLTFcIiBwb2ludHM9XCI1Ljk4IDEuMjYgNS45OCA3LjA3IDUuOTggMTIuNzIgNS45OCAxOC40MlwiLz48cGF0aCBjbGFzcz1cImNscy0xXCIgZD1cIk0zMjcuMzgsNDEzLjU5XCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKC0zMjYuODggLTQwMS45NClcIi8+PHJlY3QgY2xhc3M9XCJjbHMtMVwiIHg9XCIwLjVcIiB5PVwiMS4yNlwiIHdpZHRoPVwiMTAuOTdcIiBoZWlnaHQ9XCIxNy4xN1wiLz48cG9seWxpbmUgY2xhc3M9XCJjbHMtMVwiIHBvaW50cz1cIjExLjQ3IDcuMDcgNS45OCA3LjA3IDAuNSA3LjA3XCIvPjxwb2x5bGluZSBjbGFzcz1cImNscy0xXCIgcG9pbnRzPVwiMTEuNDcgMTIuNzIgNS45OCAxMi43MiAwLjUgMTIuNzJcIi8+PHBhdGggY2xhc3M9XCJjbHMtMlwiIGQ9XCJNMzM5LjA1LDQwMi40NGMwLDIuMDcsMCw0LjEzLS4wNSw2LjE5aC02LjEzdi02LjE5WlwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgtMzI2Ljg4IC00MDEuOTQpXCIvPjxwYXRoIGNsYXNzPVwiY2xzLTJcIiBkPVwiTTMzOSw0MDguNjNjMCwyLjI1LDAsNC41LS4wNiw2Ljc1aC02LjA3di02Ljc1WlwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgtMzI2Ljg4IC00MDEuOTQpXCIvPjxwYXRoIGNsYXNzPVwiY2xzLTJcIiBkPVwiTTMzOC45NCw0MTUuMzhjMCwxLjkyLDAsMy44MywwLDUuNzVoLTZ2LTUuNzVaXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKC0zMjYuODggLTQwMS45NClcIi8+PGxpbmUgY2xhc3M9XCJjbHMtM1wiIHgxPVwiNS45OVwiIHkxPVwiNi42OVwiIHgyPVwiNS45OFwiIHkyPVwiNi42OVwiLz48bGluZSBjbGFzcz1cImNscy0zXCIgeDE9XCI1Ljk5XCIgeTE9XCIxMy40NFwiIHgyPVwiNS45OFwiIHkyPVwiMTMuNDRcIi8+PC9zdmc+JztcblxuICAgIGJ0bi5vbm1vdXNlZG93biA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzLmFkZFJvdyh1bmRlZmluZWQsIGVkaXRvcik7XG4gICAgICAgIH0sIDEwMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ0bjtcbn1cblxudmFyIGdldEFkZFJvd0Fib3ZlQnV0dG9uID0gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgdmFyIGJ0biA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0YWJsZUFkZFJvd0Fib3ZlQnRuJyk7XG5cbiAgICBpZihidG4pIHtcbiAgICAgICAgcmV0dXJuIGJ0bjtcbiAgICB9XG5cbiAgICB2YXIgYnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGJ0bi5pZCA9ICd0YWJsZUFkZFJvd0Fib3ZlQnRuJztcbiAgICBidG4uaW5uZXJIVE1MID0gJzxzdmcgaWQ9XCJMYXllcl8xXCIgZGF0YS1uYW1lPVwiTGF5ZXIgMVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjEyLjM3XCIgaGVpZ2h0PVwiMTkuNjlcIiB2aWV3Qm94PVwiMCAwIDEyLjM3IDE5LjY5XCI+PGRlZnM+PHN0eWxlPi5jbHMtMSwuY2xzLTN7ZmlsbDpub25lO30uY2xzLTF7c3Ryb2tlOiMyMzFmMjA7fS5jbHMtMSwuY2xzLTIsLmNscy0ze3N0cm9rZS1taXRlcmxpbWl0OjEwO30uY2xzLTJ7ZmlsbDojOThjZjhkO30uY2xzLTIsLmNscy0ze3N0cm9rZTojMjk3MDI3O308L3N0eWxlPjwvZGVmcz48cGF0aCBjbGFzcz1cImNscy0xXCIgZD1cIk0zMDAuODMsMzk3LjQxXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKC0yOTkuOTMgLTM4NS43NilcIi8+PHJlY3QgY2xhc3M9XCJjbHMtMVwiIHg9XCIwLjlcIiB5PVwiMS4yNlwiIHdpZHRoPVwiMTAuOTdcIiBoZWlnaHQ9XCIxNy4xN1wiLz48cG9seWxpbmUgY2xhc3M9XCJjbHMtMVwiIHBvaW50cz1cIjYuMzggMS4yNiA2LjM4IDcuMDcgNi4zOCAxMi43MiA2LjM4IDE4LjQyXCIvPjxwb2x5bGluZSBjbGFzcz1cImNscy0xXCIgcG9pbnRzPVwiMTEuODcgNy4wNyA2LjM4IDcuMDcgMC45IDcuMDdcIi8+PHBvbHlsaW5lIGNsYXNzPVwiY2xzLTFcIiBwb2ludHM9XCIxMS44NyAxMi43MiA2LjM4IDEyLjcyIDAuOSAxMi43MlwiLz48cGF0aCBjbGFzcz1cImNscy0yXCIgZD1cIk0zMDYuNjEsMzg2LjI2YzAsMi4wNiwwLDQuMTMtLjA1LDYuMTloLTYuMTN2LTYuMTlaXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKC0yOTkuOTMgLTM4NS43NilcIi8+PHBhdGggY2xhc3M9XCJjbHMtMlwiIGQ9XCJNMzA2LjU2LDM5Mi40NXEwLDMuMzgtLjA1LDYuNzVoLTYuMDh2LTYuNzVaXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKC0yOTkuOTMgLTM4NS43NilcIi8+PHBhdGggY2xhc3M9XCJjbHMtMlwiIGQ9XCJNMzA2LjUxLDM5OS4yYzAsMS45MiwwLDMuODMsMCw1Ljc1aC02VjM5OS4yWlwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgtMjk5LjkzIC0zODUuNzYpXCIvPjxsaW5lIGNsYXNzPVwiY2xzLTNcIiB4MT1cIjAuNVwiIHkxPVwiNi42OVwiIHgyPVwiMC40OVwiIHkyPVwiNi42OVwiLz48bGluZSBjbGFzcz1cImNscy0zXCIgeDE9XCIwLjVcIiB5MT1cIjEzLjQ0XCIgeDI9XCIwLjQ5XCIgeTI9XCIxMy40NFwiLz48L3N2Zz4nO1xuXG4gICAgYnRuLm9ubW91c2Vkb3duID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMuYWRkUm93KHVuZGVmaW5lZCwgZWRpdG9yLCB0cnVlKTtcbiAgICAgICAgfSwgMTAwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnRuO1xufVxuXG52YXIgZ2V0RGVsZXRlUm93QnV0dG9uID0gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgdmFyIGJ0biA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0YWJsZURlbGV0ZVJvd0J0bicpO1xuXG4gICAgaWYoYnRuKSB7XG4gICAgICAgIHJldHVybiBidG47XG4gICAgfVxuXG4gICAgdmFyIGJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICBidG4uaWQgPSAndGFibGVEZWxldGVSb3dCdG4nO1xuICAgIGJ0bi5pbm5lckhUTUwgPSAnPHN2ZyBkYXRhLW5hbWU9XCJMYXllciAxXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMTcuOTZcIiBoZWlnaHQ9XCIxOS42OVwiIHZpZXdCb3g9XCIwIDAgMTcuOTYgMTkuNjlcIj48ZGVmcz48L2RlZnM+PHJlY3QgY2xhc3M9XCJjbHMtMS1yZWRcIiB4PVwiMC41XCIgeT1cIjEuMzZcIiB3aWR0aD1cIjE2Ljk2XCIgaGVpZ2h0PVwiMTYuOTZcIi8+PHBhdGggY2xhc3M9XCJjbHMtMS1yZWRcIiBkPVwiTTMxNi41NywzOTNcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoLTI5NS42NiAtMzg1Ljc2KVwiLz48cG9seWxpbmUgY2xhc3M9XCJjbHMtMS1yZWRcIiBwb2ludHM9XCIwLjUgNy4yNyA1Ljk5IDcuMjcgMTEuOTEgNy4yNyAxNy40NyA3LjI3XCIvPjxwb2x5bGluZSBjbGFzcz1cImNscy0xLXJlZFwiIHBvaW50cz1cIjAuNSAxMi42MiA1Ljk5IDEyLjYyIDExLjkxIDEyLjYyIDE3LjQ3IDEyLjYyXCIvPjxwb2x5bGluZSBjbGFzcz1cImNscy0xLXJlZFwiIHBvaW50cz1cIjUuOTkgMS4zNiA1Ljk5IDcuMjcgNS45OSAxMi42MiA1Ljk5IDE4LjMyXCIvPjxwb2x5bGluZSBjbGFzcz1cImNscy0xLXJlZFwiIHBvaW50cz1cIjExLjkxIDEuMzYgMTEuOTEgNy4yNyAxMS45MSAxMi42MiAxMS45MSAxOC4zMlwiLz48cGF0aCBjbGFzcz1cImNscy0yLXJlZFwiIGQ9XCJNMzA3Ljg2LDM4Ni4yNmMwLDIuMDYsMCw0LjEzLS4wNSw2LjE5aC02LjEzdi02LjE5WlwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgtMjk1LjY2IC0zODUuNzYpXCIvPjxwYXRoIGNsYXNzPVwiY2xzLTItcmVkXCIgZD1cIk0zMDcuODEsMzkyLjQ1cTAsMy4zOC0uMDUsNi43NWgtNi4wOHYtNi43NVpcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoLTI5NS42NiAtMzg1Ljc2KVwiLz48cGF0aCBjbGFzcz1cImNscy0yLXJlZFwiIGQ9XCJNMzA3Ljc2LDM5OS4yYzAsMS45MiwwLDMuODMtLjA1LDUuNzVoLTZWMzk5LjJaXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKC0yOTUuNjYgLTM4NS43NilcIi8+PGxpbmUgY2xhc3M9XCJjbHMtMi1yZWRcIiB4MT1cIjYuMDJcIiB5MT1cIjYuNjlcIiB4Mj1cIjYuMDFcIiB5Mj1cIjYuNjlcIi8+PGxpbmUgY2xhc3M9XCJjbHMtMi1yZWRcIiB4MT1cIjYuMDJcIiB5MT1cIjEzLjQ0XCIgeDI9XCI2LjAxXCIgeTI9XCIxMy40NFwiLz48L3N2Zz4nO1xuXG4gICAgYnRuLm9ubW91c2Vkb3duID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMuZGVsZXRlUm93KHVuZGVmaW5lZCwgZWRpdG9yKTtcbiAgICAgICAgfSwgMTAwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnRuO1xufVxuXG52YXIgZ2V0QWRkQ29sdW1uTGVmdEJ1dHRvbiA9IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIHZhciBidG4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdGFibGVBZGRDb2x1bW5MZWZ0QnRuJyk7XG5cbiAgICBpZihidG4pIHtcbiAgICAgICAgcmV0dXJuIGJ0bjtcbiAgICB9XG5cbiAgICB2YXIgYnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGJ0bi5pZCA9ICd0YWJsZUFkZENvbHVtbkxlZnRCdG4nO1xuICAgIGJ0bi5pbm5lckhUTUwgPSAnPHN2ZyBpZD1cIkxheWVyXzFcIiBkYXRhLW5hbWU9XCJMYXllciAxXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMTIuMzdcIiBoZWlnaHQ9XCIxOS42OVwiIHZpZXdCb3g9XCIwIDAgMTIuMzcgMTkuNjlcIj48ZGVmcz48c3R5bGU+LmNscy0xLC5jbHMtM3tmaWxsOm5vbmU7fS5jbHMtMXtzdHJva2U6IzIzMWYyMDt9LmNscy0xLC5jbHMtMiwuY2xzLTN7c3Ryb2tlLW1pdGVybGltaXQ6MTA7fS5jbHMtMntmaWxsOiM5OGNmOGQ7fS5jbHMtMiwuY2xzLTN7c3Ryb2tlOiMyOTcwMjc7fTwvc3R5bGU+PC9kZWZzPjxwYXRoIGNsYXNzPVwiY2xzLTFcIiBkPVwiTTMwMC44MywzOTcuNDFcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoLTI5OS45MyAtMzg1Ljc2KVwiLz48cmVjdCBjbGFzcz1cImNscy0xXCIgeD1cIjAuOVwiIHk9XCIxLjI2XCIgd2lkdGg9XCIxMC45N1wiIGhlaWdodD1cIjE3LjE3XCIvPjxwb2x5bGluZSBjbGFzcz1cImNscy0xXCIgcG9pbnRzPVwiNi4zOCAxLjI2IDYuMzggNy4wNyA2LjM4IDEyLjcyIDYuMzggMTguNDJcIi8+PHBvbHlsaW5lIGNsYXNzPVwiY2xzLTFcIiBwb2ludHM9XCIxMS44NyA3LjA3IDYuMzggNy4wNyAwLjkgNy4wN1wiLz48cG9seWxpbmUgY2xhc3M9XCJjbHMtMVwiIHBvaW50cz1cIjExLjg3IDEyLjcyIDYuMzggMTIuNzIgMC45IDEyLjcyXCIvPjxwYXRoIGNsYXNzPVwiY2xzLTJcIiBkPVwiTTMwNi42MSwzODYuMjZjMCwyLjA2LDAsNC4xMy0uMDUsNi4xOWgtNi4xM3YtNi4xOVpcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoLTI5OS45MyAtMzg1Ljc2KVwiLz48cGF0aCBjbGFzcz1cImNscy0yXCIgZD1cIk0zMDYuNTYsMzkyLjQ1cTAsMy4zOC0uMDUsNi43NWgtNi4wOHYtNi43NVpcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoLTI5OS45MyAtMzg1Ljc2KVwiLz48cGF0aCBjbGFzcz1cImNscy0yXCIgZD1cIk0zMDYuNTEsMzk5LjJjMCwxLjkyLDAsMy44MywwLDUuNzVoLTZWMzk5LjJaXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKC0yOTkuOTMgLTM4NS43NilcIi8+PGxpbmUgY2xhc3M9XCJjbHMtM1wiIHgxPVwiMC41XCIgeTE9XCI2LjY5XCIgeDI9XCIwLjQ5XCIgeTI9XCI2LjY5XCIvPjxsaW5lIGNsYXNzPVwiY2xzLTNcIiB4MT1cIjAuNVwiIHkxPVwiMTMuNDRcIiB4Mj1cIjAuNDlcIiB5Mj1cIjEzLjQ0XCIvPjwvc3ZnPic7XG5cbiAgICBidG4ub25tb3VzZWRvd24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cy5hZGRDb2x1bW4odW5kZWZpbmVkLCBlZGl0b3IsIHRydWUpO1xuICAgICAgICB9LCAxMDApO1xuICAgIH1cblxuICAgIHJldHVybiBidG47XG59XG5cbnZhciBnZXRBZGRDb2x1bW5SaWdodEJ1dHRvbiA9IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIHZhciBidG4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdGFibGVBZGRDb2x1bW5SaWdodEJ0bicpO1xuXG4gICAgaWYoYnRuKSB7XG4gICAgICAgIHJldHVybiBidG47XG4gICAgfVxuXG4gICAgdmFyIGJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICBidG4uaWQgPSAndGFibGVBZGRDb2x1bW5SaWdodEJ0bic7XG4gICAgYnRuLmlubmVySFRNTCA9ICc8c3ZnIGlkPVwiTGF5ZXJfMVwiIGRhdGEtbmFtZT1cIkxheWVyIDFcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIxMi42N1wiIGhlaWdodD1cIjE5LjY5XCIgdmlld0JveD1cIjAgMCAxMi42NyAxOS42OVwiPjxkZWZzPjxzdHlsZT4uY2xzLTEsLmNscy0ze2ZpbGw6bm9uZTt9LmNscy0xe3N0cm9rZTojMjMxZjIwO30uY2xzLTEsLmNscy0yLC5jbHMtM3tzdHJva2UtbWl0ZXJsaW1pdDoxMDt9LmNscy0ye2ZpbGw6Izk4Y2Y4ZDt9LmNscy0yLC5jbHMtM3tzdHJva2U6IzI5NzAyNzt9PC9zdHlsZT48L2RlZnM+PHBvbHlsaW5lIGNsYXNzPVwiY2xzLTFcIiBwb2ludHM9XCI1Ljk4IDEuMjYgNS45OCA3LjA3IDUuOTggMTIuNzIgNS45OCAxOC40MlwiLz48cGF0aCBjbGFzcz1cImNscy0xXCIgZD1cIk0zMjcuMzgsNDEzLjU5XCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKC0zMjYuODggLTQwMS45NClcIi8+PHJlY3QgY2xhc3M9XCJjbHMtMVwiIHg9XCIwLjVcIiB5PVwiMS4yNlwiIHdpZHRoPVwiMTAuOTdcIiBoZWlnaHQ9XCIxNy4xN1wiLz48cG9seWxpbmUgY2xhc3M9XCJjbHMtMVwiIHBvaW50cz1cIjExLjQ3IDcuMDcgNS45OCA3LjA3IDAuNSA3LjA3XCIvPjxwb2x5bGluZSBjbGFzcz1cImNscy0xXCIgcG9pbnRzPVwiMTEuNDcgMTIuNzIgNS45OCAxMi43MiAwLjUgMTIuNzJcIi8+PHBhdGggY2xhc3M9XCJjbHMtMlwiIGQ9XCJNMzM5LjA1LDQwMi40NGMwLDIuMDcsMCw0LjEzLS4wNSw2LjE5aC02LjEzdi02LjE5WlwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgtMzI2Ljg4IC00MDEuOTQpXCIvPjxwYXRoIGNsYXNzPVwiY2xzLTJcIiBkPVwiTTMzOSw0MDguNjNjMCwyLjI1LDAsNC41LS4wNiw2Ljc1aC02LjA3di02Ljc1WlwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgtMzI2Ljg4IC00MDEuOTQpXCIvPjxwYXRoIGNsYXNzPVwiY2xzLTJcIiBkPVwiTTMzOC45NCw0MTUuMzhjMCwxLjkyLDAsMy44MywwLDUuNzVoLTZ2LTUuNzVaXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKC0zMjYuODggLTQwMS45NClcIi8+PGxpbmUgY2xhc3M9XCJjbHMtM1wiIHgxPVwiNS45OVwiIHkxPVwiNi42OVwiIHgyPVwiNS45OFwiIHkyPVwiNi42OVwiLz48bGluZSBjbGFzcz1cImNscy0zXCIgeDE9XCI1Ljk5XCIgeTE9XCIxMy40NFwiIHgyPVwiNS45OFwiIHkyPVwiMTMuNDRcIi8+PC9zdmc+JztcblxuICAgIGJ0bi5vbm1vdXNlZG93biA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzLmFkZENvbHVtbih1bmRlZmluZWQsIGVkaXRvcik7XG4gICAgICAgIH0sIDEwMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ0bjtcbn1cblxudmFyIGdldERlbGV0ZUNvbHVtbkJ1dHRvbiA9IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIHZhciBidG4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdGFibGVEZWxldGVDb2x1bW5CdG4nKTtcblxuICAgIGlmKGJ0bikge1xuICAgICAgICByZXR1cm4gYnRuO1xuICAgIH1cblxuICAgIHZhciBidG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgYnRuLmlkID0gJ3RhYmxlRGVsZXRlQ29sdW1uQnRuJztcbiAgICBidG4uaW5uZXJIVE1MID0gJzxzdmcgZGF0YS1uYW1lPVwiTGF5ZXIgMVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjE3Ljk2XCIgaGVpZ2h0PVwiMTkuNjlcIiB2aWV3Qm94PVwiMCAwIDE3Ljk2IDE5LjY5XCI+PGRlZnM+PC9kZWZzPjxyZWN0IGNsYXNzPVwiY2xzLTEtcmVkXCIgeD1cIjAuNVwiIHk9XCIxLjM2XCIgd2lkdGg9XCIxNi45NlwiIGhlaWdodD1cIjE2Ljk2XCIvPjxwYXRoIGNsYXNzPVwiY2xzLTEtcmVkXCIgZD1cIk0zMTYuNTcsMzkzXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKC0yOTUuNjYgLTM4NS43NilcIi8+PHBvbHlsaW5lIGNsYXNzPVwiY2xzLTEtcmVkXCIgcG9pbnRzPVwiMC41IDcuMjcgNS45OSA3LjI3IDExLjkxIDcuMjcgMTcuNDcgNy4yN1wiLz48cG9seWxpbmUgY2xhc3M9XCJjbHMtMS1yZWRcIiBwb2ludHM9XCIwLjUgMTIuNjIgNS45OSAxMi42MiAxMS45MSAxMi42MiAxNy40NyAxMi42MlwiLz48cG9seWxpbmUgY2xhc3M9XCJjbHMtMS1yZWRcIiBwb2ludHM9XCI1Ljk5IDEuMzYgNS45OSA3LjI3IDUuOTkgMTIuNjIgNS45OSAxOC4zMlwiLz48cG9seWxpbmUgY2xhc3M9XCJjbHMtMS1yZWRcIiBwb2ludHM9XCIxMS45MSAxLjM2IDExLjkxIDcuMjcgMTEuOTEgMTIuNjIgMTEuOTEgMTguMzJcIi8+PHBhdGggY2xhc3M9XCJjbHMtMi1yZWRcIiBkPVwiTTMwNy44NiwzODYuMjZjMCwyLjA2LDAsNC4xMy0uMDUsNi4xOWgtNi4xM3YtNi4xOVpcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoLTI5NS42NiAtMzg1Ljc2KVwiLz48cGF0aCBjbGFzcz1cImNscy0yLXJlZFwiIGQ9XCJNMzA3LjgxLDM5Mi40NXEwLDMuMzgtLjA1LDYuNzVoLTYuMDh2LTYuNzVaXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKC0yOTUuNjYgLTM4NS43NilcIi8+PHBhdGggY2xhc3M9XCJjbHMtMi1yZWRcIiBkPVwiTTMwNy43NiwzOTkuMmMwLDEuOTIsMCwzLjgzLS4wNSw1Ljc1aC02VjM5OS4yWlwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgtMjk1LjY2IC0zODUuNzYpXCIvPjxsaW5lIGNsYXNzPVwiY2xzLTItcmVkXCIgeDE9XCI2LjAyXCIgeTE9XCI2LjY5XCIgeDI9XCI2LjAxXCIgeTI9XCI2LjY5XCIvPjxsaW5lIGNsYXNzPVwiY2xzLTItcmVkXCIgeDE9XCI2LjAyXCIgeTE9XCIxMy40NFwiIHgyPVwiNi4wMVwiIHkyPVwiMTMuNDRcIi8+PC9zdmc+JztcblxuICAgIGJ0bi5vbm1vdXNlZG93biA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzLmRlbGV0ZUNvbHVtbih1bmRlZmluZWQsIGVkaXRvcik7XG4gICAgICAgIH0sIDEwMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ0bjtcbn1cblxudmFyIGdldEhvcml6b250YWxDb250cm9sc0JhciA9IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIHZhciBiYXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjaG9yaXpvbnRhbFRhYmxlQ29udHJvbHNCYXInKTtcblxuICAgIGlmKGJhcikge1xuICAgICAgICByZXR1cm4gYmFyO1xuICAgIH1cblxuICAgIGJhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGJhci5pZCA9ICdob3Jpem9udGFsVGFibGVDb250cm9sc0Jhcic7XG4gICAgYmFyLmNsYXNzTGlzdC5hZGQoJ3RhYmxlQ29udHJvbHNCYXInKTtcblxuICAgIHZhciBhcnJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGFycm93LmNsYXNzTGlzdC5hZGQoJ2Fycm93JylcblxuICAgIGJhci5hcHBlbmRDaGlsZChnZXRBZGRDb2x1bW5MZWZ0QnV0dG9uKGVkaXRvcikpO1xuICAgIGJhci5hcHBlbmRDaGlsZChnZXREZWxldGVDb2x1bW5CdXR0b24oZWRpdG9yKSk7XG4gICAgYmFyLmFwcGVuZENoaWxkKGdldEFkZENvbHVtblJpZ2h0QnV0dG9uKGVkaXRvcikpO1xuICAgIGJhci5hcHBlbmRDaGlsZChhcnJvdyk7XG5cbiAgICBiYXIub25jbGljayA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChiYXIpO1xuXG4gICAgcmV0dXJuIGJhcjtcbn1cblxudmFyIGdldFZlcnRpY2FsQ29udHJvbHNCYXIgPSBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICB2YXIgYmFyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3ZlcnRpY2FsVGFibGVDb250cm9sc0JhcicpO1xuXG4gICAgaWYoYmFyKSB7XG4gICAgICAgIHJldHVybiBiYXI7XG4gICAgfVxuXG4gICAgYmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgYmFyLmlkID0gJ3ZlcnRpY2FsVGFibGVDb250cm9sc0Jhcic7XG4gICAgYmFyLmNsYXNzTGlzdC5hZGQoJ3RhYmxlQ29udHJvbHNCYXInKVxuXG4gICAgdmFyIGFycm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgYXJyb3cuY2xhc3NMaXN0LmFkZCgnYXJyb3cnKVxuXG4gICAgYmFyLmFwcGVuZENoaWxkKGdldEFkZFJvd0Fib3ZlQnV0dG9uKGVkaXRvcikpO1xuICAgIGJhci5hcHBlbmRDaGlsZChnZXREZWxldGVSb3dCdXR0b24oZWRpdG9yKSk7XG4gICAgYmFyLmFwcGVuZENoaWxkKGdldEFkZFJvd0JlbG93QnV0dG9uKGVkaXRvcikpO1xuICAgIGJhci5hcHBlbmRDaGlsZChhcnJvdyk7XG5cbiAgICBiYXIub25jbGljayA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChiYXIpO1xuXG4gICAgcmV0dXJuIGJhcjtcbn1cblxuT2JqZWN0LmFzc2lnbihtb2R1bGUuZXhwb3J0cywge1xuXG4gICAgbmFtZTogJ3RhYmxlJyxcblxuICAgIGNvbnRlbnRSdWxlczoge1xuICAgICAgICAndGFibGUnOiB7XG4gICAgICAgICAgICB0YWdOYW1lOiAndGFibGUnLFxuICAgICAgICAgICAgYWxsb3dlZEF0dHJpYnV0ZXM6IFsnY2xhc3MnLCAnZGlzcGxheS1oZWFkaW5nJywgJ2Rpc3BsYXktY2FwdGlvbicsICdpZCddLFxuICAgICAgICAgICAgYWxsb3dlZENsYXNzTmFtZXM6IFsnZm9jdXNlZCddLFxuICAgICAgICAgICAgYWxsb3dlZENoaWxkcmVuOiBbJ3Rib2R5JywgJ2NhcHRpb24nXSxcbiAgICAgICAgICAgIGNoaWxkcmVuQ2FyZGluYWxpdHk6IHsnY2FwdGlvbic6IHttYXg6IDF9fSxcbiAgICAgICAgICAgIGFsbG93ZWRUb0JlUm9vdDogdHJ1ZSxcbiAgICAgICAgICAgIGRlbGV0ZUlmRW1wdHk6IGZhbHNlLFxuICAgICAgICAgICAgYnVpbGRFbXB0eUVsZW1lbnQ6IGdldFNlY3Rpb25FbGVtZW50LFxuICAgICAgICAgICAgYnVpbGRBdHRyaWJ1dGVzOiBbXG4gICAgICAgICAgICAgICAge25hbWU6ICdpZCcsIGJ1aWxkOiBmdW5jdGlvbigpIHtyZXR1cm4gdXVpZCgpfX0sXG4gICAgICAgICAgICAgICAge25hbWU6ICdkaXNwbGF5LWhlYWRpbmcnLCBidWlsZDogZnVuY3Rpb24oKSB7cmV0dXJuICdZZXMnfX0sXG4gICAgICAgICAgICAgICAge25hbWU6ICdkaXNwbGF5LWNhcHRpb24nLCBidWlsZDogZnVuY3Rpb24oKSB7cmV0dXJuICdZZXMnfX1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgJ2NhcHRpb24nOiB7XG4gICAgICAgICAgICB0YWdOYW1lOiAnY2FwdGlvbicsXG4gICAgICAgICAgICBhbGxvd2VkQ2hpbGRyZW46IFsnI3RleHQnLCAncmVmZXJlbmNlJywgJ2lubGluZWVxdWF0aW9uJ10sXG4gICAgICAgICAgICBkZWxldGVJZkVtcHR5OiBmYWxzZSxcbiAgICAgICAgICAgIHBydW5lU3BhY2VzOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICAndGJvZHknOiB7XG4gICAgICAgICAgICB0YWdOYW1lOiAndGJvZHknLFxuICAgICAgICAgICAgYWxsb3dlZFN1Y2Nlc3NvcnM6IFsnY2FwdGlvbiddLFxuICAgICAgICAgICAgYWxsb3dlZENoaWxkcmVuOiBbJ3RyJ10sXG4gICAgICAgIH0sXG4gICAgICAgICd0cic6IHtcbiAgICAgICAgICAgIHRhZ05hbWU6ICd0cicsXG4gICAgICAgICAgICBhbGxvd2VkQ2hpbGRyZW46IFsndGQnXSxcbiAgICAgICAgfSxcbiAgICAgICAgJ3RkJzoge1xuICAgICAgICAgICAgdGFnTmFtZTogJ3RkJyxcbiAgICAgICAgICAgIGFsbG93ZWRDaGlsZHJlbjogWycjdGV4dCcsICdiJywgJ2knLCAndScsICdsaW5rJywgJ2Zvb3Rub3RlJywgJ3JlZmVyZW5jZScsICdpbmxpbmVjb2RlJywgJ2lubGluZWVxdWF0aW9uJ10sXG4gICAgICAgICAgICBkb05vdEJyZWFrT3V0Um9vdEVsZW1lbnRzOiB0cnVlLFxuICAgICAgICAgICAgcHJ1bmVTcGFjZXM6IHRydWVcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRPcHRpb25zOiBmdW5jdGlvbihzZWN0aW9uRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBuYW1lOiAnZGlzcGxheUhlYWRpbmcnLFxuICAgICAgICAgICAgICBkaXNwbGF5TmFtZTogJ0Rpc3BsYXkgSGVhZCBSb3cnLFxuICAgICAgICAgICAgICBhbGxvd2VkVmFsdWVzOiBbJ1llcycsICdObyddLFxuICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IHNlY3Rpb25FbGVtZW50LmdldEF0dHJpYnV0ZSgnZGlzcGxheS1oZWFkaW5nJylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5hbWU6ICdkaXNwbGF5Q2FwdGlvbicsXG4gICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiAnRGlzcGxheSBUYWJsZSBDYXB0aW9uJyxcbiAgICAgICAgICAgICAgYWxsb3dlZFZhbHVlczogWydZZXMnLCAnTm8nXSxcbiAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBzZWN0aW9uRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2Rpc3BsYXktY2FwdGlvbicpXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuXG4gICAgb25Gb2N1czogZnVuY3Rpb24oZWwsIGVkaXRvciwgYXJncykge1xuICAgICAgICB2YXIgdGQgPSBlbC5xdWVyeVNlbGVjdG9yKCd0ZCcpLFxuICAgICAgICAgICAgaXNDYXJldEluc2lkZVRhYmxlID0gKGVkaXRvci5zZWN0aW9uQXRDYXJldFBvc3Rpb24oKSA9PT0gZWwgJiYgZWRpdG9yLmNhcmV0LmdldENvbnRleHRFbGVtZW50KFsndGQnLCAnY2FwdGlvbiddKSksXG4gICAgICAgICAgICBoYXNCZWVuRm9jdXNlZEFmdGVyU2VjdGlvblR5cGVDaGFuZ2UgPSBhcmdzLmFjdGlvbiA9PT0gJ2NoYW5nZUZvY3VzZWRTZWN0aW9uVHlwZSc7XG5cbiAgICAgICAgaWYoaGFzQmVlbkZvY3VzZWRBZnRlclNlY3Rpb25UeXBlQ2hhbmdlIHx8ICFpc0NhcmV0SW5zaWRlVGFibGUpIHtcbiAgICAgICAgICAgIHRkICYmIGVkaXRvci5jYXJldC5wb3NpdGlvbkluKHRkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvbk9wdGlvbnNDaGFuZ2U6IGZ1bmN0aW9uKG9wdCwgZWRpdG9yKSB7XG4gICAgICAgIHZhciBzZWN0aW9uID0gZWRpdG9yLmZvY3VzZWRTZWN0aW9uKCk7XG4gICAgICAgIGlmKG9wdC5kaXNwbGF5SGVhZGluZyA9PT0gJ1llcycgfHwgb3B0LmRpc3BsYXlIZWFkaW5nID09PSAnTm8nKSB7XG4gICAgICAgICAgICBzZWN0aW9uLnNldEF0dHJpYnV0ZSgnZGlzcGxheS1oZWFkaW5nJywgb3B0LmRpc3BsYXlIZWFkaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKG9wdC5kaXNwbGF5Q2FwdGlvbiA9PT0gJ1llcycgfHwgb3B0LmRpc3BsYXlDYXB0aW9uID09PSAnTm8nKSB7XG4gICAgICAgICAgICBzZWN0aW9uLnNldEF0dHJpYnV0ZSgnZGlzcGxheS1jYXB0aW9uJywgb3B0LmRpc3BsYXlDYXB0aW9uKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRWZXJ0aWNhbE5laWdoYm9yRmllbGQ6IGZ1bmN0aW9uKHRkLCBsb3dlck5laWdoYm9yKSB7XG4gICAgICAgIGlmKCF0ZCkgeyByZXR1cm4gfVxuXG4gICAgICAgIHZhciB4SW5kZXggPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHRkLnBhcmVudEVsZW1lbnQuY2hpbGRyZW4sIHRkKSxcbiAgICAgICAgICAgIG5laWdoYm9yUm93ID0gdGQucGFyZW50Tm9kZSAmJiB0ZC5wYXJlbnROb2RlWyhsb3dlck5laWdoYm9yID8gJ25leHRTaWJsaW5nJyA6ICdwcmV2aW91c1NpYmxpbmcnKV0sXG4gICAgICAgICAgICBjb2xzcGFuLCB0bXBGaWVsZDtcblxuICAgICAgICBpZighbmVpZ2hib3JSb3cpIHsgcmV0dXJuIH1cblxuICAgICAgICBmb3IodmFyIGk9MDsgaTw9eEluZGV4Oykge1xuICAgICAgICAgICAgY29sc3BhbiA9IHBhcnNlSW50KG5laWdoYm9yUm93LmNoaWxkcmVuW2ldLmdldEF0dHJpYnV0ZSgnY29sc3BhbicpKSB8fCAxO1xuICAgICAgICAgICAgdG1wRmllbGQgPSBuZWlnaGJvclJvdy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGkgKz0gY29sc3BhbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0bXBGaWVsZDtcbiAgICB9LFxuXG4gICAgZ2V0TmV4dEZpZWxkOiBmdW5jdGlvbih0ZCkge1xuICAgICAgICBpZih0ZC5uZXh0U2libGluZykge1xuICAgICAgICAgICAgcmV0dXJuIHRkLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGQucGFyZW50RWxlbWVudCAmJlxuICAgICAgICAgICB0ZC5wYXJlbnRFbGVtZW50Lm5leHRTaWJsaW5nICYmXG4gICAgICAgICAgIHRkLnBhcmVudEVsZW1lbnQubmV4dFNpYmxpbmcuY2hpbGRyZW4gJiZcbiAgICAgICAgICAgdGQucGFyZW50RWxlbWVudC5uZXh0U2libGluZy5jaGlsZHJlblswXSAmJlxuICAgICAgICAgICB0ZC5wYXJlbnRFbGVtZW50Lm5leHRTaWJsaW5nLmNoaWxkcmVuWzBdLnRhZ05hbWUgPT09ICdURCcpIHtcbiAgICAgICAgICAgICByZXR1cm4gdGQucGFyZW50RWxlbWVudC5uZXh0U2libGluZy5jaGlsZHJlblswXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRQcmV2aW91c0ZpZWxkOiBmdW5jdGlvbih0ZCkge1xuICAgICAgICBpZih0ZC5wcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZC5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0ZC5wYXJlbnRFbGVtZW50ICYmXG4gICAgICAgICAgIHRkLnBhcmVudEVsZW1lbnQucHJldmlvdXNTaWJsaW5nICYmXG4gICAgICAgICAgIHRkLnBhcmVudEVsZW1lbnQucHJldmlvdXNTaWJsaW5nLmNoaWxkcmVuICYmXG4gICAgICAgICAgIHRkLnBhcmVudEVsZW1lbnQucHJldmlvdXNTaWJsaW5nLmNoaWxkcmVuW3RkLnBhcmVudEVsZW1lbnQucHJldmlvdXNTaWJsaW5nLmNoaWxkcmVuLmxlbmd0aC0xXSAmJlxuICAgICAgICAgICB0ZC5wYXJlbnRFbGVtZW50LnByZXZpb3VzU2libGluZy5jaGlsZHJlblt0ZC5wYXJlbnRFbGVtZW50LnByZXZpb3VzU2libGluZy5jaGlsZHJlbi5sZW5ndGgtMV0udGFnTmFtZSA9PT0gJ1REJykge1xuICAgICAgICAgICAgIHJldHVybiB0ZC5wYXJlbnRFbGVtZW50LnByZXZpb3VzU2libGluZy5jaGlsZHJlblt0ZC5wYXJlbnRFbGVtZW50LnByZXZpb3VzU2libGluZy5jaGlsZHJlbi5sZW5ndGgtMV07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgb25LZXlVcDogZnVuY3Rpb24oZSwgZWRpdG9yKSB7XG4gICAgICAgIHZhciB0YXJnZXRGaWVsZCA9IG1vZHVsZS5leHBvcnRzLmdldFZlcnRpY2FsTmVpZ2hib3JGaWVsZChlZGl0b3IuY2FyZXQuZ2V0Q29udGV4dEVsZW1lbnQoJ3RkJykpO1xuXG4gICAgICAgIGlmKHRhcmdldEZpZWxkKSB7XG4gICAgICAgICAgICBlZGl0b3IuY2FyZXQucG9zaXRpb25Jbih0YXJnZXRGaWVsZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlZGl0b3IucGxhY2VDYXJldEludG9TZWN0aW9uKGVkaXRvci5mb2N1c2VkU2VjdGlvbigpLnByZXZpb3VzU2libGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSxcblxuICAgIG9uS2V5RG93bjogZnVuY3Rpb24oZSwgZWRpdG9yKSB7XG4gICAgICAgIHZhciB0YXJnZXRGaWVsZCA9IG1vZHVsZS5leHBvcnRzLmdldFZlcnRpY2FsTmVpZ2hib3JGaWVsZChlZGl0b3IuY2FyZXQuZ2V0Q29udGV4dEVsZW1lbnQoJ3RkJyksIHRydWUpO1xuXG4gICAgICAgIGlmKHRhcmdldEZpZWxkKSB7XG4gICAgICAgICAgICBlZGl0b3IuY2FyZXQucG9zaXRpb25Jbih0YXJnZXRGaWVsZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlZGl0b3IucGxhY2VDYXJldEludG9TZWN0aW9uKGVkaXRvci5mb2N1c2VkU2VjdGlvbigpLm5leHRTaWJsaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuXG4gICAgb25LZXlUYWI6IGZ1bmN0aW9uKGUsIGVkaXRvcikge1xuXG4gICAgICAgIHZhciBnZXRUYXJnZXRGaWVsZCA9IGUuc2hpZnRLZXkgPyBtb2R1bGUuZXhwb3J0cy5nZXRQcmV2aW91c0ZpZWxkOiBtb2R1bGUuZXhwb3J0cy5nZXROZXh0RmllbGQsXG4gICAgICAgICAgICB0YXJnZXRGaWVsZCA9IGdldFRhcmdldEZpZWxkKGVkaXRvci5jYXJldC5nZXRDb250ZXh0RWxlbWVudCgndGQnKSk7XG5cbiAgICAgICAgaWYodGFyZ2V0RmllbGQpIHtcbiAgICAgICAgICAgIGVkaXRvci5jYXJldC5wb3NpdGlvbkluKHRhcmdldEZpZWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuXG4gICAgb25LZXlFbnRlcjogZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSxcblxuICAgIG9uV2luZG93UmVzaXplOiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMub25TZWxlY3Rpb25DaGFuZ2UoZWRpdG9yLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgb25TZWxlY3Rpb25DaGFuZ2U6IGZ1bmN0aW9uKGVkaXRvciwgZm9yY2UpIHtcbiAgICAgICAgdmFyIGNlbGwgPSBlZGl0b3IuY2FyZXQuZ2V0Q29udGV4dEVsZW1lbnQoJ3RkJyk7XG5cbiAgICAgICAgaWYoIWNlbGwpIHtcbiAgICAgICAgICAgIHRoaXMub25VbmZvY3VzKGVkaXRvcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGFibGUgPSBjZWxsLnBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50O1xuXG4gICAgICAgIGlmKGZvY3VzZWRDZWxsICE9PSBjZWxsIHx8IGZvcmNlKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KG9uVW5mb2N1c1RpbWVvdXQpO1xuICAgICAgICAgICAgdmFyIGhiYXIgPSBnZXRIb3Jpem9udGFsQ29udHJvbHNCYXIoZWRpdG9yKTtcbiAgICAgICAgICAgIHZhciB2YmFyID0gZ2V0VmVydGljYWxDb250cm9sc0JhcihlZGl0b3IpO1xuICAgICAgICAgICAgdmFyIHRhYmxlUG9zID0gdXRpbHMuZ2V0RWxlbWVudFBvc2l0aW9uKHRhYmxlKTtcbiAgICAgICAgICAgIHZhciBjZWxsUG9zID0gdXRpbHMuZ2V0RWxlbWVudFBvc2l0aW9uKGNlbGwpO1xuXG4gICAgICAgICAgICBoYmFyLnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICAgICAgaGJhci5zdHlsZS50b3AgPSAodGFibGVQb3MueSAtIDMyKSArICdweCc7XG4gICAgICAgICAgICBoYmFyLnN0eWxlLmxlZnQgPSBNYXRoLmZsb29yKGNlbGxQb3MueCArICgoY2VsbC5vZmZzZXRXaWR0aC8yKS0oaGJhci5vZmZzZXRXaWR0aC8yKSkpICsgJ3B4JztcblxuICAgICAgICAgICAgdmJhci5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgICAgICAgIHZiYXIuc3R5bGUudG9wID0gTWF0aC5mbG9vcihjZWxsUG9zLnkgKyAoKGNlbGwub2Zmc2V0SGVpZ2h0LzIpLSh2YmFyLm9mZnNldEhlaWdodC8yKSkpICsgJ3B4JztcbiAgICAgICAgICAgIHZiYXIuc3R5bGUubGVmdCA9ICh0YWJsZVBvcy54IC0gMzApICsgJ3B4JztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvY3VzZWRDZWxsID0gY2VsbDtcbiAgICB9LFxuXG4gICAgb25VbmZvY3VzOiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgdmFyIGhiYXIgPSBnZXRIb3Jpem9udGFsQ29udHJvbHNCYXIoZWRpdG9yKTtcbiAgICAgICAgdmFyIHZiYXIgPSBnZXRWZXJ0aWNhbENvbnRyb2xzQmFyKGVkaXRvcik7XG5cbiAgICAgICAgbGFzdEZvY3VzZWRDZWxsID0gZm9jdXNlZENlbGw7XG4gICAgICAgIGZvY3VzZWRDZWxsID0gbnVsbDtcblxuICAgICAgICBoYmFyLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICB2YmFyLnN0eWxlLm9wYWNpdHkgPSAwO1xuXG4gICAgICAgIG9uVW5mb2N1c1RpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGhiYXIuc3R5bGUudG9wID0gLTEwMDAgKyAncHgnO1xuICAgICAgICAgICAgaGJhci5zdHlsZS5sZWZ0ID0gLTEwMDAgKyAncHgnO1xuXG4gICAgICAgICAgICB2YmFyLnN0eWxlLnRvcCA9IC0xMDAwICsgJ3B4JztcbiAgICAgICAgICAgIHZiYXIuc3R5bGUubGVmdCA9IC0xMDAwICsgJ3B4JztcbiAgICAgICAgfSwgMTAwKTtcbiAgICB9LFxuXG4gICAgb25LZXlDb21iaW5hdGlvbjogZnVuY3Rpb24oZSwgZWRpdG9yKSB7XG4gICAgICAgIGlmKChlLm1ldGFLZXkgfHwgZS5jdHJsS2V5KSAmJiAhZS5zaGlmdEtleSAmJiBlLmtleSA9PT0gJ3InKSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cy5hZGRSb3coZWRpdG9yLmNhcmV0LmdldENvbnRleHRFbGVtZW50KCd0ZCcpLCBlZGl0b3IpO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9IGVsc2UgaWYoKGUubWV0YUtleSB8fCBlLmN0cmxLZXkpICYmICFlLnNoaWZ0S2V5ICYmIGUua2V5ID09PSAnZScpIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzLmFkZENvbHVtbihlZGl0b3IuY2FyZXQuZ2V0Q29udGV4dEVsZW1lbnQoJ3RkJyksIGVkaXRvcik7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0gZWxzZSBpZigoZS5tZXRhS2V5IHx8IGUuY3RybEtleSkgJiYgZS5zaGlmdEtleSAmJiAoZS5rZXkgPT09ICdlJyB8fCBlLmtleSA9PT0gJ0UnKSApIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzLmRlbGV0ZUNvbHVtbihlZGl0b3IuY2FyZXQuZ2V0Q29udGV4dEVsZW1lbnQoJ3RkJyksIGVkaXRvcik7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0gZWxzZSBpZigoZS5tZXRhS2V5IHx8IGUuY3RybEtleSkgJiYgZS5zaGlmdEtleSAmJiAoZS5rZXkgPT09ICdyJyB8fCBlLmtleSA9PT0gJ1InKSApIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzLmRlbGV0ZVJvdyhlZGl0b3IuY2FyZXQuZ2V0Q29udGV4dEVsZW1lbnQoJ3RkJyksIGVkaXRvcik7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgYWRkUm93OiBmdW5jdGlvbihjb250ZXh0RWxlbWVudCwgZWRpdG9yLCBpbnNlcnRCZWZvcmUpIHtcbiAgICAgICAgdmFyIHNlbDtcbiAgICAgICAgaWYoIWNvbnRleHRFbGVtZW50ICYmICFlZGl0b3IpIHsgcmV0dXJuIH1cblxuICAgICAgICBjb250ZXh0RWxlbWVudCA9IGNvbnRleHRFbGVtZW50IHx8IGxhc3RGb2N1c2VkQ2VsbCB8fCBlZGl0b3IuY2FyZXQuZ2V0Q29udGV4dEVsZW1lbnQoJ3RkJyk7XG5cbiAgICAgICAgaWYoIWNvbnRleHRFbGVtZW50KSB7XG4gICAgICAgICAgICBzZWwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBpZihzZWwuYW5jaG9yTm9kZSA9PT0gc2VsLmZvY3VzTm9kZSAmJlxuICAgICAgICAgICAgICAgc2VsLmFuY2hvck5vZGUudGFnTmFtZSAmJlxuICAgICAgICAgICAgICAgc2VsLmFuY2hvck5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndGJvZHknKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dEVsZW1lbnQgPSBzZWwuYW5jaG9yTm9kZS5jaGlsZHJlbltzZWwuYW5jaG9yT2Zmc2V0XS5jaGlsZHJlblswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb2xjb3VudCA9IGNvbnRleHRFbGVtZW50LnBhcmVudE5vZGUuY2hpbGRyZW4ubGVuZ3RoLFxuICAgICAgICAgICAgY3VycmVudFRyID0gY29udGV4dEVsZW1lbnQucGFyZW50Tm9kZSxcbiAgICAgICAgICAgIHRib2R5ID0gY3VycmVudFRyLnBhcmVudE5vZGUsXG4gICAgICAgICAgICB0YWJsZSA9IGVkaXRvci5zZWN0aW9uQnlDaGlsZE5vZGUodGJvZHkpLFxuICAgICAgICAgICAgbmV3VHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xuXG4gICAgICAgIGZvcihsZXQgaT0wOyBpPGNvbGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIG5ld1RyLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGJvZHkuaW5zZXJ0QmVmb3JlKG5ld1RyLCBpbnNlcnRCZWZvcmUgPyBjdXJyZW50VHIgOiBjdXJyZW50VHIubmV4dFNpYmxpbmcpO1xuICAgICAgICBlZGl0b3IucmVwbGFjZVNlY3Rpb25XaXRoSFRNTCh0YWJsZSwgdGFibGUub3V0ZXJIVE1MKTtcbiAgICB9LFxuXG4gICAgYWRkQ29sdW1uOiBmdW5jdGlvbihjb250ZXh0RWxlbWVudCwgZWRpdG9yLCBpbnNlcnRMZWZ0KSB7XG4gICAgICAgIHZhciBzZWw7XG4gICAgICAgIGlmKCFjb250ZXh0RWxlbWVudCAmJiAhZWRpdG9yKSB7IHJldHVybiB9XG4gICAgICAgIGNvbnRleHRFbGVtZW50ID0gY29udGV4dEVsZW1lbnQgfHwgbGFzdEZvY3VzZWRDZWxsIHx8IGVkaXRvci5jYXJldC5nZXRDb250ZXh0RWxlbWVudCgndGQnKTtcblxuICAgICAgICBpZighY29udGV4dEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGlmKHNlbC5hbmNob3JOb2RlID09PSBzZWwuZm9jdXNOb2RlICYmXG4gICAgICAgICAgICAgICBzZWwuYW5jaG9yTm9kZS50YWdOYW1lICYmXG4gICAgICAgICAgICAgICBzZWwuYW5jaG9yTm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0cicpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0RWxlbWVudCA9IHNlbC5hbmNob3JOb2RlLmNoaWxkcmVuW3NlbC5hbmNob3JPZmZzZXRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbEluZGV4ID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChjb250ZXh0RWxlbWVudC5wYXJlbnROb2RlLmNoaWxkcmVuLCBjb250ZXh0RWxlbWVudCksXG4gICAgICAgICAgICB0YWJsZVJvd3MgPSBjb250ZXh0RWxlbWVudC5wYXJlbnROb2RlLnBhcmVudE5vZGUuY2hpbGRyZW4sXG4gICAgICAgICAgICB0YWJsZSA9IGNvbnRleHRFbGVtZW50LnBhcmVudE5vZGUucGFyZW50Tm9kZS5wYXJlbnROb2RlO1xuXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwodGFibGVSb3dzLCBmdW5jdGlvbih0cikge1xuICAgICAgICAgICAgdHIuaW5zZXJ0QmVmb3JlKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyksIGluc2VydExlZnQgPyB0ci5jaGlsZHJlbltjb2xJbmRleF0gOiB0ci5jaGlsZHJlbltjb2xJbmRleF0ubmV4dFNpYmxpbmcpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGVkaXRvci5yZXBsYWNlU2VjdGlvbldpdGhIVE1MKHRhYmxlLCB0YWJsZS5vdXRlckhUTUwpO1xuICAgIH0sXG5cbiAgICBkZWxldGVDb2x1bW46IGZ1bmN0aW9uKGNvbnRleHRFbGVtZW50LCBlZGl0b3IpIHtcbiAgICAgICAgdmFyIHNlbDtcblxuICAgICAgICBpZighY29udGV4dEVsZW1lbnQgJiYgIWVkaXRvcikgeyByZXR1cm4gfVxuXG4gICAgICAgIGNvbnRleHRFbGVtZW50ID0gY29udGV4dEVsZW1lbnQgfHwgbGFzdEZvY3VzZWRDZWxsIHx8IGVkaXRvci5jYXJldC5nZXRDb250ZXh0RWxlbWVudCgndGQnKTtcblxuICAgICAgICBpZighY29udGV4dEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGlmKHNlbC5hbmNob3JOb2RlID09PSBzZWwuZm9jdXNOb2RlICYmXG4gICAgICAgICAgICAgICBzZWwuYW5jaG9yTm9kZS50YWdOYW1lICYmXG4gICAgICAgICAgICAgICBzZWwuYW5jaG9yTm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0cicpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0RWxlbWVudCA9IHNlbC5hbmNob3JOb2RlLmNoaWxkcmVuW3NlbC5hbmNob3JPZmZzZXRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbHVtbnMgPSBjb250ZXh0RWxlbWVudC5wYXJlbnROb2RlLmNoaWxkcmVuLFxuICAgICAgICAgICAgY29sSW5kZXggPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGNvbHVtbnMsIGNvbnRleHRFbGVtZW50KSxcbiAgICAgICAgICAgIHRhYmxlUm93cyA9IGNvbnRleHRFbGVtZW50LnBhcmVudE5vZGUucGFyZW50Tm9kZS5jaGlsZHJlbixcbiAgICAgICAgICAgIHRhYmxlID0gY29udGV4dEVsZW1lbnQucGFyZW50Tm9kZS5wYXJlbnROb2RlLnBhcmVudE5vZGU7XG5cbiAgICAgICAgaWYoY29sdW1ucy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbCh0YWJsZVJvd3MsIGZ1bmN0aW9uKHRyKSB7XG4gICAgICAgICAgICB0ci5yZW1vdmVDaGlsZCh0ci5jaGlsZHJlbltjb2xJbmRleF0pXG4gICAgICAgIH0pO1xuICAgICAgICBlZGl0b3IucmVwbGFjZVNlY3Rpb25XaXRoSFRNTCh0YWJsZSwgdGFibGUub3V0ZXJIVE1MKTtcbiAgICB9LFxuXG4gICAgZGVsZXRlUm93OiBmdW5jdGlvbihjb250ZXh0RWxlbWVudCwgZWRpdG9yKSB7XG4gICAgICAgIHZhciBzZWwsIHRhYmxlO1xuXG4gICAgICAgIGlmKCFjb250ZXh0RWxlbWVudCAmJiAhZWRpdG9yKSB7IHJldHVybiB9XG5cbiAgICAgICAgY29udGV4dEVsZW1lbnQgPSBjb250ZXh0RWxlbWVudCB8fCBsYXN0Rm9jdXNlZENlbGwgfHwgZWRpdG9yLmNhcmV0LmdldENvbnRleHRFbGVtZW50KCd0ZCcpO1xuICAgICAgICBjb250ZXh0RWxlbWVudCA9IGNvbnRleHRFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG5cbiAgICAgICAgaWYoIWNvbnRleHRFbGVtZW50KSB7XG4gICAgICAgICAgICBzZWwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBpZihzZWwuYW5jaG9yTm9kZSA9PT0gc2VsLmZvY3VzTm9kZSAmJlxuICAgICAgICAgICAgICAgc2VsLmFuY2hvck5vZGUudGFnTmFtZSAmJlxuICAgICAgICAgICAgICAgc2VsLmFuY2hvck5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndGJvZHknKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dEVsZW1lbnQgPSBzZWwuYW5jaG9yTm9kZS5jaGlsZHJlbltzZWwuYW5jaG9yT2Zmc2V0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRhYmxlID0gY29udGV4dEVsZW1lbnQucGFyZW50Tm9kZS5wYXJlbnROb2RlO1xuXG4gICAgICAgIGlmKGNvbnRleHRFbGVtZW50LnBhcmVudE5vZGUuY2hpbGRyZW4ubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHRFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICBlZGl0b3IucmVwbGFjZVNlY3Rpb25XaXRoSFRNTCh0YWJsZSwgdGFibGUub3V0ZXJIVE1MKTtcbiAgICB9LFxuXG4gICAgb25LZXlCYWNrc3BhY2U6IGZ1bmN0aW9uKGUsIGVkaXRvcikge1xuICAgICAgICB2YXIgc2VsLFxuICAgICAgICAgICAgdGFibGUgPSBlZGl0b3IuY2FyZXQuZ2V0Q29udGV4dEVsZW1lbnQoJ3RhYmxlJyksXG4gICAgICAgICAgICBjYXB0aW9uID0gZWRpdG9yLmNhcmV0LmdldENvbnRleHRFbGVtZW50KCdjYXB0aW9uJywgd2luZG93LmdldFNlbGVjdGlvbigpLCBbXSksXG4gICAgICAgICAgICB0ZCA9IGVkaXRvci5jYXJldC5nZXRDb250ZXh0RWxlbWVudCgndGQnLCB3aW5kb3cuZ2V0U2VsZWN0aW9uKCksIFtdKSxcbiAgICAgICAgICAgIGluQ2FwdGlvbiA9ICEhY2FwdGlvbixcbiAgICAgICAgICAgIGVsID0gdGQgfHwgY2FwdGlvbixcbiAgICAgICAgICAgIHRhYmxlSWQgPSB0YWJsZS5pZCxcbiAgICAgICAgICAgIHRyLCB0ckluZGV4LCB0ZEluZGV4O1xuXG4gICAgICAgIGlmKCFlbCkgcmV0dXJuO1xuXG4gICAgICAgIGlmKGVsLmlubmVyVGV4dCAmJiBlbC5pbm5lclRleHQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBpZighaW5DYXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgdHIgPSB0ZC5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgIHRkSW5kZXggPSB0ci5jaGlsZHJlbi5pbmRleE9mKHRkKTtcbiAgICAgICAgICAgICAgICB0ckluZGV4ID0gdHIucGFyZW50RWxlbWVudC5jaGlsZHJlbi5pbmRleE9mKHRyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ2RlbGV0ZScpO1xuXG4gICAgICAgICAgICB0YWJsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRhYmxlSWQpO1xuXG4gICAgICAgICAgICBpZighaW5DYXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgZWwgPSB0YWJsZS5xdWVyeVNlbGVjdG9yKCd0Ym9keScpLmNoaWxkcmVuW3RySW5kZXhdLmNoaWxkcmVuW3RkSW5kZXhdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbCA9IHRhYmxlLnF1ZXJ5U2VsZWN0b3IoJ2NhcHRpb24nKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlZGl0b3IuY2FyZXQucG9zaXRpb25JbihlbCk7XG5cbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSBlbHNlIGlmKCFlbC5pbm5lclRleHQgfHwgZWwuaW5uZXJUZXh0Lmxlbmd0aCA9PT0gMCB8fCBlZGl0b3IuY2FyZXQuaXNDb2xsYXBzZWRBbmRQb3NpdGlvbmVkQXRUaGVCZWdpbm5pbmdPZihjYXB0aW9uLCBmYWxzZSkpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRTZWN0aW9uRWxlbWVudDogZ2V0U2VjdGlvbkVsZW1lbnRcbn0pXG4iLCJ2YXIgYnVpbGRUb0MgPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvdG9jX2J1aWxkZXIvdG9jX2J1aWxkZXInKSxcbiAgICBiaWJTZWN0aW9uVHlwZSA9IHJlcXVpcmUoJy4uL2JpYmxpb2dyYXBoaWUvYmlibGlvZ3JhcGhpZV9zZWN0aW9uX3R5cGUnKSxcbiAgICB1dWlkID0gcmVxdWlyZSgndXVpZC92MScpO1xuXG5mdW5jdGlvbiBnZXRTZWN0aW9uRWxlbWVudCgpIHtcbiAgICB2YXIgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbmF2JyksXG4gICAgICAgICBoZWFkaW5nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDInKTtcblxuICAgIGhlYWRpbmcuc2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnLCAndHJ1ZScpO1xuICAgIGhlYWRpbmcuY2xhc3NMaXN0LmFkZCgndG9jLWhlYWRpbmcnKTtcbiAgICBoZWFkaW5nLmNsYXNzTGlzdC5hZGQoJ25vLXRvYy1saXN0aW5nJyk7XG4gICAgaGVhZGluZy5pbm5lckhUTUwgPSAnVGFibGUgb2YgQ29udGVudHMnO1xuXG4gICAgZWwub25LZXlCYWNrc3BhY2UgPSBtb2R1bGUuZXhwb3J0cy5vbktleUJhY2tzcGFjZTtcbiAgICBlbC5zZWN0aW9uVHlwZSA9IG1vZHVsZS5leHBvcnRzO1xuICAgIGVsLmNsYXNzTGlzdC5hZGQoJ3RvYycpO1xuICAgIGVsLmFwcGVuZENoaWxkKGhlYWRpbmcpO1xuXG4gICAgcmV0dXJuIGVsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIG5hbWU6ICd0b2MnLFxuXG4gICAgcHJlZmVycmVkQ2FyZXRQb3NpdGlvbmluZzogJ2VuZCcsXG5cbiAgICBjb250ZW50UnVsZXM6IHtcbiAgICAgICAgJ3RvYyc6IHtcbiAgICAgICAgICAgIHRhZ05hbWU6ICduYXYnLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAndG9jJyxcbiAgICAgICAgICAgIGFsbG93ZWRBdHRyaWJ1dGVzOiBbJ2NsYXNzJywgJ2NvbnRlbnRlZGl0YWJsZSddLFxuICAgICAgICAgICAgYWxsb3dlZENsYXNzTmFtZXM6IFsnZm9jdXNlZCcsICd0b2MnXSxcbiAgICAgICAgICAgIGFsbG93ZWRDaGlsZHJlbjogWyd0b2MtaGVhZGluZyddLFxuICAgICAgICAgICAgYWxsb3dlZFRvQmVSb290OiB0cnVlLFxuICAgICAgICAgICAgZGVsZXRlSWZFbXB0eTogZmFsc2UsXG4gICAgICAgICAgICBidWlsZEVtcHR5RWxlbWVudDogZ2V0U2VjdGlvbkVsZW1lbnRcbiAgICAgICAgfSxcbiAgICAgICAgJ3RvYy1oZWFkaW5nJzoge1xuICAgICAgICAgICAgdGFnTmFtZTogJ2gyJyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ3RvYy1oZWFkaW5nJyxcbiAgICAgICAgICAgIGFsbG93ZWRBdHRyaWJ1dGVzOiBbJ2lkJywgJ2NsYXNzJywgJ2NvbnRlbnRlZGl0YWJsZScsICd1bm51bWJlcmVkLWhlYWRpbmcnXSxcbiAgICAgICAgICAgIGFsbG93ZWRDbGFzc05hbWVzOiBbJ3RvYy1oZWFkaW5nJywgJ25vLXRvYy1saXN0aW5nJ10sXG4gICAgICAgICAgICBhbGxvd2VkQ2hpbGRyZW46IFsnI3RleHQnXSxcbiAgICAgICAgICAgIHBydW5lU3BhY2VzOiB0cnVlLFxuICAgICAgICAgICAgYnVpbGRBdHRyaWJ1dGVzOiBbXG4gICAgICAgICAgICAgICAge25hbWU6ICdpZCcsIGJ1aWxkOiBmdW5jdGlvbigpIHtyZXR1cm4gdXVpZCgpfX0sXG4gICAgICAgICAgICAgICAge25hbWU6ICd1bm51bWJlcmVkLWhlYWRpbmcnLCBidWlsZDogZnVuY3Rpb24oKSB7cmV0dXJuICdZZXMnfX1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICB9LFxuXG4gICAgZW5yaWNobWVudHM6IFtdLFxuXG4gICAgZ2V0U2VjdGlvbkVsZW1lbnQ6IGdldFNlY3Rpb25FbGVtZW50LFxuXG4gICAgb25LZXlCYWNrc3BhY2U6IGJpYlNlY3Rpb25UeXBlLm9uS2V5QmFja3NwYWNlLFxuXG4gICAgb25Gb2N1czogZnVuY3Rpb24oZWwsIGVkaXRvciwgYXJncykge1xuICAgICAgICB2YXIgdG9DSGVhZGluZyA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ2gyJyksXG4gICAgICAgICAgICBpc0NhcmV0SW5zaWRlU2VjdGlvbiA9IChlZGl0b3Iuc2VjdGlvbkF0Q2FyZXRQb3N0aW9uKCkgPT09IGVsICYmIGVkaXRvci5jYXJldC5nZXRDb250ZXh0RWxlbWVudCgnaDInKSksXG4gICAgICAgICAgICBoYXNCZWVuRm9jdXNlZEFmdGVyU2VjdGlvblR5cGVDaGFuZ2UgPSBhcmdzLmFjdGlvbiA9PT0gJ2NoYW5nZUZvY3VzZWRTZWN0aW9uVHlwZSc7XG5cbiAgICAgICAgaWYoaGFzQmVlbkZvY3VzZWRBZnRlclNlY3Rpb25UeXBlQ2hhbmdlIHx8ICFpc0NhcmV0SW5zaWRlU2VjdGlvbikge1xuICAgICAgICAgICAgdG9DSGVhZGluZyAmJiBlZGl0b3IuY2FyZXQucG9zaXRpb25Jbih0b0NIZWFkaW5nKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvbkVkaXRvckNvbnRlbnRDaGFuZ2VkOiBmdW5jdGlvbihtb2RpZmljYXRpb25Mb2cpIHtcbiAgICAgICAgaWYoIW1vZGlmaWNhdGlvbkxvZy5taWdodEluY2x1ZGVIZWFkaW5nVXBkYXRlcyAmJiAhbW9kaWZpY2F0aW9uTG9nLm1pZ2h0SW5jbHVkZVRhYmxlT2ZDb250ZW50VXBkYXRlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRvY1NlY3Rpb25zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnbmF2LnRvYycpLFxuICAgICAgICAgICAgbmV3Q29udGVudCwgdG1wRWwsIHRvYztcblxuICAgICAgICBpZih0b2NTZWN0aW9ucy5sZW5ndGggPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgdG9jID0gYnVpbGRUb0MoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnN0cnVjdHVyZWQtdGV4dC1lZGl0b3InKSwge3dpdGhMaW5rczogdHJ1ZSwgc3RhcnROdW1iZXJpbmdBdExldmVsOiAyfSk7XG4gICAgICAgIHRvYy5xdWVyeVNlbGVjdG9yQWxsKCdvbCwgbGknKS5mb3JFYWNoKGZ1bmN0aW9uKGVudHJ5KSB7IGVudHJ5LmNsYXNzTGlzdC5hZGQoJ3RvYycpIH0pO1xuICAgICAgICB0b2MuY2xhc3NMaXN0LmFkZCgndG9jJyk7XG5cbiAgICAgICAgaWYodG9jLmlubmVySFRNTCA9PT0gJycpIHtcbiAgICAgICAgICAgIG5ld0NvbnRlbnQgPSAnPHNwYW4gY2xhc3M9XCJoaW50XCI+SW5zZXJ0IHNvbWUgaGVhZGluZ3MgaW50byB5b3VyIGRvY3VtZW50IHRvIHNlZSBhIHRhYmxlIG9mIGNvbnRlbnRzIGhlcmUuPC9zcGFuPic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdDb250ZW50ID0gdG9jLm91dGVySFRNTDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRvY1NlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24odG9jU2VjdGlvbikge1xuICAgICAgICAgICAgdG9jU2VjdGlvbi5zdW1tYXJpemVkQ29udGVudExlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRtcEVsID0gdG9jU2VjdGlvbi5xdWVyeVNlbGVjdG9yKCcudG9jLWNvbnRlbnQnKTtcblxuICAgICAgICAgICAgaWYoIXRtcEVsKSB7XG4gICAgICAgICAgICAgICAgdG1wRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICAgICAgdG1wRWwuY2xhc3NMaXN0LmFkZCgndG9jLWNvbnRlbnQnKTtcbiAgICAgICAgICAgICAgICB0b2NTZWN0aW9uLmFwcGVuZENoaWxkKHRtcEVsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG1wRWwuc2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnLCAnZmFsc2UnKTtcblxuICAgICAgICAgICAgaWYodG1wRWwuaW5uZXJIVE1MICE9PSBuZXdDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgdG1wRWwuaW5uZXJIVE1MID0gbmV3Q29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2FyZXQgPSByZXF1aXJlKCcuL2NhcmV0JyksXG4gICAgSFRNTFJhem9yID0gcmVxdWlyZSgnLi4vbGliL2h0bWxfcmF6b3IvaHRtbF9yYXpvcicpLFxuICAgIHV0aWxzID0gcmVxdWlyZSgnLi4vbGliL3BpeGVsc2NodWJzZXIvdXRpbHMnKSxcbiAgICAvLyBrYXRleCA9IHJlcXVpcmUoJ2thdGV4JyksIC8vIG1ha2Ugc3VyZSB0byBsb2FkIDxzY3JpcHQgc3JjPVwiLi9rYXRleC5qc1wiIGRlZmVyPjwvc2NyaXB0PiBpbiB5b3VyIGh0bWxcbiAgICBsYXRleENoZWF0c2hlZXQgPSByZXF1aXJlKCcuLi9hc3NldHMvbGF0ZXhfY2hlYXRzaGVldCcpLFxuICAgIERlY2xhcmF0aXZGb3JtID0gcmVxdWlyZSgnLi4vbGliL2RlY2xhcmF0aXZfZm9ybXMvc3JjL2RlY2xhcmF0aXZfZm9ybScpLFxuICAgIHsgZ2V0UmVmZXJlbmNlU291cmNlc0ZpZWxkcywgc3luY0FsbFNvdXJjZXMgfSA9IHJlcXVpcmUoJy4vcmVmZXJlbmNlcy9yZWZlcmVuY2Vfc291cmNlcycpXG5cbmZ1bmN0aW9uIFRleHRFbnJpY2htZW50Q29udHJvbChlZGl0b3IpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLmNhcmV0ID0gbmV3IENhcmV0KGVkaXRvcik7XG4gICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XG4gICAgdGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kb21FbGVtZW50LmNsYXNzTmFtZSArPSAnIHRleHRFbnJpY2htZW50Q29udHJvbCc7XG4gICAgdGhpcy5oaWRlKCk7XG5cbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuZG9tRWxlbWVudCk7XG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyIChcImtleWRvd25cIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYoZS5jb2RlID09PSAnRXNjYXBlJykge1xuICAgICAgICAgICAgc2VsZi5lZGl0b3IudW5mcmVlemVTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHNlbGYuaGlkZSh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgdGhpcy5lbnJpY2htZW50cyA9IFtcbiAgICAgICAge2NsYXNzTmFtZTogJ2l0YWxpYycsICAgICBjb21tYW5kOiAnaXRhbGljJywgICAgICAgIGRpcGxheU5hbWU6ICc8aT5JPC9pPicsIGFsbG93ZWRDb250ZXh0OiBbJ3AnLCAndGFibGUnLCAnb2wnLCAndWwnXSwgbm90QWxsb3dlZENvbnRleHQ6IFsnY2FwdGlvbicsICduYXYnXX0sXG4gICAgICAgIHtjbGFzc05hbWU6ICdib2xkJywgICAgICAgY29tbWFuZDogJ2JvbGQnLCAgICAgICAgICBkaXBsYXlOYW1lOiAnPGI+QjwvYj4nLCBhbGxvd2VkQ29udGV4dDogWydwJywgJ3RhYmxlJywgJ29sJywgJ3VsJ10sIG5vdEFsbG93ZWRDb250ZXh0OiBbJ2NhcHRpb24nLCAnbmF2J119LFxuICAgICAgICB7Y2xhc3NOYW1lOiAndW5kZXJsaW5lJywgIGNvbW1hbmQ6ICd1bmRlcmxpbmUnLCAgICAgZGlwbGF5TmFtZTogJzx1PlU8L3U+JywgYWxsb3dlZENvbnRleHQ6IFsncCcsICd0YWJsZScsICdvbCcsICd1bCddLCBub3RBbGxvd2VkQ29udGV4dDogWydjYXB0aW9uJywgJ25hdiddfSxcbiAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAnY29kZScsXG4gICAgICAgICAgICBkaXBsYXlOYW1lOiAnPGNvZGUgY2xhc3M9XCJjb2RlLXRleHQtZW5yaWNobWVudC1idXR0b25cIj48aSBjbGFzcz1cImZhcyBmYS1jb2RlXCI+PC9pPjwvY29kZT4nLFxuICAgICAgICAgICAgYWxsb3dlZENvbnRleHQ6IFsncCcsICd0YWJsZScsICdvbCcsICd1bCddLFxuICAgICAgICAgICAgbm90QWxsb3dlZENvbnRleHQ6IFsnY2FwdGlvbicsICduYXYnXSxcbiAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBzZWwuZ2V0UmFuZ2VBdCgwKSxcbiAgICAgICAgICAgICAgICAgICAgbmV3RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lubGluZWNvZGUnKSxcbiAgICAgICAgICAgICAgICAgICAgc2VjdGlvbiA9IHNlbGYuZWRpdG9yLmZvY3VzZWRTZWN0aW9uKCksXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRFbCA9IHNlbGYuY2FyZXQuZ2V0Q29udGV4dEVsZW1lbnQoJ2lubGluZWNvZGUnKSxcbiAgICAgICAgICAgICAgICAgICAgYWxsQ29kZXNJblNlY3Rpb24sIGNvbnRlbnQsIHRleHROb2RlTGVmdCwgdGV4dE5vZGVSaWdodDtcblxuICAgICAgICAgICAgICAgIGlmKGNvbnRleHRFbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gcmFuZ2UuZXh0cmFjdENvbnRlbnRzKCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBzZWwuZ2V0UmFuZ2VBdCgwKTtcblxuICAgICAgICAgICAgICAgICAgICB0ZXh0Tm9kZUxlZnQgPSBzZWwuZm9jdXNOb2RlO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0Tm9kZVJpZ2h0ID0gdGV4dE5vZGVMZWZ0LnNwbGl0VGV4dChzZWwuZm9jdXNPZmZzZXQpO1xuXG4gICAgICAgICAgICAgICAgICAgIG5ld0VsZW1lbnQuYXBwZW5kQ2hpbGQodGV4dE5vZGVSaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRFbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdFbGVtZW50LCBjb250ZXh0RWwubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0RWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY29udGVudCwgY29udGV4dEVsLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdFbGVtZW50LmFwcGVuZENoaWxkKHJhbmdlLmV4dHJhY3RDb250ZW50cygpKTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UuaW5zZXJ0Tm9kZShuZXdFbGVtZW50KTtcblxuICAgICAgICAgICAgICAgICAgICBhbGxDb2Rlc0luU2VjdGlvbiA9IHNlY3Rpb24ucXVlcnlTZWxlY3RvckFsbCgnaW5saW5lY29kZScpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaT0wOyBpPGFsbENvZGVzSW5TZWN0aW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGFsbENvZGVzSW5TZWN0aW9uW2ldLm5leHRTaWJsaW5nO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihuZXh0ICYmIG5leHQudGFnTmFtZSA9PT0gJ0lOTElORUNPREUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsQ29kZXNJblNlY3Rpb25baV0uaW5uZXJIVE1MICs9IG5leHQuaW5uZXJIVE1MO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsQ29kZXNJblNlY3Rpb24gPSBzZWN0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lubGluZWNvZGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpPS0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihuZXh0ICYmIG5leHQubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFICYmIG5leHQudGV4dENvbnRlbnQgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxDb2Rlc0luU2VjdGlvbiA9IHNlY3Rpb24ucXVlcnlTZWxlY3RvckFsbCgnaW5saW5lY29kZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGk9LTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZWxmLmhpZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAnbGluaycsXG4gICAgICAgICAgICBjb21tYW5kOiAnY3JlYXRlTGluaycsXG4gICAgICAgICAgICBkaXBsYXlOYW1lOiAnPGkgY2xhc3M9XCJmYXMgZmEtbGluayBmYS14c1wiPjwvaT4nLFxuICAgICAgICAgICAgYWxsb3dlZENvbnRleHQ6IFsncCcsICd0YWJsZScsICdvbCcsICd1bCddLFxuICAgICAgICAgICAgbm90QWxsb3dlZENvbnRleHQ6IFsnYScsICdjYXB0aW9uJywgJ25hdiddLFxuICAgICAgICAgICAgYXJndW1lbnRzOiBbe25hbWU6ICd1cmwnLCBwbGFjZWhvbGRlcjogJ2h0dHA6Ly8uLi4nLCBkaXNwbGF5TmFtZTogJ1VSTCcsIHR5cGU6ICd0ZXh0J31dXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ3VubGluaycsXG4gICAgICAgICAgICByYW5nZVJlcXVpcmU6IGZhbHNlLFxuICAgICAgICAgICAgZGlwbGF5TmFtZTogJzxpIGNsYXNzPVwiZmFzIGZhLXVubGluayBmYS14c1wiPjwvaT4nLFxuICAgICAgICAgICAgYWxsb3dlZENvbnRleHQ6ICdhJyxcbiAgICAgICAgICAgIG5vdEFsbG93ZWRDb250ZXh0OiBbJ25hdiddLFxuICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbihjb250ZXh0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBjb250ZXh0RWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjb250ZXh0RWxlbWVudC5maXJzdENoaWxkKSBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNvbnRleHRFbGVtZW50LmZpcnN0Q2hpbGQsIGNvbnRleHRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoY29udGV4dEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHNlbGYuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICByYW5nZVJlcXVpcmU6IGZhbHNlLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAndmlzaXQtbGluaycsXG4gICAgICAgICAgICBkaXBsYXlOYW1lOiAnPGkgY2xhc3M9XCJmYXMgZmEtZXh0ZXJuYWwtbGluay1hbHQgZmEteHNcIj48L2k+JyxcbiAgICAgICAgICAgIGFsbG93ZWRDb250ZXh0OiAnYScsXG4gICAgICAgICAgICBub3RBbGxvd2VkQ29udGV4dDogWyduYXYnXSxcbiAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oY29udGV4dEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZihuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKCdNb25zdGVyV3JpdGVyJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZWZpeCA9ICcnXG4gICAgICAgICAgICAgICAgICAgIGlmKCFjb250ZXh0RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKS5tYXRjaCgvXmh0dHBzPzpcXC9cXC8vaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeCA9ICdodHRwczovLydcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyByZXF1aXJlKCdlbGVjdHJvbicpLnNoZWxsLm9wZW5FeHRlcm5hbChwcmVmaXggKyBjb250ZXh0RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cub3Blbihjb250ZXh0RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2VkaXQtZm9vdG5vdGUnLFxuICAgICAgICAgICAgcmFuZ2VSZXF1aXJlOiBmYWxzZSxcbiAgICAgICAgICAgIGRpcGxheU5hbWU6ICc8aSBjbGFzcz1cImZhcyBmYS1lZGl0IGZhLXhzXCI+PC9pPicsXG4gICAgICAgICAgICBhbGxvd2VkQ29udGV4dDogJy5mb290bm90ZScsXG4gICAgICAgICAgICBub3RBbGxvd2VkQ29udGV4dDogWydjYXB0aW9uJ10sXG4gICAgICAgICAgICBhcmd1bWVudHM6IFt7XG4gICAgICAgICAgICAgICAgbmFtZTogJ25vdGUnLFxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiAnZm9vdG5vdGUnLFxuICAgICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiAnRm9vdG5vdGUnLFxuICAgICAgICAgICAgICAgIGxhcmdldGV4dDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IGZ1bmN0aW9uKGNvbnRleHRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKCEoY29udGV4dEVsZW1lbnQgJiYgY29udGV4dEVsZW1lbnQuZGF0YXNldCAmJiBjb250ZXh0RWxlbWVudC5kYXRhc2V0Lm5vdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXRpbHMuYXR0cmlidXRlU2F2ZVN0cmluZ1RvU3RyaW5nKChuZXcgSFRNTFJhem9yKS5zdHJpcChjb250ZXh0RWxlbWVudC5kYXRhc2V0Lm5vdGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oY29udGV4dEVsZW1lbnQsIGFyZ1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYoIWFyZ1ZhbHVlLm5vdGUpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZih0eXBlb2YgYXJnVmFsdWUubm90ZSAhPT0gJ3N0cmluZycpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZihhcmdWYWx1ZS5ub3RlLnRyaW0oKSA9PT0gJycpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIGNvbnRleHRFbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1ub3RlJywgdXRpbHMuc3RyaW5nVG9BdHRyaWJ1dGVTYXZlU3RyaW5nKGFyZ1ZhbHVlLm5vdGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAnZm9vdG5vdGUtY29udGVudCcsXG4gICAgICAgICAgICByYW5nZVJlcXVpcmU6IGZhbHNlLFxuICAgICAgICAgICAgZGlwbGF5TmFtZTogZnVuY3Rpb24oY29udGV4dEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dEVsZW1lbnQuaW5uZXJUZXh0ICsgJzogJyArIHV0aWxzLmF0dHJpYnV0ZVNhdmVTdHJpbmdUb0hUTUxFbmNvZGVkKGNvbnRleHRFbGVtZW50LmRhdGFzZXQubm90ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWxsb3dlZENvbnRleHQ6ICcuZm9vdG5vdGUnLFxuICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbigpIHt9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJhbmdlUmVxdWlyZTogZmFsc2UsXG4gICAgICAgICAgICBpbnNlcnRBY3Rpb246IHRydWUsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdmb290bm90ZScsXG4gICAgICAgICAgICBkaXBsYXlOYW1lOiAnZm48c3VwPio8L3N1cD4nLFxuICAgICAgICAgICAgYWxsb3dlZENvbnRleHQ6IFsncCcsICd0YWJsZScsICdvbCcsICd1bCddLFxuICAgICAgICAgICAgbm90QWxsb3dlZENvbnRleHQ6IFsnY2FwdGlvbicsICduYXYnXSxcbiAgICAgICAgICAgIGFyZ3VtZW50czogW3tuYW1lOiAnbm90ZScsIHBsYWNlaG9sZGVyOiAnZm9vdG5vdGUnLCBkaXNwbGF5TmFtZTogJ0Zvb3Rub3RlJywgbGFyZ2V0ZXh0OiB0cnVlfV0sXG4gICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKGNvbnRleHRFbGVtZW50LCBhcmdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmKCFhcmdWYWx1ZS5ub3RlKSByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYodHlwZW9mIGFyZ1ZhbHVlLm5vdGUgIT09ICdzdHJpbmcnKSByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYoYXJnVmFsdWUubm90ZS50cmltKCkgPT09ICcnKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcblxuICAgICAgICAgICAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZCgnZm9vdG5vdGUnKTtcbiAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnZGF0YS1ub3RlJywgdXRpbHMuc3RyaW5nVG9BdHRyaWJ1dGVTYXZlU3RyaW5nKGFyZ1ZhbHVlLm5vdGUpKTtcbiAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHNlbGYuY2FyZXQuaW5zZXJ0Tm9kZShub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgcmFuZ2VSZXF1aXJlOiBmYWxzZSxcbiAgICAgICAgICAgIGluc2VydEFjdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ3JlZicsXG4gICAgICAgICAgICBkaXBsYXlOYW1lOiAncmVmJyxcbiAgICAgICAgICAgIGFsbG93ZWRDb250ZXh0OiBbJ3AnLCAndGFibGUnLCAnb2wnLCAndWwnLCAnY2l0ZXNyYycsICdjYXB0aW9uJywgJ2ZpZ2NhcHRpb24nXSxcbiAgICAgICAgICAgIG5vdEFsbG93ZWRDb250ZXh0OiBbJ2EnLCAnYmxvY2txdW90ZScsICdjb2RlJ10sXG4gICAgICAgICAgICBub3RGb2N1c0ZpcnN0SW5wdXQ6IHRydWUsXG4gICAgICAgICAgICBhcmd1bWVudHM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGFsbG93ZWRWYWx1ZXM6IGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VsZi5lZGl0b3IucmVmZXJlbmNlLmdldFZhbHVlc0ZvckNyb3NzUmVmZXJlbmNlU2VsZWN0Qm94KCkgfSxcbiAgICAgICAgICAgICAgICAgICAgaXNBY3RpdmU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VsZi5lZGl0b3IucmVmZXJlbmNlLmdldFZhbHVlc0ZvckNyb3NzUmVmZXJlbmNlU2VsZWN0Qm94KCkubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdjcm9zcy1yZWYnLFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZTogJ1JlZmVyZW5jZSBhIHBhcnQgb2YgeW91ciBkb2N1bWVudCAoZmlndXJlcywgdGFibGVzLCAuLi4pOicsXG4gICAgICAgICAgICAgICAgICAgIHRhYjogJ0Nyb3NzLVJlZmVyZW5jZSdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ25vLWNyb3NzLXJlZi1hdmFpbGFibGUtaGludCcsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICc8ZGl2IGNsYXNzPVwibm8tZGF0YS1oaW50XCI+PGRpdiBjbGFzcz1cIm5vLWRhdGEtaWNvblwiPjwvZGl2PjxkaXYgY2xhc3M9XCJuby1kYXRhLW1lc3NhZ2UtaGVhZGluZ1wiPk5vIENyb3NzLVJlZmVyZW5jZXMgQXZhaWxhYmxlITwvZGl2PjxkaXYgY2xhc3M9XCJuby1kYXRhLW1lc3NhZ2VcIj5PbmNlIHlvdSBoYXZlIGluc2VydGVkIGEgaGVhZGluZywgdGFibGUsIGltYWdlLCBldGMuIGludG8geW91ciBkb2N1bWVudCwgeW91IHdpbGwgYmUgYWJsZSB0byByZWZlcmVuY2Uvc2VsZWN0IGl0IGhlcmUuPC9kaXY+PC9kaXY+JyxcbiAgICAgICAgICAgICAgICAgICAgaXNBY3RpdmU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gIXNlbGYuZWRpdG9yLnJlZmVyZW5jZS5nZXRWYWx1ZXNGb3JDcm9zc1JlZmVyZW5jZVNlbGVjdEJveCgpLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICB0YWI6ICdDcm9zcy1SZWZlcmVuY2UnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJlbG9hZE9uQ2hhbmdlT2Y6IFsnZmV0Y2gtcmVmLWJ0bicsICdtYW5hZ2UtcmVmLWJ0biddLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd2VkVmFsdWVzOiBmdW5jdGlvbigpIHsgcmV0dXJuIHNlbGYuZWRpdG9yLnJlZmVyZW5jZS5nZXRWYWx1ZXNGb3JFeGlzdGluZ1JlZmVyZW5jZVNlbGVjdEJveCgpIH0sXG4gICAgICAgICAgICAgICAgICAgIGlzQWN0aXZlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHNlbGYuZWRpdG9yLnJlZmVyZW5jZS5hcmVFeGlzdGluZ1JlZmVyZW5jZXNBdmFpbGFibGUoKSB9LFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnZXhpc3RpbmctcmVmJyxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheU5hbWU6ICdSZWZlcmVuY2Ugd29yayB5b3VcXCd2ZSByZWZlcmVuY2VkIGJlZm9yZTonLFxuICAgICAgICAgICAgICAgICAgICB0YWI6ICdGaW5kIFJlZmVyZW5jZSdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ25vLWV4aXN0aW5nLXJlZmVyZW5jZS1hdmFpbGFibGUtaGludCcsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICc8ZGl2IGNsYXNzPVwibm8tZGF0YS1oaW50XCI+PGRpdiBjbGFzcz1cIm5vLWRhdGEtaWNvblwiPjwvZGl2PjxkaXYgY2xhc3M9XCJuby1kYXRhLW1lc3NhZ2UtaGVhZGluZ1wiPk5vIFJlZmVyZW5jZXMgQXZhaWxhYmxlITwvZGl2PjxkaXYgY2xhc3M9XCJuby1kYXRhLW1lc3NhZ2VcIj5TZWxlY3QgdGhlIHRhYiBcIkFkZCBSZWZlcmVuY2VcIiB0byBpbnNlcnQgYSBuZXcgcmVmZXJlbmNlLiBUaGUgbmV4dCB0aW1lIHlvdSB3YW50IHRvIHJlZmVyZW5jZSB0aGUgc2FtZSB3b3JrLCBpdCB3aWxsIHNob3cgdXAgaGVyZS48L2Rpdj48L2Rpdj4nLFxuICAgICAgICAgICAgICAgICAgICBpc0FjdGl2ZTogZnVuY3Rpb24oKSB7IHJldHVybiAhc2VsZi5lZGl0b3IucmVmZXJlbmNlLmFyZUV4aXN0aW5nUmVmZXJlbmNlc0F2YWlsYWJsZSgpIH0sXG4gICAgICAgICAgICAgICAgICAgIHRhYjogJ0ZpbmQgUmVmZXJlbmNlJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnZmV0Y2gtcmVmLWJ0bicsXG4gICAgICAgICAgICAgICAgICAgIGlzQWN0aXZlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHNlbGYuZWRpdG9yLnJlZmVyZW5jZS5hcmVFeGlzdGluZ1JlZmVyZW5jZXNBdmFpbGFibGUoKSB9LFxuICAgICAgICAgICAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uKGRvbSwgZm9ybURhdGEsIGRsRnJvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tLmlubmVySFRNTCA9ICcnXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhZGRSZWZTcmNCdG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFJlZlNyY0J0bi5jbGFzc0xpc3QuYWRkKCdmZXRjaC1leHRlcm5hbC1yZWYtYnRuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRSZWZTcmNCdG4uaW5uZXJIVE1MID0gJ0ZldGNoIE5ld2VzdCBEYXRhIEZyb20gUmVmZXJlbmNlIFNvdXJjZXMnO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRSZWZTcmNCdG4ub25jbGljayA9IGFzeW5jIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGFkZFJlZlNyY0J0bi5jbGFzc0xpc3QuY29udGFpbnMoJ2ZldGNoLWV4dGVybmFsLXJlZi1idG4tbG9hZGluZycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHRSZWZGaWVsZCA9IGRsRnJvbS5maWVsZHMuZmluZChmaWVsZCA9PiBmaWVsZC5uYW1lID09PSAnZXhpc3RpbmctcmVmJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0UmVmRmllbGQuZG9tRWxlbWVudC5zZXRMb2FkaW5nU3RhdHVzKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRSZWZTcmNCdG4uY2xhc3NMaXN0LmFkZCgnZmV0Y2gtZXh0ZXJuYWwtcmVmLWJ0bi1sb2FkaW5nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgc3luY0FsbFNvdXJjZXMoc2VsZi5lZGl0b3IucmVmZXJlbmNlLnN0b3JlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBzZWxmLmVkaXRvci5yZWZlcmVuY2Uuc3RvcmUuaW5pdENhY2hlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2VsZi5lZGl0b3IucmVmZXJlbmNlLnN0b3JlLmNsZWFudXBSZWZlcmVuY2VzRnJvbVNvdXJjZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDEwMDApKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dFJlZkZpZWxkLmRvbUVsZW1lbnQuc2V0TG9hZGluZ1N0YXR1cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFJlZlNyY0J0bi5jbGFzc0xpc3QucmVtb3ZlKCdmZXRjaC1leHRlcm5hbC1yZWYtYnRuLWxvYWRpbmcnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbS5vbkNoYW5nZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tLmFwcGVuZENoaWxkKGFkZFJlZlNyY0J0bik7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRhYjogJ0ZpbmQgUmVmZXJlbmNlJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ21hbmFnZS1yZWYtYnRuJyxcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbihkb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbS5pbm5lckhUTUwgPSAnJ1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWRkUmVmU3JjQnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRSZWZTcmNCdG4uY2xhc3NMaXN0LmFkZCgnYWRkLWV4dGVybmFsLXJlZi1idG4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkUmVmU3JjQnRuLmlubmVySFRNTCA9ICdNYW5hZ2UgUmVmZXJlbmNlIFNvdXJjZXMgKFpvdGVybyknXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFJlZlNyY0J0bi5vbmNsaWNrID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmZXJlbmNlU291cmNlc0ZpZWxkcyA9IGF3YWl0IGdldFJlZmVyZW5jZVNvdXJjZXNGaWVsZHMoc2VsZi5lZGl0b3IucmVmZXJlbmNlLnN0b3JlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbmZpZ0Zvcm0gPSBuZXcgRGVjbGFyYXRpdkZvcm0oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgZmllbGRzOiBbLi4ucmVmZXJlbmNlU291cmNlc0ZpZWxkc10gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCkgPT4geyBkb20ub25DaGFuZ2UodHJ1ZSkgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCkgPT4geyBkb20ub25DaGFuZ2UodHJ1ZSkgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0JhY2sgdG8gUmVmZXJlbmNlcycpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWdGb3JtLm9wZW5Jbk1vZGFsKClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tLmFwcGVuZENoaWxkKGFkZFJlZlNyY0J0bik7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRhYjogJ0ZpbmQgUmVmZXJlbmNlJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC4uLighc2VsZi5lZGl0b3IucmVmZXJlbmNlID8gW10gOiBzZWxmLmVkaXRvci5yZWZlcmVuY2UuZ2V0RXh0ZXJuYWxSZWZEaWFsb2dBdHRyaWJ1dGVzKCkubWFwKGZpZWxkID0+IE9iamVjdC5hc3NpZ24oZmllbGQsIHsgdGFiOiAnQWRkIFJlZmVyZW5jZScgfSkpKVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oY29udGV4dEVsZW1lbnQsIGZvcm1EYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlZiA9IGZvcm1EYXRhICYmIChmb3JtRGF0YVsnY3Jvc3MtcmVmJ10gfHwgZm9ybURhdGFbJ2V4aXN0aW5nLXJlZiddKTtcbiAgICAgICAgICAgICAgICBpZihmb3JtRGF0YS5hY3RpdmVUYWIgPT09ICdBZGQgUmVmZXJlbmNlJykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmVkaXRvci5yZWZlcmVuY2UuaW5zZXJ0RXh0ZXJuYWxSZWZlcmVuY2UoZm9ybURhdGEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZihyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5lZGl0b3IucmVmZXJlbmNlLmluc2VydEludGVybmFsUmVmZXJlbmNlKHtyZWY6IHJlZn0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgcmFuZ2VSZXF1aXJlOiBmYWxzZSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2VkaXQtcmVmJyxcbiAgICAgICAgICAgIGRpcGxheU5hbWU6ICc8aSBjbGFzcz1cImZhcyBmYS1lZGl0IGZhLXhzXCI+PC9pPicsXG4gICAgICAgICAgICBhbGxvd2VkQ29udGV4dDogJy5yZWZlcmVuY2UnLFxuICAgICAgICAgICAgc2hvdWxkQmVEaXNwbGF5ZWQ6IGZ1bmN0aW9uKGNvbnRleHRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHRFbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1leHRlcm5hbCcpID09PSAndHJ1ZSc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbihjb250ZXh0RWxlbWVudCwgZm9ybURhdGEpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmVkaXRvci5yZWZlcmVuY2Uuc2hvd0VkaXRFeHRlcm5hbFJlZkRpYWxvZyhjb250ZXh0RWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ3JlZmVyZW5jZS1jYXB0aW9uJyxcbiAgICAgICAgICAgIHJhbmdlUmVxdWlyZTogZmFsc2UsXG4gICAgICAgICAgICBkaXBsYXlOYW1lOiBmdW5jdGlvbihjb250ZXh0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBjYXB0aW9uID0gc2VsZi5lZGl0b3IucmVmZXJlbmNlLmdldFJlZkNhcHRpb25IVE1MKGNvbnRleHRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICBjYXB0aW9uID0gY2FwdGlvbi5yZXBsYWNlKC9cXDxiXFw+L2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcPFxcL2JcXD4vZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFw8L2csICcmbHQ7JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXD4vZywgJyZndDsnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FwdGlvbjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaG91bGRCZURpc3BsYXllZDogZnVuY3Rpb24oY29udGV4dEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FwdGlvbiA9IHNlbGYuZWRpdG9yLnJlZmVyZW5jZS5nZXRSZWZDYXB0aW9uSFRNTChjb250ZXh0RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhcHRpb24gJiYgY2FwdGlvbi5sZW5ndGggIT09IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhbGxvd2VkQ29udGV4dDogJy5yZWZlcmVuY2UnLFxuICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbigpIHt9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJhbmdlUmVxdWlyZTogZmFsc2UsXG4gICAgICAgICAgICBpbnNlcnRBY3Rpb246IHRydWUsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdpbmxpbmVlcXVhdGlvbicsXG4gICAgICAgICAgICBkaXBsYXlOYW1lOiAnJnJhZGljOycsXG4gICAgICAgICAgICBhbGxvd2VkQ29udGV4dDogWydwJywgJ3RhYmxlJywgJ29sJywgJ3VsJywgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2NhcHRpb24nLCAnZmlnY2FwdGlvbicsICdjaXRlc3JjJ10sXG4gICAgICAgICAgICBub3RBbGxvd2VkQ29udGV4dDogWyduYXYnLCAnYScsICdpbmxpbmVjb2RlJywgJ2NvZGUnXSxcbiAgICAgICAgICAgIGFyZ3VtZW50czogW1xuICAgICAgICAgICAgICAgIHtuYW1lOiAnbGF0ZXhlcXVhdGlvbicsIHBsYWNlaG9sZGVyOiAnTGFUZVggRXF1YXRpb24nLCBkaXNwbGF5TmFtZTogJ0xhVGVYIEVxdWF0aW9uJywgdG9vbHRpcDogbGF0ZXhDaGVhdHNoZWV0fSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiAnUHJldmlldycsXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXA6ICdJdCBzaG93cyB5b3UgaG93IHRoZSBMYVRlWCBlcXVhdGlvbiB3aWxsIGJlIHJlbmRlcmVkJyxcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbihlbGVtZW50LCBmb3JtRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZm9ybURhdGEgJiYgZm9ybURhdGEubGF0ZXhlcXVhdGlvbiAmJiBmb3JtRGF0YS5sYXRleGVxdWF0aW9uLnRyaW0oKSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrYXRleC5yZW5kZXIoZm9ybURhdGEubGF0ZXhlcXVhdGlvbiwgZWxlbWVudCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dPbkVycm9yOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheU1vZGU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJzxzcGFuIGNsYXNzPVwiZXJyb3JcIj5pbnZhbGlkIExhVGVYIGVxdWF0aW9uPC9zcGFuPic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9ICdJbnNlcnQgYSBMYVRlWCBpbiB0aGUgaW5wdXQgZmllbGQgYWJvdmUgdG8gc2VlIHRoZSBlcXVhdGlvbiBoZXJlLic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbihjb250ZXh0RWxlbWVudCwgYXJnVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZighYXJnVmFsdWUubGF0ZXhlcXVhdGlvbikgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBhcmdWYWx1ZS5sYXRleGVxdWF0aW9uICE9PSAnc3RyaW5nJykgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmKGFyZ1ZhbHVlLmxhdGV4ZXF1YXRpb24udHJpbSgpID09PSAnJykgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgdmFyIGVxID0gdXRpbHMuc3RyaW5nVG9BdHRyaWJ1dGVTYXZlU3RyaW5nKGFyZ1ZhbHVlLmxhdGV4ZXF1YXRpb24pXG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbmxpbmVlcXVhdGlvbicpO1xuXG4gICAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtbGF0ZXhlcXVhdGlvbicsIGVxKTtcbiAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJywgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5jYXJldC5pbnNlcnROb2RlKG5vZGUpO1xuICAgICAgICAgICAgICAgIHNlbGYuY2FyZXQuaW5zZXJ0Tm9kZShkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnICcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAnZWRpdC1pbmxpbmVlcXVhdGlvbicsXG4gICAgICAgICAgICByYW5nZVJlcXVpcmU6IGZhbHNlLFxuICAgICAgICAgICAgZGlwbGF5TmFtZTogJzxpIGNsYXNzPVwiZmFzIGZhLWVkaXQgZmEteHNcIj48L2k+JyxcbiAgICAgICAgICAgIGFsbG93ZWRDb250ZXh0OiAnaW5saW5lZXF1YXRpb24nLFxuICAgICAgICAgICAgbm90QWxsb3dlZENvbnRleHQ6IFtdLFxuICAgICAgICAgICAgYXJndW1lbnRzOiBbe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdsYXRleGVxdWF0aW9uJyxcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogJ0xhVGVYIEVxdWF0aW9uJyxcbiAgICAgICAgICAgICAgICB0b29sdGlwOiBsYXRleENoZWF0c2hlZXQsXG4gICAgICAgICAgICAgICAgZGlzcGxheU5hbWU6ICdMYVRlWCBFcXVhdGlvbicsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBmdW5jdGlvbihjb250ZXh0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZighKGNvbnRleHRFbGVtZW50ICYmIGNvbnRleHRFbGVtZW50LmRhdGFzZXQgJiYgY29udGV4dEVsZW1lbnQuZGF0YXNldC5sYXRleGVxdWF0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxzLmF0dHJpYnV0ZVNhdmVTdHJpbmdUb1N0cmluZyhjb250ZXh0RWxlbWVudC5kYXRhc2V0LmxhdGV4ZXF1YXRpb24pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiAnUHJldmlldzonLFxuICAgICAgICAgICAgICAgIHRvb2x0aXA6ICdJdCBzaG93cyB5b3UgaG93IHRoZSBMYVRlWCBlcXVhdGlvbiB3aWxsIGJlIHJlbmRlcmVkJyxcbiAgICAgICAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uKGVsZW1lbnQsIGZvcm1EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGZvcm1EYXRhICYmIGZvcm1EYXRhLmxhdGV4ZXF1YXRpb24gJiYgZm9ybURhdGEubGF0ZXhlcXVhdGlvbi50cmltKCkgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGthdGV4LnJlbmRlcihmb3JtRGF0YS5sYXRleGVxdWF0aW9uLCBlbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93T25FcnJvcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheU1vZGU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJzxzcGFuIGNsYXNzPVwiZXJyb3JcIj5pbnZhbGlkIExhVGVYIGVxdWF0aW9uPC9zcGFuPic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oY29udGV4dEVsZW1lbnQsIGFyZ1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYoIWFyZ1ZhbHVlLmxhdGV4ZXF1YXRpb24pIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZih0eXBlb2YgYXJnVmFsdWUubGF0ZXhlcXVhdGlvbiAhPT0gJ3N0cmluZycpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZihhcmdWYWx1ZS5sYXRleGVxdWF0aW9uLnRyaW0oKSA9PT0gJycpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIHZhciBzZWN0aW9uID0gc2VsZi5lZGl0b3IuZm9jdXNlZFNlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbGF0ZXhlcXVhdGlvbicsIHV0aWxzLnN0cmluZ1RvQXR0cmlidXRlU2F2ZVN0cmluZyhhcmdWYWx1ZS5sYXRleGVxdWF0aW9uKSk7XG4gICAgICAgICAgICAgICAgc2VsZi5lZGl0b3IucmVwbGFjZVNlY3Rpb25XaXRoSFRNTChzZWN0aW9uLCBzZWN0aW9uLm91dGVySFRNTCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2lubGluZWVxdWF0aW9uLWNvbnRlbnQnLFxuICAgICAgICAgICAgcmFuZ2VSZXF1aXJlOiBmYWxzZSxcbiAgICAgICAgICAgIGRpcGxheU5hbWU6IGZ1bmN0aW9uKGNvbnRleHRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxzLmF0dHJpYnV0ZVNhdmVTdHJpbmdUb0hUTUxFbmNvZGVkKGNvbnRleHRFbGVtZW50LmRhdGFzZXQubGF0ZXhlcXVhdGlvbik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWxsb3dlZENvbnRleHQ6ICdpbmxpbmVlcXVhdGlvbicsXG4gICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkge31cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgcmFuZ2VSZXF1aXJlOiB0cnVlLFxuICAgICAgICAgICAgaW5zZXJ0QWN0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2VucmljaG1lbnQtaW5mbycsXG4gICAgICAgICAgICBhbGxvd2VkQ29udGV4dDogJycsXG4gICAgICAgICAgICBkaXBsYXlOYW1lOiBmdW5jdGlvbihjb250ZXh0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gd2luZG93LmdldFNlbGVjdGlvbigpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgdmFyIHdvcmRDb3VudCA9IHRleHQuc3BsaXQoL1tcXHNcXC46XFw/XFwhJ10vKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKHcgPT4gdy50cmltKCkubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAgICAgLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgY2hhckNvdW50ID0gdGV4dC5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7d29yZENvdW50fSAvICR7Y2hhckNvdW50fWA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbigpIHt9XG4gICAgICAgIH0sXG4gICAgXTtcblxuICAgIHRoaXMuY2FyZXQuc3Vic2NyaWJlU2VsZWN0aW9uQ2hhbmdlKGZ1bmN0aW9uKHNlbGVjdGlvbikge1xuICAgICAgICB2YXIgZW5yaWNobWVudHMgPSBzZWxmLmdldE1lYW5pbmdmdWxFbnJpY2htZW50cygpO1xuXG4gICAgICAgIGVucmljaG1lbnRzLmxlbmd0aCAhPT0gMCA/XG4gICAgICAgICAgICBzZWxmLnNob3coZmFsc2UsIGVucmljaG1lbnRzKSA6XG4gICAgICAgICAgICBzZWxmLmhpZGUoKTtcbiAgICB9KVxufVxuXG5UZXh0RW5yaWNobWVudENvbnRyb2wucHJvdG90eXBlID0ge1xuXG4gICAgaXNWaXNpYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaWJsZTtcbiAgICB9LFxuXG4gICAgYWRkRW5yaWNobWVudHM6IGZ1bmN0aW9uKGVucmljaG1lbnRzKSB7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMuZW5yaWNobWVudHMsIGVucmljaG1lbnRzKTtcbiAgICB9LFxuXG4gICAgaGlkZTogZnVuY3Rpb24oZm9yY2UpIHtcbiAgICAgICAgaWYoZm9yY2UgfHwgIXRoaXMucHJldmVudEVucmljaG1lbnRDb250cm9sbFRvQmVIaWRkZW4pIHtcbiAgICAgICAgICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgdGhpcy5kb21FbGVtZW50LmlubmVySFRNTCA9ICcnO1xuICAgICAgICAgICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2hvdzogZnVuY3Rpb24oaXNJbnNlcnRCdG5QcmVzc2VkLCBlbnJpY2htZW50cykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBlbCA9IHRoaXMuZG9tRWxlbWVudCxcbiAgICAgICAgICAgIHRtcEJ0biwgc2VjdGlvbjtcblxuICAgICAgICBlbnJpY2htZW50cyA9IGVucmljaG1lbnRzIHx8IHRoaXMuZ2V0TWVhbmluZ2Z1bEVucmljaG1lbnRzKGlzSW5zZXJ0QnRuUHJlc3NlZCk7XG5cbiAgICAgICAgaWYoZW5yaWNobWVudHMubGVuZ3RoID09PSAwICYmICFpc0luc2VydEJ0blByZXNzZWQpIHJldHVybjtcblxuICAgICAgICBpZihlbnJpY2htZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGVucmljaG1lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGRpcGxheU5hbWU6ICdOb3RoaW5nIHRvIGRvIGhlcmUhJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdlbnJpY2htZW50LWluZm8nLFxuICAgICAgICAgICAgICAgIGFsbG93ZWRDb250ZXh0OiAnJyxcbiAgICAgICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkge31cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZGlwbGF5TmFtZTogJzxpIGNsYXNzPVwiZmFzIGZhLWluZm8gZmEteHNcIj48L2k+JyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdlbnJpY2htZW50LW1vcmUtaW5mby1idG4nLFxuICAgICAgICAgICAgICAgIGFsbG93ZWRDb250ZXh0OiAnYm9keScsXG4gICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnU29tZSBwYXJ0cyBvZiB0aGUgZG9jdW1lbnQgKGxpa2UgaGVhZGluZ3MpIGRvblxcJ3QgYWxsb3cgdG8gaW5zZXJ0IGZvb3Rub3RlcyBvciByZWZlcmVuY2VzIGFzIHRoZXkgbWlnaHQgbm90IG1ha2UgbXVjaCBzZW5jZSB0aGVyZS48YnIvPjxici8+UGxlYXNlIGdpdmUgdXMgc29tZSA8YSBocmVmPVwibWFpbHRvOmluZm9AbW9uc3RlcndyaXRlci5hcHA/c3ViamVjdD1GZWVkYmFja1wiPmZlZWRiYWNrPC9hPiBpZiB5b3UgaGF2ZSBhbiB1c2UgY2FzZSB3aGljaCByZXF1aXJlcyB0aGlzIHRvIGJlIGNoYW5nZWQuIDxici8+PGJyLz5CVFcuIHdlIHdvdWxkICYjeDFGNDk2O3RvIGhlYXIgaG93IHlvdSBsaWtlIE1vbnN0ZXJXcml0ZXIgaW4gZ2VuZXJhbCEnXG4gICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbigpIHt9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsLmlubmVySFRNTCA9ICc8c3BhbiBjbGFzcz1cInRleHRFbnJpY2htZW50Q29udHJvbEFycm93XCI+PC9zcGFuPic7XG4gICAgICAgIGVucmljaG1lbnRzLmZvckVhY2goZnVuY3Rpb24oZW5yaWNobWVudCkge1xuXG4gICAgICAgICAgICB0bXBCdG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICB0bXBCdG4uY2xhc3NOYW1lID0gZW5yaWNobWVudC5jbGFzc05hbWU7XG5cbiAgICAgICAgICAgIHRtcEJ0bi5pbm5lckhUTUwgPSAgKHR5cGVvZiBlbnJpY2htZW50LmRpcGxheU5hbWUgPT09ICdmdW5jdGlvbicpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVucmljaG1lbnQuZGlwbGF5TmFtZShlbnJpY2htZW50LmNvbnRleHRFbGVtZW50KSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnJpY2htZW50LmRpcGxheU5hbWU7XG5cbiAgICAgICAgICAgIHRtcEJ0bi5vbm1vdXNlZG93biA9IGZ1bmN0aW9uIChlKSB7XG5cbiAgICAgICAgICAgICAgICBpZighZW5yaWNobWVudC5hcmd1bWVudHMgJiYgZW5yaWNobWVudC5jb21tYW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKGVucmljaG1lbnQuY29tbWFuZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKCFlbnJpY2htZW50LmFyZ3VtZW50cyAmJiBlbnJpY2htZW50LmFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBlbnJpY2htZW50LmFjdGlvbihzZWxmLmNhcmV0LmdldENvbnRleHRFbGVtZW50KGVucmljaG1lbnQuYWxsb3dlZENvbnRleHQpLCB1bmRlZmluZWQsIHNlbGYpO1xuICAgICAgICAgICAgICAgICAgICBzZWN0aW9uID0gc2VsZi5lZGl0b3IuZm9jdXNlZFNlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5lZGl0b3IucmVwbGFjZVNlY3Rpb25XaXRoSFRNTChzZWN0aW9uLCBzZWN0aW9uLm91dGVySFRNTCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKGVucmljaG1lbnQuYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBlbnJpY2htZW50LmFyZ3VtZW50c1swXS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kaXNwbGF5U2luZ2xlQXJndW1lbnRUZXh0SW5wdXQoZW5yaWNobWVudCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kaXNwbGF5QXJndW1lbnRJbnB1dChlbnJpY2htZW50KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRtcEJ0bi5vbmNsaWNrID0gdG1wQnRuLm9ubW91c2V1cCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlIH1cblxuICAgICAgICAgICAgZWwuYXBwZW5kQ2hpbGQodG1wQnRuKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51cGRhdGVQb3NpdGlvbigpO1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICB9LFxuXG4gICAgdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2FyZXRQb3MgPSB0aGlzLmNhcmV0LmdldFBvc2l0aW9uKCksXG4gICAgICAgICAgICBlbCA9IHRoaXMuZG9tRWxlbWVudCxcbiAgICAgICAgICAgIHhPZmZzZXQgPSAoY2FyZXRQb3Mud2lkdGggPiAxMSA/IDAgOiAtMTEpLFxuICAgICAgICAgICAgb3JpZ2luYWxEaXNwbGF5ID0gZWwuc3R5bGUuZGlzcGxheTtcblxuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBlbC5zdHlsZS5sZWZ0ID0gKGNhcmV0UG9zLnggKyB4T2Zmc2V0KSArICdweCc7XG4gICAgICAgIGVsLnN0eWxlLnRvcCA9IChjYXJldFBvcy55IC0gMzIpICsgJ3B4JztcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IG9yaWdpbmFsRGlzcGxheTtcbiAgICB9LFxuXG4gICAgdXBkYXRlUG9zaXRpb25JZlZpc2libGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZih0aGlzLnZpc2libGUpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUG9zaXRpb24oKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBkaXNwbGF5QXJndW1lbnRJbnB1dDogZnVuY3Rpb24oZW5yaWNobWVudCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIHNlY3Rpb247XG5cbiAgICAgICAgdmFyIGFyZ3MgPSBlbnJpY2htZW50LmFyZ3VtZW50cy5tYXAoZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgICBpZih0eXBlb2YgYXJnLmRlZmF1bHRWYWx1ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBuZXdBcmcgPSB7fTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obmV3QXJnLCBhcmcpO1xuICAgICAgICAgICAgbmV3QXJnLmRlZmF1bHRWYWx1ZSA9IGFyZy5kZWZhdWx0VmFsdWUoZW5yaWNobWVudC5jb250ZXh0RWxlbWVudCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3QXJnO1xuICAgICAgICB9KTtcblxuICAgICAgICBzZWxmLmVkaXRvci5kaXNwbGF5TW9kYWwoYXJncywgZnVuY3Rpb24oZm9ybURhdGEpIHtcbiAgICAgICAgICAgIHNlbGYuZWRpdG9yLnVuZnJlZXplU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBzZWxmLmhpZGUoKTtcblxuICAgICAgICAgICAgZW5yaWNobWVudC5hY3Rpb24oc2VsZi5jYXJldC5nZXRDb250ZXh0RWxlbWVudChlbnJpY2htZW50LmFsbG93ZWRDb250ZXh0KSwgZm9ybURhdGEsIHNlbGYpO1xuICAgICAgICAgICAgc2VjdGlvbiA9IHNlbGYuZWRpdG9yLmZvY3VzZWRTZWN0aW9uKCk7XG4gICAgICAgICAgICBzZWxmLmVkaXRvci5yZXBsYWNlU2VjdGlvbldpdGhIVE1MKHNlY3Rpb24sIHNlY3Rpb24ub3V0ZXJIVE1MKTtcbiAgICAgICAgfSwgZW5yaWNobWVudC5ub3RGb2N1c0ZpcnN0SW5wdXQpO1xuICAgIH0sXG5cbiAgICBkaXNwbGF5U2luZ2xlQXJndW1lbnRUZXh0SW5wdXQ6IGZ1bmN0aW9uKGVucmljaG1lbnQpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgYXJndW1lbnQgPSBlbnJpY2htZW50LmFyZ3VtZW50c1swXSxcbiAgICAgICAgICAgIGVsID0gdGhpcy5kb21FbGVtZW50LFxuICAgICAgICAgICAgYXR0cklucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKSxcbiAgICAgICAgICAgIG9rQnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpLFxuICAgICAgICAgICAgY2FjaGVkQ29udGV4dEVsZW1lbnQgPSBlbnJpY2htZW50LmNvbnRleHRFbGVtZW50LFxuICAgICAgICAgICAgc2VjdGlvbjtcblxuICAgICAgICBhdHRySW5wdXQucGxhY2Vob2xkZXIgPSBhcmd1bWVudC5wbGFjZWhvbGRlcjtcbiAgICAgICAgb2tCdG4uaW5uZXJIVE1MID0gJ09LJztcbiAgICAgICAgb2tCdG4uY2xhc3NOYW1lID0gJ2NvbmZpcm1MaW5rJztcblxuICAgICAgICBpZih0eXBlb2YgYXJndW1lbnQudmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGF0dHJJbnB1dC52YWx1ZSA9IGFyZ3VtZW50LnZhbHVlKGNhY2hlZENvbnRleHRFbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF0dHJJbnB1dC52YWx1ZSA9IGFyZ3VtZW50LnZhbHVlIHx8ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgYXR0cklucHV0Lm9ubW91c2Vkb3duID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvL3NpbXVsYXRlIHRoZSB0ZXh0IGZvY3VzLCBiZWNhdXNlIGl0IHNob3VsZCBzdGlsbCBiZSB2aXNpYmxlIHdoYXRcbiAgICAgICAgICAgIC8vdGV4dCBpcyBzbGVjdGVkIGV2ZW4gd2hlbiB0aGUgZm91Y3MgY2hhbmdlcyB0byB0aGUgaW5wdXQgZmllbGRcbiAgICAgICAgICAgIHNlbGYuZWRpdG9yLmZyZWV6ZVNlbGVjdGlvbih7XG4gICAgICAgICAgICAgICAgJ3VuZnJlZXplT25DbGlja3NPdXRzaXRlT2YnOiBlbCxcbiAgICAgICAgICAgICAgICAndW5mcmVlemVDYWxsYmFjayc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnByZXZlbnRFbnJpY2htZW50Q29udHJvbGxUb0JlSGlkZGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaGlkZSgpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZi5wcmV2ZW50RW5yaWNobWVudENvbnRyb2xsVG9CZUhpZGRlbiA9IHRydWU7XG5cbiAgICAgICAgICAgIGF0dHJJbnB1dC5mb2N1cygpO1xuICAgICAgICB9XG5cbiAgICAgICAgb2tCdG4ub25tb3VzZWRvd24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuZWRpdG9yLnVuZnJlZXplU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBpZihlbnJpY2htZW50LmNvbW1hbmQpIHtcbiAgICAgICAgICAgICAgICBpZighZG9jdW1lbnQuZXhlY0NvbW1hbmQoZW5yaWNobWVudC5jb21tYW5kLCBmYWxzZSwgYXR0cklucHV0LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkuZ2V0UmFuZ2VBdCgwKS5jb2xsYXBzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZihlbnJpY2htZW50LmFjdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBhdHRyVmFsdWUgPSB7fTtcbiAgICAgICAgICAgICAgICBhdHRyVmFsdWVbYXJndW1lbnQubmFtZV0gPSBhdHRySW5wdXQudmFsdWU7XG4gICAgICAgICAgICAgICAgZW5yaWNobWVudC5hY3Rpb24oc2VsZi5jYXJldC5nZXRDb250ZXh0RWxlbWVudChlbnJpY2htZW50LmFsbG93ZWRDb250ZXh0KSwgYXR0clZhbHVlLCBzZWxmKTtcbiAgICAgICAgICAgICAgICBzZWN0aW9uID0gc2VsZi5lZGl0b3IuZm9jdXNlZFNlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBzZWxmLmVkaXRvci5yZXBsYWNlU2VjdGlvbldpdGhIVE1MKHNlY3Rpb24sIHNlY3Rpb24ub3V0ZXJIVE1MKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5oaWRlKCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBhdHRySW5wdXQub25rZXlkb3duID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYoZS5rZXlDb2RlID09PSAxMykgeyAvLyBFbnRlclxuICAgICAgICAgICAgICAgIG9rQnRuLm9ubW91c2Vkb3duKCk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZWwuaW5uZXJIVE1MID0gJzxzcGFuIGNsYXNzPVwidGV4dEVucmljaG1lbnRDb250cm9sQXJyb3dcIj48L3NwYW4+JztcbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQoYXR0cklucHV0KTtcbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQob2tCdG4pO1xuXG4gICAgICAgIGF0dHJJbnB1dC5vbm1vdXNlZG93bigpO1xuICAgIH0sXG5cbiAgICBnZXRNZWFuaW5nZnVsRW5yaWNobWVudHM6IGZ1bmN0aW9uKGlzSW5zZXJ0QnRuUHJlc3NlZCwgc2VsZWN0aW9uKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIHRhbmdlbnROb2RlcyA9IHNlbGYuY2FyZXQuZ2V0VGFuZ2V0Tm9kZXMoKTtcblxuICAgICAgICBzZWxlY3Rpb24gPSBzZWxlY3Rpb24gfHwgd2luZG93LmdldFNlbGVjdGlvbigpO1xuXG4gICAgICAgIHZhciBjb2xsYXBzZWRNYXRjaCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmKHR5cGVvZiBlLnJhbmdlUmVxdWlyZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBlLnJhbmdlUmVxdWlyZSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAhZS5yYW5nZVJlcXVpcmUgfHwgIXNlbGVjdGlvbi5pc0NvbGxhcHNlZCA9PT0gZS5yYW5nZVJlcXVpcmU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29udGV4dE1hdGNoID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYoIWUuYWxsb3dlZENvbnRleHQpIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgICBpZihlLm5vdEFsbG93ZWRDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYoc2VsZi5jYXJldC5nZXRDb250ZXh0RWxlbWVudChlLm5vdEFsbG93ZWRDb250ZXh0LCBzZWxlY3Rpb24sIHRhbmdlbnROb2RlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZS5jb250ZXh0RWxlbWVudCA9IHNlbGYuY2FyZXQuZ2V0Q29udGV4dEVsZW1lbnQoZS5hbGxvd2VkQ29udGV4dCwgc2VsZWN0aW9uLCB0YW5nZW50Tm9kZXMpO1xuICAgICAgICAgICAgcmV0dXJuICEhZS5jb250ZXh0RWxlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbnNlcnRBY3Rpb25NYXRjaCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmKGlzSW5zZXJ0QnRuUHJlc3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb24uaXNDb2xsYXBzZWQgJiYgZS5pbnNlcnRBY3Rpb24gPT09IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBlLmluc2VydEFjdGlvbiAhPT0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbnJpY2htZW50TWF0Y2ggPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZighZS5zaG91bGRCZURpc3BsYXllZCkgeyByZXR1cm4gdHJ1ZSB9XG5cbiAgICAgICAgICAgIHJldHVybiBlLnNob3VsZEJlRGlzcGxheWVkKHNlbGYuY2FyZXQuZ2V0Q29udGV4dEVsZW1lbnQoZS5hbGxvd2VkQ29udGV4dCwgc2VsZWN0aW9uLCB0YW5nZW50Tm9kZXMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmVucmljaG1lbnRzLmZpbHRlcihmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICByZXR1cm4gY29sbGFwc2VkTWF0Y2goZSkgJiZcbiAgICAgICAgICAgICAgICAgICBjb250ZXh0TWF0Y2goZSkgJiZcbiAgICAgICAgICAgICAgICAgICBpbnNlcnRBY3Rpb25NYXRjaChlKSAmJlxuICAgICAgICAgICAgICAgICAgIGVucmljaG1lbnRNYXRjaChlKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRleHRFbnJpY2htZW50Q29udHJvbDtcbiIsInZhciBDaGFuZ2VzZXQgPSByZXF1aXJlKCcuL0NoYW5nZXNldCcpXG4gICwgUmV0YWluID0gcmVxdWlyZSgnLi9vcGVyYXRpb25zL1JldGFpbicpXG4gICwgU2tpcCA9IHJlcXVpcmUoJy4vb3BlcmF0aW9ucy9Ta2lwJylcbiAgLCBJbnNlcnQgPSByZXF1aXJlKCcuL29wZXJhdGlvbnMvSW5zZXJ0JylcblxuZnVuY3Rpb24gQnVpbGRlcigpIHtcbiAgdGhpcy5vcHMgPSBbXVxuICB0aGlzLmFkZGVuZHVtID0gJydcbiAgdGhpcy5yZW1vdmVuZHVtID0gJydcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCdWlsZGVyXG5cbkJ1aWxkZXIucHJvdG90eXBlLmtlZXAgPVxuQnVpbGRlci5wcm90b3R5cGUucmV0YWluID0gZnVuY3Rpb24obGVuKSB7XG4gIHRoaXMub3BzLnB1c2gobmV3IFJldGFpbihsZW4pKVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWlsZGVyLnByb3RvdHlwZS5kZWxldGUgPVxuQnVpbGRlci5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uKHN0cikge1xuICB0aGlzLnJlbW92ZW5kdW0gKz0gc3RyXG4gIHRoaXMub3BzLnB1c2gobmV3IFNraXAoc3RyLmxlbmd0aCkpXG4gIHJldHVybiB0aGlzXG59XG5cbkJ1aWxkZXIucHJvdG90eXBlLmFkZCA9XG5CdWlsZGVyLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbihzdHIpIHtcbiAgdGhpcy5hZGRlbmR1bSArPSBzdHJcbiAgdGhpcy5vcHMucHVzaChuZXcgSW5zZXJ0KHN0ci5sZW5ndGgpKVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWlsZGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNzID0gbmV3IENoYW5nZXNldCh0aGlzLm9wcylcbiAgY3MuYWRkZW5kdW0gPSB0aGlzLmFkZGVuZHVtXG4gIGNzLnJlbW92ZW5kdW0gPSB0aGlzLnJlbW92ZW5kdW1cbiAgcmV0dXJuIGNzXG59XG4iLCIvKiFcbiAqIGNoYW5nZXNldHNcbiAqIEEgQ2hhbmdlc2V0IGxpYnJhcnkgaW5jb3Jwb3JhdGluZyBvcGVyYXRpb25hbCB0cmFuc2Zvcm1hdGlvbiAoT1QpXG4gKiBDb3B5cmlnaHQgMjAxMiBieSBNYXJjZWwgS2xlaHIgPG1rbGVockBnbXgubmV0PlxuICpcbiAqIChNSVQgTElDRU5TRSlcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyoqXG4gKiBBIHNlcXVlbmNlIG9mIGNvbnNlY3V0aXZlIG9wZXJhdGlvbnNcbiAqXG4gKiBAcGFyYW0gb3BzLi4gPE9wZXJhdGlvbj4gYWxsIHBhc3NlZCBvcGVyYXRpb25zIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGNoYW5nZXNldFxuICovXG5mdW5jdGlvbiBDaGFuZ2VzZXQob3BzLypvciBvcHMuLiovKSB7XG4gIHRoaXMuYWRkZW5kdW0gPSBcIlwiXG4gIHRoaXMucmVtb3ZlbmR1bSA9IFwiXCJcbiAgdGhpcy5pbnB1dExlbmd0aCA9IDBcbiAgdGhpcy5vdXRwdXRMZW5ndGggPSAwXG5cbiAgaWYoIUFycmF5LmlzQXJyYXkob3BzKSkgb3BzID0gYXJndW1lbnRzXG4gIGZvcih2YXIgaT0wOyBpPG9wcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMucHVzaChvcHNbaV0pXG4gICAgdGhpcy5pbnB1dExlbmd0aCArPSBvcHNbaV0uaW5wdXRcbiAgICB0aGlzLm91dHB1dExlbmd0aCArPSBvcHNbaV0ub3V0cHV0XG4gIH1cbn1cblxuLy8gVHJ1ZSBpbmhlcml0YW5jZVxuQ2hhbmdlc2V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQXJyYXkucHJvdG90eXBlLCB7XG4gIGNvbnN0cnVjdG9yOiB7XG4gICAgdmFsdWU6IENoYW5nZXNldCxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IENoYW5nZXNldFxuXG52YXIgVGV4dFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVGV4dFRyYW5zZm9ybScpXG4gICwgQ2hhbmdlc2V0VHJhbnNmb3JtID0gcmVxdWlyZSgnLi9DaGFuZ2VzZXRUcmFuc2Zvcm0nKVxuXG52YXIgUmV0YWluID0gcmVxdWlyZSgnLi9vcGVyYXRpb25zL1JldGFpbicpXG4gICwgU2tpcCA9IHJlcXVpcmUoJy4vb3BlcmF0aW9ucy9Ta2lwJylcbiAgLCBJbnNlcnQgPSByZXF1aXJlKCcuL29wZXJhdGlvbnMvSW5zZXJ0JylcblxudmFyIEJ1aWxkZXIgPSByZXF1aXJlKCcuL0J1aWxkZXInKVxuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgb3BzIHRoYXQgYXJlIHdpdGhpbiB0aGUgcGFzc2VkIHJhbmdlXG4gKiAob25seSBvcC5pbnB1dCBpcyBjb3VudGVkOyB0aHVzIG5vdCBjb3VudGluZyBpbnNlcnRzIHRvIHRoZSByYW5nZSBsZW5ndGgsIHlldCB0aGV5IGFyZSBwYXJ0IG9mIHRoZSByYW5nZSlcbiAqL1xuQ2hhbmdlc2V0LnByb3RvdHlwZS5zdWJyYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBsZW4pIHtcbiAgdmFyIHJhbmdlID0gW11cbiAgICAsIG9wLCBvcGxlblxuICAgICwgbD0wXG4gIGZvcih2YXIgaT0wLCBwb3M9MDsgaTx0aGlzLmxlbmd0aCAmJiBsIDwgbGVuOyBpKyspIHtcbiAgICBvcCA9IHRoaXNbaV1cbiAgICBpZihvcC5pbnB1dCtwb3MgPj0gc3RhcnQpIHtcbiAgICAgIGlmKG9wLmlucHV0KSB7XG4gICAgICAgIGlmKG9wLmxlbmd0aCAhPSBJbmZpbml0eSkgb3BsZW4gPSBvcC5sZW5ndGggLU1hdGgubWF4KDAsIHN0YXJ0LXBvcykgLU1hdGgubWF4KDAsIChvcC5sZW5ndGgrcG9zKS0oc3RhcnQrbGVuKSlcbiAgICAgICAgZWxzZSBvcGxlbiA9IGxlblxuICAgICAgICBpZiAob3BsZW4gIT09IDApIHJhbmdlLnB1c2goIG9wLmRlcml2ZShvcGxlbikgKSAvLyAoRG9uJ3QgY29weSBvdmVyIG1vcmUgdGhhbiBsZW4gcGFyYW0gYWxsb3dzKVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJhbmdlLnB1c2goIG9wLmRlcml2ZShvcC5sZW5ndGgpIClcbiAgICAgICAgb3BsZW4gPSAwXG4gICAgICB9XG4gICAgICBsICs9IG9wbGVuXG4gICAgfVxuICAgIHBvcyArPSBvcC5pbnB1dFxuICB9XG4gIHJldHVybiByYW5nZVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBjaGFuZ2VzZXRzICh0aGF0IGFyZSBiYXNlZCBvbiB0aGUgc2FtZSBzdGF0ZSEpIHNvIHRoYXQgdGhlIHJlc3VsdGluZyBjaGFuZ3Nlc2V0XG4gKiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzIGJvdGggb3JpZ25hbCBvbmVzIGFwcGxpZWQgb25lIGFmdGVyIHRoZSBvdGhlclxuICpcbiAqIEBwYXJhbSBvdGhlckNzIDxDaGFuZ2VzZXQ+XG4gKiBAcGFyYW0gbGVmdCA8Ym9vbGVhbj4gV2hpY2ggb3AgdG8gY2hvb3NlIGlmIHRoZXJlJ3MgYW4gaW5zZXJ0IHRpZSAoSWYgeW91IHVzZSB0aGlzIGZ1bmN0aW9uIGluIGEgZGlzdHJpYnV0ZWQsIHN5bmNocm9ub3VzIGVudmlyb25tZW50LCBiZSBzdXJlIHRvIGludmVydCB0aGlzIHBhcmFtIG9uIHRoZSBvdGhlciBzaXRlLCBvdGhlcndpc2UgaXQgY2FuIGJlIG9taXR0ZWQgc2FmZWx5KSlcbiAqIEByZXR1cm5zIDxDaGFuZ2VzZXQ+XG4gKi9cbkNoYW5nZXNldC5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbihvdGhlckNzLCBsZWZ0KSB7XG4gIGlmKCEob3RoZXJDcyBpbnN0YW5jZW9mIENoYW5nZXNldCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSAjPENoYW5nZXNldD4sIGJ1dCByZWNlaXZlZCAnK290aGVyQ3MuX19wcm90b19fLmNvbnN0cnVjdG9yLm5hbWUpXG4gIH1cblxuICBpZihvdGhlckNzLmlucHV0TGVuZ3RoICE9PSB0aGlzLm91dHB1dExlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNoYW5nZXNldCBsZW5ndGhzIGZvciBtZXJnaW5nIGRvbid0IG1hdGNoISBJbnB1dCBsZW5ndGggb2YgeW91bmdlciBjczogXCIrb3RoZXJDcy5pbnB1dExlbmd0aCsnLCBvdXRwdXQgbGVuZ3RoIG9mIG9sZGVyIGNzOicrdGhpcy5vdXRwdXRMZW5ndGgpXG4gIH1cblxuICB2YXIgbmV3b3BzID0gW11cbiAgICAsIGFkZFB0cjEgPSAwXG4gICAgLCByZW1QdHIxID0gMFxuICAgICwgYWRkUHRyMiA9IDBcbiAgICAsIHJlbVB0cjIgPSAwXG4gICAgLCBuZXdhZGRlbmR1bSA9ICcnXG4gICAgLCBuZXdyZW1vdmVuZHVtID0gJydcblxuICB6aXAodGhpcywgb3RoZXJDcywgZnVuY3Rpb24ob3AxLCBvcDIpIHtcbiAgICAvLyBjb25zb2xlLmxvZyhuZXdvcHMpXG4gICAgLy8gY29uc29sZS5sb2cob3AxLCBvcDIpXG5cbiAgICAvLyBJJ20gZGVsZXRpbmcgc29tZXRoaW5nIC0tIHRoZSBvdGhlciBjcyBjYW4ndCBrbm93IHRoYXQsIHNvIGp1c3Qgb3ZlcnRha2UgbXkgb3BcbiAgICBpZihvcDEgJiYgIW9wMS5vdXRwdXQpIHtcbiAgICAgIG5ld29wcy5wdXNoKG9wMS5tZXJnZSgpLmNsb25lKCkpXG4gICAgICBuZXdyZW1vdmVuZHVtICs9IHRoaXMucmVtb3ZlbmR1bS5zdWJzdHIocmVtUHRyMSwgb3AxLmxlbmd0aCkgLy8gb3ZlcnRha2UgYWRkZWQgY2hhcnNcbiAgICAgIHJlbVB0cjEgKz0gb3AxLmxlbmd0aFxuICAgICAgb3AxLmxlbmd0aCA9IDAgLy8gZG9uJ3QgZ2ltbWUgdGhhdCBvbmUgYWdhaW4uXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBvcDIgaXMgYW4gaW5zZXJ0XG4gICAgaWYob3AyICYmICFvcDIuaW5wdXQpIHtcbiAgICAgIG5ld29wcy5wdXNoKG9wMi5tZXJnZSgpLmNsb25lKCkpXG4gICAgICBuZXdhZGRlbmR1bSArPSBvdGhlckNzLmFkZGVuZHVtLnN1YnN0cihhZGRQdHIyLCBvcDIubGVuZ3RoKSAvLyBvdmVydGFrZSBhZGRlZCBjaGFyc1xuICAgICAgYWRkUHRyMiArPSBvcDIubGVuZ3RoXG4gICAgICBvcDIubGVuZ3RoID0gMCAvLyBkb24ndCBnaW1tZSB0aGF0IG9uZSBhZ2Fpbi5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIG9wMiBpcyBlaXRoZXIgYSByZXRhaW4gb3IgYSBza2lwXG4gICAgaWYob3AyICYmIG9wMi5pbnB1dCAmJiBvcDEpIHtcbiAgICAgIC8vIG9wMiByZXRhaW5zIHdoYXRldmVyIHdlIGRvIGhlcmUgKHJldGFpbiBvciBpbnNlcnQpLCBzbyBqdXN0IGNsb25lIG15IG9wXG4gICAgICBpZihvcDIub3V0cHV0KSB7XG4gICAgICAgIG5ld29wcy5wdXNoKG9wMS5tZXJnZShvcDIpLmNsb25lKCkpXG4gICAgICAgIGlmKCFvcDEuaW5wdXQpIHsgLy8gb3ZlcnRha2UgYWRkZW5kdW1cbiAgICAgICAgICBuZXdhZGRlbmR1bSArPSB0aGlzLmFkZGVuZHVtLnN1YnN0cihhZGRQdHIxLCBvcDEubGVuZ3RoKVxuICAgICAgICAgIGFkZFB0cjEgKz0gb3AxLmxlbmd0aFxuICAgICAgICB9XG4gICAgICAgIG9wMS5sZW5ndGggPSAwIC8vIGRvbid0IGdpbW1lIHRoZXNlIGFnYWluXG4gICAgICAgIG9wMi5sZW5ndGggPSAwXG4gICAgICB9ZWxzZVxuXG4gICAgICAvLyBvcDIgZGVsZXRlcyBteSByZXRhaW4gaGVyZSwgc28ganVzdCBjbG9uZSB0aGUgZGVsZXRlXG4gICAgICAvLyAob3AxIGNhbiBvbmx5IGJlIGEgcmV0YWluIGFuZCBubyBza2lwIGhlcmUsIGNhdXNlIHdlJ3ZlIGhhbmRsZWQgc2tpcHMgYWJvdmUgYWxyZWFkeSlcbiAgICAgIGlmKCFvcDIub3V0cHV0ICYmIG9wMS5pbnB1dCkge1xuICAgICAgICBuZXdvcHMucHVzaChvcDIubWVyZ2Uob3AxKS5jbG9uZSgpKVxuICAgICAgICBuZXdyZW1vdmVuZHVtICs9IG90aGVyQ3MucmVtb3ZlbmR1bS5zdWJzdHIocmVtUHRyMiwgb3AyLmxlbmd0aCkgLy8gb3ZlcnRha2UgYWRkZWQgY2hhcnNcbiAgICAgICAgcmVtUHRyMiArPSBvcDIubGVuZ3RoXG4gICAgICAgIG9wMS5sZW5ndGggPSAwIC8vIGRvbid0IGdpbW1lIHRoZXNlIGFnYWluXG4gICAgICAgIG9wMi5sZW5ndGggPSAwXG4gICAgICB9ZWxzZVxuXG4gICAgICAvL290aGVyQ3MgZGVsZXRlcyBzb21ldGhpbmcgSSBhZGRlZCAoLTEpICsxID0gMFxuICAgICAge1xuICAgICAgICBhZGRQdHIxICs9IG9wMS5sZW5ndGhcbiAgICAgICAgb3AxLmxlbmd0aCA9IDAgLy8gZG9uJ3QgZ2ltbWUgdGhlc2UgYWdhaW5cbiAgICAgICAgb3AyLmxlbmd0aCA9IDBcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCdvb3BzJywgYXJndW1lbnRzKVxuICAgIHRocm93IG5ldyBFcnJvcignb29wcy4gVGhpcyBjYXNlIGhhc25cXCd0IGJlZW4gY29uc2lkZXJlZCBieSB0aGUgZGV2ZWxvcGVyIChlcnJvciBjb2RlOiBQQkNBQyknKVxuICB9LmJpbmQodGhpcykpXG5cbiAgdmFyIG5ld0NzID0gbmV3IENoYW5nZXNldChuZXdvcHMpXG4gIG5ld0NzLmFkZGVuZHVtID0gbmV3YWRkZW5kdW1cbiAgbmV3Q3MucmVtb3ZlbmR1bSA9IG5ld3JlbW92ZW5kdW1cblxuICByZXR1cm4gbmV3Q3Ncbn1cblxuLyoqXG4gKiBBIHByaXZhdGUgYW5kIHF1aXRlIGhhbmR5IGZ1bmN0aW9uIHRoYXQgc2xpY2VzIG9wcyBpbnRvIGVxdWFsbHkgbG9uZyBwaWVjZXMgYW5kIGFwcGxpZXMgdGhlbSBvbiBhIG1hcHBpbmcgZnVuY3Rpb25cbiAqIHRoYXQgY2FuIGRldGVybWluZSB0aGUgaXRlcmF0aW9uIHN0ZXBzIGJ5IHNldHRpbmcgb3AubGVuZ3RoIHRvIDAgb24gYW4gb3AgKGVxdWFscyB1c2luZyAubmV4dCgpIGluIGEgdXN1YWwgaXRlcmF0b3IpXG4gKi9cbmZ1bmN0aW9uIHppcChjczEsIGNzMiwgZnVuYykge1xuICB2YXIgb3BzdGFjazEgPSBjczEubWFwKGZ1bmN0aW9uKG9wKSB7cmV0dXJuIG9wLmNsb25lKCl9KSAvLyBjb3B5IG9wc1xuICAgICwgb3BzdGFjazIgPSBjczIubWFwKGZ1bmN0aW9uKG9wKSB7cmV0dXJuIG9wLmNsb25lKCl9KVxuXG4gIHZhciBvcDIsIG9wMVxuICB3aGlsZShvcHN0YWNrMS5sZW5ndGggfHwgb3BzdGFjazIubGVuZ3RoKSB7Ly8gaXRlcmF0ZSB0aHJvdWdoIGFsbCBvdXRzdGFuZGluZyBvcHMgb2YgdGhpcyBjc1xuICAgIG9wMSA9IG9wc3RhY2sxWzBdPyBvcHN0YWNrMVswXS5jbG9uZSgpIDogbnVsbFxuICAgIG9wMiA9IG9wc3RhY2syWzBdPyBvcHN0YWNrMlswXS5jbG9uZSgpIDogbnVsbFxuXG4gICAgaWYob3AxKSB7XG4gICAgICBpZihvcDIpIG9wMSA9IG9wMS5kZXJpdmUoTWF0aC5taW4ob3AxLmxlbmd0aCwgb3AyLmxlbmd0aCkpIC8vIHNsaWNlICdlbSBpbnRvIGVxdWFsbHkgbG9uZyBwaWVjZXNcbiAgICAgIGlmKG9wc3RhY2sxWzBdLmxlbmd0aCA+IG9wMS5sZW5ndGgpIG9wc3RhY2sxWzBdID0gb3BzdGFjazFbMF0uZGVyaXZlKG9wc3RhY2sxWzBdLmxlbmd0aC1vcDEubGVuZ3RoKVxuICAgICAgZWxzZSBvcHN0YWNrMS5zaGlmdCgpXG4gICAgfVxuXG4gICAgaWYob3AyKSB7XG4gICAgICBpZihvcDEpIG9wMiA9IG9wMi5kZXJpdmUoTWF0aC5taW4ob3AxLmxlbmd0aCwgb3AyLmxlbmd0aCkpIC8vIHNsaWNlICdlbSBpbnRvIGVxdWFsbHkgbG9uZyBwaWVjZXNcbiAgICAgIGlmKG9wc3RhY2syWzBdLmxlbmd0aCA+IG9wMi5sZW5ndGgpIG9wc3RhY2syWzBdID0gb3BzdGFjazJbMF0uZGVyaXZlKG9wc3RhY2syWzBdLmxlbmd0aC1vcDIubGVuZ3RoKVxuICAgICAgZWxzZSBvcHN0YWNrMi5zaGlmdCgpXG4gICAgfVxuXG4gICAgZnVuYyhvcDEsIG9wMilcblxuICAgIGlmKG9wMSAmJiBvcDEubGVuZ3RoKSBvcHN0YWNrMS51bnNoaWZ0KG9wMSlcbiAgICBpZihvcDIgJiYgb3AyLmxlbmd0aCkgb3BzdGFjazIudW5zaGlmdChvcDIpXG4gIH1cbn1cblxuLyoqXG4gKiBJbmNsdXNpb24gVHJhbnNmb3JtYXRpb24gKElUKSBvciBGb3J3YXJkIFRyYW5zZm9ybWF0aW9uXG4gKlxuICogdHJhbnNmb3JtcyB0aGUgb3BlcmF0aW9ucyBvZiB0aGUgY3VycmVudCBjaGFuZ2VzZXQgYWdhaW5zdCB0aGVcbiAqIGFsbCBvcGVyYXRpb25zIGluIGFub3RoZXIgY2hhbmdlc2V0IGluIHN1Y2ggYSB3YXkgdGhhdCB0aGVcbiAqIGVmZmVjdHMgb2YgdGhlIGxhdHRlciBhcmUgZWZmZWN0aXZlbHkgaW5jbHVkZWQuXG4gKiBUaGlzIGlzIGJhc2ljYWxseSBsaWtlIGEgYXBwbHlpbmcgdGhlIG90aGVyIGNzIG9uIHRoaXMgb25lLlxuICpcbiAqIEBwYXJhbSBvdGhlckNzIDxDaGFuZ2VzZXQ+XG4gKiBAcGFyYW0gbGVmdCA8Ym9vbGVhbj4gV2hpY2ggb3AgdG8gY2hvb3NlIGlmIHRoZXJlJ3MgYW4gaW5zZXJ0IHRpZSAoSWYgeW91IHVzZSB0aGlzIGZ1bmN0aW9uIGluIGEgZGlzdHJpYnV0ZWQsIHN5bmNocm9ub3VzIGVudmlyb25tZW50LCBiZSBzdXJlIHRvIGludmVydCB0aGlzIHBhcmFtIG9uIHRoZSBvdGhlciBzaXRlLCBvdGhlcndpc2UgaXQgY2FuIGJlIG9taXR0ZWQgc2FmZWx5KVxuICpcbiAqIEByZXR1cm5zIDxDaGFuZ2VzZXQ+XG4gKi9cbkNoYW5nZXNldC5wcm90b3R5cGUudHJhbnNmb3JtQWdhaW5zdCA9IGZ1bmN0aW9uKG90aGVyQ3MsIGxlZnQpIHtcbiAgaWYoIShvdGhlckNzIGluc3RhbmNlb2YgQ2hhbmdlc2V0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQXJndW1lbnQgdG8gQ2hhbmdlc2V0I3RyYW5zZm9ybUFnYWluc3QgbXVzdCBiZSBhICM8Q2hhbmdlc2V0PiwgYnV0IHJlY2VpdmVkICcrb3RoZXJDcy5fX3Byb3RvX18uY29uc3RydWN0b3IubmFtZSlcbiAgfVxuXG4gIGlmKHRoaXMuaW5wdXRMZW5ndGggIT0gb3RoZXJDcy5pbnB1dExlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCB0cmFuc2Zvcm0gY2hhbmdlc2V0cyB3aXRoIGRpZmZlcmluZyBpbnB1dExlbmd0aDogJyt0aGlzLmlucHV0TGVuZ3RoKycgYW5kICcrb3RoZXJDcy5pbnB1dExlbmd0aClcbiAgfVxuXG4gIHZhciB0cmFuc2Zvcm1hdGlvbiA9IG5ldyBDaGFuZ2VzZXRUcmFuc2Zvcm0odGhpcywgW25ldyBSZXRhaW4oSW5maW5pdHkpXSlcbiAgb3RoZXJDcy5mb3JFYWNoKGZ1bmN0aW9uKG9wKSB7XG4gICAgdmFyIG5leHRPcCA9IHRoaXMuc3VicmFuZ2UodHJhbnNmb3JtYXRpb24ucG9zLCBJbmZpbml0eSlbMF0gLy8gbmV4dCBvcCBvZiB0aGlzIGNzXG4gICAgaWYobmV4dE9wICYmICFuZXh0T3AuaW5wdXQgJiYgIW9wLmlucHV0KSB7IC8vIHR3byBpbnNlcnRzIHRpZWQ7IGxlZnQgYnJlYWtzIGl0XG4gICAgICBpZiAobGVmdCkgdHJhbnNmb3JtYXRpb24ud3JpdGVPdXRwdXQodHJhbnNmb3JtYXRpb24ucmVhZElucHV0KG5leHRPcC5sZW5ndGgpKVxuICAgIH1cbiAgICBvcC5hcHBseSh0cmFuc2Zvcm1hdGlvbilcbiAgfS5iaW5kKHRoaXMpKVxuXG4gIHJldHVybiB0cmFuc2Zvcm1hdGlvbi5yZXN1bHQoKVxufVxuXG4vKipcbiAqIEV4Y2x1c2lvbiBUcmFuc2Zvcm1hdGlvbiAoRVQpIG9yIEJhY2t3YXJkcyBUcmFuc2Zvcm1hdGlvblxuICpcbiAqIHRyYW5zZm9ybXMgYWxsIG9wZXJhdGlvbnMgaW4gdGhlIGN1cnJlbnQgY2hhbmdlc2V0IGFnYWluc3QgdGhlIG9wZXJhdGlvbnNcbiAqIGluIGFub3RoZXIgY2hhbmdlc2V0IGluIHN1Y2ggYSB3YXkgdGhhdCB0aGUgaW1wYWN0IG9mIHRoZSBsYXR0ZXIgYXJlIGVmZmVjdGl2ZWx5IGV4Y2x1ZGVkXG4gKlxuICogQHBhcmFtIGNoYW5nZXNldCA8Q2hhbmdlc2V0PiB0aGUgY2hhbmdlc2V0IHRvIHN1YnN0cmFjdCBmcm9tIHRoaXMgb25lXG4gKiBAcGFyYW0gbGVmdCA8Ym9vbGVhbj4gV2hpY2ggb3AgdG8gY2hvb3NlIGlmIHRoZXJlJ3MgYW4gaW5zZXJ0IHRpZSAoSWYgeW91IHVzZSB0aGlzIGZ1bmN0aW9uIGluIGEgZGlzdHJpYnV0ZWQsIHN5bmNocm9ub3VzIGVudmlyb25tZW50LCBiZSBzdXJlIHRvIGludmVydCB0aGlzIHBhcmFtIG9uIHRoZSBvdGhlciBzaXRlLCBvdGhlcndpc2UgaXQgY2FuIGJlIG9taXR0ZWQgc2FmZWx5KVxuICogQHJldHVybnMgPENoYW5nZXNldD5cbiAqL1xuQ2hhbmdlc2V0LnByb3RvdHlwZS5zdWJzdHJhY3QgPSBmdW5jdGlvbihjaGFuZ2VzZXQsIGxlZnQpIHtcbiAgLy8gVGhlIGN1cnJlbnQgb3BlcmF0aW9ucyBhc3N1bWUgdGhhdCB0aGUgY2hhbmdlcyBpblxuICAvLyBgY2hhbmdlc2V0YCBoYXBwZW5lZCBiZWZvcmUsIHNvIGZvciBlYWNoIG9mIHRob3NlIG9wc1xuICAvLyB3ZSBjcmVhdGUgYW4gb3BlcmF0aW9uIHRoYXQgdW5kb2VzIGl0cyBlZmZlY3QgYW5kXG4gIC8vIHRyYW5zZm9ybSBhbGwgb3VyIG9wZXJhdGlvbnMgb24gdG9wIG9mIHRoZSBpbnZlcnNlIGNoYW5nZXNcbiAgcmV0dXJuIHRoaXMudHJhbnNmb3JtQWdhaW5zdChjaGFuZ2VzZXQuaW52ZXJ0KCksIGxlZnQpXG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBDaGFuZ2VzZXQgb2YgdGhlIGN1cnJlbnQgb25lXG4gKlxuICogQ2hhbmdlc2V0LmludmVydCgpLmFwcGx5KENoYW5nZXNldC5hcHBseShkb2N1bWVudCkpID09IGRvY3VtZW50XG4gKi9cbkNoYW5nZXNldC5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24oKSB7XG4gIC8vIGludmVydCBhbGwgb3BzXG4gIHZhciBuZXdDcyA9IG5ldyBDaGFuZ2VzZXQodGhpcy5tYXAoZnVuY3Rpb24ob3ApIHtcbiAgICByZXR1cm4gb3AuaW52ZXJ0KClcbiAgfSkpXG5cbiAgLy8gcmVtb3ZlbmR1bSBiZWNvbWVzIGFkZGVuZHVtIGFuZCB2aWNlIHZlcnNhXG4gIG5ld0NzLmFkZGVuZHVtID0gdGhpcy5yZW1vdmVuZHVtXG4gIG5ld0NzLnJlbW92ZW5kdW0gPSB0aGlzLmFkZGVuZHVtXG5cbiAgcmV0dXJuIG5ld0NzXG59XG5cbi8qKlxuICogQXBwbGllcyB0aGlzIGNoYW5nZXNldCBvbiBhIHRleHRcbiAqL1xuQ2hhbmdlc2V0LnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIC8vIHByZS1yZXF1aXNpdGVzXG4gIGlmKGlucHV0Lmxlbmd0aCAhPSB0aGlzLmlucHV0TGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGxlbmd0aCBkb2VzblxcJ3QgbWF0Y2ggZXhwZWN0ZWQgbGVuZ3RoLiBleHBlY3RlZDogJyt0aGlzLmlucHV0TGVuZ3RoKyc7IGFjdHVhbDogJytpbnB1dC5sZW5ndGgpXG5cbiAgdmFyIG9wZXJhdGlvbiA9IG5ldyBUZXh0VHJhbnNmb3JtKGlucHV0LCB0aGlzLmFkZGVuZHVtLCB0aGlzLnJlbW92ZW5kdW0pXG5cbiAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKG9wKSB7XG4gICAgLy8gZWFjaCBPcGVyYXRpb24gaGFzIGFjY2VzcyB0byBhbGwgcG9pbnRlcnMgYXMgd2VsbCBhcyB0aGUgaW5wdXQsIGFkZGVuZHVtIGFuZCByZW1vdmVuZHVtICh0aGUgbGF0dGVyIGFyZSBpbW11dGFibGUpXG4gICAgb3AuYXBwbHkob3BlcmF0aW9uKVxuICB9LmJpbmQodGhpcykpXG5cbiAgcmV0dXJuIG9wZXJhdGlvbi5yZXN1bHQoKVxufVxuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2Ygc3RyaW5ncyBkZXNjcmliaW5nIHRoaXMgY2hhbmdlc2V0J3Mgb3BlcmF0aW9uc1xuICovXG5DaGFuZ2VzZXQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGogPSAwXG4gIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihvcCkge1xuICAgIHZhciBzdHJpbmcgPSAnJ1xuXG4gICAgaWYoIW9wLmlucHV0KSB7IC8vIGlmIEluc2VydFxuICAgICAgc3RyaW5nID0gdGhpcy5hZGRlbmR1bS5zdWJzdHIoaixvcC5sZW5ndGgpXG4gICAgICBqICs9IG9wLmxlbmd0aFxuICAgICAgcmV0dXJuIHN0cmluZ1xuICAgIH1cblxuICAgIGZvcih2YXIgaT0wOyBpPG9wLmxlbmd0aDsgaSsrKSBzdHJpbmcgKz0gb3Auc3ltYm9sXG4gICAgcmV0dXJuIHN0cmluZ1xuICB9LmJpbmQodGhpcykpLmpvaW4oJycpXG59XG5cbi8qKlxuICogU2VyaWFsaXplcyB0aGUgZ2l2ZW4gY2hhbmdlc2V0IGluIG9yZGVyIHRvIHJldHVybiBhIChob3BlZnVsbHkpIG1vcmUgY29tcGFjdCByZXByZXNlbnRhdGlvblxuICogdGhhbiBqc29uIHRoYXQgY2FuIGJlIHNlbnQgdGhyb3VnaCBhIG5ldHdvcmsgb3Igc3RvcmVkIGluIGEgZGF0YWJhc2VcbiAqXG4gKiBOdW1iZXJzIGFyZSBjb252ZXJ0ZWQgdG8gdGhlIGJhc2UgMzYsIHVuc2FmZSBjaGFycyBpbiB0aGUgdGV4dCBhcmUgdXJsZW5jb2RlZFxuICpcbiAqIEBwYXJhbSBjcyA8Q2hhbmdlc2V0PiBUaGUgY2hhbmdlc2V0IHRvIGJlIHNlcmlhbGl6ZWRcbiAqIEByZXR1cm5zIDxTdHJpbmc+IFRoZSBzZXJpYWxpemVkIGNoYW5nZXNldFxuICovXG5DaGFuZ2VzZXQucHJvdG90eXBlLnBhY2sgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBhY2tlZCA9IHRoaXMubWFwKGZ1bmN0aW9uKG9wKSB7XG4gICAgcmV0dXJuIG9wLnBhY2soKVxuICB9KS5qb2luKCcnKVxuXG4gIHZhciBhZGRlbmR1bSA9IHRoaXMuYWRkZW5kdW0ucmVwbGFjZSgvJS9nLCAnJTI1JykucmVwbGFjZSgvXFx8L2csICclN0MnKVxuICAgICwgcmVtb3ZlbmR1bSA9IHRoaXMucmVtb3ZlbmR1bS5yZXBsYWNlKC8lL2csICclMjUnKS5yZXBsYWNlKC9cXHwvZywgJyU3QycpXG4gIHJldHVybiBwYWNrZWQrJ3wnK2FkZGVuZHVtKyd8JytyZW1vdmVuZHVtXG59XG5DaGFuZ2VzZXQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnBhY2soKVxufVxuXG4vKipcbiAqIFVuc2VyaWFsaXplcyB0aGUgb3V0cHV0IG9mIGNzLnRleHQuQ2hhbmdlc2V0I3RvU3RyaW5nKClcbiAqXG4gKiBAcGFyYW0gcGFja2VkIDxTdHJpbmc+IFRoZSBzZXJpYWxpemVkIGNoYW5nZXNldFxuICogQHBhcmFtIDxjcy5DaGFuZ2VzZXQ+XG4gKi9cbkNoYW5nZXNldC51bnBhY2sgPSBmdW5jdGlvbihwYWNrZWQpIHtcbiAgaWYocGFja2VkID09ICcnKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1bnBhY2sgZnJvbSBlbXB0eSBzdHJpbmcnKVxuICB2YXIgY29tcG9uZW50cyA9IHBhY2tlZC5zcGxpdCgnfCcpXG4gICAgLCBvcHN0cmluZyA9IGNvbXBvbmVudHNbMF1cbiAgICAsIGFkZGVuZHVtID0gY29tcG9uZW50c1sxXS5yZXBsYWNlKC8lN2MvZ2ksICd8JykucmVwbGFjZSgvJTI1L2csICclJylcbiAgICAsIHJlbW92ZW5kdW0gPSBjb21wb25lbnRzWzJdLnJlcGxhY2UoLyU3Yy9naSwgJ3wnKS5yZXBsYWNlKC8lMjUvZywgJyUnKVxuXG4gIHZhciBtYXRjaGVzID0gb3BzdHJpbmcubWF0Y2goL1s9Ky1dKFtePSstXSkrL2cpXG4gIGlmKCFtYXRjaGVzKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1bnBhY2sgaW52YWxpZGx5IHNlcmlhbGl6ZWQgb3Agc3RyaW5nJylcblxuICB2YXIgb3BzID0gW11cbiAgbWF0Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uKHMpIHtcbiAgICB2YXIgc3ltYm9sID0gcy5zdWJzdHIoMCwxKVxuICAgICAgLCBkYXRhID0gcy5zdWJzdHIoMSlcbiAgICBpZihTa2lwLnByb3RvdHlwZS5zeW1ib2wgPT0gc3ltYm9sKSByZXR1cm4gb3BzLnB1c2goU2tpcC51bnBhY2soZGF0YSkpXG4gICAgaWYoSW5zZXJ0LnByb3RvdHlwZS5zeW1ib2wgPT0gc3ltYm9sKSByZXR1cm4gb3BzLnB1c2goSW5zZXJ0LnVucGFjayhkYXRhKSlcbiAgICBpZihSZXRhaW4ucHJvdG90eXBlLnN5bWJvbCA9PSBzeW1ib2wpIHJldHVybiBvcHMucHVzaChSZXRhaW4udW5wYWNrKGRhdGEpKVxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjaGFuZ2VzZXQgcmVwcmVzZW50YXRpb24gcGFzc2VkIHRvIENoYW5nZXNldC51bnBhY2snKVxuICB9KVxuXG4gIHZhciBjcyA9IG5ldyBDaGFuZ2VzZXQob3BzKVxuICBjcy5hZGRlbmR1bSA9IGFkZGVuZHVtXG4gIGNzLnJlbW92ZW5kdW0gPSByZW1vdmVuZHVtXG5cbiAgcmV0dXJuIGNzXG59XG5cbkNoYW5nZXNldC5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBCdWlsZGVyXG59XG5cbi8qKlxuICogUmV0dXJucyBhIENoYW5nZXNldCBjb250YWluaW5nIHRoZSBvcGVyYXRpb25zIG5lZWRlZCB0byB0cmFuc2Zvcm0gdGV4dDEgaW50byB0ZXh0MlxuICpcbiAqIEBwYXJhbSB0ZXh0MSA8U3RyaW5nPlxuICogQHBhcmFtIHRleHQyIDxTdHJpbmc+XG4gKi9cbkNoYW5nZXNldC5mcm9tRGlmZiA9IGZ1bmN0aW9uKGRpZmYpIHtcbiAgLyoqXG4gICAqIFRoZSBkYXRhIHN0cnVjdHVyZSByZXByZXNlbnRpbmcgYSBkaWZmIGlzIGFuIGFycmF5IG9mIHR1cGxlczpcbiAgICogW1tESUZGX0RFTEVURSwgJ0hlbGxvJ10sIFtESUZGX0lOU0VSVCwgJ0dvb2RieWUnXSwgW0RJRkZfRVFVQUwsICcgd29ybGQuJ11dXG4gICAqIHdoaWNoIG1lYW5zOiBkZWxldGUgJ0hlbGxvJywgYWRkICdHb29kYnllJyBhbmQga2VlcCAnIHdvcmxkLidcbiAgICovXG4gIHZhciBESUZGX0RFTEVURSA9IC0xO1xuICB2YXIgRElGRl9JTlNFUlQgPSAxO1xuICB2YXIgRElGRl9FUVVBTCA9IDA7XG5cbiAgdmFyIG9wcyA9IFtdXG4gICAgLCByZW1vdmVuZHVtID0gJydcbiAgICAsIGFkZGVuZHVtID0gJydcblxuICBkaWZmLmZvckVhY2goZnVuY3Rpb24oZCkge1xuICAgIGlmIChESUZGX0RFTEVURSA9PSBkWzBdKSB7XG4gICAgICBvcHMucHVzaChuZXcgU2tpcChkWzFdLmxlbmd0aCkpXG4gICAgICByZW1vdmVuZHVtICs9IGRbMV1cbiAgICB9XG5cbiAgICBpZiAoRElGRl9JTlNFUlQgPT0gZFswXSkge1xuICAgICAgb3BzLnB1c2gobmV3IEluc2VydChkWzFdLmxlbmd0aCkpXG4gICAgICBhZGRlbmR1bSArPSBkWzFdXG4gICAgfVxuXG4gICAgaWYoRElGRl9FUVVBTCA9PSBkWzBdKSB7XG4gICAgICBvcHMucHVzaChuZXcgUmV0YWluKGRbMV0ubGVuZ3RoKSlcbiAgICB9XG4gIH0pXG5cbiAgdmFyIGNzID0gbmV3IENoYW5nZXNldChvcHMpXG4gIGNzLmFkZGVuZHVtID0gYWRkZW5kdW1cbiAgY3MucmVtb3ZlbmR1bSA9IHJlbW92ZW5kdW1cbiAgcmV0dXJuIGNzXG59XG4iLCIvKiFcbiAqIGNoYW5nZXNldHNcbiAqIEEgQ2hhbmdlc2V0IGxpYnJhcnkgaW5jb3Jwb3JhdGluZyBvcGVyYXRpb25hbCBDaGFuZ2VzZXRUcmFuc2Zvcm0gKE9UKVxuICogQ29weXJpZ2h0IDIwMTIgYnkgTWFyY2VsIEtsZWhyIDxta2xlaHJAZ214Lm5ldD5cbiAqXG4gKiAoTUlUIExJQ0VOU0UpXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbnZhciBSZXRhaW4gPSByZXF1aXJlKCcuL29wZXJhdGlvbnMvUmV0YWluJylcbiAgLCBTa2lwID0gcmVxdWlyZSgnLi9vcGVyYXRpb25zL1NraXAnKVxuICAsIEluc2VydCA9IHJlcXVpcmUoJy4vb3BlcmF0aW9ucy9JbnNlcnQnKVxuICAsIENoYW5nZXNldCA9IHJlcXVpcmUoJy4vQ2hhbmdlc2V0JylcblxuXG5mdW5jdGlvbiBDaGFuZ2VzZXRUcmFuc2Zvcm0oaW5wdXRDcywgYWRkZW5kdW0pIHtcbiAgdGhpcy5vdXRwdXQgPSBbXVxuICB0aGlzLmFkZGVuZHVtID0gYWRkZW5kdW1cbiAgdGhpcy5uZXdSZW1vdmVuZHVtID0gJydcbiAgdGhpcy5uZXdBZGRlbmR1bSA9ICcnXG5cbiAgdGhpcy5jcyA9IGlucHV0Q3NcbiAgdGhpcy5wb3MgPSAwXG4gIHRoaXMuYWRkZW5kdW1Qb2ludGVyID0gMFxuICB0aGlzLnJlbW92ZW5kdW1Qb2ludGVyID0gMFxufVxubW9kdWxlLmV4cG9ydHMgPSBDaGFuZ2VzZXRUcmFuc2Zvcm1cblxuQ2hhbmdlc2V0VHJhbnNmb3JtLnByb3RvdHlwZS5yZWFkSW5wdXQgPSBmdW5jdGlvbiAobGVuKSB7XG4gIHZhciByZXQgPSB0aGlzLmNzLnN1YnJhbmdlKHRoaXMucG9zLCBsZW4pXG4gIHRoaXMucG9zICs9IGxlblxuICByZXR1cm4gcmV0XG59XG5cbkNoYW5nZXNldFRyYW5zZm9ybS5wcm90b3R5cGUucmVhZEFkZGVuZHVtID0gZnVuY3Rpb24gKGxlbikge1xuICAvL3JldHVybiBbbmV3IFJldGFpbihsZW4pXVxuICB2YXIgcmV0ID0gdGhpcy5zdWJyYW5nZSh0aGlzLmFkZGVuZHVtLCB0aGlzLmFkZGVuZHVtUG9pbnRlciwgbGVuKVxuICB0aGlzLmFkZGVuZHVtUG9pbnRlciArPSBsZW5cbiAgcmV0dXJuIHJldFxufVxuXG5DaGFuZ2VzZXRUcmFuc2Zvcm0ucHJvdG90eXBlLndyaXRlUmVtb3ZlbmR1bSA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICByYW5nZVxuICAgIC5maWx0ZXIoZnVuY3Rpb24ob3ApIHtyZXR1cm4gIW9wLm91dHB1dH0pXG4gICAgLmZvckVhY2goZnVuY3Rpb24ob3ApIHtcbiAgICAgIHRoaXMucmVtb3ZlbmR1bVBvaW50ZXIgKz0gb3AubGVuZ3RoXG4gICAgfS5iaW5kKHRoaXMpKVxufVxuXG5DaGFuZ2VzZXRUcmFuc2Zvcm0ucHJvdG90eXBlLndyaXRlT3V0cHV0ID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gIHRoaXMub3V0cHV0ID0gdGhpcy5vdXRwdXQuY29uY2F0KHJhbmdlKVxuICByYW5nZVxuICAgIC5maWx0ZXIoZnVuY3Rpb24ob3ApIHtyZXR1cm4gIW9wLm91dHB1dH0pXG4gICAgLmZvckVhY2goZnVuY3Rpb24ob3ApIHtcbiAgICAgIHRoaXMubmV3UmVtb3ZlbmR1bSArPSB0aGlzLmNzLnJlbW92ZW5kdW0uc3Vic3RyKHRoaXMucmVtb3ZlbmR1bVBvaW50ZXIsIG9wLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlbmR1bVBvaW50ZXIgKz0gb3AubGVuZ3RoXG4gICAgfS5iaW5kKHRoaXMpKVxufVxuXG5DaGFuZ2VzZXRUcmFuc2Zvcm0ucHJvdG90eXBlLnN1YnJhbmdlID0gZnVuY3Rpb24gKHJhbmdlLCBzdGFydCwgbGVuKSB7XG4gIGlmKGxlbikgcmV0dXJuIHRoaXMuY3Muc3VicmFuZ2UuY2FsbChyYW5nZSwgc3RhcnQsIGxlbilcbiAgZWxzZSByZXR1cm4gcmFuZ2UuZmlsdGVyKGZ1bmN0aW9uKG9wKXsgcmV0dXJuICFvcC5pbnB1dH0pXG59XG5cbkNoYW5nZXNldFRyYW5zZm9ybS5wcm90b3R5cGUucmVzdWx0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMud3JpdGVPdXRwdXQodGhpcy5yZWFkSW5wdXQoSW5maW5pdHkpKVxuICB2YXIgbmV3Q3MgPSBuZXcgQ2hhbmdlc2V0KHRoaXMub3V0cHV0KVxuICBuZXdDcy5hZGRlbmR1bSA9IHRoaXMuY3MuYWRkZW5kdW1cbiAgbmV3Q3MucmVtb3ZlbmR1bSA9IHRoaXMubmV3UmVtb3ZlbmR1bVxuICByZXR1cm4gbmV3Q3Ncbn1cbiIsImZ1bmN0aW9uIE9wZXJhdG9yKCkge1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE9wZXJhdG9yXG5cbk9wZXJhdG9yLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5kZXJpdmUodGhpcy5sZW5ndGgpXG59XG5cbk9wZXJhdG9yLnByb3RvdHlwZS5kZXJpdmUgPSBmdW5jdGlvbihsZW4pIHtcbiAgcmV0dXJuIG5ldyAodGhpcy5jb25zdHJ1Y3RvcikobGVuKVxufVxuXG5PcGVyYXRvci5wcm90b3R5cGUucGFjayA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5zeW1ib2wgKyAodGhpcy5sZW5ndGgpLnRvU3RyaW5nKDM2KVxufVxuIiwiLyohXG4gKiBjaGFuZ2VzZXRzXG4gKiBBIENoYW5nZXNldCBsaWJyYXJ5IGluY29ycG9yYXRpbmcgb3BlcmF0aW9uYWwgQXBwbHkgKE9UKVxuICogQ29weXJpZ2h0IDIwMTIgYnkgTWFyY2VsIEtsZWhyIDxta2xlaHJAZ214Lm5ldD5cbiAqXG4gKiAoTUlUIExJQ0VOU0UpXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbnZhciBSZXRhaW4gPSByZXF1aXJlKCcuL29wZXJhdGlvbnMvUmV0YWluJylcbiAgLCBTa2lwID0gcmVxdWlyZSgnLi9vcGVyYXRpb25zL1NraXAnKVxuICAsIEluc2VydCA9IHJlcXVpcmUoJy4vb3BlcmF0aW9ucy9JbnNlcnQnKVxuICAsIEluc2VydCA9IHJlcXVpcmUoJy4vQ2hhbmdlc2V0JylcblxuXG5mdW5jdGlvbiBUZXh0VHJhbnNmb3JtKGlucHV0LCBhZGRlbmR1bSwgcmVtb3ZlbmR1bSkge1xuICB0aGlzLm91dHB1dCA9ICcnXG5cbiAgdGhpcy5pbnB1dCA9IGlucHV0XG4gIHRoaXMuYWRkZW5kdW0gPSBhZGRlbmR1bVxuICB0aGlzLnJlbW92ZW5kdW0gPSByZW1vdmVuZHVtXG4gIHRoaXMucG9zID0gMFxuICB0aGlzLmFkZFBvcyA9IDBcbiAgdGhpcy5yZW1Qb3MgPSAwXG59XG5tb2R1bGUuZXhwb3J0cyA9IFRleHRUcmFuc2Zvcm1cblxuVGV4dFRyYW5zZm9ybS5wcm90b3R5cGUucmVhZElucHV0ID0gZnVuY3Rpb24gKGxlbikge1xuICB2YXIgcmV0ID0gdGhpcy5pbnB1dC5zdWJzdHIodGhpcy5wb3MsIGxlbilcbiAgdGhpcy5wb3MgKz0gbGVuXG4gIHJldHVybiByZXRcbn1cblxuVGV4dFRyYW5zZm9ybS5wcm90b3R5cGUucmVhZEFkZGVuZHVtID0gZnVuY3Rpb24gKGxlbikge1xuICB2YXIgcmV0ID0gdGhpcy5hZGRlbmR1bS5zdWJzdHIodGhpcy5hZGRQb3MsIGxlbilcbiAgdGhpcy5hZGRQb3MgKz0gbGVuXG4gIHJldHVybiByZXRcbn1cblxuVGV4dFRyYW5zZm9ybS5wcm90b3R5cGUud3JpdGVSZW1vdmVuZHVtID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gIC8vdmFyIGV4cGVjdGVkID0gdGhpcy5yZW1vdmVuZHVtLnN1YnN0cih0aGlzLnJlbVBvcywgcmFuZ2UubGVuZ3RoKVxuICAvL2lmKHJhbmdlICE9IGV4cGVjdGVkKSB0aHJvdyBuZXcgRXJyb3IoJ1JlbW92ZWQgY2hhcnMgZG9uXFwndCBtYXRjaCByZW1vdmVuZHVtLiBleHBlY3RlZDogJytleHBlY3RlZCsnOyBhY3R1YWw6ICcrcmFuZ2UpXG4gIHRoaXMucmVtUG9zICs9IHJhbmdlLmxlbmd0aFxufVxuXG5UZXh0VHJhbnNmb3JtLnByb3RvdHlwZS53cml0ZU91dHB1dCA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICB0aGlzLm91dHB1dCArPSByYW5nZVxufVxuXG5UZXh0VHJhbnNmb3JtLnByb3RvdHlwZS5zdWJyYW5nZSA9IGZ1bmN0aW9uIChyYW5nZSwgc3RhcnQsIGxlbikge1xuICByZXR1cm4gcmFuZ2Uuc3Vic3RyKHN0YXJ0LCBsZW4pXG59XG5cblRleHRUcmFuc2Zvcm0ucHJvdG90eXBlLnJlc3VsdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLndyaXRlT3V0cHV0KHRoaXMucmVhZElucHV0KEluZmluaXR5KSlcbiAgcmV0dXJuIHRoaXMub3V0cHV0XG59XG4iLCIvKiFcbiAqIGNoYW5nZXNldHNcbiAqIEEgQ2hhbmdlc2V0IGxpYnJhcnkgaW5jb3Jwb3JhdGluZyBvcGVyYXRpb25hbCB0cmFuc2Zvcm1hdGlvbiAoT1QpXG4gKiBDb3B5cmlnaHQgMjAxMiBieSBNYXJjZWwgS2xlaHIgPG1rbGVockBnbXgubmV0PlxuICpcbiAqIChNSVQgTElDRU5TRSlcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxudmFyIENoYW5nZXNldCA9IHJlcXVpcmUoJy4vQ2hhbmdlc2V0JylcbiAgLCBSZXRhaW4gPSByZXF1aXJlKCcuL29wZXJhdGlvbnMvUmV0YWluJylcbiAgLCBTa2lwID0gcmVxdWlyZSgnLi9vcGVyYXRpb25zL1NraXAnKVxuICAsIEluc2VydCA9IHJlcXVpcmUoJy4vb3BlcmF0aW9ucy9JbnNlcnQnKVxuXG5leHBvcnRzLk9wZXJhdG9yID0gcmVxdWlyZSgnLi9PcGVyYXRvcicpXG5leHBvcnRzLkNoYW5nZXNldCA9IENoYW5nZXNldFxuZXhwb3J0cy5JbnNlcnQgPSBJbnNlcnRcbmV4cG9ydHMuUmV0YWluID0gUmV0YWluXG5leHBvcnRzLlNraXAgPSBTa2lwXG5cbmlmKCd1bmRlZmluZWQnICE9IHR5cGVvZiB3aW5kb3cpIHdpbmRvdy5jaGFuZ2VzZXRzID0gZXhwb3J0c1xuXG4vKipcbiAqIFNlcmlhbGl6ZXMgdGhlIGdpdmVuIGNoYW5nZXNldCBpbiBvcmRlciB0byByZXR1cm4gYSAoaG9wZWZ1bGx5KSBtb3JlIGNvbXBhY3QgcmVwcmVzZW50YXRpb25cbiAqIHRoYXQgY2FuIGJlIHNlbnQgdGhyb3VnaCBhIG5ldHdvcmsgb3Igc3RvcmVkIGluIGEgZGF0YWJhc2VcbiAqIEBhbGlhcyBjcy50ZXh0LkNoYW5nZXNldCNwYWNrXG4gKi9cbmV4cG9ydHMucGFjayA9IGZ1bmN0aW9uKGNzKSB7XG4gIHJldHVybiBjcy5wYWNrKClcbn1cblxuLyoqXG4gKiBVbnNlcmlhbGl6ZXMgdGhlIG91dHB1dCBvZiBjcy50ZXh0LnBhY2tcbiAqIEBhbGlhcyBjcy50ZXh0LkNoYW5nZXNldC51bnBhY2tcbiAqL1xuZXhwb3J0cy51bnBhY2sgPSBmdW5jdGlvbihwYWNrZWQpIHtcbiAgcmV0dXJuIENoYW5nZXNldC51bnBhY2socGFja2VkKVxufVxuXG5cblxuXG4vKipcbiAqIHNoYXJlSlMgb3QgdHlwZSBBUEkgc2VwYyBzdXBwb3J0XG4gKi9cblxuZXhwb3J0cy5uYW1lID0gJ2NoYW5nZXNldHMnXG5leHBvcnRzLnVybCA9ICdodHRwczovL2dpdGh1Yi5jb20vbWFyY2Vsa2xlaHIvY2hhbmdlc2V0cydcblxuLyoqXG4gKiBjcmVhdGUoW2luaXRpYWxUZXh0XSlcbiAqXG4gKiBjcmVhdGVzIGEgc25hcHNob3QgKG9wdGlvbmFsbHkgd2l0aCBzdXBwbGllZCBpbnRpYWwgdGV4dClcbiAqL1xuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbihpbml0VGV4dCkge1xuICByZXR1cm4gaW5pdFRleHQgfHwgJydcbn1cblxuLyoqXG4gKiBBcHBseSBhIGNoYW5nZXNldCBvbiBhIHNuYXBzaG90IGNyZWF0aW5nIGEgbmV3IG9uZVxuICpcbiAqIFRoZSBvbGQgc25hcHNob3Qgb2JqZWN0IG11c3RuJ3QgYmUgdXNlZCBhZnRlciBjYWxsaW5nIGFwcGx5IG9uIGl0XG4gKiByZXR1cm5zIHRoZSByZXN1bHRpbmdcbiAqL1xuZXhwb3J0cy5hcHBseSA9IGZ1bmN0aW9uKHNuYXBzaG90LCBvcCkge1xuICBvcCA9IGV4cG9ydHMudW5wYWNrKG9wKVxuICByZXR1cm4gb3AuYXBwbHkoc25hcHNob3QpXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGNoYW5nZXNldDEgYWdhaW5zdCBjaGFuZ2VzZXQyXG4gKi9cbmV4cG9ydHMudHJhbnNmb3JtID0gZnVuY3Rpb24gKG9wMSwgb3AyLCBzaWRlKSB7XG4gIG9wMSA9IGV4cG9ydHMudW5wYWNrKG9wMSlcbiAgb3AyID0gZXhwb3J0cy51bnBhY2sob3AyKVxuICByZXR1cm4gZXhwb3J0cy5wYWNrKG9wMS50cmFuc2Zvcm1BZ2FpbnN0KG9wMiwgKCdsZWZ0Jz09c2lkZSkpKVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBjaGFuZ2VzZXRzIGludG8gb25lXG4gKi9cbmV4cG9ydHMuY29tcG9zZSA9IGZ1bmN0aW9uIChvcDEsIG9wMikge1xuICBvcDEgPSBleHBvcnRzLnVucGFjayhvcDEpXG4gIG9wMiA9IGV4cG9ydHMudW5wYWNrKG9wMilcbiAgcmV0dXJuIGV4cG9ydHMucGFjayhvcDEubWVyZ2Uob3AyKSlcbn1cblxuLyoqXG4gKiBJbnZlcnQgYSBjaGFuZ2VzZXRcbiAqL1xuZXhwb3J0cy5pbnZlcnQgPSBmdW5jdGlvbihvcCkge1xuICByZXR1cm4gZXhwb3J0cy5wYWNrKGV4cG9ydHMudW5wYWNrKG9wKS5pbnZlcnQoKSlcbn1cbiIsIi8qIVxuICogY2hhbmdlc2V0c1xuICogQSBDaGFuZ2VzZXQgbGlicmFyeSBpbmNvcnBvcmF0aW5nIG9wZXJhdGlvbmFsIHRyYW5zZm9ybWF0aW9uIChPVClcbiAqIENvcHlyaWdodCAyMDEyIGJ5IE1hcmNlbCBLbGVociA8bWtsZWhyQGdteC5uZXQ+XG4gKlxuICogKE1JVCBMSUNFTlNFKVxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG52YXIgT3BlcmF0b3IgPSByZXF1aXJlKCcuLi9PcGVyYXRvcicpXG5cbi8qKlxuICogSW5zZXJ0IE9wZXJhdG9yXG4gKiBEZWZpbmVkIGJ5OlxuICogLSBsZW5ndGhcbiAqIC0gaW5wdXQ9MFxuICogLSBvdXRwdXQ9bGVuZ3RoXG4gKlxuICogQHBhcmFtIGxlbmd0aCA8TnVtYmVyPiBIb3cgbWFueSBjaGFycyB0byBiZSBpbnNlcnRlZFxuICovXG5mdW5jdGlvbiBJbnNlcnQobGVuZ3RoKSB7XG4gIHRoaXMubGVuZ3RoID0gbGVuZ3RoXG4gIHRoaXMuaW5wdXQgPSAwXG4gIHRoaXMub3V0cHV0ID0gbGVuZ3RoXG59XG5cbi8vIFRydWUgaW5oZXJpdGFuY2Vcbkluc2VydC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE9wZXJhdG9yLnByb3RvdHlwZSwge1xuICBjb25zdHJ1Y3Rvcjoge1xuICAgIHZhbHVlOiBJbnNlcnQsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH1cbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBJbnNlcnRcbkluc2VydC5wcm90b3R5cGUuc3ltYm9sID0gJysnXG5cbnZhciBTa2lwID0gcmVxdWlyZSgnLi9Ta2lwJylcbiAgLCBSZXRhaW4gPSByZXF1aXJlKCcuL1JldGFpbicpXG5cbkluc2VydC5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbih0KSB7XG4gIHQud3JpdGVPdXRwdXQodC5yZWFkQWRkZW5kdW0odGhpcy5vdXRwdXQpKVxufVxuXG5JbnNlcnQucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzXG59XG5cbkluc2VydC5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgU2tpcCh0aGlzLmxlbmd0aClcbn1cblxuSW5zZXJ0LnVucGFjayA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgcmV0dXJuIG5ldyBJbnNlcnQocGFyc2VJbnQoZGF0YSwgMzYpKVxufVxuIiwiLyohXG4gKiBjaGFuZ2VzZXRzXG4gKiBBIENoYW5nZXNldCBsaWJyYXJ5IGluY29ycG9yYXRpbmcgb3BlcmF0aW9uYWwgdHJhbnNmb3JtYXRpb24gKE9UKVxuICogQ29weXJpZ2h0IDIwMTIgYnkgTWFyY2VsIEtsZWhyIDxta2xlaHJAZ214Lm5ldD5cbiAqXG4gKiAoTUlUIExJQ0VOU0UpXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbnZhciBPcGVyYXRvciA9IHJlcXVpcmUoJy4uL09wZXJhdG9yJylcblxuLyoqXG4gKiBSZXRhaW4gT3BlcmF0b3JcbiAqIERlZmluZWQgYnk6XG4gKiAtIGxlbmd0aFxuICogLSBpbnB1dD1vdXRwdXQ9bGVuZ3RoXG4gKlxuICogQHBhcmFtIGxlbmd0aCA8TnVtYmVyPiBIb3cgbWFueSBjaGFycyB0byByZXRhaW5cbiAqL1xuZnVuY3Rpb24gUmV0YWluKGxlbmd0aCkge1xuICB0aGlzLmxlbmd0aCA9IGxlbmd0aFxuICB0aGlzLmlucHV0ID0gbGVuZ3RoXG4gIHRoaXMub3V0cHV0ID0gbGVuZ3RoXG59XG5cbi8vIFRydWUgaW5oZXJpdGFuY2VcblJldGFpbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE9wZXJhdG9yLnByb3RvdHlwZSwge1xuICBjb25zdHJ1Y3Rvcjoge1xuICAgIHZhbHVlOiBSZXRhaW4sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH1cbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBSZXRhaW5cblJldGFpbi5wcm90b3R5cGUuc3ltYm9sID0gJz0nXG5cblJldGFpbi5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbih0KSB7XG4gIHQud3JpdGVPdXRwdXQodC5yZWFkSW5wdXQodGhpcy5pbnB1dCkpXG59XG5cblJldGFpbi5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzXG59XG5cblJldGFpbi5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbihvcDIpIHtcbiAgcmV0dXJuIHRoaXNcbn1cblxuUmV0YWluLnVucGFjayA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgcmV0dXJuIG5ldyBSZXRhaW4ocGFyc2VJbnQoZGF0YSwgMzYpKVxufVxuIiwiLyohXG4gKiBjaGFuZ2VzZXRzXG4gKiBBIENoYW5nZXNldCBsaWJyYXJ5IGluY29ycG9yYXRpbmcgb3BlcmF0aW9uYWwgdHJhbnNmb3JtYXRpb24gKE9UKVxuICogQ29weXJpZ2h0IDIwMTIgYnkgTWFyY2VsIEtsZWhyIDxta2xlaHJAZ214Lm5ldD5cbiAqXG4gKiAoTUlUIExJQ0VOU0UpXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbnZhciBPcGVyYXRvciA9IHJlcXVpcmUoJy4uL09wZXJhdG9yJylcblxuLyoqXG4gKiBTa2lwIE9wZXJhdG9yXG4gKiBEZWZpbmVkIGJ5OlxuICogLSBsZW5ndGhcbiAqIC0gaW5wdXQ9bGVuZ3RoXG4gKiAtIG91dHB1dD0wXG4gKlxuICogQHBhcmFtIGxlbmd0aCA8TnVtYmVyPiBIb3cgbWFueSBjaGFycyB0byBiZSBTa2lwXG4gKi9cbmZ1bmN0aW9uIFNraXAobGVuZ3RoKSB7XG4gIHRoaXMubGVuZ3RoID0gbGVuZ3RoXG4gIHRoaXMuaW5wdXQgPSBsZW5ndGhcbiAgdGhpcy5vdXRwdXQgPSAwXG59XG5cbi8vIFRydWUgaW5oZXJpdGFuY2VcblNraXAucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShPcGVyYXRvci5wcm90b3R5cGUsIHtcbiAgY29uc3RydWN0b3I6IHtcbiAgICB2YWx1ZTogU2tpcCxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IFNraXBcblNraXAucHJvdG90eXBlLnN5bWJvbCA9ICctJ1xuXG52YXIgSW5zZXJ0ID0gcmVxdWlyZSgnLi9JbnNlcnQnKVxuICAsIFJldGFpbiA9IHJlcXVpcmUoJy4vUmV0YWluJylcbiAgLCBDaGFuZ2VzZXQgPSByZXF1aXJlKCcuLi9DaGFuZ2VzZXQnKVxuXG5Ta2lwLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKHQpIHtcbiAgdmFyIGlucHV0ID0gdC5yZWFkSW5wdXQodGhpcy5pbnB1dClcbiAgdC53cml0ZVJlbW92ZW5kdW0oaW5wdXQpXG4gIHQud3JpdGVPdXRwdXQodC5zdWJyYW5nZShpbnB1dCwgMCwgdGhpcy5vdXRwdXQpKSAvLyByZXRhaW4gSW5zZXJ0cyBpbiBteSByYW5nZVxufVxuXG5Ta2lwLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uKG9wMikge1xuICByZXR1cm4gdGhpc1xufVxuXG5Ta2lwLnByb3RvdHlwZS5pbnZlcnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBJbnNlcnQodGhpcy5sZW5ndGgpXG59XG5cblNraXAudW5wYWNrID0gZnVuY3Rpb24oZGF0YSkge1xuICByZXR1cm4gbmV3IFNraXAocGFyc2VJbnQoZGF0YSwgMzYpKVxufVxuIiwiLyoqXG4gKiBEaWZmIE1hdGNoIGFuZCBQYXRjaFxuICpcbiAqIENvcHlyaWdodCAyMDA2IEdvb2dsZSBJbmMuXG4gKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvZ29vZ2xlLWRpZmYtbWF0Y2gtcGF0Y2gvXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ29tcHV0ZXMgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0d28gdGV4dHMgdG8gY3JlYXRlIGEgcGF0Y2guXG4gKiBBcHBsaWVzIHRoZSBwYXRjaCBvbnRvIGFub3RoZXIgdGV4dCwgYWxsb3dpbmcgZm9yIGVycm9ycy5cbiAqIEBhdXRob3IgZnJhc2VyQGdvb2dsZS5jb20gKE5laWwgRnJhc2VyKVxuICovXG5cbi8qKlxuICogQ2xhc3MgY29udGFpbmluZyB0aGUgZGlmZiwgbWF0Y2ggYW5kIHBhdGNoIG1ldGhvZHMuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gZGlmZl9tYXRjaF9wYXRjaCgpIHtcblxuICAvLyBEZWZhdWx0cy5cbiAgLy8gUmVkZWZpbmUgdGhlc2UgaW4geW91ciBwcm9ncmFtIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0cy5cblxuICAvLyBOdW1iZXIgb2Ygc2Vjb25kcyB0byBtYXAgYSBkaWZmIGJlZm9yZSBnaXZpbmcgdXAgKDAgZm9yIGluZmluaXR5KS5cbiAgdGhpcy5EaWZmX1RpbWVvdXQgPSAxLjA7XG4gIC8vIENvc3Qgb2YgYW4gZW1wdHkgZWRpdCBvcGVyYXRpb24gaW4gdGVybXMgb2YgZWRpdCBjaGFyYWN0ZXJzLlxuICB0aGlzLkRpZmZfRWRpdENvc3QgPSA0O1xuICAvLyBUaGUgc2l6ZSBiZXlvbmQgd2hpY2ggdGhlIGRvdWJsZS1lbmRlZCBkaWZmIGFjdGl2YXRlcy5cbiAgLy8gRG91YmxlLWVuZGluZyBpcyB0d2ljZSBhcyBmYXN0LCBidXQgbGVzcyBhY2N1cmF0ZS5cbiAgdGhpcy5EaWZmX0R1YWxUaHJlc2hvbGQgPSAzMjtcbiAgLy8gQXQgd2hhdCBwb2ludCBpcyBubyBtYXRjaCBkZWNsYXJlZCAoMC4wID0gcGVyZmVjdGlvbiwgMS4wID0gdmVyeSBsb29zZSkuXG4gIHRoaXMuTWF0Y2hfVGhyZXNob2xkID0gMC41O1xuICAvLyBIb3cgZmFyIHRvIHNlYXJjaCBmb3IgYSBtYXRjaCAoMCA9IGV4YWN0IGxvY2F0aW9uLCAxMDAwKyA9IGJyb2FkIG1hdGNoKS5cbiAgLy8gQSBtYXRjaCB0aGlzIG1hbnkgY2hhcmFjdGVycyBhd2F5IGZyb20gdGhlIGV4cGVjdGVkIGxvY2F0aW9uIHdpbGwgYWRkXG4gIC8vIDEuMCB0byB0aGUgc2NvcmUgKDAuMCBpcyBhIHBlcmZlY3QgbWF0Y2gpLlxuICB0aGlzLk1hdGNoX0Rpc3RhbmNlID0gMTAwMDtcbiAgLy8gV2hlbiBkZWxldGluZyBhIGxhcmdlIGJsb2NrIG9mIHRleHQgKG92ZXIgfjY0IGNoYXJhY3RlcnMpLCBob3cgY2xvc2UgZG9lc1xuICAvLyB0aGUgY29udGVudHMgaGF2ZSB0byBtYXRjaCB0aGUgZXhwZWN0ZWQgY29udGVudHMuICgwLjAgPSBwZXJmZWN0aW9uLFxuICAvLyAxLjAgPSB2ZXJ5IGxvb3NlKS4gIE5vdGUgdGhhdCBNYXRjaF9UaHJlc2hvbGQgY29udHJvbHMgaG93IGNsb3NlbHkgdGhlXG4gIC8vIGVuZCBwb2ludHMgb2YgYSBkZWxldGUgbmVlZCB0byBtYXRjaC5cbiAgdGhpcy5QYXRjaF9EZWxldGVUaHJlc2hvbGQgPSAwLjU7XG4gIC8vIENodW5rIHNpemUgZm9yIGNvbnRleHQgbGVuZ3RoLlxuICB0aGlzLlBhdGNoX01hcmdpbiA9IDQ7XG5cbiAgLyoqXG4gICAqIENvbXB1dGUgdGhlIG51bWJlciBvZiBiaXRzIGluIGFuIGludC5cbiAgICogVGhlIG5vcm1hbCBhbnN3ZXIgZm9yIEphdmFTY3JpcHQgaXMgMzIuXG4gICAqIEByZXR1cm4ge251bWJlcn0gTWF4IGJpdHNcbiAgICovXG4gIGZ1bmN0aW9uIGdldE1heEJpdHMoKSB7XG4gICAgdmFyIG1heGJpdHMgPSAwO1xuICAgIHZhciBvbGRpID0gMTtcbiAgICB2YXIgbmV3aSA9IDI7XG4gICAgd2hpbGUgKG9sZGkgIT0gbmV3aSkge1xuICAgICAgbWF4Yml0cysrO1xuICAgICAgb2xkaSA9IG5ld2k7XG4gICAgICBuZXdpID0gbmV3aSA8PCAxO1xuICAgIH1cbiAgICByZXR1cm4gbWF4Yml0cztcbiAgfVxuICAvLyBIb3cgbWFueSBiaXRzIGluIGEgbnVtYmVyP1xuICB0aGlzLk1hdGNoX01heEJpdHMgPSBnZXRNYXhCaXRzKCk7XG59XG5cblxuLy8gIERJRkYgRlVOQ1RJT05TXG5cblxuLyoqXG4gKiBUaGUgZGF0YSBzdHJ1Y3R1cmUgcmVwcmVzZW50aW5nIGEgZGlmZiBpcyBhbiBhcnJheSBvZiB0dXBsZXM6XG4gKiBbW0RJRkZfREVMRVRFLCAnSGVsbG8nXSwgW0RJRkZfSU5TRVJULCAnR29vZGJ5ZSddLCBbRElGRl9FUVVBTCwgJyB3b3JsZC4nXV1cbiAqIHdoaWNoIG1lYW5zOiBkZWxldGUgJ0hlbGxvJywgYWRkICdHb29kYnllJyBhbmQga2VlcCAnIHdvcmxkLidcbiAqL1xudmFyIERJRkZfREVMRVRFID0gLTE7XG52YXIgRElGRl9JTlNFUlQgPSAxO1xudmFyIERJRkZfRVFVQUwgPSAwO1xuXG5cbi8qKlxuICogRmluZCB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiB0d28gdGV4dHMuICBTaW1wbGlmaWVzIHRoZSBwcm9ibGVtIGJ5IHN0cmlwcGluZ1xuICogYW55IGNvbW1vbiBwcmVmaXggb3Igc3VmZml4IG9mZiB0aGUgdGV4dHMgYmVmb3JlIGRpZmZpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgT2xkIHN0cmluZyB0byBiZSBkaWZmZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgTmV3IHN0cmluZyB0byBiZSBkaWZmZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdF9jaGVja2xpbmVzIE9wdGlvbmFsIHNwZWVkdXAgZmxhZy4gIElmIHByZXNlbnQgYW5kIGZhbHNlLFxuICogICAgIHRoZW4gZG9uJ3QgcnVuIGEgbGluZS1sZXZlbCBkaWZmIGZpcnN0IHRvIGlkZW50aWZ5IHRoZSBjaGFuZ2VkIGFyZWFzLlxuICogICAgIERlZmF1bHRzIHRvIHRydWUsIHdoaWNoIGRvZXMgYSBmYXN0ZXIsIHNsaWdodGx5IGxlc3Mgb3B0aW1hbCBkaWZmXG4gKiBAcmV0dXJuIHtBcnJheS48QXJyYXkuPG51bWJlcnxzdHJpbmc+Pn0gQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfbWFpbiA9IGZ1bmN0aW9uKHRleHQxLCB0ZXh0Miwgb3B0X2NoZWNrbGluZXMpIHtcbiAgLy8gQ2hlY2sgZm9yIG51bGwgaW5wdXRzLlxuICBpZiAodGV4dDEgPT0gbnVsbCB8fCB0ZXh0MiA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOdWxsIGlucHV0LiAoZGlmZl9tYWluKScpO1xuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIGVxdWFsaXR5IChzcGVlZHVwKS5cbiAgaWYgKHRleHQxID09IHRleHQyKSB7XG4gICAgcmV0dXJuIFtbRElGRl9FUVVBTCwgdGV4dDFdXTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0X2NoZWNrbGluZXMgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBvcHRfY2hlY2tsaW5lcyA9IHRydWU7XG4gIH1cbiAgdmFyIGNoZWNrbGluZXMgPSBvcHRfY2hlY2tsaW5lcztcblxuICAvLyBUcmltIG9mZiBjb21tb24gcHJlZml4IChzcGVlZHVwKS5cbiAgdmFyIGNvbW1vbmxlbmd0aCA9IHRoaXMuZGlmZl9jb21tb25QcmVmaXgodGV4dDEsIHRleHQyKTtcbiAgdmFyIGNvbW1vbnByZWZpeCA9IHRleHQxLnN1YnN0cmluZygwLCBjb21tb25sZW5ndGgpO1xuICB0ZXh0MSA9IHRleHQxLnN1YnN0cmluZyhjb21tb25sZW5ndGgpO1xuICB0ZXh0MiA9IHRleHQyLnN1YnN0cmluZyhjb21tb25sZW5ndGgpO1xuXG4gIC8vIFRyaW0gb2ZmIGNvbW1vbiBzdWZmaXggKHNwZWVkdXApLlxuICBjb21tb25sZW5ndGggPSB0aGlzLmRpZmZfY29tbW9uU3VmZml4KHRleHQxLCB0ZXh0Mik7XG4gIHZhciBjb21tb25zdWZmaXggPSB0ZXh0MS5zdWJzdHJpbmcodGV4dDEubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcbiAgdGV4dDEgPSB0ZXh0MS5zdWJzdHJpbmcoMCwgdGV4dDEubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcbiAgdGV4dDIgPSB0ZXh0Mi5zdWJzdHJpbmcoMCwgdGV4dDIubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcblxuICAvLyBDb21wdXRlIHRoZSBkaWZmIG9uIHRoZSBtaWRkbGUgYmxvY2suXG4gIHZhciBkaWZmcyA9IHRoaXMuZGlmZl9jb21wdXRlKHRleHQxLCB0ZXh0MiwgY2hlY2tsaW5lcyk7XG5cbiAgLy8gUmVzdG9yZSB0aGUgcHJlZml4IGFuZCBzdWZmaXguXG4gIGlmIChjb21tb25wcmVmaXgpIHtcbiAgICBkaWZmcy51bnNoaWZ0KFtESUZGX0VRVUFMLCBjb21tb25wcmVmaXhdKTtcbiAgfVxuICBpZiAoY29tbW9uc3VmZml4KSB7XG4gICAgZGlmZnMucHVzaChbRElGRl9FUVVBTCwgY29tbW9uc3VmZml4XSk7XG4gIH1cbiAgdGhpcy5kaWZmX2NsZWFudXBNZXJnZShkaWZmcyk7XG4gIHJldHVybiBkaWZmcztcbn07XG5cblxuLyoqXG4gKiBGaW5kIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHR3byB0ZXh0cy4gIEFzc3VtZXMgdGhhdCB0aGUgdGV4dHMgZG8gbm90XG4gKiBoYXZlIGFueSBjb21tb24gcHJlZml4IG9yIHN1ZmZpeC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBPbGQgc3RyaW5nIHRvIGJlIGRpZmZlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBOZXcgc3RyaW5nIHRvIGJlIGRpZmZlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY2hlY2tsaW5lcyBTcGVlZHVwIGZsYWcuICBJZiBmYWxzZSwgdGhlbiBkb24ndCBydW4gYVxuICogICAgIGxpbmUtbGV2ZWwgZGlmZiBmaXJzdCB0byBpZGVudGlmeSB0aGUgY2hhbmdlZCBhcmVhcy5cbiAqICAgICBJZiB0cnVlLCB0aGVuIHJ1biBhIGZhc3Rlciwgc2xpZ2h0bHkgbGVzcyBvcHRpbWFsIGRpZmZcbiAqIEByZXR1cm4ge0FycmF5LjxBcnJheS48bnVtYmVyfHN0cmluZz4+fSBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqIEBwcml2YXRlXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfY29tcHV0ZSA9IGZ1bmN0aW9uKHRleHQxLCB0ZXh0MiwgY2hlY2tsaW5lcykge1xuICB2YXIgZGlmZnM7XG5cbiAgaWYgKCF0ZXh0MSkge1xuICAgIC8vIEp1c3QgYWRkIHNvbWUgdGV4dCAoc3BlZWR1cCkuXG4gICAgcmV0dXJuIFtbRElGRl9JTlNFUlQsIHRleHQyXV07XG4gIH1cblxuICBpZiAoIXRleHQyKSB7XG4gICAgLy8gSnVzdCBkZWxldGUgc29tZSB0ZXh0IChzcGVlZHVwKS5cbiAgICByZXR1cm4gW1tESUZGX0RFTEVURSwgdGV4dDFdXTtcbiAgfVxuXG4gIHZhciBsb25ndGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQxIDogdGV4dDI7XG4gIHZhciBzaG9ydHRleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MiA6IHRleHQxO1xuICB2YXIgaSA9IGxvbmd0ZXh0LmluZGV4T2Yoc2hvcnR0ZXh0KTtcbiAgaWYgKGkgIT0gLTEpIHtcbiAgICAvLyBTaG9ydGVyIHRleHQgaXMgaW5zaWRlIHRoZSBsb25nZXIgdGV4dCAoc3BlZWR1cCkuXG4gICAgZGlmZnMgPSBbW0RJRkZfSU5TRVJULCBsb25ndGV4dC5zdWJzdHJpbmcoMCwgaSldLFxuICAgICAgICAgICAgIFtESUZGX0VRVUFMLCBzaG9ydHRleHRdLFxuICAgICAgICAgICAgIFtESUZGX0lOU0VSVCwgbG9uZ3RleHQuc3Vic3RyaW5nKGkgKyBzaG9ydHRleHQubGVuZ3RoKV1dO1xuICAgIC8vIFN3YXAgaW5zZXJ0aW9ucyBmb3IgZGVsZXRpb25zIGlmIGRpZmYgaXMgcmV2ZXJzZWQuXG4gICAgaWYgKHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCkge1xuICAgICAgZGlmZnNbMF1bMF0gPSBkaWZmc1syXVswXSA9IERJRkZfREVMRVRFO1xuICAgIH1cbiAgICByZXR1cm4gZGlmZnM7XG4gIH1cbiAgbG9uZ3RleHQgPSBzaG9ydHRleHQgPSBudWxsOyAgLy8gR2FyYmFnZSBjb2xsZWN0LlxuXG4gIC8vIENoZWNrIHRvIHNlZSBpZiB0aGUgcHJvYmxlbSBjYW4gYmUgc3BsaXQgaW4gdHdvLlxuICB2YXIgaG0gPSB0aGlzLmRpZmZfaGFsZk1hdGNoKHRleHQxLCB0ZXh0Mik7XG4gIGlmIChobSkge1xuICAgIC8vIEEgaGFsZi1tYXRjaCB3YXMgZm91bmQsIHNvcnQgb3V0IHRoZSByZXR1cm4gZGF0YS5cbiAgICB2YXIgdGV4dDFfYSA9IGhtWzBdO1xuICAgIHZhciB0ZXh0MV9iID0gaG1bMV07XG4gICAgdmFyIHRleHQyX2EgPSBobVsyXTtcbiAgICB2YXIgdGV4dDJfYiA9IGhtWzNdO1xuICAgIHZhciBtaWRfY29tbW9uID0gaG1bNF07XG4gICAgLy8gU2VuZCBib3RoIHBhaXJzIG9mZiBmb3Igc2VwYXJhdGUgcHJvY2Vzc2luZy5cbiAgICB2YXIgZGlmZnNfYSA9IHRoaXMuZGlmZl9tYWluKHRleHQxX2EsIHRleHQyX2EsIGNoZWNrbGluZXMpO1xuICAgIHZhciBkaWZmc19iID0gdGhpcy5kaWZmX21haW4odGV4dDFfYiwgdGV4dDJfYiwgY2hlY2tsaW5lcyk7XG4gICAgLy8gTWVyZ2UgdGhlIHJlc3VsdHMuXG4gICAgcmV0dXJuIGRpZmZzX2EuY29uY2F0KFtbRElGRl9FUVVBTCwgbWlkX2NvbW1vbl1dLCBkaWZmc19iKTtcbiAgfVxuXG4gIC8vIFBlcmZvcm0gYSByZWFsIGRpZmYuXG4gIGlmIChjaGVja2xpbmVzICYmICh0ZXh0MS5sZW5ndGggPCAxMDAgfHwgdGV4dDIubGVuZ3RoIDwgMTAwKSkge1xuICAgIC8vIFRvbyB0cml2aWFsIGZvciB0aGUgb3ZlcmhlYWQuXG4gICAgY2hlY2tsaW5lcyA9IGZhbHNlO1xuICB9XG4gIHZhciBsaW5lYXJyYXk7XG4gIGlmIChjaGVja2xpbmVzKSB7XG4gICAgLy8gU2NhbiB0aGUgdGV4dCBvbiBhIGxpbmUtYnktbGluZSBiYXNpcyBmaXJzdC5cbiAgICB2YXIgYSA9IHRoaXMuZGlmZl9saW5lc1RvQ2hhcnModGV4dDEsIHRleHQyKTtcbiAgICB0ZXh0MSA9IGFbMF07XG4gICAgdGV4dDIgPSBhWzFdO1xuICAgIGxpbmVhcnJheSA9IGFbMl07XG4gIH1cbiAgZGlmZnMgPSB0aGlzLmRpZmZfbWFwKHRleHQxLCB0ZXh0Mik7XG4gIGlmICghZGlmZnMpIHtcbiAgICAvLyBObyBhY2NlcHRhYmxlIHJlc3VsdC5cbiAgICBkaWZmcyA9IFtbRElGRl9ERUxFVEUsIHRleHQxXSwgW0RJRkZfSU5TRVJULCB0ZXh0Ml1dO1xuICB9XG4gIGlmIChjaGVja2xpbmVzKSB7XG4gICAgLy8gQ29udmVydCB0aGUgZGlmZiBiYWNrIHRvIG9yaWdpbmFsIHRleHQuXG4gICAgdGhpcy5kaWZmX2NoYXJzVG9MaW5lcyhkaWZmcywgbGluZWFycmF5KTtcbiAgICAvLyBFbGltaW5hdGUgZnJlYWsgbWF0Y2hlcyAoZS5nLiBibGFuayBsaW5lcylcbiAgICB0aGlzLmRpZmZfY2xlYW51cFNlbWFudGljKGRpZmZzKTtcblxuICAgIC8vIFJlZGlmZiBhbnkgcmVwbGFjZW1lbnQgYmxvY2tzLCB0aGlzIHRpbWUgY2hhcmFjdGVyLWJ5LWNoYXJhY3Rlci5cbiAgICAvLyBBZGQgYSBkdW1teSBlbnRyeSBhdCB0aGUgZW5kLlxuICAgIGRpZmZzLnB1c2goW0RJRkZfRVFVQUwsICcnXSk7XG4gICAgdmFyIHBvaW50ZXIgPSAwO1xuICAgIHZhciBjb3VudF9kZWxldGUgPSAwO1xuICAgIHZhciBjb3VudF9pbnNlcnQgPSAwO1xuICAgIHZhciB0ZXh0X2RlbGV0ZSA9ICcnO1xuICAgIHZhciB0ZXh0X2luc2VydCA9ICcnO1xuICAgIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoKSB7XG4gICAgICBzd2l0Y2ggKGRpZmZzW3BvaW50ZXJdWzBdKSB7XG4gICAgICAgIGNhc2UgRElGRl9JTlNFUlQ6XG4gICAgICAgICAgY291bnRfaW5zZXJ0Kys7XG4gICAgICAgICAgdGV4dF9pbnNlcnQgKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRElGRl9ERUxFVEU6XG4gICAgICAgICAgY291bnRfZGVsZXRlKys7XG4gICAgICAgICAgdGV4dF9kZWxldGUgKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRElGRl9FUVVBTDpcbiAgICAgICAgICAvLyBVcG9uIHJlYWNoaW5nIGFuIGVxdWFsaXR5LCBjaGVjayBmb3IgcHJpb3IgcmVkdW5kYW5jaWVzLlxuICAgICAgICAgIGlmIChjb3VudF9kZWxldGUgPj0gMSAmJiBjb3VudF9pbnNlcnQgPj0gMSkge1xuICAgICAgICAgICAgLy8gRGVsZXRlIHRoZSBvZmZlbmRpbmcgcmVjb3JkcyBhbmQgYWRkIHRoZSBtZXJnZWQgb25lcy5cbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5kaWZmX21haW4odGV4dF9kZWxldGUsIHRleHRfaW5zZXJ0LCBmYWxzZSk7XG4gICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudF9kZWxldGUgKyBjb3VudF9pbnNlcnQpO1xuICAgICAgICAgICAgcG9pbnRlciA9IHBvaW50ZXIgLSBjb3VudF9kZWxldGUgLSBjb3VudF9pbnNlcnQ7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gYS5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciwgMCwgYVtqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2ludGVyID0gcG9pbnRlciArIGEubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb3VudF9pbnNlcnQgPSAwO1xuICAgICAgICAgIGNvdW50X2RlbGV0ZSA9IDA7XG4gICAgICAgICAgdGV4dF9kZWxldGUgPSAnJztcbiAgICAgICAgICB0ZXh0X2luc2VydCA9ICcnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICBwb2ludGVyKys7XG4gICAgfVxuICAgIGRpZmZzLnBvcCgpOyAgLy8gUmVtb3ZlIHRoZSBkdW1teSBlbnRyeSBhdCB0aGUgZW5kLlxuICB9XG4gIHJldHVybiBkaWZmcztcbn07XG5cblxuLyoqXG4gKiBTcGxpdCB0d28gdGV4dHMgaW50byBhbiBhcnJheSBvZiBzdHJpbmdzLiAgUmVkdWNlIHRoZSB0ZXh0cyB0byBhIHN0cmluZyBvZlxuICogaGFzaGVzIHdoZXJlIGVhY2ggVW5pY29kZSBjaGFyYWN0ZXIgcmVwcmVzZW50cyBvbmUgbGluZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBGaXJzdCBzdHJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgU2Vjb25kIHN0cmluZy5cbiAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmd8QXJyYXkuPHN0cmluZz4+fSBUaHJlZSBlbGVtZW50IEFycmF5LCBjb250YWluaW5nIHRoZVxuICogICAgIGVuY29kZWQgdGV4dDEsIHRoZSBlbmNvZGVkIHRleHQyIGFuZCB0aGUgYXJyYXkgb2YgdW5pcXVlIHN0cmluZ3MuICBUaGVcbiAqICAgICB6ZXJvdGggZWxlbWVudCBvZiB0aGUgYXJyYXkgb2YgdW5pcXVlIHN0cmluZ3MgaXMgaW50ZW50aW9uYWxseSBibGFuay5cbiAqIEBwcml2YXRlXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfbGluZXNUb0NoYXJzID0gZnVuY3Rpb24odGV4dDEsIHRleHQyKSB7XG4gIHZhciBsaW5lQXJyYXkgPSBbXTsgIC8vIGUuZy4gbGluZUFycmF5WzRdID09ICdIZWxsb1xcbidcbiAgdmFyIGxpbmVIYXNoID0ge307ICAgLy8gZS5nLiBsaW5lSGFzaFsnSGVsbG9cXG4nXSA9PSA0XG5cbiAgLy8gJ1xceDAwJyBpcyBhIHZhbGlkIGNoYXJhY3RlciwgYnV0IHZhcmlvdXMgZGVidWdnZXJzIGRvbid0IGxpa2UgaXQuXG4gIC8vIFNvIHdlJ2xsIGluc2VydCBhIGp1bmsgZW50cnkgdG8gYXZvaWQgZ2VuZXJhdGluZyBhIG51bGwgY2hhcmFjdGVyLlxuICBsaW5lQXJyYXlbMF0gPSAnJztcblxuICAvKipcbiAgICogU3BsaXQgYSB0ZXh0IGludG8gYW4gYXJyYXkgb2Ygc3RyaW5ncy4gIFJlZHVjZSB0aGUgdGV4dHMgdG8gYSBzdHJpbmcgb2ZcbiAgICogaGFzaGVzIHdoZXJlIGVhY2ggVW5pY29kZSBjaGFyYWN0ZXIgcmVwcmVzZW50cyBvbmUgbGluZS5cbiAgICogTW9kaWZpZXMgbGluZWFycmF5IGFuZCBsaW5laGFzaCB0aHJvdWdoIGJlaW5nIGEgY2xvc3VyZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgU3RyaW5nIHRvIGVuY29kZS5cbiAgICogQHJldHVybiB7c3RyaW5nfSBFbmNvZGVkIHN0cmluZy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGRpZmZfbGluZXNUb0NoYXJzTXVuZ2UodGV4dCkge1xuICAgIHZhciBjaGFycyA9ICcnO1xuICAgIC8vIFdhbGsgdGhlIHRleHQsIHB1bGxpbmcgb3V0IGEgc3Vic3RyaW5nIGZvciBlYWNoIGxpbmUuXG4gICAgLy8gdGV4dC5zcGxpdCgnXFxuJykgd291bGQgd291bGQgdGVtcG9yYXJpbHkgZG91YmxlIG91ciBtZW1vcnkgZm9vdHByaW50LlxuICAgIC8vIE1vZGlmeWluZyB0ZXh0IHdvdWxkIGNyZWF0ZSBtYW55IGxhcmdlIHN0cmluZ3MgdG8gZ2FyYmFnZSBjb2xsZWN0LlxuICAgIHZhciBsaW5lU3RhcnQgPSAwO1xuICAgIHZhciBsaW5lRW5kID0gLTE7XG4gICAgLy8gS2VlcGluZyBvdXIgb3duIGxlbmd0aCB2YXJpYWJsZSBpcyBmYXN0ZXIgdGhhbiBsb29raW5nIGl0IHVwLlxuICAgIHZhciBsaW5lQXJyYXlMZW5ndGggPSBsaW5lQXJyYXkubGVuZ3RoO1xuICAgIHdoaWxlIChsaW5lRW5kIDwgdGV4dC5sZW5ndGggLSAxKSB7XG4gICAgICBsaW5lRW5kID0gdGV4dC5pbmRleE9mKCdcXG4nLCBsaW5lU3RhcnQpO1xuICAgICAgaWYgKGxpbmVFbmQgPT0gLTEpIHtcbiAgICAgICAgbGluZUVuZCA9IHRleHQubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICAgIHZhciBsaW5lID0gdGV4dC5zdWJzdHJpbmcobGluZVN0YXJ0LCBsaW5lRW5kICsgMSk7XG4gICAgICBsaW5lU3RhcnQgPSBsaW5lRW5kICsgMTtcblxuICAgICAgaWYgKGxpbmVIYXNoLmhhc093blByb3BlcnR5ID8gbGluZUhhc2guaGFzT3duUHJvcGVydHkobGluZSkgOlxuICAgICAgICAgIChsaW5lSGFzaFtsaW5lXSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBjaGFycyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxpbmVIYXNoW2xpbmVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoYXJzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGluZUFycmF5TGVuZ3RoKTtcbiAgICAgICAgbGluZUhhc2hbbGluZV0gPSBsaW5lQXJyYXlMZW5ndGg7XG4gICAgICAgIGxpbmVBcnJheVtsaW5lQXJyYXlMZW5ndGgrK10gPSBsaW5lO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hhcnM7XG4gIH1cblxuICB2YXIgY2hhcnMxID0gZGlmZl9saW5lc1RvQ2hhcnNNdW5nZSh0ZXh0MSk7XG4gIHZhciBjaGFyczIgPSBkaWZmX2xpbmVzVG9DaGFyc011bmdlKHRleHQyKTtcbiAgcmV0dXJuIFtjaGFyczEsIGNoYXJzMiwgbGluZUFycmF5XTtcbn07XG5cblxuLyoqXG4gKiBSZWh5ZHJhdGUgdGhlIHRleHQgaW4gYSBkaWZmIGZyb20gYSBzdHJpbmcgb2YgbGluZSBoYXNoZXMgdG8gcmVhbCBsaW5lcyBvZlxuICogdGV4dC5cbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXJ8c3RyaW5nPj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gbGluZUFycmF5IEFycmF5IG9mIHVuaXF1ZSBzdHJpbmdzLlxuICogQHByaXZhdGVcbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jaGFyc1RvTGluZXMgPSBmdW5jdGlvbihkaWZmcywgbGluZUFycmF5KSB7XG4gIGZvciAodmFyIHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICB2YXIgY2hhcnMgPSBkaWZmc1t4XVsxXTtcbiAgICB2YXIgdGV4dCA9IFtdO1xuICAgIGZvciAodmFyIHkgPSAwOyB5IDwgY2hhcnMubGVuZ3RoOyB5KyspIHtcbiAgICAgIHRleHRbeV0gPSBsaW5lQXJyYXlbY2hhcnMuY2hhckNvZGVBdCh5KV07XG4gICAgfVxuICAgIGRpZmZzW3hdWzFdID0gdGV4dC5qb2luKCcnKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEV4cGxvcmUgdGhlIGludGVyc2VjdGlvbiBwb2ludHMgYmV0d2VlbiB0aGUgdHdvIHRleHRzLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIE9sZCBzdHJpbmcgdG8gYmUgZGlmZmVkLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIE5ldyBzdHJpbmcgdG8gYmUgZGlmZmVkLlxuICogQHJldHVybiB7P0FycmF5LjxBcnJheS48bnVtYmVyfHN0cmluZz4+fSBBcnJheSBvZiBkaWZmIHR1cGxlcyBvciBudWxsIGlmIG5vXG4gKiAgICAgZGlmZiBhdmFpbGFibGUuXG4gKiBAcHJpdmF0ZVxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX21hcCA9IGZ1bmN0aW9uKHRleHQxLCB0ZXh0Mikge1xuICAvLyBEb24ndCBydW4gZm9yIHRvbyBsb25nLlxuICB2YXIgbXNfZW5kID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSArIHRoaXMuRGlmZl9UaW1lb3V0ICogMTAwMDtcbiAgLy8gQ2FjaGUgdGhlIHRleHQgbGVuZ3RocyB0byBwcmV2ZW50IG11bHRpcGxlIGNhbGxzLlxuICB2YXIgdGV4dDFfbGVuZ3RoID0gdGV4dDEubGVuZ3RoO1xuICB2YXIgdGV4dDJfbGVuZ3RoID0gdGV4dDIubGVuZ3RoO1xuICB2YXIgbWF4X2QgPSB0ZXh0MV9sZW5ndGggKyB0ZXh0Ml9sZW5ndGggLSAxO1xuICB2YXIgZG91YmxlRW5kID0gdGhpcy5EaWZmX0R1YWxUaHJlc2hvbGQgKiAyIDwgbWF4X2Q7XG4gIC8vIEphdmFTY3JpcHQgZWZmaWNpZW5jeSBub3RlOiAoeCA8PCAzMikgKyB5IGRvZXNuJ3Qgd29yayBzaW5jZSBudW1iZXJzIGFyZVxuICAvLyBvbmx5IDMyIGJpdC4gIFVzZSB4ICsgJywnICsgeSB0byBjcmVhdGUgYSBoYXNoIGluc3RlYWQuXG4gIHZhciB2X21hcDEgPSBbXTtcbiAgdmFyIHZfbWFwMiA9IFtdO1xuICB2YXIgdjEgPSB7fTtcbiAgdmFyIHYyID0ge307XG4gIHYxWzFdID0gMDtcbiAgdjJbMV0gPSAwO1xuICB2YXIgeCwgeTtcbiAgdmFyIGZvb3RzdGVwOyAgLy8gVXNlZCB0byB0cmFjayBvdmVybGFwcGluZyBwYXRocy5cbiAgdmFyIGZvb3RzdGVwcyA9IHt9O1xuICB2YXIgZG9uZSA9IGZhbHNlO1xuICAvLyBJZiB0aGUgdG90YWwgbnVtYmVyIG9mIGNoYXJhY3RlcnMgaXMgb2RkLCB0aGVuIHRoZSBmcm9udCBwYXRoIHdpbGwgY29sbGlkZVxuICAvLyB3aXRoIHRoZSByZXZlcnNlIHBhdGguXG4gIHZhciBmcm9udCA9ICh0ZXh0MV9sZW5ndGggKyB0ZXh0Ml9sZW5ndGgpICUgMjtcbiAgZm9yICh2YXIgZCA9IDA7IGQgPCBtYXhfZDsgZCsrKSB7XG4gICAgLy8gQmFpbCBvdXQgaWYgdGltZW91dCByZWFjaGVkLlxuICAgIGlmICh0aGlzLkRpZmZfVGltZW91dCA+IDAgJiYgKG5ldyBEYXRlKCkpLmdldFRpbWUoKSA+IG1zX2VuZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gV2FsayB0aGUgZnJvbnQgcGF0aCBvbmUgc3RlcC5cbiAgICB2X21hcDFbZF0gPSB7fTtcbiAgICBmb3IgKHZhciBrID0gLWQ7IGsgPD0gZDsgayArPSAyKSB7XG4gICAgICBpZiAoayA9PSAtZCB8fCBrICE9IGQgJiYgdjFbayAtIDFdIDwgdjFbayArIDFdKSB7XG4gICAgICAgIHggPSB2MVtrICsgMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gdjFbayAtIDFdICsgMTtcbiAgICAgIH1cbiAgICAgIHkgPSB4IC0gaztcbiAgICAgIGlmIChkb3VibGVFbmQpIHtcbiAgICAgICAgZm9vdHN0ZXAgPSB4ICsgJywnICsgeTtcbiAgICAgICAgaWYgKGZyb250ICYmIGZvb3RzdGVwc1tmb290c3RlcF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZnJvbnQpIHtcbiAgICAgICAgICBmb290c3RlcHNbZm9vdHN0ZXBdID0gZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKCFkb25lICYmIHggPCB0ZXh0MV9sZW5ndGggJiYgeSA8IHRleHQyX2xlbmd0aCAmJlxuICAgICAgICAgICAgIHRleHQxLmNoYXJBdCh4KSA9PSB0ZXh0Mi5jaGFyQXQoeSkpIHtcbiAgICAgICAgeCsrO1xuICAgICAgICB5Kys7XG4gICAgICAgIGlmIChkb3VibGVFbmQpIHtcbiAgICAgICAgICBmb290c3RlcCA9IHggKyAnLCcgKyB5O1xuICAgICAgICAgIGlmIChmcm9udCAmJiBmb290c3RlcHNbZm9vdHN0ZXBdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWZyb250KSB7XG4gICAgICAgICAgICBmb290c3RlcHNbZm9vdHN0ZXBdID0gZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHYxW2tdID0geDtcbiAgICAgIHZfbWFwMVtkXVt4ICsgJywnICsgeV0gPSB0cnVlO1xuICAgICAgaWYgKHggPT0gdGV4dDFfbGVuZ3RoICYmIHkgPT0gdGV4dDJfbGVuZ3RoKSB7XG4gICAgICAgIC8vIFJlYWNoZWQgdGhlIGVuZCBpbiBzaW5nbGUtcGF0aCBtb2RlLlxuICAgICAgICByZXR1cm4gdGhpcy5kaWZmX3BhdGgxKHZfbWFwMSwgdGV4dDEsIHRleHQyKTtcbiAgICAgIH0gZWxzZSBpZiAoZG9uZSkge1xuICAgICAgICAvLyBGcm9udCBwYXRoIHJhbiBvdmVyIHJldmVyc2UgcGF0aC5cbiAgICAgICAgdl9tYXAyID0gdl9tYXAyLnNsaWNlKDAsIGZvb3RzdGVwc1tmb290c3RlcF0gKyAxKTtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmRpZmZfcGF0aDEodl9tYXAxLCB0ZXh0MS5zdWJzdHJpbmcoMCwgeCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQyLnN1YnN0cmluZygwLCB5KSk7XG4gICAgICAgIHJldHVybiBhLmNvbmNhdCh0aGlzLmRpZmZfcGF0aDIodl9tYXAyLCB0ZXh0MS5zdWJzdHJpbmcoeCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDIuc3Vic3RyaW5nKHkpKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRvdWJsZUVuZCkge1xuICAgICAgLy8gV2FsayB0aGUgcmV2ZXJzZSBwYXRoIG9uZSBzdGVwLlxuICAgICAgdl9tYXAyW2RdID0ge307XG4gICAgICBmb3IgKHZhciBrID0gLWQ7IGsgPD0gZDsgayArPSAyKSB7XG4gICAgICAgIGlmIChrID09IC1kIHx8IGsgIT0gZCAmJiB2MltrIC0gMV0gPCB2MltrICsgMV0pIHtcbiAgICAgICAgICB4ID0gdjJbayArIDFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHggPSB2MltrIC0gMV0gKyAxO1xuICAgICAgICB9XG4gICAgICAgIHkgPSB4IC0gaztcbiAgICAgICAgZm9vdHN0ZXAgPSAodGV4dDFfbGVuZ3RoIC0geCkgKyAnLCcgKyAodGV4dDJfbGVuZ3RoIC0geSk7XG4gICAgICAgIGlmICghZnJvbnQgJiYgZm9vdHN0ZXBzW2Zvb3RzdGVwXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb250KSB7XG4gICAgICAgICAgZm9vdHN0ZXBzW2Zvb3RzdGVwXSA9IGQ7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKCFkb25lICYmIHggPCB0ZXh0MV9sZW5ndGggJiYgeSA8IHRleHQyX2xlbmd0aCAmJlxuICAgICAgICAgICAgICAgdGV4dDEuY2hhckF0KHRleHQxX2xlbmd0aCAtIHggLSAxKSA9PVxuICAgICAgICAgICAgICAgdGV4dDIuY2hhckF0KHRleHQyX2xlbmd0aCAtIHkgLSAxKSkge1xuICAgICAgICAgIHgrKztcbiAgICAgICAgICB5Kys7XG4gICAgICAgICAgZm9vdHN0ZXAgPSAodGV4dDFfbGVuZ3RoIC0geCkgKyAnLCcgKyAodGV4dDJfbGVuZ3RoIC0geSk7XG4gICAgICAgICAgaWYgKCFmcm9udCAmJiBmb290c3RlcHNbZm9vdHN0ZXBdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZnJvbnQpIHtcbiAgICAgICAgICAgIGZvb3RzdGVwc1tmb290c3RlcF0gPSBkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2MltrXSA9IHg7XG4gICAgICAgIHZfbWFwMltkXVt4ICsgJywnICsgeV0gPSB0cnVlO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIC8vIFJldmVyc2UgcGF0aCByYW4gb3ZlciBmcm9udCBwYXRoLlxuICAgICAgICAgIHZfbWFwMSA9IHZfbWFwMS5zbGljZSgwLCBmb290c3RlcHNbZm9vdHN0ZXBdICsgMSk7XG4gICAgICAgICAgdmFyIGEgPSB0aGlzLmRpZmZfcGF0aDEodl9tYXAxLCB0ZXh0MS5zdWJzdHJpbmcoMCwgdGV4dDFfbGVuZ3RoIC0geCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDIuc3Vic3RyaW5nKDAsIHRleHQyX2xlbmd0aCAtIHkpKTtcbiAgICAgICAgICByZXR1cm4gYS5jb25jYXQodGhpcy5kaWZmX3BhdGgyKHZfbWFwMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDEuc3Vic3RyaW5nKHRleHQxX2xlbmd0aCAtIHgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Mi5zdWJzdHJpbmcodGV4dDJfbGVuZ3RoIC0geSkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBOdW1iZXIgb2YgZGlmZnMgZXF1YWxzIG51bWJlciBvZiBjaGFyYWN0ZXJzLCBubyBjb21tb25hbGl0eSBhdCBhbGwuXG4gIHJldHVybiBudWxsO1xufTtcblxuXG4vKipcbiAqIFdvcmsgZnJvbSB0aGUgbWlkZGxlIGJhY2sgdG8gdGhlIHN0YXJ0IHRvIGRldGVybWluZSB0aGUgcGF0aC5cbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IHZfbWFwIEFycmF5IG9mIHBhdGhzLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIE9sZCBzdHJpbmcgZnJhZ21lbnQgdG8gYmUgZGlmZmVkLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIE5ldyBzdHJpbmcgZnJhZ21lbnQgdG8gYmUgZGlmZmVkLlxuICogQHJldHVybiB7QXJyYXkuPEFycmF5LjxudW1iZXJ8c3RyaW5nPj59IEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICogQHByaXZhdGVcbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9wYXRoMSA9IGZ1bmN0aW9uKHZfbWFwLCB0ZXh0MSwgdGV4dDIpIHtcbiAgdmFyIHBhdGggPSBbXTtcbiAgdmFyIHggPSB0ZXh0MS5sZW5ndGg7XG4gIHZhciB5ID0gdGV4dDIubGVuZ3RoO1xuICAvKiogQHR5cGUgez9udW1iZXJ9ICovXG4gIHZhciBsYXN0X29wID0gbnVsbDtcbiAgZm9yICh2YXIgZCA9IHZfbWFwLmxlbmd0aCAtIDI7IGQgPj0gMDsgZC0tKSB7XG4gICAgd2hpbGUgKDEpIHtcbiAgICAgIGlmICh2X21hcFtkXVsoeCAtIDEpICsgJywnICsgeV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB4LS07XG4gICAgICAgIGlmIChsYXN0X29wID09PSBESUZGX0RFTEVURSkge1xuICAgICAgICAgIHBhdGhbMF1bMV0gPSB0ZXh0MS5jaGFyQXQoeCkgKyBwYXRoWzBdWzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGgudW5zaGlmdChbRElGRl9ERUxFVEUsIHRleHQxLmNoYXJBdCh4KV0pO1xuICAgICAgICB9XG4gICAgICAgIGxhc3Rfb3AgPSBESUZGX0RFTEVURTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKHZfbWFwW2RdW3ggKyAnLCcgKyAoeSAtIDEpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHktLTtcbiAgICAgICAgaWYgKGxhc3Rfb3AgPT09IERJRkZfSU5TRVJUKSB7XG4gICAgICAgICAgcGF0aFswXVsxXSA9IHRleHQyLmNoYXJBdCh5KSArIHBhdGhbMF1bMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aC51bnNoaWZ0KFtESUZGX0lOU0VSVCwgdGV4dDIuY2hhckF0KHkpXSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdF9vcCA9IERJRkZfSU5TRVJUO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgtLTtcbiAgICAgICAgeS0tO1xuICAgICAgICBpZiAodGV4dDEuY2hhckF0KHgpICE9IHRleHQyLmNoYXJBdCh5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZGlhZ29uYWwuICBDYW5cXCd0IGhhcHBlbi4gKGRpZmZfcGF0aDEpJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3Rfb3AgPT09IERJRkZfRVFVQUwpIHtcbiAgICAgICAgICBwYXRoWzBdWzFdID0gdGV4dDEuY2hhckF0KHgpICsgcGF0aFswXVsxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRoLnVuc2hpZnQoW0RJRkZfRVFVQUwsIHRleHQxLmNoYXJBdCh4KV0pO1xuICAgICAgICB9XG4gICAgICAgIGxhc3Rfb3AgPSBESUZGX0VRVUFMO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcGF0aDtcbn07XG5cblxuLyoqXG4gKiBXb3JrIGZyb20gdGhlIG1pZGRsZSBiYWNrIHRvIHRoZSBlbmQgdG8gZGV0ZXJtaW5lIHRoZSBwYXRoLlxuICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gdl9tYXAgQXJyYXkgb2YgcGF0aHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgT2xkIHN0cmluZyBmcmFnbWVudCB0byBiZSBkaWZmZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgTmV3IHN0cmluZyBmcmFnbWVudCB0byBiZSBkaWZmZWQuXG4gKiBAcmV0dXJuIHtBcnJheS48QXJyYXkuPG51bWJlcnxzdHJpbmc+Pn0gQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX3BhdGgyID0gZnVuY3Rpb24odl9tYXAsIHRleHQxLCB0ZXh0Mikge1xuICB2YXIgcGF0aCA9IFtdO1xuICB2YXIgcGF0aExlbmd0aCA9IDA7XG4gIHZhciB4ID0gdGV4dDEubGVuZ3RoO1xuICB2YXIgeSA9IHRleHQyLmxlbmd0aDtcbiAgLyoqIEB0eXBlIHs/bnVtYmVyfSAqL1xuICB2YXIgbGFzdF9vcCA9IG51bGw7XG4gIGZvciAodmFyIGQgPSB2X21hcC5sZW5ndGggLSAyOyBkID49IDA7IGQtLSkge1xuICAgIHdoaWxlICgxKSB7XG4gICAgICBpZiAodl9tYXBbZF1bKHggLSAxKSArICcsJyArIHldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgeC0tO1xuICAgICAgICBpZiAobGFzdF9vcCA9PT0gRElGRl9ERUxFVEUpIHtcbiAgICAgICAgICBwYXRoW3BhdGhMZW5ndGggLSAxXVsxXSArPSB0ZXh0MS5jaGFyQXQodGV4dDEubGVuZ3RoIC0geCAtIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGhbcGF0aExlbmd0aCsrXSA9XG4gICAgICAgICAgICAgIFtESUZGX0RFTEVURSwgdGV4dDEuY2hhckF0KHRleHQxLmxlbmd0aCAtIHggLSAxKV07XG4gICAgICAgIH1cbiAgICAgICAgbGFzdF9vcCA9IERJRkZfREVMRVRFO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAodl9tYXBbZF1beCArICcsJyArICh5IC0gMSldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgeS0tO1xuICAgICAgICBpZiAobGFzdF9vcCA9PT0gRElGRl9JTlNFUlQpIHtcbiAgICAgICAgICBwYXRoW3BhdGhMZW5ndGggLSAxXVsxXSArPSB0ZXh0Mi5jaGFyQXQodGV4dDIubGVuZ3RoIC0geSAtIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGhbcGF0aExlbmd0aCsrXSA9XG4gICAgICAgICAgICAgIFtESUZGX0lOU0VSVCwgdGV4dDIuY2hhckF0KHRleHQyLmxlbmd0aCAtIHkgLSAxKV07XG4gICAgICAgIH1cbiAgICAgICAgbGFzdF9vcCA9IERJRkZfSU5TRVJUO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgtLTtcbiAgICAgICAgeS0tO1xuICAgICAgICBpZiAodGV4dDEuY2hhckF0KHRleHQxLmxlbmd0aCAtIHggLSAxKSAhPVxuICAgICAgICAgICAgdGV4dDIuY2hhckF0KHRleHQyLmxlbmd0aCAtIHkgLSAxKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZGlhZ29uYWwuICBDYW5cXCd0IGhhcHBlbi4gKGRpZmZfcGF0aDIpJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3Rfb3AgPT09IERJRkZfRVFVQUwpIHtcbiAgICAgICAgICBwYXRoW3BhdGhMZW5ndGggLSAxXVsxXSArPSB0ZXh0MS5jaGFyQXQodGV4dDEubGVuZ3RoIC0geCAtIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGhbcGF0aExlbmd0aCsrXSA9XG4gICAgICAgICAgICAgIFtESUZGX0VRVUFMLCB0ZXh0MS5jaGFyQXQodGV4dDEubGVuZ3RoIC0geCAtIDEpXTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0X29wID0gRElGRl9FUVVBTDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59O1xuXG5cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSBjb21tb24gcHJlZml4IG9mIHR3byBzdHJpbmdzXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgRmlyc3Qgc3RyaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIFNlY29uZCBzdHJpbmcuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBjb21tb24gdG8gdGhlIHN0YXJ0IG9mIGVhY2hcbiAqICAgICBzdHJpbmcuXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfY29tbW9uUHJlZml4ID0gZnVuY3Rpb24odGV4dDEsIHRleHQyKSB7XG4gIC8vIFF1aWNrIGNoZWNrIGZvciBjb21tb24gbnVsbCBjYXNlcy5cbiAgaWYgKCF0ZXh0MSB8fCAhdGV4dDIgfHwgdGV4dDEuY2hhckF0KDApICE9IHRleHQyLmNoYXJBdCgwKSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIC8vIEJpbmFyeSBzZWFyY2guXG4gIC8vIFBlcmZvcm1hbmNlIGFuYWx5c2lzOiBodHRwOi8vbmVpbC5mcmFzZXIubmFtZS9uZXdzLzIwMDcvMTAvMDkvXG4gIHZhciBwb2ludGVybWluID0gMDtcbiAgdmFyIHBvaW50ZXJtYXggPSBNYXRoLm1pbih0ZXh0MS5sZW5ndGgsIHRleHQyLmxlbmd0aCk7XG4gIHZhciBwb2ludGVybWlkID0gcG9pbnRlcm1heDtcbiAgdmFyIHBvaW50ZXJzdGFydCA9IDA7XG4gIHdoaWxlIChwb2ludGVybWluIDwgcG9pbnRlcm1pZCkge1xuICAgIGlmICh0ZXh0MS5zdWJzdHJpbmcocG9pbnRlcnN0YXJ0LCBwb2ludGVybWlkKSA9PVxuICAgICAgICB0ZXh0Mi5zdWJzdHJpbmcocG9pbnRlcnN0YXJ0LCBwb2ludGVybWlkKSkge1xuICAgICAgcG9pbnRlcm1pbiA9IHBvaW50ZXJtaWQ7XG4gICAgICBwb2ludGVyc3RhcnQgPSBwb2ludGVybWluO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludGVybWF4ID0gcG9pbnRlcm1pZDtcbiAgICB9XG4gICAgcG9pbnRlcm1pZCA9IE1hdGguZmxvb3IoKHBvaW50ZXJtYXggLSBwb2ludGVybWluKSAvIDIgKyBwb2ludGVybWluKTtcbiAgfVxuICByZXR1cm4gcG9pbnRlcm1pZDtcbn07XG5cblxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIGNvbW1vbiBzdWZmaXggb2YgdHdvIHN0cmluZ3NcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBGaXJzdCBzdHJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgU2Vjb25kIHN0cmluZy5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGNvbW1vbiB0byB0aGUgZW5kIG9mIGVhY2ggc3RyaW5nLlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2NvbW1vblN1ZmZpeCA9IGZ1bmN0aW9uKHRleHQxLCB0ZXh0Mikge1xuICAvLyBRdWljayBjaGVjayBmb3IgY29tbW9uIG51bGwgY2FzZXMuXG4gIGlmICghdGV4dDEgfHwgIXRleHQyIHx8IHRleHQxLmNoYXJBdCh0ZXh0MS5sZW5ndGggLSAxKSAhPVxuICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Mi5jaGFyQXQodGV4dDIubGVuZ3RoIC0gMSkpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICAvLyBCaW5hcnkgc2VhcmNoLlxuICAvLyBQZXJmb3JtYW5jZSBhbmFseXNpczogaHR0cDovL25laWwuZnJhc2VyLm5hbWUvbmV3cy8yMDA3LzEwLzA5L1xuICB2YXIgcG9pbnRlcm1pbiA9IDA7XG4gIHZhciBwb2ludGVybWF4ID0gTWF0aC5taW4odGV4dDEubGVuZ3RoLCB0ZXh0Mi5sZW5ndGgpO1xuICB2YXIgcG9pbnRlcm1pZCA9IHBvaW50ZXJtYXg7XG4gIHZhciBwb2ludGVyZW5kID0gMDtcbiAgd2hpbGUgKHBvaW50ZXJtaW4gPCBwb2ludGVybWlkKSB7XG4gICAgaWYgKHRleHQxLnN1YnN0cmluZyh0ZXh0MS5sZW5ndGggLSBwb2ludGVybWlkLCB0ZXh0MS5sZW5ndGggLSBwb2ludGVyZW5kKSA9PVxuICAgICAgICB0ZXh0Mi5zdWJzdHJpbmcodGV4dDIubGVuZ3RoIC0gcG9pbnRlcm1pZCwgdGV4dDIubGVuZ3RoIC0gcG9pbnRlcmVuZCkpIHtcbiAgICAgIHBvaW50ZXJtaW4gPSBwb2ludGVybWlkO1xuICAgICAgcG9pbnRlcmVuZCA9IHBvaW50ZXJtaW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50ZXJtYXggPSBwb2ludGVybWlkO1xuICAgIH1cbiAgICBwb2ludGVybWlkID0gTWF0aC5mbG9vcigocG9pbnRlcm1heCAtIHBvaW50ZXJtaW4pIC8gMiArIHBvaW50ZXJtaW4pO1xuICB9XG4gIHJldHVybiBwb2ludGVybWlkO1xufTtcblxuXG4vKipcbiAqIERvIHRoZSB0d28gdGV4dHMgc2hhcmUgYSBzdWJzdHJpbmcgd2hpY2ggaXMgYXQgbGVhc3QgaGFsZiB0aGUgbGVuZ3RoIG9mIHRoZVxuICogbG9uZ2VyIHRleHQ/XG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgRmlyc3Qgc3RyaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIFNlY29uZCBzdHJpbmcuXG4gKiBAcmV0dXJuIHs/QXJyYXkuPHN0cmluZz59IEZpdmUgZWxlbWVudCBBcnJheSwgY29udGFpbmluZyB0aGUgcHJlZml4IG9mXG4gKiAgICAgdGV4dDEsIHRoZSBzdWZmaXggb2YgdGV4dDEsIHRoZSBwcmVmaXggb2YgdGV4dDIsIHRoZSBzdWZmaXggb2ZcbiAqICAgICB0ZXh0MiBhbmQgdGhlIGNvbW1vbiBtaWRkbGUuICBPciBudWxsIGlmIHRoZXJlIHdhcyBubyBtYXRjaC5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9oYWxmTWF0Y2ggPSBmdW5jdGlvbih0ZXh0MSwgdGV4dDIpIHtcbiAgdmFyIGxvbmd0ZXh0ID0gdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gdGV4dDEgOiB0ZXh0MjtcbiAgdmFyIHNob3J0dGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQyIDogdGV4dDE7XG4gIGlmIChsb25ndGV4dC5sZW5ndGggPCAxMCB8fCBzaG9ydHRleHQubGVuZ3RoIDwgMSkge1xuICAgIHJldHVybiBudWxsOyAgLy8gUG9pbnRsZXNzLlxuICB9XG4gIHZhciBkbXAgPSB0aGlzOyAgLy8gJ3RoaXMnIGJlY29tZXMgJ3dpbmRvdycgaW4gYSBjbG9zdXJlLlxuXG4gIC8qKlxuICAgKiBEb2VzIGEgc3Vic3RyaW5nIG9mIHNob3J0dGV4dCBleGlzdCB3aXRoaW4gbG9uZ3RleHQgc3VjaCB0aGF0IHRoZSBzdWJzdHJpbmdcbiAgICogaXMgYXQgbGVhc3QgaGFsZiB0aGUgbGVuZ3RoIG9mIGxvbmd0ZXh0P1xuICAgKiBDbG9zdXJlLCBidXQgZG9lcyBub3QgcmVmZXJlbmNlIGFueSBleHRlcm5hbCB2YXJpYWJsZXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsb25ndGV4dCBMb25nZXIgc3RyaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2hvcnR0ZXh0IFNob3J0ZXIgc3RyaW5nLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaSBTdGFydCBpbmRleCBvZiBxdWFydGVyIGxlbmd0aCBzdWJzdHJpbmcgd2l0aGluIGxvbmd0ZXh0XG4gICAqIEByZXR1cm4gez9BcnJheS48c3RyaW5nPn0gRml2ZSBlbGVtZW50IEFycmF5LCBjb250YWluaW5nIHRoZSBwcmVmaXggb2ZcbiAgICogICAgIGxvbmd0ZXh0LCB0aGUgc3VmZml4IG9mIGxvbmd0ZXh0LCB0aGUgcHJlZml4IG9mIHNob3J0dGV4dCwgdGhlIHN1ZmZpeFxuICAgKiAgICAgb2Ygc2hvcnR0ZXh0IGFuZCB0aGUgY29tbW9uIG1pZGRsZS4gIE9yIG51bGwgaWYgdGhlcmUgd2FzIG5vIG1hdGNoLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZGlmZl9oYWxmTWF0Y2hJKGxvbmd0ZXh0LCBzaG9ydHRleHQsIGkpIHtcbiAgICAvLyBTdGFydCB3aXRoIGEgMS80IGxlbmd0aCBzdWJzdHJpbmcgYXQgcG9zaXRpb24gaSBhcyBhIHNlZWQuXG4gICAgdmFyIHNlZWQgPSBsb25ndGV4dC5zdWJzdHJpbmcoaSwgaSArIE1hdGguZmxvb3IobG9uZ3RleHQubGVuZ3RoIC8gNCkpO1xuICAgIHZhciBqID0gLTE7XG4gICAgdmFyIGJlc3RfY29tbW9uID0gJyc7XG4gICAgdmFyIGJlc3RfbG9uZ3RleHRfYSwgYmVzdF9sb25ndGV4dF9iLCBiZXN0X3Nob3J0dGV4dF9hLCBiZXN0X3Nob3J0dGV4dF9iO1xuICAgIHdoaWxlICgoaiA9IHNob3J0dGV4dC5pbmRleE9mKHNlZWQsIGogKyAxKSkgIT0gLTEpIHtcbiAgICAgIHZhciBwcmVmaXhMZW5ndGggPSBkbXAuZGlmZl9jb21tb25QcmVmaXgobG9uZ3RleHQuc3Vic3RyaW5nKGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG9ydHRleHQuc3Vic3RyaW5nKGopKTtcbiAgICAgIHZhciBzdWZmaXhMZW5ndGggPSBkbXAuZGlmZl9jb21tb25TdWZmaXgobG9uZ3RleHQuc3Vic3RyaW5nKDAsIGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG9ydHRleHQuc3Vic3RyaW5nKDAsIGopKTtcbiAgICAgIGlmIChiZXN0X2NvbW1vbi5sZW5ndGggPCBzdWZmaXhMZW5ndGggKyBwcmVmaXhMZW5ndGgpIHtcbiAgICAgICAgYmVzdF9jb21tb24gPSBzaG9ydHRleHQuc3Vic3RyaW5nKGogLSBzdWZmaXhMZW5ndGgsIGopICtcbiAgICAgICAgICAgIHNob3J0dGV4dC5zdWJzdHJpbmcoaiwgaiArIHByZWZpeExlbmd0aCk7XG4gICAgICAgIGJlc3RfbG9uZ3RleHRfYSA9IGxvbmd0ZXh0LnN1YnN0cmluZygwLCBpIC0gc3VmZml4TGVuZ3RoKTtcbiAgICAgICAgYmVzdF9sb25ndGV4dF9iID0gbG9uZ3RleHQuc3Vic3RyaW5nKGkgKyBwcmVmaXhMZW5ndGgpO1xuICAgICAgICBiZXN0X3Nob3J0dGV4dF9hID0gc2hvcnR0ZXh0LnN1YnN0cmluZygwLCBqIC0gc3VmZml4TGVuZ3RoKTtcbiAgICAgICAgYmVzdF9zaG9ydHRleHRfYiA9IHNob3J0dGV4dC5zdWJzdHJpbmcoaiArIHByZWZpeExlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChiZXN0X2NvbW1vbi5sZW5ndGggPj0gbG9uZ3RleHQubGVuZ3RoIC8gMikge1xuICAgICAgcmV0dXJuIFtiZXN0X2xvbmd0ZXh0X2EsIGJlc3RfbG9uZ3RleHRfYixcbiAgICAgICAgICAgICAgYmVzdF9zaG9ydHRleHRfYSwgYmVzdF9zaG9ydHRleHRfYiwgYmVzdF9jb21tb25dO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvLyBGaXJzdCBjaGVjayBpZiB0aGUgc2Vjb25kIHF1YXJ0ZXIgaXMgdGhlIHNlZWQgZm9yIGEgaGFsZi1tYXRjaC5cbiAgdmFyIGhtMSA9IGRpZmZfaGFsZk1hdGNoSShsb25ndGV4dCwgc2hvcnR0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguY2VpbChsb25ndGV4dC5sZW5ndGggLyA0KSk7XG4gIC8vIENoZWNrIGFnYWluIGJhc2VkIG9uIHRoZSB0aGlyZCBxdWFydGVyLlxuICB2YXIgaG0yID0gZGlmZl9oYWxmTWF0Y2hJKGxvbmd0ZXh0LCBzaG9ydHRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5jZWlsKGxvbmd0ZXh0Lmxlbmd0aCAvIDIpKTtcbiAgdmFyIGhtO1xuICBpZiAoIWhtMSAmJiAhaG0yKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAoIWhtMikge1xuICAgIGhtID0gaG0xO1xuICB9IGVsc2UgaWYgKCFobTEpIHtcbiAgICBobSA9IGhtMjtcbiAgfSBlbHNlIHtcbiAgICAvLyBCb3RoIG1hdGNoZWQuICBTZWxlY3QgdGhlIGxvbmdlc3QuXG4gICAgaG0gPSBobTFbNF0ubGVuZ3RoID4gaG0yWzRdLmxlbmd0aCA/IGhtMSA6IGhtMjtcbiAgfVxuXG4gIC8vIEEgaGFsZi1tYXRjaCB3YXMgZm91bmQsIHNvcnQgb3V0IHRoZSByZXR1cm4gZGF0YS5cbiAgdmFyIHRleHQxX2EsIHRleHQxX2IsIHRleHQyX2EsIHRleHQyX2I7XG4gIGlmICh0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGgpIHtcbiAgICB0ZXh0MV9hID0gaG1bMF07XG4gICAgdGV4dDFfYiA9IGhtWzFdO1xuICAgIHRleHQyX2EgPSBobVsyXTtcbiAgICB0ZXh0Ml9iID0gaG1bM107XG4gIH0gZWxzZSB7XG4gICAgdGV4dDJfYSA9IGhtWzBdO1xuICAgIHRleHQyX2IgPSBobVsxXTtcbiAgICB0ZXh0MV9hID0gaG1bMl07XG4gICAgdGV4dDFfYiA9IGhtWzNdO1xuICB9XG4gIHZhciBtaWRfY29tbW9uID0gaG1bNF07XG4gIHJldHVybiBbdGV4dDFfYSwgdGV4dDFfYiwgdGV4dDJfYSwgdGV4dDJfYiwgbWlkX2NvbW1vbl07XG59O1xuXG5cbi8qKlxuICogUmVkdWNlIHRoZSBudW1iZXIgb2YgZWRpdHMgYnkgZWxpbWluYXRpbmcgc2VtYW50aWNhbGx5IHRyaXZpYWwgZXF1YWxpdGllcy5cbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXJ8c3RyaW5nPj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2NsZWFudXBTZW1hbnRpYyA9IGZ1bmN0aW9uKGRpZmZzKSB7XG4gIHZhciBjaGFuZ2VzID0gZmFsc2U7XG4gIHZhciBlcXVhbGl0aWVzID0gW107ICAvLyBTdGFjayBvZiBpbmRpY2VzIHdoZXJlIGVxdWFsaXRpZXMgYXJlIGZvdW5kLlxuICB2YXIgZXF1YWxpdGllc0xlbmd0aCA9IDA7ICAvLyBLZWVwaW5nIG91ciBvd24gbGVuZ3RoIHZhciBpcyBmYXN0ZXIgaW4gSlMuXG4gIHZhciBsYXN0ZXF1YWxpdHkgPSBudWxsOyAgLy8gQWx3YXlzIGVxdWFsIHRvIGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aC0xXVsxXVxuICB2YXIgcG9pbnRlciA9IDA7ICAvLyBJbmRleCBvZiBjdXJyZW50IHBvc2l0aW9uLlxuICAvLyBOdW1iZXIgb2YgY2hhcmFjdGVycyB0aGF0IGNoYW5nZWQgcHJpb3IgdG8gdGhlIGVxdWFsaXR5LlxuICB2YXIgbGVuZ3RoX2NoYW5nZXMxID0gMDtcbiAgLy8gTnVtYmVyIG9mIGNoYXJhY3RlcnMgdGhhdCBjaGFuZ2VkIGFmdGVyIHRoZSBlcXVhbGl0eS5cbiAgdmFyIGxlbmd0aF9jaGFuZ2VzMiA9IDA7XG4gIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoKSB7XG4gICAgaWYgKGRpZmZzW3BvaW50ZXJdWzBdID09IERJRkZfRVFVQUwpIHsgIC8vIGVxdWFsaXR5IGZvdW5kXG4gICAgICBlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGgrK10gPSBwb2ludGVyO1xuICAgICAgbGVuZ3RoX2NoYW5nZXMxID0gbGVuZ3RoX2NoYW5nZXMyO1xuICAgICAgbGVuZ3RoX2NoYW5nZXMyID0gMDtcbiAgICAgIGxhc3RlcXVhbGl0eSA9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgIH0gZWxzZSB7ICAvLyBhbiBpbnNlcnRpb24gb3IgZGVsZXRpb25cbiAgICAgIGxlbmd0aF9jaGFuZ2VzMiArPSBkaWZmc1twb2ludGVyXVsxXS5sZW5ndGg7XG4gICAgICBpZiAobGFzdGVxdWFsaXR5ICE9PSBudWxsICYmIChsYXN0ZXF1YWxpdHkubGVuZ3RoIDw9IGxlbmd0aF9jaGFuZ2VzMSkgJiZcbiAgICAgICAgICAobGFzdGVxdWFsaXR5Lmxlbmd0aCA8PSBsZW5ndGhfY2hhbmdlczIpKSB7XG4gICAgICAgIC8vIER1cGxpY2F0ZSByZWNvcmRcbiAgICAgICAgZGlmZnMuc3BsaWNlKGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdLCAwLFxuICAgICAgICAgICAgICAgICAgICAgW0RJRkZfREVMRVRFLCBsYXN0ZXF1YWxpdHldKTtcbiAgICAgICAgLy8gQ2hhbmdlIHNlY29uZCBjb3B5IHRvIGluc2VydC5cbiAgICAgICAgZGlmZnNbZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0gKyAxXVswXSA9IERJRkZfSU5TRVJUO1xuICAgICAgICAvLyBUaHJvdyBhd2F5IHRoZSBlcXVhbGl0eSB3ZSBqdXN0IGRlbGV0ZWQuXG4gICAgICAgIGVxdWFsaXRpZXNMZW5ndGgtLTtcbiAgICAgICAgLy8gVGhyb3cgYXdheSB0aGUgcHJldmlvdXMgZXF1YWxpdHkgKGl0IG5lZWRzIHRvIGJlIHJlZXZhbHVhdGVkKS5cbiAgICAgICAgZXF1YWxpdGllc0xlbmd0aC0tO1xuICAgICAgICBwb2ludGVyID0gZXF1YWxpdGllc0xlbmd0aCA+IDAgPyBlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSA6IC0xO1xuICAgICAgICBsZW5ndGhfY2hhbmdlczEgPSAwOyAgLy8gUmVzZXQgdGhlIGNvdW50ZXJzLlxuICAgICAgICBsZW5ndGhfY2hhbmdlczIgPSAwO1xuICAgICAgICBsYXN0ZXF1YWxpdHkgPSBudWxsO1xuICAgICAgICBjaGFuZ2VzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcG9pbnRlcisrO1xuICB9XG4gIGlmIChjaGFuZ2VzKSB7XG4gICAgdGhpcy5kaWZmX2NsZWFudXBNZXJnZShkaWZmcyk7XG4gIH1cbiAgdGhpcy5kaWZmX2NsZWFudXBTZW1hbnRpY0xvc3NsZXNzKGRpZmZzKTtcbn07XG5cblxuLyoqXG4gKiBMb29rIGZvciBzaW5nbGUgZWRpdHMgc3Vycm91bmRlZCBvbiBib3RoIHNpZGVzIGJ5IGVxdWFsaXRpZXNcbiAqIHdoaWNoIGNhbiBiZSBzaGlmdGVkIHNpZGV3YXlzIHRvIGFsaWduIHRoZSBlZGl0IHRvIGEgd29yZCBib3VuZGFyeS5cbiAqIGUuZzogVGhlIGM8aW5zPmF0IGM8L2lucz5hbWUuIC0+IFRoZSA8aW5zPmNhdCA8L2lucz5jYW1lLlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcnxzdHJpbmc+Pn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfY2xlYW51cFNlbWFudGljTG9zc2xlc3MgPSBmdW5jdGlvbihkaWZmcykge1xuICAvLyBEZWZpbmUgc29tZSByZWdleCBwYXR0ZXJucyBmb3IgbWF0Y2hpbmcgYm91bmRhcmllcy5cbiAgdmFyIHB1bmN0dWF0aW9uID0gL1teYS16QS1aMC05XS87XG4gIHZhciB3aGl0ZXNwYWNlID0gL1xccy87XG4gIHZhciBsaW5lYnJlYWsgPSAvW1xcclxcbl0vO1xuICB2YXIgYmxhbmtsaW5lRW5kID0gL1xcblxccj9cXG4kLztcbiAgdmFyIGJsYW5rbGluZVN0YXJ0ID0gL15cXHI/XFxuXFxyP1xcbi87XG5cbiAgLyoqXG4gICAqIEdpdmVuIHR3byBzdHJpbmdzLCBjb21wdXRlIGEgc2NvcmUgcmVwcmVzZW50aW5nIHdoZXRoZXIgdGhlIGludGVybmFsXG4gICAqIGJvdW5kYXJ5IGZhbGxzIG9uIGxvZ2ljYWwgYm91bmRhcmllcy5cbiAgICogU2NvcmVzIHJhbmdlIGZyb20gNSAoYmVzdCkgdG8gMCAod29yc3QpLlxuICAgKiBDbG9zdXJlLCBtYWtlcyByZWZlcmVuY2UgdG8gcmVnZXggcGF0dGVybnMgZGVmaW5lZCBhYm92ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9uZSBGaXJzdCBzdHJpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0d28gU2Vjb25kIHN0cmluZy5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgc2NvcmUuXG4gICAqL1xuICBmdW5jdGlvbiBkaWZmX2NsZWFudXBTZW1hbnRpY1Njb3JlKG9uZSwgdHdvKSB7XG4gICAgaWYgKCFvbmUgfHwgIXR3bykge1xuICAgICAgLy8gRWRnZXMgYXJlIHRoZSBiZXN0LlxuICAgICAgcmV0dXJuIDU7XG4gICAgfVxuXG4gICAgLy8gRWFjaCBwb3J0IG9mIHRoaXMgZnVuY3Rpb24gYmVoYXZlcyBzbGlnaHRseSBkaWZmZXJlbnRseSBkdWUgdG9cbiAgICAvLyBzdWJ0bGUgZGlmZmVyZW5jZXMgaW4gZWFjaCBsYW5ndWFnZSdzIGRlZmluaXRpb24gb2YgdGhpbmdzIGxpa2VcbiAgICAvLyAnd2hpdGVzcGFjZScuICBTaW5jZSB0aGlzIGZ1bmN0aW9uJ3MgcHVycG9zZSBpcyBsYXJnZWx5IGNvc21ldGljLFxuICAgIC8vIHRoZSBjaG9pY2UgaGFzIGJlZW4gbWFkZSB0byB1c2UgZWFjaCBsYW5ndWFnZSdzIG5hdGl2ZSBmZWF0dXJlc1xuICAgIC8vIHJhdGhlciB0aGFuIGZvcmNlIHRvdGFsIGNvbmZvcm1pdHkuXG4gICAgdmFyIHNjb3JlID0gMDtcbiAgICAvLyBPbmUgcG9pbnQgZm9yIG5vbi1hbHBoYW51bWVyaWMuXG4gICAgaWYgKG9uZS5jaGFyQXQob25lLmxlbmd0aCAtIDEpLm1hdGNoKHB1bmN0dWF0aW9uKSB8fFxuICAgICAgICB0d28uY2hhckF0KDApLm1hdGNoKHB1bmN0dWF0aW9uKSkge1xuICAgICAgc2NvcmUrKztcbiAgICAgIC8vIFR3byBwb2ludHMgZm9yIHdoaXRlc3BhY2UuXG4gICAgICBpZiAob25lLmNoYXJBdChvbmUubGVuZ3RoIC0gMSkubWF0Y2god2hpdGVzcGFjZSkgfHxcbiAgICAgICAgICB0d28uY2hhckF0KDApLm1hdGNoKHdoaXRlc3BhY2UpKSB7XG4gICAgICAgIHNjb3JlKys7XG4gICAgICAgIC8vIFRocmVlIHBvaW50cyBmb3IgbGluZSBicmVha3MuXG4gICAgICAgIGlmIChvbmUuY2hhckF0KG9uZS5sZW5ndGggLSAxKS5tYXRjaChsaW5lYnJlYWspIHx8XG4gICAgICAgICAgICB0d28uY2hhckF0KDApLm1hdGNoKGxpbmVicmVhaykpIHtcbiAgICAgICAgICBzY29yZSsrO1xuICAgICAgICAgIC8vIEZvdXIgcG9pbnRzIGZvciBibGFuayBsaW5lcy5cbiAgICAgICAgICBpZiAob25lLm1hdGNoKGJsYW5rbGluZUVuZCkgfHwgdHdvLm1hdGNoKGJsYW5rbGluZVN0YXJ0KSkge1xuICAgICAgICAgICAgc2NvcmUrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNjb3JlO1xuICB9XG5cbiAgdmFyIHBvaW50ZXIgPSAxO1xuICAvLyBJbnRlbnRpb25hbGx5IGlnbm9yZSB0aGUgZmlyc3QgYW5kIGxhc3QgZWxlbWVudCAoZG9uJ3QgbmVlZCBjaGVja2luZykuXG4gIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoIC0gMSkge1xuICAgIGlmIChkaWZmc1twb2ludGVyIC0gMV1bMF0gPT0gRElGRl9FUVVBTCAmJlxuICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMF0gPT0gRElGRl9FUVVBTCkge1xuICAgICAgLy8gVGhpcyBpcyBhIHNpbmdsZSBlZGl0IHN1cnJvdW5kZWQgYnkgZXF1YWxpdGllcy5cbiAgICAgIHZhciBlcXVhbGl0eTEgPSBkaWZmc1twb2ludGVyIC0gMV1bMV07XG4gICAgICB2YXIgZWRpdCA9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgdmFyIGVxdWFsaXR5MiA9IGRpZmZzW3BvaW50ZXIgKyAxXVsxXTtcblxuICAgICAgLy8gRmlyc3QsIHNoaWZ0IHRoZSBlZGl0IGFzIGZhciBsZWZ0IGFzIHBvc3NpYmxlLlxuICAgICAgdmFyIGNvbW1vbk9mZnNldCA9IHRoaXMuZGlmZl9jb21tb25TdWZmaXgoZXF1YWxpdHkxLCBlZGl0KTtcbiAgICAgIGlmIChjb21tb25PZmZzZXQpIHtcbiAgICAgICAgdmFyIGNvbW1vblN0cmluZyA9IGVkaXQuc3Vic3RyaW5nKGVkaXQubGVuZ3RoIC0gY29tbW9uT2Zmc2V0KTtcbiAgICAgICAgZXF1YWxpdHkxID0gZXF1YWxpdHkxLnN1YnN0cmluZygwLCBlcXVhbGl0eTEubGVuZ3RoIC0gY29tbW9uT2Zmc2V0KTtcbiAgICAgICAgZWRpdCA9IGNvbW1vblN0cmluZyArIGVkaXQuc3Vic3RyaW5nKDAsIGVkaXQubGVuZ3RoIC0gY29tbW9uT2Zmc2V0KTtcbiAgICAgICAgZXF1YWxpdHkyID0gY29tbW9uU3RyaW5nICsgZXF1YWxpdHkyO1xuICAgICAgfVxuXG4gICAgICAvLyBTZWNvbmQsIHN0ZXAgY2hhcmFjdGVyIGJ5IGNoYXJhY3RlciByaWdodCwgbG9va2luZyBmb3IgdGhlIGJlc3QgZml0LlxuICAgICAgdmFyIGJlc3RFcXVhbGl0eTEgPSBlcXVhbGl0eTE7XG4gICAgICB2YXIgYmVzdEVkaXQgPSBlZGl0O1xuICAgICAgdmFyIGJlc3RFcXVhbGl0eTIgPSBlcXVhbGl0eTI7XG4gICAgICB2YXIgYmVzdFNjb3JlID0gZGlmZl9jbGVhbnVwU2VtYW50aWNTY29yZShlcXVhbGl0eTEsIGVkaXQpICtcbiAgICAgICAgICBkaWZmX2NsZWFudXBTZW1hbnRpY1Njb3JlKGVkaXQsIGVxdWFsaXR5Mik7XG4gICAgICB3aGlsZSAoZWRpdC5jaGFyQXQoMCkgPT09IGVxdWFsaXR5Mi5jaGFyQXQoMCkpIHtcbiAgICAgICAgZXF1YWxpdHkxICs9IGVkaXQuY2hhckF0KDApO1xuICAgICAgICBlZGl0ID0gZWRpdC5zdWJzdHJpbmcoMSkgKyBlcXVhbGl0eTIuY2hhckF0KDApO1xuICAgICAgICBlcXVhbGl0eTIgPSBlcXVhbGl0eTIuc3Vic3RyaW5nKDEpO1xuICAgICAgICB2YXIgc2NvcmUgPSBkaWZmX2NsZWFudXBTZW1hbnRpY1Njb3JlKGVxdWFsaXR5MSwgZWRpdCkgK1xuICAgICAgICAgICAgZGlmZl9jbGVhbnVwU2VtYW50aWNTY29yZShlZGl0LCBlcXVhbGl0eTIpO1xuICAgICAgICAvLyBUaGUgPj0gZW5jb3VyYWdlcyB0cmFpbGluZyByYXRoZXIgdGhhbiBsZWFkaW5nIHdoaXRlc3BhY2Ugb24gZWRpdHMuXG4gICAgICAgIGlmIChzY29yZSA+PSBiZXN0U2NvcmUpIHtcbiAgICAgICAgICBiZXN0U2NvcmUgPSBzY29yZTtcbiAgICAgICAgICBiZXN0RXF1YWxpdHkxID0gZXF1YWxpdHkxO1xuICAgICAgICAgIGJlc3RFZGl0ID0gZWRpdDtcbiAgICAgICAgICBiZXN0RXF1YWxpdHkyID0gZXF1YWxpdHkyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkaWZmc1twb2ludGVyIC0gMV1bMV0gIT0gYmVzdEVxdWFsaXR5MSkge1xuICAgICAgICAvLyBXZSBoYXZlIGFuIGltcHJvdmVtZW50LCBzYXZlIGl0IGJhY2sgdG8gdGhlIGRpZmYuXG4gICAgICAgIGlmIChiZXN0RXF1YWxpdHkxKSB7XG4gICAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdID0gYmVzdEVxdWFsaXR5MTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciAtIDEsIDEpO1xuICAgICAgICAgIHBvaW50ZXItLTtcbiAgICAgICAgfVxuICAgICAgICBkaWZmc1twb2ludGVyXVsxXSA9IGJlc3RFZGl0O1xuICAgICAgICBpZiAoYmVzdEVxdWFsaXR5Mikge1xuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSA9IGJlc3RFcXVhbGl0eTI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgKyAxLCAxKTtcbiAgICAgICAgICBwb2ludGVyLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcG9pbnRlcisrO1xuICB9XG59O1xuXG5cbi8qKlxuICogUmVkdWNlIHRoZSBudW1iZXIgb2YgZWRpdHMgYnkgZWxpbWluYXRpbmcgb3BlcmF0aW9uYWxseSB0cml2aWFsIGVxdWFsaXRpZXMuXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyfHN0cmluZz4+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jbGVhbnVwRWZmaWNpZW5jeSA9IGZ1bmN0aW9uKGRpZmZzKSB7XG4gIHZhciBjaGFuZ2VzID0gZmFsc2U7XG4gIHZhciBlcXVhbGl0aWVzID0gW107ICAvLyBTdGFjayBvZiBpbmRpY2VzIHdoZXJlIGVxdWFsaXRpZXMgYXJlIGZvdW5kLlxuICB2YXIgZXF1YWxpdGllc0xlbmd0aCA9IDA7ICAvLyBLZWVwaW5nIG91ciBvd24gbGVuZ3RoIHZhciBpcyBmYXN0ZXIgaW4gSlMuXG4gIHZhciBsYXN0ZXF1YWxpdHkgPSAnJzsgIC8vIEFsd2F5cyBlcXVhbCB0byBlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGgtMV1bMV1cbiAgdmFyIHBvaW50ZXIgPSAwOyAgLy8gSW5kZXggb2YgY3VycmVudCBwb3NpdGlvbi5cbiAgLy8gSXMgdGhlcmUgYW4gaW5zZXJ0aW9uIG9wZXJhdGlvbiBiZWZvcmUgdGhlIGxhc3QgZXF1YWxpdHkuXG4gIHZhciBwcmVfaW5zID0gZmFsc2U7XG4gIC8vIElzIHRoZXJlIGEgZGVsZXRpb24gb3BlcmF0aW9uIGJlZm9yZSB0aGUgbGFzdCBlcXVhbGl0eS5cbiAgdmFyIHByZV9kZWwgPSBmYWxzZTtcbiAgLy8gSXMgdGhlcmUgYW4gaW5zZXJ0aW9uIG9wZXJhdGlvbiBhZnRlciB0aGUgbGFzdCBlcXVhbGl0eS5cbiAgdmFyIHBvc3RfaW5zID0gZmFsc2U7XG4gIC8vIElzIHRoZXJlIGEgZGVsZXRpb24gb3BlcmF0aW9uIGFmdGVyIHRoZSBsYXN0IGVxdWFsaXR5LlxuICB2YXIgcG9zdF9kZWwgPSBmYWxzZTtcbiAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGgpIHtcbiAgICBpZiAoZGlmZnNbcG9pbnRlcl1bMF0gPT0gRElGRl9FUVVBTCkgeyAgLy8gZXF1YWxpdHkgZm91bmRcbiAgICAgIGlmIChkaWZmc1twb2ludGVyXVsxXS5sZW5ndGggPCB0aGlzLkRpZmZfRWRpdENvc3QgJiZcbiAgICAgICAgICAocG9zdF9pbnMgfHwgcG9zdF9kZWwpKSB7XG4gICAgICAgIC8vIENhbmRpZGF0ZSBmb3VuZC5cbiAgICAgICAgZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoKytdID0gcG9pbnRlcjtcbiAgICAgICAgcHJlX2lucyA9IHBvc3RfaW5zO1xuICAgICAgICBwcmVfZGVsID0gcG9zdF9kZWw7XG4gICAgICAgIGxhc3RlcXVhbGl0eSA9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm90IGEgY2FuZGlkYXRlLCBhbmQgY2FuIG5ldmVyIGJlY29tZSBvbmUuXG4gICAgICAgIGVxdWFsaXRpZXNMZW5ndGggPSAwO1xuICAgICAgICBsYXN0ZXF1YWxpdHkgPSAnJztcbiAgICAgIH1cbiAgICAgIHBvc3RfaW5zID0gcG9zdF9kZWwgPSBmYWxzZTtcbiAgICB9IGVsc2UgeyAgLy8gYW4gaW5zZXJ0aW9uIG9yIGRlbGV0aW9uXG4gICAgICBpZiAoZGlmZnNbcG9pbnRlcl1bMF0gPT0gRElGRl9ERUxFVEUpIHtcbiAgICAgICAgcG9zdF9kZWwgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zdF9pbnMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgLypcbiAgICAgICAqIEZpdmUgdHlwZXMgdG8gYmUgc3BsaXQ6XG4gICAgICAgKiA8aW5zPkE8L2lucz48ZGVsPkI8L2RlbD5YWTxpbnM+QzwvaW5zPjxkZWw+RDwvZGVsPlxuICAgICAgICogPGlucz5BPC9pbnM+WDxpbnM+QzwvaW5zPjxkZWw+RDwvZGVsPlxuICAgICAgICogPGlucz5BPC9pbnM+PGRlbD5CPC9kZWw+WDxpbnM+QzwvaW5zPlxuICAgICAgICogPGlucz5BPC9kZWw+WDxpbnM+QzwvaW5zPjxkZWw+RDwvZGVsPlxuICAgICAgICogPGlucz5BPC9pbnM+PGRlbD5CPC9kZWw+WDxkZWw+QzwvZGVsPlxuICAgICAgICovXG4gICAgICBpZiAobGFzdGVxdWFsaXR5ICYmICgocHJlX2lucyAmJiBwcmVfZGVsICYmIHBvc3RfaW5zICYmIHBvc3RfZGVsKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKChsYXN0ZXF1YWxpdHkubGVuZ3RoIDwgdGhpcy5EaWZmX0VkaXRDb3N0IC8gMikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAocHJlX2lucyArIHByZV9kZWwgKyBwb3N0X2lucyArIHBvc3RfZGVsKSA9PSAzKSkpIHtcbiAgICAgICAgLy8gRHVwbGljYXRlIHJlY29yZFxuICAgICAgICBkaWZmcy5zcGxpY2UoZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0sIDAsXG4gICAgICAgICAgICAgICAgICAgICBbRElGRl9ERUxFVEUsIGxhc3RlcXVhbGl0eV0pO1xuICAgICAgICAvLyBDaGFuZ2Ugc2Vjb25kIGNvcHkgdG8gaW5zZXJ0LlxuICAgICAgICBkaWZmc1tlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSArIDFdWzBdID0gRElGRl9JTlNFUlQ7XG4gICAgICAgIGVxdWFsaXRpZXNMZW5ndGgtLTsgIC8vIFRocm93IGF3YXkgdGhlIGVxdWFsaXR5IHdlIGp1c3QgZGVsZXRlZDtcbiAgICAgICAgbGFzdGVxdWFsaXR5ID0gJyc7XG4gICAgICAgIGlmIChwcmVfaW5zICYmIHByZV9kZWwpIHtcbiAgICAgICAgICAvLyBObyBjaGFuZ2VzIG1hZGUgd2hpY2ggY291bGQgYWZmZWN0IHByZXZpb3VzIGVudHJ5LCBrZWVwIGdvaW5nLlxuICAgICAgICAgIHBvc3RfaW5zID0gcG9zdF9kZWwgPSB0cnVlO1xuICAgICAgICAgIGVxdWFsaXRpZXNMZW5ndGggPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVxdWFsaXRpZXNMZW5ndGgtLTsgIC8vIFRocm93IGF3YXkgdGhlIHByZXZpb3VzIGVxdWFsaXR5O1xuICAgICAgICAgIHBvaW50ZXIgPSBlcXVhbGl0aWVzTGVuZ3RoID4gMCA/XG4gICAgICAgICAgICAgIGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdIDogLTE7XG4gICAgICAgICAgcG9zdF9pbnMgPSBwb3N0X2RlbCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNoYW5nZXMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBwb2ludGVyKys7XG4gIH1cblxuICBpZiAoY2hhbmdlcykge1xuICAgIHRoaXMuZGlmZl9jbGVhbnVwTWVyZ2UoZGlmZnMpO1xuICB9XG59O1xuXG5cbi8qKlxuICogUmVvcmRlciBhbmQgbWVyZ2UgbGlrZSBlZGl0IHNlY3Rpb25zLiAgTWVyZ2UgZXF1YWxpdGllcy5cbiAqIEFueSBlZGl0IHNlY3Rpb24gY2FuIG1vdmUgYXMgbG9uZyBhcyBpdCBkb2Vzbid0IGNyb3NzIGFuIGVxdWFsaXR5LlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcnxzdHJpbmc+Pn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfY2xlYW51cE1lcmdlID0gZnVuY3Rpb24oZGlmZnMpIHtcbiAgZGlmZnMucHVzaChbRElGRl9FUVVBTCwgJyddKTsgIC8vIEFkZCBhIGR1bW15IGVudHJ5IGF0IHRoZSBlbmQuXG4gIHZhciBwb2ludGVyID0gMDtcbiAgdmFyIGNvdW50X2RlbGV0ZSA9IDA7XG4gIHZhciBjb3VudF9pbnNlcnQgPSAwO1xuICB2YXIgdGV4dF9kZWxldGUgPSAnJztcbiAgdmFyIHRleHRfaW5zZXJ0ID0gJyc7XG4gIHZhciBjb21tb25sZW5ndGg7XG4gIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoKSB7XG4gICAgc3dpdGNoIChkaWZmc1twb2ludGVyXVswXSkge1xuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcbiAgICAgICAgY291bnRfaW5zZXJ0Kys7XG4gICAgICAgIHRleHRfaW5zZXJ0ICs9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgICBwb2ludGVyKys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0RFTEVURTpcbiAgICAgICAgY291bnRfZGVsZXRlKys7XG4gICAgICAgIHRleHRfZGVsZXRlICs9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgICBwb2ludGVyKys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgICAvLyBVcG9uIHJlYWNoaW5nIGFuIGVxdWFsaXR5LCBjaGVjayBmb3IgcHJpb3IgcmVkdW5kYW5jaWVzLlxuICAgICAgICBpZiAoY291bnRfZGVsZXRlICE9PSAwIHx8IGNvdW50X2luc2VydCAhPT0gMCkge1xuICAgICAgICAgIGlmIChjb3VudF9kZWxldGUgIT09IDAgJiYgY291bnRfaW5zZXJ0ICE9PSAwKSB7XG4gICAgICAgICAgICAvLyBGYWN0b3Igb3V0IGFueSBjb21tb24gcHJlZml4aWVzLlxuICAgICAgICAgICAgY29tbW9ubGVuZ3RoID0gdGhpcy5kaWZmX2NvbW1vblByZWZpeCh0ZXh0X2luc2VydCwgdGV4dF9kZWxldGUpO1xuICAgICAgICAgICAgaWYgKGNvbW1vbmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICBpZiAoKHBvaW50ZXIgLSBjb3VudF9kZWxldGUgLSBjb3VudF9pbnNlcnQpID4gMCAmJlxuICAgICAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCAtIDFdWzBdID09XG4gICAgICAgICAgICAgICAgICBESUZGX0VRVUFMKSB7XG4gICAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCAtIDFdWzFdICs9XG4gICAgICAgICAgICAgICAgICAgIHRleHRfaW5zZXJ0LnN1YnN0cmluZygwLCBjb21tb25sZW5ndGgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpZmZzLnNwbGljZSgwLCAwLCBbRElGRl9FUVVBTCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dF9pbnNlcnQuc3Vic3RyaW5nKDAsIGNvbW1vbmxlbmd0aCldKTtcbiAgICAgICAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGV4dF9pbnNlcnQgPSB0ZXh0X2luc2VydC5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgdGV4dF9kZWxldGUgPSB0ZXh0X2RlbGV0ZS5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZhY3RvciBvdXQgYW55IGNvbW1vbiBzdWZmaXhpZXMuXG4gICAgICAgICAgICBjb21tb25sZW5ndGggPSB0aGlzLmRpZmZfY29tbW9uU3VmZml4KHRleHRfaW5zZXJ0LCB0ZXh0X2RlbGV0ZSk7XG4gICAgICAgICAgICBpZiAoY29tbW9ubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdID0gdGV4dF9pbnNlcnQuc3Vic3RyaW5nKHRleHRfaW5zZXJ0Lmxlbmd0aCAtXG4gICAgICAgICAgICAgICAgICBjb21tb25sZW5ndGgpICsgZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgICAgICAgIHRleHRfaW5zZXJ0ID0gdGV4dF9pbnNlcnQuc3Vic3RyaW5nKDAsIHRleHRfaW5zZXJ0Lmxlbmd0aCAtXG4gICAgICAgICAgICAgICAgICBjb21tb25sZW5ndGgpO1xuICAgICAgICAgICAgICB0ZXh0X2RlbGV0ZSA9IHRleHRfZGVsZXRlLnN1YnN0cmluZygwLCB0ZXh0X2RlbGV0ZS5sZW5ndGggLVxuICAgICAgICAgICAgICAgICAgY29tbW9ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gRGVsZXRlIHRoZSBvZmZlbmRpbmcgcmVjb3JkcyBhbmQgYWRkIHRoZSBtZXJnZWQgb25lcy5cbiAgICAgICAgICBpZiAoY291bnRfZGVsZXRlID09PSAwKSB7XG4gICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCxcbiAgICAgICAgICAgICAgICBjb3VudF9kZWxldGUgKyBjb3VudF9pbnNlcnQsIFtESUZGX0lOU0VSVCwgdGV4dF9pbnNlcnRdKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvdW50X2luc2VydCA9PT0gMCkge1xuICAgICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSBjb3VudF9kZWxldGUgLSBjb3VudF9pbnNlcnQsXG4gICAgICAgICAgICAgICAgY291bnRfZGVsZXRlICsgY291bnRfaW5zZXJ0LCBbRElGRl9ERUxFVEUsIHRleHRfZGVsZXRlXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0LFxuICAgICAgICAgICAgICAgIGNvdW50X2RlbGV0ZSArIGNvdW50X2luc2VydCwgW0RJRkZfREVMRVRFLCB0ZXh0X2RlbGV0ZV0sXG4gICAgICAgICAgICAgICAgW0RJRkZfSU5TRVJULCB0ZXh0X2luc2VydF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb2ludGVyID0gcG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCArXG4gICAgICAgICAgICAgICAgICAgIChjb3VudF9kZWxldGUgPyAxIDogMCkgKyAoY291bnRfaW5zZXJ0ID8gMSA6IDApICsgMTtcbiAgICAgICAgfSBlbHNlIGlmIChwb2ludGVyICE9PSAwICYmIGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PSBESUZGX0VRVUFMKSB7XG4gICAgICAgICAgLy8gTWVyZ2UgdGhpcyBlcXVhbGl0eSB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdICs9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyLCAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgIH1cbiAgICAgICAgY291bnRfaW5zZXJ0ID0gMDtcbiAgICAgICAgY291bnRfZGVsZXRlID0gMDtcbiAgICAgICAgdGV4dF9kZWxldGUgPSAnJztcbiAgICAgICAgdGV4dF9pbnNlcnQgPSAnJztcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVsxXSA9PT0gJycpIHtcbiAgICBkaWZmcy5wb3AoKTsgIC8vIFJlbW92ZSB0aGUgZHVtbXkgZW50cnkgYXQgdGhlIGVuZC5cbiAgfVxuXG4gIC8vIFNlY29uZCBwYXNzOiBsb29rIGZvciBzaW5nbGUgZWRpdHMgc3Vycm91bmRlZCBvbiBib3RoIHNpZGVzIGJ5IGVxdWFsaXRpZXNcbiAgLy8gd2hpY2ggY2FuIGJlIHNoaWZ0ZWQgc2lkZXdheXMgdG8gZWxpbWluYXRlIGFuIGVxdWFsaXR5LlxuICAvLyBlLmc6IEE8aW5zPkJBPC9pbnM+QyAtPiA8aW5zPkFCPC9pbnM+QUNcbiAgdmFyIGNoYW5nZXMgPSBmYWxzZTtcbiAgcG9pbnRlciA9IDE7XG4gIC8vIEludGVudGlvbmFsbHkgaWdub3JlIHRoZSBmaXJzdCBhbmQgbGFzdCBlbGVtZW50IChkb24ndCBuZWVkIGNoZWNraW5nKS5cbiAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGggLSAxKSB7XG4gICAgaWYgKGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PSBESUZGX0VRVUFMICYmXG4gICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVswXSA9PSBESUZGX0VRVUFMKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgc2luZ2xlIGVkaXQgc3Vycm91bmRlZCBieSBlcXVhbGl0aWVzLlxuICAgICAgaWYgKGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZyhkaWZmc1twb2ludGVyXVsxXS5sZW5ndGggLVxuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXS5sZW5ndGgpID09IGRpZmZzW3BvaW50ZXIgLSAxXVsxXSkge1xuICAgICAgICAvLyBTaGlmdCB0aGUgZWRpdCBvdmVyIHRoZSBwcmV2aW91cyBlcXVhbGl0eS5cbiAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0gPSBkaWZmc1twb2ludGVyIC0gMV1bMV0gK1xuICAgICAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKDAsIGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aCAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdLmxlbmd0aCk7XG4gICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSA9IGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArIGRpZmZzW3BvaW50ZXIgKyAxXVsxXTtcbiAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSAxLCAxKTtcbiAgICAgICAgY2hhbmdlcyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZygwLCBkaWZmc1twb2ludGVyICsgMV1bMV0ubGVuZ3RoKSA9PVxuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSkge1xuICAgICAgICAvLyBTaGlmdCB0aGUgZWRpdCBvdmVyIHRoZSBuZXh0IGVxdWFsaXR5LlxuICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0gKz0gZGlmZnNbcG9pbnRlciArIDFdWzFdO1xuICAgICAgICBkaWZmc1twb2ludGVyXVsxXSA9XG4gICAgICAgICAgICBkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoZGlmZnNbcG9pbnRlciArIDFdWzFdLmxlbmd0aCkgK1xuICAgICAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzFdO1xuICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciArIDEsIDEpO1xuICAgICAgICBjaGFuZ2VzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcG9pbnRlcisrO1xuICB9XG4gIC8vIElmIHNoaWZ0cyB3ZXJlIG1hZGUsIHRoZSBkaWZmIG5lZWRzIHJlb3JkZXJpbmcgYW5kIGFub3RoZXIgc2hpZnQgc3dlZXAuXG4gIGlmIChjaGFuZ2VzKSB7XG4gICAgdGhpcy5kaWZmX2NsZWFudXBNZXJnZShkaWZmcyk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBsb2MgaXMgYSBsb2NhdGlvbiBpbiB0ZXh0MSwgY29tcHV0ZSBhbmQgcmV0dXJuIHRoZSBlcXVpdmFsZW50IGxvY2F0aW9uIGluXG4gKiB0ZXh0Mi5cbiAqIGUuZy4gJ1RoZSBjYXQnIHZzICdUaGUgYmlnIGNhdCcsIDEtPjEsIDUtPjhcbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXJ8c3RyaW5nPj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IGxvYyBMb2NhdGlvbiB3aXRoaW4gdGV4dDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IExvY2F0aW9uIHdpdGhpbiB0ZXh0Mi5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl94SW5kZXggPSBmdW5jdGlvbihkaWZmcywgbG9jKSB7XG4gIHZhciBjaGFyczEgPSAwO1xuICB2YXIgY2hhcnMyID0gMDtcbiAgdmFyIGxhc3RfY2hhcnMxID0gMDtcbiAgdmFyIGxhc3RfY2hhcnMyID0gMDtcbiAgdmFyIHg7XG4gIGZvciAoeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xuICAgIGlmIChkaWZmc1t4XVswXSAhPT0gRElGRl9JTlNFUlQpIHsgIC8vIEVxdWFsaXR5IG9yIGRlbGV0aW9uLlxuICAgICAgY2hhcnMxICs9IGRpZmZzW3hdWzFdLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKGRpZmZzW3hdWzBdICE9PSBESUZGX0RFTEVURSkgeyAgLy8gRXF1YWxpdHkgb3IgaW5zZXJ0aW9uLlxuICAgICAgY2hhcnMyICs9IGRpZmZzW3hdWzFdLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKGNoYXJzMSA+IGxvYykgeyAgLy8gT3ZlcnNob3QgdGhlIGxvY2F0aW9uLlxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxhc3RfY2hhcnMxID0gY2hhcnMxO1xuICAgIGxhc3RfY2hhcnMyID0gY2hhcnMyO1xuICB9XG4gIC8vIFdhcyB0aGUgbG9jYXRpb24gd2FzIGRlbGV0ZWQ/XG4gIGlmIChkaWZmcy5sZW5ndGggIT0geCAmJiBkaWZmc1t4XVswXSA9PT0gRElGRl9ERUxFVEUpIHtcbiAgICByZXR1cm4gbGFzdF9jaGFyczI7XG4gIH1cbiAgLy8gQWRkIHRoZSByZW1haW5pbmcgY2hhcmFjdGVyIGxlbmd0aC5cbiAgcmV0dXJuIGxhc3RfY2hhcnMyICsgKGxvYyAtIGxhc3RfY2hhcnMxKTtcbn07XG5cblxuLyoqXG4gKiBDb252ZXJ0IGEgZGlmZiBhcnJheSBpbnRvIGEgcHJldHR5IEhUTUwgcmVwb3J0LlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcnxzdHJpbmc+Pn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEhUTUwgcmVwcmVzZW50YXRpb24uXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfcHJldHR5SHRtbCA9IGZ1bmN0aW9uKGRpZmZzKSB7XG4gIHZhciBodG1sID0gW107XG4gIHZhciBpID0gMDtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xuICAgIHZhciBvcCA9IGRpZmZzW3hdWzBdOyAgICAvLyBPcGVyYXRpb24gKGluc2VydCwgZGVsZXRlLCBlcXVhbClcbiAgICB2YXIgZGF0YSA9IGRpZmZzW3hdWzFdOyAgLy8gVGV4dCBvZiBjaGFuZ2UuXG4gICAgdmFyIHRleHQgPSBkYXRhLnJlcGxhY2UoLyYvZywgJyZhbXA7JykucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JykucmVwbGFjZSgvXFxuL2csICcmcGFyYTs8QlI+Jyk7XG4gICAgc3dpdGNoIChvcCkge1xuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcbiAgICAgICAgaHRtbFt4XSA9ICc8SU5TIFNUWUxFPVwiYmFja2dyb3VuZDojRTZGRkU2O1wiIFRJVExFPVwiaT0nICsgaSArICdcIj4nICtcbiAgICAgICAgICAgICAgICB0ZXh0ICsgJzwvSU5TPic7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0RFTEVURTpcbiAgICAgICAgaHRtbFt4XSA9ICc8REVMIFNUWUxFPVwiYmFja2dyb3VuZDojRkZFNkU2O1wiIFRJVExFPVwiaT0nICsgaSArICdcIj4nICtcbiAgICAgICAgICAgICAgICB0ZXh0ICsgJzwvREVMPic7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgICBodG1sW3hdID0gJzxTUEFOIFRJVExFPVwiaT0nICsgaSArICdcIj4nICsgdGV4dCArICc8L1NQQU4+JztcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChvcCAhPT0gRElGRl9ERUxFVEUpIHtcbiAgICAgIGkgKz0gZGF0YS5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiBodG1sLmpvaW4oJycpO1xufTtcblxuXG4vKipcbiAqIENvbXB1dGUgYW5kIHJldHVybiB0aGUgc291cmNlIHRleHQgKGFsbCBlcXVhbGl0aWVzIGFuZCBkZWxldGlvbnMpLlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcnxzdHJpbmc+Pn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFNvdXJjZSB0ZXh0LlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX3RleHQxID0gZnVuY3Rpb24oZGlmZnMpIHtcbiAgdmFyIHRleHQgPSBbXTtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xuICAgIGlmIChkaWZmc1t4XVswXSAhPT0gRElGRl9JTlNFUlQpIHtcbiAgICAgIHRleHRbeF0gPSBkaWZmc1t4XVsxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRleHQuam9pbignJyk7XG59O1xuXG5cbi8qKlxuICogQ29tcHV0ZSBhbmQgcmV0dXJuIHRoZSBkZXN0aW5hdGlvbiB0ZXh0IChhbGwgZXF1YWxpdGllcyBhbmQgaW5zZXJ0aW9ucykuXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyfHN0cmluZz4+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqIEByZXR1cm4ge3N0cmluZ30gRGVzdGluYXRpb24gdGV4dC5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl90ZXh0MiA9IGZ1bmN0aW9uKGRpZmZzKSB7XG4gIHZhciB0ZXh0ID0gW107XG4gIGZvciAodmFyIHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICBpZiAoZGlmZnNbeF1bMF0gIT09IERJRkZfREVMRVRFKSB7XG4gICAgICB0ZXh0W3hdID0gZGlmZnNbeF1bMV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0ZXh0LmpvaW4oJycpO1xufTtcblxuXG4vKipcbiAqIENvbXB1dGUgdGhlIExldmVuc2h0ZWluIGRpc3RhbmNlOyB0aGUgbnVtYmVyIG9mIGluc2VydGVkLCBkZWxldGVkIG9yXG4gKiBzdWJzdGl0dXRlZCBjaGFyYWN0ZXJzLlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcnxzdHJpbmc+Pn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE51bWJlciBvZiBjaGFuZ2VzLlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2xldmVuc2h0ZWluID0gZnVuY3Rpb24oZGlmZnMpIHtcbiAgdmFyIGxldmVuc2h0ZWluID0gMDtcbiAgdmFyIGluc2VydGlvbnMgPSAwO1xuICB2YXIgZGVsZXRpb25zID0gMDtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xuICAgIHZhciBvcCA9IGRpZmZzW3hdWzBdO1xuICAgIHZhciBkYXRhID0gZGlmZnNbeF1bMV07XG4gICAgc3dpdGNoIChvcCkge1xuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcbiAgICAgICAgaW5zZXJ0aW9ucyArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxuICAgICAgICBkZWxldGlvbnMgKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgICAvLyBBIGRlbGV0aW9uIGFuZCBhbiBpbnNlcnRpb24gaXMgb25lIHN1YnN0aXR1dGlvbi5cbiAgICAgICAgbGV2ZW5zaHRlaW4gKz0gTWF0aC5tYXgoaW5zZXJ0aW9ucywgZGVsZXRpb25zKTtcbiAgICAgICAgaW5zZXJ0aW9ucyA9IDA7XG4gICAgICAgIGRlbGV0aW9ucyA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBsZXZlbnNodGVpbiArPSBNYXRoLm1heChpbnNlcnRpb25zLCBkZWxldGlvbnMpO1xuICByZXR1cm4gbGV2ZW5zaHRlaW47XG59O1xuXG5cbi8qKlxuICogQ3J1c2ggdGhlIGRpZmYgaW50byBhbiBlbmNvZGVkIHN0cmluZyB3aGljaCBkZXNjcmliZXMgdGhlIG9wZXJhdGlvbnNcbiAqIHJlcXVpcmVkIHRvIHRyYW5zZm9ybSB0ZXh0MSBpbnRvIHRleHQyLlxuICogRS5nLiA9M1xcdC0yXFx0K2luZyAgLT4gS2VlcCAzIGNoYXJzLCBkZWxldGUgMiBjaGFycywgaW5zZXJ0ICdpbmcnLlxuICogT3BlcmF0aW9ucyBhcmUgdGFiLXNlcGFyYXRlZC4gIEluc2VydGVkIHRleHQgaXMgZXNjYXBlZCB1c2luZyAleHggbm90YXRpb24uXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyfHN0cmluZz4+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqIEByZXR1cm4ge3N0cmluZ30gRGVsdGEgdGV4dC5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl90b0RlbHRhID0gZnVuY3Rpb24oZGlmZnMpIHtcbiAgdmFyIHRleHQgPSBbXTtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xuICAgIHN3aXRjaCAoZGlmZnNbeF1bMF0pIHtcbiAgICAgIGNhc2UgRElGRl9JTlNFUlQ6XG4gICAgICAgIHRleHRbeF0gPSAnKycgKyBlbmNvZGVVUkkoZGlmZnNbeF1bMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XG4gICAgICAgIHRleHRbeF0gPSAnLScgKyBkaWZmc1t4XVsxXS5sZW5ndGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgICB0ZXh0W3hdID0gJz0nICsgZGlmZnNbeF1bMV0ubGVuZ3RoO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgLy8gT3BlcmEgZG9lc24ndCBrbm93IGhvdyB0byBlbmNvZGUgY2hhciAwLlxuICByZXR1cm4gdGV4dC5qb2luKCdcXHQnKS5yZXBsYWNlKC9cXHgwMC9nLCAnJTAwJykucmVwbGFjZSgvJTIwL2csICcgJyk7XG59O1xuXG5cbi8qKlxuICogR2l2ZW4gdGhlIG9yaWdpbmFsIHRleHQxLCBhbmQgYW4gZW5jb2RlZCBzdHJpbmcgd2hpY2ggZGVzY3JpYmVzIHRoZVxuICogb3BlcmF0aW9ucyByZXF1aXJlZCB0byB0cmFuc2Zvcm0gdGV4dDEgaW50byB0ZXh0MiwgY29tcHV0ZSB0aGUgZnVsbCBkaWZmLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIFNvdXJjZSBzdHJpbmcgZm9yIHRoZSBkaWZmLlxuICogQHBhcmFtIHtzdHJpbmd9IGRlbHRhIERlbHRhIHRleHQuXG4gKiBAcmV0dXJuIHtBcnJheS48QXJyYXkuPG51bWJlcnxzdHJpbmc+Pn0gQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgaW52YWxpZCBpbnB1dC5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9mcm9tRGVsdGEgPSBmdW5jdGlvbih0ZXh0MSwgZGVsdGEpIHtcbiAgdmFyIGRpZmZzID0gW107XG4gIHZhciBkaWZmc0xlbmd0aCA9IDA7ICAvLyBLZWVwaW5nIG91ciBvd24gbGVuZ3RoIHZhciBpcyBmYXN0ZXIgaW4gSlMuXG4gIHZhciBwb2ludGVyID0gMDsgIC8vIEN1cnNvciBpbiB0ZXh0MVxuICAvLyBPcGVyYSBkb2Vzbid0IGtub3cgaG93IHRvIGRlY29kZSBjaGFyIDAuXG4gIGRlbHRhID0gZGVsdGEucmVwbGFjZSgvJTAwL2csICdcXDAnKTtcbiAgdmFyIHRva2VucyA9IGRlbHRhLnNwbGl0KC9cXHQvZyk7XG4gIGZvciAodmFyIHggPSAwOyB4IDwgdG9rZW5zLmxlbmd0aDsgeCsrKSB7XG4gICAgLy8gRWFjaCB0b2tlbiBiZWdpbnMgd2l0aCBhIG9uZSBjaGFyYWN0ZXIgcGFyYW1ldGVyIHdoaWNoIHNwZWNpZmllcyB0aGVcbiAgICAvLyBvcGVyYXRpb24gb2YgdGhpcyB0b2tlbiAoZGVsZXRlLCBpbnNlcnQsIGVxdWFsaXR5KS5cbiAgICB2YXIgcGFyYW0gPSB0b2tlbnNbeF0uc3Vic3RyaW5nKDEpO1xuICAgIHN3aXRjaCAodG9rZW5zW3hdLmNoYXJBdCgwKSkge1xuICAgICAgY2FzZSAnKyc6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZGlmZnNbZGlmZnNMZW5ndGgrK10gPSBbRElGRl9JTlNFUlQsIGRlY29kZVVSSShwYXJhbSldO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIC8vIE1hbGZvcm1lZCBVUkkgc2VxdWVuY2UuXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGVzY2FwZSBpbiBkaWZmX2Zyb21EZWx0YTogJyArIHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJy0nOlxuICAgICAgICAvLyBGYWxsIHRocm91Z2guXG4gICAgICBjYXNlICc9JzpcbiAgICAgICAgdmFyIG4gPSBwYXJzZUludChwYXJhbSwgMTApO1xuICAgICAgICBpZiAoaXNOYU4obikgfHwgbiA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbnVtYmVyIGluIGRpZmZfZnJvbURlbHRhOiAnICsgcGFyYW0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ZXh0ID0gdGV4dDEuc3Vic3RyaW5nKHBvaW50ZXIsIHBvaW50ZXIgKz0gbik7XG4gICAgICAgIGlmICh0b2tlbnNbeF0uY2hhckF0KDApID09ICc9Jykge1xuICAgICAgICAgIGRpZmZzW2RpZmZzTGVuZ3RoKytdID0gW0RJRkZfRVFVQUwsIHRleHRdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpZmZzW2RpZmZzTGVuZ3RoKytdID0gW0RJRkZfREVMRVRFLCB0ZXh0XTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIEJsYW5rIHRva2VucyBhcmUgb2sgKGZyb20gYSB0cmFpbGluZyBcXHQpLlxuICAgICAgICAvLyBBbnl0aGluZyBlbHNlIGlzIGFuIGVycm9yLlxuICAgICAgICBpZiAodG9rZW5zW3hdKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRpZmYgb3BlcmF0aW9uIGluIGRpZmZfZnJvbURlbHRhOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zW3hdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAocG9pbnRlciAhPSB0ZXh0MS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlbHRhIGxlbmd0aCAoJyArIHBvaW50ZXIgK1xuICAgICAgICAnKSBkb2VzIG5vdCBlcXVhbCBzb3VyY2UgdGV4dCBsZW5ndGggKCcgKyB0ZXh0MS5sZW5ndGggKyAnKS4nKTtcbiAgfVxuICByZXR1cm4gZGlmZnM7XG59O1xuXG5cbi8vICBNQVRDSCBGVU5DVElPTlNcblxuXG4vKipcbiAqIExvY2F0ZSB0aGUgYmVzdCBpbnN0YW5jZSBvZiAncGF0dGVybicgaW4gJ3RleHQnIG5lYXIgJ2xvYycuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBzZWFyY2guXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0dGVybiBUaGUgcGF0dGVybiB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGxvYyBUaGUgbG9jYXRpb24gdG8gc2VhcmNoIGFyb3VuZC5cbiAqIEByZXR1cm4ge251bWJlcn0gQmVzdCBtYXRjaCBpbmRleCBvciAtMS5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUubWF0Y2hfbWFpbiA9IGZ1bmN0aW9uKHRleHQsIHBhdHRlcm4sIGxvYykge1xuICAvLyBDaGVjayBmb3IgbnVsbCBpbnB1dHMuXG4gIGlmICh0ZXh0ID09IG51bGwgfHwgcGF0dGVybiA9PSBudWxsIHx8IGxvYyA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOdWxsIGlucHV0LiAobWF0Y2hfbWFpbiknKTtcbiAgfVxuXG4gIGxvYyA9IE1hdGgubWF4KDAsIE1hdGgubWluKGxvYywgdGV4dC5sZW5ndGgpKTtcbiAgaWYgKHRleHQgPT0gcGF0dGVybikge1xuICAgIC8vIFNob3J0Y3V0IChwb3RlbnRpYWxseSBub3QgZ3VhcmFudGVlZCBieSB0aGUgYWxnb3JpdGhtKVxuICAgIHJldHVybiAwO1xuICB9IGVsc2UgaWYgKCF0ZXh0Lmxlbmd0aCkge1xuICAgIC8vIE5vdGhpbmcgdG8gbWF0Y2guXG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2UgaWYgKHRleHQuc3Vic3RyaW5nKGxvYywgbG9jICsgcGF0dGVybi5sZW5ndGgpID09IHBhdHRlcm4pIHtcbiAgICAvLyBQZXJmZWN0IG1hdGNoIGF0IHRoZSBwZXJmZWN0IHNwb3QhICAoSW5jbHVkZXMgY2FzZSBvZiBudWxsIHBhdHRlcm4pXG4gICAgcmV0dXJuIGxvYztcbiAgfSBlbHNlIHtcbiAgICAvLyBEbyBhIGZ1enp5IGNvbXBhcmUuXG4gICAgcmV0dXJuIHRoaXMubWF0Y2hfYml0YXAodGV4dCwgcGF0dGVybiwgbG9jKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIExvY2F0ZSB0aGUgYmVzdCBpbnN0YW5jZSBvZiAncGF0dGVybicgaW4gJ3RleHQnIG5lYXIgJ2xvYycgdXNpbmcgdGhlXG4gKiBCaXRhcCBhbGdvcml0aG0uXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBzZWFyY2guXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0dGVybiBUaGUgcGF0dGVybiB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGxvYyBUaGUgbG9jYXRpb24gdG8gc2VhcmNoIGFyb3VuZC5cbiAqIEByZXR1cm4ge251bWJlcn0gQmVzdCBtYXRjaCBpbmRleCBvciAtMS5cbiAqIEBwcml2YXRlXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLm1hdGNoX2JpdGFwID0gZnVuY3Rpb24odGV4dCwgcGF0dGVybiwgbG9jKSB7XG4gIGlmIChwYXR0ZXJuLmxlbmd0aCA+IHRoaXMuTWF0Y2hfTWF4Qml0cykge1xuICAgIHRocm93IG5ldyBFcnJvcignUGF0dGVybiB0b28gbG9uZyBmb3IgdGhpcyBicm93c2VyLicpO1xuICB9XG5cbiAgLy8gSW5pdGlhbGlzZSB0aGUgYWxwaGFiZXQuXG4gIHZhciBzID0gdGhpcy5tYXRjaF9hbHBoYWJldChwYXR0ZXJuKTtcblxuICB2YXIgZG1wID0gdGhpczsgIC8vICd0aGlzJyBiZWNvbWVzICd3aW5kb3cnIGluIGEgY2xvc3VyZS5cblxuICAvKipcbiAgICogQ29tcHV0ZSBhbmQgcmV0dXJuIHRoZSBzY29yZSBmb3IgYSBtYXRjaCB3aXRoIGUgZXJyb3JzIGFuZCB4IGxvY2F0aW9uLlxuICAgKiBBY2Nlc3NlcyBsb2MgYW5kIHBhdHRlcm4gdGhyb3VnaCBiZWluZyBhIGNsb3N1cmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlIE51bWJlciBvZiBlcnJvcnMgaW4gbWF0Y2guXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IExvY2F0aW9uIG9mIG1hdGNoLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE92ZXJhbGwgc2NvcmUgZm9yIG1hdGNoICgwLjAgPSBnb29kLCAxLjAgPSBiYWQpLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gbWF0Y2hfYml0YXBTY29yZShlLCB4KSB7XG4gICAgdmFyIGFjY3VyYWN5ID0gZSAvIHBhdHRlcm4ubGVuZ3RoO1xuICAgIHZhciBwcm94aW1pdHkgPSBNYXRoLmFicyhsb2MgLSB4KTtcbiAgICBpZiAoIWRtcC5NYXRjaF9EaXN0YW5jZSkge1xuICAgICAgLy8gRG9kZ2UgZGl2aWRlIGJ5IHplcm8gZXJyb3IuXG4gICAgICByZXR1cm4gcHJveGltaXR5ID8gMS4wIDogYWNjdXJhY3k7XG4gICAgfVxuICAgIHJldHVybiBhY2N1cmFjeSArIChwcm94aW1pdHkgLyBkbXAuTWF0Y2hfRGlzdGFuY2UpO1xuICB9XG5cbiAgLy8gSGlnaGVzdCBzY29yZSBiZXlvbmQgd2hpY2ggd2UgZ2l2ZSB1cC5cbiAgdmFyIHNjb3JlX3RocmVzaG9sZCA9IHRoaXMuTWF0Y2hfVGhyZXNob2xkO1xuICAvLyBJcyB0aGVyZSBhIG5lYXJieSBleGFjdCBtYXRjaD8gKHNwZWVkdXApXG4gIHZhciBiZXN0X2xvYyA9IHRleHQuaW5kZXhPZihwYXR0ZXJuLCBsb2MpO1xuICBpZiAoYmVzdF9sb2MgIT0gLTEpIHtcbiAgICBzY29yZV90aHJlc2hvbGQgPSBNYXRoLm1pbihtYXRjaF9iaXRhcFNjb3JlKDAsIGJlc3RfbG9jKSwgc2NvcmVfdGhyZXNob2xkKTtcbiAgICAvLyBXaGF0IGFib3V0IGluIHRoZSBvdGhlciBkaXJlY3Rpb24/IChzcGVlZHVwKVxuICAgIGJlc3RfbG9jID0gdGV4dC5sYXN0SW5kZXhPZihwYXR0ZXJuLCBsb2MgKyBwYXR0ZXJuLmxlbmd0aCk7XG4gICAgaWYgKGJlc3RfbG9jICE9IC0xKSB7XG4gICAgICBzY29yZV90aHJlc2hvbGQgPVxuICAgICAgICAgIE1hdGgubWluKG1hdGNoX2JpdGFwU2NvcmUoMCwgYmVzdF9sb2MpLCBzY29yZV90aHJlc2hvbGQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEluaXRpYWxpc2UgdGhlIGJpdCBhcnJheXMuXG4gIHZhciBtYXRjaG1hc2sgPSAxIDw8IChwYXR0ZXJuLmxlbmd0aCAtIDEpO1xuICBiZXN0X2xvYyA9IC0xO1xuXG4gIHZhciBiaW5fbWluLCBiaW5fbWlkO1xuICB2YXIgYmluX21heCA9IHBhdHRlcm4ubGVuZ3RoICsgdGV4dC5sZW5ndGg7XG4gIHZhciBsYXN0X3JkO1xuICBmb3IgKHZhciBkID0gMDsgZCA8IHBhdHRlcm4ubGVuZ3RoOyBkKyspIHtcbiAgICAvLyBTY2FuIGZvciB0aGUgYmVzdCBtYXRjaDsgZWFjaCBpdGVyYXRpb24gYWxsb3dzIGZvciBvbmUgbW9yZSBlcnJvci5cbiAgICAvLyBSdW4gYSBiaW5hcnkgc2VhcmNoIHRvIGRldGVybWluZSBob3cgZmFyIGZyb20gJ2xvYycgd2UgY2FuIHN0cmF5IGF0IHRoaXNcbiAgICAvLyBlcnJvciBsZXZlbC5cbiAgICBiaW5fbWluID0gMDtcbiAgICBiaW5fbWlkID0gYmluX21heDtcbiAgICB3aGlsZSAoYmluX21pbiA8IGJpbl9taWQpIHtcbiAgICAgIGlmIChtYXRjaF9iaXRhcFNjb3JlKGQsIGxvYyArIGJpbl9taWQpIDw9IHNjb3JlX3RocmVzaG9sZCkge1xuICAgICAgICBiaW5fbWluID0gYmluX21pZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJpbl9tYXggPSBiaW5fbWlkO1xuICAgICAgfVxuICAgICAgYmluX21pZCA9IE1hdGguZmxvb3IoKGJpbl9tYXggLSBiaW5fbWluKSAvIDIgKyBiaW5fbWluKTtcbiAgICB9XG4gICAgLy8gVXNlIHRoZSByZXN1bHQgZnJvbSB0aGlzIGl0ZXJhdGlvbiBhcyB0aGUgbWF4aW11bSBmb3IgdGhlIG5leHQuXG4gICAgYmluX21heCA9IGJpbl9taWQ7XG4gICAgdmFyIHN0YXJ0ID0gTWF0aC5tYXgoMSwgbG9jIC0gYmluX21pZCArIDEpO1xuICAgIHZhciBmaW5pc2ggPSBNYXRoLm1pbihsb2MgKyBiaW5fbWlkLCB0ZXh0Lmxlbmd0aCkgKyBwYXR0ZXJuLmxlbmd0aDtcblxuICAgIHZhciByZCA9IEFycmF5KGZpbmlzaCArIDIpO1xuICAgIHJkW2ZpbmlzaCArIDFdID0gKDEgPDwgZCkgLSAxO1xuICAgIGZvciAodmFyIGogPSBmaW5pc2g7IGogPj0gc3RhcnQ7IGotLSkge1xuICAgICAgLy8gVGhlIGFscGhhYmV0IChzKSBpcyBhIHNwYXJzZSBoYXNoLCBzbyB0aGUgZm9sbG93aW5nIGxpbmUgZ2VuZXJhdGVzXG4gICAgICAvLyB3YXJuaW5ncy5cbiAgICAgIHZhciBjaGFyTWF0Y2ggPSBzW3RleHQuY2hhckF0KGogLSAxKV07XG4gICAgICBpZiAoZCA9PT0gMCkgeyAgLy8gRmlyc3QgcGFzczogZXhhY3QgbWF0Y2guXG4gICAgICAgIHJkW2pdID0gKChyZFtqICsgMV0gPDwgMSkgfCAxKSAmIGNoYXJNYXRjaDtcbiAgICAgIH0gZWxzZSB7ICAvLyBTdWJzZXF1ZW50IHBhc3NlczogZnV6enkgbWF0Y2guXG4gICAgICAgIHJkW2pdID0gKChyZFtqICsgMV0gPDwgMSkgfCAxKSAmIGNoYXJNYXRjaCB8XG4gICAgICAgICAgICAgICAgKCgobGFzdF9yZFtqICsgMV0gfCBsYXN0X3JkW2pdKSA8PCAxKSB8IDEpIHxcbiAgICAgICAgICAgICAgICBsYXN0X3JkW2ogKyAxXTtcbiAgICAgIH1cbiAgICAgIGlmIChyZFtqXSAmIG1hdGNobWFzaykge1xuICAgICAgICB2YXIgc2NvcmUgPSBtYXRjaF9iaXRhcFNjb3JlKGQsIGogLSAxKTtcbiAgICAgICAgLy8gVGhpcyBtYXRjaCB3aWxsIGFsbW9zdCBjZXJ0YWlubHkgYmUgYmV0dGVyIHRoYW4gYW55IGV4aXN0aW5nIG1hdGNoLlxuICAgICAgICAvLyBCdXQgY2hlY2sgYW55d2F5LlxuICAgICAgICBpZiAoc2NvcmUgPD0gc2NvcmVfdGhyZXNob2xkKSB7XG4gICAgICAgICAgLy8gVG9sZCB5b3Ugc28uXG4gICAgICAgICAgc2NvcmVfdGhyZXNob2xkID0gc2NvcmU7XG4gICAgICAgICAgYmVzdF9sb2MgPSBqIC0gMTtcbiAgICAgICAgICBpZiAoYmVzdF9sb2MgPiBsb2MpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gcGFzc2luZyBsb2MsIGRvbid0IGV4Y2VlZCBvdXIgY3VycmVudCBkaXN0YW5jZSBmcm9tIGxvYy5cbiAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoMSwgMiAqIGxvYyAtIGJlc3RfbG9jKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQWxyZWFkeSBwYXNzZWQgbG9jLCBkb3duaGlsbCBmcm9tIGhlcmUgb24gaW4uXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gTm8gaG9wZSBmb3IgYSAoYmV0dGVyKSBtYXRjaCBhdCBncmVhdGVyIGVycm9yIGxldmVscy5cbiAgICBpZiAobWF0Y2hfYml0YXBTY29yZShkICsgMSwgbG9jKSA+IHNjb3JlX3RocmVzaG9sZCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxhc3RfcmQgPSByZDtcbiAgfVxuICByZXR1cm4gYmVzdF9sb2M7XG59O1xuXG5cbi8qKlxuICogSW5pdGlhbGlzZSB0aGUgYWxwaGFiZXQgZm9yIHRoZSBCaXRhcCBhbGdvcml0aG0uXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0dGVybiBUaGUgdGV4dCB0byBlbmNvZGUuXG4gKiBAcmV0dXJuIHtPYmplY3R9IEhhc2ggb2YgY2hhcmFjdGVyIGxvY2F0aW9ucy5cbiAqIEBwcml2YXRlXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLm1hdGNoX2FscGhhYmV0ID0gZnVuY3Rpb24ocGF0dGVybikge1xuICB2YXIgcyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdHRlcm4ubGVuZ3RoOyBpKyspIHtcbiAgICBzW3BhdHRlcm4uY2hhckF0KGkpXSA9IDA7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXR0ZXJuLmxlbmd0aDsgaSsrKSB7XG4gICAgc1twYXR0ZXJuLmNoYXJBdChpKV0gfD0gMSA8PCAocGF0dGVybi5sZW5ndGggLSBpIC0gMSk7XG4gIH1cbiAgcmV0dXJuIHM7XG59O1xuXG5cbi8vICBQQVRDSCBGVU5DVElPTlNcblxuXG4vKipcbiAqIEluY3JlYXNlIHRoZSBjb250ZXh0IHVudGlsIGl0IGlzIHVuaXF1ZSxcbiAqIGJ1dCBkb24ndCBsZXQgdGhlIHBhdHRlcm4gZXhwYW5kIGJleW9uZCBNYXRjaF9NYXhCaXRzLlxuICogQHBhcmFtIHtwYXRjaF9vYmp9IHBhdGNoIFRoZSBwYXRjaCB0byBncm93LlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgU291cmNlIHRleHQuXG4gKiBAcHJpdmF0ZVxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5wYXRjaF9hZGRDb250ZXh0ID0gZnVuY3Rpb24ocGF0Y2gsIHRleHQpIHtcbiAgaWYgKHRleHQubGVuZ3RoID09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSB0ZXh0LnN1YnN0cmluZyhwYXRjaC5zdGFydDIsIHBhdGNoLnN0YXJ0MiArIHBhdGNoLmxlbmd0aDEpO1xuICB2YXIgcGFkZGluZyA9IDA7XG5cbiAgLy8gTG9vayBmb3IgdGhlIGZpcnN0IGFuZCBsYXN0IG1hdGNoZXMgb2YgcGF0dGVybiBpbiB0ZXh0LiAgSWYgdHdvIGRpZmZlcmVudFxuICAvLyBtYXRjaGVzIGFyZSBmb3VuZCwgaW5jcmVhc2UgdGhlIHBhdHRlcm4gbGVuZ3RoLlxuICB3aGlsZSAodGV4dC5pbmRleE9mKHBhdHRlcm4pICE9IHRleHQubGFzdEluZGV4T2YocGF0dGVybikgJiZcbiAgICAgICAgIHBhdHRlcm4ubGVuZ3RoIDwgdGhpcy5NYXRjaF9NYXhCaXRzIC0gdGhpcy5QYXRjaF9NYXJnaW4gLVxuICAgICAgICAgdGhpcy5QYXRjaF9NYXJnaW4pIHtcbiAgICBwYWRkaW5nICs9IHRoaXMuUGF0Y2hfTWFyZ2luO1xuICAgIHBhdHRlcm4gPSB0ZXh0LnN1YnN0cmluZyhwYXRjaC5zdGFydDIgLSBwYWRkaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRjaC5zdGFydDIgKyBwYXRjaC5sZW5ndGgxICsgcGFkZGluZyk7XG4gIH1cbiAgLy8gQWRkIG9uZSBjaHVuayBmb3IgZ29vZCBsdWNrLlxuICBwYWRkaW5nICs9IHRoaXMuUGF0Y2hfTWFyZ2luO1xuXG4gIC8vIEFkZCB0aGUgcHJlZml4LlxuICB2YXIgcHJlZml4ID0gdGV4dC5zdWJzdHJpbmcocGF0Y2guc3RhcnQyIC0gcGFkZGluZywgcGF0Y2guc3RhcnQyKTtcbiAgaWYgKHByZWZpeCkge1xuICAgIHBhdGNoLmRpZmZzLnVuc2hpZnQoW0RJRkZfRVFVQUwsIHByZWZpeF0pO1xuICB9XG4gIC8vIEFkZCB0aGUgc3VmZml4LlxuICB2YXIgc3VmZml4ID0gdGV4dC5zdWJzdHJpbmcocGF0Y2guc3RhcnQyICsgcGF0Y2gubGVuZ3RoMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoLnN0YXJ0MiArIHBhdGNoLmxlbmd0aDEgKyBwYWRkaW5nKTtcbiAgaWYgKHN1ZmZpeCkge1xuICAgIHBhdGNoLmRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIHN1ZmZpeF0pO1xuICB9XG5cbiAgLy8gUm9sbCBiYWNrIHRoZSBzdGFydCBwb2ludHMuXG4gIHBhdGNoLnN0YXJ0MSAtPSBwcmVmaXgubGVuZ3RoO1xuICBwYXRjaC5zdGFydDIgLT0gcHJlZml4Lmxlbmd0aDtcbiAgLy8gRXh0ZW5kIHRoZSBsZW5ndGhzLlxuICBwYXRjaC5sZW5ndGgxICs9IHByZWZpeC5sZW5ndGggKyBzdWZmaXgubGVuZ3RoO1xuICBwYXRjaC5sZW5ndGgyICs9IHByZWZpeC5sZW5ndGggKyBzdWZmaXgubGVuZ3RoO1xufTtcblxuXG4vKipcbiAqIENvbXB1dGUgYSBsaXN0IG9mIHBhdGNoZXMgdG8gdHVybiB0ZXh0MSBpbnRvIHRleHQyLlxuICogVXNlIGRpZmZzIGlmIHByb3ZpZGVkLCBvdGhlcndpc2UgY29tcHV0ZSBpdCBvdXJzZWx2ZXMuXG4gKiBUaGVyZSBhcmUgZm91ciB3YXlzIHRvIGNhbGwgdGhpcyBmdW5jdGlvbiwgZGVwZW5kaW5nIG9uIHdoYXQgZGF0YSBpc1xuICogYXZhaWxhYmxlIHRvIHRoZSBjYWxsZXI6XG4gKiBNZXRob2QgMTpcbiAqIGEgPSB0ZXh0MSwgYiA9IHRleHQyXG4gKiBNZXRob2QgMjpcbiAqIGEgPSBkaWZmc1xuICogTWV0aG9kIDMgKG9wdGltYWwpOlxuICogYSA9IHRleHQxLCBiID0gZGlmZnNcbiAqIE1ldGhvZCA0IChkZXByZWNhdGVkLCB1c2UgbWV0aG9kIDMpOlxuICogYSA9IHRleHQxLCBiID0gdGV4dDIsIGMgPSBkaWZmc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxBcnJheS48bnVtYmVyfHN0cmluZz4+fSBhIHRleHQxIChtZXRob2RzIDEsMyw0KSBvclxuICogQXJyYXkgb2YgZGlmZiB0dXBsZXMgZm9yIHRleHQxIHRvIHRleHQyIChtZXRob2QgMikuXG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48QXJyYXkuPG51bWJlcnxzdHJpbmc+Pn0gb3B0X2IgdGV4dDIgKG1ldGhvZHMgMSw0KSBvclxuICogQXJyYXkgb2YgZGlmZiB0dXBsZXMgZm9yIHRleHQxIHRvIHRleHQyIChtZXRob2QgMykgb3IgdW5kZWZpbmVkIChtZXRob2QgMikuXG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48QXJyYXkuPG51bWJlcnxzdHJpbmc+Pn0gb3B0X2MgQXJyYXkgb2YgZGlmZiB0dXBsZXMgZm9yXG4gKiB0ZXh0MSB0byB0ZXh0MiAobWV0aG9kIDQpIG9yIHVuZGVmaW5lZCAobWV0aG9kcyAxLDIsMykuXG4gKiBAcmV0dXJuIHtBcnJheS48cGF0Y2hfb2JqPn0gQXJyYXkgb2YgcGF0Y2ggb2JqZWN0cy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUucGF0Y2hfbWFrZSA9IGZ1bmN0aW9uKGEsIG9wdF9iLCBvcHRfYykge1xuICB2YXIgdGV4dDEsIGRpZmZzO1xuICBpZiAodHlwZW9mIGEgPT0gJ3N0cmluZycgJiYgdHlwZW9mIG9wdF9iID09ICdzdHJpbmcnICYmXG4gICAgICB0eXBlb2Ygb3B0X2MgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBNZXRob2QgMTogdGV4dDEsIHRleHQyXG4gICAgLy8gQ29tcHV0ZSBkaWZmcyBmcm9tIHRleHQxIGFuZCB0ZXh0Mi5cbiAgICB0ZXh0MSA9IGE7XG4gICAgZGlmZnMgPSB0aGlzLmRpZmZfbWFpbih0ZXh0MSwgb3B0X2IsIHRydWUpO1xuICAgIGlmIChkaWZmcy5sZW5ndGggPiAyKSB7XG4gICAgICB0aGlzLmRpZmZfY2xlYW51cFNlbWFudGljKGRpZmZzKTtcbiAgICAgIHRoaXMuZGlmZl9jbGVhbnVwRWZmaWNpZW5jeShkaWZmcyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGEgJiYgdHlwZW9mIGEgPT0gJ29iamVjdCcgJiYgdHlwZW9mIG9wdF9iID09ICd1bmRlZmluZWQnICYmXG4gICAgICB0eXBlb2Ygb3B0X2MgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBNZXRob2QgMjogZGlmZnNcbiAgICAvLyBDb21wdXRlIHRleHQxIGZyb20gZGlmZnMuXG4gICAgZGlmZnMgPSBhO1xuICAgIHRleHQxID0gdGhpcy5kaWZmX3RleHQxKGRpZmZzKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYSA9PSAnc3RyaW5nJyAmJiBvcHRfYiAmJiB0eXBlb2Ygb3B0X2IgPT0gJ29iamVjdCcgJiZcbiAgICAgIHR5cGVvZiBvcHRfYyA9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIE1ldGhvZCAzOiB0ZXh0MSwgZGlmZnNcbiAgICB0ZXh0MSA9IGE7XG4gICAgZGlmZnMgPSBvcHRfYjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYSA9PSAnc3RyaW5nJyAmJiB0eXBlb2Ygb3B0X2IgPT0gJ3N0cmluZycgJiZcbiAgICAgIG9wdF9jICYmIHR5cGVvZiBvcHRfYyA9PSAnb2JqZWN0Jykge1xuICAgIC8vIE1ldGhvZCA0OiB0ZXh0MSwgdGV4dDIsIGRpZmZzXG4gICAgLy8gdGV4dDIgaXMgbm90IHVzZWQuXG4gICAgdGV4dDEgPSBhO1xuICAgIGRpZmZzID0gb3B0X2M7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGNhbGwgZm9ybWF0IHRvIHBhdGNoX21ha2UuJyk7XG4gIH1cblxuICBpZiAoZGlmZnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdOyAgLy8gR2V0IHJpZCBvZiB0aGUgbnVsbCBjYXNlLlxuICB9XG4gIHZhciBwYXRjaGVzID0gW107XG4gIHZhciBwYXRjaCA9IG5ldyBwYXRjaF9vYmooKTtcbiAgdmFyIHBhdGNoRGlmZkxlbmd0aCA9IDA7ICAvLyBLZWVwaW5nIG91ciBvd24gbGVuZ3RoIHZhciBpcyBmYXN0ZXIgaW4gSlMuXG4gIHZhciBjaGFyX2NvdW50MSA9IDA7ICAvLyBOdW1iZXIgb2YgY2hhcmFjdGVycyBpbnRvIHRoZSB0ZXh0MSBzdHJpbmcuXG4gIHZhciBjaGFyX2NvdW50MiA9IDA7ICAvLyBOdW1iZXIgb2YgY2hhcmFjdGVycyBpbnRvIHRoZSB0ZXh0MiBzdHJpbmcuXG4gIC8vIFN0YXJ0IHdpdGggdGV4dDEgKHByZXBhdGNoX3RleHQpIGFuZCBhcHBseSB0aGUgZGlmZnMgdW50aWwgd2UgYXJyaXZlIGF0XG4gIC8vIHRleHQyIChwb3N0cGF0Y2hfdGV4dCkuICBXZSByZWNyZWF0ZSB0aGUgcGF0Y2hlcyBvbmUgYnkgb25lIHRvIGRldGVybWluZVxuICAvLyBjb250ZXh0IGluZm8uXG4gIHZhciBwcmVwYXRjaF90ZXh0ID0gdGV4dDE7XG4gIHZhciBwb3N0cGF0Y2hfdGV4dCA9IHRleHQxO1xuICBmb3IgKHZhciB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgdmFyIGRpZmZfdHlwZSA9IGRpZmZzW3hdWzBdO1xuICAgIHZhciBkaWZmX3RleHQgPSBkaWZmc1t4XVsxXTtcblxuICAgIGlmICghcGF0Y2hEaWZmTGVuZ3RoICYmIGRpZmZfdHlwZSAhPT0gRElGRl9FUVVBTCkge1xuICAgICAgLy8gQSBuZXcgcGF0Y2ggc3RhcnRzIGhlcmUuXG4gICAgICBwYXRjaC5zdGFydDEgPSBjaGFyX2NvdW50MTtcbiAgICAgIHBhdGNoLnN0YXJ0MiA9IGNoYXJfY291bnQyO1xuICAgIH1cblxuICAgIHN3aXRjaCAoZGlmZl90eXBlKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICBwYXRjaC5kaWZmc1twYXRjaERpZmZMZW5ndGgrK10gPSBkaWZmc1t4XTtcbiAgICAgICAgcGF0Y2gubGVuZ3RoMiArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgICAgICBwb3N0cGF0Y2hfdGV4dCA9IHBvc3RwYXRjaF90ZXh0LnN1YnN0cmluZygwLCBjaGFyX2NvdW50MikgKyBkaWZmX3RleHQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RwYXRjaF90ZXh0LnN1YnN0cmluZyhjaGFyX2NvdW50Mik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0RFTEVURTpcbiAgICAgICAgcGF0Y2gubGVuZ3RoMSArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgICAgICBwYXRjaC5kaWZmc1twYXRjaERpZmZMZW5ndGgrK10gPSBkaWZmc1t4XTtcbiAgICAgICAgcG9zdHBhdGNoX3RleHQgPSBwb3N0cGF0Y2hfdGV4dC5zdWJzdHJpbmcoMCwgY2hhcl9jb3VudDIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICBwb3N0cGF0Y2hfdGV4dC5zdWJzdHJpbmcoY2hhcl9jb3VudDIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmX3RleHQubGVuZ3RoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgIGlmIChkaWZmX3RleHQubGVuZ3RoIDw9IDIgKiB0aGlzLlBhdGNoX01hcmdpbiAmJlxuICAgICAgICAgICAgcGF0Y2hEaWZmTGVuZ3RoICYmIGRpZmZzLmxlbmd0aCAhPSB4ICsgMSkge1xuICAgICAgICAgIC8vIFNtYWxsIGVxdWFsaXR5IGluc2lkZSBhIHBhdGNoLlxuICAgICAgICAgIHBhdGNoLmRpZmZzW3BhdGNoRGlmZkxlbmd0aCsrXSA9IGRpZmZzW3hdO1xuICAgICAgICAgIHBhdGNoLmxlbmd0aDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBwYXRjaC5sZW5ndGgyICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSBpZiAoZGlmZl90ZXh0Lmxlbmd0aCA+PSAyICogdGhpcy5QYXRjaF9NYXJnaW4pIHtcbiAgICAgICAgICAvLyBUaW1lIGZvciBhIG5ldyBwYXRjaC5cbiAgICAgICAgICBpZiAocGF0Y2hEaWZmTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnBhdGNoX2FkZENvbnRleHQocGF0Y2gsIHByZXBhdGNoX3RleHQpO1xuICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHBhdGNoKTtcbiAgICAgICAgICAgIHBhdGNoID0gbmV3IHBhdGNoX29iaigpO1xuICAgICAgICAgICAgcGF0Y2hEaWZmTGVuZ3RoID0gMDtcbiAgICAgICAgICAgIC8vIFVubGlrZSBVbmlkaWZmLCBvdXIgcGF0Y2ggbGlzdHMgaGF2ZSBhIHJvbGxpbmcgY29udGV4dC5cbiAgICAgICAgICAgIC8vIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9nb29nbGUtZGlmZi1tYXRjaC1wYXRjaC93aWtpL1VuaWRpZmZcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBwcmVwYXRjaCB0ZXh0ICYgcG9zIHRvIHJlZmxlY3QgdGhlIGFwcGxpY2F0aW9uIG9mIHRoZVxuICAgICAgICAgICAgLy8ganVzdCBjb21wbGV0ZWQgcGF0Y2guXG4gICAgICAgICAgICBwcmVwYXRjaF90ZXh0ID0gcG9zdHBhdGNoX3RleHQ7XG4gICAgICAgICAgICBjaGFyX2NvdW50MSA9IGNoYXJfY291bnQyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGNvdW50LlxuICAgIGlmIChkaWZmX3R5cGUgIT09IERJRkZfSU5TRVJUKSB7XG4gICAgICBjaGFyX2NvdW50MSArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAoZGlmZl90eXBlICE9PSBESUZGX0RFTEVURSkge1xuICAgICAgY2hhcl9jb3VudDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgLy8gUGljayB1cCB0aGUgbGVmdG92ZXIgcGF0Y2ggaWYgbm90IGVtcHR5LlxuICBpZiAocGF0Y2hEaWZmTGVuZ3RoKSB7XG4gICAgdGhpcy5wYXRjaF9hZGRDb250ZXh0KHBhdGNoLCBwcmVwYXRjaF90ZXh0KTtcbiAgICBwYXRjaGVzLnB1c2gocGF0Y2gpO1xuICB9XG5cbiAgcmV0dXJuIHBhdGNoZXM7XG59O1xuXG5cbi8qKlxuICogR2l2ZW4gYW4gYXJyYXkgb2YgcGF0Y2hlcywgcmV0dXJuIGFub3RoZXIgYXJyYXkgdGhhdCBpcyBpZGVudGljYWwuXG4gKiBAcGFyYW0ge0FycmF5LjxwYXRjaF9vYmo+fSBwYXRjaGVzIEFycmF5IG9mIHBhdGNoIG9iamVjdHMuXG4gKiBAcmV0dXJuIHtBcnJheS48cGF0Y2hfb2JqPn0gQXJyYXkgb2YgcGF0Y2ggb2JqZWN0cy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUucGF0Y2hfZGVlcENvcHkgPSBmdW5jdGlvbihwYXRjaGVzKSB7XG4gIC8vIE1ha2luZyBkZWVwIGNvcGllcyBpcyBoYXJkIGluIEphdmFTY3JpcHQuXG4gIHZhciBwYXRjaGVzQ29weSA9IFtdO1xuICBmb3IgKHZhciB4ID0gMDsgeCA8IHBhdGNoZXMubGVuZ3RoOyB4KyspIHtcbiAgICB2YXIgcGF0Y2ggPSBwYXRjaGVzW3hdO1xuICAgIHZhciBwYXRjaENvcHkgPSBuZXcgcGF0Y2hfb2JqKCk7XG4gICAgcGF0Y2hDb3B5LmRpZmZzID0gW107XG4gICAgZm9yICh2YXIgeSA9IDA7IHkgPCBwYXRjaC5kaWZmcy5sZW5ndGg7IHkrKykge1xuICAgICAgcGF0Y2hDb3B5LmRpZmZzW3ldID0gcGF0Y2guZGlmZnNbeV0uc2xpY2UoKTtcbiAgICB9XG4gICAgcGF0Y2hDb3B5LnN0YXJ0MSA9IHBhdGNoLnN0YXJ0MTtcbiAgICBwYXRjaENvcHkuc3RhcnQyID0gcGF0Y2guc3RhcnQyO1xuICAgIHBhdGNoQ29weS5sZW5ndGgxID0gcGF0Y2gubGVuZ3RoMTtcbiAgICBwYXRjaENvcHkubGVuZ3RoMiA9IHBhdGNoLmxlbmd0aDI7XG4gICAgcGF0Y2hlc0NvcHlbeF0gPSBwYXRjaENvcHk7XG4gIH1cbiAgcmV0dXJuIHBhdGNoZXNDb3B5O1xufTtcblxuXG4vKipcbiAqIE1lcmdlIGEgc2V0IG9mIHBhdGNoZXMgb250byB0aGUgdGV4dC4gIFJldHVybiBhIHBhdGNoZWQgdGV4dCwgYXMgd2VsbFxuICogYXMgYSBsaXN0IG9mIHRydWUvZmFsc2UgdmFsdWVzIGluZGljYXRpbmcgd2hpY2ggcGF0Y2hlcyB3ZXJlIGFwcGxpZWQuXG4gKiBAcGFyYW0ge0FycmF5LjxwYXRjaF9vYmo+fSBwYXRjaGVzIEFycmF5IG9mIHBhdGNoIG9iamVjdHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBPbGQgdGV4dC5cbiAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmd8QXJyYXkuPGJvb2xlYW4+Pn0gVHdvIGVsZW1lbnQgQXJyYXksIGNvbnRhaW5pbmcgdGhlXG4gKiAgICAgIG5ldyB0ZXh0IGFuZCBhbiBhcnJheSBvZiBib29sZWFuIHZhbHVlcy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUucGF0Y2hfYXBwbHkgPSBmdW5jdGlvbihwYXRjaGVzLCB0ZXh0KSB7XG4gIGlmIChwYXRjaGVzLmxlbmd0aCA9PSAwKSB7XG4gICAgcmV0dXJuIFt0ZXh0LCBbXV07XG4gIH1cblxuICAvLyBEZWVwIGNvcHkgdGhlIHBhdGNoZXMgc28gdGhhdCBubyBjaGFuZ2VzIGFyZSBtYWRlIHRvIG9yaWdpbmFscy5cbiAgcGF0Y2hlcyA9IHRoaXMucGF0Y2hfZGVlcENvcHkocGF0Y2hlcyk7XG5cbiAgdmFyIG51bGxQYWRkaW5nID0gdGhpcy5wYXRjaF9hZGRQYWRkaW5nKHBhdGNoZXMpO1xuICB0ZXh0ID0gbnVsbFBhZGRpbmcgKyB0ZXh0ICsgbnVsbFBhZGRpbmc7XG5cbiAgdGhpcy5wYXRjaF9zcGxpdE1heChwYXRjaGVzKTtcbiAgLy8gZGVsdGEga2VlcHMgdHJhY2sgb2YgdGhlIG9mZnNldCBiZXR3ZWVuIHRoZSBleHBlY3RlZCBhbmQgYWN0dWFsIGxvY2F0aW9uXG4gIC8vIG9mIHRoZSBwcmV2aW91cyBwYXRjaC4gIElmIHRoZXJlIGFyZSBwYXRjaGVzIGV4cGVjdGVkIGF0IHBvc2l0aW9ucyAxMCBhbmRcbiAgLy8gMjAsIGJ1dCB0aGUgZmlyc3QgcGF0Y2ggd2FzIGZvdW5kIGF0IDEyLCBkZWx0YSBpcyAyIGFuZCB0aGUgc2Vjb25kIHBhdGNoXG4gIC8vIGhhcyBhbiBlZmZlY3RpdmUgZXhwZWN0ZWQgcG9zaXRpb24gb2YgMjIuXG4gIHZhciBkZWx0YSA9IDA7XG4gIHZhciByZXN1bHRzID0gW107XG4gIGZvciAodmFyIHggPSAwOyB4IDwgcGF0Y2hlcy5sZW5ndGg7IHgrKykge1xuICAgIHZhciBleHBlY3RlZF9sb2MgPSBwYXRjaGVzW3hdLnN0YXJ0MiArIGRlbHRhO1xuICAgIHZhciB0ZXh0MSA9IHRoaXMuZGlmZl90ZXh0MShwYXRjaGVzW3hdLmRpZmZzKTtcbiAgICB2YXIgc3RhcnRfbG9jO1xuICAgIHZhciBlbmRfbG9jID0gLTE7XG4gICAgaWYgKHRleHQxLmxlbmd0aCA+IHRoaXMuTWF0Y2hfTWF4Qml0cykge1xuICAgICAgLy8gcGF0Y2hfc3BsaXRNYXggd2lsbCBvbmx5IHByb3ZpZGUgYW4gb3ZlcnNpemVkIHBhdHRlcm4gaW4gdGhlIGNhc2Ugb2ZcbiAgICAgIC8vIGEgbW9uc3RlciBkZWxldGUuXG4gICAgICBzdGFydF9sb2MgPSB0aGlzLm1hdGNoX21haW4odGV4dCwgdGV4dDEuc3Vic3RyaW5nKDAsIHRoaXMuTWF0Y2hfTWF4Qml0cyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWRfbG9jKTtcbiAgICAgIGlmIChzdGFydF9sb2MgIT0gLTEpIHtcbiAgICAgICAgZW5kX2xvYyA9IHRoaXMubWF0Y2hfbWFpbih0ZXh0LFxuICAgICAgICAgICAgdGV4dDEuc3Vic3RyaW5nKHRleHQxLmxlbmd0aCAtIHRoaXMuTWF0Y2hfTWF4Qml0cyksXG4gICAgICAgICAgICBleHBlY3RlZF9sb2MgKyB0ZXh0MS5sZW5ndGggLSB0aGlzLk1hdGNoX01heEJpdHMpO1xuICAgICAgICBpZiAoZW5kX2xvYyA9PSAtMSB8fCBzdGFydF9sb2MgPj0gZW5kX2xvYykge1xuICAgICAgICAgIC8vIENhbid0IGZpbmQgdmFsaWQgdHJhaWxpbmcgY29udGV4dC4gIERyb3AgdGhpcyBwYXRjaC5cbiAgICAgICAgICBzdGFydF9sb2MgPSAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydF9sb2MgPSB0aGlzLm1hdGNoX21haW4odGV4dCwgdGV4dDEsIGV4cGVjdGVkX2xvYyk7XG4gICAgfVxuICAgIGlmIChzdGFydF9sb2MgPT0gLTEpIHtcbiAgICAgIC8vIE5vIG1hdGNoIGZvdW5kLiAgOihcbiAgICAgIHJlc3VsdHNbeF0gPSBmYWxzZTtcbiAgICAgIC8vIFN1YnRyYWN0IHRoZSBkZWx0YSBmb3IgdGhpcyBmYWlsZWQgcGF0Y2ggZnJvbSBzdWJzZXF1ZW50IHBhdGNoZXMuXG4gICAgICBkZWx0YSAtPSBwYXRjaGVzW3hdLmxlbmd0aDIgLSBwYXRjaGVzW3hdLmxlbmd0aDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvdW5kIGEgbWF0Y2guICA6KVxuICAgICAgcmVzdWx0c1t4XSA9IHRydWU7XG4gICAgICBkZWx0YSA9IHN0YXJ0X2xvYyAtIGV4cGVjdGVkX2xvYztcbiAgICAgIHZhciB0ZXh0MjtcbiAgICAgIGlmIChlbmRfbG9jID09IC0xKSB7XG4gICAgICAgIHRleHQyID0gdGV4dC5zdWJzdHJpbmcoc3RhcnRfbG9jLCBzdGFydF9sb2MgKyB0ZXh0MS5sZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dDIgPSB0ZXh0LnN1YnN0cmluZyhzdGFydF9sb2MsIGVuZF9sb2MgKyB0aGlzLk1hdGNoX01heEJpdHMpO1xuICAgICAgfVxuICAgICAgaWYgKHRleHQxID09IHRleHQyKSB7XG4gICAgICAgIC8vIFBlcmZlY3QgbWF0Y2gsIGp1c3Qgc2hvdmUgdGhlIHJlcGxhY2VtZW50IHRleHQgaW4uXG4gICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydF9sb2MpICtcbiAgICAgICAgICAgICAgIHRoaXMuZGlmZl90ZXh0MihwYXRjaGVzW3hdLmRpZmZzKSArXG4gICAgICAgICAgICAgICB0ZXh0LnN1YnN0cmluZyhzdGFydF9sb2MgKyB0ZXh0MS5sZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSW1wZXJmZWN0IG1hdGNoLiAgUnVuIGEgZGlmZiB0byBnZXQgYSBmcmFtZXdvcmsgb2YgZXF1aXZhbGVudFxuICAgICAgICAvLyBpbmRpY2VzLlxuICAgICAgICB2YXIgZGlmZnMgPSB0aGlzLmRpZmZfbWFpbih0ZXh0MSwgdGV4dDIsIGZhbHNlKTtcbiAgICAgICAgaWYgKHRleHQxLmxlbmd0aCA+IHRoaXMuTWF0Y2hfTWF4Qml0cyAmJlxuICAgICAgICAgICAgdGhpcy5kaWZmX2xldmVuc2h0ZWluKGRpZmZzKSAvIHRleHQxLmxlbmd0aCA+XG4gICAgICAgICAgICB0aGlzLlBhdGNoX0RlbGV0ZVRocmVzaG9sZCkge1xuICAgICAgICAgIC8vIFRoZSBlbmQgcG9pbnRzIG1hdGNoLCBidXQgdGhlIGNvbnRlbnQgaXMgdW5hY2NlcHRhYmx5IGJhZC5cbiAgICAgICAgICByZXN1bHRzW3hdID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kaWZmX2NsZWFudXBTZW1hbnRpY0xvc3NsZXNzKGRpZmZzKTtcbiAgICAgICAgICB2YXIgaW5kZXgxID0gMDtcbiAgICAgICAgICB2YXIgaW5kZXgyO1xuICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgcGF0Y2hlc1t4XS5kaWZmcy5sZW5ndGg7IHkrKykge1xuICAgICAgICAgICAgdmFyIG1vZCA9IHBhdGNoZXNbeF0uZGlmZnNbeV07XG4gICAgICAgICAgICBpZiAobW9kWzBdICE9PSBESUZGX0VRVUFMKSB7XG4gICAgICAgICAgICAgIGluZGV4MiA9IHRoaXMuZGlmZl94SW5kZXgoZGlmZnMsIGluZGV4MSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW9kWzBdID09PSBESUZGX0lOU0VSVCkgeyAgLy8gSW5zZXJ0aW9uXG4gICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydF9sb2MgKyBpbmRleDIpICsgbW9kWzFdICtcbiAgICAgICAgICAgICAgICAgICAgIHRleHQuc3Vic3RyaW5nKHN0YXJ0X2xvYyArIGluZGV4Mik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1vZFswXSA9PT0gRElGRl9ERUxFVEUpIHsgIC8vIERlbGV0aW9uXG4gICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydF9sb2MgKyBpbmRleDIpICtcbiAgICAgICAgICAgICAgICAgICAgIHRleHQuc3Vic3RyaW5nKHN0YXJ0X2xvYyArIHRoaXMuZGlmZl94SW5kZXgoZGlmZnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgxICsgbW9kWzFdLmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vZFswXSAhPT0gRElGRl9ERUxFVEUpIHtcbiAgICAgICAgICAgICAgaW5kZXgxICs9IG1vZFsxXS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIFN0cmlwIHRoZSBwYWRkaW5nIG9mZi5cbiAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKG51bGxQYWRkaW5nLmxlbmd0aCwgdGV4dC5sZW5ndGggLSBudWxsUGFkZGluZy5sZW5ndGgpO1xuICByZXR1cm4gW3RleHQsIHJlc3VsdHNdO1xufTtcblxuXG4vKipcbiAqIEFkZCBzb21lIHBhZGRpbmcgb24gdGV4dCBzdGFydCBhbmQgZW5kIHNvIHRoYXQgZWRnZXMgY2FuIG1hdGNoIHNvbWV0aGluZy5cbiAqIEludGVuZGVkIHRvIGJlIGNhbGxlZCBvbmx5IGZyb20gd2l0aGluIHBhdGNoX2FwcGx5LlxuICogQHBhcmFtIHtBcnJheS48cGF0Y2hfb2JqPn0gcGF0Y2hlcyBBcnJheSBvZiBwYXRjaCBvYmplY3RzLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgcGFkZGluZyBzdHJpbmcgYWRkZWQgdG8gZWFjaCBzaWRlLlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5wYXRjaF9hZGRQYWRkaW5nID0gZnVuY3Rpb24ocGF0Y2hlcykge1xuICB2YXIgcGFkZGluZ0xlbmd0aCA9IHRoaXMuUGF0Y2hfTWFyZ2luO1xuICB2YXIgbnVsbFBhZGRpbmcgPSAnJztcbiAgZm9yICh2YXIgeCA9IDE7IHggPD0gcGFkZGluZ0xlbmd0aDsgeCsrKSB7XG4gICAgbnVsbFBhZGRpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh4KTtcbiAgfVxuXG4gIC8vIEJ1bXAgYWxsIHRoZSBwYXRjaGVzIGZvcndhcmQuXG4gIGZvciAodmFyIHggPSAwOyB4IDwgcGF0Y2hlcy5sZW5ndGg7IHgrKykge1xuICAgIHBhdGNoZXNbeF0uc3RhcnQxICs9IHBhZGRpbmdMZW5ndGg7XG4gICAgcGF0Y2hlc1t4XS5zdGFydDIgKz0gcGFkZGluZ0xlbmd0aDtcbiAgfVxuXG4gIC8vIEFkZCBzb21lIHBhZGRpbmcgb24gc3RhcnQgb2YgZmlyc3QgZGlmZi5cbiAgdmFyIHBhdGNoID0gcGF0Y2hlc1swXTtcbiAgdmFyIGRpZmZzID0gcGF0Y2guZGlmZnM7XG4gIGlmIChkaWZmcy5sZW5ndGggPT0gMCB8fCBkaWZmc1swXVswXSAhPSBESUZGX0VRVUFMKSB7XG4gICAgLy8gQWRkIG51bGxQYWRkaW5nIGVxdWFsaXR5LlxuICAgIGRpZmZzLnVuc2hpZnQoW0RJRkZfRVFVQUwsIG51bGxQYWRkaW5nXSk7XG4gICAgcGF0Y2guc3RhcnQxIC09IHBhZGRpbmdMZW5ndGg7ICAvLyBTaG91bGQgYmUgMC5cbiAgICBwYXRjaC5zdGFydDIgLT0gcGFkZGluZ0xlbmd0aDsgIC8vIFNob3VsZCBiZSAwLlxuICAgIHBhdGNoLmxlbmd0aDEgKz0gcGFkZGluZ0xlbmd0aDtcbiAgICBwYXRjaC5sZW5ndGgyICs9IHBhZGRpbmdMZW5ndGg7XG4gIH0gZWxzZSBpZiAocGFkZGluZ0xlbmd0aCA+IGRpZmZzWzBdWzFdLmxlbmd0aCkge1xuICAgIC8vIEdyb3cgZmlyc3QgZXF1YWxpdHkuXG4gICAgdmFyIGV4dHJhTGVuZ3RoID0gcGFkZGluZ0xlbmd0aCAtIGRpZmZzWzBdWzFdLmxlbmd0aDtcbiAgICBkaWZmc1swXVsxXSA9IG51bGxQYWRkaW5nLnN1YnN0cmluZyhkaWZmc1swXVsxXS5sZW5ndGgpICsgZGlmZnNbMF1bMV07XG4gICAgcGF0Y2guc3RhcnQxIC09IGV4dHJhTGVuZ3RoO1xuICAgIHBhdGNoLnN0YXJ0MiAtPSBleHRyYUxlbmd0aDtcbiAgICBwYXRjaC5sZW5ndGgxICs9IGV4dHJhTGVuZ3RoO1xuICAgIHBhdGNoLmxlbmd0aDIgKz0gZXh0cmFMZW5ndGg7XG4gIH1cblxuICAvLyBBZGQgc29tZSBwYWRkaW5nIG9uIGVuZCBvZiBsYXN0IGRpZmYuXG4gIHBhdGNoID0gcGF0Y2hlc1twYXRjaGVzLmxlbmd0aCAtIDFdO1xuICBkaWZmcyA9IHBhdGNoLmRpZmZzO1xuICBpZiAoZGlmZnMubGVuZ3RoID09IDAgfHwgZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMF0gIT0gRElGRl9FUVVBTCkge1xuICAgIC8vIEFkZCBudWxsUGFkZGluZyBlcXVhbGl0eS5cbiAgICBkaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBudWxsUGFkZGluZ10pO1xuICAgIHBhdGNoLmxlbmd0aDEgKz0gcGFkZGluZ0xlbmd0aDtcbiAgICBwYXRjaC5sZW5ndGgyICs9IHBhZGRpbmdMZW5ndGg7XG4gIH0gZWxzZSBpZiAocGFkZGluZ0xlbmd0aCA+IGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzFdLmxlbmd0aCkge1xuICAgIC8vIEdyb3cgbGFzdCBlcXVhbGl0eS5cbiAgICB2YXIgZXh0cmFMZW5ndGggPSBwYWRkaW5nTGVuZ3RoIC0gZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0ubGVuZ3RoO1xuICAgIGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzFdICs9IG51bGxQYWRkaW5nLnN1YnN0cmluZygwLCBleHRyYUxlbmd0aCk7XG4gICAgcGF0Y2gubGVuZ3RoMSArPSBleHRyYUxlbmd0aDtcbiAgICBwYXRjaC5sZW5ndGgyICs9IGV4dHJhTGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIG51bGxQYWRkaW5nO1xufTtcblxuXG4vKipcbiAqIExvb2sgdGhyb3VnaCB0aGUgcGF0Y2hlcyBhbmQgYnJlYWsgdXAgYW55IHdoaWNoIGFyZSBsb25nZXIgdGhhbiB0aGUgbWF4aW11bVxuICogbGltaXQgb2YgdGhlIG1hdGNoIGFsZ29yaXRobS5cbiAqIEBwYXJhbSB7QXJyYXkuPHBhdGNoX29iaj59IHBhdGNoZXMgQXJyYXkgb2YgcGF0Y2ggb2JqZWN0cy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUucGF0Y2hfc3BsaXRNYXggPSBmdW5jdGlvbihwYXRjaGVzKSB7XG4gIGZvciAodmFyIHggPSAwOyB4IDwgcGF0Y2hlcy5sZW5ndGg7IHgrKykge1xuICAgIGlmIChwYXRjaGVzW3hdLmxlbmd0aDEgPiB0aGlzLk1hdGNoX01heEJpdHMpIHtcbiAgICAgIHZhciBiaWdwYXRjaCA9IHBhdGNoZXNbeF07XG4gICAgICAvLyBSZW1vdmUgdGhlIGJpZyBvbGQgcGF0Y2guXG4gICAgICBwYXRjaGVzLnNwbGljZSh4LS0sIDEpO1xuICAgICAgdmFyIHBhdGNoX3NpemUgPSB0aGlzLk1hdGNoX01heEJpdHM7XG4gICAgICB2YXIgc3RhcnQxID0gYmlncGF0Y2guc3RhcnQxO1xuICAgICAgdmFyIHN0YXJ0MiA9IGJpZ3BhdGNoLnN0YXJ0MjtcbiAgICAgIHZhciBwcmVjb250ZXh0ID0gJyc7XG4gICAgICB3aGlsZSAoYmlncGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIC8vIENyZWF0ZSBvbmUgb2Ygc2V2ZXJhbCBzbWFsbGVyIHBhdGNoZXMuXG4gICAgICAgIHZhciBwYXRjaCA9IG5ldyBwYXRjaF9vYmooKTtcbiAgICAgICAgdmFyIGVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgcGF0Y2guc3RhcnQxID0gc3RhcnQxIC0gcHJlY29udGV4dC5sZW5ndGg7XG4gICAgICAgIHBhdGNoLnN0YXJ0MiA9IHN0YXJ0MiAtIHByZWNvbnRleHQubGVuZ3RoO1xuICAgICAgICBpZiAocHJlY29udGV4dCAhPT0gJycpIHtcbiAgICAgICAgICBwYXRjaC5sZW5ndGgxID0gcGF0Y2gubGVuZ3RoMiA9IHByZWNvbnRleHQubGVuZ3RoO1xuICAgICAgICAgIHBhdGNoLmRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIHByZWNvbnRleHRdKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoYmlncGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwICYmXG4gICAgICAgICAgICAgICBwYXRjaC5sZW5ndGgxIDwgcGF0Y2hfc2l6ZSAtIHRoaXMuUGF0Y2hfTWFyZ2luKSB7XG4gICAgICAgICAgdmFyIGRpZmZfdHlwZSA9IGJpZ3BhdGNoLmRpZmZzWzBdWzBdO1xuICAgICAgICAgIHZhciBkaWZmX3RleHQgPSBiaWdwYXRjaC5kaWZmc1swXVsxXTtcbiAgICAgICAgICBpZiAoZGlmZl90eXBlID09PSBESUZGX0lOU0VSVCkge1xuICAgICAgICAgICAgLy8gSW5zZXJ0aW9ucyBhcmUgaGFybWxlc3MuXG4gICAgICAgICAgICBwYXRjaC5sZW5ndGgyICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBzdGFydDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIHBhdGNoLmRpZmZzLnB1c2goYmlncGF0Y2guZGlmZnMuc2hpZnQoKSk7XG4gICAgICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGlmZl90eXBlID09PSBESUZGX0RFTEVURSAmJiBwYXRjaC5kaWZmcy5sZW5ndGggPT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICAgcGF0Y2guZGlmZnNbMF1bMF0gPT0gRElGRl9FUVVBTCAmJlxuICAgICAgICAgICAgICAgICAgICAgZGlmZl90ZXh0Lmxlbmd0aCA+IDIgKiBwYXRjaF9zaXplKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgbGFyZ2UgZGVsZXRpb24uICBMZXQgaXQgcGFzcyBpbiBvbmUgY2h1bmsuXG4gICAgICAgICAgICBwYXRjaC5sZW5ndGgxICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBzdGFydDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKFtkaWZmX3R5cGUsIGRpZmZfdGV4dF0pO1xuICAgICAgICAgICAgYmlncGF0Y2guZGlmZnMuc2hpZnQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRGVsZXRpb24gb3IgZXF1YWxpdHkuICBPbmx5IHRha2UgYXMgbXVjaCBhcyB3ZSBjYW4gc3RvbWFjaC5cbiAgICAgICAgICAgIGRpZmZfdGV4dCA9IGRpZmZfdGV4dC5zdWJzdHJpbmcoMCwgcGF0Y2hfc2l6ZSAtIHBhdGNoLmxlbmd0aDEgLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLlBhdGNoX01hcmdpbik7XG4gICAgICAgICAgICBwYXRjaC5sZW5ndGgxICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBzdGFydDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChkaWZmX3R5cGUgPT09IERJRkZfRVFVQUwpIHtcbiAgICAgICAgICAgICAgcGF0Y2gubGVuZ3RoMiArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgICAgICAgICAgICBzdGFydDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKFtkaWZmX3R5cGUsIGRpZmZfdGV4dF0pO1xuICAgICAgICAgICAgaWYgKGRpZmZfdGV4dCA9PSBiaWdwYXRjaC5kaWZmc1swXVsxXSkge1xuICAgICAgICAgICAgICBiaWdwYXRjaC5kaWZmcy5zaGlmdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYmlncGF0Y2guZGlmZnNbMF1bMV0gPVxuICAgICAgICAgICAgICAgICAgYmlncGF0Y2guZGlmZnNbMF1bMV0uc3Vic3RyaW5nKGRpZmZfdGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlIHRoZSBoZWFkIGNvbnRleHQgZm9yIHRoZSBuZXh0IHBhdGNoLlxuICAgICAgICBwcmVjb250ZXh0ID0gdGhpcy5kaWZmX3RleHQyKHBhdGNoLmRpZmZzKTtcbiAgICAgICAgcHJlY29udGV4dCA9XG4gICAgICAgICAgICBwcmVjb250ZXh0LnN1YnN0cmluZyhwcmVjb250ZXh0Lmxlbmd0aCAtIHRoaXMuUGF0Y2hfTWFyZ2luKTtcbiAgICAgICAgLy8gQXBwZW5kIHRoZSBlbmQgY29udGV4dCBmb3IgdGhpcyBwYXRjaC5cbiAgICAgICAgdmFyIHBvc3Rjb250ZXh0ID0gdGhpcy5kaWZmX3RleHQxKGJpZ3BhdGNoLmRpZmZzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN1YnN0cmluZygwLCB0aGlzLlBhdGNoX01hcmdpbik7XG4gICAgICAgIGlmIChwb3N0Y29udGV4dCAhPT0gJycpIHtcbiAgICAgICAgICBwYXRjaC5sZW5ndGgxICs9IHBvc3Rjb250ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBwYXRjaC5sZW5ndGgyICs9IHBvc3Rjb250ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBpZiAocGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwICYmXG4gICAgICAgICAgICAgIHBhdGNoLmRpZmZzW3BhdGNoLmRpZmZzLmxlbmd0aCAtIDFdWzBdID09PSBESUZGX0VRVUFMKSB7XG4gICAgICAgICAgICBwYXRjaC5kaWZmc1twYXRjaC5kaWZmcy5sZW5ndGggLSAxXVsxXSArPSBwb3N0Y29udGV4dDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0Y2guZGlmZnMucHVzaChbRElGRl9FUVVBTCwgcG9zdGNvbnRleHRdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlbXB0eSkge1xuICAgICAgICAgIHBhdGNoZXMuc3BsaWNlKCsreCwgMCwgcGF0Y2gpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogVGFrZSBhIGxpc3Qgb2YgcGF0Y2hlcyBhbmQgcmV0dXJuIGEgdGV4dHVhbCByZXByZXNlbnRhdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXkuPHBhdGNoX29iaj59IHBhdGNoZXMgQXJyYXkgb2YgcGF0Y2ggb2JqZWN0cy5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGV4dCByZXByZXNlbnRhdGlvbiBvZiBwYXRjaGVzLlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5wYXRjaF90b1RleHQgPSBmdW5jdGlvbihwYXRjaGVzKSB7XG4gIHZhciB0ZXh0ID0gW107XG4gIGZvciAodmFyIHggPSAwOyB4IDwgcGF0Y2hlcy5sZW5ndGg7IHgrKykge1xuICAgIHRleHRbeF0gPSBwYXRjaGVzW3hdO1xuICB9XG4gIHJldHVybiB0ZXh0LmpvaW4oJycpO1xufTtcblxuXG4vKipcbiAqIFBhcnNlIGEgdGV4dHVhbCByZXByZXNlbnRhdGlvbiBvZiBwYXRjaGVzIGFuZCByZXR1cm4gYSBsaXN0IG9mIHBhdGNoIG9iamVjdHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dGxpbmUgVGV4dCByZXByZXNlbnRhdGlvbiBvZiBwYXRjaGVzLlxuICogQHJldHVybiB7QXJyYXkuPHBhdGNoX29iaj59IEFycmF5IG9mIHBhdGNoIG9iamVjdHMuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgaW52YWxpZCBpbnB1dC5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUucGF0Y2hfZnJvbVRleHQgPSBmdW5jdGlvbih0ZXh0bGluZSkge1xuICB2YXIgcGF0Y2hlcyA9IFtdO1xuICBpZiAoIXRleHRsaW5lKSB7XG4gICAgcmV0dXJuIHBhdGNoZXM7XG4gIH1cbiAgLy8gT3BlcmEgZG9lc24ndCBrbm93IGhvdyB0byBkZWNvZGUgY2hhciAwLlxuICB0ZXh0bGluZSA9IHRleHRsaW5lLnJlcGxhY2UoLyUwMC9nLCAnXFwwJyk7XG4gIHZhciB0ZXh0ID0gdGV4dGxpbmUuc3BsaXQoJ1xcbicpO1xuICB2YXIgdGV4dFBvaW50ZXIgPSAwO1xuICB3aGlsZSAodGV4dFBvaW50ZXIgPCB0ZXh0Lmxlbmd0aCkge1xuICAgIHZhciBtID0gdGV4dFt0ZXh0UG9pbnRlcl0ubWF0Y2goL15AQCAtKFxcZCspLD8oXFxkKikgXFwrKFxcZCspLD8oXFxkKikgQEAkLyk7XG4gICAgaWYgKCFtKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGF0Y2ggc3RyaW5nOiAnICsgdGV4dFt0ZXh0UG9pbnRlcl0pO1xuICAgIH1cbiAgICB2YXIgcGF0Y2ggPSBuZXcgcGF0Y2hfb2JqKCk7XG4gICAgcGF0Y2hlcy5wdXNoKHBhdGNoKTtcbiAgICBwYXRjaC5zdGFydDEgPSBwYXJzZUludChtWzFdLCAxMCk7XG4gICAgaWYgKG1bMl0gPT09ICcnKSB7XG4gICAgICBwYXRjaC5zdGFydDEtLTtcbiAgICAgIHBhdGNoLmxlbmd0aDEgPSAxO1xuICAgIH0gZWxzZSBpZiAobVsyXSA9PSAnMCcpIHtcbiAgICAgIHBhdGNoLmxlbmd0aDEgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRjaC5zdGFydDEtLTtcbiAgICAgIHBhdGNoLmxlbmd0aDEgPSBwYXJzZUludChtWzJdLCAxMCk7XG4gICAgfVxuXG4gICAgcGF0Y2guc3RhcnQyID0gcGFyc2VJbnQobVszXSwgMTApO1xuICAgIGlmIChtWzRdID09PSAnJykge1xuICAgICAgcGF0Y2guc3RhcnQyLS07XG4gICAgICBwYXRjaC5sZW5ndGgyID0gMTtcbiAgICB9IGVsc2UgaWYgKG1bNF0gPT0gJzAnKSB7XG4gICAgICBwYXRjaC5sZW5ndGgyID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0Y2guc3RhcnQyLS07XG4gICAgICBwYXRjaC5sZW5ndGgyID0gcGFyc2VJbnQobVs0XSwgMTApO1xuICAgIH1cbiAgICB0ZXh0UG9pbnRlcisrO1xuXG4gICAgd2hpbGUgKHRleHRQb2ludGVyIDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgIHZhciBzaWduID0gdGV4dFt0ZXh0UG9pbnRlcl0uY2hhckF0KDApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGxpbmUgPSBkZWNvZGVVUkkodGV4dFt0ZXh0UG9pbnRlcl0uc3Vic3RyaW5nKDEpKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIC8vIE1hbGZvcm1lZCBVUkkgc2VxdWVuY2UuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBlc2NhcGUgaW4gcGF0Y2hfZnJvbVRleHQ6ICcgKyBsaW5lKTtcbiAgICAgIH1cbiAgICAgIGlmIChzaWduID09ICctJykge1xuICAgICAgICAvLyBEZWxldGlvbi5cbiAgICAgICAgcGF0Y2guZGlmZnMucHVzaChbRElGRl9ERUxFVEUsIGxpbmVdKTtcbiAgICAgIH0gZWxzZSBpZiAoc2lnbiA9PSAnKycpIHtcbiAgICAgICAgLy8gSW5zZXJ0aW9uLlxuICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0lOU0VSVCwgbGluZV0pO1xuICAgICAgfSBlbHNlIGlmIChzaWduID09ICcgJykge1xuICAgICAgICAvLyBNaW5vciBlcXVhbGl0eS5cbiAgICAgICAgcGF0Y2guZGlmZnMucHVzaChbRElGRl9FUVVBTCwgbGluZV0pO1xuICAgICAgfSBlbHNlIGlmIChzaWduID09ICdAJykge1xuICAgICAgICAvLyBTdGFydCBvZiBuZXh0IHBhdGNoLlxuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoc2lnbiA9PT0gJycpIHtcbiAgICAgICAgLy8gQmxhbmsgbGluZT8gIFdoYXRldmVyLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV1RGP1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGF0Y2ggbW9kZSBcIicgKyBzaWduICsgJ1wiIGluOiAnICsgbGluZSk7XG4gICAgICB9XG4gICAgICB0ZXh0UG9pbnRlcisrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGF0Y2hlcztcbn07XG5cblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgb25lIHBhdGNoIG9wZXJhdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBwYXRjaF9vYmooKSB7XG4gIC8qKiBAdHlwZSB7QXJyYXkuPEFycmF5LjxudW1iZXJ8c3RyaW5nPj59ICovXG4gIHRoaXMuZGlmZnMgPSBbXTtcbiAgLyoqIEB0eXBlIHs/bnVtYmVyfSAqL1xuICB0aGlzLnN0YXJ0MSA9IG51bGw7XG4gIC8qKiBAdHlwZSB7P251bWJlcn0gKi9cbiAgdGhpcy5zdGFydDIgPSBudWxsO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdGhpcy5sZW5ndGgxID0gMDtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHRoaXMubGVuZ3RoMiA9IDA7XG59XG5cblxuLyoqXG4gKiBFbW11bGF0ZSBHTlUgZGlmZidzIGZvcm1hdC5cbiAqIEhlYWRlcjogQEAgLTM4Miw4ICs0ODEsOSBAQFxuICogSW5kaWNpZXMgYXJlIHByaW50ZWQgYXMgMS1iYXNlZCwgbm90IDAtYmFzZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBHTlUgZGlmZiBzdHJpbmcuXG4gKi9cbnBhdGNoX29iai5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNvb3JkczEsIGNvb3JkczI7XG4gIGlmICh0aGlzLmxlbmd0aDEgPT09IDApIHtcbiAgICBjb29yZHMxID0gdGhpcy5zdGFydDEgKyAnLDAnO1xuICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoMSA9PSAxKSB7XG4gICAgY29vcmRzMSA9IHRoaXMuc3RhcnQxICsgMTtcbiAgfSBlbHNlIHtcbiAgICBjb29yZHMxID0gKHRoaXMuc3RhcnQxICsgMSkgKyAnLCcgKyB0aGlzLmxlbmd0aDE7XG4gIH1cbiAgaWYgKHRoaXMubGVuZ3RoMiA9PT0gMCkge1xuICAgIGNvb3JkczIgPSB0aGlzLnN0YXJ0MiArICcsMCc7XG4gIH0gZWxzZSBpZiAodGhpcy5sZW5ndGgyID09IDEpIHtcbiAgICBjb29yZHMyID0gdGhpcy5zdGFydDIgKyAxO1xuICB9IGVsc2Uge1xuICAgIGNvb3JkczIgPSAodGhpcy5zdGFydDIgKyAxKSArICcsJyArIHRoaXMubGVuZ3RoMjtcbiAgfVxuICB2YXIgdGV4dCA9IFsnQEAgLScgKyBjb29yZHMxICsgJyArJyArIGNvb3JkczIgKyAnIEBAXFxuJ107XG4gIHZhciBvcDtcbiAgLy8gRXNjYXBlIHRoZSBib2R5IG9mIHRoZSBwYXRjaCB3aXRoICV4eCBub3RhdGlvbi5cbiAgZm9yICh2YXIgeCA9IDA7IHggPCB0aGlzLmRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgc3dpdGNoICh0aGlzLmRpZmZzW3hdWzBdKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICBvcCA9ICcrJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxuICAgICAgICBvcCA9ICctJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgIG9wID0gJyAnO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGV4dFt4ICsgMV0gPSBvcCArIGVuY29kZVVSSSh0aGlzLmRpZmZzW3hdWzFdKSArICdcXG4nO1xuICB9XG4gIC8vIE9wZXJhIGRvZXNuJ3Qga25vdyBob3cgdG8gZW5jb2RlIGNoYXIgMC5cbiAgcmV0dXJuIHRleHQuam9pbignJykucmVwbGFjZSgvXFx4MDAvZywgJyUwMCcpLnJlcGxhY2UoLyUyMC9nLCAnICcpO1xufTtcblxuXG4vLyBFeHBvcnQgdGhlc2UgZ2xvYmFsIHZhcmlhYmxlcyBzbyB0aGF0IHRoZXkgc3Vydml2ZSBHb29nbGUncyBKUyBjb21waWxlci5cbi8qY2hhbmdlZCBieSBsZmJvcmphczogY2hhbmdlZCBgd2luZG93YCBmb3IgYGV4cG9ydHNgIHRvIG1ha2UgaXQgc3VpdGFibGUgZm9yIHRoZSBub2RlLmpzIG1vZHVsZSBjb252ZW50aW9ucyovXG5leHBvcnRzWydkaWZmX21hdGNoX3BhdGNoJ10gPSBkaWZmX21hdGNoX3BhdGNoO1xuZXhwb3J0c1sncGF0Y2hfb2JqJ10gPSBwYXRjaF9vYmo7XG5leHBvcnRzWydESUZGX0RFTEVURSddID0gRElGRl9ERUxFVEU7XG5leHBvcnRzWydESUZGX0lOU0VSVCddID0gRElGRl9JTlNFUlQ7XG5leHBvcnRzWydESUZGX0VRVUFMJ10gPSBESUZGX0VRVUFMO1xuIiwiaW1wb3J0IExpbmtlZFJlY29yZHMgZnJvbSAnLi4vLi4vc3JjL2Jyb3dzZXJfc2RrL2luZGV4JztcbmltcG9ydCBMb25nVGV4dEF0dHJpYnV0ZSBmcm9tICcuLi8uLi9zcmMvYXR0cmlidXRlcy9sb25nX3RleHQvY2xpZW50JztcbmltcG9ydCBLZXlWYWx1ZUF0dHJpYnV0ZSBmcm9tICcuLi8uLi9zcmMvYXR0cmlidXRlcy9rZXlfdmFsdWUvY2xpZW50JztcbmltcG9ydCBsckVkaXRvciBmcm9tICcuL2xyRWRpdG9yJztcblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGFzeW5jIChldmVudCkgPT4ge1xuICBjb25zdCBsaW5rZWRSZWNvcmRzID0gbmV3IExpbmtlZFJlY29yZHMobmV3IFVSTCgnaHR0cDovLzEwLjYwLjMuMjE4OjMwMDAnKSk7XG5cbiAgLy8gY29uc3QgY29udGVudCA9IGF3YWl0IGxpbmtlZFJlY29yZHMuQXR0cmlidXRlLmNyZWF0ZSgnbG9uZ1RleHQnLCAnaW5pdGFsJyk7XG4gIC8vIGNvbnNvbGUubG9nKCdOZXcgQ29udGVudElkJywgY29udGVudC5pZCk7XG4gIC8vIGNvbnN0IGNvbnRlbnRJZCA9IGNvbnRlbnQuaWQ7XG5cbiAgY29uc3QgY29udGVudElkID0gJ2wtMzlkNWFiMDctYjU3MS00ZDNiLWFiZjAtMmE1OTc0ZmU0MWRmJztcblxuICBsZXQgeyBjb250ZW50OiBjb250ZW50QXR0cmlidXRlLCByZWZlcm5jZXM6IFsgcmVmZXJlbmNlc0F0dHJpYnV0ZSBdIH0gPSA8e1xuICAgIGNvbnRlbnQ6IExvbmdUZXh0QXR0cmlidXRlLFxuICAgIHJlZmVybmNlczogS2V5VmFsdWVBdHRyaWJ1dGVbXSxcbiAgICByZWZlcmVuY2VTb3VyY2VzOiBLZXlWYWx1ZUF0dHJpYnV0ZVtdXG4gIH0+IDx1bmtub3duPiBhd2FpdCBsaW5rZWRSZWNvcmRzLkF0dHJpYnV0ZS5maW5kQWxsKHtcbiAgICBjb250ZW50OiBjb250ZW50SWQsXG4gICAgcmVmZXJuY2VzOiBbXG4gICAgICBbJ2lzQScsICdyZWZlcmVuY2VTdG9yZSddLFxuICAgICAgWydiZWxvbmdzVG8nLCBjb250ZW50SWRdLFxuICAgIF0sXG4gICAgcmVmZXJlbmNlU291cmNlczogW1xuICAgICAgWydpc0EnLCAncmVmZXJlbmNlU291cmNlU3RvcmUnXSxcbiAgICAgIFsnYmVsb25nc1RvJywgY29udGVudElkXSxcbiAgICAgIFsnYmVsb25nc1RvJywgJ3Vzci14eCddLFxuICAgIF1cbiAgfSk7XG5cbiAgaWYgKCFyZWZlcmVuY2VzQXR0cmlidXRlKSB7XG4gICAgcmVmZXJlbmNlc0F0dHJpYnV0ZSA9IGF3YWl0IGxpbmtlZFJlY29yZHMuQXR0cmlidXRlLmNyZWF0ZSgna2V5VmFsdWUnLCB7fSkgYXMgS2V5VmFsdWVBdHRyaWJ1dGU7XG4gICAgYXdhaXQgbGlua2VkUmVjb3Jkcy5GYWN0LmNyZWF0ZUFsbChbXG4gICAgICBbcmVmZXJlbmNlc0F0dHJpYnV0ZS5pZCwgJ2lzQScsICdyZWZlcmVuY2VTdG9yZSddLFxuICAgICAgW3JlZmVyZW5jZXNBdHRyaWJ1dGUuaWQsICdiZWxvbmdzVG8nLCBjb250ZW50SWRdXG4gICAgXSk7XG4gIH1cblxuICBsckVkaXRvcigndmFsdWUnLCBjb250ZW50QXR0cmlidXRlLCByZWZlcmVuY2VzQXR0cmlidXRlKTtcbn0pO1xuIiwiaW1wb3J0IEVkaXRvciBmcm9tICdzdHJ1Y3R1cmVkLXRleHQtZWRpdG9yL3NyYy9lZGl0b3InO1xuaW1wb3J0IHsgQ2hhbmdlc2V0IH0gZnJvbSAnY2hhbmdlc2V0cyc7XG5pbXBvcnQgTG9uZ1RleHRBdHRyaWJ1dGUgZnJvbSAnLi4vLi4vc3JjL2F0dHJpYnV0ZXMvbG9uZ190ZXh0L2NsaWVudCc7XG5pbXBvcnQgS2V5VmFsdWVBdHRyaWJ1dGUgZnJvbSAnLi4vLi4vc3JjL2F0dHJpYnV0ZXMva2V5X3ZhbHVlL2NsaWVudCc7XG5pbXBvcnQgS2V5VmFsdWVDaGFuZ2UgZnJvbSAnLi4vLi4vc3JjL2F0dHJpYnV0ZXMva2V5X3ZhbHVlL2tleV92YWx1ZV9jaGFuZ2UnO1xuaW1wb3J0IExvbmdUZXh0Q2hhbmdlIGZyb20gJy4uLy4uL3NyYy9hdHRyaWJ1dGVzL2xvbmdfdGV4dC9sb25nX3RleHRfY2hhbmdlJztcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24oZG9tSWQ6IHN0cmluZywgY29udGVudEF0dHJpYnV0ZTogTG9uZ1RleHRBdHRyaWJ1dGUsIHJlZmVyZW5jZXNBdHRyaWJ1dGU6IEtleVZhbHVlQXR0cmlidXRlKSB7XG4gIGNvbnN0IGVkaXRvciA9IG5ldyBFZGl0b3IoZG9tSWQpO1xuICBlZGl0b3Iuc2V0Q29udGVudChhd2FpdCBjb250ZW50QXR0cmlidXRlLmdldFZhbHVlKCkpO1xuICBlZGl0b3IuYWRkUmVmZXJlbmNlRGF0YShhd2FpdCByZWZlcmVuY2VzQXR0cmlidXRlLmdldFZhbHVlKCkpO1xuXG4gIHJlZmVyZW5jZXNBdHRyaWJ1dGUuc3Vic2NyaWJlKGFzeW5jIChjaGFuZ2VzZXQpID0+IHtcbiAgICBjb25zdCBuZXdEYXRhID0ge307XG5cbiAgICBjaGFuZ2VzZXQuY2hhbmdlLmZvckVhY2goKHtrZXksIHZhbHVlfSkgPT4ge1xuICAgICAgbmV3RGF0YVtrZXldID0gdmFsdWU7XG4gICAgfSk7XG5cbiAgICBlZGl0b3IuYWRkUmVmZXJlbmNlRGF0YShuZXdEYXRhKTtcbiAgfSk7XG5cbiAgZWRpdG9yLnN1YnNjcmliZVJlZmVyZW5jZUluc2VydGlvbihhc3luYyAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgIHJlZmVyZW5jZXNBdHRyaWJ1dGUhLmNoYW5nZShuZXcgS2V5VmFsdWVDaGFuZ2UoW3sga2V5LCB2YWx1ZSB9XSkpO1xuICB9KTtcblxuICBjb250ZW50QXR0cmlidXRlLnN1YnNjcmliZShhc3luYyAoY2hhbmdlc2V0LCBjaGFuZ2VJbmZvKSA9PiB7XG4gICAgY29uc3QgYXR0ciA9IHsgYWN0b3I6IHsgaWQ6IGNoYW5nZUluZm8uYWN0b3JJZCB9IH07XG5cbiAgICB0cnkge1xuICAgICAgZWRpdG9yLmFwcGx5Q2hhbmdlc2V0KGNoYW5nZXNldC5jaGFuZ2VzZXQsIGF0dHIpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBjb25zb2xlLmxvZygnZmFpbGVkIHRvIGFwcGx5IGNoYW5nZXNldCB0byBFRElUT1IgY29udGVudC4gRmFsbGluZyBiYWNrIHRvIHJlcGxhY2UgdGhlIHdob2xlIGVkaXRvcnMgY29udGVudCcsIGV4KTtcbiAgICAgIGVkaXRvci5zZXRDb250ZW50KGF3YWl0IGNvbnRlbnRBdHRyaWJ1dGUuZ2V0VmFsdWUoKSwgYXR0cik7XG4gICAgfVxuICB9KTtcblxuICBlZGl0b3Iuc3Vic2NyaWJlKGFzeW5jIChtb2RpZmljYXRpb25Mb2cpID0+IHtcbiAgICBpZiAoIW1vZGlmaWNhdGlvbkxvZy5hY3Rvcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgY29udGVudEF0dHJpYnV0ZS5jaGFuZ2UobmV3IExvbmdUZXh0Q2hhbmdlKG1vZGlmaWNhdGlvbkxvZy50b0NoYW5nZXNldChDaGFuZ2VzZXQpKSk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBjb25zb2xlLmxvZygnZmFpbGVkIHRvIGFwcGx5IGNoYW5nZXNldCB0byBBVFRSSUJVVEUuIEZhbGxpbmcgYmFjayB0byByZXBsYWNlIHdob2xlIGF0dHJpYnV0ZSBjb250ZW50JywgZXgpO1xuICAgICAgICBhd2FpdCBjb250ZW50QXR0cmlidXRlLnNldChlZGl0b3IuZ2V0T3JpZ2luYWxDb250ZW50KCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59IiwiZXhwb3J0IGludGVyZmFjZSBJc1N1YnNjcmliYWJsZSB7XG4gIHN1YnNjcmliZSh1cmw6IHN0cmluZywgY2hhbm5lbDogc3RyaW5nLCBoYW5kbGVyOiAoZGF0YTogYW55KSA9PiBhbnkpO1xuICB1bnN1YnNjcmliZUFsbCgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZXJ2ZXJTaWRlRXZlbnRzIGltcGxlbWVudHMgSXNTdWJzY3JpYmFibGUge1xuICBzdWJzY3JpcHRpb25zID0ge307XG5cbiAgY29ubmV0aW9ucyA9IHt9O1xuXG4gIGlzUGF1c2VkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgbWVzc2FnZXNXaGlsZVBhdXNlZDogeyBjYjogKGRhdGE6IGFueSkgPT4gYW55LCBkYXRhOiBhbnkgfVtdID0gW107XG5cbiAgdGFiSWQ6IHN0cmluZyA9IChNYXRoLnJhbmRvbSgpICsgMSkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KTtcblxuICBwdWJsaWMgZ2V0RXZlbnRTb3VyY2VBc3luYyh1cmw6IFVSTCkge1xuICAgIGlmICghdXJsLnNlYXJjaFBhcmFtcy5oYXMoJ3RhYklkJykpIHtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCd0YWJJZCcsIHRoaXMudGFiSWQpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UodXJsLnRvU3RyaW5nKCkpO1xuXG4gICAgICBzb3VyY2Uub25lcnJvciA9IHJlamVjdDtcbiAgICAgIHNvdXJjZS5vbm9wZW4gPSAoKSA9PiByZXNvbHZlKHNvdXJjZSk7XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgc3Vic2NyaWJlKHVybDogc3RyaW5nLCBjaGFubmVsOiBzdHJpbmcsIGhhbmRsZXI6IChkYXRhOiBhbnkpID0+IGFueSkge1xuICAgIGNvbnN0IHBhcnNlZFVybDogVVJMID0gbmV3IFVSTCh1cmwpO1xuICAgIGNvbnN0IHN1YklkID0gYCR7cGFyc2VkVXJsLm9yaWdpbn0tJHtjaGFubmVsfWA7XG5cbiAgICBpZiAoIXBhcnNlZFVybC5zZWFyY2hQYXJhbXMuaGFzKCd0YWJJZCcpKSB7XG4gICAgICBwYXJzZWRVcmwuc2VhcmNoUGFyYW1zLmFwcGVuZCgndGFiSWQnLCB0aGlzLnRhYklkKTtcbiAgICB9XG5cbiAgICBhd2FpdCB0aGlzLmVuc3VyZUNvbm5lY3Rpb24ocGFyc2VkVXJsLm9yaWdpbik7XG4gICAgYXdhaXQgZmV0Y2gocGFyc2VkVXJsLnRvU3RyaW5nKCkpO1xuXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zW3N1YklkXSA9IHRoaXMuc3Vic2NyaXB0aW9uc1tzdWJJZF0gfHwgW107XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zW3N1YklkXS5wdXNoKGhhbmRsZXIpO1xuICB9XG5cbiAgcHVibGljIHVuc3Vic2NyaWJlQWxsKCkge1xuICAgIE9iamVjdC52YWx1ZXModGhpcy5jb25uZXRpb25zKS5mb3JFYWNoKChjb25uZWN0aW9uOiBhbnkpID0+IHtcbiAgICAgIGNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICB9KTtcblxuICAgIHRoaXMuY29ubmV0aW9ucyA9IHt9O1xuICB9XG5cbiAgcHVibGljIHBhdXNlTm90aWZpY2F0aW9uKCkge1xuICAgIHRoaXMuaXNQYXVzZWQgPSB0cnVlO1xuICB9XG5cbiAgcHVibGljIHVucGF1c2VOb3RpZmljYXRpb24oKSB7XG4gICAgdGhpcy5tZXNzYWdlc1doaWxlUGF1c2VkLmZvckVhY2goKHsgY2IsIGRhdGEgfSkgPT4ge1xuICAgICAgY2IoZGF0YSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLm1lc3NhZ2VzV2hpbGVQYXVzZWQgPSBbXTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZW5zdXJlQ29ubmVjdGlvbihvcmlnaW4pIHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKG9yaWdpbik7XG4gICAgdXJsLnBhdGhuYW1lID0gJy9zZXJ2ZXItc2VudC1ldmVudHMnO1xuXG4gICAgaWYgKCF0aGlzLmNvbm5ldGlvbnNbdXJsLm9yaWdpbl0pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuY29ubmV0aW9uc1t1cmwub3JpZ2luXSA9IGF3YWl0IHRoaXMuZ2V0RXZlbnRTb3VyY2VBc3luYyh1cmwpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgdGhpcy5jb25uZXRpb25zW3VybC5vcmlnaW5dID0gYXdhaXQgdGhpcy5nZXRFdmVudFNvdXJjZUFzeW5jKHVybCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29ubmV0aW9uc1t1cmwub3JpZ2luXS5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgICAgIGNvbnN0IHsgc3NlQ2hhbm5lbCB9ID0gZGF0YTtcblxuICAgICAgICBpZiAoIXNzZUNoYW5uZWwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgZGF0YS5zc2VDaGFubmVsO1xuXG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSB0aGlzLnN1YnNjcmlwdGlvbnNbYCR7dXJsLm9yaWdpbn0tJHtzc2VDaGFubmVsfWBdO1xuXG4gICAgICAgIGlmIChzdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgc3Vic2NyaXB0aW9ucy5mb3JFYWNoKChjYikgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNQYXVzZWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlc1doaWxlUGF1c2VkLnB1c2goeyBjYiwgZGF0YSB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNiKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNvbm5ldGlvbnNbb3JpZ2luXTtcbiAgfVxufVxuIiwiLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L25vLWN5Y2xlICovXG4vKiBlc2xpbnQtZGlzYWJsZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzICovXG5cbmltcG9ydCB7IHY0IGFzIHV1aWQgfSBmcm9tICd1dWlkJztcbmltcG9ydCBMaW5rZWRSZWNvcmRzIGZyb20gJy4uLy4uL2Jyb3dzZXJfc2RrL2luZGV4JztcbmltcG9ydCBTZXJpYWxpemVkQ2hhbmdlV2l0aE1ldGFkYXRhIGZyb20gJy4vc2VyaWFsaXplZF9jaGFuZ2Vfd2l0aF9tZXRhZGF0YSc7XG5pbXBvcnQgSXNTZXJpYWxpemFibGUgZnJvbSAnLi9pc19zZXJpYWxpemFibGUnO1xuaW1wb3J0IHsgSXNTdWJzY3JpYmFibGUgfSBmcm9tICcuLi8uLi8uLi9saWIvc2VydmVyLXNpZGUtZXZlbnRzL2NsaWVudCc7XG5cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIEFic3RyYWN0QXR0cmlidXRlQ2xpZW50IDxUeXBlLCBUeXBlZENoYW5nZSBleHRlbmRzIElzU2VyaWFsaXphYmxlID4ge1xuICBsaW5rZWRSZWNvcmRzOiBMaW5rZWRSZWNvcmRzO1xuXG4gIHNlcnZlclNpZGVFdmVudHM6IElzU3Vic2NyaWJhYmxlO1xuXG4gIGlkPzogc3RyaW5nO1xuXG4gIGFjdG9ySWQ6IHN0cmluZztcblxuICBjbGllbnRJZDogc3RyaW5nO1xuXG4gIHNlcnZlclVSTDogVVJMO1xuXG4gIG9ic2VydmVyczogRnVuY3Rpb25bXTtcblxuICBpc0luaXRpYWxpemVkOiBib29sZWFuO1xuXG4gIHZlcnNpb246IHN0cmluZzsgLy8gVE9ETzogc2hvdWxkIGJlIG51bWJlclxuXG4gIHZhbHVlOiBUeXBlO1xuXG4gIGNvbnN0cnVjdG9yKGxpbmtlZFJlY29yZHM6IExpbmtlZFJlY29yZHMsIHNlcnZlclNpZGVFdmVudHM6IElzU3Vic2NyaWJhYmxlLCBpZD86IHN0cmluZykge1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmxpbmtlZFJlY29yZHMgPSBsaW5rZWRSZWNvcmRzO1xuICAgIHRoaXMuc2VydmVyU2lkZUV2ZW50cyA9IHNlcnZlclNpZGVFdmVudHM7XG4gICAgdGhpcy5zZXJ2ZXJVUkwgPSBsaW5rZWRSZWNvcmRzLnNlcnZlclVSTDtcbiAgICB0aGlzLm9ic2VydmVycyA9IFtdO1xuXG4gICAgLy8gYmVjYXVzZSB0aGUgc2FtZSB1c2VyIGNhbiBiZSBsb2dnZWQgb24gdHdvIGJyb3dzZXJzL2xhcHRvcHMsIHdlIG5lZWRcbiAgICAvLyBhIGNsaWVudElkIGFuZCBhbiBhY3RvcklkXG4gICAgdGhpcy5jbGllbnRJZCA9IGxpbmtlZFJlY29yZHMuY2xpZW50SWQ7XG4gICAgdGhpcy5hY3RvcklkID0gbGlua2VkUmVjb3Jkcy5hY3RvcklkO1xuXG4gICAgdGhpcy52ZXJzaW9uID0gJzAnO1xuICAgIHRoaXMudmFsdWUgPSB0aGlzLmdldERlZmF1bHRWYWx1ZSgpO1xuICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IGZhbHNlO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBnZXREYXRhVHlwZU5hbWUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdnZXREYXRhVHlwZU5hbWUgbmVlZHMgdG8gYmUgaW1wbGVtZW50ZWQgaW4gY2hpbGQgY2xhc3MnKTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgaXNBdHRyaWJ1dGVJZChpZDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIGlkLnNwbGl0KCctJylbMF0gPT09IHRoaXMucHJvdG90eXBlLmdldERhdGFUeXBlUHJlZml4KCk7XG4gIH1cblxuICBwdWJsaWMgYWJzdHJhY3QgZ2V0RGF0YVR5cGVQcmVmaXgoKTtcbiAgcHVibGljIGFic3RyYWN0IGdldERlZmF1bHRWYWx1ZSgpIDogVHlwZTtcbiAgcHVibGljIGFic3RyYWN0IGRlc2VyaWFsaXplVmFsdWUoc2VyaWFsaXplZFZhbHVlOiBzdHJpbmcpIDogVHlwZTtcblxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgcmF3U2V0KG5ld1ZhbHVlOiBUeXBlKTogdm9pZDtcbiAgcHJvdGVjdGVkIGFic3RyYWN0IHJhd0NoYW5nZShkZWx0YTogVHlwZWRDaGFuZ2UpOiB2b2lkO1xuICBwcm90ZWN0ZWQgYWJzdHJhY3Qgb25TZXJ2ZXJNZXNzYWdlKHBheWxvYWQ6IFNlcmlhbGl6ZWRDaGFuZ2VXaXRoTWV0YWRhdGE8VHlwZWRDaGFuZ2U+KTtcbiAgcHJvdGVjdGVkIGFic3RyYWN0IG9uTG9hZCgpO1xuXG4gIHB1YmxpYyBhc3luYyBjcmVhdGUodmFsdWU6IFR5cGUpIHtcbiAgICBpZiAodGhpcy5pZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY3JlYXRlIGF0dHJpYnV0ZSBiZWNhdXNlIGl0IGhhcyBhbiBpZCBhc3NpZ25lZCAoJHt0aGlzLmlkfSlgKTtcbiAgICB9XG5cbiAgICB0aGlzLmlkID0gYCR7dGhpcy5nZXREYXRhVHlwZVByZWZpeCgpfS0ke3V1aWQoKX1gO1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLndpdGhDb25uZWN0aW9uTG9zdEhhbmRsZXIoKCkgPT4gZmV0Y2goYCR7dGhpcy5saW5rZWRSZWNvcmRzLnNlcnZlclVSTH1hdHRyaWJ1dGVzLyR7dGhpcy5pZH1gLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGNsaWVudElkOiB0aGlzLmNsaWVudElkLFxuICAgICAgICBhY3RvcklkOiB0aGlzLmFjdG9ySWQsXG4gICAgICAgIHZhbHVlLFxuICAgICAgfSksXG4gICAgfSkpO1xuXG4gICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBjb21tdW5pY2F0aW5nIHdpdGggdGhlIHNlcnZlciB3aGVuIGNyZWF0aW5nIGF0dHJpYnV0ZS4nKTtcbiAgICB9XG5cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgIHRoaXMuaGFuZGxlRXhwaXJlZExvZ2luU2Vzc2lvbigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBjcmVhdGluZyBhdHRyaWJ1dGU6ICR7YXdhaXQgcmVzcG9uc2UudGV4dCgpfWApO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3BvbnNlQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBhd2FpdCB0aGlzLmxvYWQocmVzcG9uc2VCb2R5KTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBnZXQoKSA6IFByb21pc2U8eyB2YWx1ZTogVHlwZSwgY2hhbmdlSWQ6IHN0cmluZywgYWN0b3JJZDogc3RyaW5nIH0+IHtcbiAgICBhd2FpdCB0aGlzLmxvYWQoKTtcblxuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogdGhpcy52YWx1ZSxcbiAgICAgIGNoYW5nZUlkOiB0aGlzLnZlcnNpb24sXG4gICAgICBhY3RvcklkOiB0aGlzLmFjdG9ySWQsXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBnZXRWYWx1ZSgpIDogUHJvbWlzZTxUeXBlPiB7XG4gICAgYXdhaXQgdGhpcy5sb2FkKCk7XG5cbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBzZXQobmV3VmFsdWU6IFR5cGUpIDogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgdGhpcy5sb2FkKCk7XG5cbiAgICBpZiAobmV3VmFsdWUgPT09IHRoaXMudmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhd2FpdCB0aGlzLnJhd1NldChuZXdWYWx1ZSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgY2hhbmdlKGNoYW5nZTogVHlwZWRDaGFuZ2UpIDogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgdGhpcy5sb2FkKCk7XG4gICAgYXdhaXQgdGhpcy5yYXdDaGFuZ2UoY2hhbmdlKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBzdWJzY3JpYmUob2JzZXJ2ZXI6IEZ1bmN0aW9uKSB7XG4gICAgYXdhaXQgdGhpcy5sb2FkKCk7XG4gICAgdGhpcy5vYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG4gIH1cblxuICBwdWJsaWMgaGFuZGxlRXhwaXJlZExvZ2luU2Vzc2lvbigpIHtcbiAgICBjb25zdCB3aW46IFdpbmRvdyA9IHdpbmRvdztcbiAgICB3aW4ubG9jYXRpb24gPSAnL2xvZ2luJztcbiAgfVxuXG4gIHB1YmxpYyBoYW5kbGVDb25uZWN0aW9uRXJyb3IoZXJyb3IpIHtcbiAgICBjb25zb2xlLmxvZygnQ29ubmVjdGlvbiBMb3N0JywgZXJyb3IpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHdpdGhDb25uZWN0aW9uTG9zdEhhbmRsZXIoZm46ICgpID0+IFByb21pc2U8YW55Pikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgZm4oKTtcbiAgICB9IGNhdGNoIChleDogYW55KSB7XG4gICAgICBpZiAoZXgubWVzc2FnZSA9PT0gJ0ZhaWxlZCB0byBmZXRjaCcpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVDb25uZWN0aW9uRXJyb3IoZXgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIGxvYWQoc2VydmVyU3RhdGU/OiB7IGNoYW5nZUlkOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgfSkge1xuICAgIGxldCByZXN1bHQgPSBzZXJ2ZXJTdGF0ZTtcblxuICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGxvYWQgYW4gYXR0cmlidXRlIHdpdGhvdXQgaWQnKTtcbiAgICB9XG5cbiAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuc2VydmVyVVJMfWF0dHJpYnV0ZXMvJHt0aGlzLmlkfT9jbGllbnRJZD0ke3RoaXMuY2xpZW50SWR9JmFjdG9ySWQ9JHt0aGlzLmFjdG9ySWR9YDtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy53aXRoQ29ubmVjdGlvbkxvc3RIYW5kbGVyKCgpID0+IGZldGNoKHVybCkpO1xuXG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVFeHBpcmVkTG9naW5TZXNzaW9uKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QganNvbkJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgY2hhbmdlSWQ6IGpzb25Cb2R5LmNoYW5nZUlkLFxuICAgICAgICB2YWx1ZToganNvbkJvZHkudmFsdWUsXG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMudmVyc2lvbiA9IHJlc3VsdC5jaGFuZ2VJZDtcbiAgICB0aGlzLnZhbHVlID0gdGhpcy5kZXNlcmlhbGl6ZVZhbHVlKHR5cGVvZiByZXN1bHQudmFsdWUgPT09ICdzdHJpbmcnID8gcmVzdWx0LnZhbHVlIDogSlNPTi5zdHJpbmdpZnkocmVzdWx0LnZhbHVlKSk7XG4gICAgdGhpcy5vbkxvYWQoKTtcbiAgICB0aGlzLm5vdGlmeVN1YnNjcmliZXJzKHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcblxuICAgIGNvbnN0IHVybCA9IGAke3RoaXMuc2VydmVyVVJMfWF0dHJpYnV0ZXMvJHt0aGlzLmlkfS9jaGFuZ2VzP2NsaWVudElkPSR7dGhpcy5jbGllbnRJZH0mYWN0b3JJZD0ke3RoaXMuYWN0b3JJZH1gO1xuICAgIGF3YWl0IHRoaXMuc2VydmVyU2lkZUV2ZW50cy5zdWJzY3JpYmUodXJsLCB0aGlzLmlkLCAocGFyc2VkRGF0YSkgPT4ge1xuICAgICAgaWYgKHBhcnNlZERhdGEuYXR0cmlidXRlSWQgIT09IHRoaXMuaWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm9uU2VydmVyTWVzc2FnZShwYXJzZWREYXRhKTtcbiAgICB9KTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBzZW5kVG9TZXJ2ZXIoY2hhbmdlOiBTZXJpYWxpemVkQ2hhbmdlV2l0aE1ldGFkYXRhPFR5cGVkQ2hhbmdlPikge1xuICAgIGNvbnN0IHVybCA9IGAke3RoaXMuc2VydmVyVVJMfWF0dHJpYnV0ZXMvJHt0aGlzLmlkfT9jbGllbnRJZD0ke3RoaXMuY2xpZW50SWR9JmFjdG9ySWQ9JHt0aGlzLmFjdG9ySWR9YDtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMud2l0aENvbm5lY3Rpb25Mb3N0SGFuZGxlcigoKSA9PiBmZXRjaCh1cmwsIHtcbiAgICAgIG1ldGhvZDogJ1BBVENIJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoY2hhbmdlLnRvSlNPTigpKSxcbiAgICB9KSk7XG5cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgIHRoaXMuaGFuZGxlRXhwaXJlZExvZ2luU2Vzc2lvbigpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBub3RpZnlTdWJzY3JpYmVycyhjaGFuZ2U/OiBUeXBlZENoYW5nZSwgZnVsbENoYW5nZUluZm8/OiB7IGFjdG9ySWQ6IHN0cmluZyB9KSB7XG4gICAgdGhpcy5vYnNlcnZlcnMuZm9yRWFjaCgoY2FsbGJhY2spID0+IHtcbiAgICAgIGNhbGxiYWNrKGNoYW5nZSwgZnVsbENoYW5nZUluZm8pO1xuICAgIH0pO1xuICB9XG59XG4iLCJpbXBvcnQgSXNTZXJpYWxpemFibGUgZnJvbSAnLi9pc19zZXJpYWxpemFibGUnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZXJpYWxpemVkQ2hhbmdlV2l0aE1ldGFkYXRhPENoYW5nZSBleHRlbmRzIElzU2VyaWFsaXphYmxlPiB7XG4gIHB1YmxpYyBhdHRyaWJ1dGVJZDogc3RyaW5nO1xuXG4gIHB1YmxpYyBhY3RvcklkOiBzdHJpbmc7XG5cbiAgcHVibGljIGNsaWVudElkOiBzdHJpbmc7XG5cbiAgcHVibGljIGNoYW5nZTogQ2hhbmdlO1xuXG4gIGNvbnN0cnVjdG9yKGF0dHJpYnV0ZUlkOiBzdHJpbmcsIGFjdG9ySWQ6IHN0cmluZywgY2xpZW50SWQ6IHN0cmluZywgY2hhbmdlOiBDaGFuZ2UpIHtcbiAgICB0aGlzLmF0dHJpYnV0ZUlkID0gYXR0cmlidXRlSWQ7XG4gICAgdGhpcy5hY3RvcklkID0gYWN0b3JJZDtcbiAgICB0aGlzLmNsaWVudElkID0gY2xpZW50SWQ7XG4gICAgdGhpcy5jaGFuZ2UgPSBjaGFuZ2U7XG4gIH1cblxuICB0b0pTT04oKTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgYXR0cmlidXRlSWQ6IHRoaXMuYXR0cmlidXRlSWQsXG4gICAgICBjaGFuZ2U6IHRoaXMuY2hhbmdlLnRvSlNPTigpLFxuICAgICAgYWN0b3JJZDogdGhpcy5hY3RvcklkLFxuICAgICAgY2xpZW50SWQ6IHRoaXMuY2xpZW50SWQsXG4gICAgfTtcbiAgfVxufVxuIiwiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uICovXG4vKiBlc2xpbnQtZGlzYWJsZSBpbXBvcnQvbm8tY3ljbGUgKi9cbi8qIGVzbGludC1kaXNhYmxlIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXMgKi9cbmltcG9ydCBBYnN0cmFjdEF0dHJpYnV0ZUNsaWVudCBmcm9tICcuLi8uLi9hYnN0cmFjdC9hYnN0cmFjdF9hdHRyaWJ1dGVfY2xpZW50JztcbmltcG9ydCBTZXJpYWxpemVkQ2hhbmdlV2l0aE1ldGFkYXRhIGZyb20gJy4uLy4uL2Fic3RyYWN0L3NlcmlhbGl6ZWRfY2hhbmdlX3dpdGhfbWV0YWRhdGEnO1xuaW1wb3J0IEtleVZhbHVlQ2hhbmdlLCB7IEF0b21pY0NoYW5nZSB9IGZyb20gJy4uL2tleV92YWx1ZV9jaGFuZ2UnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLZXlWYWx1ZUF0dHJpYnV0ZSBleHRlbmRzIEFic3RyYWN0QXR0cmlidXRlQ2xpZW50PG9iamVjdCwgS2V5VmFsdWVDaGFuZ2U+IHtcbiAgcHVibGljIHN0YXRpYyBnZXREYXRhVHlwZVByZWZpeCgpIDogc3RyaW5nIHtcbiAgICByZXR1cm4gJ2t2JztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZ2V0RGF0YVR5cGVOYW1lKCkgOiBzdHJpbmcge1xuICAgIHJldHVybiAna2V5VmFsdWUnO1xuICB9XG5cbiAgcHVibGljIGdldERhdGFUeXBlUHJlZml4KCkgOiBzdHJpbmcge1xuICAgIHJldHVybiBLZXlWYWx1ZUF0dHJpYnV0ZS5nZXREYXRhVHlwZVByZWZpeCgpO1xuICB9XG5cbiAgcHVibGljIGdldERhdGFUeXBlTmFtZSgpIDogc3RyaW5nIHtcbiAgICByZXR1cm4gS2V5VmFsdWVBdHRyaWJ1dGUuZ2V0RGF0YVR5cGVOYW1lKCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0RGVmYXVsdFZhbHVlKCkgOiBvYmplY3Qge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIHB1YmxpYyBkZXNlcmlhbGl6ZVZhbHVlKHNlcmlhbGl6ZWRWYWx1ZTogc3RyaW5nKSA6IG9iamVjdCB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2Uoc2VyaWFsaXplZFZhbHVlKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyByYXdTZXQobmV3VmFsdWU6IG9iamVjdCkge1xuICAgIGxldCBjaGFuZ2VzOiBBdG9taWNDaGFuZ2VbXSA9IFtdO1xuXG4gICAgT2JqZWN0LmVudHJpZXModGhpcy52YWx1ZSkuZm9yRWFjaCgoW2tleV0pID0+IHtcbiAgICAgIGNoYW5nZXMucHVzaCh7IGtleSwgdmFsdWU6IG51bGwgfSk7XG4gICAgfSk7XG5cbiAgICBPYmplY3QuZW50cmllcyhuZXdWYWx1ZSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBjaGFuZ2VzID0gY2hhbmdlcy5maWx0ZXIoKGNoKSA9PiBjaC5rZXkgIT09IGtleSk7XG4gICAgICBjaGFuZ2VzLnB1c2goeyBrZXksIHZhbHVlIH0pO1xuICAgIH0pO1xuXG4gICAgdGhpcy5jaGFuZ2UobmV3IEtleVZhbHVlQ2hhbmdlKGNoYW5nZXMpKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyByYXdDaGFuZ2UoY2hhbmdlOiBLZXlWYWx1ZUNoYW5nZSkge1xuICAgIHRoaXMudHJhbnNtaXRDaGFuZ2UobmV3IEtleVZhbHVlQ2hhbmdlKGNoYW5nZS5jaGFuZ2UsIHRoaXMudmVyc2lvbikpO1xuICAgIHRoaXMudmFsdWUgPSBjaGFuZ2UuYXBwbHkodGhpcy52YWx1ZSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb25Mb2FkKCkge1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uU2VydmVyTWVzc2FnZShjaGFuZ2VXaXRoTWV0YWRhdGE6IFNlcmlhbGl6ZWRDaGFuZ2VXaXRoTWV0YWRhdGE8S2V5VmFsdWVDaGFuZ2U+KSB7XG4gICAgY29uc3QgY2hhbmdlID0gbmV3IEtleVZhbHVlQ2hhbmdlKFxuICAgICAgY2hhbmdlV2l0aE1ldGFkYXRhLmNoYW5nZSBhcyB1bmtub3duIGFzIEF0b21pY0NoYW5nZVtdLFxuICAgICAgY2hhbmdlV2l0aE1ldGFkYXRhLmNoYW5nZS5jaGFuZ2VJZCxcbiAgICApO1xuXG4gICAgaWYgKGNoYW5nZVdpdGhNZXRhZGF0YS5jbGllbnRJZCA9PT0gdGhpcy5jbGllbnRJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMudmFsdWUgPSBjaGFuZ2UuYXBwbHkodGhpcy52YWx1ZSk7XG4gICAgdGhpcy52ZXJzaW9uID0gY2hhbmdlLmNoYW5nZUlkO1xuXG4gICAgdGhpcy5ub3RpZnlTdWJzY3JpYmVycyhjaGFuZ2UsIGNoYW5nZVdpdGhNZXRhZGF0YSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgdHJhbnNtaXRDaGFuZ2UoY2hhbmdlc2V0OiBLZXlWYWx1ZUNoYW5nZSkge1xuICAgIGlmICghdGhpcy5pZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGFuZ2UgY2FuIG5vdCBiZSB0cmFuc21pdHRlZCBiZWNhdXNlIGF0dHJpYnV0ZSBkb2VzIG5vdCBoYXMgYW4gaWQnKTtcbiAgICB9XG5cbiAgICB0aGlzLnNlbmRUb1NlcnZlcihuZXcgU2VyaWFsaXplZENoYW5nZVdpdGhNZXRhZGF0YTxLZXlWYWx1ZUNoYW5nZT4oXG4gICAgICB0aGlzLmlkLFxuICAgICAgdGhpcy5hY3RvcklkLFxuICAgICAgdGhpcy5jbGllbnRJZCxcbiAgICAgIGNoYW5nZXNldCxcbiAgICApKTtcbiAgfVxufVxuIiwiZXhwb3J0IHR5cGUgQXRvbWljQ2hhbmdlID0ge1xuICBrZXk6IHN0cmluZyxcbiAgdmFsdWU6IHN0cmluZyB8IG51bGwsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLZXlWYWx1ZUNoYW5nZSB7XG4gIHB1YmxpYyBjaGFuZ2VJZDogc3RyaW5nO1xuXG4gIHB1YmxpYyBjaGFuZ2U6IEF0b21pY0NoYW5nZVtdO1xuXG4gIHB1YmxpYyBzdGF0aWMgZnJvbUpTT04oaW5wdXQ6IGFueSwgY2hhbmdlSWQ/OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gbmV3IEtleVZhbHVlQ2hhbmdlKGlucHV0IGFzIEF0b21pY0NoYW5nZVtdLCBjaGFuZ2VJZCk7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGZyb21TdHJpbmcoaW5wdXQ6IHN0cmluZykgOiBLZXlWYWx1ZUNoYW5nZSB7XG4gICAgcmV0dXJuIG5ldyBLZXlWYWx1ZUNoYW5nZShKU09OLnBhcnNlKGlucHV0KSk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihjaGFuZ2VzZXQ6IEF0b21pY0NoYW5nZVtdLCBjaGFuZ2VJZD86IHN0cmluZykge1xuICAgIHRoaXMuY2hhbmdlSWQgPSBjaGFuZ2VJZCA/PyAndW5jb21taXRlZCc7XG4gICAgdGhpcy5jaGFuZ2UgPSBjaGFuZ2VzZXQ7XG4gIH1cblxuICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5jaGFuZ2UpO1xuICB9XG5cbiAgcHVibGljIHRvSlNPTigpOiBvYmplY3Qge1xuICAgIHJldHVybiB0aGlzLmNoYW5nZTtcbiAgfVxuXG4gIHB1YmxpYyBhcHBseShpbnB1dDogb2JqZWN0KTogb2JqZWN0IHtcbiAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGlucHV0KSk7XG5cbiAgICB0aGlzLmNoYW5nZS5mb3JFYWNoKChhQ2hhbmdlKSA9PiB7XG4gICAgICBpZiAoYUNoYW5nZS52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBkZWxldGUgcmVzdWx0W2FDaGFuZ2Uua2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFthQ2hhbmdlLmtleV0gPSBhQ2hhbmdlLnZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHB1YmxpYyBtZXJnZShvdGhlcjogS2V5VmFsdWVDaGFuZ2UpOiBLZXlWYWx1ZUNoYW5nZSB7XG4gICAgbGV0IG1lcmdlZENoYW5nZXM6IEF0b21pY0NoYW5nZVtdID0gW107XG5cbiAgICB0aGlzLmNoYW5nZS5mb3JFYWNoKChjaCkgPT4ge1xuICAgICAgbWVyZ2VkQ2hhbmdlcyA9IG1lcmdlZENoYW5nZXMuZmlsdGVyKCh4KSA9PiB4LmtleSAhPT0gY2gua2V5KTtcbiAgICAgIG1lcmdlZENoYW5nZXMucHVzaChjaCk7XG4gICAgfSk7XG5cbiAgICBvdGhlci5jaGFuZ2UuZm9yRWFjaCgoY2gpID0+IHtcbiAgICAgIG1lcmdlZENoYW5nZXMgPSBtZXJnZWRDaGFuZ2VzLmZpbHRlcigoeCkgPT4geC5rZXkgIT09IGNoLmtleSk7XG4gICAgICBtZXJnZWRDaGFuZ2VzLnB1c2goY2gpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ldyBLZXlWYWx1ZUNoYW5nZShtZXJnZWRDaGFuZ2VzKTtcbiAgfVxufVxuIiwiaW1wb3J0IExvbmdUZXh0Q2hhbmdlIGZyb20gJy4uL2xvbmdfdGV4dF9jaGFuZ2UnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaGFuZ2VCdWZmZXIge1xuICB2YWx1ZT86IExvbmdUZXh0Q2hhbmdlO1xuXG4gIGluRmxpZ2h0T3A/OiBMb25nVGV4dENoYW5nZTtcblxuICBhZGQoY2hhbmdlc2V0OiBMb25nVGV4dENoYW5nZSk6IHZvaWQge1xuICAgIHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlID8gdGhpcy52YWx1ZS5tZXJnZShjaGFuZ2VzZXQpIDogY2hhbmdlc2V0O1xuICB9XG5cbiAgLy8gdGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgdHJhbnNmb3JtZWQgdmVyc2lvbiBvZiB0aGUgZm9yZWlnbkNoYW5nZSB3aGljaFxuICAvLyBmaXRzIGludG8gdGhlIGN1cnJlbnQgY2xpZW50IHN0YXRlLiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2UgdGhlIGNsaWVudFxuICAvLyBjb3VsZCBoYXZlIHNvbWUgY2hhbmdlcyB3aGljaCBoYXMgbm90IGJlZW4gc2VuZCB0byB0aGUgc2VydmVyIHlldC4gU28sIHRoZVxuICAvLyBzZXJ2ZXIgZG9uJ3Qga25vdyBhYm91dCB0aGVzZSBjaGFuZ2VzIGFuZCB0aGUgY2hhbmdlcyBjb21taW5nIGZyb20gdGhlIHNlcnZlclxuICAvLyB3b3VsZCBub3QgZml0IGludG8gdGhlIGNsaWVudCBzdGF0ZS5cbiAgdHJhbnNmb3JtQWdhaW5zdChcbiAgICBmb3JlaWduQ2hhbmdlOiBMb25nVGV4dENoYW5nZSxcbiAgICBjaGFuZ2VJblRyYW5zbWlzc2lvbj86IExvbmdUZXh0Q2hhbmdlLFxuICApIDogTG9uZ1RleHRDaGFuZ2Uge1xuICAgIGlmICghY2hhbmdlSW5UcmFuc21pc3Npb24pIHtcbiAgICAgIHJldHVybiBmb3JlaWduQ2hhbmdlO1xuICAgIH1cblxuICAgIHRoaXMuaW5GbGlnaHRPcCA9IHRoaXMuaW5GbGlnaHRPcCB8fCBjaGFuZ2VJblRyYW5zbWlzc2lvbjtcblxuICAgIGNvbnN0IGMyID0gZm9yZWlnbkNoYW5nZS50cmFuc2Zvcm1BZ2FpbnN0KHRoaXMuaW5GbGlnaHRPcCwgdHJ1ZSk7XG4gICAgdGhpcy5pbkZsaWdodE9wID0gdGhpcy5pbkZsaWdodE9wPy50cmFuc2Zvcm1BZ2FpbnN0KGZvcmVpZ25DaGFuZ2UsIGZhbHNlKTtcblxuICAgIGlmICghdGhpcy52YWx1ZSkgcmV0dXJuIGMyO1xuXG4gICAgLy8gaW5zdGVhZCBvZiB1c2luZyBhIGJyaWRnZSB3ZSB1c2UgYzIgdG8gdHJhbnNmb3JtIHRoZVxuICAgIC8vIGZvcmVpZ25DaGFuZ2UgKGNoYW5nZSBmcm9tIHNlcnZlcikgaW50byB0aGUgY2xpZW50IHN0YXRlLlxuICAgIGNvbnN0IGMxID0gYzIudHJhbnNmb3JtQWdhaW5zdCh0aGlzLnZhbHVlLCB0cnVlKTtcblxuICAgIC8vIFwiT25jZSB3ZSBoYXZlIHRoaXMgaW5mZXJyZWQgb3BlcmF0aW9uLCBjMiwgd2UgY2FuIHVzZSBpdFxuICAgIC8vIHRvIHRyYW5zZm9ybSB0aGUgYnVmZmVyIChiKSBcImRvd25cIiBvbmUgc3RlcFwiXG4gICAgdGhpcy52YWx1ZSA9IHRoaXMudmFsdWU/LnRyYW5zZm9ybUFnYWluc3QoYzIsIGZhbHNlKTtcblxuICAgIHJldHVybiBjMTtcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIHRoaXMudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pbkZsaWdodE9wID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZ2V0VmFsdWUoKTogTG9uZ1RleHRDaGFuZ2UgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICB9XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBpbXBvcnQvbm8tY3ljbGUgKi9cbi8qIGVzbGludC1kaXNhYmxlIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXMgKi9cblxuaW1wb3J0IEFic3RyYWN0QXR0cmlidXRlQ2xpZW50IGZyb20gJy4uLy4uL2Fic3RyYWN0L2Fic3RyYWN0X2F0dHJpYnV0ZV9jbGllbnQnO1xuaW1wb3J0IFNlcmlhbGl6ZWRDaGFuZ2VXaXRoTWV0YWRhdGEgZnJvbSAnLi4vLi4vYWJzdHJhY3Qvc2VyaWFsaXplZF9jaGFuZ2Vfd2l0aF9tZXRhZGF0YSc7XG5pbXBvcnQgTG9uZ1RleHRDaGFuZ2UgZnJvbSAnLi4vbG9uZ190ZXh0X2NoYW5nZSc7XG5pbXBvcnQgQ2hhbmdlQnVmZmVyIGZyb20gJy4vYnVmZmVyJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9uZ1RleHRBdHRyaWJ1dGUgZXh0ZW5kcyBBYnN0cmFjdEF0dHJpYnV0ZUNsaWVudDxzdHJpbmcsIExvbmdUZXh0Q2hhbmdlPiB7XG4gIGJ1ZmZlcjogQ2hhbmdlQnVmZmVyID0gbmV3IENoYW5nZUJ1ZmZlcigpO1xuXG4gIGNoYW5nZUluVHJhbnNtaXNzaW9uPzogU2VyaWFsaXplZENoYW5nZVdpdGhNZXRhZGF0YTxMb25nVGV4dENoYW5nZT4gPSB1bmRlZmluZWQ7XG5cbiAgcHVibGljIHN0YXRpYyBnZXREYXRhVHlwZVByZWZpeCgpIDogc3RyaW5nIHtcbiAgICByZXR1cm4gJ2wnO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBnZXREYXRhVHlwZU5hbWUoKSA6IHN0cmluZyB7XG4gICAgcmV0dXJuICdsb25nVGV4dCc7XG4gIH1cblxuICBwdWJsaWMgZ2V0RGF0YVR5cGVQcmVmaXgoKSA6IHN0cmluZyB7XG4gICAgcmV0dXJuICdsJztcbiAgfVxuXG4gIHB1YmxpYyBnZXREYXRhVHlwZU5hbWUoKSA6IHN0cmluZyB7XG4gICAgcmV0dXJuIExvbmdUZXh0QXR0cmlidXRlLmdldERhdGFUeXBlTmFtZSgpO1xuICB9XG5cbiAgcHVibGljIGdldERlZmF1bHRWYWx1ZSgpIDogc3RyaW5nIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBwdWJsaWMgZGVzZXJpYWxpemVWYWx1ZShzZXJpYWxpemVkVmFsdWU6IHN0cmluZykgOiBzdHJpbmcge1xuICAgIHJldHVybiBzZXJpYWxpemVkVmFsdWU7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgcmF3U2V0KG5ld1ZhbHVlOiBzdHJpbmcpIHtcbiAgICBjb25zdCBjaGFuZ2VzZXQgPSBMb25nVGV4dENoYW5nZS5mcm9tRGlmZih0aGlzLnZhbHVlLCBuZXdWYWx1ZSk7XG5cbiAgICBhd2FpdCB0aGlzLmNoYW5nZShjaGFuZ2VzZXQpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIHJhd0NoYW5nZShjaGFuZ2VzZXQ6IExvbmdUZXh0Q2hhbmdlKSB7XG4gICAgLy8gVE9ETzogQ2hlY2sgZm9yIHZlcnNpb24gaXMgdmFsaWRcbiAgICAvLyBpZiAodGhpcy52ZXJzaW9uID09PSAnMCcpIHtcbiAgICAvLyAgIHRocm93IEVycm9yKCdDYW5ub3QgY2hhbmdlIGF0dHJpYnV0ZSBhcyBhdHRyaWJ1dGVkIHN0YXRlIGlzIG5vdCBsb2FkZWQgZnJvbSBzZXJ2ZXIhJyk7XG4gICAgLy8gfVxuXG4gICAgdGhpcy52YWx1ZSA9IGNoYW5nZXNldC5hcHBseSh0aGlzLnZhbHVlKTtcblxuICAgIGlmICh0aGlzLmNoYW5nZUluVHJhbnNtaXNzaW9uKSB7XG4gICAgICB0aGlzLmJ1ZmZlci5hZGQoY2hhbmdlc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50cmFuc21pdENoYW5nZShuZXcgTG9uZ1RleHRDaGFuZ2UoY2hhbmdlc2V0LmNoYW5nZXNldCwgdGhpcy52ZXJzaW9uKSk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIG9uTG9hZCgpIHtcbiAgICB0aGlzLmJ1ZmZlci5jbGVhcigpO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uU2VydmVyTWVzc2FnZShjaGFuZ2VXaXRoTWV0YWRhdGE6IFNlcmlhbGl6ZWRDaGFuZ2VXaXRoTWV0YWRhdGE8TG9uZ1RleHRDaGFuZ2U+KSB7XG4gICAgaWYgKGNoYW5nZVdpdGhNZXRhZGF0YS5jbGllbnRJZCA9PT0gdGhpcy5jbGllbnRJZCkge1xuICAgICAgdGhpcy5wcm9jZXNzQXBwcm92YWwoY2hhbmdlV2l0aE1ldGFkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcm9jZXNzRm9yZWlnbkNoYW5nZShjaGFuZ2VXaXRoTWV0YWRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcHJvY2Vzc0ZvcmVpZ25DaGFuZ2UoXG4gICAgZm9yZWlnbkNoYW5nZVdpdGhNZXRhZGF0YTogU2VyaWFsaXplZENoYW5nZVdpdGhNZXRhZGF0YTxMb25nVGV4dENoYW5nZT4sXG4gICkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBmb3JlaWduQ2hhbmdlc2V0ID0gTG9uZ1RleHRDaGFuZ2UuZnJvbVN0cmluZyhcbiAgICAgICAgZm9yZWlnbkNoYW5nZVdpdGhNZXRhZGF0YS5jaGFuZ2UuY2hhbmdlc2V0LFxuICAgICAgKTtcblxuICAgICAgY29uc3QgdHJhbnNmb3JtZWRGb3JlaWduQ2hhbmdlID0gdGhpcy5idWZmZXIudHJhbnNmb3JtQWdhaW5zdChcbiAgICAgICAgZm9yZWlnbkNoYW5nZXNldCxcbiAgICAgICAgdGhpcy5jaGFuZ2VJblRyYW5zbWlzc2lvbj8uY2hhbmdlLFxuICAgICAgKTtcblxuICAgICAgdGhpcy52YWx1ZSA9IHRyYW5zZm9ybWVkRm9yZWlnbkNoYW5nZS5hcHBseSh0aGlzLnZhbHVlKTtcbiAgICAgIHRoaXMudmVyc2lvbiA9IGZvcmVpZ25DaGFuZ2VXaXRoTWV0YWRhdGEuY2hhbmdlLmNoYW5nZUlkO1xuICAgICAgdGhpcy5ub3RpZnlTdWJzY3JpYmVycyh0cmFuc2Zvcm1lZEZvcmVpZ25DaGFuZ2UsIGZvcmVpZ25DaGFuZ2VXaXRoTWV0YWRhdGEpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBjb25zb2xlLmxvZygnRVJST1I6IHByb2Nlc3NpbmcgZm9yZWlnbiBjaGFuZ2UgZmFpbGVkIChwcm9iYWJseSBiZWNhdXNlIG9mIGEgcHJldmlvdXMgbWVzc2FnZSBsb3NzKS4gUmVsb2FkIHNlcnZlciBzdGF0ZSB0byByZWNvdmVyLicsIGV4KTtcbiAgICAgIHRoaXMubG9hZCgpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcHJvY2Vzc0FwcHJvdmFsKGFwcHJvdmFsOiBTZXJpYWxpemVkQ2hhbmdlV2l0aE1ldGFkYXRhPExvbmdUZXh0Q2hhbmdlPikge1xuICAgIGNvbnN0IGJ1ZmZlcmVkQ2hhbmdlcyA9IHRoaXMuYnVmZmVyLmdldFZhbHVlKCk7XG4gICAgdGhpcy5jaGFuZ2VJblRyYW5zbWlzc2lvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnZlcnNpb24gPSBhcHByb3ZhbC5jaGFuZ2UuY2hhbmdlSWQ7XG4gICAgdGhpcy5idWZmZXIuY2xlYXIoKTtcblxuICAgIGlmIChidWZmZXJlZENoYW5nZXMpIHtcbiAgICAgIHRoaXMudHJhbnNtaXRDaGFuZ2UobmV3IExvbmdUZXh0Q2hhbmdlKGJ1ZmZlcmVkQ2hhbmdlcy5jaGFuZ2VzZXQsIGFwcHJvdmFsLmNoYW5nZS5jaGFuZ2VJZCkpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCB0cmFuc21pdENoYW5nZShjaGFuZ2VzZXQ6IExvbmdUZXh0Q2hhbmdlKSB7XG4gICAgaWYgKCF0aGlzLmlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoYW5nZSBjYW4gbm90IGJlIHRyYW5zbWl0dGVkIGJlY2F1c2UgYXR0cmlidXRlIGRvZXMgbm90IGhhcyBhbiBpZCcpO1xuICAgIH1cblxuICAgIHRoaXMuY2hhbmdlSW5UcmFuc21pc3Npb24gPSBuZXcgU2VyaWFsaXplZENoYW5nZVdpdGhNZXRhZGF0YTxMb25nVGV4dENoYW5nZT4oXG4gICAgICB0aGlzLmlkLFxuICAgICAgdGhpcy5hY3RvcklkLFxuICAgICAgdGhpcy5jbGllbnRJZCxcbiAgICAgIGNoYW5nZXNldCxcbiAgICApO1xuXG4gICAgdGhpcy5zZW5kVG9TZXJ2ZXIodGhpcy5jaGFuZ2VJblRyYW5zbWlzc2lvbik7XG4gIH1cbn1cbiIsImltcG9ydCB7IENoYW5nZXNldCB9IGZyb20gJ2NoYW5nZXNldHMnO1xuaW1wb3J0IHsgZGlmZl9tYXRjaF9wYXRjaCBhcyBEaWZmTWF0Y2hQYXRjaCB9IGZyb20gJ2RpZmZfbWF0Y2hfcGF0Y2gnO1xuXG5jb25zdCBkaWZmRW5naW5lID0gbmV3IERpZmZNYXRjaFBhdGNoKCk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvbmdUZXh0Q2hhbmdlIHtcbiAgcHVibGljIGNoYW5nZXNldDtcblxuICBwdWJsaWMgY2hhbmdlSWQ6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihjaGFuZ2VzZXQsIGNoYW5nZUlkPzogc3RyaW5nKSB7XG4gICAgdGhpcy5jaGFuZ2VzZXQgPSBjaGFuZ2VzZXQ7XG4gICAgdGhpcy5jaGFuZ2VJZCA9IGNoYW5nZUlkID8/ICd1bmNvbW1pdGVkJztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZnJvbVN0cmluZyhjaGFuZ2U6IHN0cmluZyk6IExvbmdUZXh0Q2hhbmdlIHtcbiAgICByZXR1cm4gbmV3IExvbmdUZXh0Q2hhbmdlKENoYW5nZXNldC51bnBhY2soY2hhbmdlKSk7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGZyb21EaWZmKGE6IHN0cmluZywgYjogc3RyaW5nKTogTG9uZ1RleHRDaGFuZ2Uge1xuICAgIHJldHVybiBuZXcgTG9uZ1RleHRDaGFuZ2UoQ2hhbmdlc2V0LmZyb21EaWZmKGRpZmZFbmdpbmUuZGlmZl9tYWluKGEsIGIpKSk7XG4gIH1cblxuICBwdWJsaWMgYXBwbHkodmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbmdlc2V0LmFwcGx5KHZhbHVlKTtcbiAgfVxuXG4gIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy5jaGFuZ2VzZXQgPT09ICdzdHJpbmcnXG4gICAgICA/IHRoaXMuY2hhbmdlc2V0XG4gICAgICA6IHRoaXMuY2hhbmdlc2V0LnBhY2soKTtcbiAgfVxuXG4gIHB1YmxpYyB0cmFuc2Zvcm1BZ2FpbnN0KGNoYW5nZTogTG9uZ1RleHRDaGFuZ2UgfCBudWxsLCBzaWRlPykgOiBMb25nVGV4dENoYW5nZSB7XG4gICAgaWYgKCFjaGFuZ2UpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgTG9uZ1RleHRDaGFuZ2UodGhpcy5jaGFuZ2VzZXQudHJhbnNmb3JtQWdhaW5zdChjaGFuZ2UuY2hhbmdlc2V0LCBzaWRlKSk7XG4gIH1cblxuICBwdWJsaWMgbWVyZ2Uob3RoZXJDaGFuZ2U6IExvbmdUZXh0Q2hhbmdlKSA6IExvbmdUZXh0Q2hhbmdlIHtcbiAgICByZXR1cm4gbmV3IExvbmdUZXh0Q2hhbmdlKHRoaXMuY2hhbmdlc2V0Lm1lcmdlKG90aGVyQ2hhbmdlLmNoYW5nZXNldCkpO1xuICB9XG5cbiAgcHVibGljIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2hhbmdlc2V0OiB0aGlzLnRvU3RyaW5nKCksXG4gICAgICBjaGFuZ2VJZDogdGhpcy5jaGFuZ2VJZCxcbiAgICB9O1xuICB9XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBtYXgtY2xhc3Nlcy1wZXItZmlsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L25vLWN5Y2xlICovXG5cbmltcG9ydCB7IHY0IGFzIHV1aWQgfSBmcm9tICd1dWlkJztcbmltcG9ydCBMb25nVGV4dEF0dHJpYnV0ZSBmcm9tICcuLi9hdHRyaWJ1dGVzL2xvbmdfdGV4dC9jbGllbnQnO1xuaW1wb3J0IEtleVZhbHVlQXR0cmlidXRlIGZyb20gJy4uL2F0dHJpYnV0ZXMva2V5X3ZhbHVlL2NsaWVudCc7XG5pbXBvcnQgU2VydmVyU2lkZUV2ZW50cywgeyBJc1N1YnNjcmliYWJsZSB9IGZyb20gJy4uLy4uL2xpYi9zZXJ2ZXItc2lkZS1ldmVudHMvY2xpZW50JztcbmltcG9ydCBBYnN0cmFjdEF0dHJpYnV0ZUNsaWVudCBmcm9tICcuLi9hdHRyaWJ1dGVzL2Fic3RyYWN0L2Fic3RyYWN0X2F0dHJpYnV0ZV9jbGllbnQnO1xuaW1wb3J0IElzU2VyaWFsaXphYmxlIGZyb20gJy4uL2F0dHJpYnV0ZXMvYWJzdHJhY3QvaXNfc2VyaWFsaXphYmxlJztcbmltcG9ydCBGYWN0IGZyb20gJy4uL2ZhY3RzL2NsaWVudCc7XG5cbmNsYXNzIEF0dHJpYnV0ZXNSZXBvc2l0b3J5IHtcbiAgbGlua2VkUmVjb3JkczogTGlua2VkUmVjb3JkcztcblxuICBwcml2YXRlIHNlcnZlclNpZGVFdmVudHM6IElzU3Vic2NyaWJhYmxlO1xuXG4gIHByaXZhdGUgc3RhdGljIGF0dHJpYnV0ZVR5cGVzID0gW1xuICAgIExvbmdUZXh0QXR0cmlidXRlLFxuICAgIEtleVZhbHVlQXR0cmlidXRlLFxuICBdO1xuXG4gIGNvbnN0cnVjdG9yKGxpbmtlZFJlY29yZHM6IExpbmtlZFJlY29yZHMsIHNlcnZlclNpZGVFdmVudHM6IElzU3Vic2NyaWJhYmxlKSB7XG4gICAgdGhpcy5saW5rZWRSZWNvcmRzID0gbGlua2VkUmVjb3JkcztcbiAgICB0aGlzLnNlcnZlclNpZGVFdmVudHMgPSBzZXJ2ZXJTaWRlRXZlbnRzO1xuICB9XG5cbiAgYXN5bmMgY3JlYXRlKGF0dHJpYnV0ZVR5cGU6IHN0cmluZywgdmFsdWU6IGFueSlcbiAgICA6UHJvbWlzZTxBYnN0cmFjdEF0dHJpYnV0ZUNsaWVudDxhbnksIElzU2VyaWFsaXphYmxlPj4ge1xuICAgIGNvbnN0IEF0dHJpYnV0ZUNsYXNzID0gQXR0cmlidXRlc1JlcG9zaXRvcnlcbiAgICAgIC5hdHRyaWJ1dGVUeXBlc1xuICAgICAgLmZpbmQoKGMpID0+IGMuZ2V0RGF0YVR5cGVOYW1lKCkgPT09IGF0dHJpYnV0ZVR5cGUpO1xuXG4gICAgaWYgKCFBdHRyaWJ1dGVDbGFzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdHRyaWJ1dGUgVHlwZSAke2F0dHJpYnV0ZVR5cGV9IGlzIHVua25vd25gKTtcbiAgICB9XG5cbiAgICBjb25zdCBhdHRyaWJ1dGU6IEFic3RyYWN0QXR0cmlidXRlQ2xpZW50PGFueSwgSXNTZXJpYWxpemFibGU+ID0gbmV3IEF0dHJpYnV0ZUNsYXNzKFxuICAgICAgdGhpcy5saW5rZWRSZWNvcmRzLFxuICAgICAgdGhpcy5zZXJ2ZXJTaWRlRXZlbnRzLFxuICAgICk7XG5cbiAgICBhd2FpdCBhdHRyaWJ1dGUuY3JlYXRlKHZhbHVlKTtcbiAgICByZXR1cm4gYXR0cmlidXRlO1xuICB9XG5cbiAgYXN5bmMgZmluZChhdHRyaWJ1dGVJZDogc3RyaW5nKVxuICAgIDpQcm9taXNlPEFic3RyYWN0QXR0cmlidXRlQ2xpZW50PGFueSwgSXNTZXJpYWxpemFibGU+PiB7XG4gICAgY29uc3QgW2F0dHJpYnV0ZVR5cGVQcmVmaXhdID0gYXR0cmlidXRlSWQuc3BsaXQoJy0nKTtcbiAgICBjb25zdCBBdHRyaWJ1dGVDbGFzcyA9IEF0dHJpYnV0ZXNSZXBvc2l0b3J5XG4gICAgICAuYXR0cmlidXRlVHlwZXNcbiAgICAgIC5maW5kKChjKSA9PiBjLmdldERhdGFUeXBlUHJlZml4KCkgPT09IGF0dHJpYnV0ZVR5cGVQcmVmaXgpO1xuXG4gICAgaWYgKCFBdHRyaWJ1dGVDbGFzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdHRyaWJ1dGUgSUQgJHthdHRyaWJ1dGVJZH0gaXMgdW5rbm93bmApO1xuICAgIH1cblxuICAgIGNvbnN0IGF0dHJpYnV0ZSA9IG5ldyBBdHRyaWJ1dGVDbGFzcyh0aGlzLmxpbmtlZFJlY29yZHMsIHRoaXMuc2VydmVyU2lkZUV2ZW50cywgYXR0cmlidXRlSWQpO1xuICAgIGF3YWl0IGF0dHJpYnV0ZS5nZXQoKTtcbiAgICByZXR1cm4gYXR0cmlidXRlO1xuICB9XG5cbiAgYXN5bmMgZmluZEFsbChxdWVyeTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBzdHJpbmdbXVtdIH0pXG4gICAgOlByb21pc2U8e1xuICAgICAgW2tleTogc3RyaW5nXTogQWJzdHJhY3RBdHRyaWJ1dGVDbGllbnQ8YW55LCBhbnk+W10gfCBBYnN0cmFjdEF0dHJpYnV0ZUNsaWVudDxhbnksIGFueT5cbiAgICB9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgY29uc3QgcUVudHJpZXMgPSBPYmplY3QuZW50cmllcyhxdWVyeSk7XG4gICAgY29uc3QgcHJvbWlzZXM6IFByb21pc2U8YW55PltdID0gW107XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHFFbnRyaWVzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICBjb25zdCBxRW50cnkgPSBxRW50cmllc1tqXTtcblxuICAgICAgaWYgKHFFbnRyeSkge1xuICAgICAgICBjb25zdCBuID0gcUVudHJ5WzBdO1xuICAgICAgICBjb25zdCBxID0gcUVudHJ5WzFdO1xuXG4gICAgICAgIGlmICh0eXBlb2YgcSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuZmluZChxKS50aGVuKChhdHRyaWJ1dGUpID0+IHtcbiAgICAgICAgICAgIHJlc3VsdFtuXSA9IGF0dHJpYnV0ZTtcbiAgICAgICAgICB9KS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICByZXN1bHRbbl0gPSBudWxsO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRbbl0gPSBbXTtcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMubGlua2VkUmVjb3Jkcy5GYWN0LmZpbmRBbGwoeyBzdWJqZWN0OiBxIH0pLnRoZW4oKGZhY3RzKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZhY3RzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHN1YmplY3RJZCA9IGZhY3RzW2ldPy5zdWJqZWN0O1xuICAgICAgICAgICAgICBpZiAoc3ViamVjdElkICYmICFyZXN1bHRbbl0uZmluZCgoYXR0cikgPT4gYXR0ci5pZCA9PT0gc3ViamVjdElkKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IEF0dHJpYnV0ZUNsYXNzID0gQXR0cmlidXRlc1JlcG9zaXRvcnkuYXR0cmlidXRlVHlwZXNcbiAgICAgICAgICAgICAgICAgIC5maW5kKChhdCkgPT4gYXQuaXNBdHRyaWJ1dGVJZChzdWJqZWN0SWQpKTtcblxuICAgICAgICAgICAgICAgIGlmIChBdHRyaWJ1dGVDbGFzcykge1xuICAgICAgICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlID0gbmV3IEF0dHJpYnV0ZUNsYXNzKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmtlZFJlY29yZHMsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VydmVyU2lkZUV2ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgc3ViamVjdElkLFxuICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgcmVzdWx0W25dLnB1c2goYXR0cmlidXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbmNsYXNzIEZhY3RzUmVwb3NpdG9yeSB7XG4gIGxpbmtlZFJlY29yZHM6IExpbmtlZFJlY29yZHM7XG5cbiAgY29uc3RydWN0b3IobGlua2VkUmVjb3JkczogTGlua2VkUmVjb3Jkcykge1xuICAgIHRoaXMubGlua2VkUmVjb3JkcyA9IGxpbmtlZFJlY29yZHM7XG4gIH1cblxuICBhc3luYyBjcmVhdGVBbGwoZmFjdHM6IFsgc3RyaW5nPywgc3RyaW5nPywgc3RyaW5nPyBdW10pOlxuICBQcm9taXNlPEZhY3RbXT4ge1xuICAgIGNvbnN0IGNyZWF0ZWRGYWN0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgZmFjdHMubWFwKChhdHRyKSA9PiB0aGlzLmNyZWF0ZShcbiAgICAgICAgYXR0clswXSxcbiAgICAgICAgYXR0clsxXSxcbiAgICAgICAgYXR0clsyXSxcbiAgICAgICkpLFxuICAgICk7XG5cbiAgICByZXR1cm4gY3JlYXRlZEZhY3RzO1xuICB9XG5cbiAgYXN5bmMgY3JlYXRlKHN1YmplY3RJZD86IHN0cmluZywgcHJlZGljYXRlSWQ/OiBzdHJpbmcsIG9iamVjdElkPzogc3RyaW5nKTogUHJvbWlzZTxGYWN0PiB7XG4gICAgaWYgKCFzdWJqZWN0SWQpIHtcbiAgICAgIHRocm93IEVycm9yKCdzdWJqZWN0SWQgY2FuIG5vdCBiZSBudWxsJyk7XG4gICAgfVxuXG4gICAgaWYgKCFvYmplY3RJZCkge1xuICAgICAgdGhyb3cgRXJyb3IoJ29iamVjdElkIGNhbiBub3QgYmUgbnVsbCcpO1xuICAgIH1cblxuICAgIGlmICghcHJlZGljYXRlSWQpIHtcbiAgICAgIHRocm93IEVycm9yKCdwcmVkaWNhdGVJZCBjYW4gbm90IGJlIG51bGwnKTtcbiAgICB9XG5cbiAgICBjb25zdCBmYWN0ID0gbmV3IEZhY3QodGhpcy5saW5rZWRSZWNvcmRzLCBzdWJqZWN0SWQsIHByZWRpY2F0ZUlkLCBvYmplY3RJZCk7XG4gICAgYXdhaXQgZmFjdC5zYXZlKCk7XG4gICAgcmV0dXJuIGZhY3Q7XG4gIH1cblxuICBhc3luYyBkZWxldGVBbGwoKSB7XG4gICAgYXdhaXQgZmV0Y2goYCR7dGhpcy5saW5rZWRSZWNvcmRzLnNlcnZlclVSTH1mYWN0c2AsIHtcbiAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGZpbmRBbGwoeyBzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCB9OlxuICB7IHN1YmplY3Q/OiAoc3RyaW5nIHwgc3RyaW5nW10pW10sXG4gICAgcHJlZGljYXRlPzogc3RyaW5nW10sXG4gICAgb2JqZWN0PzogKHN0cmluZyB8IHN0cmluZ1tdKVtdIH0pOiBQcm9taXNlPEZhY3RbXT4ge1xuICAgIGNvbnN0IHF1ZXJ5VVJMID0gbmV3IFVSTChgJHt0aGlzLmxpbmtlZFJlY29yZHMuc2VydmVyVVJMfWZhY3RzYCk7XG5cbiAgICBpZiAoc3ViamVjdCkge1xuICAgICAgcXVlcnlVUkwuc2VhcmNoUGFyYW1zLmFwcGVuZCgnc3ViamVjdCcsIEpTT04uc3RyaW5naWZ5KHN1YmplY3QpKTtcbiAgICB9XG5cbiAgICBpZiAocHJlZGljYXRlKSB7XG4gICAgICBxdWVyeVVSTC5zZWFyY2hQYXJhbXMuYXBwZW5kKCdwcmVkaWNhdGUnLCBKU09OLnN0cmluZ2lmeShwcmVkaWNhdGUpKTtcbiAgICB9XG5cbiAgICBpZiAob2JqZWN0KSB7XG4gICAgICBxdWVyeVVSTC5zZWFyY2hQYXJhbXMuYXBwZW5kKCdvYmplY3QnLCBKU09OLnN0cmluZ2lmeShvYmplY3QpKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHF1ZXJ5VVJMLCB7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IHJlc3BvbnNlSnNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgIHJldHVybiByZXNwb25zZUpzb24ubWFwKChyZWNvcmQpID0+IG5ldyBGYWN0KFxuICAgICAgdGhpcy5saW5rZWRSZWNvcmRzLFxuICAgICAgcmVjb3JkLnN1YmplY3QsXG4gICAgICByZWNvcmQucHJlZGljYXRlLFxuICAgICAgcmVjb3JkLm9iamVjdCxcbiAgICApKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaW5rZWRSZWNvcmRzIHtcbiAgc2VydmVyU2lkZUV2ZW50czogSXNTdWJzY3JpYmFibGU7XG5cbiAgc2VydmVyVVJMOiBVUkw7XG5cbiAgY2xpZW50SWQ6IHN0cmluZztcblxuICBhY3RvcklkOiBzdHJpbmc7XG5cbiAgQXR0cmlidXRlOiBBdHRyaWJ1dGVzUmVwb3NpdG9yeTtcblxuICBGYWN0OiBGYWN0c1JlcG9zaXRvcnk7XG5cbiAgY29uc3RydWN0b3Ioc2VydmVyVVJMOiBVUkwsIHNlcnZlclNpZGVFdmVudHM/OiBJc1N1YnNjcmliYWJsZSkge1xuICAgIHRoaXMuc2VydmVyVVJMID0gc2VydmVyVVJMO1xuICAgIHRoaXMuYWN0b3JJZCA9IHV1aWQoKTtcbiAgICB0aGlzLmNsaWVudElkID0gdXVpZCgpO1xuICAgIHRoaXMuc2VydmVyU2lkZUV2ZW50cyA9IHNlcnZlclNpZGVFdmVudHMgfHwgbmV3IFNlcnZlclNpZGVFdmVudHMoKTtcbiAgICB0aGlzLkF0dHJpYnV0ZSA9IG5ldyBBdHRyaWJ1dGVzUmVwb3NpdG9yeSh0aGlzLCB0aGlzLnNlcnZlclNpZGVFdmVudHMpO1xuICAgIHRoaXMuRmFjdCA9IG5ldyBGYWN0c1JlcG9zaXRvcnkodGhpcyk7XG4gIH1cbn1cbiIsIi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tY3ljbGVcbmltcG9ydCBMaW5rZWRSZWNvcmRzIGZyb20gJy4uLy4uL2Jyb3dzZXJfc2RrJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmFjdCB7XG4gIHNlcnZlclVSTDogVVJMO1xuXG4gIHN1YmplY3Q6IHN0cmluZztcblxuICBwcmVkaWNhdGU6IHN0cmluZztcblxuICBvYmplY3Q6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihsaW5rZWRSZWNvcmRzOiBMaW5rZWRSZWNvcmRzLCBzdWJqZWN0OiBzdHJpbmcsIHByZWRpY2F0ZTogc3RyaW5nLCBvYmplY3Q6IHN0cmluZykge1xuICAgIHRoaXMuc2VydmVyVVJMID0gbGlua2VkUmVjb3Jkcy5zZXJ2ZXJVUkw7XG4gICAgdGhpcy5zdWJqZWN0ID0gc3ViamVjdDtcbiAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcbiAgfVxuXG4gIGFzeW5jIHNhdmUoKSB7XG4gICAgYXdhaXQgZmV0Y2goYCR7dGhpcy5zZXJ2ZXJVUkx9ZmFjdHNgLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBzdWJqZWN0OiB0aGlzLnN1YmplY3QsXG4gICAgICAgIHByZWRpY2F0ZTogdGhpcy5wcmVkaWNhdGUsXG4gICAgICAgIG9iamVjdDogdGhpcy5vYmplY3QsXG4gICAgICB9KSxcbiAgICB9KTtcbiAgfVxufVxuIiwiZXhwb3J0IHsgZGVmYXVsdCBhcyB2MSB9IGZyb20gJy4vdjEuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2MyB9IGZyb20gJy4vdjMuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2NCB9IGZyb20gJy4vdjQuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2NSB9IGZyb20gJy4vdjUuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBOSUwgfSBmcm9tICcuL25pbC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24uanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2YWxpZGF0ZSB9IGZyb20gJy4vdmFsaWRhdGUuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBzdHJpbmdpZnkgfSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHBhcnNlIH0gZnJvbSAnLi9wYXJzZS5qcyc7IiwiLypcbiAqIEJyb3dzZXItY29tcGF0aWJsZSBKYXZhU2NyaXB0IE1ENVxuICpcbiAqIE1vZGlmaWNhdGlvbiBvZiBKYXZhU2NyaXB0IE1ENVxuICogaHR0cHM6Ly9naXRodWIuY29tL2JsdWVpbXAvSmF2YVNjcmlwdC1NRDVcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSwgU2ViYXN0aWFuIFRzY2hhblxuICogaHR0cHM6Ly9ibHVlaW1wLm5ldFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKlxuICogQmFzZWQgb25cbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUlNBIERhdGEgU2VjdXJpdHksIEluYy4gTUQ1IE1lc3NhZ2VcbiAqIERpZ2VzdCBBbGdvcml0aG0sIGFzIGRlZmluZWQgaW4gUkZDIDEzMjEuXG4gKiBWZXJzaW9uIDIuMiBDb3B5cmlnaHQgKEMpIFBhdWwgSm9obnN0b24gMTk5OSAtIDIwMDlcbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZVxuICogU2VlIGh0dHA6Ly9wYWpob21lLm9yZy51ay9jcnlwdC9tZDUgZm9yIG1vcmUgaW5mby5cbiAqL1xuZnVuY3Rpb24gbWQ1KGJ5dGVzKSB7XG4gIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIG1zZyA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChieXRlcykpOyAvLyBVVEY4IGVzY2FwZVxuXG4gICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShtc2cubGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgKytpKSB7XG4gICAgICBieXRlc1tpXSA9IG1zZy5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtZDVUb0hleEVuY29kZWRBcnJheSh3b3Jkc1RvTWQ1KGJ5dGVzVG9Xb3JkcyhieXRlcyksIGJ5dGVzLmxlbmd0aCAqIDgpKTtcbn1cbi8qXG4gKiBDb252ZXJ0IGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHMgdG8gYW4gYXJyYXkgb2YgYnl0ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIG1kNVRvSGV4RW5jb2RlZEFycmF5KGlucHV0KSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgdmFyIGxlbmd0aDMyID0gaW5wdXQubGVuZ3RoICogMzI7XG4gIHZhciBoZXhUYWIgPSAnMDEyMzQ1Njc4OWFiY2RlZic7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGgzMjsgaSArPSA4KSB7XG4gICAgdmFyIHggPSBpbnB1dFtpID4+IDVdID4+PiBpICUgMzIgJiAweGZmO1xuICAgIHZhciBoZXggPSBwYXJzZUludChoZXhUYWIuY2hhckF0KHggPj4+IDQgJiAweDBmKSArIGhleFRhYi5jaGFyQXQoeCAmIDB4MGYpLCAxNik7XG4gICAgb3V0cHV0LnB1c2goaGV4KTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG4vKipcbiAqIENhbGN1bGF0ZSBvdXRwdXQgbGVuZ3RoIHdpdGggcGFkZGluZyBhbmQgYml0IGxlbmd0aFxuICovXG5cblxuZnVuY3Rpb24gZ2V0T3V0cHV0TGVuZ3RoKGlucHV0TGVuZ3RoOCkge1xuICByZXR1cm4gKGlucHV0TGVuZ3RoOCArIDY0ID4+PiA5IDw8IDQpICsgMTQgKyAxO1xufVxuLypcbiAqIENhbGN1bGF0ZSB0aGUgTUQ1IG9mIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHMsIGFuZCBhIGJpdCBsZW5ndGguXG4gKi9cblxuXG5mdW5jdGlvbiB3b3Jkc1RvTWQ1KHgsIGxlbikge1xuICAvKiBhcHBlbmQgcGFkZGluZyAqL1xuICB4W2xlbiA+PiA1XSB8PSAweDgwIDw8IGxlbiAlIDMyO1xuICB4W2dldE91dHB1dExlbmd0aChsZW4pIC0gMV0gPSBsZW47XG4gIHZhciBhID0gMTczMjU4NDE5MztcbiAgdmFyIGIgPSAtMjcxNzMzODc5O1xuICB2YXIgYyA9IC0xNzMyNTg0MTk0O1xuICB2YXIgZCA9IDI3MTczMzg3ODtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgdmFyIG9sZGEgPSBhO1xuICAgIHZhciBvbGRiID0gYjtcbiAgICB2YXIgb2xkYyA9IGM7XG4gICAgdmFyIG9sZGQgPSBkO1xuICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2ldLCA3LCAtNjgwODc2OTM2KTtcbiAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgMV0sIDEyLCAtMzg5NTY0NTg2KTtcbiAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgMl0sIDE3LCA2MDYxMDU4MTkpO1xuICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyAzXSwgMjIsIC0xMDQ0NTI1MzMwKTtcbiAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpICsgNF0sIDcsIC0xNzY0MTg4OTcpO1xuICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyA1XSwgMTIsIDEyMDAwODA0MjYpO1xuICAgIGMgPSBtZDVmZihjLCBkLCBhLCBiLCB4W2kgKyA2XSwgMTcsIC0xNDczMjMxMzQxKTtcbiAgICBiID0gbWQ1ZmYoYiwgYywgZCwgYSwgeFtpICsgN10sIDIyLCAtNDU3MDU5ODMpO1xuICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2kgKyA4XSwgNywgMTc3MDAzNTQxNik7XG4gICAgZCA9IG1kNWZmKGQsIGEsIGIsIGMsIHhbaSArIDldLCAxMiwgLTE5NTg0MTQ0MTcpO1xuICAgIGMgPSBtZDVmZihjLCBkLCBhLCBiLCB4W2kgKyAxMF0sIDE3LCAtNDIwNjMpO1xuICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyAxMV0sIDIyLCAtMTk5MDQwNDE2Mik7XG4gICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaSArIDEyXSwgNywgMTgwNDYwMzY4Mik7XG4gICAgZCA9IG1kNWZmKGQsIGEsIGIsIGMsIHhbaSArIDEzXSwgMTIsIC00MDM0MTEwMSk7XG4gICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDE0XSwgMTcsIC0xNTAyMDAyMjkwKTtcbiAgICBiID0gbWQ1ZmYoYiwgYywgZCwgYSwgeFtpICsgMTVdLCAyMiwgMTIzNjUzNTMyOSk7XG4gICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDFdLCA1LCAtMTY1Nzk2NTEwKTtcbiAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgNl0sIDksIC0xMDY5NTAxNjMyKTtcbiAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgMTFdLCAxNCwgNjQzNzE3NzEzKTtcbiAgICBiID0gbWQ1Z2coYiwgYywgZCwgYSwgeFtpXSwgMjAsIC0zNzM4OTczMDIpO1xuICAgIGEgPSBtZDVnZyhhLCBiLCBjLCBkLCB4W2kgKyA1XSwgNSwgLTcwMTU1ODY5MSk7XG4gICAgZCA9IG1kNWdnKGQsIGEsIGIsIGMsIHhbaSArIDEwXSwgOSwgMzgwMTYwODMpO1xuICAgIGMgPSBtZDVnZyhjLCBkLCBhLCBiLCB4W2kgKyAxNV0sIDE0LCAtNjYwNDc4MzM1KTtcbiAgICBiID0gbWQ1Z2coYiwgYywgZCwgYSwgeFtpICsgNF0sIDIwLCAtNDA1NTM3ODQ4KTtcbiAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgOV0sIDUsIDU2ODQ0NjQzOCk7XG4gICAgZCA9IG1kNWdnKGQsIGEsIGIsIGMsIHhbaSArIDE0XSwgOSwgLTEwMTk4MDM2OTApO1xuICAgIGMgPSBtZDVnZyhjLCBkLCBhLCBiLCB4W2kgKyAzXSwgMTQsIC0xODczNjM5NjEpO1xuICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2kgKyA4XSwgMjAsIDExNjM1MzE1MDEpO1xuICAgIGEgPSBtZDVnZyhhLCBiLCBjLCBkLCB4W2kgKyAxM10sIDUsIC0xNDQ0NjgxNDY3KTtcbiAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgMl0sIDksIC01MTQwMzc4NCk7XG4gICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDddLCAxNCwgMTczNTMyODQ3Myk7XG4gICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaSArIDEyXSwgMjAsIC0xOTI2NjA3NzM0KTtcbiAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgNV0sIDQsIC0zNzg1NTgpO1xuICAgIGQgPSBtZDVoaChkLCBhLCBiLCBjLCB4W2kgKyA4XSwgMTEsIC0yMDIyNTc0NDYzKTtcbiAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgMTFdLCAxNiwgMTgzOTAzMDU2Mik7XG4gICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDE0XSwgMjMsIC0zNTMwOTU1Nik7XG4gICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDFdLCA0LCAtMTUzMDk5MjA2MCk7XG4gICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaSArIDRdLCAxMSwgMTI3Mjg5MzM1Myk7XG4gICAgYyA9IG1kNWhoKGMsIGQsIGEsIGIsIHhbaSArIDddLCAxNiwgLTE1NTQ5NzYzMik7XG4gICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDEwXSwgMjMsIC0xMDk0NzMwNjQwKTtcbiAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgMTNdLCA0LCA2ODEyNzkxNzQpO1xuICAgIGQgPSBtZDVoaChkLCBhLCBiLCBjLCB4W2ldLCAxMSwgLTM1ODUzNzIyMik7XG4gICAgYyA9IG1kNWhoKGMsIGQsIGEsIGIsIHhbaSArIDNdLCAxNiwgLTcyMjUyMTk3OSk7XG4gICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDZdLCAyMywgNzYwMjkxODkpO1xuICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyA5XSwgNCwgLTY0MDM2NDQ4Nyk7XG4gICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaSArIDEyXSwgMTEsIC00MjE4MTU4MzUpO1xuICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyAxNV0sIDE2LCA1MzA3NDI1MjApO1xuICAgIGIgPSBtZDVoaChiLCBjLCBkLCBhLCB4W2kgKyAyXSwgMjMsIC05OTUzMzg2NTEpO1xuICAgIGEgPSBtZDVpaShhLCBiLCBjLCBkLCB4W2ldLCA2LCAtMTk4NjMwODQ0KTtcbiAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgN10sIDEwLCAxMTI2ODkxNDE1KTtcbiAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgMTRdLCAxNSwgLTE0MTYzNTQ5MDUpO1xuICAgIGIgPSBtZDVpaShiLCBjLCBkLCBhLCB4W2kgKyA1XSwgMjEsIC01NzQzNDA1NSk7XG4gICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaSArIDEyXSwgNiwgMTcwMDQ4NTU3MSk7XG4gICAgZCA9IG1kNWlpKGQsIGEsIGIsIGMsIHhbaSArIDNdLCAxMCwgLTE4OTQ5ODY2MDYpO1xuICAgIGMgPSBtZDVpaShjLCBkLCBhLCBiLCB4W2kgKyAxMF0sIDE1LCAtMTA1MTUyMyk7XG4gICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDFdLCAyMSwgLTIwNTQ5MjI3OTkpO1xuICAgIGEgPSBtZDVpaShhLCBiLCBjLCBkLCB4W2kgKyA4XSwgNiwgMTg3MzMxMzM1OSk7XG4gICAgZCA9IG1kNWlpKGQsIGEsIGIsIGMsIHhbaSArIDE1XSwgMTAsIC0zMDYxMTc0NCk7XG4gICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDZdLCAxNSwgLTE1NjAxOTgzODApO1xuICAgIGIgPSBtZDVpaShiLCBjLCBkLCBhLCB4W2kgKyAxM10sIDIxLCAxMzA5MTUxNjQ5KTtcbiAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpICsgNF0sIDYsIC0xNDU1MjMwNzApO1xuICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyAxMV0sIDEwLCAtMTEyMDIxMDM3OSk7XG4gICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDJdLCAxNSwgNzE4Nzg3MjU5KTtcbiAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgOV0sIDIxLCAtMzQzNDg1NTUxKTtcbiAgICBhID0gc2FmZUFkZChhLCBvbGRhKTtcbiAgICBiID0gc2FmZUFkZChiLCBvbGRiKTtcbiAgICBjID0gc2FmZUFkZChjLCBvbGRjKTtcbiAgICBkID0gc2FmZUFkZChkLCBvbGRkKTtcbiAgfVxuXG4gIHJldHVybiBbYSwgYiwgYywgZF07XG59XG4vKlxuICogQ29udmVydCBhbiBhcnJheSBieXRlcyB0byBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzXG4gKiBDaGFyYWN0ZXJzID4yNTUgaGF2ZSB0aGVpciBoaWdoLWJ5dGUgc2lsZW50bHkgaWdub3JlZC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGJ5dGVzVG9Xb3JkcyhpbnB1dCkge1xuICBpZiAoaW5wdXQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIGxlbmd0aDggPSBpbnB1dC5sZW5ndGggKiA4O1xuICB2YXIgb3V0cHV0ID0gbmV3IFVpbnQzMkFycmF5KGdldE91dHB1dExlbmd0aChsZW5ndGg4KSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg4OyBpICs9IDgpIHtcbiAgICBvdXRwdXRbaSA+PiA1XSB8PSAoaW5wdXRbaSAvIDhdICYgMHhmZikgPDwgaSAlIDMyO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cbi8qXG4gKiBBZGQgaW50ZWdlcnMsIHdyYXBwaW5nIGF0IDJeMzIuIFRoaXMgdXNlcyAxNi1iaXQgb3BlcmF0aW9ucyBpbnRlcm5hbGx5XG4gKiB0byB3b3JrIGFyb3VuZCBidWdzIGluIHNvbWUgSlMgaW50ZXJwcmV0ZXJzLlxuICovXG5cblxuZnVuY3Rpb24gc2FmZUFkZCh4LCB5KSB7XG4gIHZhciBsc3cgPSAoeCAmIDB4ZmZmZikgKyAoeSAmIDB4ZmZmZik7XG4gIHZhciBtc3cgPSAoeCA+PiAxNikgKyAoeSA+PiAxNikgKyAobHN3ID4+IDE2KTtcbiAgcmV0dXJuIG1zdyA8PCAxNiB8IGxzdyAmIDB4ZmZmZjtcbn1cbi8qXG4gKiBCaXR3aXNlIHJvdGF0ZSBhIDMyLWJpdCBudW1iZXIgdG8gdGhlIGxlZnQuXG4gKi9cblxuXG5mdW5jdGlvbiBiaXRSb3RhdGVMZWZ0KG51bSwgY250KSB7XG4gIHJldHVybiBudW0gPDwgY250IHwgbnVtID4+PiAzMiAtIGNudDtcbn1cbi8qXG4gKiBUaGVzZSBmdW5jdGlvbnMgaW1wbGVtZW50IHRoZSBmb3VyIGJhc2ljIG9wZXJhdGlvbnMgdGhlIGFsZ29yaXRobSB1c2VzLlxuICovXG5cblxuZnVuY3Rpb24gbWQ1Y21uKHEsIGEsIGIsIHgsIHMsIHQpIHtcbiAgcmV0dXJuIHNhZmVBZGQoYml0Um90YXRlTGVmdChzYWZlQWRkKHNhZmVBZGQoYSwgcSksIHNhZmVBZGQoeCwgdCkpLCBzKSwgYik7XG59XG5cbmZ1bmN0aW9uIG1kNWZmKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgcmV0dXJuIG1kNWNtbihiICYgYyB8IH5iICYgZCwgYSwgYiwgeCwgcywgdCk7XG59XG5cbmZ1bmN0aW9uIG1kNWdnKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgcmV0dXJuIG1kNWNtbihiICYgZCB8IGMgJiB+ZCwgYSwgYiwgeCwgcywgdCk7XG59XG5cbmZ1bmN0aW9uIG1kNWhoKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgcmV0dXJuIG1kNWNtbihiIF4gYyBeIGQsIGEsIGIsIHgsIHMsIHQpO1xufVxuXG5mdW5jdGlvbiBtZDVpaShhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVjbW4oYyBeIChiIHwgfmQpLCBhLCBiLCB4LCBzLCB0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWQ1OyIsImV4cG9ydCBkZWZhdWx0ICcwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDAnOyIsImltcG9ydCB2YWxpZGF0ZSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcblxuZnVuY3Rpb24gcGFyc2UodXVpZCkge1xuICBpZiAoIXZhbGlkYXRlKHV1aWQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdJbnZhbGlkIFVVSUQnKTtcbiAgfVxuXG4gIHZhciB2O1xuICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMTYpOyAvLyBQYXJzZSAjIyMjIyMjIy0uLi4uLS4uLi4tLi4uLi0uLi4uLi4uLi4uLi5cblxuICBhcnJbMF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMCwgOCksIDE2KSkgPj4+IDI0O1xuICBhcnJbMV0gPSB2ID4+PiAxNiAmIDB4ZmY7XG4gIGFyclsyXSA9IHYgPj4+IDggJiAweGZmO1xuICBhcnJbM10gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tIyMjIy0uLi4uLS4uLi4tLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzRdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDksIDEzKSwgMTYpKSA+Pj4gODtcbiAgYXJyWzVdID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tIyMjIy0uLi4uLS4uLi4uLi4uLi4uLlxuXG4gIGFycls2XSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgxNCwgMTgpLCAxNikpID4+PiA4O1xuICBhcnJbN10gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tLi4uLi0uLi4uLSMjIyMtLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzhdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDE5LCAyMyksIDE2KSkgPj4+IDg7XG4gIGFycls5XSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0uLi4uLS4uLi4tLi4uLi0jIyMjIyMjIyMjIyNcbiAgLy8gKFVzZSBcIi9cIiB0byBhdm9pZCAzMi1iaXQgdHJ1bmNhdGlvbiB3aGVuIGJpdC1zaGlmdGluZyBoaWdoLW9yZGVyIGJ5dGVzKVxuXG4gIGFyclsxMF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMjQsIDM2KSwgMTYpKSAvIDB4MTAwMDAwMDAwMDAgJiAweGZmO1xuICBhcnJbMTFdID0gdiAvIDB4MTAwMDAwMDAwICYgMHhmZjtcbiAgYXJyWzEyXSA9IHYgPj4+IDI0ICYgMHhmZjtcbiAgYXJyWzEzXSA9IHYgPj4+IDE2ICYgMHhmZjtcbiAgYXJyWzE0XSA9IHYgPj4+IDggJiAweGZmO1xuICBhcnJbMTVdID0gdiAmIDB4ZmY7XG4gIHJldHVybiBhcnI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHBhcnNlOyIsImV4cG9ydCBkZWZhdWx0IC9eKD86WzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzEtNV1bMC05YS1mXXszfS1bODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwKSQvaTsiLCIvLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiBJbiB0aGUgYnJvd3NlciB3ZSB0aGVyZWZvcmVcbi8vIHJlcXVpcmUgdGhlIGNyeXB0byBBUEkgYW5kIGRvIG5vdCBzdXBwb3J0IGJ1aWx0LWluIGZhbGxiYWNrIHRvIGxvd2VyIHF1YWxpdHkgcmFuZG9tIG51bWJlclxuLy8gZ2VuZXJhdG9ycyAobGlrZSBNYXRoLnJhbmRvbSgpKS5cbnZhciBnZXRSYW5kb21WYWx1ZXM7XG52YXIgcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBybmcoKSB7XG4gIC8vIGxhenkgbG9hZCBzbyB0aGF0IGVudmlyb25tZW50cyB0aGF0IG5lZWQgdG8gcG9seWZpbGwgaGF2ZSBhIGNoYW5jZSB0byBkbyBzb1xuICBpZiAoIWdldFJhbmRvbVZhbHVlcykge1xuICAgIC8vIGdldFJhbmRvbVZhbHVlcyBuZWVkcyB0byBiZSBpbnZva2VkIGluIGEgY29udGV4dCB3aGVyZSBcInRoaXNcIiBpcyBhIENyeXB0byBpbXBsZW1lbnRhdGlvbi4gQWxzbyxcbiAgICAvLyBmaW5kIHRoZSBjb21wbGV0ZSBpbXBsZW1lbnRhdGlvbiBvZiBjcnlwdG8gKG1zQ3J5cHRvKSBvbiBJRTExLlxuICAgIGdldFJhbmRvbVZhbHVlcyA9IHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKGNyeXB0bykgfHwgdHlwZW9mIG1zQ3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nICYmIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKG1zQ3J5cHRvKTtcblxuICAgIGlmICghZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMoKSBub3Qgc3VwcG9ydGVkLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkI2dldHJhbmRvbXZhbHVlcy1ub3Qtc3VwcG9ydGVkJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGdldFJhbmRvbVZhbHVlcyhybmRzOCk7XG59IiwiLy8gQWRhcHRlZCBmcm9tIENocmlzIFZlbmVzcycgU0hBMSBjb2RlIGF0XG4vLyBodHRwOi8vd3d3Lm1vdmFibGUtdHlwZS5jby51ay9zY3JpcHRzL3NoYTEuaHRtbFxuZnVuY3Rpb24gZihzLCB4LCB5LCB6KSB7XG4gIHN3aXRjaCAocykge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiB4ICYgeSBeIH54ICYgejtcblxuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiB4IF4geSBeIHo7XG5cbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4geCAmIHkgXiB4ICYgeiBeIHkgJiB6O1xuXG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIHggXiB5IF4gejtcbiAgfVxufVxuXG5mdW5jdGlvbiBST1RMKHgsIG4pIHtcbiAgcmV0dXJuIHggPDwgbiB8IHggPj4+IDMyIC0gbjtcbn1cblxuZnVuY3Rpb24gc2hhMShieXRlcykge1xuICB2YXIgSyA9IFsweDVhODI3OTk5LCAweDZlZDllYmExLCAweDhmMWJiY2RjLCAweGNhNjJjMWQ2XTtcbiAgdmFyIEggPSBbMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSwgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3NiwgMHhjM2QyZTFmMF07XG5cbiAgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgbXNnID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGJ5dGVzKSk7IC8vIFVURjggZXNjYXBlXG5cbiAgICBieXRlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyArK2kpIHtcbiAgICAgIGJ5dGVzLnB1c2gobXNnLmNoYXJDb2RlQXQoaSkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShieXRlcykpIHtcbiAgICAvLyBDb252ZXJ0IEFycmF5LWxpa2UgdG8gQXJyYXlcbiAgICBieXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGJ5dGVzKTtcbiAgfVxuXG4gIGJ5dGVzLnB1c2goMHg4MCk7XG4gIHZhciBsID0gYnl0ZXMubGVuZ3RoIC8gNCArIDI7XG4gIHZhciBOID0gTWF0aC5jZWlsKGwgLyAxNik7XG4gIHZhciBNID0gbmV3IEFycmF5KE4pO1xuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBOOyArK19pKSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50MzJBcnJheSgxNik7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IDE2OyArK2opIHtcbiAgICAgIGFycltqXSA9IGJ5dGVzW19pICogNjQgKyBqICogNF0gPDwgMjQgfCBieXRlc1tfaSAqIDY0ICsgaiAqIDQgKyAxXSA8PCAxNiB8IGJ5dGVzW19pICogNjQgKyBqICogNCArIDJdIDw8IDggfCBieXRlc1tfaSAqIDY0ICsgaiAqIDQgKyAzXTtcbiAgICB9XG5cbiAgICBNW19pXSA9IGFycjtcbiAgfVxuXG4gIE1bTiAtIDFdWzE0XSA9IChieXRlcy5sZW5ndGggLSAxKSAqIDggLyBNYXRoLnBvdygyLCAzMik7XG4gIE1bTiAtIDFdWzE0XSA9IE1hdGguZmxvb3IoTVtOIC0gMV1bMTRdKTtcbiAgTVtOIC0gMV1bMTVdID0gKGJ5dGVzLmxlbmd0aCAtIDEpICogOCAmIDB4ZmZmZmZmZmY7XG5cbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgTjsgKytfaTIpIHtcbiAgICB2YXIgVyA9IG5ldyBVaW50MzJBcnJheSg4MCk7XG5cbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IDE2OyArK3QpIHtcbiAgICAgIFdbdF0gPSBNW19pMl1bdF07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX3QgPSAxNjsgX3QgPCA4MDsgKytfdCkge1xuICAgICAgV1tfdF0gPSBST1RMKFdbX3QgLSAzXSBeIFdbX3QgLSA4XSBeIFdbX3QgLSAxNF0gXiBXW190IC0gMTZdLCAxKTtcbiAgICB9XG5cbiAgICB2YXIgYSA9IEhbMF07XG4gICAgdmFyIGIgPSBIWzFdO1xuICAgIHZhciBjID0gSFsyXTtcbiAgICB2YXIgZCA9IEhbM107XG4gICAgdmFyIGUgPSBIWzRdO1xuXG4gICAgZm9yICh2YXIgX3QyID0gMDsgX3QyIDwgODA7ICsrX3QyKSB7XG4gICAgICB2YXIgcyA9IE1hdGguZmxvb3IoX3QyIC8gMjApO1xuICAgICAgdmFyIFQgPSBST1RMKGEsIDUpICsgZihzLCBiLCBjLCBkKSArIGUgKyBLW3NdICsgV1tfdDJdID4+PiAwO1xuICAgICAgZSA9IGQ7XG4gICAgICBkID0gYztcbiAgICAgIGMgPSBST1RMKGIsIDMwKSA+Pj4gMDtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IFQ7XG4gICAgfVxuXG4gICAgSFswXSA9IEhbMF0gKyBhID4+PiAwO1xuICAgIEhbMV0gPSBIWzFdICsgYiA+Pj4gMDtcbiAgICBIWzJdID0gSFsyXSArIGMgPj4+IDA7XG4gICAgSFszXSA9IEhbM10gKyBkID4+PiAwO1xuICAgIEhbNF0gPSBIWzRdICsgZSA+Pj4gMDtcbiAgfVxuXG4gIHJldHVybiBbSFswXSA+PiAyNCAmIDB4ZmYsIEhbMF0gPj4gMTYgJiAweGZmLCBIWzBdID4+IDggJiAweGZmLCBIWzBdICYgMHhmZiwgSFsxXSA+PiAyNCAmIDB4ZmYsIEhbMV0gPj4gMTYgJiAweGZmLCBIWzFdID4+IDggJiAweGZmLCBIWzFdICYgMHhmZiwgSFsyXSA+PiAyNCAmIDB4ZmYsIEhbMl0gPj4gMTYgJiAweGZmLCBIWzJdID4+IDggJiAweGZmLCBIWzJdICYgMHhmZiwgSFszXSA+PiAyNCAmIDB4ZmYsIEhbM10gPj4gMTYgJiAweGZmLCBIWzNdID4+IDggJiAweGZmLCBIWzNdICYgMHhmZiwgSFs0XSA+PiAyNCAmIDB4ZmYsIEhbNF0gPj4gMTYgJiAweGZmLCBIWzRdID4+IDggJiAweGZmLCBIWzRdICYgMHhmZl07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNoYTE7IiwiaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4vdmFsaWRhdGUuanMnO1xuLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG5cbnZhciBieXRlVG9IZXggPSBbXTtcblxuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXgucHVzaCgoaSArIDB4MTAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpKTtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5KGFycikge1xuICB2YXIgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAvLyBOb3RlOiBCZSBjYXJlZnVsIGVkaXRpbmcgdGhpcyBjb2RlISAgSXQncyBiZWVuIHR1bmVkIGZvciBwZXJmb3JtYW5jZVxuICAvLyBhbmQgd29ya3MgaW4gd2F5cyB5b3UgbWF5IG5vdCBleHBlY3QuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQvcHVsbC80MzRcbiAgdmFyIHV1aWQgPSAoYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAzXV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA2XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDddXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA5XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDExXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEzXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE1XV0pLnRvTG93ZXJDYXNlKCk7IC8vIENvbnNpc3RlbmN5IGNoZWNrIGZvciB2YWxpZCBVVUlELiAgSWYgdGhpcyB0aHJvd3MsIGl0J3MgbGlrZWx5IGR1ZSB0byBvbmVcbiAgLy8gb2YgdGhlIGZvbGxvd2luZzpcbiAgLy8gLSBPbmUgb3IgbW9yZSBpbnB1dCBhcnJheSB2YWx1ZXMgZG9uJ3QgbWFwIHRvIGEgaGV4IG9jdGV0IChsZWFkaW5nIHRvXG4gIC8vIFwidW5kZWZpbmVkXCIgaW4gdGhlIHV1aWQpXG4gIC8vIC0gSW52YWxpZCBpbnB1dCB2YWx1ZXMgZm9yIHRoZSBSRkMgYHZlcnNpb25gIG9yIGB2YXJpYW50YCBmaWVsZHNcblxuICBpZiAoIXZhbGlkYXRlKHV1aWQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdTdHJpbmdpZmllZCBVVUlEIGlzIGludmFsaWQnKTtcbiAgfVxuXG4gIHJldHVybiB1dWlkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHJpbmdpZnk7IiwiaW1wb3J0IHJuZyBmcm9tICcuL3JuZy5qcyc7XG5pbXBvcnQgc3RyaW5naWZ5IGZyb20gJy4vc3RyaW5naWZ5LmpzJzsgLy8gKipgdjEoKWAgLSBHZW5lcmF0ZSB0aW1lLWJhc2VkIFVVSUQqKlxuLy9cbi8vIEluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9MaW9zSy9VVUlELmpzXG4vLyBhbmQgaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L3V1aWQuaHRtbFxuXG52YXIgX25vZGVJZDtcblxudmFyIF9jbG9ja3NlcTsgLy8gUHJldmlvdXMgdXVpZCBjcmVhdGlvbiB0aW1lXG5cblxudmFyIF9sYXN0TVNlY3MgPSAwO1xudmFyIF9sYXN0TlNlY3MgPSAwOyAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkIGZvciBBUEkgZGV0YWlsc1xuXG5mdW5jdGlvbiB2MShvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcbiAgdmFyIGIgPSBidWYgfHwgbmV3IEFycmF5KDE2KTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBub2RlID0gb3B0aW9ucy5ub2RlIHx8IF9ub2RlSWQ7XG4gIHZhciBjbG9ja3NlcSA9IG9wdGlvbnMuY2xvY2tzZXEgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2xvY2tzZXEgOiBfY2xvY2tzZXE7IC8vIG5vZGUgYW5kIGNsb2Nrc2VxIG5lZWQgdG8gYmUgaW5pdGlhbGl6ZWQgdG8gcmFuZG9tIHZhbHVlcyBpZiB0aGV5J3JlIG5vdFxuICAvLyBzcGVjaWZpZWQuICBXZSBkbyB0aGlzIGxhemlseSB0byBtaW5pbWl6ZSBpc3N1ZXMgcmVsYXRlZCB0byBpbnN1ZmZpY2llbnRcbiAgLy8gc3lzdGVtIGVudHJvcHkuICBTZWUgIzE4OVxuXG4gIGlmIChub2RlID09IG51bGwgfHwgY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgIHZhciBzZWVkQnl0ZXMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nKSgpO1xuXG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgLy8gUGVyIDQuNSwgY3JlYXRlIGFuZCA0OC1iaXQgbm9kZSBpZCwgKDQ3IHJhbmRvbSBiaXRzICsgbXVsdGljYXN0IGJpdCA9IDEpXG4gICAgICBub2RlID0gX25vZGVJZCA9IFtzZWVkQnl0ZXNbMF0gfCAweDAxLCBzZWVkQnl0ZXNbMV0sIHNlZWRCeXRlc1syXSwgc2VlZEJ5dGVzWzNdLCBzZWVkQnl0ZXNbNF0sIHNlZWRCeXRlc1s1XV07XG4gICAgfVxuXG4gICAgaWYgKGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjIuMiwgcmFuZG9taXplICgxNCBiaXQpIGNsb2Nrc2VxXG4gICAgICBjbG9ja3NlcSA9IF9jbG9ja3NlcSA9IChzZWVkQnl0ZXNbNl0gPDwgOCB8IHNlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG4gICAgfVxuICB9IC8vIFVVSUQgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXG4gIC8vICgxNTgyLTEwLTE1IDAwOjAwKS4gIEpTTnVtYmVycyBhcmVuJ3QgcHJlY2lzZSBlbm91Z2ggZm9yIHRoaXMsIHNvXG4gIC8vIHRpbWUgaXMgaGFuZGxlZCBpbnRlcm5hbGx5IGFzICdtc2VjcycgKGludGVnZXIgbWlsbGlzZWNvbmRzKSBhbmQgJ25zZWNzJ1xuICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxuXG5cbiAgdmFyIG1zZWNzID0gb3B0aW9ucy5tc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tc2VjcyA6IERhdGUubm93KCk7IC8vIFBlciA0LjIuMS4yLCB1c2UgY291bnQgb2YgdXVpZCdzIGdlbmVyYXRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgY2xvY2tcbiAgLy8gY3ljbGUgdG8gc2ltdWxhdGUgaGlnaGVyIHJlc29sdXRpb24gY2xvY2tcblxuICB2YXIgbnNlY3MgPSBvcHRpb25zLm5zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5zZWNzIDogX2xhc3ROU2VjcyArIDE7IC8vIFRpbWUgc2luY2UgbGFzdCB1dWlkIGNyZWF0aW9uIChpbiBtc2VjcylcblxuICB2YXIgZHQgPSBtc2VjcyAtIF9sYXN0TVNlY3MgKyAobnNlY3MgLSBfbGFzdE5TZWNzKSAvIDEwMDAwOyAvLyBQZXIgNC4yLjEuMiwgQnVtcCBjbG9ja3NlcSBvbiBjbG9jayByZWdyZXNzaW9uXG5cbiAgaWYgKGR0IDwgMCAmJiBvcHRpb25zLmNsb2Nrc2VxID09PSB1bmRlZmluZWQpIHtcbiAgICBjbG9ja3NlcSA9IGNsb2Nrc2VxICsgMSAmIDB4M2ZmZjtcbiAgfSAvLyBSZXNldCBuc2VjcyBpZiBjbG9jayByZWdyZXNzZXMgKG5ldyBjbG9ja3NlcSkgb3Igd2UndmUgbW92ZWQgb250byBhIG5ld1xuICAvLyB0aW1lIGludGVydmFsXG5cblxuICBpZiAoKGR0IDwgMCB8fCBtc2VjcyA+IF9sYXN0TVNlY3MpICYmIG9wdGlvbnMubnNlY3MgPT09IHVuZGVmaW5lZCkge1xuICAgIG5zZWNzID0gMDtcbiAgfSAvLyBQZXIgNC4yLjEuMiBUaHJvdyBlcnJvciBpZiB0b28gbWFueSB1dWlkcyBhcmUgcmVxdWVzdGVkXG5cblxuICBpZiAobnNlY3MgPj0gMTAwMDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1dWlkLnYxKCk6IENhbid0IGNyZWF0ZSBtb3JlIHRoYW4gMTBNIHV1aWRzL3NlY1wiKTtcbiAgfVxuXG4gIF9sYXN0TVNlY3MgPSBtc2VjcztcbiAgX2xhc3ROU2VjcyA9IG5zZWNzO1xuICBfY2xvY2tzZXEgPSBjbG9ja3NlcTsgLy8gUGVyIDQuMS40IC0gQ29udmVydCBmcm9tIHVuaXggZXBvY2ggdG8gR3JlZ29yaWFuIGVwb2NoXG5cbiAgbXNlY3MgKz0gMTIyMTkyOTI4MDAwMDA7IC8vIGB0aW1lX2xvd2BcblxuICB2YXIgdGwgPSAoKG1zZWNzICYgMHhmZmZmZmZmKSAqIDEwMDAwICsgbnNlY3MpICUgMHgxMDAwMDAwMDA7XG4gIGJbaSsrXSA9IHRsID4+PiAyNCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiAxNiAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdGwgJiAweGZmOyAvLyBgdGltZV9taWRgXG5cbiAgdmFyIHRtaCA9IG1zZWNzIC8gMHgxMDAwMDAwMDAgKiAxMDAwMCAmIDB4ZmZmZmZmZjtcbiAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdG1oICYgMHhmZjsgLy8gYHRpbWVfaGlnaF9hbmRfdmVyc2lvbmBcblxuICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG5cbiAgYltpKytdID0gdG1oID4+PiAxNiAmIDB4ZmY7IC8vIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYCAoUGVyIDQuMi4yIC0gaW5jbHVkZSB2YXJpYW50KVxuXG4gIGJbaSsrXSA9IGNsb2Nrc2VxID4+PiA4IHwgMHg4MDsgLy8gYGNsb2NrX3NlcV9sb3dgXG5cbiAgYltpKytdID0gY2xvY2tzZXEgJiAweGZmOyAvLyBgbm9kZWBcblxuICBmb3IgKHZhciBuID0gMDsgbiA8IDY7ICsrbikge1xuICAgIGJbaSArIG5dID0gbm9kZVtuXTtcbiAgfVxuXG4gIHJldHVybiBidWYgfHwgc3RyaW5naWZ5KGIpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2MTsiLCJpbXBvcnQgdjM1IGZyb20gJy4vdjM1LmpzJztcbmltcG9ydCBtZDUgZnJvbSAnLi9tZDUuanMnO1xudmFyIHYzID0gdjM1KCd2MycsIDB4MzAsIG1kNSk7XG5leHBvcnQgZGVmYXVsdCB2MzsiLCJpbXBvcnQgc3RyaW5naWZ5IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcbmltcG9ydCBwYXJzZSBmcm9tICcuL3BhcnNlLmpzJztcblxuZnVuY3Rpb24gc3RyaW5nVG9CeXRlcyhzdHIpIHtcbiAgc3RyID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpOyAvLyBVVEY4IGVzY2FwZVxuXG4gIHZhciBieXRlcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgYnl0ZXMucHVzaChzdHIuY2hhckNvZGVBdChpKSk7XG4gIH1cblxuICByZXR1cm4gYnl0ZXM7XG59XG5cbmV4cG9ydCB2YXIgRE5TID0gJzZiYTdiODEwLTlkYWQtMTFkMS04MGI0LTAwYzA0ZmQ0MzBjOCc7XG5leHBvcnQgdmFyIFVSTCA9ICc2YmE3YjgxMS05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzgnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKG5hbWUsIHZlcnNpb24sIGhhc2hmdW5jKSB7XG4gIGZ1bmN0aW9uIGdlbmVyYXRlVVVJRCh2YWx1ZSwgbmFtZXNwYWNlLCBidWYsIG9mZnNldCkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IHN0cmluZ1RvQnl0ZXModmFsdWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlID09PSAnc3RyaW5nJykge1xuICAgICAgbmFtZXNwYWNlID0gcGFyc2UobmFtZXNwYWNlKTtcbiAgICB9XG5cbiAgICBpZiAobmFtZXNwYWNlLmxlbmd0aCAhPT0gMTYpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignTmFtZXNwYWNlIG11c3QgYmUgYXJyYXktbGlrZSAoMTYgaXRlcmFibGUgaW50ZWdlciB2YWx1ZXMsIDAtMjU1KScpO1xuICAgIH0gLy8gQ29tcHV0ZSBoYXNoIG9mIG5hbWVzcGFjZSBhbmQgdmFsdWUsIFBlciA0LjNcbiAgICAvLyBGdXR1cmU6IFVzZSBzcHJlYWQgc3ludGF4IHdoZW4gc3VwcG9ydGVkIG9uIGFsbCBwbGF0Zm9ybXMsIGUuZy4gYGJ5dGVzID1cbiAgICAvLyBoYXNoZnVuYyhbLi4ubmFtZXNwYWNlLCAuLi4gdmFsdWVdKWBcblxuXG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoMTYgKyB2YWx1ZS5sZW5ndGgpO1xuICAgIGJ5dGVzLnNldChuYW1lc3BhY2UpO1xuICAgIGJ5dGVzLnNldCh2YWx1ZSwgbmFtZXNwYWNlLmxlbmd0aCk7XG4gICAgYnl0ZXMgPSBoYXNoZnVuYyhieXRlcyk7XG4gICAgYnl0ZXNbNl0gPSBieXRlc1s2XSAmIDB4MGYgfCB2ZXJzaW9uO1xuICAgIGJ5dGVzWzhdID0gYnl0ZXNbOF0gJiAweDNmIHwgMHg4MDtcblxuICAgIGlmIChidWYpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgICAgYnVmW29mZnNldCArIGldID0gYnl0ZXNbaV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBidWY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZ2lmeShieXRlcyk7XG4gIH0gLy8gRnVuY3Rpb24jbmFtZSBpcyBub3Qgc2V0dGFibGUgb24gc29tZSBwbGF0Zm9ybXMgKCMyNzApXG5cblxuICB0cnkge1xuICAgIGdlbmVyYXRlVVVJRC5uYW1lID0gbmFtZTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gIH0gY2F0Y2ggKGVycikge30gLy8gRm9yIENvbW1vbkpTIGRlZmF1bHQgZXhwb3J0IHN1cHBvcnRcblxuXG4gIGdlbmVyYXRlVVVJRC5ETlMgPSBETlM7XG4gIGdlbmVyYXRlVVVJRC5VUkwgPSBVUkw7XG4gIHJldHVybiBnZW5lcmF0ZVVVSUQ7XG59IiwiaW1wb3J0IHJuZyBmcm9tICcuL3JuZy5qcyc7XG5pbXBvcnQgc3RyaW5naWZ5IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcblxuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTsgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuXG4gIHJuZHNbNl0gPSBybmRzWzZdICYgMHgwZiB8IDB4NDA7XG4gIHJuZHNbOF0gPSBybmRzWzhdICYgMHgzZiB8IDB4ODA7IC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuXG4gIGlmIChidWYpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgYnVmW29mZnNldCArIGldID0gcm5kc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmO1xuICB9XG5cbiAgcmV0dXJuIHN0cmluZ2lmeShybmRzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdjQ7IiwiaW1wb3J0IHYzNSBmcm9tICcuL3YzNS5qcyc7XG5pbXBvcnQgc2hhMSBmcm9tICcuL3NoYTEuanMnO1xudmFyIHY1ID0gdjM1KCd2NScsIDB4NTAsIHNoYTEpO1xuZXhwb3J0IGRlZmF1bHQgdjU7IiwiaW1wb3J0IFJFR0VYIGZyb20gJy4vcmVnZXguanMnO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZSh1dWlkKSB7XG4gIHJldHVybiB0eXBlb2YgdXVpZCA9PT0gJ3N0cmluZycgJiYgUkVHRVgudGVzdCh1dWlkKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdmFsaWRhdGU7IiwiaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4vdmFsaWRhdGUuanMnO1xuXG5mdW5jdGlvbiB2ZXJzaW9uKHV1aWQpIHtcbiAgaWYgKCF2YWxpZGF0ZSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignSW52YWxpZCBVVUlEJyk7XG4gIH1cblxuICByZXR1cm4gcGFyc2VJbnQodXVpZC5zdWJzdHIoMTQsIDEpLCAxNik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZlcnNpb247IiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIiIsIi8vIHN0YXJ0dXBcbi8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLy8gVGhpcyBlbnRyeSBtb2R1bGUgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBtb2R1bGVzIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vZXhhbXBsZS9jbGllbnQvaW5kZXgudHNcIik7XG4iLCIiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=